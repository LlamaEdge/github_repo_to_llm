Path,Content
main/2023/CG-01-31.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 31st video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: January 31st, 5pm-6pm UTC (January 31st, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Extended const expressions: https://github.com/WebAssembly/extended-const [5 min]
        1. Poll to phase 4
    1. Relaxed SIMD, updates and phase 4 poll: https://github.com/WebAssembly/relaxed-simd [15 min]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
 - Sergey Rubanov
 - Kevin Moore
 - Kriztian Gacsal
 - Slava Kuzmich
 - Paolo Severini
 - Chris Fallin
 - Jeff Charles
 - Nick Fitzgerald
 - Sam Clegg
 - Philipe Le Hegaret
 - Kieth Winstein
 - Alex Crichton
 - Shravan Narayan 
 - Nabeel Al-Shamma
 - Alon Zakai
 - Conrad Watt
 - Yury Delendik
 - Luke Wagner
 - Zhi An Ng
 - Manos Koukoutos
 - Daniel Philips
 - Ilya Rezvov
 - Heejin Ahn
 - Thomas Lively
 - Ryan Hunt
 - Shravan Narayan
 - Mingqui Sun
 - Yuri Iozelli
 - Francis McCabe
 - Andreas Rossberg
 - Rick Battagline
 - Jakob Kummerow
 - Ashley Nelson
 - Benjamin Titzer
 - Brendan Dahl
 - Andrew Brown
 - Zalim Bashorov
 - Asumu Takikawa
 - Adam Klein
 - Marat Dhukan
 - Emanuel Ziegler
 - Petr Penzin
 - Shaoib Kamil

### Extended-const

SC: I haven’t fully resolved this issue before bringing it back to the CG. We did talk about it in the last in-person meeting and there’s been some discussion since then but I don’t think there is firm resolution on that. But if Ryan & Andreas are here, we can chat about it now. Otherwise, we can delay once again.

SC: Issue: Link Prefixing, Extended Const Expressions Right now we don’t have a link prefixing, and the result of that discussion is we wouldn’t want to put it on the individual expressions anyway but the overall global declaration instead.

RH: IIRC I couldn’t think of a great way to make this work well and I dno’t think it’s necessarily the biggest issue, so I’m fine just not changing the proposal for this and leaving it as-is

SC: I kind of agree, that was my gut feeling and the real complexity of these expressions is going to kick in with the GC proposal and we can look at adding it there. I did look at adding these length information to the globals themselves and we do have flags in both of those places. Like for globals we have the mutability flag, but adding this information there would ??. Possible to add more flags. And with the passives we have the active bitfield thing which is already overloaded and tricky to pass.

AR: I’m also fine with leaving it out, but I think we should then also be clear that we don’t want to introduce it later with GC expressions because if we do it at a random point with random expressions where some expressions can have them and some don’t then it gets hard. So we should decide that we want this and keep the set of special instructions that are const as small as possible, so the rule is simple, or just agree that we won’t introduce it later. But I don’t really see it as a necessity.

SC: Yeah I guess we could also make them optional as well if it’s just a tooling thing that makes object passing these things. We could make them never required and still introduce them.

AR: that’s an interesting idea

CW: Is the advantage of introducing them about complexity or speed? 

SC: yeah my original reason to raise this is that its nice for tools to do partial decoding, even if they don’t understand all the instructions they can still skip over the expressions

AR: Right now we have the section sizes so the only thing you can do is skip over the entire section.
SC: Yeah

AR: So the idea would be that we also have the segment sizes then. On the other hand, the other thing we discussed is allowing repeated sections in which case you can split every section with single segments. And then you can give every segment a size already.

SC: I'm a big fan of that proposal too. That would help LLVM a lot if we could have repeated code and data segments.

AR: Yeah

SC: I’m still a fan of closing this issue. 

BT: Personally I find the speed argument pretty compelling, because at least in my implementation the special const expressions are decoded initially. But I don’t want to add more to that special set, so it’s likely to turtle everything through the main decoder. So that would mean to parse the general initializer ??. So I think the speed argument is pretty solid.

RH: when are you evaluating these global initializers?

BT: it’s not about evaluation, it’s about parsing.

AR: The original idea was to hook it into the syntax of the constant expressions, that’s the only place we can do it in the global of the initializer. But we would have to do it for other initializers, and that would be a significant size overhead across the board. 

BT: Keep in mind it would only be necessary for extended constants so the constants we already have can stilll be the shorter form.

AR: but they all use the sae notion of constant, if you extend the notion of constant, you want to allow it everywhere

BT: Sure we can allow it but the existing forms would still be the same size.

RH: I think the issue is that if you have an element segment of anyref, then each of the indexes would have to be prefixed but you only care about skipping the segment as a whole. I’m still not quite clear with the speed argument with that. Why is it slower to do parsing of the general const expr? You'll still have to branch on the opcode

BT: Having a length allows you to skip forward, so you can skip over global declarations and get to what is after it more quickly and if you’re doing parallel compilation, you can get to the code or anything after these sections much faster.

CW: you can skip the whole section already, right?

AR: yeah I think we had this very discussion at the time where we nailed down the binary format originally, which I mentioned in the thread. At that time, we discussed whether constant expressions or global initializers should have a length prefix, I was actually the one who proposed it. And at that time there was a clear sentiment that this would not be useful for parallelizing. I’m not sure if that has changed, or we have evidence that has changed or what has changed your mind on that.

BT: at the time we hadn’t speced out anything with GC and extended object graphs, but we have that ability coming so they can be arbitrarily large. I get that you can skip the whole section to get to the code, but now each global can be arbitrarily large

SC: In your use case, why is it useful to skip the entire global section.

BT: it’s probably fine for now but it al depends on how modules end up in the wild. If they have dozens or hundreds of big globals, then it might make sense to parallelize compiling that

SC: I see, so you are compiling each of these initializers separately.

BT: Potentially, yes.

RH: I was thinking about this in the original issue because in some of the GC issues I’ve seen, they can have a large number of globals, 10K. If you’re emitting code or not doing an interpreter there is a bit of linearity needed because globals can refer to previous globals. So if I’m doing code that instantiates globals, the code has to be ordered to refer to previous things. SO it wasn’t clear there would be a win to generate the instantiation code or interpret it in parallel.

CW: my feeling is we should just give up on the idea of segment sizes and if it turns out we’ve made a mistake, we go in on repeated sections and have that be the mechanism we use to parallelize.

AR: that sounds fine to me although ryan has a point that i don’t think in practice it’s easy to parallelize global initializers, especially the complex ones where you need a dependency analysis

CW: I kind of agree but that’s just another reason to not add segment sizes right now.

BT: At the risk of going too deep on this, I think that global initialization that depends on another global initialization, you don't need to actually see the code for that global to initialize this global. The generated bodies are different enough. Or generate the boilerplate in V8, which is basically just an empty object with holes in it.

RH: for that you'd need the types of previous globals, so as you’re streaming you’d fill in the previous types…

BT: Generally it makes me a bit uncomfortable that modules in the hundreds of megabytes, already dozens of MBs now. And if dozens of that is data and it needs to be processed serially, that makes me nervous that we can’t parallelize this easily. That makes me feel better about having arbitrarily large things that can be skipped over.

RH: in the hypothetical future with repeated sections you coil have multiple global sections and within one you could refer to previous globals…. You could split it up to repeated sections. It does seem similar to <>

CW: Each section will have a length, so between the sections you’ll be able to get the parallelization you want. 

BT: yeah that puts the onus on the producer to split their modules up into different sections for parallel processing as opposed to being a property of the format that makes it possible for an engine or consumer to do it.

AR: Yeah but that becomes a quality of implementation question for the producers which seems fine to me. The producer can always create terrible, wasteful code without the consumer being able to do anything about it. But of course the producer should be interested in creating good code if they want customers. So the incentive should still be there.

TL: I could see implementing this in BInaryen,. If you measure this and could split your globals into sections, we’d do that.

SC: And bad producers can already produce giant functions that cannot be done in parallel. So I guess the alternative to repeated sections would be trying to shoehorn the size bit in the global type. Along with the mutability that we have today. Seems pretty gross.

AR: you’d need to put it in a few places, e.g. in globals where you’d probably have to put it in the type, and also for element segments. I’d expect you’d want it in both places.

DS: Ben, it seems like we almost have consensus, how hard do you want to dig in here? Should we punt this to offline or do you think that we’ve said as much as people want to say here?

BT: Given where we are, and how far this proposal has advanced, and that I’m not prepared to experiment, so we can just move this ahead. 

DS: Okay, let’s go ahead and do the poll. This will be a poll to essentially close Issue 9 and move Extended Const to Phase 4 in its current state as we discussed in the previous in-person meeting.

AR: Can you give us a summary of what is in the extension right now? I admit that I have lost track, I think we have discussed several possible instructions that could be included but I don’t know.

SC: In the beginning we had integer arithmetic and we toyed with the idea of adding other integer instructions like wrap and extend but we didn’t in the end because everyone had already added that base set and we were in a good place to ship something. So we just have integer arithmetic instructions.

AR: What about division?

TL: What are our two web implementations? 

SC: Firefox & Chrome definitely implement it, not sure about Safari, maybe done too. All the tools have an implementation

AR: I think division will come up naturally when you have to compute sizes of things from other values but we can of course add that laters.

SC: I can’t remember why I didn’t put it in the original set.

CW: This doesn’t block phase 4, do we have implementation specific limits, we had discussed that in the meeting. (https://webassembly.github.io/spec/js-api/index.html#limits)

SC: We don't have anything in the limits yet.

CW: I think we should do that at some point just so there is no divergence there.

SC: Are whose limits in the core spec?

CW: Either in the JS or web API

DS: I think in the web api

AR: So the core spec should mention the limitations.

CW: I vaguely remember that during the in-person meeting, Thomas mentioned that V8’s limits for stack size when evaluating const expressions are different (smaller) than for function bodies

BT: there isn’t a limit for the operand stack for functions but the function size implicitly limits it. It’s pretty big. It might be good to limit the stack for functions too, because it's like 7B so we could probably make that smaller.

SC: Is there any reason not to use the same limits for constant expressions?

CW: You may want a simple expression if I’m remembering what Thomas said correctly.

AR: I don’t really see operations on operand stack?

DS: That makes sense, we want to generalize it but that doesn’t block Phase 4. 

**POLL**
|SF|F|N|A|SA|
|--|-|-|-|--|
|6|25|2|0|0|

### Relaxed SIMD

ZN: Presenting [slides](https://docs.google.com/presentation/d/1xlyO1ly2Fbo2Up5ZuV_BTSwiNpCwPygag09XQRjclSA/edit?usp=sharing)

FM: can you explain why you went with option 2 rather than option 1?

ZN: Initially we had an instruction that didn’t have an obviously correct deterministic lowering, fp16 dot product, and was implemented in many different ways across architectures and even different versions of architecture. So because it didn’t have any obviously correct deterministic semantics, we’d have to remove it entirely. But it seemed ad hoc to remove just that one and keep the others like min and max. So we decided maybe to just remove all the instructions. Buf if you do that, one issue could be binary issues where you need 2 different versions of your modules, one with the instructions removed and one with them remaining. But all spec compliant implementations would have to be able to understand them but they might implement them in a different way.

FM: If you’re a producer, you basically have to assume relaxed semantics?

ZN: So relaxed semantics will be an opt-in flag when you generate your module. A flag you pass that says I want to be able to use the relaxed semantics together with the intrinsics. 

CW: we did actually have some discussions about this
 before. Francis you’re basically right, it would be a hazard if we allowed people to target the deterministic semantics in a nondeterministic …. All producers would have to target the relaxed semantics. 
So, what is the benefit of any implementer advertising that they implement the deterministic semantics if all producers have to assume the nondeterministic?

LW: Sorry was that a question you were asking to the group?

CW: I don’t think this needs to stop the phase 4 vote, because said we could work out the profiles later.

LW: The value in implementing deterministic profile is, you want determinism but also be able to run as much code as I can, because if I can't run the code that creates friction.

CW: Why do you need support from the spec to do that?

LW: Because you don’t want different platforms doing determinism differently

CW: But the producer has to assume that already when they are generating the wasm module, They can’t rely on the platform doing anything.

LW: yeah it would be a benefit among the different deterministic execution environments

CW: But which code would they be running that would see this benefit.

LW: it’s not the code, its the people running it. It will run the same way on different platforms

TL: For example, I suppose they could use each other as fuzzing oracles if they want that same determinism.

LW: when we do determinism we all do it this way regardless of how. When you have determinism, you want it to be the same everywhere.

CW: What is not clear in my head is who is the “you” that wants determinism. Because it seems it’s not the author of the code.

LW: not the author of the code, it’s someone else who is consuming that code or an operator of a bunch of different code, or the owner of the platform. The code is a black box here.

PP: I skipped the last SIMD meeting because I was out. Are we asking, How do we tell if a module is deterministic? That’s part of the point. Or in general do we assume all producers are? There should be a way to determine if the module is deterministic.

LW: I think what Conrad is saying is when you’re producing a module, if you emit a relaxed instruction you have to assume it's fully nondeterministic, you can’t assume the deterministic semantics. But when you implement it, you have the choice and can select just one subset of the allowed executions

TL: I suppose if the code author wants determinism they target the existing proposal which is deterministic.

AR: Here's a use case: imagine you want to build a platform that has to run deterministically because it uses consensus, but wants to support as much of the instruction set as possible. Plus it's distributed and has different clients, it wants to be able to switch between engines, so it depends on deterministic mode being the same everywhere.

CW: So Dan does have his hand up and I want to hear from him because he’s been one of the key people in this discussion.

DanG: It’s not a question of whether the producers can assume anything …. It’s about FMA, so i’ll punt it until after were’ done with this part of the discussion

CW: I would think it reasonable to say that we can have modules with relaxed simd instructions

Know who talked here? : Determinism is going to be a mainstream thing I think

BT: are any of the deterministic semantics so slow that we don’t expect a high perf implementation will choose that?

KW: I’m a bit nervous to see the cost of implementing deterministic semantics of NaN. It’s scary if every floating point instruction has to be wrapped with an isnan. It could be quite costly.

AR: often you can optimize that, you only need to normalize nans when they become observable, when you return them or write them to memory.

KW: But with exported memory, that could be anything.

AR: Usually with float operations you do multiple operations and the nan flows through them. So you only have to normalize at the end, not at every step. Usually the engine or compiler can figure out where it has to do that and can minimize where it has to do that.

DeG: if you do have these full semantics, are there environments that care about performance at the same time. If you have these and want to be able to run them, do you care about the performance of these at the same time? 

BT: One of the things Dan brought up at the in-person meeting is we should try to converge on one thing at the end. Hardware diverges right now but eventually they may converge and we would want to move towards them. Is the deterministic semantics, they all have SIMD lowering, are any of them seemingly inefficient now?

PP: they are pretty obscenely inefficient, with the NaNs

ZN: Ignoring NaNs, only the obscenely expensive one is Multiply-Add. It depends on the deterministic semantics, do we choose a fused multiply-add or choose just a multiply-add

PP: the expense is breaking it into parts and combining them back together

CW: I was going to say that my feelings are since determinism or relaxed is determined by the platform, so any platform that wants to advertise determinism and be fast needs to buy hardware where FMA is supported.

AR: I”m not sure platforms really want to advertise determinism as a feature, they might just have to do it out of necessity, it’s just an implementation constraint rather than  service to users. So they might not want to artificially restrict what they can run, or running it slow is better than not being able to run it at all. I don't know how realistic that is with relaxed SIMD; you wouldn’t generate this if you planned to run on a platform where you know it’s going to be slow. I”m a bit on the fence here.

MD: Getting back to the question of whether we are going to converge the semantics. We [removed?] bfloat16.dot product which is the least-convergent[?]

For FMA it son’ly older Intel CPUs that are missing this so we are converging. For integer dot product, newer ARM CPUs support the deterministic semantics, and Intel announced it fo rfuture CPUs that wil have this but no current hardware. So it looks like these will converge.

CW: I would say that we can’t ignore NaNs here. It doesn’t seem like Intel or ARM are going to converge on their NaN bits, so this will only ever be a best effort initiative. 

PP: the FMA is important, but kind of a special case in this proposal. It could be 2 different topics
For nans, the reason you’d want to be particular about the bits, e.g. if you ‘re writing a hash, you can detect that a single bit is different. The use cases for this are small and rare and exotic. I don’t know if we want’t get hung up.

ZN: Thomas hsa a good suggestion in chat. We do option 2, the multiple-add current semantics. And then when hardware catches up, we have a relaxed FMA. But the deterministic semantics would be a real FMA. 
Thomas’ note from chat: What if we make the deterministic semantics mul+add now, and once hardware all has compatible fast fma, we can add a new instruction with the same relaxed semantics but fused deterministic semantics.

CW: I would want to go further than what Thomas is saying, make all the semantics single precision if we believe all the hardware supports it.

DanG: I just wanted to advocate for making FMA be the deterministic semantics. Implementations that need this, if you really want this you can get it, and it’s not very extreme to have this FMA hardware these days.

PP: eventually we may even need both, algorithms may benefit from both because they don’t produce the same result. Manty systems that try to tackle this have both,. I wouldn’t want this question to hinder the progress. We can pick something and then pick something else or both later.

ZN: Presenting

So we want feedback on the deterministic semantics on relaxed madd. This is the only thing left blocking phase 4

CW: I would like to decouple that specific conversation from the phase 4 poll.

AR: i'm not sure that’s how we should use phase 4, 

DeG: I was going to suggest an alternative. The biggest open question is what deterministic semantics we want to pick. Lots of opinions that haven’t changed. So we can have a poll on what should be the deterministic semantics and then see if we have time for a phase 4 poll.

AR: IIRC the advantage fo the first one is aht it’s faster on a lot of future hardware, at the coast of being slower on hardware that doesn’t support it natively

DanG: It’s more costly on very low-end hardware today but basically faster on everything.

PP: Something about low end Intel machines

TL: Can we do a 3 stage poll because I would like to vote neutral on this.

NF<chat>: Sure, but floats ""escape"" at every return from an exported function, every reinterpret, and every store (whether the memory is exported or not)?

BT<chat>: In general, numerical algorithms that do a lot of matrix multiplication will have a lot read+arith+write, so I expect nan-checking overhead there will be proportionately more

DanG<chat>: I've benchmarked NaN canonicalization overhead; it's pretty regularly 5-15% in fp-intensive code.

BT<chat>: Just curious what the cheapest nan canonicalization insert sequence is?

TL<chat>: What if we make the deterministic semantics mul+add now, and once hardware all has compatible fast fma, we can add a new instruction with the same relaxed semantics but fused deterministic semantics.

ZA<chat>: good suggestion, i can be relaxed_fma

BT<chat>: That is just to avoid spec’ing slow on today’s hardware?

TL<chat>: correct

DanG<chat>: The NaN canonicalization sequence I used was just a compare+branch with a load from a constant pool

DanG: Also, ARM and RISC-V have modes which do the desired NaN semantics in hardware.
    
ZA: vote for det semantics for relaxed madd/nmadd:
1. (real) fma
2. mul + add (with intermediate rounding)
3. neutral

**POLL**

|FMA|Mul+Add|Neutral|
|---|--|--|
|15|2|16|

DeG: It seems like we have consensus we want the pure FMA to be the deterministic semantics. Do Peter or Ben want to say why they want to have mul + add.

BT: I will just mention that #2 is easier to implement in all hardware.

PP: I would say that it would not be too bad if we had both, but that is beyond the scope of this proposal I think.

DeG: We are two minutes over, so we can just comeback for a quick poll at the next CG meeting. I just want to forward Zhi & Marat as at the champions of this proposal. Is there anything else you want addressed Andreaas?

AR: I still have to review the actual spec, and that;’s on me. I’ll get to that this week. But it seems safe for voting next time. 

DeG: So we’ll schedule a quick 5 to 10 minutes in the next meeting for a phase 4 poll. Sounds good Zhi?

ZN: Sounds good, thanks for the time everyone.

### Closure
"
gc/2022/GC-08-23.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 23 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: August 23, 5pm-6pm UTC (August 23, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion and nonbinding poll: Type annotations ([#27](https://github.com/WebAssembly/function-references/issues/27))
        1. Nonbinding poll: We should remove type annotations from array and struct accessor instructions rather than add a type annotation to call_ref.
    3. _add items here_
1. Closure

## Meeting Notes

### Introduction of attendees

- Francis McCabe
- Ben Titzer
- Asumu Takikawa
- Justin Michaud
- Mathias Liedtke
- Zalim Bashorov
- Alon Zakai
- Ilya Rezvov
- Deepti Gandluri
- Andreas Rossberg
- Ashley Nelson
- Jakob Kummerow
- Aske Simon Christensen
- Conrad Watt
- Luke Wagner
- Rick
- Michael Knyzek
- Emanuel Ziegler

### Discussions

#### Type annotations ([#27](https://github.com/WebAssembly/function-references/issues/27))

AZ: There is a future type system feature that might need annotations, we probably need an example of a future type system that will not be solved by adding annotations later. I don’t think we’ve seen examples of that

AR: One thing to be clear about is that adding annotations later is not going to fit any problems that we run into later, we can’t retrofit the type annotations on existing instructions, completely depends on the nature of the problem we run into. In general I assume there are ways to work around them. In terms of an example, I can appreciate to see something concrete, I don’t think we have anything. One thing I also want to say is that for people who haven’t worked with advanced type systems, it’s very easy to run into problems that we don’t foresee. I don’t want to run this, either algorithmic complexity explodes, or we reach an unsolvable state, especially when we lead into type parameters. Either we have to cut/restrict features in that space, this is a warning I want to give as not an easy thing to decide. The main advantage to omitting is the size win

DG: Validation complexity?

AR: That was an assumption that was made, JK’s numbers didn’t show anything substantial in terms of complexity

BT: Type systems are fragile, and we don’t know yet what future extensions we want, and we don’t want to design things out by leaving them out. There are also other tools that process Wasm code, tools that want to inspect how fields of a struct are used, all those tools then have to reconstruct the type systems, and more inference is required, more likely that the tools will all have the burden that want to process the bytecode

AR: Some folks that do program analysis were really happy that they didn’t have to do type inference, otherwise you have to do non-local type reconstruction, it’s only simple when you’re looking at whole programs, some of them you’re looking at program fragments, we have to shuffle around a bunch of constraints if you only have partial knowledge of the program

AZ: I appreciate that it makes the analysis simple, you do need to do analysis but it’s local the type is present on the stack, example a call instruction we don’t annotate the return type of the binary and you have to do a global look up. There is already a some amount of burden, but it’s not a large burden

AR: This is a different type of burden, you need to know what all the indices that you can refer to what their types are, an invariant environment, where they are explicitly declared in the program, here you have to have context of the instruction sequence that can be potentially unbounded, depending on what the instructions sequence is, there’s no bound on how far you have to look back, that’s a sort of different dimension from looking a

DG: Are there examples of tools that we can reach out to to look at what kinds analysys these tools do? Theoretically all sorts of analysys is possible, looking for something used in practise

BT: There aren’t tools for Wasm GC, if you go by analogy, for Java bytecode, there are lots of bytecode analysis tools, examples: find me all uses of this field, or some analysis at the class file level, Java bytecode has enough annotation that you can do this

AR: A generalization of this is a simple example of finding out where a type is used, or size of a certain type. If you have that in the instructions explicitly, it’s easy to have that. Certain transformations want to have this information, not sure we have any concrete examples of tools, I would be interested in hearing of them too

DG: Even in a limited context if there are tools that perform some sort of analysis right now we could extrapolate what the costs would be, a lot of the discussions here about what sorts of analysis the tools would perform is also hypothetical right now

AR: Yeah, there are a lot of hypotheticals right now, in the presence of hypotheticals, it’s safe to be conservative and type annotations are a conservative choice. We can always add unannotated versions of instructions later if we find out that there’s a problem that sizes are really too big in practice, once we don’t have them we can’t go back

AZ: Can you clarify why it’s easier to add unannotated versions later vs. adding the annotated versions later?

AR: When we run into problems with lack of annotations, we can’t add them because of backwards compatibility, because we’re tied into supporting these instructions forever.  If there’s interference with some feature we want to add, then we basically a bad place. We have to resolve this somehow. The other way is more robust, the size optimization is always something you can add at later.

AZ: Why do we think we’d be at a point of time in the future where we think the risk is lower vs. now? Do you think we’ll come to a point where we’ve implemented all the tricky things in the type system? That seems unlikely. We’d always have the argument against adding them, we’ll always thinking it’s risky to add. Worry is always that we will keep suffering the 5% loss indefinitely, cost can be significant in the long run, and we’re choosing to opt into it, we might always say it’s risky to add them

AR: there’s never a point to be sure, over time we might have more data about what size data is more relevant, personally I think 5% is not an issue but ymmv, but we will be able to gather more data on that.  The other side is that some features that are at higher risk, we will have added already,  we will know more about whether these risks materialize, there will always be potential more things there are very likely features that we have them, type parameters for example, once we have those I’d be somewhat more comfortablle

JK: Having annotations make some tools simpler, don’t think that’s a convincing argument. In particular a bunch of arguments  regarding tools don’t make much sense, if you want to look for all occurrences of something, then you have to look everywhere anyway because you can reconstruct the types in a single linear pass over the module, and you have to do a single linear pass over the module if you want to look for all occurrences of something, that’s not really a significant burden, it only affects tools that process fragments of Wasm functions. Do we really want to make regular production modules that ship to billions of users larger by x%, because there could be a tool that wants to analyze fragments, and that tool would be slightly simpler? I remain extremely unconvinced by that line of reasoning.

BT: We are designing a format that has many different purposes, it’s a code format for interchange, we should prioritize all the tools that process that format, producers and consumers, and I don’t see how we justify that.. We could make the reverse argument, why aren’t there annotations that would be useful for tool authors and engines? From a different point of view that might be a hostile design decision

AR: This is very real feedback from people that work in the research space, one of the top things that makes their life easier with Wasm was that there is no overload, which is the trivial case of the problem we’re discussing right now. We’re talking about a much more inconvenient relaxation. I would also like to push back on the size arguments, it falls into the category of premature optimization, we haven’t really optimized for size as much previously, putting in ad hoc solutions to individual small things, we could have had a const 0 instruction, but we decided against it, we don’t have a negate instruction, and all these things we never decided to size optimize, we should do a more targeted approach instead of ad hoc ideas, we should stay consistent with that.

BT: I think we would call this layer 1 compression, I see what we’re doing  as we’re trying to use the type reconstruction algorithm as a way to compression, if we really want to use this, that might be really cool. That’s a compression mechanism that might not be available to a general purpose zip algorithm, if we were to continue looking at that idea, that could exist at another level, and we can have another tool that decompresses, still get the best of both worlds

AZ: Fair point that the compression could be done at another level, we haven’t focused on micro optimizing things. Want to push back against some of these, while in theory we could do something in the space, but it would take time, it’s unclear that we would actually do this. Unclear that we would actually have the resources to work on this, there are things we could have done the past, but did not but those are things  (const 0, const 1) that compress well, on the other hand, type annotations are high entropy thing and have a higher cost, this stuff does matter, we have a lot of use cases on the web where there are limited on the size of the download, while it doesn’t matter in some countries with unlimited bandwidth, other countries it isn’t. 5% is significant, lots of efforts to reduce code size overall and ever % matters. It is likely that if we don’t save this now, it’s possible that we’ll be stuck with this for a very long time and that would be wasteful.

DG: We’ve had discussions on both sides of this, one of the things that I’d like to circle back on, was that there are future features that there is a point of time in the future that we might feel comfortable about not having type annotations, you mentioned type parameters, maybe we can dig into that a little more what are other examples of future features? It would be nice to quantify that, at what point of time do we think the risk is lower, or is there a feature set you have in mind?

AR: It’s really a spectrum, certainty is increasing monotonically, at some point we can have a more informed decision about this. What the features would be, or what the timeline would be, I would make no predictions at this point given how long we’ve worked on at this point

DG: phrased this wrong, maybe looking for more of an opinion, the point that this could be unbounded w.r.t to time/features it seems uncomfortable at a time that we see the binary size being bloated that we want to make sure that we’re not adding size increase in unless necessary

FM: What would be the rationale for having type parameters? I’m not sure that there is one

AR: Currently there is no way to create code that operates the same on any reference, where you don’t really care  what the reference is. This is a frequent thing for compilers, in Wasm you can’t express them because every reference has to be concretely defined, I view this feature as giving a way to generate this kind of code that native code compilers are able to generate

FM: You can use any type

AR: But then you have a lot of casts, examples: polymorphic or dynamic languages. Main use case is all the languages which operate with a uniform representation. In many cases they don’t care about what the type is, but right now you have to go to the top type and go back. There are a lots of casts, will be expensive in practice. This is the type of cast you can get rid of because they’re only there because the type system of Wasm is unique.This is one very obvious case where we should be better without going overboard.

LW: Wanted to make the case for taking the layer 1 approach seriously, if we compress in some cases but not others, we’ll keep motivating ourselves not to work on this. There are significant wins to be had over the current status quo to doing this consistently. Doing individual small optimizations motivates us less to do this.Separately I was talking about this opcode table approach, where you define single bytes that could expand to opcodes and some fixed set of immediates, the idea being that you could do it inline in the decoder instead of the streaming phase, we abandoned it because we didn’t have time, and that we only got size savings with gzip and not brotli. The hope was that in the future that a simplistic scheme that we could implement to get rid of redundant immediates, if the normal bytecode stake could use this scheme, it could result in savings at multiple stages

BT: I’ll +1 to that, the tools want annotations and we might want to keep the annotations indefinitely, but have the tools do the compression. 

DG: That’s a reasonable answer, that assumes that we do the work to handle compression at a different layer, and that the tools do the right thing and we have the tools in place to do that right?

BT: Right, I see layer 1 compression as the thing that’ll give us the best of both worlds. We could use the Wasm type system as the type compression, and still have type annotation in the bytecode for future tools, and future feature extensions

DG: Any other thoughts? 

CW: Restate something came up implicitly, in a couple of years from now, if we do have a more solidified view of what extensions we want in the future, we can still add annotationless versions in the future with essentially the same code size savings. 

AR: That’s the conservativeness argument

DG: It doesn’t have to be an example for this particular set, but is there an example that you could point to of something that was broken, looking for something that’s not as hypothetical as future problems, extensions, but even a toy type system example that can run into this problem

AR: Select instruction is an example it didn’t have annotations, and once we added subtyping we realized we have to compute LUBs now we did this hack, where it was moderately ugly, we’ve already run into this problem, the br_table was also simple but hack not so ugly, simple example that everyone can understand. With the kind of things we’re talking about now, the problems would be much more intricate. It’s not completely generic types, it’s very specific types

FM: Is it fair to say that you run into trouble when you have to do the LUB?

AR: Depends on how you define trouble, it’s very expensive, depending on how large your types are. In Wasm, we require that all types that occur in validation are defined, when you compute an LUB you may have a type that doesn’t have a definition, doesn’t have an index it can refer to.  You have to extend the whole type system with synthesized types, that’s a whole new level of complexity as well which we do avoid right now

BT: Ran into this problem for func.bind, which has a synthesized type, we run into the same issue with any type of inference that it creates types that you haven’t written down. It’s because we have this subtyping relationship that we have to declare, if you haven’t written one of the subtypes in the chain, it’s essentially a synthesized type, and how is that type canonicalized? We don’t have to mandate type canonicalization

AR: LUBs only work when you have proper lattice in the type system, or at least a semi lattice. For br_table you need GLBs (?) so you would need a full lattice, that’s a severe constraint. There are cases where you can’t synthesize a proper type, there is no principle type that you could synthesize, it’s not clear how you would solve this problem

DG: The select, and br_table examples make sense, but the larger picture of exactly what problems we would run into is still hard for me to grasp. 

BT: Look at the func.bind example, Andreas had an example of how this would work, without annotations we would have to do this operation, I’m not sure what the complexity would be it would have made it easier to have annoptations on func.bind

JK: We can always require annotations in places where annotations are required, for example we could say that the hypothetical struct.get is valid if and only if the type of the thing on the value type is uniquely defined. If that’s not the case, a new instruction has to be used, or an explicit ref.cast or something else would need to be introduced

AR: Highlighted the problem again, that’s what doesn’t work. The condition under which.. You would need to be able to decide whether the type is principled or not, and deciding that as complex as as deriving all tht types that are possible. You have a decision process that is arbitrarily expensive

JK: To validate the annotation, which you have to do in an engine, you do have to check the type on the stack, for example, you have to check is there even a struct to do struct.get on that, and if you can tell easily enough whether you have a struct at all, then presumably you can always tell whether that has a type parameter or not 

AR: It’s more complicated than that. In general, do you have a principal type or not? Is there a most generic type that covers all possibilities. If you don’t have that then you need back tracking in general. This is a thing you don’t want to do. To even decide whether your type is principal, that’s not something you can generally do without backtracking either. You have to explore all the search space where you could have decided otherwise. I have seen systems that track the principality of the types used, but that is very researchy,  I don’t know how well it generalizes. In general, the assumption that you can make this distinction doesn’t work

BT: In practise what would happen is that the annotation less instruction become less and less useful over time, because you add features that can’t use them, and then you have to come up with rules for when  they can be used and not and they can be very subtle

AR: Because you’re very likely to lose properties like substitutability, if you have very adhoc restrictionson what types are allowed somewhere. One essential principle of subtyping is that whenever you can use a type, you can always use a subtype. If you break the property, you’ve broken the entire type system, so these rules have to work in a way that you don’t break the property, I’m not sure that is possible in general

JK: We can make the rules as simple as we want them to be, not saying that’s a particularly good design, but just saying that we do have the power to make the simplest rules possible

AR: That would make merging modules broken

JK: Merging modules is already broken, you can’t merge a GC enabled module into a non-GC enabled module and then expect it to run on a non-GC enabled engines that the old module can run on, module merging argument would rule out adding any feature ever

AR: I disagree, that doesn’t make sense

BT: Obviously if you merge modules, then you have to run on engines that support all those modules 

CW: To flip it around, if we want to make the point that the annotation less instructions are reasonable, the check to distinguish whether we need an annotation or not is not too bad, I think we’ll be in a better place to make our judgment. At the point that we’re past the GC MVP, at some point we are going to care about code size. This shouldn’t lock us out about caring about code size, but we’re trying to hold together a lot of discussions about the type system right now, it makes sense to be conservative to get the MVP through the door.

BT: The rules are exactly the same whether you need an annotation or not, to determine when you can compress, either way we can end up with different opcodes in the encoding

CW: At some point we care about code size, then we can decide the rules of when an annotation is ok and when it isn’t. Give different opcodes and we get the same size opcodes

DG: The concern I have with that is that some point is very indefinitely into the future and we’re not able to define what that point could be, hypothetically we could be doing several things with layer 1 compression, just want to mention the other side that the indefinite period is concerning

AR: That is true of any feature, if you consider size savings features, then different features have different priorities, and as features are requested more and more they become higher priority, so let’s see where we land

BT: Can believe space is a priority, there are other techniques that are just valuable, if code size is a high priority, we can always do things to factor them out, tooling things that would help in this domain. Giving it a full try there, it was mentioned in the thread, Java module compiled to JS vs WebASsembly GC have a 2x space gap, there are probably more reasons that the immediates to struct.get to that. There are different design decisions that can be made to save code space too

AR: In general if you want to optimize for code size, you have to do that in a targeted way at a higher level, this is a problem we can’t solve without having domain specific abstractions

JK: BT says if you really cares you can sacrifice performance for it, and AR says well if you really care you can do something other than Wasm. Still unconvinced about this argument

FM: Pushing back argument the in-browser toolchain argument, not consistent with CSP, the CSP policy applies to the module that has to instantiate, it strongly limits the type of things we can do at the tooling level

AR: Not sure how to respond to that, if that was a constraint we want to work around, then we’d end up turning Wasm into a source language. If we can’t add additional layers of abstraction, then we’re doomed
 
FM: We looked at doing macros, the macro question keeps coming up, but as it happened that I was working on CSP at the time, it causes sufficient pain to drop it at the time, it’s possible we could fix it

CW: To me the core of what’s going on is the meta question, of when we want to do that worrying, can we defer the eat the 5% and come back to it later

BT: Is 5% shippable? 

AZ: 5% is not going to make the difference between shipping and not, it could be something we suffer for a long time, it affects everyone, not just one subset of people working on toolchains/specs, there are risks to people across the board and we have to consider that

BT: I do want to discount that, it is a binary question of can we ship, that determines whether we want to remove annotations

AZ: I think we could ship either way, just one way would be less good

Poll: **We should remove type annotations from array and struct accessor instructions rather than add a type annotation to call_ref.**

Non binding poll, we should do F/N/A

|F|N|A|
|-|-|-|
|3|5|6|

Other comments:
JM: Neutral: Code size is a big problem now, and we should prioritize end users over toolchains, but the worries about future type system enhancements seem to have a lot of merit

AT: Weak preference in my case, I agree with picking the conservative option for now while investigating other ways to save space and possibly revisiting this

BT: I don’t think we should remove annotations at all, but handle compression at a different layer. 

AR: What are next steps?

DG: Could be many options, do we thing this is sufficient consensus or want another poll? With majority vote against for this poll, do we need a separate poll to add annotations for call_ref? Let’s follow up on the issue as we’re out of time.

### Closure
"
wasi/2023/WASI-02-09.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: February 9 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: February 9, 17:00-18:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. A possible roadmap for WASI Preview1, Preview2, Preview3, and WASI 1.0 - Dan Gohman (slides: [pdf](presentations/2023-02-09-gohman-wasi-roadmap.pdf))
      - A proposed framework for Preview3 and WASI 1.0: https://github.com/WebAssembly/WASI/issues/515
      - Reorganizing the Preview1 files: https://github.com/WebAssembly/WASI/pull/510
    1. Should Preview1 `fd_readdir` filter out `.` and `..`?
      - https://github.com/WebAssembly/wasi-testsuite/issues/52
    1. Should we start a new WASI proposal repo for a CLI world?
      - https://github.com/WebAssembly/WASI/issues/509

### Attendees
- Lin Clark
- Joel Dice
- Bailey Hayes
- Slava Kuzmich
- Steve Schoettler
- Pat Hickey
- Zalim Bashorov
- Jeff Charles
- Dave Hay
- Hung-Ying Tai
- Adam Mohammed
- Dan Gohman
- Piotr Sikora
- Ashley Nelson
- Chinmay Garde
- Ivan Font
- Frank Schaffa
- Antoni Bofarull
- Yong He
- Sam Clegg
- Till Schneidereit
- Colin Murphy
- Andrew Brown
- David Justice
- Kyle Brown
- Deepti Gandluri

### Preview 1, Preview 2, Preview 3, WASI 1.0 Framework
**Dan Gohman:** For quite some time no clear path where it would be. New sense of clarity with wit tooling in place. Proposal for thinking through scope of each step on the path

Preview 1 is what’s out there today, supported in many engines, some prod envs. Focus: let’s support existing users. PR 510 is tidying up preview 1 docs to clarify existing semantics. Compat with what we have now is the theme.

Preview 2 is the big item, based on wit idl. That gives us answers to longstanding questions. Things like modularization. Interfaces and worlds are concepts that WASI can build on there. Things like what is a file descriptor, etc. Never had clear answers, and now the component model gives us that. What should be WASI’s job vs low level standards? Now emerging that there are clear ways to separate. Other layers can define those pieces and WASI can be pure API standardization. How to make WASI interfaces fully virtualizable. With CM, we have answer for that. We now have answers for thses things, moment of clarity. Number of lessons learned in Preview 1 fixed in Preview 2.

Preview 3. In Preview 2 timeframe won’t be able to do integrated async. Points to Preview 3 being where we add async features. This adds future and stream of T. Bindings for different languages is pretty complex. Check out Luke’s proposal. Big benefit of integrated async, can have single global event loop for composition (even though there may be nested event loops), idiomatic source language bindings, and ability to have typed streams. Turn async up to 11

Beyond that, that feels like the last big platform feature for the foundation. Big push for WASI 1.0 is standardization and process. Starting to work with WASM CG, getting an editor, publishing the document. WASI now has this concept of worlds. At point of 1.0, we’ll have some worlds. WASI 1.0 will just include those worlds and interfaces that are standardized at that time.

Preview 1: Support existing users
Preview 2: Rebase WASI on wit
Preview 3: Level up async
1.0: Standardize

At each point, can incorp real world feedback. May need to make breaking changes. Preview 2 -> 3 and 3->1.0 should be easier than the transition from Preview 1->2. Not going to promise Preview 2 forever, but these transitions won’t fundamentally change what we need to do.

Questions?

**Andrew Brown:** Which proposals do you see as being a part of Preview 2, Preview 3, and 1.0. Do you see just the 5 original, or can several other of the 20 be included.

**Dan Gohman:** At each stage, we’ll say everything that is ready can join the party. Just about timing. Timeline defined by CM and wit tooling readiness. Original fs, clocks, random set. Hoping those will be ready, Hoping that other proposals could advance and be ready.

**Andrew Brown:** So you know what’s required what’s needed for Preview 2, but other authors don’t necessarily have that insight.

**Dan Gohman:** Good question. Next step for me to write up docs. Then we can put together a framework, and as part of that explain that you need to write in the wit format. Could add other criteria, but the big criteria is wit. For Preview 3, if async is relevant, you make the changes, but otherwise no changes. For WASI 1.0, would need to go through CG.

**Bailey Hayes:** Thanks for putting this together. I’d like to see—we want WASI to be modular. Some don’t make sense for all runtimes. I think one thing that will help is showing that now with the modular set of interfaces what it looks like when one isn’t supported.

**Dan Gohman:** Great idea. I think the world concept is the first building block to getting there. That will define sets of APIs. The world is the nexus between developers and platforms. WASI subgroup will define some number of standardized worlds. Other worlds people have talked about, e.g. embedded systems. You can also build worlds on top of worlds with your custom APIs.

CW: Exactly what Bailey said, thanks for this hard work. From an external perspective, WASI user C developer point of view. What’s the impact. Preview 1, not much. Preview 2, would need C interfaces going towards wit. For P2, have a situation where I could create a component with P2, but it will only execute on what supports that. P3 is going to be the same.

**Dan Gohman:** Yes, there will be a transition period. One thing that is happening is a preview 1 -> 2 adapter toolchain. Can take Preview 1 impl forward migration

CW: Then engine impl will just have to play catch up. We may be able to help with C++ runtimes. If you could keep us in mind.

**Dan Gohman:** WASI sg meeting is a great place to keep up with things. Also follow me on social media, Mastodon

**Piotr Sikora:** Especially like that you aren’t abandoning Preview 1 users. Question, what timeline? Especially if we want feedback, sounds like multi-year process before WASI 1.0.

**Dan Gohman:** That’s right, don’t expect to be as long as Preview 1.

**Piotr Sikora:** Are we expecting at least 1 year between?

**Dan Gohman:** For Preview 3 we’re talking about moving once the tooling is ready. ONce we have the tooling that can do it, I think we’ll want to make that move. A year might not be a bad place to start in terms of timelines.

**Piotr Sikora:** Perfect, thanks. Between p1 and p2 main feature is moving to wit. That’s mostly about how interfaces are generated. Do we expect those to change at the ABI level

**Dan Gohman:** ABI does change. P2 is using CM, using canonical ABI

**Piotr Sikora:** So some of the proposals including WASI HTTP are blocked on async features.

**Luke Wagner:** Dan currently has WASI I/O with psuedofutures and pseudostreams. This is the stop gap. The idea is to publish a P2 version that has these pseudofutures and streams. This won’t give us the magic composability, but fine for now.

**Piotr Sikora:** Perfect, thank you

**Till Schneidereit:** Big fan of this roadmap. One thing I’m curious about is how much you’ve been thinking about what degree the different milestones should be covered by what level of test coverage for APIs. Besides tests, what about more substantial description of interfaces. Obviously, for WASI 1.0, we’ll need to have a solid interop test suite. Do you think that’s something that should happen for P2 and P3 as well, or will that need to join at 1.0.

**Dan Gohman:** I do want to shout out to WASI test suite. Right now being built on P1. P1 spec is not very complete, so this is helping flush out. Hopeful that these can be upgraded to P2 because these are being written as source language tests rather than raw wat. Don’t have strong opinion about whether we should block on tests. A little tricky with some of the APIs.  Not clear that we’d want to block Preview 2 on whole testing framework. For command style APIs is that they are really easy to test. Once we get outside that space, harder to write tests. Don’t know what our answer should be: should we require for advancement? Would want group to decide

**Till Schneidereit:** I do feel like we should require some kind of test suite at a certain stage because otherwise hard to see how to have interop implementation. Maybe equivalent to Web Driver. For now, neither here nor there. Was just curious about your current thinking.

**Dan Gohman:** My personal thinking on that is letting each proposal figure out its own path. Not ideal in some respects, but does give us flexibility to allow for specific needs of APIs. Similar to current story on portability. Different APIs can proposal limit sets of portability. E.g. EBPF probably not portable to Windows. My thinking is we approach testing in the same way. Probably not the worst situation to be in. Progress here probably happens iteratively over time.

**Deepti Gandaluri:** You were talking about portability already. Some amount of portability that P1->P2 and P2->P3 provide guarantees?

**Dan Gohman:** Current thinking is we continue with current scheme will define its own thing. All the command APIs expect to support Windows, MacOS, Linux. Other APIs can define what they do. WASI as a whole with the framework we’re talking about, lots won’t be portable. We don’t want to preclude those to not being part of WASI. Maybe the world mechanism is a way to impose more portability rules. Feels to me we can do it world by world.

**Deepti Gandaluri:** Think that answers my question. Mentions that at each level would be taking implementation feedback. Maybe the worlds answer this to an extent, but what impl feedback is what you block on or move to a further preview.

**Dan Gohman:** This is more open ended because there’s more diversity between engine impl styles. Same thing basically applies though. If someone raises a problem for core, like SIMD, and one person says that it doesn’t work on x86, that applies to most engines. We can use the same process of figuring out how valid that concern is. In the core wasm spec process, we just work through that and champion makes judgement call. Those are the decision making process that we follow. We can say we trust the champion. If someone has some super exotic changes, then the champion can define the scope. E.g. someone trying to impl a fs on a system that doesn’t have an fs, the champion can scope to only platforms that have fs and figure out the others with a different proposal.

Currently champions can make decisions, CG can vote.

**Deepti Gandaluri:** We do have a minimal subset of two web vms

**Dan Gohman:** We do have an analog for that, where the SG votes on each proposals

**Deepti Gandaluri:** I see the parallel to that, but was harder for me to reason about

**Luke Wagner:** I think some of the intention between the WebVMs is that you want impl feedback from people who have a real commitment to longterm security, maintainability. That meant sign off meant something. That was 4-5 years ago. In the current state, we do have long term thinking outside the browser so I think we’ll want to find out some verbiage to capture that long term thinking.

**Deepti Gandaluri:** Probably something we’ll want to define for core too.

### Worlds

**Dan Gohman:** Now that wit can have worlds, we can use existing proposal template to define worlds. That could just be a WASI level proposal. Should we define a new proposal template for a world.

**Luke Wagner:** From my perspective, makes sense to have repo as world. Possibly have worlds and itnerfaces separated by worlds. Other case, couple HTTP interface with HTTP proxy world. Don’t want to always separate them, may have collection of interfaces and worlds in the same repo.

**Dan Gohman:** Makes sense, I’ll have a new proposal for our next meeting

### Reorganizing the Preview 1 files

**Dan Gohman:** Just calling attention to the PR.

### Should Preview1 fd_readdir filter out . and ..

**Dan Gohman:** POSIX historically included. A lot of languages have filtered those out because users don’t care about those. Idea is that we could also filter these out and then re-add them. Then there’s a question of what Preview 1 should do. Could just continue to do the POSIX conforming. Curious about sg

**Pat Hickey:** Because there are existing P1 programs, we shouldn’t make changes like this.

**Dan Gohman:** I’m seeing sam as a thumbsup up there. More broadly, I think any changes to P1 should increase compat and we should try not to introduce non-determinism. That sound right? Looks like agreement

### Attendees
- Lin Clark
- Joel Dice
- Bailey Hayes
- Slava Kuzmich
- Steve Schoettler
- Pat Hickey
- Zalim Bashorov
- Jeff Charles
- Dave Hay
- Hung-Ying Tai
- Adam Mohammed
- Dan Gohman
- Piotr Sikora
- Ashley Nelson
- Chinmay Garde
- Ivan Font
- Frank Schaffa
- Antoni Bofarull
- Yong He
- Sam Clegg
- Till Schneidereit
- Colin Murphy
- Andrew Brown
- David Justice
- Kyle Brown
- Deepti Gandluri

### Preview 1, Preview 2, Preview 3, WASI 1.0 Framework
**Dan Gohman:** For quite some time no clear path where it would be. New sense of clarity with wit tooling in place. Proposal for thinking through scope of each step on the path

Preview 1 is what’s out there today, supported in many engines, some prod envs. Focus: let’s support existing users. PR 510 is tidying up preview 1 docs to clarify existing semantics. Compat with what we have now is the theme.

Preview 2 is the big item, based on wit idl. That gives us answers to longstanding questions. Things like modularization. Interfaces and worlds are concepts that WASI can build on there. Things like what is a file descriptor, etc. Never had clear answers, and now the component model gives us that. What should be WASI’s job vs low level standards? Now emerging that there are clear ways to separate. Other layers can define those pieces and WASI can be pure API standardization. How to make WASI interfaces fully virtualizable. With CM, we have answer for that. We now have answers for thses things, moment of clarity. Number of lessons learned in Preview 1 fixed in Preview 2.

Preview 3. In Preview 2 timeframe won’t be able to do integrated async. Points to Preview 3 being where we add async features. This adds future and stream of T. Bindings for different languages is pretty complex. Check out Luke’s proposal. Big benefit of integrated async, can have single global event loop for composition (even though there may be nested event loops), idiomatic source language bindings, and ability to have typed streams. Turn async up to 11

Beyond that, that feels like the last big platform feature for the foundation. Big push for WASI 1.0 is standardization and process. Starting to work with WASM CG, getting an editor, publishing the document. WASI now has this concept of worlds. At point of 1.0, we’ll have some worlds. WASI 1.0 will just include those worlds and interfaces that are standardized at that time.

Preview 1: Support existing users
Preview 2: Rebase WASI on wit
Preview 3: Level up async
1.0: Standardize

At each point, can incorp real world feedback. May need to make breaking changes. Preview 2 -> 3 and 3->1.0 should be easier than the transition from Preview 1->2. Not going to promise Preview 2 forever, but these transitions won’t fundamentally change what we need to do.

Questions?

**Andrew Brown:** Which proposals do you see as being a part of Preview 2, Preview 3, and 1.0. Do you see just the 5 original, or can several other of the 20 be included.

**Dan Gohman:** At each stage, we’ll say everything that is ready can join the party. Just about timing. Timeline defined by CM and wit tooling readiness. Original fs, clocks, random set. Hoping those will be ready, Hoping that other proposals could advance and be ready.

**Andrew Brown:** So you know what’s required what’s needed for Preview 2, but other authors don’t necessarily have that insight.

**Dan Gohman:** Good question. Next step for me to write up docs. Then we can put together a framework, and as part of that explain that you need to write in the wit format. Could add other criteria, but the big criteria is wit. For Preview 3, if async is relevant, you make the changes, but otherwise no changes. For WASI 1.0, would need to go through CG.

**Bailey Hayes:** Thanks for putting this together. I’d like to see—we want WASI to be modular. Some don’t make sense for all runtimes. I think one thing that will help is showing that now with the modular set of interfaces what it looks like when one isn’t supported.

**Dan Gohman:** Great idea. I think the world concept is the first building block to getting there. That will define sets of APIs. The world is the nexus between developers and platforms. WASI subgroup will define some number of standardized worlds. Other worlds people have talked about, e.g. embedded systems. You can also build worlds on top of worlds with your custom APIs.

CW: Exactly what Bailey said, thanks for this hard work. From an external perspective, WASI user C developer point of view. What’s the impact. Preview 1, not much. Preview 2, would need C interfaces going towards wit. For P2, have a situation where I could create a component with P2, but it will only execute on what supports that. P3 is going to be the same.

**Dan Gohman:** Yes, there will be a transition period. One thing that is happening is a preview 1 -> 2 adapter toolchain. Can take Preview 1 impl forward migration

CW: Then engine impl will just have to play catch up. We may be able to help with C++ runtimes. If you could keep us in mind.

**Dan Gohman:** WASI sg meeting is a great place to keep up with things. Also follow me on social media, Mastodon

**Piotr Sikora:** Especially like that you aren’t abandoning Preview 1 users. Question, what timeline? Especially if we want feedback, sounds like multi-year process before WASI 1.0.

**Dan Gohman:** That’s right, don’t expect to be as long as Preview 1.

**Piotr Sikora:** Are we expecting at least 1 year between?

**Dan Gohman:** For Preview 3 we’re talking about moving once the tooling is ready. ONce we have the tooling that can do it, I think we’ll want to make that move. A year might not be a bad place to start in terms of timelines.

**Piotr Sikora:** Perfect, thanks. Between p1 and p2 main feature is moving to wit. That’s mostly about how interfaces are generated. Do we expect those to change at the ABI level

**Dan Gohman:** ABI does change. P2 is using CM, using canonical ABI

**Piotr Sikora:** So some of the proposals including WASI HTTP are blocked on async features.

**Luke Wagner:** Dan currently has WASI I/O with psuedofutures and pseudostreams. This is the stop gap. The idea is to publish a P2 version that has these pseudofutures and streams. This won’t give us the magic composability, but fine for now.

**Piotr Sikora:** Perfect, thank you

**Till Schneidereit:** Big fan of this roadmap. One thing I’m curious about is how much you’ve been thinking about what degree the different milestones should be covered by what level of test coverage for APIs. Besides tests, what about more substantial description of interfaces. Obviously, for WASI 1.0, we’ll need to have a solid interop test suite. Do you think that’s something that should happen for P2 and P3 as well, or will that need to join at 1.0.

**Dan Gohman:** I do want to shout out to WASI test suite. Right now being built on P1. P1 spec is not very complete, so this is helping flush out. Hopeful that these can be upgraded to P2 because these are being written as source language tests rather than raw wat. Don’t have strong opinion about whether we should block on tests. A little tricky with some of the APIs.  Not clear that we’d want to block Preview 2 on whole testing framework. For command style APIs is that they are really easy to test. Once we get outside that space, harder to write tests. Don’t know what our answer should be: should we require for advancement? Would want group to decide

**Till Schneidereit:** I do feel like we should require some kind of test suite at a certain stage because otherwise hard to see how to have interop implementation. Maybe equivalent to Web Driver. For now, neither here nor there. Was just curious about your current thinking.

**Dan Gohman:** My personal thinking on that is letting each proposal figure out its own path. Not ideal in some respects, but does give us flexibility to allow for specific needs of APIs. Similar to current story on portability. Different APIs can proposal limit sets of portability. E.g. EBPF probably not portable to Windows. My thinking is we approach testing in the same way. Probably not the worst situation to be in. Progress here probably happens iteratively over time.

**Deepti Gandaluri:** You were talking about portability already. Some amount of portability that P1->P2 and P2->P3 provide guarantees?

**Dan Gohman:** Current thinking is we continue with current scheme will define its own thing. All the command APIs expect to support Windows, MacOS, Linux. Other APIs can define what they do. WASI as a whole with the framework we’re talking about, lots won’t be portable. We don’t want to preclude those to not being part of WASI. Maybe the world mechanism is a way to impose more portability rules. Feels to me we can do it world by world.

**Deepti Gandaluri:** Think that answers my question. Mentions that at each level would be taking implementation feedback. Maybe the worlds answer this to an extent, but what impl feedback is what you block on or move to a further preview.

**Dan Gohman:** This is more open ended because there’s more diversity between engine impl styles. Same thing basically applies though. If someone raises a problem for core, like SIMD, and one person says that it doesn’t work on x86, that applies to most engines. We can use the same process of figuring out how valid that concern is. In the core wasm spec process, we just work through that and champion makes judgement call. Those are the decision making process that we follow. We can say we trust the champion. If someone has some super exotic changes, then the champion can define the scope. E.g. someone trying to impl a fs on a system that doesn’t have an fs, the champion can scope to only platforms that have fs and figure out the others with a different proposal.

Currently champions can make decisions, CG can vote.

**Deepti Gandaluri:** We do have a minimal subset of two web vms

**Dan Gohman:** We do have an analog for that, where the SG votes on each proposals

**Deepti Gandaluri:** I see the parallel to that, but was harder for me to reason about

**Luke Wagner:** I think some of the intention between the WebVMs is that you want impl feedback from people who have a real commitment to longterm security, maintainability. That meant sign off meant something. That was 4-5 years ago. In the current state, we do have long term thinking outside the browser so I think we’ll want to find out some verbiage to capture that long term thinking.

**Deepti Gandaluri:** Probably something we’ll want to define for core too.

### Worlds

**Dan Gohman:** Now that wit can have worlds, we can use existing proposal template to define worlds. That could just be a WASI level proposal. Should we define a new proposal template for a world.

**Luke Wagner:** From my perspective, makes sense to have repo as world. Possibly have worlds and itnerfaces separated by worlds. Other case, couple HTTP interface with HTTP proxy world. Don’t want to always separate them, may have collection of interfaces and worlds in the same repo.

**Dan Gohman:** Makes sense, I’ll have a new proposal for our next meeting

### Reorganizing the Preview 1 files

**Dan Gohman:** Just calling attention to the PR.

### Should Preview1 fd_readdir filter out . and ..

**Dan Gohman:** POSIX historically included. A lot of languages have filtered those out because users don’t care about those. Idea is that we could also filter these out and then re-add them. Then there’s a question of what Preview 1 should do. Could just continue to do the POSIX conforming. Curious about sg

**Pat Hickey:** Because there are existing P1 programs, we shouldn’t make changes like this.

**Dan Gohman:** I’m seeing sam as a thumbsup up there. More broadly, I think any changes to P1 should increase compat and we should try not to introduce non-determinism. That sound right? Looks like agreement
"
gc/2021/GC-07-27.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 27 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: July 27, 4pm-6pm UTC (July 13, 9am-11am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Nominal and structural types (2 hours)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Alon Zakai
- Tim Steenvoorden
- Jay Phelps
- Igor Laevsky
- Daniel Wirtz
- Ross Tate
- Ryan Hunt
- Zalim Bashorov
- Dmitry Bezhetskov
- Sergey Rubanov
- Andreas Rossberg
- Conrad Watt
- Jakob Kummerow
- Ioanna Dimitriou
- Francis McCabe
- Rick Battagline
- Emanuel Ziegler
- Asumu Takikawa
- Adam Klein
- Luke Wagner
- Slava Kuzmich
- Daniel Ehrenberg
- Ben Titzer
- Keith Miller
- Petr Penzin
- Zhi An Ng

### Discussion: Nominal and structural types (2 hours)

AR presenting [slides](https://github.com/WebAssembly/meetings/blob/master/gc/2021/presentations/2021-07-13+-rossberg-modulariy.pdf)

AR: Recap from last time: there are many degrees of modularity that are important for different use cases and all are possible to use in Wasm today. Anything that works in a modular fashion today should still work with GC. Structural types are not a fringe problem. Many languages have structural types and they must be compiled correctly and handled at module boundaries.

Structural types are infinite in number, so declaring them in a runtime module does not scale.

CW: I appreciate the number of possible tuple types is infinite. You’re still matching each tuple type in the source code to a different struct definition. Same number of definitions in nominal and structural.

AR: Right. This is about the runtime module not scaling.

RT: You would have a loader that would deduplicate these types.

AR: Will get to that.

RT: How do you allocate a new struct for this?

AR: Just allocate a struct.

RT: In what OO language does a tuple not have a vtable?

AR: Good question. Not sure.

BT: This seems like a distraction. It’s easy to come up with a language with tuples with no vtables.

RT: Languages that do have tuples with vtables also need a mechanism to consolidate their vtables. If we have structural types, we can’t service such languages.

AR: You can synthesize the vtable, accessors, etc. on the fly.

RT: Java does ….

AR: This is why you wouldn’t want vtables.

RT: But C# does this as well.

BT: I’d like to see what AR has to say about Wob. There are lots of languages and implementation strategies.

RT: These strategies are appealing because they don’t solve the hard problems in real languages.

CW: “ought to be zero-overhead” line: We have an idea that certain vtable accesses should be zero-overhead from the source point of view, but in fact in Wasm there will be cost. Is this that kind of “ought” or actually zero overhead?

AR: This means actually zero-cost.

CW: You could imagine the Wasm types system not being rich enough to do this without casts.

AR: In functional languages this module access is about as common as method access in OO languages, so we want it to be fast.

RT: Why do nominal types break this diamond import example?

CW: I think it would be inaccurate to say “this works because of structural types” because we haven’t seen that it doesn’t work with nominal types yet. The top level coordination logic in equirecursive types is IMO the engine doing canonicalization.

RT: Right, you could instead have the loader do that coordination instead.

AR: Will get to those solutions in a bit.

CW: Again, that needs to come with caveats. There are patterns you can do with linear memory and static offsets that you cannot do with references. So it is too strong to say that everything you can do with linear memory you can do with references.

AR: Don’t remember your specific example.

CW: Could have modules import the same memory with offsets to coordinate.

BT: Could also do all sorts of other things like multi-dimensional inheritance in linear memory that we definitely can’t do with nominal types, so I’m not sure this is relevant.

FM: IMO, int32 is a nominal type, and it just happens to be known by everyone. The reason that it works is because everybody understands what int32 means

AR: yea, primitive types you can view as builtin nominal types, or structural types that are atomic. Since they are ambient, doesn’t matter which view you take

FM: you can solve ambient problem separately, you can have duplicate type definitions that you check for consistency, similar to checking structural type

AR: how is it not a structural type?

FM: because it has a name

CW: sounds to me like nominal types but with a linker in userspace that enforces structural convention for how types get passed, has some links to my notion to canonicalization in the engine

FM: if the argument is that you can’t do everything with structural types and nominal types, there is an obvious outcome - have both.

AR: fair argument, not sure if int32 is a good argument. You can view everything as a builtin type. You have to make some minimal set of primitives, otherwise nothing to boot from.

FM: disagree, you can boot from a bitstream

AR: the type language has to have something, otherwise you can’t build anything

TL: we should continue and see more examples, and come back to this more general discussion afterwards

CW: To be more specific about (2) (on structural import inversion slide), I would accept if the module carried some sort of state that had to be fed to the central infrastructure before that module could be linked in.

AR: yup, that’s fine, you’ll need some kind of reflection mechanism anyway, how that works specifically is not of concern

TL: example of treating indefinite as definite is wasi namespace or emscripten namespace

AR: also like es6 module, runtime resolves module based on path

TL: Emscripten has both, builtin and WASI modules, the user can then add whatever they want on top of that.

CW: is this necessarily true, having it is useful, but also can have toolchain convention, have the things you instantiate have different names

BT: almost the same as what I came up with in Jawa, either parameterize imports with args (type args), or have really tiny modules

AR: you still want to have this, C is a certain module with parameters, you want to import it from different places under that name, but give it different parameters. Can use some name mangling convention, with something denoting what it is.

CW: lot of complexity in doing this, how far can you get without this?

RT: is this like in C#, if you’re importing a generic type instantiated with specific arg, import List with type argument String to get a List[String]

AR: yea, but C is not a type/class, it is a module. Modules have type arg parameters like generic parameters.

FM: this raises a lot of problems, if C exports a type that depends on T, or doesn’t depend on T, the same type S considered the same or not the same depends on whether it references T or not. Difficult to do.

AR: Won’t disagree. It gets complicated

FM: is this a serious proposal to add type parameters?

AR: Inverting the exports of structural types is one solution that has been suggested in previous discussions, want to show how far we can take it and whether it works

RT: this doesn’t look familiar to anything i’ve seen

BT: you need to introduce type params for anything you want to reuse. Imagine C is Pair, everything you use Pair, you have to know it has type parameters

TL: looks similar to the solution to invert the structural imports and weak definitions

AR: the kind of importexport thing came out of that discussion

CW: i remember this kind of idea importexport inversion coming from older debates we have about nominal types.

TL: when this import inversion came up recently, it was about how to deal with mutually dependent/mutually recursive modules, we have since decided we don’t care about those complex things

RT: also, in that same place discussing, loaders resolve it rather than clients resolve it

AR: typically source language have nominal types, you have natural place of definition, with recursion group you have similar problems. Not reasonable to have recursion across package boundaries.

CW: agree that in the context of linking arrangement it’s not interesting, but has implication for central coordination

CW: it’s true that impotexport adds not expressiveness, it was brought up to address the concern that in nominal types, you have to decide who owns the type at compile type. If you imagine a central logic that incrementally links logic together, it can look at importexport, and decide if you want to interpret that as import or exprot at runtime

TL: any concrete patterns of import/export, can be described with normal import and exports. When you use importexport, it defers that choice to runtime. A single module graph that uses exportimport can map to multiple concrete graphs

CW: instead of define exportimport, you can add capability…

AR: some convention on the import name, then use that as an import and pass it on

CW: importexport sketches what that mechanism looks like

<BREAK>

CW: agree that regular Wasm module isn’t powerful enough to do this, the “central logic” is more about scripts in JS to link things together

CW: client modules have names they know they can access things from, but not an actual Wasm module

RT: can be unbounded number of names

AR: can be a set yes

CW: a single entry point in practice, to access all those names

AR: all imports have 2 names, module and item, you split it at module or item level, if it is virtual, doesn’t matter, multiple ways to do it here

CW: using the word module for everything makes it seem less reasonable

RT: addresses the infinite types problem, the ability for modules to ship modules with aux modules defining each type, it addresses the infinite types problem

CW: at any execution point, the central logic has a finite number of types, but unbounded, since it can always add more

RT: reflection can be what Wasm already uses, which is the name of the import

AR: if you are in the JS API yea

RT: are there other ones where import names are ignored?

AR: if you can implement a custom loader you always have this kind of reflection

RT: if a loader looks at 2 same names and decides to use 1 of them, you can solve the infinite types problem

TL: you’re saying you don’t need JS or more powerful reflection?

BT: java has Array type constructor, you need import arguments to supply a type, so the central module knows

AR: you can mangle structure type into module or item name

CW: yes, what i’ve had in mind

BT: yea implemented this, mangling everything into names is not viable

AR: mangling is not that easy here, one problem is that outside of a module you don’t have a global namespace, how to refer, in your name, to outside types

RT: rtt.canon requires you to put equirecursive into canonical form, it already requires this infrastructure

BT: what is the point of types if you encode everything into strings?

AR: once you mix structural types and nominal types, e.g. if you have WASI and import fd type, how to globally name that in your mangling scheme?

BT: wrestled with this, you can encode the bytes of the Wasm module into names of module, you can encode type defs, the actual bytes, into the name, that’s where you end up

AR: solvable, but not obvious how to scale this up. Have in mind a simple convention, then look at type bounds.  You have to reflect on the type bounds.

RT: isn’t it the same name means same import

AR: if you have mangling then yes. When you have structural types, especially recursive ones, there is no unique name. Many different ways of writing the same type. You need to canonicalize the mangling as well.

FM: if you have nominal types then you don’t try to have recursive structural types

AR: we’re compiling a source language that might have that

FM: for the same reason we don’t support mutual recursion across modules

TL: for example, source lang has equirecursive structural types, the frontend compiler for that language should do the canonicalization. Non controversial that for complex situations like that, the frontend has to do extra work

AR: there are languages with structural recursive types, such as OCaml, object types and polymorphic variants

CW: was looking at how OCaml links modules, to make sure separately compiled modules match, they hash, don’t try to at link time do structural comparison

AR: when you compile OCaml, you don’t lower structural source types to structural Wasm types. You would use a top type and encode a union, and do some casts.

CW: OCaml is not something that requires recursive structural types at Wasm level.

AR: don’t really care about mapping source level equirecursive types, but care about structural types in general. Talked to Sam Lindely, eager to compile structural recursive types in Links to structural recursive types in Wasm.

RT: even in module literature, don’t recommend this super exponential time

TL: extrapolating from what toolchains look like now, have a static linker for each one of these schemes, and a dynamic loader. Optimizers today work on a single module, if you want to run wasm-op on multiple modules, you will statically link them first.

AR: at least linkers and loaders need to understand this

CW: the convention of how these types get resolved starts at the toolchain

RT: current toolchains already do this yea?

TL: yes, we have static linkers, dynamic loaders. That’s the choice of each language team trying to compile to Wasm, how they want to extend.

CW: any environment that wants to do GC types need a place for custom loaders

TL: already need that with linear memory languages, can’t do Emscripten linking with just module linking proposal

RT: custom loader and precompute a lot, internally can resolve a lot

CW: we have to do a lot of this currently in JS, a non-web will need their own DSL for describing this

BT: even in JS, there is not enough reflection to be able to generate new type defs to link things, back to encoding everything in names and decode them

RT: or wrap modules in a layer, meta information that knows

BT: that extra meta information will be custom section with encoded type information, or names

CW: that’s exactly importexport comes in, you have a ready-made hook

BT: if you have enough info to generate types, you need to be able to import things like which field am I accessing. You can’t parameterize things over field indices

AR: good point about linear memory, this is a simpler problem. Maybe could implement purely in Wasm, fixup in start function

TL: thinking about thread local variables, weak symbols, things to implement real world C

AR: some of it is trying to reimplement existing linking solution

CW: isn’t that your argument for structural types? To replicate source structural types. 

AR: not saying it is overengineering, just illustrating other use cases

TL: j2cl not trying to replicate Java, just something that works. Anyone who is trying to replicate the full native linking story for any non-trivial language, has to do custom work and not rely on built-in Wasm. Also a big space of people trying to compile their language to Wasm, and trying to keep to Wasm linking. Not trying to be perfectly the same as source language.

CW: if you go too far the other way, you’re getting to whole program compilation anyway, then this is moot, since you know all the types

TL: good to focus on the concrete needs of users, what j2cl, kotlin, dart needs. No one is working on separate compilation now, so it’s tougher.

AR: One difference with memory issue is that, this is linking module that is language agnostic. With the types, you have more complex semantics for something that is language specific.

RT: string mangling still works for all these use cases

AR: you still need a custom loader

CW: there is a world where the custom loader is just a bag of exports, a dictionary where if you export something with a different name, it goes into it. With name mangling, how far does that get you?

BT: you won’t be able to parameterize type constructors that way, you have to mangle type arguments as a name, need to generate new names. Loader needs to decode names. Simple languages have generic types.

RT: you would say Array Array int

BT: you have to decode a string, to figure out what mytype is, decode, and bind that. Custom loader have to look at strings, decode them, generate new type.

CW: will want to see a sketch of this example

AR: a lot of complicated solutions, no one try implementing

TL: name mangling successfully used for many things, can follow up offline to see examples where it won’t work

CW: core mechanism is a dict that you can put and take names out. There may be source languages where it doesn’t work

BT: arrays in java are not simple struct, has vtable. Need to generate a new type. Need to decode mangled names, and generate new types.

CW: if you are compiling code that uses Arrays, you know which types, you can generate types.

BT: java no, unless you have the whole program

FM: in java, array is a nominal type that is generic

BT: java has funky array, covariant arrays

TL: should take this offline to look at this specific example

<slide on Diversity challenges>

FM: that’s done through coercion, we don’t try to share values across langauges

FM: multi-langauge interop is an unsolvable problem. Thought that Wasm isn’t trying to solve this problem in the context of Wasm.

AR: not talking about language speaking to each other, but just components talking to each other

FM: if you have a multi-langauge application, there is overhead associated with every different language.

RT: each component will have its own loader

LW: yea, local to that component

CW: and they don’t interact

AR: depends, don't’ know how you would make that work

LW: if you want to do runtime loading in components, and if you don’t have runtime instantiation type creation, you need to bust out loader stuff using JS API, maybe eventually we solve that by adding first class runtime instantiations

FM: can add rtt.fresh and ...

CW: seems to be the domain of interface types, everything is copied, no crazy structural type, just simple flat structs, seems like something that wouldn’t affect the design of core GC proposal, since we made inter-lang interp a non-goal.

AR: not about languages talking together, talking about centralization problem in the face of multiple centers

RT: if they are not talking together, the nominal ypes don’t need centers

AR: how do you set up multiple centers

CW: from POV of one centers, other centers don’t exist

TL: application level has global knowledge to set them all up

AR: this is not unsolvable, but not obvious

RT: prior work in this space of typed assembly lans show that the types are the things that are hard to get right, validating all access are safe is hard

AR: agree, even more reason to put into language and not defer

RT: things that can scale are the nominal ones

BT: nominal v.s. Structural aside, we need to put a place to put this logic, is it outside the VM, in userspace with superpowers beyond what Wasm offers today, what are those powers? It looks to me like moving this to userspace is really complicated

RT: only if doing separate compilation. Everything can be done with whole program

BT: separate compilation and expecting lowered code to interop, will never work right. Can’t emulate source semantics or platform. There will be a runtime system. Lowered code between same lang or different be type-safe or interop won’t work. Don’t think we are honest with ourselves about that.

AR: e.g. in Java with dynamic loading and JIT, yes that’s the case

BT: security model associated in source language, Java’s whole module is violated once you can link lowered code. Get around things that are not possible with just bytecode. Wasm doesn’t provide security guarantees that JVM does.

CW: in the past we have considered a virtue to keep Wasm small, push this kind of logic into a level above us, here, push into toolchain. To replicate C’s linking semantics, we pushed all logic into tools and tools-generated JS. Maybe in the future it is JS and module linking proposal. In other situations we would consider this a virtue, deferring how to manage types into toolchain.

AR: don’t think so, this is a genuine part of the semantics, what is type equivalence. Outsourcing a central part of the semantics seems not such a great idea. We have made different decisions in different cases, whether it makes sense to put things into engines or toolchains. We haven’t been totally consistent. Driven by other considerations.

TL: as tool author, prefer to keep tools simple. Our philosophy has been, we are pushing as much as cost and complexity into tools. Conflicting here, want Wasm engines to be simple, security risk there. When we have structural types, all this sharing, it is a lot simpler for producers. The performance cost of doing equirecursive cost on engines is too high.

AR: consciously not talked about equirecursive, that is an orthogonal question

CW: only if we have an alternative proposal

AR: next part of the presentation

BT: primarily think about engine complexity, moving this into userspace seems really complicated, considering all the layers, it will be even more complicated if this is not in the engine.

AR: if we don’t need equirecursion, what we put in engine is not complicated, really just hash consing.

CW: complexity of doing something at engine level that supports all lang that wants to compile to Wasm, will be more than any toolchain that wants to implement. Equi-canon is what engines will need to implement.

AR: structural recursion, not equi

RT: many examples where structural types are more convenient for languages, but for them we can use nominal types too, with some effort. Other problems, the flipside isn’t true.

AR: none of these claims are true

CW: should shut down this conversation, bounded quant is post-post-post MVP

BT: meta-level - need to align on shipping something that people will use. Many things down the road we can think about, and many iterations. We need to actually make progress forward.

RT: need to figure out the overhead making 5x slower

CW: mvp will have so many casts that it will be slow

FM: no point shipping something 5x slower

TL: recent perf numbers are better than 5x slower, not as bad. Agree to align on shipping something

RT: kotlin tried to do separate compilation and couldn’t get it to work

AR: yea could be true, but can have many reasons for that, doesn’t mean we should give up on separate compilation

RT: the issues were how MVP expresses and composes types, insufficient for them

BT: when you use type across module boundary, you can’t refer to fields, that’s missing

RT: importing bounded types…

CW: any reasonable MVP will replicate these issues, unless we go to the extensions RT talked about

AR: yea, have to add a lot of things to support that

CW: equirec types as implementing in target language, is also untested

AR: we have tested it to some degree, why we are having this discussion, not one has tested this (self-hosting)

CW: if we want to switch, we should test what we switch to

TL: have the theme for next meeting be alternative solutions, and multiple presenters

FM: are we talking about another two-hour session

TL: go back to an hour, be open to occasional two-hour

RT: have meetings more productive by having them be presented in issues first

TL: yea can share an issue, agree that’s helpful

CW: you can get into infinite regress by responding to each other. Would like to see examples of name mangling being insufficient

BT: yea i can come up with that example
"
gc/2023/GC-03-21.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 21 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: March 21, 4pm-5pm UTC (March 21, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Status checks
        1. Resolving cast annotation issues
        1. Bulk array operations
    1. Discussion: Implementation-defined limits ([#335](https://github.com/WebAssembly/gc/issues/335))
    1. Discussion: Text format ([#333](https://github.com/WebAssembly/gc/issues/333))
        1. Type definition abbreviations
        1. Dependent field names
        1. Instruction names
    1. Discussion: Field names in names section ([#193](https://github.com/WebAssembly/gc/issues/193))
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Sergey Rubanov
- Zalim Bashorov
- Francis McCabe
- Conrad Watt
- Nick Fitzgerald
- Manos Koukoutos
- Alon Zakai
- Jakob Kummerow
- Ilya Rezvov
- Adam Klein
- Ashley Nelson
- Deepti Gandluri
- Adam Klein
- Andreas Rossberg

### Status checks

TL: A bunch of little things on the agenda today. Status checks, Bulk array operations, I continue to work on the tests in Binaryen and have all the test infrastructure and have started writing and executing tests and finding bugs in my implementation. Hopefully it’ll be done by the end of this week or early next week. I’ll make a PR against the spec repo. Conrad, I know you said you’d work on the interpreter for that. I think the semantics I posted on the Issue haven’t changed, so whenever you have time to get started on that

CW: I should get to it at the end of this week.

TL: Perfect, sounds great. Thank you. Andreas has signed up to do the formal spec write up for that. I was hoping to check-in about resolving the cast annotation issues because we made those PRs a while ago adding the properties we want to maintain with type annotations, but we as far as I know we haven’t updated the proposal to reflect those properties. We’ve not added type annotations to the cast like we need to. Conrad, do you know anything more about whether Andreas plans to do that?

CW: I can pretend. Just to check, is there any idea that we might wavering on adding them or are we definitely adding these cast annotations?

TL: My understanding is the issue is settled, just need to update the documentation.

CW: I can poke Andreas on GH and tell him this is what we expect to be doing.

TL: I will take an action to poke him on GH. Great, would be good to close that. Any other status updates folks want to share before we move on?

### Discussion: Implementation-defined limits ([#335](https://github.com/WebAssembly/gc/issues/335))

TL: Continuing our discussion of implementation defined limits. Last time we talked we considered mostly the subtyping depth limit and we talked about the different tradeoffs that we'd have if we made it very large we’d have to fall back to a more than constant time implementation. And if it’s too small, then it’s more limiting. I think based on the GH info we got from OCaml, it seems like consensus is leaning towards setting the initial limit to be 63. If no one here wants to discuss that any further, then I think we can just call that final and make a PR and close this issue. Does anyone have any objection to setting the limit to 63 or have any comments about any of the other limits in this issue?

CW: I know I keep banging the drum, but when I last looked I didn’t see this, are we discussing limits on the stack size or the limits in initializer instructions?

TL: Yes, the last idea that came up was to set the max size of the global initializer as the same as the max size of a function.

CW: No problem with v8? I vaguely remember in global initializers you were allowed to have fewer consts on the stack at once or something like that.

JK: I’m not sure I don’t think we have an intentional lower limit. It might be that the implementation results in an unintentional lower limit when you run out of stack space. It seems unlikely real code would run into that unless you’re writing something that stress tests initializers. Even if there is a lower limit, it’s probably easier to fix it there than in functions because we evaluate initializers with an interpreter so that would be easier to change to some heap allocated data structure instead of using the real stack.

CW: I think I remember correctly, there was a limit in the thousands that isn’t present in functions. It’s probably not a big deal in the real world but if we want to close the loop totally, we may want to fix a limit that all the implementations know about.

TL: Can’t find where someone suggested the global initializer should be the same as the function body, so I’m either hallucinating or it’s in the last meeting notes. This discussion has dragged on quite a bit and we’re losing context. I think the proper next step is to make a PR with the actual proposed limits and if there needs to be further discussion, we can do so in a directed manner.

CW: In favor of forgetting this particular limit to get the others through the door. And we can come back to it.

JK: Programmatically, I expect that global initializers can have lwo instruction count and stack height. There is one use case, array.new_fixed but we have array.new_data and array.new_elem as well.

TL: But those aren’t constant expressions so you have to lazily initialize globals.

JK: Aside from that most global initializers are probably few instructions. Not strictly related to the GC proposal anyway.

TL: I’ll take an action item to make a PR with the limits we haven’t discussed in a while since that seems settled. We can focus the discussion on the remaining limits. Anything else someone wants to mention on limits? 

### Discussion: Text format ([#333](https://github.com/WebAssembly/gc/issues/333))

TL: We haven’t talked about the text format in a long time. I had an open issue where I suggested a bunch of abbreviations for the text format to make type declarations simpler. I’ve implemented this in the new Binaryen text parser that I’m working on. There hasn’t really been any discussion about it. My guess is most people don’t care that much about what we do here in the text format. Then there is a separate issue of how symbolic field names should work. Is it a single global flattened namespace for fields or can you get dependent naming where it’s a two-level namespace so that two different structs can have fields with the same name? For debugging wasmGC it’s currently fairly primitive in that we are dependent on the text format to provide our debugging experience. We don’t add much on top of the text format. I would lean toward having the two-level namespace for struct field names to keep them shorter and unprefixed. Which would make the debugging as it exists today much better. This is strange because the text format is supposed to be just for tests but we do depend on it for providing a basic debugging experience. I think it’s worth doing.

CW: It’s true the text format was created for the “view source” use case so in that sense, it’s the same spirit.

JK: We allow functions to have locals with the same names, so an analogy with that, we should allow structs to have fields with the same name. One remaining issue about text format that we need Andreas to discuss is the discrepancy between the implementations and upstream docs about the “_canon” suffix on certain instructions. 

TL: Any other strong opinions about whether we should have the canon string in our allocation name? For the text format, it doesn’t affect semantics in any way.

ZB: It doesn’t affect semantics at all?

TL: Yeah, we should discuss this with Andreas. The quick version is the long term future once we add all the post-MVP things we want to add to wasm, then having canon in the names makes sense. So it’s mostly philosophical disagreements about how to name things I think. We can leave this aside for now. Andreas just showed up!

AR: Sorry, I forgot about the clock change. 

TL: Should have posted an issue notifying about that. Let’s backup. Do you have a status update on the spec test?

AR: No, I haven’t made any progress because I’m blocked on CW doing a review of the function ref proposal. 

CW: Oh God, this is the semantic type change. I’ll get that done this week, I’m sorry for forgetting. 

AR: Right now, it doesn’t matter because I won’t get to it for the next 3 weeks because of the OOPSLA deadline. But if I could start working on it after that, that would be great. Other than that, I don’t expect any particular surprises there. Most is straightforward as far as the spec is concerned. Biggest part is the type recursion and all that. That and precise language.

TL: We were just talking about the text format. In particular, this issue (linked above) which mentions the abbreviations I proposed for type definitions and also the two-level namespace for struct fields. Just before you joined Jakob had made a connection between struct fields and local names, where we support multiple functions having locals of the same name across functions and we could use the same for structs. And I was saying our debugging was heavily dependent on the text format, so having the names and being able to share them with people would be helpful.

AR: I don’t think this is similar to locals at all because they are really local. this would be a new thing. Symbolic names so far. There is no such thing as dependent lookup at all. This would be a slight complication to the whole symbol resolution. The other concern is that we if we ever want to leave the desire open to potentially move type annotations then this would not be future proof for that. This would navigate us into a dead end with respect to removing type annotations. At least in the text format, we would need hacks, it’s not clear what an elegant solution would be for that.

FM: Why does having local struct names affect removing type annotations?

AR: Because then you have no syntactic way of knowing which scope to look them up in. The type annotation tells you lookup in this type definition to look up, but if you don't have that, you can’t do it. That is not how the symbolic names work right now, they are purely syntactic, you don’t need type info to resolve them and I’d like to keep it like that because otherwise you have muddling of the phases. 

TL: Which phases?

AR: Purely a parsing thing, Sugar during parsing wouldn’t work anymore if you make it dependent on type information. You’d have to have in the spec a specification form of AST with symbolic names and typing rules that tell you how to transform that in the AST without names and things like that. So significantly more complicated.

TL: I appreciate it would complicate the text format to do this. But I think there is real value, because we have no plans to do anything better than display text format in dev tools. You get that or source maps, your choice. No plan to do anything richer. Actually making this slightly more readable has a real devEx impact for the foreseeable future. 

AR: Isn’t that the job of the name annotations actually, the name section. 

TL: Yes.

AR: So then it doesn’t have to be directly related to what we do in the text format then.

TL: When you go from binary to text, the names of the sections says what names to use in the text format, but it still needs to be valid in the text format.

AR: But you could just automatically prefix them if you want to have a valid output then that would be very trivial

TL: But you have these fully qualified Java names to start anyway, so if you prefix your field names with the giant fully qualified text names, there is no way you can read

CW: No way to disambiguate is to append an underscore or something to the second one.

AR: Lowkey ways of resolving this I think. Because of what I said earlier, if we ever wanted to introduce annotated instructions with field names, and I think the only way to make that work would be to require in the text format still putting the type annotation there. Drop it from the binary format but not the text format for these instructions at least. So in that case, you would still have the same notation overhead that you’re complaining about. You’re not really getting rid of that in that case.

TL: New version of get and set instructions that don’t have the type annotations would still have the class name and the field name in the text format. So having dependent naming lets you have your instruction, class name and field name, without having to repeat the class name as a prefix of the field name. 

CW: Do we already require a type derivation when going from Binary to text?

AR: If you round trip, you forget the symbolic names anyway. This is only an issue for symbolic names

TL: They get round tripped through the name section in the binary format.

CW: That seems like a problem for this vision. 

TL: I don’t think so, because the unannotated instructions for the struct.get and struct.set would be different opcodes. So you’d know how to round trip that to the binary format. You would need to track the types to emit the right text, and that would be an in-our-faces consequence of removing the principle type properties, which we would have to do to add these instructions.

AR: Seems like an entangling of concerns in a way.

CW: Is it definitely not a viable solution in the case that the name section has duplicate fields to append a disambiguation symbol like a little hex suffix?

TL: It’s possible but every time we do that our devEX gets worse. And it’s quite bad already.

JK: Decoding a name section becomes a lot more complicated because you can’t just do one off lookups to get one field name of a struct, you have to decode the whole thing and store them in dictionaries instead of simple arrays just to check for duplicates in the names

AR: My feeling is regarding tooling, you are going to buy yourself some pain one way or another. 

TL: For Binaryen, and this is not universal, we have all the type information anyway. It wouldn’t matter for us.

AR: In general, I like to minimize ambiguity and that would be if you don’t have dependencies you need to resolve. Seems simpler on this level and having something more user friendly I’d have as a tooling concern, especially since this isn’t a user facing. This isn’t a language people want to code in.

TL: v8 team in general can take an AI to check-in with our dev partners working on debugging and see how bad it would it be if we had to prefix or suffix these field names. They might say we can do this or this is the end of the world, in which case we can discuss further.

AR: SGTM.

TL: We’ll get user feedback there.

JK: j2wasm generates field names that contain the class name anyway, if i'm not mistaken then nothing would change for them, but I don’t know offhand about our other partners and what they are doing.

TL: If they are already doing that, that would simplify things so we’ll check-in.

AK: Kotlin folks are on the call if they want to say anything here.

ZB: I don’t remember the exact names we use for GC things. 

TL: Have you thought about the debugging experience in devTools at all. 

ZB: Definitely short names is much better for debugging we need to debug over ??? code. I have seen variables, it seems to me unusable for usual users. It just shows deep internal things of GC structures and I think usual users need something more high level. More inheriting? Hinting??? Variables showing deep structures is even deeper than original GC structures and sometimes it’s inconvenient to use.

IR: Generation for GC types could be beneficial could be helpful for non JS reflection if you want to show something readable on the JS side. When we read types of GC functions.

TL: We’re in this place where everything to make the devEx better, but the devEx is so bad anything we do for this particular problem might not matter too much.

ZB: I just looked at what Chrome shows for our code and it shows short names partly because we generated such names.

TL: Okay, let’s dig into details offline. Thanks Zalim that’s very helpful. Lines up with my understanding of how things are working. Andreas, those type definition abbreviations I had suggested in the issue, do those sound good or are you trying to minimize the # of abbreviations we have. What’s your take there?

AR: What are the abbreviations here? 

TL: Basically similar to the ones for parameters, where you can say parameter and list a bunch of them without each having to say parameter. This is the same thing for struct fields.

AR: I thought this was already the case, I’m pretty sure the interpreter already implements that by the very analogy you just mentioned.

TL: Might go further, you might not need to say field at all. I’ll write up examples in this issue so we can look at it and see. 

AR: Saying field is annoying in the same way parameter is annoying, irregularity if you want to bind the name if it’s there.

TL: A lot to write

AR: I know, I’ve omitted from slides as well. That’s the only thing you suggested here? Otherwise it’s the straight syntax?

TL: pretty much

AR: I think that matches what I implemented.

### Discussion: Field names in names section ([#193](https://github.com/WebAssembly/gc/issues/193))

TL: JK had this issue that proposes that we add struct to the name sections. Thai is orthogonal but it’s just should we put them in the name section. I think the answer is yes. So the next step is the PR documenting so we can close the issue.

AR: I agree.

JK: The only logical wrinkle is there is an extended name proposal that has been asleep for years and we are deepening on that because they are occupying fields 4-10 and this would take the next. If GC ships before the extended name section. 

TL: I think we should do what we do for opcode prefixes. Whoever gets standardized first, gets the prefix. Ignore the extended const proposal and if they need to adjust their prefixes, that’s fine.

JK: We also implemented.

TL: Oh we implemented.

JK: I think we should assume it will be implemented already and work around it.

TL: Oh okay if it’s implemented 

AR: Coordinate with the author of that proposal and get the status. What do we do if it’s orphaned? Who is owning that?

TL: Andrew Scheidecker.

AR: Okay that’s orphaned. 

DG: v8 implementation we have looked at moving stuff around if it’s not merged, maybe that’s a thing we should consider doing.

NF: wasmtime implements the extended name section, fwiw

TL: We can reduce our implementation burden by not taking an opcode for that.

AR: Maybe whoever takes over the field names for extended consts, can take over the proposal. We need a new champion, not sure how we’ll make progress.

TL: JK can you do a PR documenting the extended names and field names

AR: Did you already do the status checks?

TL: Yes, wanted to talk to you about the cast annotations, do you want to do a PR to update that?

AR: I should do that.

TL: That would be great. *repeats bulk status update*

JK: Another logistical headsup is we're going to have to use new opcodes so they are different for cast annotations. We have some opcodes that were freed up from the last restructuring we did. So we can pick a consistent set of binary encodings that won’t clash. The opcode space will be cleaned up int he final reshuffling.

AR: If we do that, there will also be a time window when they are forced to break. Unless you move all your partners.

JK: We assume one breakage when everything is final. Between now and then, it has been working pretty great for that. It has been working to maintain backwards compatibility. In theory there would be a way to do that if we switched to a new prefix for a final wasmGC, that would be a new thing, but there would be a prefix for big proposals.

AR: Resolving FF for that kind of purpose, experimental namespace. Let’s not get into that. It makes sense.

*back to discussion about _canon in instruction names*

TL: None of the implementations use _canon. I dont know if you saw Andy Wingo's blogpost about compiling Scheme to wasm. He dedicates multiple paragraphs to the “ghost in the instruction set”. Has to get the history right and generates confusion. I think we should remove them, they are confusing. 

AR: I’m fine doing that. I should look at Andy’s post, I haven’t seen it.

JK: There isn’t much cost to having alias in the text format, so we can reintroduce _canon if needed in the future when there are other instructions that could create confusion.

AR: The problem is that would be the wrong way around, you don’t want to use up the current name.

CW: It seems like we have agreed to remove it, so let’s just be unhappy about it and let it happen.

TL: Anything else?
"
gc/2023/GC-02-07.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 7 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: February 7, 5pm-6pm UTC (February 7, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Consistent rationale for type annotations ([#324](https://github.com/WebAssembly/gc/issues/342))
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Slava Kuzmich
- Conrad Watt
- Asumu Takikawa
- Luke Wagner
- Andreas Rossberg
- Adam Klein
- Alon Zakai
- Ashley Nelson
- Manos Koukoutos
- Francis McCabe
- Ryan Hunt
- Matthias Liedtke
- Zalim Bashorov
- Igor Iakovlev
- Ilya Rezvov
- Deepti Gandluri
- Jakob Kummerow
- Ben Titzer

### Discussion: Consistent rationale for type annotations ([#342](https://github.com/WebAssembly/gc/issues/342))

TL: To recap, we are continuing a discussion about type annotations. Everyone agrees that we should have a consistent method for figuring out which instructions have type annotations. The question is, what method should that be? And what’s the motivation for that? I’ve talked with colleagues on the v8 team and we agree that a consistent method here would be great. Our preference is to simply remove the type annotations, it would avoid a bunch of these tough questions and be good for code size. And any tool that needs types can recover them with a single pass due to our validation design constraints. Andreas I saw you respond to that. Can you summarize?

AR: Three options at this point: 1) reverse decision we made last time, and remove all the annotations. 2) ignore what we decided last time and don't do annotations this time. 3) add these annotations on cast instructions. (1) seems like reopening a long and painful discussion, and if we reversed that we'd open a couple of issues we'd closed (e.g. unreachable code). (2) feels bad to me since we have to ignore the reasons we decided to add the annotations last time. (3) isn't ideal, but seems the least-bad to me. It's a bit more cost added to the cost we've already agreed to.

TL: For the path of just biting the bullet and just adding the annotations as you put it. If we can arrive at something consistent, then great, I would be glad to close this discussion. My concern is that we don’t have a consistent rationale that backs up our choices of what to annotate. Last week we talked a lot about principal types so I took a look at the instruction set and saw that if we actually want a principal type for each instruction, there are a bunch of annotations we want to add. So existing polymorphic stuff wouldn’t fit the rationale.

AR: To be more precise on what it means to have a principal type: you can express polymorphism with an unconstrained type variable. In the case of drop, you can put in any type there, there's no additional constraint. What's different for these other instructions is that you have some kind of variable, as well as a constraint on the side, it cannot be arbitrary. For accessors, you have to deal with the n-th field of some structure, and it has to be a subtype of something-or-other, and this makes a qualitative difference. It's something like the difference between type inference, and type inference in the presence of subtyping. (restated version of [this comment](https://github.com/WebAssembly/gc/issues/342#issuecomment-1420748058))

TL: In general, sure, absolutely. Specifically for Wasm, I have a hard time seeing that it matters, the difference between principal types up to unconstrained type variables, and principal types up to, you have to do more inference for each instruction. But it’s all linear anyway, so what’s the difference?

AR: Not just that you can do something linear, and solve the problem. The more general problem is you want to know for certain optimizations, when you do code refactorings, like constant propagation or subexpression elimination or whatever the corollary is in Wasm. It’s not sufficient to know the type of something in that specific context. You actually want to know the most general type you can assign to it, that might influence how much you can reuse that part. So how general this sequence of code is you are thinking of here and if you can outline that and call it from different places or the other way around, you can inline it. Inlining you are actually duplicating, so that doesn't matter. 

TL: For outlining, you are giving it a concrete signature type so it doesn’t matter, you have to instantiate variables.

AR: Basically when you arrive with type variables. We might have polymorphism or generics at some point, that aside it basically means you don’t have to care in some of these use cases if there is a type variable remaining. You can just put in whatever you want because all the use cases don’t care potentially. Whereas with the others, you still have to deal with all these constraints on the side. These use cases in terms of practical use cases may seem hypothetical but having talked with static analysis folks, it’s something they care about, keeping this analysis. I think I mentioned that last time, one thing they repeatedly told me last time is they were glad we didn't do overloading, which is like a simple version of this problem. And now we're discussing a more complex version of this same thing. 

JK (chat): Is anyone going to do such analyses/transformations on the Wasm instruction level? Wouldn't any serious tool use its own custom IR anyway?

AR: That depends on what your tool is trying to do. If it’s on the Wasm level, then sure it will use the Wasm instruction set. If you want to transform Wasm to Wasm somehow, for whatever reason, then why.

TL: To give a concrete example, Binaryen does nothing but translate Wasm to Wasm and it kind of has its own IR but really tries to reuse Wasm as much as possible and it’s very deliberate about where it departs from Wasm in its IR and one of those places is it deliberately discards all of these type annotations because it would rather not have those extra type constraints. It wants to discard the type annotations so it can deliberately recover the most specific type.

AR: It’s a common pattern with typed IRs, where you have to produce something typed, that throwing out the type info in the middle is something you might regret because you might need the type IR later. 

TL: And we certainly do require type information but we recover it with a linear pass whenever we need it. There is a very concrete example of a producer doing this Wasm to Wasm translation that we’re talking about and that producer does not want the type annotations.

AR: It is unfortunate that we don’t have the folks doing this kind of thing to explain their situation. I can only relay what I’ve heard in speaking with people like that. 

TL: Anyone else like to chime in here?

AK: I want to raise binary size, it sounds like we’re getting some interesting constraints here in wasm. On one hand, a compact format for transmitting optimized apps over networks. On the other hand, we’re trying to use it as an ideal IR for programming transformations and those sound like different domains to me. I think we could benefit from working out a framework for deciding what the priorities of constituencies are. There are lots of different ways to consume Wasm, it seems tricky to pit these things against each other. 

AR: It’s a fair point. It’s definitely the case that WebAssembly isn’t designed to be an IR itself. IIRC that was an explicit non-goal in the beginning. LLVM for example would make different choices w.r.t space and things like that. That being said, for most static analyses you don’t want to have to convert the program to an IR first. I have experience in this field and I know how easy it is to make things hard due to sloppiness.

TL: It’s not sloppiness for sloppiness sake, it’s to save bytes on the wire.

LW: I have a question, is this overloading we’re talking about? Overloading if i understand right is the type context I’m in changes the context. Polymorphism is we do the same thing regardless of the type. Overloading is polymorphism is about subtype bounds?

AR: You’re right, overloading is a slightly different thing with an operational meaning. Overloading means this additional thing.

LW: Potentially our type analysis should be more complex.

AR: I think we didn’t want overloading for the reason you’re saying, we view it as a different operation. But it turns out this is a good thing to avoid for another reason, because it makes the type analysis level more easy. And with respect to that, it is in the exact same class as the thing we’re discussing now. I’m feeling a bit uncomfortable because Ben isn’t here and he was a particular vocal proponent of having type annotations. So what are we going to do? We are discussing reversing the decision wouldn’t be fair without Ben here.

TL: Agree, but I think there is space to understand the options and get on the same page. For option 3, add more type annotations, I’m concerned. How confident are we that we haven’t broken this with our existing standardized Wasm? Will we find that oops this standardized instruction doesn’t fit with the type annotation? Will we be able to explain this rationale to anyone else? I think explainability is important for rationale. Why do I have to send all these extra bytes over the wire? I should be able to explain why it was important. Perhaps offline, it would be good to have the crispest possible statement of this design rationale and double check we haven’t violated it somewhere else, double check it explains all the annotation choices we’ve already made. And even then, how explainable will it be?

AR: When I wrote the spec, we did this appendix for properties and that basically contains type soundness and I called it properties because there are other properties that might be interesting. Which would have been the version of principal types. But I’m saying this is something you can formulate precisely and not something difficult to prove, just induction on the type. And for most of the rules, it’s completely obvious that it holds so I’m happy trying to do that. And then the way you could think of how to phrase this formal statement in layman’s terms is for every instruction you can give basically a type that is in closed form that describes what the type is with some type errors. But that’s all you need, you don’t need conditions on the side. That’s the type of type property I would accept here.

TL: Curious to hear from other folks who haven’t spoken up yet. 

CW: I have a preference for adding the type annotations. I definitely believe there is a world in the future where we can come up with the variants of the structure without the type annotations. I think there is also a distinction between br_on_null/br_on_non_null and on_cast instructions. Which is br_on_non-null is not trying to be polymorphic on and you know the input is not null, you can refine the type a lot more. There’s no point in emitting the instruction.

AR: If we have the type annotations the typing rule becomes more simple, even simpler than the discussion I wrote. I realized after that you can get rid of the common top-type? If you have a top-type, you only need to know one is the subtype of the other. So this fairly complex condition Conrad worked out for propagating nullness would go away. And I’m scared of that condition because it has 8 or 10 different cases and shouldn’t be that complex. There would be just one subtyping check and that’s it.

TL: I admit this would be a great outcome.

~ Ben Titzer joins ~

TL: Hi Ben, you came up before when AR mentioned that removing the type annotations would be uncomfortable without you here. Most of the discussion hasn’t been about removing, it’s been about rationalizing adding more type annotations. Do you have new thoughts on the subject you’d like to share?

BT: For me it’s not about in-place interpreters, it can use side table entries and probably will for speed anyway particularly for struct.get. But for baseline compilation it does not model the complete types, only kinds are necessary so if we remove the type annotations then it would be necessary to model all the complete types in the baseline compiler And one point I made about keeping the type annotations is for other tools that process bytecode, static analysis tool that doesn’t necessarily want to completely replicate the type annotation algorithm. They all benefit from type annotations. Just repeating and reminding folks of my points.

TL: Possible way forward. We could give AR an AI to write a crisply stated design rationale offline and make sure we haven’t violated it so far. Then we could add new type annotations in accordance with that rationale. After due diligence, we could add the annotations and settle this. Right now, that’s looking like the least path of resistance to get this resolved. Would anyone prefer a different course of action besides everyone who would like to remove the type annotations for code size reasons?

AR: I should add this is the most conservative, because we can always remove type annotations for code size reasons, but adding will not be possible, ever.

FM (chat): This seems like a case for having a criterion: what is more important: wire size or making life easy for generators

TL: This gets back to what Adam was saying, we have a bunch of different communities of Wasm who have different design priorities and it would be helpful to come up with a framework to navigate that. That being said, in this particular case, despite the wire size concerns, it is true that this does seem like the more conservative choice. We could also add unannotated versions in the future like Conrad said.

AK (chat): Some prior art on criteria from the w3c: https://www.w3.org/TR/design-principles/#priority-of-constituencies

BT: For the input type to cast, if we moved to Any as the input type and didn’t require the validator to reject invalid casts. Would that solve the problem? So impossible casts, like a cross type, where the input type is not a supertype of the casted to type

AR: One thing we noticed is that there is a similar problem with nullability, not just the heap type involved. So that also means we need to annotate on that otherwise we lose this kind of principality I think..

CW: You could save a byte if you have a hardcoded case from Any. I need to think about if that works because you could have a bit free to say if you were nullable or not.

AR: Yeah, so basically you need to know it’s true that it would be enough to say what is your top type, currently we only have three. But it’s not clear that it stays that way. If we do what Ben just suggested, what would that imply? I need to think about that, it might work.

CW: I think it would still be a problem with br_on casts. I need to think this through.

AR: They would just be unrelated right? Means you can’t take that one path. I don’t think it causes a problem but we need to think about it more carefully. In that case we would need only the null annotation for that.

CW: (note taker missed this)

AR: If we don’t need the top type then we could roll the instruction into the opcode itself.

BT:  I think you can figure out the top type from the annotation.

CW: You can but the proposal was not to need the annotation in some circumstances, right?

TL: The cast annotation, the one that tells you what the cast is supposed to do 

AR: It doesn't work to use the top type there, the reason is the br_on_casts. If you do the top type, then you lose the type information on the top type so that doesn’t work. You want a precise type there so it doesn’t work. So that the thing remains on the stack and you want it to be precise. So it’s not good enough to have a top type. 

TL: Anyone have objections to continuing to resolve this offline with a tentative goal of coming up with a rationale and adding the extra annotations? Okay, then that’s what we should do and let’s plan to have this resolved before the next meeting. AR, please take up the AI to have a precise rationale in the issue and we can all take a look at it.

AR: Sure, I’ll try to do that.

TL: No other agenda options, but an update on bulk_array stuff… 

### Bulk Array operations

TL: I checked with Dart and J2CL (Java) for partners and it sounds like everyone is happy for now with the minimal set of instructions, so I guess it would be helpful to clear with you all what that minimal set of instructions should be: array.copy, array.fill, and the question I have is would folks be unhappy or consider this an insufficient set of instructions if we skipped array.init_data and array.init_elem. The rationale for skipping is literally no one is going to use them. No one is going to use them because for the wasmGC languages, there is no reason to have data segments at all because they are not using linear memories. And anything they’d put in a data segment or an element segment, could easily be put in an array and they could just use array.copy.

AR: That doesn’t make sense to me. Of course you still have a data segment, my compiler when I compile string literals, I put the strings in the data segments, because the data has to come from somewhere right. And that’s why we introduced array.newFromData or something like that. So that is definitely useful, so you will have data segments, even with GC for that reason. And from there, it’s not hard to imagine you may also want to update an array from some segment. Basically the data segment can be used for both GC types and memory.

AZ: Why would you prefer to put that static data in linear memory instead of in an array?

AR: You don’t put it in linear memory, but you initialize the array from the segment.

AZ: You can initialize it from another array in a global.

TL: And that scheme would bottom out with array.init_static where you take the values directly from the stack.

AR: If you have a large string, you have to construct a gigantic array that puts every operand on the stack. You have to bootstrap it from somewhere. You want these array literals to be constructed from somewhere, not by each byte. 

ZB (chat): we are using array.new_data in Kotlin.

TL: I’m convinced having array.init_data is useful if you want to reinitialize any arrays, you want to initialize them from the data segments for the same reason you might create them from the data segments, if you want to reuse the object for some reason. I’m still pretty sure no one will use array.init_elem because there are no size benefits there, because when you create an element segment, you have to say what each thing is anyway. It’s not a compact format like the data segment. But it would be oddly asymmetrical to have array.init_data without array.init_elem. Okay so the full set is array.copy, array,fill, array.init_data, and array.init_elem. 

AR: Sounds good.

CW: Question about array.init_data: I know this is an awful thing that has come up before but would there be people wanting to use it as a constant expression, for example a global init? And then dealing with the fact that the data section is in the wrong place. 

TL: I think we can punt on that like we are punting on the same problem with array.new_elem.

CW: And we have the same problem with stringref.

AR: I think the problem only exists with new_data, not init_data, because that wouldn’t be a constant expression, it’s mutating what you already have. 

TL: If no demand to be a constant expression, then it’s moot.

AR: Not a constant at all, it’s mutated.

CW: I got confused between init_data and new_data.

AR: Confusing but too late to change that.

TL: copy_data or copy_elem would make a lot more sense, but yeah too late. As we said last meeting, I volunteered to do the tests for those instructions, AR you volunteered to do the spec work, and CW you volunteered to do the interpreter work. No rush, let’s wait for validation from v8 and our users that this is going to be useful to have. And then we’ll do all the other work soon.

TL: Anything else? Otherwise we can end early.

BT: I filed an issue on the spec repo for test locals which I had mentioned last time so if AR can take a look at that issue. 

AR: Yeah there is a bit of discussion from TL and me.

TL: Thanks for filing, look forward to discussing that further. Let’s go ahead and close this meeting. Thanks for the progress, see you in two weeks. And thanks to AN for helping with notes!
"
gc/2020/GC-07-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 14th video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: July 14th, 4pm-5pm UTC (July 14th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: criteria/objectives/requirements for linear memory GC
1. Closure

## Meeting Notes

### Introduction of attendees

* Adam Klein
* Ben Smith
* Daniel Wirtz
* Emanuel Ziegler
* Francis McCabe
* George Karachallas
* Jakob Kummerow
* JP Sugarbroad
* Keith Miller
* Ross Tate
* Ryan Hunt
* Sabine
* Syvatoslav Kuzmich
* Thomas Lively
* Wouter Van Oortmerssen
* Zalim Bashorov
* Zhi An Ng

### Discussion: Criteria/Requirements for Linear memory GCs

FM: The number one criteria that I would like to focus on is popularity, using the TIOBE index. For linear GC, the critical factor of being able to resolve cycles between the host and the modules. If we don't do that, we're not really solving the problem. There are some requirements that don't seem that applicable. If the host is not going to do much for GC… but if you're deploying a language on the web and you can't resolve the cycles, then everyone is going to have the same problem.

FM: I've thought about this -- the first question is whether we'd want to support it, and if we did then it would be how to handle cycles. Can we design features such that a language implementer does not have to use the shadow stack to use their own GC?

FM: There's another thing that's worth talking about: I've heard people say that it needs to be competitive in performance, especially w.r.t. comparisons with JS. It is important, but it's putting the cart before the horse. You can view the programming language as a guest in the browser, and guests should behave themselves. Ross and I have been working on stack walking, this would be part of it, but it isn't solved by our proposal.

KM: related, is there an interaction with safepointing of various browsers gc? Browser GCs for the most part are fully concurrent, anywhere anytime, not clear that any random GC can respond to requests to scan itself at any time. The other thing that would be good as a criteria, for all GC proposals, will be a shame if we implemented Wasm GC and JS still seem a better target for compilation. Can consider this more as we discuss more. If we get to the end of the road and we don’t have an answer, then we have done a disservice. A lot of downsides to compiling to JS, dynamic, overhead.

RT: I should also point out that performance isn't the only reason to compile to something beside JS. JS has monkey-patching, it removes their abstractions. we shouldn't have something that's a worse target than JS, but performance isn't the only thing.

KM: if we ended up with GC being worse for some particular language that they end up going to JS, then we definitely done something wrong. Those are things against JS, and even with those, they decide to go JS then we would have failed.

FM: You're predicating failure before we've started.

KM: I'm predicating one failure -- there's a huge range of outcomes, I'm trying to describe a high-level goal, that for as many languages as possible, to make it better to compile to wasm than to JS.

FM: when you say any language, that’s a very difficult and amorphous target.

KM: I changed my perspective back to ""as many languages as possible"", we can't enumerate all programming languages...

FM: should be countable

KM: quantum programming language?

FM: any discussion in the various proposals that makes you think that there’s a risk associated with this

KM: Of preferring to compile to JS?

FM: ya

KM: nothing concrete, if the overhead of interacting with the host GC causes large pauses, that’s something that has been optimized a lot, entire benchmarks around preventing GC pauses, chrome + safari have concurrent GCs, the entire purpose is to prevent GC pauses. If linear memory GC provided can do that, interact with it in some way, it will be great.

JS: I'm not sure if there's another proposal aside from Wouter's that shows a linear memory GC?

RT: been thinking about the problem, hoping to ask questions and get some insights into what the problem looks like more concretely. Cycles, turns out different cycles can be solved differently. Understanding this in more detail will be more useful.

JS: I'm also interested in knowing what is a pointer, where small integers are indistinguishable from pointers.

RT: the high level is that the application is responsible for that. The questions I came up with was: things like Keith brought up. They run on different timelines, linear memory gc will do it’s thing on the application timeline, at the same time at the concurrent gc, a lot of algorithm don’t work so well when different parts of gc work on different timelines, outdated information. People have brought up that there currently is problem with cycles happening. Can someone give me a more concrete picture.

KM: I don't know every conceivable cycle in browser -- the ones I've fixed are wrappers…

RT: concretely with Wasm having references in tables causing cycles

KM: Right now the DOM has its own collection strategy, it is a reference counted garbage collector (or some other) and JS has its own too. What goes wrong, is if the reference count edge anywhere, it's a root, so if you see it your'e stuck. One solution is to try really hard not to do that, which is Safari does AFAIK. The other one is you have cycle detection, I think that's a better answer for a browser with cycle detection. They generally occur because you have wrapper objects that reference something higher up in the tree, and it makes a loop, and when you detach the tree it creates a hard edge that can't be collected. It's more tractable with multiple GCs, but I think someone from Google can probably answer it better.

AK: chrome has spent many years trying to fix this, we have cross tracing gc, the solution was basically have 1 gc.

KM: What were the kinds of issues?

AK: yea, the two graphs didn’t know about each other

KM: It's easier because you have two explicit GCs, so you can solve the safepointing with one well-defined set of GCs, as opposed to another GC that don't know about each other, where the browser and the application can't work together.

FM: that sounds like an obvious, there’s a fix in there, we add a safepoint instruction to Wasm that we would rely on.

KM: You could probably do something like that, but when the browser scans … at least for us, we can mark objects without safe-pointing, we only need a safepoint to do the flip.

RT: few ways to take the linear problem and break down solution strategy, the most complete one would be likely have application provide the host gc some way to navigate the application’s linear memory. Whether that’s practical, is an important problem, but it’;s one strategy. Another one is how to specify information such that browser GC can interpret it without running custom code, some sort of handoff between browser and Wasm, communicate live objects in this way, challenges here due to distinctions in timeline and spirals, maybe it’s an imperfect solution that can work reasonably well for coarse applications, things where applications don’t tend to have direct references. Two high-level, more complete solutions. Less complete one is to not collect all the cycles, just do the easy cases. Tell the application that we’re no longer using the handle anymore, and Wasm removes reference from the table.

FM: The last one sounds like resources...

RT: what keith mentioned with the roots, just linear memory, has not externrefs, refs are all in the tables, a browser can say, ignore linear memory, just use table. The issue here is, application is responsible for clearing table when it doesn’t need refs anymore. It can do that for its own GC. Problem is that these programs are giving out callback information, their GC then have to use those as roots, and maybe outside doesn’t need them anymore, but GC doesn’t know, so not clearing those up. Give outside world the callback information, and have the outside world notify that the info is not needed anymore, so it’s no longer a root. This will clean up simple cycles, and could be the main form of cycles.

FM: If you have an event listener in your DOM, which calls a wasm function, and that node is GC'd because it is cut out of the graph, there's no way of knowing that the wasm function isn't needed...

AK: this is why we added WeakRefs to JS, for this case. We knew that this was when there are no cycles through the linear memory.

RT: You're finding that it's not sufficient?

AK: we’re still beginning that journey, Chrome shipping that in M84, don’t yet know it is sufficient. Sufficient for use cases where it’s simple, application doesn’t have GC, just vending JS wrapper for objects. But in internal Chrome discussion, same thing that Keith mentioned came up, people who built unified heap asked if we won’t have the same problems that are analogous in the browser.

FM: The answer to that is yes, isn't it?

RT: high level question to consider is do we want to set it up such that applications have infra to say what weak refs are, and if you don’t do that, then there’ll be a memory leak. Or do we want to figure out how to do the more advanced ones, where GC interact with each other in some coordinated way, so you can GC through multiple spaces.

KM: With weakrefs… it wouldn't be performant, but can't you do all of this already, as an experiment?

RT: played with that, there are a lot of cases, you can get these spirals where… weakref to your thing, then ref to table, and that ref is what is keeping weakref alive

KM: You can have cycles, but you can experiment with applications using the handle mechanism. 

RT: roughly what i was describing

KM: It has a different collection timeline, which is only in the run loop. But we wouldn't do something different anyway. But it seems like someone could build an application with this form and see what happens. I think it's doable today.

RT: not performance considerations, but semantic. How do programs communicate these kind of information? Without having to run the program, you can tell which ones it will work for. Do we tell people that’s the only one we will support, so make sure programs work well with that. If you want something more advanced, use GC.

KM: I worry about telling people that too much. I expect people will use their own use case, and find that it works in one browser, but not in others, or not with a new browser GC, and we'll be trying to solve the compat problem there.

RT: all browsers will still have to perform the same way, application isn’t able to give the info browsers...

KM: I think in this case all browsers will probably leak and look bad here equally.

RT: need much more advanced, one of the two strategies, application give browsers info to do GC itself, or you have some sort of handshaking back and forth protocol, tried sketching, non-trivial, sharing information, might be do-able.

FM: This sounds like a MVP-type thing. We could start with weakref solution, and then let another generation solve the harder problem.

RT: have to figure out if it is separable enough, would it change how we design the GC proposal? Probably no?

FM: don’t foresee that the same tech, host gc and linear gc, I don’t think that’s a requirement. Two kinds of styles, someone wants to bring ocaml to the web and use their own GC. You can do that with these tools we provide. The other one is ditch your own GC and use the host. There may be overlap in the future but my guess is not significant. But… as a total offering, we will offer GC to language designers, you can use host provided GC, your data structures have to fit our pattern, or do you own GC, here’s some tools that might work for you. As a group we can say, hang on a min, linear memory is way more important than host gc, i’m suggesting that no we don’t, this is more a MVP. Should be Minimum Awesome Product. If people are ambivalent about supporting linear memory gc, then having a simple thing that doesn’t… integrating the timeline of GC strikes me as really hard to get right.

BS: we had a lot of discussion about how to deal with cycles. This has been on people’s mind for a while. Wondering if there are other requirements. This technical requirement is the biggest one, but are there other requirements we can imagine?

FM: channelling keith a bit… the other part of this would be… if you are a language with your own GC, how natural a fit would the already existing GC be over what we do. The better that is, the easier it would be to port languages onto Wasm -> more adoption. Having a solution that is simple and minimally invasive to the language will foster adoption.

BS: in the past this is what people have been describing as the benefit of linear memory gc, more closely fit existing models.

Sabine (chat): Side note: If popularity of languages is a criterion, then we should use better data than the TIOBE index. (If you are not aware what TIOBE index actually is, do a web search). Better data can be extracted from looking at active repositories on github (biased towards open source) or activity on stackoverflow (probably more representative overall).

BS: for linear memory gc, considering the popularity of language is important, and having a good metric is important too.

KM: idk if we want to commit to this. I don’t think it’s fundamentally that linear memory gc and host gc are incompatible. I can imagine where you can have both, how they interact idk, they are references you pass around, can extract as needed. Might be interesting to consider, where should we focus our efforts first? If we end up choosing one over the other, doesn’t mean the other will not happen, just where we are spending effort first to get to MAP to people first. Probably better to have one thing come up first, another come up later, rather than both later.

FM: Right, we have to choose.

RT: want to consider that, while designing one, should consider what you want to add later on, some forward compatibility work. For linear gc, however we design the host gc system, whatever we add for linear gc and host gc cooperation, probably will be independent of that design, no big forwards compat issue here.

BS: fortunately, there are existing languages compiling to Wasm using linear memory and implementing GC on the shadow stack, considering switching to host GC. We might see this naturally as the evolution, when language tries to do the transition and choose how they do the interop. E.g. Go does this, and Blazor does this.

RT: non-gc features that can help with that, such as stack inspection, such that you don’t have to maintain shadow stack, just look for roots on demand, often faster. But that’s separate from host gc.

FM: I do agree that we should try to focus… part of the reason for having this discussion at all, is that there is a fight for the soul of WebAssembly. Some people see that the relationship between and JS and wasm module, or the relationship between the host and the module being critical. And for them, having a unitary model of memory is a no-brainer. This shows up in some unexpected places, for example with exception handling there are entities shared between the host and the application. OTOH, the other side of this is the C++ code that ""I want to run, so just give me the data, I know how to do GC, just get out of my way"". There's a choice. If we pick one then we're going to alienate the other lot. I have an opinion. I think we should focus on host-provided GC. But I think we should honor the other side of the story too. My reasoning for opting for host-provided GC -- it's similar to the guest thing. The host knows its environment better than any language can. It's best able to tailor its GC for its environment. But with a general programming language, you don't know what the host GC is like, so you don't know what kind of GC to provide. But I do think we should choose. By the way, it wasn't my starting point, I first started on the other side.

RT: agree with your points, while we are on the topic… here’s an idea for how you can make host and linear gc collaborate. You can say, linear gc, if you want the host to help you with memory management, you need to abide by certain conventions: let me know your roots (addresses into arrays), when go to a gc allocated block, above it is some bits to indicate which are refs and scalars, can use that info to walk you map for your without running your code. This restricts how you do GC, but allows collaborating. More corner cases to consider. If you do linear gc with this convention, the host can incorporate that into the GC process. Is that appealing? Either to host or to the modules.

BS: i will guess that it doesn’t solve one problem we hope linear memory gc would be - would need to change gc. If host requires some layout, porting your language will need more invasive changes

WO (chat): ok, my mics not working, but I would contest that the host ""knows better"" how to do GC.. I would say the language knows best how to manage its own objects. Also, do keep in mind we are designing Wasm to also run without a browser, and without JS/Dom

FM: the host knows its environment better than the language does… there's more opportunity for contextualizing GC. An example in Java, there are different GCs for different applications. Some are suitable for terabyte memories, and some for laptops. But the JVM can choose for itself, you can tailor the GC to the application.

RT: I know that Wouter suggested that we don't share, and instead ""I copy to you, and you copy back"". One downside is large objects. And there's mutable objects. If we want to support that kind of thing, then we have to deal with fine-shared memory. If we don't want to do that, then there's a lot more freedom, since we don't have to deal with it. Do people prefer to have more clear boundaries?

BT: step back a bit, reqs for linear gc that comes from host gc. We use a couple of models here, where we assume host gc works in synchronous manner, nowadays gcs are becoming more concurrent. This being observable also means that it is difficult to make it concurrent. Memory management community is close to making concurrent gc the default in the future. If you allow any concurrent computation of Wasm on same memory, it will be chaos, race.

RT: Yeah, that would only work if the application was paused while that was happening.

BT: if you need to pause to do it, then performance suffers for the whole system. Whether that’s declarative or code you have to run, that’s something you can’t get around.

BS: primary concerns that Keith had, how to deal with safepoints and concurrent gc.

RT: rules that option out, it basically leaves you to weak refs, or you come up with coordination policy. You are responsible for collecting your memory, then some communication principle to declare dependencies.

BT: On this topic, I don't think concurrency rules this out. I think observability rules it out, at least on the web. Could work, but if you want this to work, it needs to be concurrent.

BS: few minutes left, any final points?

JK: another aspect to perf and efficiency, making me skeptical about the two-gc system. The cycles certainly can be solved on a functional level, can get arbitrarily complicated, cycles with pointers crossing boundaries many times. If you have one gc informing the other is alive, then the other gc has to run a full gc cycle. When it does a full cycle, it might only free up 1 ref, then it has to inform the other gc, which has another cycle to do. We have seen in chrome, you can have inefficient full gc cycles in two worlds without making progress in cleaning up progress. That’s what the unified heap is the answer for, making it efficient to find cycles, with the assumption that applications can be arbitrarily complex.

RT: yea it’s not easy to do this

BS: if there were some nice examples or writeups for this. It’s probably an interesting research problem and will help put some constraints on how we tackle this problem.
"
main/2021/CG-04-27.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 27th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: April 27th, 3pm-5pm UTC (April 27th, 8am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

This is a special edition longer form meeting to discuss Scoping and Layering of Module Linking and Interface Types.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Scoping and Layering of Module Linking and Interface Types (full session) ([slides](https://docs.google.com/presentation/d/1PSC3Q5oFsJEaYyV5lNJvVgh-SNxhySWUqZ6puyojMi8))
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes
### Opening, welcome and roll call

### Opening of the meeting

###  Introduction of attendees
Luke Wagner

Deepti Gandluri

Thomas Trankler

Zalim Bashorov

Francis McCabe

Asumu Takikawa

Saul Cabrera

Matias Funder

Arun Purushan

Ryan Hunt

Till Schneiderdeit

Sergey Rubanov

Dan Gohman

Wouter van Oortmerssen

Alon Zakai

Piotr Sikora

Paolo Severini

Mingqiu Sun

Alex Crichton

Rick Battagline

Lars Hansen

Jakob Kummerow

Chris Fallin

Adam Reese

Andrew Brown

Sam Clegg

Garrett Gu

Zhi An Ng

Daniel Wirtz

Slava Kuzmich

Ross Tate

Nicholas

Richard Winterton

Andreas Rossberg

Emanuel Ziegler

Piotr Sikora

Michal Kawalec

Manos Koukoutos

Nicholas Matsakis

Jhonnie Birch

Nabeel Al-Shamma

Heejin Ahn

Flaki

Thomas Lively

Pat

Adam Klein

Lin Clark

Sean Westfall

Fitzgen

Petr Penzin

### Find volunteers for note taking

Zhi An Ng, Dan Gohman, Derek Schuff volunteer

### Proposals and discussions

Luke: [presenting]

About 1 hour of content with slides, discussion to follow.
Scoping and Layering the Module Linking and Interface Types proposals

Not trying to carve out a 3-year plan, there’s some urgency to do something in the short term, an “MVP”

Summary of current Module Linking proposal.
Can import modules, with no state, and instances
Define nested modules
Instantiate modules to make instances
This allows composing wasm modules, including instantiating module multiple times

Module linking now implemented in Wasmtime, leading to practical feedback. Including the question of duplicate imports, reported as design/#1402. This points to Module Linking being a new layer, rather than part of the core spec.

Core Wasm unchanged, new things go into “adapter module”. Syntax is identical, keyword is different.

Adapter modules are purely (typed) wiring. Linker specification. Adapter modules/instances form a tree, core modules/instances only at the leaves.

PP: Right now tools do link wasm objects together. How is this different from that, other than being part of the spec?

LW: type of linking we currently support with object file is static linking, many object files linked to make 1 Wasm file. Here, we have multiple Wasm files (from different toolchains), want to link at runtime, maybe want to share machine code, or other reasons.

SC: We can also use this for same-language dynamic linking in C++: the object format we have isn’t really a dynamic linking format, we could use this for that.

WV: Also module linking can involve multiple memories, unlike how C++ does it now.

FM: With dynamic linking people will want all kinds of different use cases. What’s the escape hatch for when the use case doesn’t really fit this. How many of these pieces can be re-used if the use case doesn’t line up exactly?

LW: have a slide laying out spectrum of linking options, it can be complementary to address different use cases, can come back to that

[presentation continues]

Module linking is a new spec layer between Core and the JS API and other language APIs. Module linking isn’t a required layer; JS and other languages could continue to use Core features and APIs.

PP: self-modifying code, person was asking about generating wasm and loading it up in the same instance, we cannot do that now, have to go back to JS, will this support something like that?

LW: will speak to that in a few slides, then return to this question, what I’m proposing wouldn’t do that but also wouldn’t block it.

[presentation continues]
Implementation layering can reflect spec layering; engines can focus on the core spec, with a module linking implementation layer on top.

Interface Types:
A feature proposal which extend the Module Linking layer
Adapter modules can contain adapter functions which use Interface Types types like strings, and lifting/lowering instructions.

FM: Can the adapter concept be completely factored out? i.e. a separate functionality, reusable in different contexts?

LW: yes, will talk a bit about it when we get to WASI, spend a lot of time designing lifting/lowering, how to go between abstract types.

[presentation]
Module Linking is a layer, with Interface Types as a feature, what other features are there? What should the scope be?

Spectrum of dynamic linking:
Module linking at one end, usable even in very static use cases
In the middle, the ability to have a first-class reference to a module.
Or a step further, adding an instruction to dynamically compile bytecode to modules
Or even further, JIT-style linkage
There are interesting points on the spectrum with less dynamism too.

Greater dynamism provides greater flexibility, but fewer invariants. Wasm can potentially pursue multiple points on the spectrum; the spec layering means that Module Linking can make some choices, and core wasm can still explore other points in the spectrum.

RT: for 3rd one, no JIT + static linkage, how is that static? If you do branch you won’t know which reference you’re getting.

LW: the pointer to the instance is dynamic, but you know its type (what module it’s an instance of). It’s like a class with a non-virtual method.

RT: statically typed essentially.

LW: get_export is virtual dispatch, and the other one is C++ static function calls

LH: some of these seem to be dipping into the core spec, i.e. you havenew instructions and types, etc

LW: will return to what i think goes where, some of these make sense in core

FM: not sure if you kept the existing concepts invariant, if you have an instantiate instruction that refers to an index, that index is across all of your modules, in the first 2 items of the spectrum.

LW: this would be locally scoped the way indices are today. So this module would either be nested or imported into the containing module. So it would still be scoped.

[presentation]

Proposed scope: a Lightweight component model.
Components: composable units of software. Many prior examples of this, on many points on the dynamism spectrum. Wasm modules are close to components already, but lack black-box and cross-language reuse and external composition. Interface types and module linking provide those pieces.
Model: Cross-language and black-box reuse raise many questions, about how linking works, async, etc., so a component model needs to be somewhat opinionated. This also points to a layered approach, so that the Module Linking layer doesn’t need to impose its opinions on the core spec.
Lightweight: Define a scope, and exclude features like distributed, services, etc., and don’t tie it to GUI or other domain-specific functionality.

Positioning: a middle-ground between language-specific units on one hand, and host-oriented units on the other.

SC: for “fast import calls” did you mean IT instead of module linking to implement those?

LW: both, module linking to wire them up, and IT to say how to pass values and handles back and forth

PP: if gc were implemented in one of those components… are we running ELF binaries?

LW: I meant some sort of “wasm-ified” ELF-like system, like what we have now in our tool conventions. All of these are wasm but the way they interact inside is different.

SC: they have to agree on their own conventions, not specced, whereas the green arrows are specced.

PP: what’s an example of what those ELF things could actually be?

LW: for the .a, that’s already a thing that exists, multiple wasm files, can make them into a .a. Emscripten supports dynamic linking of Wasm files, uses JS.

PP: so in that case, JS wouldn’t be needed. So ok yeah in this case it needn’t be literally ELF, but ELF-like use of wasm

FM: question about handles, for people not familiar with handles, they are a handle on a resource you don’t have access to. I’m thinking about the other part, the lifecycle of the resource identified by the handle. The lifecycle is something known by the engine, if sharing a resource across modules or components, and now we’re looking at something like a service making sure the handles are collected properly.

LW: in the same sense you could say the wasm engine is  a service which implements the runtime semantics of the spec. So you you could specify when destructors are called, handle lifetimes, etc.

FM: a component is running in 1 Wasm engine.

LW: at least one component. It should be possible/common that all the components are running inside one engine

FM: whereas the heavyweight model, you’re talking about multiple Wasm engines.

SC: the model for the components would be an isolate in V8?

LW: yeah, like an isolate. Maybe even a little smaller. I drew 4 here but it would be normal to have hundreds.

PP: we can think of multiple engines running Wasm on different machines, function as a service, what use cases do you see, how would it work. How does supporting GC languages play into this? What kind of problems will this be a solution for?

LW: when you have separate units of code from separate projects/languages tha you want to reuse: today what people often do is put in a whole separate container and talk over a socket. This would be much lighter weight (putting in a component and calling synchronously). This fits (back to “spectrum of granularity” slide). Today people take these and bundle them up and expose in JS.
For the GC question: inside a component you can linear memory but also GC memory as a component implementation detail. I will propose that there’s no intra-component GC (will get to that later)

PP: those things compiled to Wasm, accessing them somewhere in some opaque form?

RT: can you clarify, what is the deployed wasm file or files here?

LW: a component is a .wasm, if it wants it can bundle all the code it contains, if we have a host that wants to share libc, then don’t bundle libc, then host can say you import the shared libraries, then component can use a module import of libc. Shared library can be outside the component, you’re not importing state, you’re importing raw machine code essentially.

RT: so the green arrows, how are those imports set up?

LW: can say that if a component is a root, it could bundle all 3. You can nest dependents inside the root. If the host is like node.js, maybe ESM is what is linking them together. Different host can have different ways to load separate components and link them according to the host. Simplest case is all 4 in one wasm file.

RT: at a high level, somewhere between green and blue, depending on the specifics of the host. They could be sections of the same file.

[use cases]

PP: imagine i’m a developer using C++/Rust/AssemblyScript etc. Don’t know how someone would use Typed Main, probably hard to use from C/C++, what are the user visible things?

LW: e.g. typed main: that requires a bit of  language-specifc tooling. Dan has a prototype in Rust that we want to extend to C++/WASI. You just write main with typed parameters like file handles, strings, etc. when you compile that to components, the export uses IT. then the host runtime, when you invoke the CLI, it converts the CLI arguments into the main types. So the tooling allows you to emit those files that do all that. It could involve a lot of different tools. So there are lots of questions about how do we enable people to produce those.

PP: Typed Main is a new way of writing code, not yet mainstream, maybe not the best to talk about here. I don’t understand how if I am a C++ developer, how would this benefit me? We can define novel use cases, but if they are quite far out, we’re defining our own users and own solutions.

LW: the hope is that we should be able to tweak but not have to rewrite existing tools, an likewise not have to rewrite existing codebases, to adapt legacy code by doing adaptation at the boundaries. E.g. take legacy code with a normal main() but write a witx file. But it is on us to write the tools the developers can use.

PP: witx is for one very specific runtime, not everyone support it.

LW: I just meant that as a stand-in for being able to specify a signature for what my component exports. It doesn't have to be exactly witx

PP: would that also be part of this new layer? Part of the tooling story for components.

FM: these use cases are great, might be helpful if we could say what components are bringing to these use cases. Take the first 1 for example, developer import component from their native language. They can import a module, what does component bring to the table?

LW: in this one, they pass native values and don’t have to write manual glue code that e.g. creates a typed array view and passes the values through that

FM: I would justify it a different way: it’s the unit of commerce, developer brings in some functionality and they don’t really want to know how that functionality is constructed. These are great use cases, what is component bringing to the table to make these use cases better.

LW: the same toolchain/standards can support all of these and I can just make a component that can be reused in all or many of these different use cases. It reduces the combination of the number of ways a piece needs to be produced and consumed.

[composition use cases]

RT: the trapping one, sounds like you have to be able to catch other people’s trap.

LW: there’s a difference between saying my state is not corrupted v.s. When someone traps, what’s the blast radius. Not suggesting that when one traps, making sure others are not corrupted, as opposed to letting corruption happen and later get some bizarre results. Not handling traps.

PP: follow-up to host side, in previous side, potentially having a registry of components, if you’re pulling them, can you depend on them crashing and not everything dies

LW: if you import a dependency and it traps (in the current proposal) you trap too, similarly to if you call it today. There are ways dependencies can break you. That’s subtly different from silent corruption.

PP: we cannot promise this, for sufficiently large applications, likely to pull in one small component that spoils everything. The current way where you load modules, maybe there are ways to detect and stop.

LW: for now, when you talk about host-specific units. Many of those today talk about partial failure, e.g. container systems expect containers to crash. In the future we can ask, how might we be able to handle this within the component model too.

PP: streaming data, a lot of things have to happen under the hood for it to work, okay for this level of proposal because it is high level.

LW: there are subtleties with streams. There’s synchronous streaming, and async, which is harder. Ultimately I think we want both.

[Composition use cases (future features)]

RT: one slide we talked about portability, and nother talked about changes you could make to the module system. ES modules (one e.g. you gave) don’t support some of those changes you described. How do you think about that

LW: talked to ESM experts about, we can embed it within the ESM loader, loader loads the root component, then they determine how the DAGs contained in it are linked. The ESM loader is a big singleton register, module linking doesn’t describe it, what ESM calls a single instance is a DAG of component instances. Technically feasible. WHen you drop a whole DAG in ESM it looks just like 1 thing.

RT: I was more thinking about default imports, would components work differently in that case?

LW: when you instantiate components, the root’s imports are determined by host, take what you’re given. Up to ESM to say what gets supplied to the root component.

[static analyzability use cases]

AZ: everywhere you say “AOT compiler” could that be a toolchain that does this with compilation?

LW: either build aot or client side

AZ: you mention x-module inline, wasm vm does not do that, probably left to toolchain, are you imagining it better for engine to do that?

LW: in these multi-tenant hosts you don’t want the toolchain to have done this because you want to share code between the tenants. So in that case you want to be more careful about the boundaries where you inline,so it’s more nuanced. For the web it could well be the case that you want everything together.

KM: in the web, if you import wasm malloc, you want to some inline some part of that. Hypothetically some vm can decide it will be much faster if we inline it

PP: cost of inlining in multiple places, binary size

KM: for the malloc example, it could just be a bump allocator. Hypothetically the VM could figure it out.

[Requirements]

PP: do you expect this to change, how do you see this evolving?

LW: if we have these requirements it will limit it some. Sometimes use cases are in conflict. E.g. needing ubiquitous GC means it can’t be implemented in environments without GC. so if there are radically different requirements then maybe those uses need something other than this particular component model.

PP: what’s an example of, if you work on it, and find that it is not efficient, we can remove. What is fixed?

LW: just to be clear, GC is fine within component bodies. From the outside I don’t care whether that happens in e.g. a linear memory or with platform GC. but otherwise, i could imagine loosening static component linkage. Certainly there are lots of use cases for modules dynamically chosen by the user. That could also happen outside the component model, but through the host (e.g. lots of different possibilities, e.g. does it come via fetch or filesystem, etc). So there’s lots of design space.

FM: is this set of requirements spanning, if we have all these requirements we can do it?

LW: I’m not sure. It summarizes a lot of debates and challenges and tradeoffs we’ve discussed over the last couple of years. Lots of these are not the obvious thing, we had to discover them in some sense.

RT: Good to have a description of the sort of changeability you want to have. What can people rely on, if they make changes what will not break compatibility.

LW: what’s the subtyping relationship between components...

RT: subtyping can be part, there's also other research on changeability

LW: mentioned a few things earlier, that’s something we need to iterate on

RT: good for scoping and for others to know what guarantees the component system has

LW: in some sense it means defining a semver model for components, what qualifies as a breaking change.

PP: versioning this layer will be harder than versioning core spec. If you don’t support certain instructions yet, you can’t do this way of communicating between modules.

[spectrum slide]

The scope of the lightweight component model suggests the leftmost 2 belong in the spec now

RT: suggest not calling them canonical? Idea of separating adapter functions from IT is a good idea. Many ways to represent strings, the term canonical suggests “only” rather than “easy”.

LW: that’s open for discussion. I think it will end up being useful as a canonical ABI for wasi. It can serve that role, but there doesn’t have to be exactly one.

PP: question about previous slide. We can have a component model first, then rebase, if you think about linking, it is a sub case of component model. Can we do linking first? Don’t feel great about a broader proposal first, then a more narrow proposal.

LW: it makes sense to do module-linking first and written up/implemented. We could say IT and the rest are optional, to achieve the outcomes you want. But if we don’t scope it to the component module, I worry we will have scoping problems in the future.

PP: wouldn’t linking be useful even without the rest? Standardizing how we dynamically link things...

LW: the point is that there are lots of ways to dynamically link things. In the component model you have [one way to do it?]. But there’s not just one kind of linking, so we want module-linking to be scoped to component-model-style linking.

DG: next meeting is full, we might have to wait for some time.

LW: not a full thing, but  just a couple of materials.

DG: yeah, the agenda is full

LW: enough time to do a basic poll whether people think this is a good idea? Or is it premature

DS: seems like there is a lot to chew on here

DG: one option is to have an issue in document to do a tentative poll and can have more discussion later

[Poll on general interest, or general agreement with the high-level direction]

|SF|F|N|A|SA|
|--|-|-|-|--|
|17|6|4|2|0|

### Closure
"
main/2023/CG-06-06.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 6th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: June 6th, 4pm-5pm UTC (June 6th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Announcement: Next hybrid CG meeting, tentative dates in Oct 2023 [Deepti Gandluri, 5 mins]
    2. Announcement: Github roles and permissions cleanup (see #1215 and #1233) [Derek Schuff, 5 mins]
    3. Compile time imports and string builtin API [Ryan Hunt, 25 mins]
    4. GC & strings: discussion [25 mins]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 6th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: June 6th, 4pm-5pm UTC (June 6th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Announcement: Next hybrid CG meeting, tentative dates in Oct 2023 [Deepti Gandluri, 5 mins]
    2. Announcement: Github roles and permissions cleanup (see #1215 and #1233) [Derek Schuff, 5 mins]
    3. Compile time imports and string builtin API [Ryan Hunt, 25 mins]
    4. GC & strings: discussion [25 mins]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
 - Andy Wingo
 - Yuri Iozzelli
 - Derek Schuff
 - Justin Michaud
 - Jeff Charles
 - Alon Zakai
 - Conrad Watt
 - Slava Kuzmich
 - Adam Klein
 - Ryan Hunt
 - Keith Winstein
 - Shravan Narayan
 - Paolo Severini
 - Bruce He
 - Brendan Dahl
 - Luke Wagner
 - Sam Clegg
 - Dan Gohman
 - Ioanna Dimitriou
 - Tal Garfinkel
 - Dan Phillips
 - Petr Penzin
 - Mattias Liedtke
 - Daniel Lehmann
 - Jakob Kummerow
 - Heejin Ahn
 - Calvin Prewitt
 - Emanuel Ziegler
 - Thomas Lively
 - Benjamin Titzer
 - Daniel Hillerström
 - Mingqiu Sun
 - Andreas Rossberg
 - Ilya Rezvov
 - Nick Ruff
 - Francis McCabe
 - Zalim Bashorov
 - Nick Fitzgerald
 - Chris Woods
 - Andrew Brown
 - Sean Jensen-Grey
 - Dan Philips
 - Ashley Nelson
 - Kevin Moore
 - Johnnie Birch
 - Peter Huene

### Discussions

#### Announcement: Next hybrid CG meeting, dates in Oct 2023 [Deepti Gandluri, 5 mins]

DG: Next hybrid meeting will be held on Oct 11th, 12th in Munich. Registration form, agenda, and other details will be shared as we get closer to the date. Please email the chairs if you have any questions, or need an invitation letter for travel requirements. 
 
#### Announcement: Github roles and permissions cleanup (see issue #[1215](https://github.com/WebAssembly/meetings/issues/1215) and issue #[1233](https://github.com/WebAssembly/meetings/pull/1233)) [Derek Schuff, 5 mins]

DS: We will be cleaning up some of the permissions for the WebAssembly github org, the details are in the linked issues. Right now, the permissions are inconsistent and some folks have access are no longer working on Wasm for several years. This is an administrative for making permissions and access cleaner, and more secure. No changes to how proposals are advanced, or should not affect what we do in the CG on a regular basi. 

#### Compile time imports and string builtin API [Ryan Hunt, 25 mins]

RH presenting [slides](https://docs.google.com/presentation/d/1X3XdJPnloXLrwP7_w0-lrzmMDHt4CKePBk0E-0nkpkk/edit#slide=id.p)

CW: Are the encodings going to close over the JS side, or would Wasm know about them?

RH: Getting to it in a couple of slides

CW: I would expect there to be.. From a Wasm point of view, is memory a first class argument that you have to pass in?

RH: yes, concretely how this could be done is you’d have JS code that instantiates your module (like today), that would create the actual memory object, it could be imported into your module and have this memory type, and when you invoke it would be a first-class value.

CW: Does this require first class imports?

RH: No, just type imports

BT: You skipped over type imports, how does it work exactly? 

RH: with type imports, in that proposal there’s an idea where you have an extension to import types from the JS API. I just called it builtin type but there’s some design work to do. You create a module with a builtin type and in the API youd have string.type. And it would only be values that are JS string primitives, so everything would be typed by importing that. In this example this iw aht you could do if you haed ad type for webassembly.memory, not a first-class memory.

CW: How do you call that from within Wasm?
RH: I’ve seen this before in JS glue code, you can export your memory. Maybe in this case it requires your memory to be instantiated before th emodule, then you’d use global.get

CW: it seems this would require you to instantiate the memory first, and then import that and close over the memory

RH: you wouldn’t have to close over it but I h tink you do have to export it

BT: The WASI was is that you export the memory, and then WASI knows how to bind it, emscripten does something similar, where it binds it later, do you can’t do this in a way that you define it and then bind it later

CW: making that fast in the engine is going to take a lot of specila magic, right? To generate the code that knows where to find the memory you’d need to use lots of indirections, or do special magic at compilation time, right?

TL: If you declare your memory in the
 module and then export it, the JS code then writes a mutable global, and then it writes it back through an externref, you don’t need a type check on that because you use it as an imported typeimport, then you know that the engine knows its a first class reference to a memory without memoryref

CW: every access to memory through this f unction has to go th rough that externref

LW<in chat>: Presumably there is a first stage where it all uses externref (and there’s extra runtime type-checking overhead)

TL: but you don’t even need ot tpyecheck that because you have this typed import, so you just have a reference that the engine knows is a first-class reference to memory, even though we haven’t added memoryref to wasm.

CW: im just wondering, can an engine make this as fast a a proper instruction that can get directly to the webassembly memory?

KW: <in chat>: It would be nice if these builtins were applicable to any memory in a multi-memory module, and ideally without the instantiating code needing to know a priori how many memories are declared in the module.

AB<in chat>: There have been discussions about switching WASI from memory export to memory import: https://github.com/WebAssembly/WASI/issues/502

RH: There would be loading a data pointer and a bounds check, so there is some indirection, but there are other ways of doing this, where a UTF8 string doesn’t close on the memory

BT: type imports are a thing we’ve kicked around for 5 years but haven’t gotten a design that has moved forward. Is there a dynamically typed version of this API that would have dynamic type checks at the boundaries?

RH: Open question about what happens if you have this without type imports, and everything is externref, is this forwards compatible, and would it have sufficient performance? Not a clear answer to that

CW: at some point the question is, how much extra do you get from even having compile time imports as opposed to just regular imports?
RH: Depends on the nature of the type check, if ou have a cheap type check, a quick type check and an OOL fall back code, it might not be too much overhead, it’s not a certainty, we would have to pin something down

TL: with the GC MVP being almost done, I think we could actuallly move pretty quickly on a type imports proposal as a follow up. But as we finish GC we could actually give it attention and move it pretty quickly.

BT: Do you mean that just CPUs are freed up? 

TL:  yeah I just mean brainpower to think about it.

AR: there’s certainly a dependence on the funcref proposal, which we’ve tied to GC, since it defines what typed refs are. So it would depend on that.

KW (chat): (It would also be super-nice if the builtins included a community-maintained Wasm implementation that could be provided as an import, so that the non-Web engines can just compile that module and link it, rather than every non-Web engine having to maintain their own implementation in host code.)

RH: Going to get through the last sets of slides: thoughts on stringref

BT: There’s a lot of complexity in string implementations, and when you consider that against what’s already in Wasm, and then adding additional complexity of hiding the representations in the engine, its a complexity that keeps mushrooming, this is a good step forward to keep it out of the core engine

NF (chat): one could imagine specializing for Reflect.get builtins and all that similar to the string operations, which is neat

AW: I have a couple of comments, one is the necessity of builtins for shareability, it would be nice if we could get the functionality without adding a new thing, then we can do this by passing by reference. Any functionality that has the right shape, there are a lot of things that aren’t in a good shape. You can still use the func.bind, even without builtins. 

Another: a thought experiment: if you remove string.concat and equality from stringref, you remove a source of nondeterminism, but these will certainly be added back in as builtins and be recognized by entines, so languages will have expectations about the complexity. If we had a string type that worked on web and non-JS, then this ability to specialize performance of strings wrt what web engines do is a risk anyway, standardized or not. Just based on what source languages start to encode in their engines, just a few comments

RH: on the first part, could we reuse the existing definitions of JS global space: i’m open to finding a way, i agree adding a new thing has risk and would be good to avoid that. Details are unclear. The second thing, a quick clarification question: you’re saying there would still be a stringref type but you’d import the functions that run on it?

AW: That would be the thought experiment, if the objection to stringref is the unclear cost of concat etc. you would still incur the cost of this anyway, 

RH: yeah, I think if you wend down that road of a stringref type, with the mutation ops are builtins you end up in the same long-term result. Probably worse, since they aren’t instructions but imports. My hope with going to import a string type, if you compile for the web and want to reuse the JS string type, that you know what cost you need and will pay it.

But when you’re compiling for something else, you can use whatever is the cost effective thing on that platform so you don’t incur the cost of it if you don’t need it.

AK: wanted to respond to the first point on the last slide about motivation for stringref. There are really 2 motivations. My presentation focused on the urgency of sharing strings across the boundary. As ben said there is a huge amount of code in engines to get good string performance. If we don’t provide that in the platform, each toolchain will have to do that in userspace. There are conceptual advantages to that. E.g. kotlin/dart/java have all expressed interest not just for interop but internally.

The Kotlin folks have been thinking about how their engines would run on non-web engines, stringref is a way to deal with that complexity, there are a lot of things you might want to do where the language uses UTF8 as its encoding.
There are 2 big performance benefits. One is interchange and the other is simplicity, where they can lean on the engine and still get good performance.

RH: That’s an interesting experiment, what is the peak performance you cna get with that compared to Wasm GC? It will be performant but at a big cost of complexity, but it won’t be universal across languages, stringrefs are the lowest common denominator.
Maybe this is where you get into the philosophy, should we have big common runtimes that everyone tries to use, but I think it would be better not do.

AR: These two different use cases are also in conflict with each other, one discussion was should string ref allow eqref, or be a subtype of it, many languages would want that, but that would run into problems in JS  where you don’t want to inherently add it. These are all in conflict, so its not clear what to do. The proposal has to be clear about the scope, JS API seems to be the right choice in taking this forward

BT: I would say that in some sense wasm has been an exercise in exposing those things from below in the machine to code above in making things useful and standardized, and this has some flavor in taking a thing in the web and moving it down. This is maybe the pointo where we should explore what are the mechanisms where we talk about external things. This is an opportunity to get it right. There will be other kinds of embenddeings, e.g. databases, where want to expose things for databases, and we’ll want to get that fast, so type imports could be a way to get there.

AK: I’m interested in stepping aside JS sharing, interested in getting thoughts about Wasm engines provide a stringref functionality. Would be interested in toolchain folks - not as an interchange format, but providing a functionality. GC is an example of us providing something that’s not at the machine level that people need. Comparing strings to databases, there’s a long gap between how fundamental those two are. Toolchainss are a bit part of Wasm development, and is an important part of the discussion.

RH: [portability and polyfills slide] one thing, I have one extra slide, not sure if its relevant. It comes up, Is it desirable to.. If a toolchain wants to use string ref on the web. It can be sort of portable across web and non-web environments because its in the platform. A way we can make it better, IMO, I think the web environment is unique and difficult enough to target, its seems inevitable that people will want to have different code and bindings to target the rich environment. There’s been concerns about toolchains haveing web/non-web environments, I think its inevitable. It’s possible that to ease the transition for some toolchains, what if we create a polyfill module built on GC that’s compatible with the builtin API. if you had a tool that could inline this into something that imports the builtin API it would be very good, and allow compatibility between the different environments.

SJG (chat): I would hate to see web and non-web Wasm ecosystems diverge.

BT(chat):I honestly think that Wasm will give rise to endless ecosystems, and that is a good thing (TM)

KW: I like the idea that there would be standardized set of imports that engine can agree on. How easy would it be to maintain a standardized module that implements these functions,? Rather than all the engines having to maintain a set of functions etc. then non-web engines could just link to it instead of working with their complexity

RH: I think I agree with the idea that it would be desirable if someone would create a polyfill that would emulate these web builtin primitives. It's an open question if this is something non-web environments would want to have themselves. IMO it would be better to have this in toolchains that they would bake in rather than having all the environments/engines have.

KW: The idea is that it would be a valid implementation, if the browser wants to provide an implementation backed by its native implementation thats fine, for an engine that doesn’t have its native implementation then it would just use the module, and it would be normal linking. This does create constraints on the Wasm API, having the constraints of what’s implemented, it would be good to have it upfront. 

RH: going down this road i’d be interested in seeing, is there a benefit for non web engines to have and add to the user code, vs users bringing it themselves. If it’s part of the embedding layer that runtimes provide, I don’t think that’s good, I think it’s better for tools to bring it.

KW: I agree, the point would be to free the non-web engines from doing anything

BT(chat): A benefit of the “wasm polyfill” module is that its performance characteristics are transparent.

SJG (chat): I agree, but they should share a common chirality so the DNA is compatible. This is more of a feeling than a concrete objection. I like the idea of Wasm polyfills as a mechanism for portable behavior

NF (chat): and it can have breaking changes managed by semver or whatever, updates that are independent from the engine itself, etc because it is all under control of the toolchain

AW(chat): prevents you from using built-in intl though

BT(chat): couldn’t that intl also be specified too?

AK: Agree that at the interface layer we see web/non-web do different things. Strings show up in the source language without any compute interface. It’s a slippery slope the other way. In the compiled to JS space, languages had to deal with not having 64-bit integers, I feel like imposing sort of thing on languages that will be targeting wasm in the future, for a language that does want to strings. My worry is that people will depend on that for more than interchange, it would be nice if there was a polyfill of that, if the polyfill has to be performant then that creates a high bar. Wasm in isolation doesn’t provide everything folks need, so don’t understand the argument for keeping Wasm pure, strings are more fundamental than that. There’s going to be some difference in web/non-web. Strings doesn’t seem like the right place to make the cut

AR: I think underlying this argument is the assumption that an interface like that is equally useful for JS usage as it is for internal runtimes. I think that is fundamentally not true. If languages didn’t care about web interop, this interface would be suboptimal. As ryan pointed out the web brings a lot of problems that you only need to solve if you are there. For internal use you’d do something different. A lot of languages would need something different anyway, since they have different constraints. So there are different assumptions about how broad an audience this is useful to.

Chris Woods: yes, I think andreas had a good point. From a non-web point of view there are many use cases where we don’t use strings. In the web interfaces, there are 
But in industrial code it’s usually numeric, and I”m concerned about the growing size of the runtime to support these new features.

CW: this is also true of GC. How do you feel about that?

CW2: I have concerns about that too, but we should take that offline due to time constraints.

AW(chat): the question is, does the app have to ship intl?  if strings are a pure toolchain consideration then yes, right?  certainly on the web that sounds suboptimal :)

BT(chat): A wasm polyfill is also a good executable specification :-)

KW(chat): Naively I think the Wasm polyfill *could* be a lot simpler than an in-browser engine, because it wouldn't be burdened with UTF-16-related baggage and could just use UTF-8 internally.

AK(chat): But if source languages depend on UTF-16 semantics, as Java and Kotlin do, they'll bring that requirement along with them

KW(chat): It wasn't my understanding that anything in today's proposed API would guarantee UTF-16 semantics on the API boundary... maybe I missed that.

DG: next steps: probably the next time to talk about this live would be a month from now. Probably we’ll request a quick 5 minutes from Adam and Ryan to start that out. In the meantime, more async and offline discussion. Maybe we need a more centralized way to track this.

DG: one other thing, we’ve been discussing how we post notes. There’s a link to the doc in the chat, if you want to correct the representation of what’s been said you can edit the doc and I”ll post the note at the end of the week.

### Closure

"
main/2023/CG-03-28.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 28th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: March 28th, 4pm-5pm UTC (March 28th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
   1. Phases doc clarifications (https://github.com/WebAssembly/meetings/pull/1232)
3. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees

- Deepti Gandluri
- Thomas Lively
- Ilya Rezvov
- Ryan Hunt
- Alex Crichton
- Conrad Watt
- Paolo Severini
- Ben Green
- Manos Koukoutos
- Yury Delendik
- Derek Schuff
- Brendan Dahl
- Daniel Lehmann
- Luke Wagner
- Matthias Liedke
- David Piepgrass
- Jakob Kummerow
- Andreas Rossberg
- Chris Fallin
- Ashley Nelson
- Sean Jensen-Grey

### Proposals and discussions
 
#### Phases doc clarifications (https://github.com/WebAssembly/meetings/pull/1232)

AR: Clarifying PR, nothing in there should be controversial, it is changing the process document so we thought it might be best to bring it up in a meeting. 

AR presenting PR.

AR: Historically, the how-to is in the proposal repo and the phases doc s in the meeting repo, it’s a bit weird. Maybe we should move the phases doc to the proposal repo. ANyway, something to solve for the future. 

AR: Previously we had that the spec text ust be in “reasonably complete” state. We’ve never done that, we’ve just had informal prose that was precise enough, but not “real” spec text. But usually you don’t do that until after you have formal language and turn it into prose. So we’re trying to reflect that reality by avoiding the term “spec text”. Just a doc that has to be “precise enough” that someone could implement it. So it should be precise and complete but needn’t be spec text.

AR: Another clarification for the test suite is to not have to pass the reference interpreter (since you don’t have to update the reference interpreter yet), but there should be some implementation that it passes. There has to be something that passes the tests, the purpose is not correctness, but that the tests pass some implementation and make sense.


AR: Here it’s really just mostly wording that I tried to clarify. At this stage you need the formalization and also the English prose. Reflects the reality that they are usually written together. You can do it earlier but has to be done by now. Also, at this stage we want to resolve all open questions. Usually there are some minor open questions, even though the overview is precise and complete there will always be a few things open, and we want to close those. So here is where proposals will sit for a long time until we get everything discussed and resolved.

AR: It's also clarifying that it's happening in the forked repository. There was another vague statement, we had some discussion about what it means, that’s been split up and clarified.

AR: also for the last phase when it’s handed over to the WG, that means when we vote into stage 4 we’ve reached consensus in the community group. And at this point in phase 4 we just do tweaks or whatever. The WG may discuss the feature but usually there’s nothing to discuss since they were already involved. But the WG needs to discuss when to merge things into the spec. With Tail calls we were ready to merge it, but Apple pulled their implementation back out, so we decided to wait to merge since we didn’t meet the requirements anymore. 

AR: At that stage there can also be editorial changes to the spec. The last part is standardized. The precise W3C process evaded me, but this would be useful to flesh out. How to release candidates etc. is not very clear, hopefully we can add more detail to this later.

AR: one thing I didn’t change although I think we should really change it, is the requirement regarding the 2 implementations. It says web VMs, but we should discuss whether to change ti to say one of the implementations doesn’t need to be web VMs. We have production non-web VMs, and there is a decreasing number of web VMs, so it makes it harder. But that’s not in this change, everything here should be non-controversial. 


DG: thanks for working on and clarifying this!

Unanimous consent poll: no objections, changes are approved.


AR: is there any appetite for discussing the web engine requirement?

CW: we should probably give some warning for that discussion, there might be people who want to be in on it, who might show up for that but not here.

AR: we should be discussing this soon.

CW: my hot take is that we should be scared of relaxing the requirement because V8 has been running far enough ahead of the other web engines that we risk standardizing things that they don’t intend to implement.

AR: Part of the motivation is to put more pressure on other engines if they fall behind. It’s not enough for V8 to run ahead, there still has to be a second production engine. Right now, outside of the web space, wasmtime would be the one that qualifies. And wasmtime isn’t running ahead, so this wouldn’t change the game. The other two web engines besides V8 are JSC Apple and Spidermonkey Firefox and both of them have not been particularly quick and have often been a blocker for adopting features.


RH: my question here is, in what cases have we been blockers? I see tail calls but are there other examples?

AR: Tail calls are a particular one, but was there something else?

CW: I'm a little worried about stringref. I wonder if Mozilla has been looking at that.

RH: We’ve been looking into it, but we don’t have an implementation at this time

AR: there are quite a few proposals that have been at phase 3 for a long time that people are eager to start using.

RH: I believe memory64 is mostly blocked on toolchains, we have an implementation of that. Multi-memory we have a prototype implementation that’s been going slowly. It hasn’t been a priority for us. We’re also working on GC but there’s been plenty of spec work there too.

AR: it’s also about changing the perception of what wasm is. It’s no longer just a web thing and our process should reflect that.

CW: I would make a distinction between the browsers being in sync and the non-web engines implementing features

AR: no engine is required to implement the latest version of the standard as fast as they can. Even when we had 4, some were lagging behind and that’s fine, it’s their choice. For the standard to be adopted , it shouldn't be a requirement that everyone implements it. The standard should drive adoption rather than follow behind. So this requirement for 2 engines to have implemented is not so that everyone is up to date but to ensure that whatever the proposal is, we are sufficiently certain that it’s reasonable and can be implemented across a wide variety of engines.

CW: I could be convinced it would be okay to have one web VM and one non-web VM as long as there was a signal a web VM would implement it. I think a signal of implementation from our big stakeholders is missing.


AR: that’s the other thing, all these are just the base requirements, you can’t proceed unless they are met. But it’s not sufficient, there still has to be a vote in the CG. if there’s real concern by other vendors, it will come up there. So this is about not having unreasonably high minimum requirements.

DG: I like the idea of using the signal process, I know Mozilla and Safari have their own GH repositories which track signals  and Chrome release process uses that for Origin trials to see when other engines will implement proposals. Maybe we can’t discuss this in this meeting, but every time we discuss this, what does a production engine look like in the non-wasm space. But there are other engines that implement features that are to some degree production engines. How do we firm up the requirements around what a production engine looks like if it is not a web VM. Some questions about how to navigate that. The second thing is we want to have a case of a minimum tool engine requirement here because for multi-memories it has been really interesting, there are a lot of use cases, but there hasn’t been one big reason to implement it. In cases like that, the two engine requirement makes sense. I want to make sure that people are going to use it if it’s going to be part of the requirement. 

PP: There could be situations where an engine doesn’t find the feature useful/compelling. Similar to what DG said.

TL: I don’t really want to be in the business of deciding which engine is production grade, and then we don’t have unanimous consent on when an engine count

PP: Case in point, when we met before the in-person CG, there were so many presentations on e.g. WAMR, e.g. Seimens said they are using it in “production” but that means different things, it’s not as clear as in browsers.

AR: Procedure for marking engines as production so this CG could take a vote on recognizing a given engine as production engine and from that point on we can accept it as that so we don’t have to discuss it every time. We can discuss what the requirements will be or leave it up to the vote. Decouples from the process document. I think that would solve tha problem. It’s an additional process stage, but should work fine. Let’s not indefinitely give web engines this privilege they have now. I think it woud be harmful to wasm as a whole/ecosystem. More of a philosophical/marketing question. In practice, probably won’t change much.

PP: wouldn’t part of the problem be that sometimes web engines and non-web engines may have completely different interest. We may have features taht are web only or standalone-only. There’s WASI but it’s a set of APIs rather than a core feature.

DG: Interested in hearing from Luke about the non-web perspective.

LW: I was just thinking, what are some of the useful properties of web VMs that make them good, that we could apply to other VMs. they care a lot about security and longevity of the implementation. E.g. can we make this secure, and can we support this for a very long time. We can also recognize when developers of other engines are taking those same considerations.

AR: Makes sense, maybe we should come up with a list of requirements that we kind of state for a production engine to be recognized and discuss that.

SJG <chat>: Reference engine implementation? Engine conformance tests? If it passes the conformance tests, then it qualifies.

CW: maybe this is too harsh of an opinion, but i’m not sure we want to work this out eagerly, maybe we should wait until there’s a proposal where this matters, and then we can figure how how we want to deal with it.

AR: I would argue the exact opposite, we want to do that before it becomes controversial.

CW: Hence everyone agrees for example, if we get in a world where wasi wants to go through the process to become a separate spec document we are endorsing. Clearly we don’t want two web VMs to implement it and that’s the kind of stage it would make sense to have that discussion instead of tryign to predict which features would need an elongation of the proposal procedure.

AR: WASI is a different story anyway, since it’s not like core wasm. For standards like that we can certainly have different procedures. But i’m also concerned about core wasm, because the more users we have outside, the less represented they feel if all our requirements are based around web engines. Some of these use cases have quite otehr pressing concerns. Some care much more about the memory extensions but much less about SIMD, but traditionally the priorities in the web world are the opposite. But it would be good to get their views better represented.

DG: I couldn’t track down the notes but long ago in a meeting I discussed this and we talked about loosening the languages around our requirements document for a production engine that has unanimous consent for specific proposals. I don’t remember the exact wording but could we consider it async. What language makes sense to loosen ther restriction and argue that a different production VM is implementing it in addition to a web VM. I agree to CW, we want to make sure something is actually blocked to actually move forward, we’re not meeting the two VM requirement. Temporary middleground we can flesh out async, as long as there is unanimous consent about a production engine qualifying for a specific feature. How do people feel about that?

AR: how is that any different from just saying that a non-production engine might qualify? To be precise i have in mind to say that we require 2 production engines, one of which must be a web engine. I think thats the same as what youre’ saying, and we can discuss in each proposal whether the engine in question qualifies for that proposal.

DG: The thing I was suggesting is we have one web VM implement it and a second engine implement it that is not a web engine. The thing I’m suggesting is not saying two web VMs have to implement it, leave wiggle room to bring it to the CG. Unanimous consent to consider a different engine. Then we can work on what Luke said, quantify what the requirements are and see how it applies to non-web VMs.

PP: unanimous consent is the difference I think. That’s a strong requirement. If we just say “a production VM” that's open to debate, but if we say “ a production VM and we have to discuss it in a meeting” that should be less controversial

AR: Difference is, we’d still have a vote in both cases, there cannot be any against vote. Is that the only difference?

DG: yeah, that we have a unanimous vote to consider a different implementation 

AR: That would at least be some progress.

CW: Andreas, do you have a specific proposal in mind that needs this to go through? Are you thinking of multiple memories for example?

AR: My point is this wouldn’t be tied to a specific proposal but reflect the reality of the wasm world as it is today, more for representation reasons than concrete decisions. And I think it’s good to consider that before something comes to concrete. Because then there are all these biases that will convolute that people will argue at that point. So if we can resolve this independent of any concrete thing, I think that is much more tenable.

PP: we should discuss what exactly we mean by “production” engine rather than just relaxing the  language. If we just reduce the requirement, it’s less strong, even if we require one, but from a completely different world, it makes even weather. Maybe also this is related to profiles as a mechanism, if you’re building something that will never be implemented on the web, then you don’t need any web engines.

AR: Fair but I think that is the wasi case which is a different discussion if there are features where the web is applicable. N/A to the web. I also care about features that are core wasm that everybody will potentially want, or many will and what do we do about those. I think we’ve discussed this enough. DG’s point makes sense to me, we can make progress from there.

SJG: i think there are 2 issues: does the group agree that they want input from non-web engines on passing what needs to be voted on, and second the mechanism to achieve that goal. E.g. you could count the number of web and non-web voters that vote for it, you could track whether you have support from implementers of non-web engines, and are we hearing from them. So, is that a direction that 

DS: We’ve always wanted to have that input, it hasn’t been easy. In the browser space, people are accustomed to dealing with web standards, whereas its a much less familiar thing for people with other backgrounds. This really goes back to what Luke said, it would be better to discuss ahead of time for what properties of mature engines that we want to see in non-web engines

SJG: The risk of having some nascent web engine and dictate how the standards move forward is low. The number of mature wasm engines we could just list them out and if someone wants to be on the list, we say how come. The # of non-web engines that exist is finite. We can make a non-exclusionary list.

DS: Those are the different options, do we have an explicit list of features we want to have? We’ve definitely heard of folks embedding WAMR, Wasmtime, which could count as production. Do we want to have a blessed list? Or do we make the distinction on which proposals make sense for which environments? 

SJG: I’d include wasm3 since it includes older environments. It’s nice to get feedback from those engine authors about what would be harder to implement. It would be nice to get their feedback on these things.

CW: Yes, it would be nice to get feedback, but I would argue that that raises the bar for existing proposals. But the issue seems orthogonal to relax the requirements for a particular proposal

RH: I think that's where I’m leaning. Iconservatively i would want to relax this when there’s a real issue. There’s a lot of spec work, toolchains etc that seems to be the bottleneck rather than the VM requirement. I haven’t seen that be a real problem yet. I’m open to be convinced about this though.

SJG: What does conservative mean in this process?

RH: Conservative means changing the rules when its a problem and not eagerly

PP: The point about gimmicks, the non-browser implementations we should just collect feedback. On the different directions groups can take, we don’t know how this is going to affect. Embedded engine says something needs to be in a standard, is that okay that someone in the browser world may do extra work? Really an interesting and difficult question. I know that one other solution is CG to have some of the web apis to add them to the JS requirements, like nodejs. So they are looking at which parts can be relaxed. So maybe web and non-web can be viewed as what subset/superset you can have. Which features need to be slightly tweaked.

LW: one thing i’d also point out to give some mor color here: in addition to the non-browser engines that have been mentioned. Other ones that have been used in production include wasmedge and wazero, thy

DS: Another criteria that occurred to me is that do developers give feedback in some way or do they participate more actively? We would want more active participants.

AR: That sounds good too. I want to push back a bit on what Ryan said that we should only change things if there’s a problem. This is a little like legislation. But laws shouldn't change only when people are harmed. They should be changed when they are bad or need to be improved, even before that happens.

RH: I think one important thing is to see if there are victims of a law, but just semantics. 

AR: i think I disagree with that?

DS: We get regular input from wasmtime developers, and folks that are working on WAMR, the other ones less so. 

PP: This mneeting is inaccessible to WAMR folks, it’s middle of the night for them

DS: You are a regular participant, do you understand their positions enough to have a sense for what they think or represent their opinions do you think? Not trying to put you on the hook but wanted a sense.

PP: I have some idea but  I Would need to talk to them more to be useful. 

DS: We should continue this in a future meeting, or follow up on github. But this is an important discussion
"
gc/2023/GC-03-07.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 7 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: March 7, 5pm-6pm UTC (March 7, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Status checks
        1. Resolving cast annotation issues
        1. Finishing JS API (https://github.com/WebAssembly/gc/pull/355)
        1. Bulk array operations (https://github.com/WebAssembly/gc/issues/313)
    1. Discussion: Implementation-defined limits ([#335](https://github.com/WebAssembly/gc/issues/335))
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Ilya Rezvov
- Ashley Nelson
- Ryan Hunt
- Alon Zakai
- Aske Simon Christensen
- Rick Battagline
- Manos Koukoutos
- Asumu Takikawa
- Jakob Kummerow
- Zalim Bashorov

### Status checks

TL: Check in on a few things in progress. I’ve been working on Bulk Array operations and I have a Binaryen implementation done. Now I’m working on spec tests. I’ve listed out 100 different tests I think I should write for it, so I’m working on cranking those out. I saw that Aske had suggested we should add additional instructions. Since I already have so many tests to write, I think I will not write tests for those instructions right now, but I would be open to prototyping them and seeing if they are useful and if based on that data we think they are useful we can add specification and tests and all that for those instructions. Does anyone have related updates? Or thoughts on Aske’s instructions?

RH: What is the set of instructions? I know about Array.copy.

TL: I pasted in the [link](https://github.com/WebAssembly/gc/issues/313#issuecomment-1458062757) in chat, people had previously discussed wanting a complete set of operations rather than adding just array.copy to the MVP, so the complete set is array.copy, array.fill, array.init_data, array.init_elem. These are 1:1 with the bulk memory instructions. The additional instructions Aske pointed out would be array.new_copy which is similar but allocates a new array and fills it with the copied data. And array.init_fixed which is like array.new_fixed in that it takes values from the stack but it could write those into a pre-existing array. Right now we are adding 4 operations and there are 2 additional operations Aske pointed out.

AC: I was looking at the duality between the new instructions and the array init instructions and saw these two holes in the duality. I think array.new_copy can be very useful, not so sure about the other one. But in the case where you want to create a new array containing the data of some sub-section of an existing array, the only way to do that with the currently proposed bulk operations is to create the array, initialized with some value, and then copy from the existing array to the new array. So with array.new_copy you can do that in one step instead of having to also initialize the array. I think that could be useful.

RH: I think that could be useful too.

TL: I will be sure to implement it in Binaryen and then coordinate with v8. Or Ryan, do you want to get it in Firefox?

RH: Eventually we’ll implement it.

TL: I don’t want this holding up the MVP, so if we get to the point where all the other issues are resolved and folks are interested in shipping, we should just drop it and go to post-MVP. But this seems like something useful to do during the slack space while everything else is cleaned up in parallel. That’s it on bulk operations, I hope to have PR up later this week with spec tests. Andreas and Conrad aren’t here but they signed up to do the spec and interpreter work.

TL: Asumu, can you do a status on the JS spec?

AT: The status is there is a draft spec and it’s in review. It is mostly complete, but there are some changes needed because the JS spec depends on the core spec which hasn’t been written yet. And there are changes coming that will affect the JS spec. About as done as it can be done right now. Not sure if there are any merge blockers, unless anyone has any issues with that. That’s the state of the spec. I also had a PR for adding tests to the JS API and I think those are in a pretty good state too. I don’t know who the best person to review and approve that is. More tests would also be useful. One thing that’s come up, I talked to Thomas via email, but due to project staffing changes, I’m not going to be able to devote a lot of time to WasmGC topics in the future. I can do small maintenance tasks, but unlikely to have time for big changes, tests are included in that. So if anyone has bandwidth to work on those tests, that would be helpful.

TL: Definitely agree for the spec PR, let’s get that merged and ping Andreas about that. Better to have it merged than outstanding and open. Makes sense that when the core spec is written, we may need to change some things.

JK: We have a fairly large set of tests in v8. They use V8’s testing infrastructure, but the test contents would be engine independent.

TL: That would be great, sounds good. Also wanted to check in on resolving cast annotation issues but Andreas isn’t here so we can push that. Just wanted to check-in because we have a new property that determines which things should have annotations but I don’t think we have a PR that adds annotations to the merge and cast instructions. Needs to get done, but we can handle it offline. 

TL: The other thing I wanted to talk about today was implementation defined limits. Here is the issue link: https://github.com/WebAssembly/gc/issues/335 

RH: Before we get to that, on the status checks, has the text format been written yet? I’m guessing it’s a *WIP* since it’s part of the spec, but impacts writing tests since we write them in the text format. It would be nice to have the text format standardize these instructions. 

TL: Great point, I don’t think we’ve formally written any text format stuff. A few fragments have been implicitly specified, because they are used in tests that have been checked in along with the spec interpreter. Defining types has a fairly known format that is fairly stable. The text format for individual instructions can also be read directly out of the MVP doc where they are described, So I don’t think there is too much left, beyond the instructions and type definitions. Fairly stable but not written all in one place.

RH: I expect the instructions are pretty simple, but the one that had the most decisions in our text parser was defining types, especially recursion groups, the syntactic sugar for a recursion group. But if there are tests for that already, I can see if I made the same decisions as the spec interpreter did.

TL: The fully expanded form is fully stable, but the sugar we are going to add to the spec tests is up for discussion. I filed this issue, https://github.com/WebAssembly/gc/issues/333, a while ago proposing a bunch of abbreviations. We haven’t made any decisions based on that. But this is what I’ve implemented in Binaryen’s parser. I would just stick with the fully expanded versions right now and not do any abbreviations until we’ve had a chance to discuss them further.

RH: In terms of testing it’s subtype, structural type, and (missed this)

JK: We could also add a de facto reflection of what’s been implemented. In the long term we need a proper spec, but in the short term, this might be the quickest way.

TL: I think a short PR that adds in what we have agreed upon today, makes sense. I can do that today.

AC: Is the extra syntax for final types and the defaults for that also in there?

TL: I’m not sure actually, good question. I think Andreas added tests that use final types, so there should be some text format there. I haven’t looked at it myself. Any other status before we move on to implementation defined limits?

### Discussion: Implementation-defined limits ([#335](https://github.com/WebAssembly/gc/issues/335))

TL: Implementation defined limits, issue 335. Most of these are non-controversial, million recursion groups and a million total types, no one has disagreed with. No one has disagreed with not having a limit on Array sizes. Most of the discussion has been around subtyping depth limit. OCaml folks and Dart folks say 31 seems low for their use cases. We have Jakob here, I know 31 was chosen to make a bit-packing scheme possible. If we need to make it significantly larger, does the limit really matter? Is there a difference between 100 and 10,000

RH: The bit packing scheme is no longer relevant because the depth doesn’t show up in the value type anymore. That may become the case in the future with explicit RTTs, but I don't know the plan of record for that. Our bit packing scheme I was just looking at, it would be hard to support more than 64 using our existing scheme without doing an overhaul on it. So that’s the rough limit on that. Once you get past that, it doesn’t matter if it’s 100 or 10,000 for the bit-packing part. The other part is the metadata part, space usage would get high for the constant time subtyping trick. We can have internal limits around that. And possibly we could have a heuristic around a depth of 64, we switch to linear subtyping tricks or something like that, but that might have other impacts. But that might be a big performance cliff. 

TL: Aske, for Dart closure representation use case, 31 seems low, what would you expect to be a reasonable upper bound the language implementation would be okay with?

AC: If this were completely unconstrained to the other limits in place, another limit we have in Wasm is at most 1,000 parameters to a function. So 1,000 would be enough here. The in-practice depth would be the number of different numbers of parameters to closures that would appear in the program and in practice this is probably not very big. Functions with many parameters tend to use named parameters so those are not counted with the limit at least in the documentation. So it’s probably unlikely that a limit of 64 would cause any problems. If some program happens to take a lot of positional arguments to function, then it breaks down. I think OCaml case here is more precarious as I understand it. In their case it’s the # of fields in a struct, which often grows to much bigger numbers. And even if they did the same optimization that I suggested where it’s not the number of fields but the different numbers of fields then 64 could become a low limit in a big program.

TL: Definitely will check with them to get more details. Provisionally, would a limit of 1000 be concerning for implementation? I know the space consideration you were talking about could be potentially serious, Ryan.

RH: On the bit packing thing, if it came down to it and we were adding explicit RTTs, we could find room for representing 1,000. It might involve an allocation, but I would hope that would be rare. I’m okay with setting that aside. On the space concerns, it could grow quite a bit if we just naively did that. Even in the OCaml case, they might trigger that without trying to write pathological tests. So there could be some pressure to allow it to succeed but fall back to a slower casting technique which might not be so great. I don’t have a great suggestion here unfortunately. So I guess the question is what do languages expect to happen when they have a very long subtyping chain. Do they still expect constant or can there be a linear fallback? If they are okay? I'm okay.

TL: Wonder if we can come up with something fancy and have a logarithmic fallback

JK: Linear time subtyping checks will be expensive if your subtyping chain is long. It’s exactly the long cases where the constant time is interesting. ON the v8 size, we have the same concerns Ryan has expressed. If it’s small, some power of 2 - 1 so 63 instead of 64. My thoughts on OCaml is if we did 1,000 would that be enough or do they need 10,000 or 100,000? At some point, it becomes unwieldy for dealing with small limit optimizations. My take is I don’t mind adding 1 more bit, how would folks think about the conservative choice of having 63 as the limit right now and if a concrete use case comes up we can consider raising the limit. 

TL: I’d want to check in with the OCaml people before committing to 63. But if their use case is 100,000 just as much as they need 64, then yeah 63 probably sounds good.

RH: SGTM, I don't know enough about OCaml use-case, but it sounds like they are dealing with a situation where they need a dedicated feature. Shouldn't block MVP, from a spec standpoint down the road we can agree to raise the limit. 63 sounds like a good start.

TL: Cool. Any other thoughts on this topic or other implementation limits Struct fields is currently 2,000 and we haven’t heard any feedback that it was too limiting right now.

JK: Yes that’s my understanding, I don’t feel strongly if it’s 2,000 or 10,000. If we think 10,000 is a rounder number, I have no complaints. 2,000 does seem to be enough.

RH: We have no complaints here as well. 

TL: Of course we can always raise it if someone does run into it, but if the implementations don’t have any special considerations to keep it lower, then I would say let’s do 10,000 and reduce the chance someone is going to run into it.

JK: One consideration, we recently started doing a special null sentinel so we can do trap based null checks. So in the straightforward way, it requires having a null sentinel that is as big as the biggest struct can ever be. There is a cost, it’s not huge, but it means that every single Wasm module will burn because the size needs to be encoded in the engine. We can do a fast hybrid [where larger structs have explicit null checks], but that would make implementations more complicated when we do the switchover. That is the cost of raising the limit to 1 million fields.

TL: So say we did 10,000 fields it would be the size of a v128 * 10,000 so 156KB? 

JK: Exactly.

TL: Maybe we keep it at 2,000 for now then. Sounds like there are no strong opinions. 

AC: I think 10,000 sounds like a good pt, Jakob’s concern is 10,000 would be 40KB or so. 

TL: No, it’s 156KB since v128 is the largest possible field/

AC: So yes 160KB then, yes.

RH: Does this memory need to be committed or reserved?

JK: Just reserved.

TL: Okay, 10,000. Great. Are there other limits we need to talk about? Number of operands to Array.newFixed, thinking we should have a limit to the number of operands on the stack in general. What is the latest thinking here? 999 was too low and now it’s 10,000 which is sufficient in v8. Should we just call this 10,000 for now?

RH: I think this is okay but there might be difficulty with our baseline compiler that might overflow our maximum frame size. I have to double check what our maximum frame size is right now. I don’t have an issue with it as long as we're allowed to possibly fail lower than that. We’ll do our best not to do that.

TL: Some can always fail like allocations, but I think the goal of the implementation defined limits is to provide firmer guarantees for web portability. So I would be interested in hearing the maximum frame size you’re working with so what is the max in your implementation. I guess it depends what else is going on in that farmer, and it not about this one instructions

JK: It’s hard to say, and not the same frame, it’s the same stack. If you have some reasonably deep recursion and then array.new_fixed you can run out of stack space. And then the types matter whether it’s i8 or i128. I think we always use 64 bits on a 64 bit machine because we fill all the registers.

TL: I would be fine setting the limit as the highest possible number that has a chance of working or 10,000. If we deterministically fail below the defined limit, we should lower the limit. 

RH: We have ½ MB for a frame. There is a comment that says the reason is 1000 parameters, 50,000 locals and 50,000 evaluations for the compiler. So there is still some space left for that. If you are doing a Array.new_fixed then I believe 10,000 is fine. I can verify after the meeting.

AC: The use case I’ve seen is global initializers and they are not that big. Are the concerns different in global initializers than they are in functions?

RH: Good point, because global initializers will use our interpreter which should fare better. It will be slower but have a higher limit.

AC: So how would it work if we had a limit of 10,000 for the stack inside the function body but a higher limit for array.new_fixed on itself which can be used in constant/global initializers 

RH: One concern I have is the speed of doing this because that’s a lot of values to push and pop off the stack. Are these strings that we are initializing here?

AC: Strings or big arrays. I’ve also seen arrays bigger than 10,000 sometimes

TL: Would we expect that at some point, the benefit of getting a baseline compiler to fill out these arrays with an initialization function would be faster than filling out an interpreter with the array in a global initializer? So there is some crossover point Aske where you might prefer to do it in an initialization function for performance reasons.

AC: You still have one instruction per value and this code is only run once, so we assume the baseline compiler would take longer to compile than the interpreter running them.

JK: Probably a fair assumption, yes.

RH: Is it possible to use array.new_elem or array.new_data?

AC: Yes but we’ve decided not to have that in the MVP.

TL: This goes back to the section ordering problem, I forget if it’s data or ordering or both.

AC: Data is the simple one, the only thing that needs is the number of data segments which we have this extra section for. It’s just not placed early enough. So one of the suggestions in the discussion is could we allow that section to appear earlier. 

TL: This is the data count section that was introduced.

AC: Yes for array.new_elem, it was more complex because it could introduce cyclic dependencies between the global initializers and the elements because the elements could also contain constants. So there was discussion for how we can allow this in a way that guarantees to not run into cycles or can detect cycles and give an error. I don’t think we had agreement on the right approach.

TL: In a perfect world, we would solve this, but if we solve this for the MVP it would delay the MVP which nobody wants.

AC: Ideally there would be a limit.

RH: That helps jog my memory. I’m concerned about the performance of array.new_fixed initializer expressions. I feel this should be discouraged but I understand it’s nice to have. It would be nice to have something optimized than pushing and popping for the interpreter.

TL: I suggest we stick with 10,000 for now and post-MVP we return to this question of what to do with section order. Which is really what you’d want for the global initializers in the first place. I think that’s all the implementation limits for now. Any other spec limits we should discuss or comments about what we’ve discussed? I’ll try to get the implementation limits decided and closed. Thanks all, see you in two weeks. 
"
main/2022/CG-05-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 10 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: May 10, 4pm-5pm UTC (April 12, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Update on [Memory64](https://github.com/WebAssembly/memory64/) (Sam Clegg) [10 min]
    1. Wasm WG followup on Spec versions, see relevant [WG meeting notes](https://github.com/WebAssembly/meetings/blob/main/main/2022/WG-04-13.md) [15 mins]  
        1. Poll: Adopt new versioning scheme to bump minor version after each stage 5 feature  
    1. Discuss a WebAssembly Research organization
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

To be added after the meeting.
### Attendees

* Yurii Rashkovskii
* Francis McCabe
* Yury Delendik
* Zalim Bashrov
* Ezzat Chamudi
* Eric Prud’Hommeaux
* Ashley Nelson
* Jeff Charles
* Dan Gohman
* Francis McCabe
* Sam Clegg
* Yuri Iozzelli
* Chris Fallin
* Paolo Severini
* Slava Kuzmich
* Rick Battagline
* Ilya Rezvov
* Jacob Abraham
* Michal Kawalec
* Charles Vaughn
* Keith Miller
* Ryan Hunt
* Asumu Takikawa
* Ben Titzer
* Luke Wagner
* Mingqui Sun
* Igor Iakovlev
* Johnnie Birch
* Heejin Ahn
* Andreas Rossberg
* Sebastien Deleuze
* Peter Heune
* rrw
* Sean Jensen-Grey
* Deepti Gandluri
* Kevin Moore
* Andrew Brown
* Paul Schoenfelder
* Charles Vaughn
* Sergey Rubanov
* Alex Chricton
* Jakob Kummerow
* George Kulakowski


### Discussion

#### Update on [Memory64](https://github.com/WebAssembly/memory64/) (Sam Clegg) [10 min]

SC Presenting [Slides](https://docs.google.com/presentation/d/1yBBmBRobBWcl3_WvtOacPxnpCqmZk1fbK8K9RNgbpz8/edit?usp=sharing)

RH: SpiderMonkey has implemented the proposal as-is, and should be up to date, can check to make sure, but will probably be minor tweaks.

SC: the major tools have support. There’s a fair bit of work on the JS boundary in emscripten. We can also lower away all the 64 bit memory operations into wasm32


SC + DS: Let’s do a unanimous consent poll for Sam Clegg to take over as champion for the Memory64 proposal.

No objections

SC: Are there any issues the current champion should be aware of? 

None


#### Wasm WG followup on Spec versions, see relevant [WG meeting notes](https://github.com/WebAssembly/meetings/blob/main/main/2022/WG-04-13.md) [15 mins]  

LW: background: a year or so ago, when wasm 1.0 reached REC status. What do we do? Start a new REC with a new version? Another option is “evergreen”, a new thing in the W3C used by HTML now. Once vetting is done, we just have the WG publish a Candidate Recommendation that reflects the live status in the CG. It reduces the delay between CG and WG publication. Fits with the goal of making the CG be where the interesting stuff happens.
It means that the choice of version number is done by the CG, not that there are not versions at all. We do have a changelog with a monotonic version number (that happens as a result of how we merge things into the spec in the CG).

About half a year ago, we chose to adopt the EverGreen model, but didn’t actually release versions. In the mean time the WG charter expired and we needed to put up a new one quickly. So since we agreed to evergreen before, we wanted to decide what version to call it. It couldn’t be 1.0, that was the REC number. Could we take the current CG number (1.4 currently) and bump it when we bump the evergreen version. But that doesn’tw ork because of the WG process and tooling, the WG version has to stay the same.

The version used by the WG would be a major version, and we update the minor version when a feature is bumped, 1.0 is already taken, so we decided to go ahead with a 2.0 major version. The version is 2.x, and everytime we merge a feature, a minor version would be updated. So it’s a version 2 that’s live, but not an explicit 2.0

If we want to, the evergreen model allows us to stamp an REC spec. That would cause us to bump the major version to 3. If there’s some process reason we wanted to do that.
The WG discussion happened quickly because of the charter expiration, but we do want to discuss here.

BT: I support having linear versions, what does that mean for engines that have to ship features one by one?

LW: That story is unchanged. You can always enable a feature independently. The discussion of what the version numbers mean? For ane engine to support a version, it includes all the features in the version but there can be other things too.

EP: I would expect that there’s not a huge gap between all the versions having the same feature, when we’re ready to release a REC, as a nominal endpoint for the process, the time required is usually short

SC: is there a 2.0 REC then?

EP: Just a first public working draft, and then it has to start the process from the beginning, we would have to do that even without transition to Evergreen

SC: so 2.0 is just a draft then?

EP: It’s just how the W3C communicates with the rest of the world

SC: and when it’s released it will be called 2.0 or 2.1 or whatever we call it?

LW: the idea is that there will be a CR that always stays. It will always have a major version of 2, it will be baked into the URL and such and won’t change. And when we add to it in the CG we can bump the numbers in the doc, but the version of 2 in the WG won’t change.

EP : An interplay between, anytime you publish a working draft, you get a dated draft, if we coordinate the minor versions between those, we could have a dated version for small constellation of minor versions.

LW: Any other questions?

POLL: Adopt new versioning scheme to bump minor version after each stage 5 feature

DS: Any concerns or objections about this? 

EP: There’s some text that we changed as we had said version in the first public working draft, someone submitted an issue to say it’s version

AR: yeah, release. So “version” is teh W3C term, so we can keep that reserved and update the doc itself to say “release”

FM: Are there any significant changes to the charter?

EP: there was a small interim charter to let us publish the working draft. We’ve got a charter (https://github.com/w3c/charter-drafts/blob/0bfabf552a6418b1e29628d47e887dc8d00c5dd1/wasm-2019.html is the old draft charter, new one is TODO) that’s benign circulated with the advisory committee. It’s pretty much teh same. The template is changed a bit,b ut the section that matters (the deliverables) are similar. I took the previous deliverables, removed the ones we’ve already done, and added some proposals that were in flight in the CG.

AR: In terms of the process, do we intend to automate when we push something to merge into the spec? Can we automatically merge or is this a separate decision for the WG?

EP: We’re probably going to not want to make it a git hook to avoid minor fixes bumping the versions. We could automate it as a button that releases when we want it. I
‘Ve tried to automate it before, pretty close to being automated right now

AR: I guess we just have to decide whether we want to view it as being automatic, or say that we push one out whenever we add a new feature

EP: Right.

DS: We’ve been thinking about this certainly as whenever a new proposal makes it all the way to Phase 5, the idea is someone would push it out, we can decide on a case by case for smaller changes. 

AR: Decision connected to bumping minor versions, i.e. is this worth bumping the version?

LW: Like this being the CG choice, whether this change is worth bumping this etc?

AR: YEah, there’s just not a way to change it in all the places that it needs to be

DS: There’s a way to publish minor changes without increasing the minor versions, and then only decide when we want to bump for significant changes

AR: is there any reason not to push minor corrections as they come?

EP: probably not. That’s what they do in the HTML WG, they are sort of the model for this.

AR: We might as well automate it. IS there any point where we have something that’s not a draft anymore? To say this is a recommendation now?

DS: Other way around, only evergreen but not draft

LW: When we publish a new rec. 

EP: We have to do it at least once a new charter cycle. IT’s sort of our contract with the W3C

AR: how long is the charter cycle?

EP: Typically 2 years, link dropped is the draft charter for review, anyone here can propose that the charter be longer, intended to do that but didn’t. 

AR: so you’re saing we’ll have to bump to version 3 in 2 years?

EP: Gave wrong link, we’ll have to publish the REC at some point, we’ll want it to correspond to some set of features, also to present some subset of features as an atomic versions. Release is entirely our own thing, and we can change it when we want, i.e. bump the major version at the point

AR: so you’re saing we don’t have to bump version even if we push a REC

FM: scanning the charter, another question?

EP: before you go into that, let me fix the link

FM: Small warning that this may be a longer discussion, on the JS side there are two deliverables, the JS API & the Web API, I’m in the middle of drafting something for JS Promise integration API, and it seemed like neither of the two was the right place for it, the JS API doc has grown, this may need reorganization, can we change this without needing a new charter? 

EP: yes we can say “here are new doc” we can just publish a new working draft with the new organization. We’ll have to come up with naes to go in the URLs, but it should be OK.

SC: curious about the level of detail we’ll have in the changelog. Do we have that now, how much detail is there?

EP: Very coarse details are required, beyond that it’s upto Andreas and us
AR: You are talking about the changes in the spec itself. 

SC: As a reader of the spec, what has changed?

AR: yeah what I added in the appendix, lists all the instructions and types added but doesn’t go into details. Usually it’s linked. It doesnt give you a detailed diff of the spec. If you really need that as an implementer, we’d have to produce that separately. There’s HTML diff, not sure how useful that would be for this. The appendix just gives an overview, e.g. the constructs but no extra info other than links.

EP: HTML diff tools are more useful on single page docs, this might take more.

AR: I’m not sure what a better answer to this would be, we don’t want the spec itself to have the diff info, that would be cumbersome, 

SC: You can actually do a git diff in the spec repo

AR: That’s going to be a lot, and harder to read the spec as well

FM: ergonomically, having something that says “features since v1.1” on hover would ben ice. But not not trivial to implement.

AR: We could annotate some of these.. Yeah not easy.

EP: It’s not always that the versions correspond to a new versions of the document. 

DS: Do we have any implications on the W3C side? That’s the only thing we have to do decide now

POLL again:

No objections.

 #### Discuss a WebAssembly Research organization [Ben Titzer]

BT: I’m interesting in doing research on wasm in a lot of context. There are over 100 publications in ACM DL tha mention wasm or use it. I think this is healthy. Academics have a relationship with the CG, comment on varous language features, potential uses, in particular stack switching.

There’s a value add of people having academics also look at this and use. The particular thing I want to discuss isl what is their mode of interaction with the CG, and is there space for another type of organization that might be under the CG umbrella. We could have something called “webassemly research”. There are several sub organizations or teamson github. What would people think about having another organization or team that is focused on research

IT would host the things people that on the research suite would find useful, like benchmarks for example, or research tools to do dynamic tools. IF we want  academics to share tools, data and information for research, this would be a place for it. What does the CG think about that?

AR: is there actually a clear distinction between production and research things? Ideally things would cross over. It seems maybe suboptimal to separate them into different organizations? Also, I’d love to see under the wasm organization is the mechanization efforts, e.g. Coq and isabel? Also researchers don’t always want to give over their hard work.

BT: That’s something I’m wrestling with, my particular area of research is engine research, I’d like to be able to bring that under the Wasm org, definitely the mechanization stuff would be a good candidate

AR: Conrad’s stuff is in the open, it’s a fairly large project with its own repo

BT: I’ll mention Jikes, open source, 100s of students worked on it, the VM itself was open source, so people would make their own changes, it’s not clear what it looks like these days?

DS: Maybe the concern I have with that is, everything starts out as a repo/research group etc. at some point they say I’m willing to share this with the broader public, there has to be some criteria to say what belongs in the organization. The two extreme options are that we take everything Wasm related, or only take them if there’s an official Wasm publications, we don’t have a good criteria for what we have under the organization

BT: that's true. Also there's no clearinghouse for wasm research, where everyone knows what people are working on. Groups do their own thing. So it’s not clear how we go from them having their own internal things to having shared things.

EP: We could do something like github ?? that people could link their own work too

BT: yeah there is also a list of e.g. interesting languages. We could start with something like that and when things are interesting enough that people can use them, they could even be moved.

EP: Two criteria there - we have a sample URL to give for citation, if they are playing around with some implementation of it, if there’s a diff with a spec then that sounds like we want to adopt it

DG: there’s also a 3rd category, tools that don’nt have impact on the spec but are useful for research purposes, useful to share work instead of reinvent the wheel. There’s a place for that too even without an official spec diff

EP: Would a Wiki solution work for them? 

BT: It’s a good start, there’s definitely things that need to be up leveled, there’s lots of engines we can modify, we have to reason by analogy, something like SPIM, there’s a lot of papers that came from that, maybe Wasabi is a thing like that, here’s this thing that we want to analyze something like that

DS: What is it that an organization like the CG provide? Researchers can always find/form repos. In the initial phases, bringing information to the CG actually just slows them down, but maybe at the point where you want a framework in which you want to work across organizations, that’s what the CG helps with. Do we want the CG for that? Or do we want another organization that has a separate charter that can produce useful things.

BT: i see it as a potential for giving a singal boost, not necessarily a blessing like the CG blesses the spec. But if we want to attract researchers, any kind of boost is great for them. If there’s something official even if it just a research org, that makes research of wasm more attractive for research, which can lead to more work on production or proposals.

KW <in chat>: “One service it would be nice to have is a place for researchers to discuss work-in-progress and get early feedback from (a) other researchers, and (b) the Wasm experts on the CG.
The CG meetings don't seem to be quite the place for that.”

BT: I agree, it would be great to have a place to discuss this early stuff.

FM: There’s a related thing, general outreach, if this is the place that people come to for information, we could have some curated source for information

BT: yeah

FM but we are a natural place for someone who want to find out more to go, the reason may vary, how to do research, or just general info.

BT: I see it also as a researchers are interested in getting a transfer of ideas, so this is a good place for that. For example, what are concurrency primitives for the GC proposal? There has tpo be a big enough payoff for senior folks to devote resources for that, so I’m trying to find the carrots that we can offer to those people? 

EP<chat> : is that the discord channel?

KW<chat>: Not in my experience -- I think it's probably too much to expect that from a 24/7 chat group (few researchers I think have the time to hang out there in case somebody else pops up and wants to talk about work in progress, and honestly not that many Wasm experts do that either)
BT: yeah it’s hard to know who will show up in something like discord.

FM: Would like to endorse what you are suggesting, and lift the game a bet, the CG is the locus, we’ve been focusing on building the thing, there’s going to be more in the future, there will be other kinds of connectivity we want to establish. Agnostic about where it should be, but it would be useful. 

BT: I do like the question, What are the criterea by which we take in projects? We should think more about that

DS: and what is it that we can offer that nobody else can?

BT: They have no expectation that the actual Wam people notice, being approachable, and potentially getting the big signal boosts. I think it’s a pretty big value add

SJG<chat>: Access to collaborators, major engine authors, open questions in wasm?
Researchers could show up here and do a 5 minute poster? 

KW: one service it would be nice to have if you maybe designated a CG meeting every couple of months or something as a research day, where you invite people, can give talks and get feedback etc

DG: TC39 does something similar called “incubation calls” where they discuss new ideas and that sor tof t thing, that aren’t proposals yet, things people are thinkigna bout. One thing i’ve heard feedback on is kind of in this visibility into what kinds of problems people are working on even if there aren’t proposals yet.

BT: yeah its definitely related. When I think of incubation i think about things that could use some help getting a long. Something like e.g. a new language port, that could have a big impact if it brings all those languages’ users to wasm.

YR: Definitely value to have a research day, basically open to everyone that’s trying to push the boundaries, and explore ideas. IT m ight help directing people to information that isn’t charted yet, because there’s not a single map of things, often times I have to socialize the work, and that’s a day to find what people are working on. A research day might have tremendous value. 

SJG, YR<chat>: +1 research day

DS: Thanks for bringing this up, sounds like we want to kick off a discussion on github or think of bringing this back at a future meeting

"
debugging/2019/debugging-07-16.md,"## Agenda for the July 16 video call of WebAssembly's debugging subgroup

- **Where**: zoom.us
- **When**: July 16, 3pm-4pm UTC (July 16, 8am-9am Pacific Daylight Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Derek Schuff
    - Email: dschuff@google.com

### Registration

None required if you've attended a wasm CG meeting before. Email Derek Schuff to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.

Installation is required, see the calendar invite.

## Agenda items

1. Opening
   1. Introduction of attendees
1. Goals and scope of upcoming debugging work
1. Future meeting schedule

## Meeting Notes

* [DS] Derek Schuff
* [YG] Yang Guo
* [YS] Yulia Startsev
* [NF] Nick Fitzgerald
* [PS] Paolo Severini
* [BT] Bill Ticehurst
* [ZN] Z Nguyen-Huu
* [YD] Yury Delendik
* [RL] Ryan Levick


Current state web assembly debugging: Not great.
  * FF devtools can show the disassembled code, set breakpoints, step.
  * Can show variables
  * Has sourcemap support, but this is only line table support.
  * Not full featured debugging info from this
  * Parses dwarf directly (pilot)

Chrome has similar support.
We would like to do better.

LLVM ecosystem Outputs dwarf (thanks yury)

[YD] Making tweaks to dwarf (a webassembly flavored dwarf)

[YD] We are lucky that dwarf already emits line information

[YD] Allow encoding local and global variables

[YD] We can generate wasm binaries with dwarf sections with special information

[YD] There is a patch to encode wasm local in expression

It’s a little controversial, contributors to llvm/dwarf recommend using existing primitives

This isn’t ideal, we would like to be able to extend this beyond what dwarf support by default.

[PS] also tried it out in V8 and it seems to work well

[YD] Idea is also not to expose dwarf to web browsers directly. Can also generate native dwarf translated from wasm dwarf for native debuggers to debug JIT code; allows attaching a native debugger to the browser

[YG] I had in mind an engine exposing an API to provide state like the wasm stack which the debugger could request, then translation wouldn’t be needed.

[YD] Trying to consider both cases; browser and more “native” case (e.g. wasmtime) because there is a lot of interest in both cases. Transformation works well there

[YG] Having VM expose wasm stack etc seems simpler than translating dwarf.

[NF] Do you mean expose the source-level stack in terms of wasm?

[YG] Give a way to expose architectural state such as wasm stack and wasm memory 

[YD] In this case, you cannot reuse most of existing native debugging capabilities. You have to implement the debugger yourself.

[YG] for this you need some sort of bridge between LLDB and ?

[DS] You would need to port your debugger, which would be some work. But there would be a number of similarities

[YD] Memory isn’t the same. There are different address spaces e.g. in ELF the code is in memory. LLDB/native debuggers have a common address space, so that idea is foreign for native debuggers.

 [PS] we will always need to attach the native debugger 

 [YG] so you’re proposing that the VM would parse the wasm dwarf, translate to native, and then provide that object to the debugger.

[YD] it works right now, I evaluated it with crane lift and it is working.

[YG]  I had assumed it would be easier to do it the other way

[NF] different environments will be easier or not, depending on the context. Inside a web browser, I am not so sure about that -- developers will want to use their existing tools. I am not sure that dwarf will work in that case 

 [YG] I was wondering if we should standardize around dwarf or not. It may or may not work for all languages that use webassembly in the future. To make this the job of the VM to transform wasm dwarf into dwarf puts a certain burden on the VMs.

 [NF] Don’t know if everyone has seen the presentation from a coruna, but briefly, the surface area of capabilities that the debugger wants to expose is much smaller than the surface area of all the debug info that we’d ever want for all languages. The VM doesn’t have to know how to parse dwarf, etc. it just knows how to make the queries. We can standardize the smallest amount possible and let the community work out the best/smallest format.

[PS] whether this debugger module -- would it always need to know the internal state of the engine. This part is not clear to me, how this would work if the module is completely separated and only provides an interface.

[YG] I think the way is that you’d … query the debugger module, but the engine would have a low level interface to query e.g. the stack

[NF] it would almost be the same interface, but the one exposed to the debugger UI is almost exactly the same as what the debugger uses now While the one exposed to the module is specific to the language / whatever

[YG] the frontend of devtools/debugger would set a breakpoint from a source line, request that from the debugger module, which would translate that to a wasm instruction and request the VM to break there. Then the VM would call back into the debugger module which would call the frontend.

[PS] bit the debugger module would still need to call into the VM to get the state.

[YG] that would take a couple more round trips but yes.

[NF] the other thing is that it’s possible to support something like Blazor eventually. You could have a debugger module that uses dwarf internally to answer these queries. Blazor is an interpreter, not AOT. the wasm stack isn’t useful, you’d have to look at its internal data structures. Dwarf would not be a good fit for this use case

[DS] Yeah we had talked to the Blazor folks in the past and it was not a good fit. What they are doing now is they are intercepting the chrome devtools protocol and injecting their interpreter in the middle to do what essentially we are discussing here 

[YG] This gives us the ability to not use dwarf and just use any data format that you want

[DS] Eventually in the future I think there will be a standard for a file format, if you look back on the doc that nick wrote about requirements. There will probably be a spec for a common way to format data for debug information so that tools can reason about it. 

 [BT] You’d probably want a separate v8 isolate to run the debugger module, to make those queries since they’d be privileged?

 [YG] I would assume that yeah. Previously, in V8 -- part of the JS debugger was written in JS as well. It already had privileged context, but having a privileged isolate would make it a lot nicer.

[NF] thats an implementation detail though

[YG] Yes, you could even make it out of process and use RPCs.

[PS] devtools will also need this capability to always be able to debug WASM right?

[YG] Im imaging that devtools frontend wouldn’t have too many changes. All it needs to do is give a high-level understanding of wasm debugging. But it doesn’t have to translate high-level debuggability to low level because it would have the debugger module. So it could fetch scopes, request things at the source level. All this exists for JS already, so it would map well into that.

[PS] we just need to extend the CDP to add just what is missing 

[YG] I expect that there are some things that are slightly different so we could extend the CDP a bit. So we’d probably need something that expresses types (since no types in JS) but this would be small improvements and not fundamental changes.

[PS] And you said there are other kinds of debuggers, how would that work, would it use the same api to talk to the engine? It would need to talk to the module so it would need to run webassembly

[YG] the point of having the debugger module is that you’d make that an implementation detail. It could be a shared library that you load at runtime. Having a wasm module do it seems easier.

[NF] since wasm is capabilities based, we could play with the idea of statically known debug info vs things that need to inspect memory. That could be the difference between whether the debugger imports introspection apis. And you can decide to import them or stub them out. You could build up native dwarf if you want.

 [YG] I’m not quite sure what you mean. You’re saying that if we don’t expose the lower level API to the debug module, that it would still do some (serialization?)

[NF] It depends on how we do some of these cuts. If some information like line tables don’t need to dynamically inspect runtime state. You can go through and enumerate the offsets -- and you could build up native dwarf rather than wasm dwarf. You can see how far you can push this.

[YG] I see so if you have e.g. information in a stack trace, it could be interpreted without the need for more capabilities.

[PS] What will be the next phase then? 

[NF] We could try to agree on some very minimal kernel of an idea that we can start playing with and implementing and standardizing. It seems like people generally like the idea of a debugging module. We could do a poll to see if people feel good about that? 

[YG] I am a bit torn about this being a JS api or a WASM API. It could be both and there are merits to both 

[DS] There is no WASM api at the moment, we don’t have a way to spec those. WASI is the closest we have. It probably makes sense to start thinking from the perspective of JS capabilities, and then we can change it and the way that its defined. There is hope that with the webidl proposal and build on that

[NF] I think that bindings would be very good for this purpose, since it would allow things like taking webIDL dictionaries. The property-bag approach is amenable to adding more information to a query in the future. Dwarf really bends over backwards to ensure that its future compatible and extensibile, but that makes it convoluted. Using bindings allows easily adding stuff.

[YG] To be fair, in javascript you would have the same advantage since you can just pass a bag of properties. 

[NF] not all wasm environments are going to have a JS environment. IF we use the IDL to define them it will work for all.

[YG] Thats true. Yet another way would be to have a wire protocol, could be any existing ones or a new one that we come up with. I think that could also be an implementation detail  

[DS] That is one thing that i observed, the reason that we want this as an api rather than as a protocols, is that protocols could have a lot of round trips. What I think is that in the space of debuggers, the protocol seems to be something that they do. If protocols are the best thing for native debuggers why not for us?

[NF] I would say that it wasn't just the round trips that you have to do, but standardizing a protocol is more work than standardizing an interface. You would also have to standardize the details of the wire format.

[YG] realistically there’s not going to be too much of a performance difference because you'll want the debugger module in a different VM instance anyway and copy stuff around.

[NF] I wonder how much work it will take to get around that .the dwarf expressions let you know information about a few things you might want to do all at once. Whereas if each of those steps was a round trip i can imagine a lot of latency introduced. 

[YG] Unless the debugger API is high-level enough that it asks for local variables in the sense of wasm. Or e.g. all the locals at once.

[YD] There is also type information that needs to be known by the debugger. Right now javascript doesn’t need to know about types, but we need that for wasm. 

[YS] Also one of the reasons why the JS side is interested in a standardized debug format is for things like clojurescript or other typed lanaguages that compile to JS.

[YG] That essentially is the problem of transpiling any language into javascript. The problem here is that sourcemaps are just not good enough

[YS] In this case we don’t have dwarf to start but other languages that have advanced debug environments is that they have interfaces similar to what we’ve been talking about e.g. just running a clojure REPL

[NF] That’s also the other thing - expression evaluation. There are lots of features here, it would be nice to have a small subset. 

[DS] IF we can split debugger from front end and identify the capabilities that go between those, and specify those as a protocol. Then we just need to add a serialization on top of that.

[YG] I agree, once we crystallize out the components and their responsibilities, other aspects are negotiable. 

[BT] since you’ll have multiple wasm modules being deb ugged from different compilers, they have to coexist.

[NF] If you have two things that use different types of dwarf, they can just say that they are dwarf and get different input. 

[BT] with the cross language, e.g. JS to wasm etc, mostly things will delegate cross-langauge stacks etc to the frontend. The debugger won’t know about JS Frames, etc.

[YG] I guess the font end would need to know the difference between a wasm frame and a javascript frame to understand the content of each frame.

[BT] with things like ref types and host bindings is there anything coming where reaching into other frames something that will need to be known about?

[YG] I guess reftypes are going to be interesting in that they are opaque in wasm and not so opaque outside of it

[DS] I think there is going to need to be some kind of mechanism to allow whatever component that implements the ui, to know which language this frame is from, which debugger module will be used to query information about it. There will need to be a way to hand off between debuggers.	

[BT] Interesting to thing about things like data watchpoints, etc where you have to translate data addresses. There will be minor wrinkles as we implement this.

[YG] I think at this point just being able to debug one source language would be a great progress. We will need to think about this down the line but we will get there and worry about it then.

[NF] how about this for a 0-level MVP. how about we get line tables/breakpoints working. Replace source maps first, then think about rematerializing scopes/variables, but without pretty-printing. E.g. if you get a rust string, you just get the heap pointer + size, etc.

[YG] I think implementing this MVP might not be that hard. You just need a JS implementation that understands source maps and hook that up to the right apis. 

[PS] Shouldn’t we start with dwarf, since we’ll use it anyway?

[YG] I think realistically we won’t be based off sourcemaps, but we can implement the mvp easily using sourcemaps

[BT] Either should be doable since  we have the dwarf work already

[DS] We might need something that parses the dwarf and interacts with it. It might be more work upfront but more sustainable in the long term

[YD] FF can essentially replace source maps with dwarf today. So today it can translate dwarf into JSON, which contains the dwarfdump in JS objects and can be used to get line information plus everything else dwarf contains without low-level binary stuff. 

[NF] ITs all the debug info section right?

[YD] Yes, with expanded satellite sections. 

[PS] is that scalable? Dwarf is already quite compact but it’s large anyway.

[YD] Yes its huge, but I didn't find any issue with loading. With modern computers i think they can ingest that. But we cannot browse it for huge projects. I am only using it for small projects. The dwarf that we get from llvm has a lot of dead entries. If we purge all of those dead entries it will be a lot smaller

[YG] I’m a little worried that if we just take dwarf as the standard format this way and write the parser, etc that we will just be reinventing the wheel, and catching up with the feature set will be difficult.

[PS] My experience with playing with the prototype, is that using an existing library to parse dwarf it as not so bad. It’s complicated but not huge. I have the impression that using LLDB might be overkill

[YG] I haven’t experimented yet. Iw could be that lld is overkill. But when it comes to evaluating expressions etc that we’d get that for free.

[PS] LLDB doesn't know how webassembly works, so we would need to implement everything that is web assembly specific ourselves

[NF] They don’t have an assembly script interpreter for sure

[DS] The LLDB would buy you the language specific part of that. Ie C, Rust, etc. Maybe we should find out about that, because if it is just compiling with clang it might not be so useful

[YG] Unless you ship a wasm version of clang

[YD] It doesn't matter, we have 2 use cases. Compiling LLDB to understand wasm. If we discard that we have one case. Have lldb just read native dwarf

[DS] <discussion about expression evaluation parts and also having lldb as a debugger module>

[BT] one observation is that you can connect remotely, and the remote debugger has the sources and symbols, and the local one doesn’t have the confident data. In this model the local one would have to have all the symbols.

[YG] The way i was thinking of this is that the target (production wasm binary_ doesn’t come with anything. You would have to compile for that a specific binary with a wams port of lldb and the respective adapters to the debugging apis. You would have to ship a different debugger module for every wasm module that you ship, but it would not expose any confidential information. 

[BT] youd need to run the debug module on the target you’re debugging though?

[YG] I guess so, unless you have the thing that is talking between the vm and the debugging module. I guess that would be a problem in some use cases. 

[DS] I think you can probably extend this to a simple server where you do not have to package everything. With source maps you have a url to the maps. But we could have that for the symbols and other things. 

[BT] I am thinking about the run time impact. It would be interesting to explore the security implications. Having a server that spins up a module and just starts running it is obviously something to think about.

[DS] Ok, so before we sign off. When do we meet again and how often. The other thing is what do we want to do and when do we want to start doing it. NF mentioned that we seem to be on board with the general capabilities and we have a rough sketch. Do we want to start sketching out how those interfaces should look?

[agreement]

[DS] Nick do you want to start with what you had on your slides?

[NF] Yeah, the rough edges were ignored a bit, but i think that trying to match existing source map capability is a good checkpoint 

[DS] How often do we meet?

[BT] How aggressively are people working on this? We are happy to jump in wherever we can to help

[YG] Every couple of weeks sounds good, but i dont think we will have something in two weeks. Once a month makes sense

[NF] Why don’t we start with once a month? If our meetings run more that the full hour we can bump it up.

[DS] I will start a git hub thread about scheduling.
"
gc/2020/GC-08-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 11th video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: August 11th, 4pm-5pm UTC (August 11th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: [Garbage Collection with Two Types](https://github.com/WebAssembly/gc/issues/109)
1. Closure

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Adam Klein
* Andreas Rossberg
* Benjamin Titzer
* Ben Smith
* Daniel Wirtz
* Emanuel Ziegler
* Francis McCabe
* Jakob Kummerow
* JP Sugarbroad
* Keith Miller
* Lars Hansen
* Luke Wagner
* Ross Tate
* Sabine
* Thomas Lively
* Tobias Tebbi
* Wouter van Oortmersson
* Zalim Bashorov
* Zhi An Ng

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

### Proposals and discussions

#### Discussion: [Garbage Collection with Two Types](https://github.com/WebAssembly/gc/issues/109)

[Slide presentation](presentations/2020-08-11-sugarbroad-gc-with-two-types.pdf)

JS: Anyone interested in helping implement/prototype?

FM: I think there are people who are interested. You said that languages are doing dynamic casting anyway, can you say why that might be?

JS: couple of reasons have shown up, kotlin, e.g., potentially using arrays of anyref, to maximize flexibility in the absence of compile time parameterization. OCaml has some amount of dynamic casting.

RT: For ocaml, every function call has to cast the return type, since the wasm type system isn't precise enough to guarantee that it's not an arbitrary object. If you are given arguments, it's the same problem. Until you get to a much more precise type system, then you have to fallback on dynamic casting.

KM: confused, is it because they don’t trust the code they are linking against. OCaml is compiled with type erasure right? Normally it doesn’t have to do that.

RT: It's the trust model is the issue -- for wasm you don't trust that the type is correct. For ocaml, you trust that you have already validated the types.

KM: has to be downcasted to the shape, not that OCaml is doing it for itsel

RT: Only when compiling ocaml to wasm this is the case.

AR: explain this slightly differently, you can have monomorphic calls when compiling OCaml, there is no problem using concrete type. The problem is compiling polymorphism, don’t use monomorphization, polymorphic fn have to work for every type, needs  uniform representation. A monomorphic fn has to be compatible with it, can pass it to polymorphic HOF. In general, you have two entry points to monomorphic fns, one that expects uniform rep, unwraps, then call monomorphic. Whenever you cross the boundary between mono and poly where you have to do that.

KM: I get it, I was misunderstanding what Ross was saying. It seemed bizarre that ocaml wouldn't trust the code it was generating.

LH: Are these tagrefs arbitrarily large?

JS: tagrefs will compile down to numbers, they are type IDs. If it is a recognized/canonical type id (yet to be defined), then when instruction uses this, you get (hopefully) a specialized type rep, if not you get boxes. Opportunity cost to make things less deterministic, e.g. V8 uses 31-bit SMI, … will be an option for V8 to conditionally box integers based on your bit size.

LH: The reason I'm asking, your writeup the tag references can take any number of values from stack and package them up...

JS: Certainly a design point that can be explored … borrowed from EH proposal. Nothing to stop you to do it in a more general way, boxing up a tuple. That would force a tuple.

LH: I don't want that, because I have to worry about cost, can’t represent that easily in the compiler. In a streaming compiler, you want value stack (actual thing) to have elements of manageable size.

JS: tag.pack in this case would be a heap allocation...

LH: but that’s pretty expensive. I can do that, but not cheap.

JS: It's not intended to be cheap at that point.

LH: you can do this, but...

JS: If it turns out that that's not useful, we can remove it later.

RT: only canonical tags should not require heap alloc, non-canonical ones <cut off>

JS: This is one of the reasons that i32 didn't have a canonical tag defined, it doesn't seem like you can do a cheap canonical pack for every embedder. You may want deterministic performance, even if it's not high -- we need to explore that space and see how we can flex the performance. I wanted to provide in this MVP, users that are not performance-sensitive, they are going to use externref. There is a non-trivial cost to shipping your allocator (like rust wee_alloc), there's a market for not having to ship your allocator. This provides a way to … even if you eliminate the reference part of it, just not having malloc is useful for some customers.

FM: you view this as an MVP, elaborations in the future. In the write-up, there is talk about doing the pre-type checks, so not every access needs to do the check. Re: future elaboration, how much dynamic type checking are we signing up for on a permanent basis.

JS: Good question. I think the idea here is that, there is no promise of dynamic type inference. This is the version you use if you don't care about performance, we can expand structref. tagref can be used for interface hiding and discriminated union, maybe equivalent to Andreas's proposal. If you provide that type information, then you get performance. If you don't, you get dynamic checks. If we stay with this for a long time, or if there are cheap wins from inference -- for example assert_bounds -- inside of a function's flow you can provide the bounds to remove checks. Not sure if there are other checks possible here, probably only done if they are cheap.

RT: we looked through a number of languages, even though there are more dynamic checks, those are cheaper, and more flexible, a number of systems perform better even with the more frequent checks

JS: At least we hope they will...

AR: Amount of checks you have to do in the MVP, especially if you want a uniform representation (like a functional language will want), is kind of like a stop gap measure. Eventually we have to do something about it, need to add type params (parametric polymorphism).

JS: I agree 100%, this is the MVP, we are rapidly going to fine that people want refined types. But hopefully we can make those decisions on hard data from real-world code. e.g. 50 instructions could be removed if we had the right types.

AR: it’s not that easy though, if you are constrained in certain ways, you structure your rep in certain ways, might not map to if you have a certain instructions you can use those differently. It doesn’t compare to what you are doing now.

JS: one of the reasons why i’m excited to find out what comes up of the V8 experimentation on the full proposal. Maybe we can get data about how they differ, and find out substantial road blocks for this.

KM: Going on that, I don’t think the simplicity of the proposal removes my desire to show that any GC proposal is better than compiling to JS.

JS: I don't blame you there, at the same time I stand by my comment in the thread. There are spaces where people aren't going to want to install a JS runtime, but they are going to want a wasm gc.

KM: don’t know if <cut off>. Agree with that, I will have concerns shipping it on the web. There are probably people who don’t want to have two different runtimes. I think there’s a lot of opportunities here, despite the fact that it’s super dynamic, it can be faster than JS. Particularly maintaining deoptimization side state in JS is very expensive, kills register alloc. The assert trap is uncatchable in Wasm, then we don’t need to maintain that data, no need to keep the flow.

JS: You wouldn't want assert_bounds to throw an exception, that sounds like a terrible idea.

RT: The shape analysis and hidden class in jS, that’s telling you, when accessing a prop, which field do you look at? This thing boils it down to “look at this field”, and a tag check. We eliminate all the shape analysis and gives you what it gives you at the end.

AR: You will still get in the business of dynamic analysis that JS JITs go through. I'm a bit nervous about going that route, because we're...

JS: agree 100%. I don’t want people to heavily optimize this MVP. If we choose to ship this, i will want to iterate relatively quickly… once we ship something, there will be some people who try to use it and complain about performance. I would want to encourage embedders to resist the temptation to optimize this intermediate step. The purpose of this is to ship something that satisfies some use cases and gets us information. I’m not sure if we might ship this, if we get good enough data from an experiment to inform final design. I don’t know. That’s the crux of some challenges we had, we have great ideas and not a lot of data.

AR: That is true.

BT: We're stuck on a step before that. We haven't agreed on requirements, what are the requirements for languages, static typedness, etc.. we need to have a crisper problem statement for what we're trying to do. On a number of requirements this may not be performant enough.

AR: baseline requirement that KM mentioned is that it should be faster than JS. This might require JIT work, without which you might be slower than a JS engine.

RT: A current MVP, ocaml has to represent everything as anyref, requires many casts. Dynamism is there, already in current MVP. We're not adding dynamism, we are acknowledging that it exists and planning around it.

JS: I don’t disagree, we don’t know, it’s possible that for some langs, like C# or Java, can find a way to compile down with one option, or can compile to JS more efficiently than they can to this MVP. Personally don’t think it’s likely, even with the amount of dynamism in this, the expense is in how much indirection, cache size, working set, more than the degree of dynamic checks.

AR: I still think you have more dynamism, even in monomorphic code.

JS: it’s possible, one of the reasons I would like to see examples of what this looks like with an actual language compiled down and running.

AR: don’t disagree

BT: is there a requirement that we support statically typed languages well. Personally, the requirement Wasm GC to be a value add to Web Platform, it should serve languages that are not served well by compiling to JS, almost always static type languages.

KM: What does well mean, better than JS?

BT: more efficiently than JS in particular space, not so much runtime

TL: is it also a non-goal to serve languages that are already served OK by JS?

FM: I proposed before that we look at the most popular languages, and use that as a metric for what to do. e.g. Java is most popular language we can support, then we look at that. I would second Ben's argument, it's not just .... we need to be better than JS on speed, complexity of support. The more complex the less likely it happens.

JS: at some point we start talking about tradeoffs, it becomes a call where we want to cut that space

FM: It's not just mono-dimensional.

JS: at some point we say A and B are both important, then we have to make a call. A is better than B at some stuff, B is better than A at others.

FM: It's the object of that phrase that's interesting here. We should focus on … if you want to establish requirements then pick the popular languages for that support.

RT: a little confused by the comment, so far all the languages discussed are statically typed languages

JS: what do you mean by static type, like ML style, or C++ style,

RT: or Go, or C#

BT: Simple example is Java's object model. Unboxed primitive fields in objects.

RT: works well for compiling Java, but JVM’s object model is known to not work well for compiling a variety of other systems. Other languages are not compiling well to JVM object model, and better suited by this object model.

BS: take a step back, can drill quite deep into technical details. We are sort of disagreeing whether this is fast enough, the only way to resolve is via some experimentation. Not sure who will do this. Even though this is fleshed out, there are some missing pieces of this proposal, and also who will take on that work. Not sure if CG can mandate who can look at that, though there is some interest

JS: if spec work is needed, i can do that, flesh it out for experimental purposes. Turn it into something someone can make two implementations that are compatible. Make sure it doesn’t have overlapping opcode space with Andreas’ proposal. If that’s what people think will be necessary for experiment, I can do that. I can’t write an embedder or compiler.

BS: the other aspect of this, mentioned a couple of times, we should have requirements here. Some of these won’t be satisfied by looking at designs, but there are some reqs which we can look at the design and see that it will not satisfy it. Francis started some of that, maybe your list (BT), how well we want to support statically typed languages. We need both, experimentation and list of requirements.

RT: another useful thing… something that makes things hard to make comparison, we have no plans for how to compile languages to systems. There’s OCaml thread showing how to compile to two systems. Walkthroughs to show how to compile languages down with many interacting features.

JS: We got one recently, right?

RT: Yes, it would be good to write that up, and look it at it from this perspective too. Without running them we can see how to improve, which things do we need experiments to evaluate.

FM: would like to add a small word of caution about experiments. The cost of running an experiment is more than implementing a given proposal. Embedding it in V8, you have to address the issue of compatibility with JS. The overhead of doing an experiment in a system like V8 or SM is much higher than just implementing the particular feature.

JS: I appreciate that an experiment is not cheap. But I'd like to experiment with one other proposal.

FM: what is an experiment look like? A walkthrough is good because it is human-level, you can understand it, the risk is you don’t know if it is complete or not. E.g. for Java, you meet all of Java’s needs

BS: experiments need to answer a question, you have to start with a question. What parts of these do we believe we don’t understand yet. If we just implement the prototype, we currently have that for MVP, for new experiments we should be more directed.

JS: thing I’ve heard the most is: can it perform. Concerns about dynamic checking, although the possibility that it might be offset by the simplicity of those checks, it is not clear. I want this out of experiment: can it be made to perform. KM, when you said, needs to be better than JS, assume you mean, it can be made better than JS.

KM: I mean it, I won’t ship it unless it is already better than JS. I want a real compiler, not some toy compiler. I don’t know if… I haven’t seen anything across all languages, can necessarily perform better than compiling to JS.

JS: The reason I ask… if we do these experiments and it doesn't perform better than JS, but if we put the work in. We are not going to put into the experiment, but … do you want the experiment to show that.

KM: it’s all performance things. My experience dealing with optimization, you can have guesses, but until you actually do it, reality can be wildly off. I have experience with expecting 10% better, but doesn’t really make any difference. A lot of subtleties.

BT: point out again, taking a narrow view of performance, sounds like runtime overhead matters, space overhead also matters, easier to measure and demonstrate if it is better or not.

JS: memory or code size

BT: memory

KM: will say code size matters too

JS: looking for feedback on all 3 dimensions

RT: unrelated to specific proposals… if it turns out that performance is… if all the proposals perform worse than JS, because all of them have to have dynamic casting (or other reasons), would the assessment be that we should not ship a GC.

AK: definitely make me reassess what the goals of Wasm GC

KM: without GC, linear memory one is sort of a new language one you have the GC in, happens to line in nicely with non-gc instruction set

JS: it will be hard for us not to make code size improvement, can be worse on memory and cpu perf

KM: i can believe code size is better, JS has the upside of high information density, downside is that engine has a ton of memory overhead for JIT profiling etc, have to factor that in too

AR: static code size and dynamic code size in JIT

KM: they grow proportionally, based on experiments, each JIT tier you add, the correlated in memory use and runtime perf, you want better throughput, you have more memory overhead

BS: 5 mins left, I’m hearing a few things, we have a few hard requirements from multiple members, this needs to be better than JS, the experiment doesn’t necessarily have to be better, but we need to convince ourselves it can be better. THat’s going to be the part we need to do some measurements, we won’t be sure about code size, memory use, runtime performance. This is a good place to start. We need more experimentation here, some amount we can do with current MVP, but also need more

KM: do we also have a list of language implementations? We have browser support, at least V8 implemented the proposals. Do we have other languages that will be willing to do this?

RT: kotlin, ocaml, go, erlang

KM: Anyone from the Java compiler side? High profile language will be valuable

RT: I talked with someone from Java compiler… they had mild interest.

KM: just curious..

RT: kotlin is pretty close, that one will gauge Java

AR: I talked to some JS folks, they have JVM so they don't want to support another VM.

JS: I’m with android, some interest w.r.t. Java models, it is possible that I can drum up some interest from the Android side. So far, interested in deeper host embeddings, use native apis from Wasm, without which it's a non-starter. One reason why we are pushing some kind of GC in. The ability to have things that cross boundaries is important to Android use case.

KM: This is part of our problem, that's why I like the two-types proposal, because we can start to implement something.

JS: It is months of work for somebody, non-trivial investment

RT: volatility, how to get people to invest in something uncertain. If they compile to this, pretty much any other MVP gets accepted, easy to transition to it.

BS: out of time, next steps to do some outreach, find people willing to help out. Also start thinking about requirements, fleshing out this proposal.

JS: I’ll start working on some spec work, making it implementable.

### Closure
"
main/2019/CG-04-16.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 16 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: April 16, 4pm-5pm UTC (April 16, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email Ben Smith to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. POLL: WASI subgroup chair
    1. POLL: WASI subgroup charter
        - [proposal here](https://github.com/CraneStation/wasmtime/blob/master/docs/WASI-proposed-CG-subgroup-charter.md)
        derived from the Debugging Subgroup's charter
    1. [WASI] Can we land WASI libc in WebAssembly/reference-sysroot?
        - https://github.com/WebAssembly/reference-sysroot/pull/11
    1. Presentation: K language and wasm    
    1. Discuss [Community Group chat](https://github.com/WebAssembly/meetings/issues/236) and [increasing inclusiveness at the community group meetings](https://github.com/WebAssembly/meetings/issues/304).
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Adam Klein
* Alex Crichton
* Alon Zakai
* Andreas Rossberg
* Arun Purushan
* Ben Smith
* Ben Titzer
* Conrad Watt
* Dan Gohman
* Daniel Ehrenberg
* Derek Schuff
* Everett Hildenbrandt
* Flaki
* Francis McCabe
* Jay Phelps
* Luke Imhoff
* Luke Wagner
* Maher Jendoubi
* Mark Miller
* Pat Hickey
* Paul Dworzanksi
* Peter Jensen
* Richard Winterton
* Sam Clegg
* Sergey Rubanov
* Sven Sauleau
* TatWai Chong
* Thomas Lively
* Till Schneidereit
* Ulrik Sorber
* Venkat

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Jay seconds

### Proposals and discussions

#### Review of action items from prior meeting.

BS: So let’s start off with the WASI subgroup chair. I’ll take about this briefly. So when we did the subgroup in the past we just sort of nominated a chair -- not really, but I mean, people who proposed the subgroup became the chairs. I think that’s reasonable to do here, too. But I did want to bring it in front of the community group to have it official and down in writing. Obviously Dan Gohman has been spending pretty much all the time working on this. So I think it’s reasonable for him to be the subgroup chair of the WASI subgroup. But I’d like to put that to a poll in the group. Is everyone OK with that? Any questions about it?

<silence>

BS: OK, let’s go to the poll.

#### POLL: WASI subgroup chair

Dan Gohman as WASI subgroup chair?

| SF | F | N | A | SA |
| - | - | - | - | - |
| 21 | 2 | 0 | 0 | 0 |

DG: How about a chair as a backup, is that worth doing now?

BS: If we want to have an additional chair, we can do that now. But we can also do it later. Does anyone want to be co-chair?

SBC: I’m happy to step up to co-chair if we think that’s necessary.

Sam Clegg as subgroup co-chair?

Flaki: Should we reach out to group about this?

BS: People on this group will probably be the ones who’d be interested in doing this.

TS: I don’t think waiting two weeks here would make a difference, we could just go ahead.

Flaki: no objections

#### POLL: WASI subgroup charter

BS: Any concerns over the subgroup charter?

- [proposal here](https://github.com/CraneStation/wasmtime/blob/master/docs/WASI-proposed-CG-subgroup-charter.md)

derived from the Debugging Subgroup's charter

TS: There’s nothing controversial in it, it’s the same boilerplate that we used for previous subgroups.

BS: Unanimous consent

#### [WASI] Can we land WASI libc in WebAssembly/reference-sysroot?

- https://github.com/WebAssembly/reference-sysroot/pull/11

BS: There’s a PR that’s in the reference sysroot that Dan has been keeping up to date with the WASI original source that was in CraneStation and we wanted to make sure that we could land this, but we wanted to bring it to the CG first.

DG: It’s a libc implementation, based on code from cloudlibc, libpreopen and musl. If there are technical concerns I think we can address those after we land. There’s nothing that’s going to be fixed in stone here. I think the biggest question raised so far is the license. Musl is an MIT license and at the moment there’s no other MIT license code in the webassembly org. Is this OK? I don’t know why it wouldn’t be, but I’m interested if anyone has ideas why it would.

BS: Yeah, curious if anyone knows more about the specifics of how we were doing licensing in the past, I wasn’t really involved in those conversations. Our current license is Apache 2.

JP: There were discussions about Apache vs MIT before in the past. The difference being the explicit patent grant versus the ambiguous… MIT doesn’t explicitly call it out. This came up with Binaryen.

BS: Yes, I remember that too. I’m not sure how that works with changes going forward. The code we copied would be MIT, but how would new could work?

JP: Could we get legal guidance from W3C?

BS: I Could talk to Eric about this. I don’t want to hold up the PR though.

DS: One other issue could be the Patent Grant that need to be signed. If we say “no contributions until you are in the CG”, and that should have us covered.

TS: Another question is whether all of musl should be considered part of our implementation, we might want to ask our lawyer/W3C.

BS: I can follow up with Eric, although I would prefer not to stall this further. I think DS’s suggestion is a reasonable/good faith one.

JP: As a counterpoint, just contributing does not mean one is allowed to grant a patent. That said this may not be an issue here.

BS: ..

SBC: This could become a natural artifact of the spec.

DG: This is more a layer on top of the specification, maintained by the CG.

BS: In a way it could end up being similar to the tools that we already provide -- not part of the specification, but a convenience for working with the spec product. Sounds like we have enough concerns that we should seek guidance from lawyers first, instead of just landing.

SBC: We already have other licenses in the repo, so it wouldn’t hurt to get legal guidance overall.

AI[BS]: talk to eric about licenses

JP: Could we still vote, pending no concerns are raised by legal?

BS: Sure

SBC: I would have some small concerns, but nothing major, I could just comment on the PR.

BS: More looking for general problems, overall direction of the PR.

SBC: Should we find an alternative for musl, since it’s so linux-specific?

DG: In this case we should just discuss offline

SBC: I’m happy to see this land, actually, if legal is fine.

BS: We could just come back in two weeks, and see if any concerns emerge.


#### Presentation: K language and wasm    

BS: [technical issues on the connection side]

#### Discuss [Community Group chat](https://github.com/WebAssembly/meetings/issues/236) and [increasing inclusiveness at the community group meetings](https://github.com/WebAssembly/meetings/issues/304).

SR: I have found that our IRC channels are not very popular due to barriers of entry in accessing them. As far as I know Spectrum.chat (owned by GitHub) and also Gitter meet these requirements, and Discord (used by many communities including React, Rust/rustwasm) might be a popular choice.

SR: I helped with run Russian-speaking web assembly community group chat and it’s on telegram. It’s the most popular in Russia, not in the world, so maybe not a good choice. It’s the biggest chat I found, 300 people. We even have english speaking people there. And some core contributors from AssemblyScript, with experience in emscripten and rust. Building a community and helping each other, and were starting a meetup soon in Moscow. I think it would be great to have an official chat, and maybe even a repository or website where people can share links to local meetups. AFAIK there are a number of meetups already, SF, London, Munich, Moscow. Maybe we should have another place where people can find this.

SR: I also found this link on a website, which is kind of outdated, maybe we should also do something with this. I think that web chat can help us to realize what our next steps should be to increase inclusiveness. In our Russian-speaking chat, we collected FAQs, and made a list of links explaining how wasm works. What do people think about this? I think the hardest question is what to use here -- I think slack is not great because it doesn’t have history or logs as far as I know. It’s also hard to sign up. Maybe something people have good experience with Discord or Gitter.

TS: We might want to consider Discord. It has a pretty large community behind it, it is possible to have stable invite links to channels). I could prepare a bit more information on this if people would be interested (by talking to some Rust people) for next time.

SR: Reached out to Ashley Williams, but haven’t received a response yet.

BS: Perhaps we should find a champion for this (maybe SR or TS?). We should also figure out what to do with webassembly.org. Does that sound good to everyone?

JP: [Requested that official CG discussions and community support be clearly separated by channels], I’ve had issues with noise in the past -- too much confusion about implementing and using wasm.

JP: I used gitter before with OSS projects, but exposure to search engines is not great. It does have an archive, but if people are searching for things it is hard to find them. Not sure if others have better experience.

Flaki: We have been experimenting with Spectrum, it has a nice properties, doesn’t replace an actual chat client. Has some problems, not the most stable but is promising.

TS: Happy to make a case for Discord for next meeting -- the rust community has had good experience with this, multiple channels, logs, the features we need. I don’t think we should make a choice right now.

BS: Makes sense. We can put this conversation on hold until next time, and have the conversation after the presentation.

---

BS: You’re on the call now?

EH: Yes, finally was able to join. Also Dwight (?) another engineer at runtime verification, Rikard (?) university of Chalmers.

EH: Would like to give a tour through the KWasm semantics. Does that sound good?

EH: First I’ll start with this presentation I gave at Edcon.

EH: Rikard has been helping me a lot with KWasm, he can chime in on technical details. We’ll go through this quickly.

EH: Idea with K is to write down your formal semantics once, and syntax and semantics and all tools derive from single golden truth.

MM: [issues w/ screen sharing]

EH: We have the semantics of several large languages, JavaScript, Python, EVM LLVM. C++ is WIP, Solidity is WIP. All these tools except test case generation and compiler is derived from the semantics. Compiler is in the prototyping phase, test case generation -- we have a road map for it, general plan for it but we haven’t implemented yet. Focus of this talk was the deductive program verifier, because that’s what people were interested in, so that’s highlighted here.

EH: To specify program in K, you have to give syntax of language, and configuration (which is like state monad), and rules which describe small-step operational semantics of language.

EH: People are mostly interested in the [Wasm semantics](https://github.com/kframework/wasm-semantics) probably. The way the semantics are broken down there are two files -- operational semantics, we assume validation has already happened. If that hasn’t happened, then the semantics will get stuck. Two files `data.md`/`wasm.md` are the two files interesting. Data defines algebraic data structures, used in wasm.md to define the semantics.

EH: `data.md` define our basic types, i32 and i64. This in quotes means that this token literal is an inhabitant of this sort ival type, and that generates a parser for us. Here we can subsort all the ival types and fval types into a sortval type.

EH: Here’s some examples of declaring type constructors. List of valtype is valtypes, and the list is separated with empty syntax. Valtypes with square braces around it is a vec type. A vectype with arrow between it is a func type.

EH: Here’s an example of a recursively defined function. It uses a function annotation, says we can take two valtypes and append them to make a new valtype. It will look a lot like a conslist append operator in a function programming language. <describes operation>

EH: More helpers functions. Now we get to values, number is an int or float. Semantics we do dynamic typing, we store the width with each number. This is a data constructor, so if we have left angle bracket, ival type, and right angle bracket and int that makes an ival. That will be used in semantics later. Then we subsort everything into a supersort val to complete our subsort hierarchy. We add a special value called undefined.

EH: The chop function is our workhorse, it makes sure things are within their correct range. If we chop a typed value N, and it’s in this itype here, we take the mod of the pow of the valtype here, so we get 2**32 for i32, and 2**64 for i64.

EH: Here we tell it, don’t simplify this chop function if any of its arguments are symbolic, so this is useful if we want to axiomize chop instead of simplifying it. More helpers for signed/unsigned numbers. Some things that lift the kbool sort into integers, for storing on the stack. Some stack operations, we define stack as a conslist of stack items, and stack items are values. Some other stack operations. Local memory is a map, we can do bulk updates of the map. We have to split the integer your storing into a set of bytes.

EH: This was just to warm up with K a bit, most of this data semantics are pretty similar to Wasm. Moving on to K’s WebAssembly semantics, here we have been trying to get the records from the Wasm spec and just translate them into K. Some cases we had to deviate a little bit.

EH: K cell -- that is a syntax declaration. This is our instruction stack on the K cell, we have a separate stack for values. We deviate from wasm spec here. He have the current frame, we have a bunch of addresses, as well as local variables, and portion of module instance we support (globals, mem addresses). Basically, you have to say the function definition has a function name, a chunk of code (by default empty list), some type (domain and range, so this is a functype), some locals (vectype), and addresses that that function can see in scope. We try to do it literately, so the code you’re seeing here in markdown is the source code.

EH: When we get a list of instructions, we have to sequence it out with followed-by operator. This lets us pattern match directly on `i` in later rules, and omit everything else with the `…`. Let’s look at an actual opcode. We declare the syntax of folded and unfolded form, of the opcodes. Here is the unfolded form… <describes> if you have that form on the front of the kcell, then we sequence it out, evaluate first, then evaluate second and deal with unfolded form. For unfolded form, we check first if the itype is the same as the first two, if it is then we apply the itype binop to the two integer arguments. Almost like refolding it back up. That let’s us define the semantics of each opcode separately. Similar to the spec, we have binary arithmetic operators. We use the chop function to make sure values stay within bounds. Most of the opcodes are straightforward. Let’s try to get to something more interesting. Stack manipulation operators -- like select, has folded and unfolded form. Checks for i32, then numbers (which are vals), checks to see if they have the same type.

EH: Going to scroll more quickly through, to show you what we’ve implemented. Labels, blocks, breaks, conditional breaks, if-then-else, loops, Rikard recently implemented memory. We have function declarations as well.

EH: Normally in wasm you have to declare an entire wasm module, but we are more lenient. We don’t require there to be a module in scope. For modules, we take a list of instructions and execute them. Later when we finish module semantics, we close the module which loads the current state of the VM, which moves it into a module that you have to point to.

EH: We don’t currently have any floating point, since our target is K eWASM, for eWASM happening with ethereum, still need module semantics and table semantics. I can take some questions now, or show a proof.

CW: The K framework allows you to generate verification tools from a semantic definition. Do you have any ability to verify language level properties of the specification itself. How does this relate to existing mechanisation.

EH: There are some tools that let you do that, but won’t compare to what you can do in isabel. The reachability logic prover for instance, the strength is that it is fast, you don’t have to manually specify how to find the proof. We’re only working in reachability logic, we can model check to find proofs that some reachability property holds. It’s been adequate for us for functional correctness verification. We’re able to scale up to large programs using our evm semantics.

??: Because we can use generate an interpreter from the semantics, we use the tests associated with the semantics to at least test that they behave correctly when executed on various concrete inputs. This is one way we guarantee we have correct semantics, it’s not a formal reasoning about the properties.

CW: Thanks, that’s helpful.

AR: Can you share how you model branches? It recall it was difficult for isabel [CW: main difficulty was for the type soundness proof, which is not expressible in this mechanization]. I would be curious to see how this turns out in K.

EH: In the K specification I think it turns out quite nice.

[some technical issues]

EH: This is the meat of how this context operator is implemented. What makes it nice, is that we separate out the instruction stack from the value stack. First we have labels, in the wasm spec the labels are annotated with how many values -- the return amount. The list of instructions, we also store the current stack at the time the label is created. Instead of the number, we store the vector of types. It probably isn’t necessary if we run it through the validator.

EH: If we hit a label, we replace the current stack with the stack that the label is storing, but we take the types off the top of the current stack. This take operation is like the take operation in haskell, but this takes the first types that match from the stack.

AR: This is when you exit the label?

EH: Yeah, when a label comes to the front of the kcell, then we are exiting into the continuation. A block of some type, we will end up executing the block, but then create a label with the empty continuation, but the current stack is stored off in that label, then the stack is zeroed out for the execution of the block. This is the block balancing stuff.

AR: Why did you have to do the take there? Validation ensures that you need to take the entire stack.

EH: True, I wanted to typecheck as much as possible. This is an inefficiency. This is a take that typechecks as it goes.

BS: [break to mention that we are at time]

[presentation continues]

### Closure
"
gc/2023/GC-07-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 11 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: July 11, 4pm-5pm UTC (July 11, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Status checks
        1. Spec tests ([#396](https://github.com/WebAssembly/gc/issues/396)) and ([function-references/#100](https://github.com/WebAssembly/function-references/issues/100))
        1. Final types in Binaryen
    1. Discussion: Text format for final types ([#333](https://github.com/WebAssembly/gc/issues/333))
    1. Discussion: final opcodes ([#372](https://github.com/WebAssembly/gc/pull/372))
    1. Discussion: extending type difference to heap types ([#381](https://github.com/WebAssembly/gc/issues/381))
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Conrad Watt
- Bruce He
- Adam Klein
- Alon Zakai
- Ilya Rezvov
- Ashley Nelson
- Nick Fitzgerald
- Ryan Hunt
- Manos Koukoutos
- Ben Titzer
- Andreas Rossberg
- Francis McCabe
- Jakob Kummerow
- Matthias Liedtke

### Status

TL: In Binaryen I implemented final types. The way they are parsed is not quite spec compliant to avoid a breaking change for our users. Behind a flag is the spec compliant version. Communicated with our users and they are working on updating the text in binary they emit so we can just flip the default and be totally compliant. Jakob looked at the JS spec tests and type function references and found a bunch of issues. Andreas I saw that you have seen those issues and you’re planning to look into that

AR: Definitely, basically untested code 

TL: Great, thanks. Any other status?

AR: Spec work, updating the properties section so it has the soundness statement and some auxiliary rules for stating that. Other than that, I think everything is out there, except for missing pieces for bulk arrays. One item has no owner, extended name section. Am I the right person? I don’t know, haven’t looked at the spec. We should probably nail that down.

TL: The missing pieces I’m aware of for the bulk array operations is just validation, am I right?

AR: It’s validation and prose for execution.

TL: I’m working on validation and I’ll work on prose for execution as well. And I can also look into the name section part. 

AR: Thanks. I think then we’ll be covered, and I’ll just have to go over the remaining speculative hint issues.

TL: Spec notes, right. On the review front, CW I saw you did an initial review of the validation PR?

CW: I think with Andreas’ changes, that is pretty much done. I’ll look at that after this meeting. I’ll have the subtyping spec done by the end of this week.

TL: Sounds like we’re in a great place with the spec then. Also, AR put up the GH pages link so you can view the rendered spec linked from the readme on the GC repo. As we finish up landing new parts of the spec, the more eyes we get on it to catch typos and things, the better. 

RH: No real update on spidermonkey. Still . Working on generalizing?? , i31 patches are still in progress.

TL: Final types implemented as well?

RH: Yes

AK: Little update from W3C side. The W3C tag has closed the review for wasmGC, effectively approving it, no issues or worries with this. Thanks AR for chiming in on that 

RH: Would someone share the link to that?

AK: <linked in chat>: https://github.com/w3ctag/design-reviews/issues/814

NF: <comments from chat>
no big update on the wasmtime side. our contributor is still finishing up validation. I'm not working on gc stuff myself until I finish tail calls, which is close.

### Discussion: Text format for final types ([#333](https://github.com/WebAssembly/gc/issues/333))

TL: RH you are concerned about the text format here being slightly counterintuitive and confusing. Particular the MVP shorthand means final and then make it non-final you have to add sub. And it looks like that should be a no-op expansion of the syntax but actually ends up changing the meaning. Part of the Binaryen work, I’ve been spending time updating tests to add that sub, to make things non-final and it seems okay to me. Definitely counterintuitive at first thought, but having added it to a bunch of tests, I think AR’s suggested interpretation that sub annotation means you can interpret it as particppating in subtype relationships holds up in practice. What is your latest thinking on that? Did you still want to pursue alternatives?

RH: This is just the text format, so it doesn’t matter too much, since there are a lot of counterintuitive things. The reason is that we interpret things as final by default, but I think it’s fine. If people don’t like the syntax of inverting it, we can leave it as it is.

TL: Any other opinions?

AR: Its slightly more ergonomic, because you have to put in more sub. 2 keywords sub, sub final, the latter is written with a space. I mean it’s what you’re used to in other languages. You put final as an explicit marker. I think it’s more confusing the other way around, even with the shorthand.

TL: Close out this issue then and keep it the way it is

### Discussion: final opcodes ([#372](https://github.com/WebAssembly/gc/pull/372))

TL: Last time we didn’t have enough people to make a decision, but we checked the temperature. I posted a straw poll on the github issue. We have 6 votes in favor of not having holes, I voted for not carrying it forward, and AR voted for having holes.

AR: Don’t care too much, it's the binary format. But I think we are jumping back and forth, compared to what we used to do. I saw recently that someone mentioned pairs of expressions should somehow be aligned somehow, which means minor holes I think. GC Repo # 372

TL: Quick temp check, what do folks think of tiny holes to make groupings of instructions aligned?

RH: <in chat> No preference on any of this.

CW: We might have more instructions than could fit in holes, but we want to align groups of instructions.

TL: At that point, you’d have tiny holes and leave groupings of instructions for later.

BT: To have a null and non null variant, we want to have them 1 bit apart (as per Aske). Are there things beside that?

AR: Good Q. I guess something like br_on_cast and br_on_cast_fail. Probably also want to apply the same thing to the signed getters. I could see a bunch of instructions as a pair of variations of the same thing. Not sure what the exact rule should be.

TL: I think it’s more important they are next to each other rather than aligned. I can make a new hole-less opcode set as a next step.

AR: One thing I want to add is that I’m not sure I think we’re only discussing the instruction opcodes because those are the type op codes, because those already have various holes and we don’t want to move this around. 

TR: Are you referring to the part where some are negative coming down from the top?

AR: They always are but we are already extending certain groups that already exist. So func is an opcode that is already starting an opcode and we are adding some there.

TL: I’ll follow the existing pattern for the type.

AR: Why don’t you take the existing PR and change it.

TL: Yes, I’ll do that. I think we’ll have a consensus after we do that.

### Discussion: extending type difference to heap types ([#381](https://github.com/WebAssembly/gc/issues/381))

TL: Basically if you do a br_on_cast where you can statically prove that one branch is always going to be taken, then the other branch would end up, if extending type differences to heap types, then the other branches would end up with non-nullable references to type. which encodes that it is impossible to take. Or if the only way you could take that branch was on a null then it would have a nullable reference to none. So it would basically, as we iterated on these br_on_cast instructions, we’ve been trying to make the types as ??? as possible. Arguably an unnecessary step because Binaryen transformations could stop using br_on_cast and use different branching casts on these instructions, but I do think it would be good for a couple of reasons to make br_on_cast instructions as precise as possible as long as there is no computational complexity considerations. So if we had union types and it was O(n) to take the difference, that would be a problem, but we’re certainly not in that case in the MVP.

AR: I think it’s fine. It’s a bit more complicated, you have more case distinctions every time you do a branch. It’s a minor annoyance. It’s only used for completely useless casts, so I’m not sure there is a practical reason. It’s only  interesting if there are more interesting cases to make more precise.

TL: Cool, agree that it is only useful for useless casts. The thing is, from an eng perspective, useless casts pop up quite frequently in between Binaryen optimization passes. Being able to represent them more precisely and propagate them more directly in the IR types and pass to pass in Binaryen would be a big simplification. If you’re okay AR, I can make a PR for that change as well.

AR: Sure. On a meta level, I’m more skeptical of the language's changes just because Binaryen’s IR needs it. It’s a dangerous argument to make.

TL: Binaryen’s IR with few exceptions does try to be as close to wasm as possible, I suspect it’s not alone in that. Many tools for manipulating Wasm have some IR and are going to want it to be as close as possible. I use Binaryen as a motivating example here, but I do think the general principle makes Wasm more useful and would extend to more tools as well.

AR: One thing after the previous discussion that I realized is that it’s kind of a bit backwards. Opcodes exist for operational behavior, and we need to type them themselves. We are slowly turning casts into a monolithic thing which takes on more cases and subsumes I don’t know how many operators. This is an odd view of what the instruction is. We’re making casts into a general type annotation instead of having different operations for different things. What you’re using in the IR is much more general than it used to be. Maybe it’s ok now, but it could get a lot more complicated

TL: Understood, goes back to our discussion when we first combined the different cast operators and combined them into a single operator and that was based on feedback from Binaryen and also from engines because by seeing the entire cast in a single instruction, yes it’s more complex, but the code they generate is better and if they are separately generating code for operational parts of the casts. I still think it’s worth it. But I understand the concern as well. I have a lot of AIs but that is great. That is the end of our agenda. Anything else folks want to talk about?

CW: Are we going forward with the additional relaxation of type cast operators?

TL: With the proposed extension of type differences to heap types? 

CW: Yes.

TL: I think so. I’ll make a PR and I’m happy for folks to look at the details for what that actually means. If there are concerns, I’m happy to discuss them then. I’ll definitely pause and see if there are any concerns once we have the details up.

AR: One issue is multi-byte access. Clearly a post MVP feature, but I don’t know.

TL: I have been thinking we can address that problem space post-MVP, maybe very quickly post-MVP since it’s certainly a useful thing.

AR: In general it makes sense. I remember that I posted on the issue that we had the discussion on having reinterpret casts on references as a more general feature to have different views on arrays and also structs as long as there are fragments that map to transparent binary things. There is a certain overlap here, and I wonder if we should have both or only one.

TL: Personally I haven’t thought about it deep enough so I don’t have a formed opinion but that’s a good question.

BT: I don’t think we should have reinterpret casts on arrays because it will expose the machine endian-ness.

AR: That would be true with any of these operators, right?

BT: The proposal that was discussed was that the load and store instructions can be somehow overloaded. You can have load and store instructions on arrays, and these are little endian semantics.

CW: The Q of whether we think of them as the same instruction or mirror instructions of every load and store is mostly a binary format question, right?

BT: If you can do reinterpret casts, then you can do it on an array of i32, and you can see the byte order. That would force us to have a defined order on multi-byte arrays or multivalues, or force us to do something more expensive.

AR: Don’t we already commit to little endian in memory?

BT: Yes but we don’t have to commit to a byte order for in-heap arrays.

AR: Okay, interesting point. Food for thought. Not convinced that is worth considering but yes.

TL: A lot to think about here. Once we have time to think about it, I’ll be interested in engine implementer opinions.

CW: I don’t think this idea is fleshed out but my impression of that conversation in that issue was someone brought up a not fleshed out version of that idea of that array buffer could become i8 arrays

RH: Right now array buffers in SpiderMonkey have a very different representation than i8 arrays so anything is possible but that might be difficult from thinking about it quickly.

JK: There is lots of demand for that. I see it’s a desirable use case to do something there. I don’t know what we should do, but I’m leaning toward access to javascript style arrays. Maybe it should live under JS API just like imported strings. I’ve heard demand for this, and it’s worth tackling, but it’s also a big design space to think about.

AR: JS array buffers are not super simple and it might cause issues if we try to overload these notions with one specific type of arrays. I don’t know if we can make that coherent. I would agree with Jakob that it is probably something that belongs on the idea level.

CW: Orthogonal thought, even at the API level, the JS side gives me an array buffer, I can give the wasm side an i8 array. It could be a spec that only lives at the JS spec side.

AR: You can’t just easily convert it, so you’re basically having the same issue.

BT: Fundamentally, do we try to make foreign things show up as wasm arrays or make foreign things show up as a memory segment. If we try to make foreign things show up as a wasm array type, it has an implication for how you represent wasm arrays. I would like to optimize wasm arrays for the most efficient wasm implementation, so there are no indirections to some memory elsewhere. If we are thinking about bringing foreign things into wasm high performance, my preference is to make them appear as memory because they are inherently more powerful with the load & store instructions.

CW: Andreas was floating having a view of memory as an i8 array.

BT: Could be a strategy but it means i8 arrays have to be an indirection.

AR: Actually I wasn’t suggesting that, I was going in the direction of this should be something like in the space of strings, you have these instructions you can import somehow. It’s a bit more annoying with the zoo of load and store instructions, but I can imagine the particular program needs some of them, not the entire module so in terms of imports, not so bad. But I agree with BT that trying to unify them has a lot of implications. Arrays are a more general concept and having this special case for array i8 is probably more annoying. 

RH: I can see if you go in this direction, it will slow down i8. You’ll have indirection, and casting will get more complicated. It is great if array buffers are the common case, and everything else will be penalized. I think we should find another way to do it.

JK: Agree that array buffers are so complex under the hood and heavyweight and different from the wasmGC arrays we’ve had so far that from an implementation perspective, it would be unfortunate to unify. Interesting wrinkle from Dart is that they have abstractions on the Dart language level of the buffer style things that can refer to many things under the hood, which would require indirections or virtualization. When I pointed this out to them, they would happily take the overhead because they need it to model their language design. Maybe there is room for a relatively heavyweight tool available there that would like that tradeoff. 

TL: If there needs to be an indirection/virtualization. There is a case for putting it in userspace where Binaryen can get to it and devirtualize things. If it’s in the engine, we can’t devirtualize it, except locally since engines aren’t doing full program optimizations.

BT: FWIW, Virgil has a notion of off heap arrays. Virgil doesn’t target wasmGC yet but there everything is an index into the memory. i31 if you are memory segment. Otherwise a wasmGC array on the heap. 

TL: Clearly this design space deserves further thought, so let’s keep it going on the github issue. Targeting post MVP feature. We’re so close to finishing the MVP spec, we don’t want to throw this kind of uncertainty to it.

AK: PM point of view, as we get close to Phase 4, do we have a post-MVP label we can apply?

AR: We have it, I added to that very issue.

RH: Quick agenda item. On the final opcode renumbering, has there been any plans in v8 to implement on a certain day. What are the logistics? Want to sync up here.

JK: We currently have the origin trial running in chrome until the end of october. 118 is the last one. It should be on chromestatus.com. Want to land the changes in the second half of September, Chrome 119 feature freeze is September 19, branch point October 3, Ships to stable November 7th. ??? [couldn’t keep up with the rest]

RH: Just so I understand, what is the day it would hit stable. Was that October?

JK: I believe we hit stable in new encoding in early November.

RH: And that would be stable as in fully released in this scenario?

JK: Assuming we finalize phase 4 vote before that. I don’t think we have any action items on chrome other than waiting for phase 4 and finalizing binary encoding.

TL: Chrome 119 goes to full stable release on November 7th.

RH: Makes sense. I’ll have to look at our release schedule. I’m sure it’ll be fairly close.

TL: Thanks for a very productive meeting. See you in two weeks if there’s anything to discuss.
"
gc/2023/GC-10-03.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 3 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: October 3, 4pm-5pm UTC (October 3, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Resolve text format final/open/??? issue ([#423](https://github.com/WebAssembly/gc/pull/423))
    2. Renaming extern conversions ([#432](https://github.com/WebAssembly/gc/issues/432))
    3. Discussion of follow-on GC proposals
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Zalim Bashorov
- Alon Zakai
- Ben Titzer
- Nick Fitzgerald
- Manos Koukoutos
- Ilya Rezvov
- Adam Klein
- Ashley Nelson
- Sergey Rubanov

### Resolve text format final/open/??? issue

TL: We have a slot at the in-person for new GC proposals, but it would be helpful to discuss here first. RH & AR aren’t here, so we may not be able to resolve the text format issue. Let’s just review the state. The latest discussion on the final open close text format, is that RH discussed it with Mozilla folks and they don’t think AR’s last proposal fixes things, but they don’t want to continue discussing it either. So maybe we’ll go with AR’s thing. Close that discussion when AR is around.

AK: Maybe it’s something we can resolve in-person in 10 minutes with the right parties. Not a fan of adding extra to the text format.

TL: Do you know if RH is going to be in-person?

AK: He is.

TL: Great, let’s plan to grab RH & AR and hash this out in-person

### Renaming extern conversions

TL: I think this is a good idea. We don’t have an immediate use case but I think making more future proof makes sense, just a text format change. Any other opinions/objections, anything to say?

TL: If no opinions, we can accept this change and close this asap so everyone can go implement.

### Discussion of follow-on GC proposals

TL: First, I have a combination follow-on proposal for GC and EH, even though EH isn’t done yet. It’s a proposal to add throw invariants of trapping instructions. So struct.get and the reference is null, that would trap. For Java, that would result in a null pointer exception instead. Could add explicit guards around all of your struct.gets to check for null but that has a huge amount of code size and perf overhead. We’d like to fix that. I have an explainer for the follow-on proposal almost ready to go. Just need some hard data about the code size before publishing.

TL: The other proposal is shared wasmGC, so multithreaded. We have a basic design for this ready to go because it was published in an appendix of a paper on the linear wasm model that AR and CW and a few others wrote back in 2018. So we have a really great starting point but there are a lot of details to figure out about what kind of atomicity we’re going to provide for references to share in reference type fields. We can’t allow out of thin air behavior for shared reference type fields, that would be bad from a security perspective. How do you properly compile OCaml to WasmGC? Lots of work to do there to figure out those details. Slightly esoteric memory model work. What we are going to impl, what are people going to use? How do we spec it and make it safe? Hoping to make progress on it the rest of the year, hopefully having something people can play around with early next year.

TL: Any other post-MVP wasmGC proposals?

ZB: Question about traps, is it only about nulls for struct.get or something more widely.

TL: What I have in mind is broader than null checking, we’ll have the initial proposal to be discussed in the community, throwing variants of division and remainder operations, and then all of the struct and array accessors. For array accessors, we’ll have throwing for the null check and the index out of bounds check, so that you can raise different exceptions depending on the reason for the error.

ZB: Great, had the same request for Kotlin.

TL: I think it’ll be useful for a lot of people. Not including throwing variants of every single trap instructions, for example memory loads and stores we won’t have throwing variants of because those are used by low level variants of C and C++ where itw as undefined behavior for OOB memory access. But 

ZB: In my mind, catching any trap except unreachable makes sense

TL: I agree it would be nice and symmetrical, but my worry is we’d have a lot of instructions nobody would use in practice. Array.copy has 4 different reasons it can trap, 2 ararys, and each of them could be null or OOB. So if we add that instruction in the proposal, it would take 4 tag immediates and be expensive/heavyweight. We’ll definitely discuss. Expect it to be a common thing of people asking for all the throwing variants, which is a reasonable ask, but we have to see if its worth it.

ZB: In general, Kotlin worries about size. Trying to work on things that improve size, nothing specific right now.

TL: Good to know.

ZB: It would be nice for array.new_elem and array.new_data to be const instructions. We have to initialize some constants lazily and these lazy things take some space in the binary and it’s not cheap at runtime. Another thing not directly related to GC is there are runtime bool checks to make sure an object is initialized before accessing, and it would be nice to have some way to only check once. Right now we do it with explicit checks so its not fast at runtime. Would be nice to have machine code that after the first access check, optimizes the call.

TL: Some type of monotonic initialization that notices things won’t change and optimizes?

ZB: Yes

TL: Java folks need that too for class initializers. We can look into what we can do there. 

BT (via chat): Another option for throwing versions of trapping instructions could be to have a section that defines trap handlers per trap type; I’m somewhat worried about the explosion of instruction variants. That makes handling traps per-module but factors out all the trap handling logic

TL: That could work BT. Has some downsides but we can wait till we have a full explainer so we can file issues and have a full discussion. There is a wide design space here and the initial thing I plan to propose is certainly not the only way to achieve the goals. 

ZB: One more thing not about GC is we need something to manage new features in the future. We want to generate binary, how we can introduce new features from Wasm to specific toolchain like Kotlin-Wasm, how can we introduce smoothly without breaking things on user side. We need some sort of feature checks, to see which features are available. In some cases we can switch to different functions but at least we need to have the ability to say to users what doesn’t work and why it doesn’t work. We need something more robust than our basic feature checks. When we fix from old GC instructions to final version, we don’t have any way to say at runtime what browser we’re trying to run. We can’t give the user advice that you’re using an old browser, try to update your browser. Or your browser didn’t support it at all.

TL: This request comes up a lot. It would be nice to have something in the spec section. The state of the art is to use tiny wasm modules that uses features with wasm.validate to see if the features are available. Use tiny wasmGC module and run validate on that.

ZB: If a user comes from outside of Chrome and doesn’t support final version on default, old browsers don’t support it at all. We need to suggest turn on and use some old binaries.

TL: I see, you can’t tell the difference of whether it’s an old browser with no support or one where the support isn’t turned on by default. Good feedback and feature detection keeps coming up. We had a proposal for feature detection in Wasm. It probably wouldn’t have worked for this particular use case because they were more about hot functions they wanted to include different versions of in their binary and changing the opcodes changes the entire binaries, so you’d need a more robust API for features like Javascript to detect that. It’s come up before but we haven’t proposed anything. I know AR next week is going to talk about his vision for different Wasm profiles, different feature sets. Not sure. Good problem to think about, thanks for bringing it up.

BT: Working on type imports is going to be important, probably the next most important after GC. 

TL: For ecosystem concerns? Useful to import types or string use case or? What use cases?

BT: Yeah, I think APIs are going to start appearing that are more than just externref and can be implemented with WasmGC and you want to import types from APIs and export types from your module. I think it’s the key to unlocking ecosystem evolution. Something we should work on. From my side, I had given a talk a year ago about combining header information so there is a header for every WasmGC object. And there is a field in it for every meta state. So having a meta field can save a bit of space. Fundamentally comes down to improving the memory usage of WasmGC objects.

TL: IIRC, would allow defining static fields on the meta object that would go on the type rather than on each instance of the class. 

BT: That’s what AR had proposed, I think it needs to be more general than that. One field with the meta object field which is a default that points to a canonical RTT. A field that is mutable but that thing is an object you control the layout of. Not just adding fields to one global meta object per type, but a different meta object per type. Different meta objects are fine with the latter.

TL: That’s just strictly more general and would allow static fields, right?

BT: Right

TL: Could be exciting. Intrigued by being able to replace the meta object. Not sure our toolchain partners have a specific use case for that, but more powerful primitives are nice. We are excited about adding static fields for vtables to reduce the size of meta objects, so something in this space would be great. Are you planning to revive this discussion and make a proposal in this space?

BT: Yes, planning to talk to AR about this next week.

TL: Great.

ZB: import could be helpful in case of module splitting (generating many modules instead of one). Merging modules together is not easy because if you start generating a few modules, you need to do a type check somehow. You need to put types together in a recursion group to use built-in type checks. Otherwise you have to invent your own type checks. In general, we need something to simpify the cases when we generate a few modules together, not one monolithic module, and they will be each run.

TL: Makes sense, a thing in Binaryen we’ve thought about. Optimize the module and put all the types in a giant recursion group to keep it simple. We’ve thought about making a pass that would break the giant group into multiple small groups, as small as possible. Bundle all of your stuff together, optimize your module and run this pass to get the small recursion groups, and then each split up module would have the small recursion groups it needs. Only works if you bundle into one big module at first and then split it back up. Not going to work as well if you are going to create separate modules and keep them separate and you never get that global view of all the types.

ZB: Generating several modules on our side might be important to avoid running other tools during development. We want to develop binaries incrementally. Doing the same thing would require additional work on our side. In development mode, we don’t want to run any external binaries, like Binaryen or any other tool, but in release builds we have to run additional optimizers.

TL: Right now, if you want to generate separate binaries, you can generate your own small recursion groups, but I don’t know how you’d get away without having your own user level type checks to avoid when they get merged. It would be nice if type imports allowed you to get away without those type checks. Or BT’s idea to swap out the meta object allowed you to do that. That’s definitely something we can think of. Not the only one to raise this question. The Java folks have also been thinking about separate compilation. That will be a common use case that is not super well addressed right that. 

AZ (via chat): Another post-MVP feature that could be useful is weak references / finalization. Helpful in particular for combining GC with linear memory (to know when to free in linear memory).

ZB: Right now we use javascript API for weak references, so we need it for caching things. If we had something built-in to Wasm, it would reduce our dependency on JS.

TL: Are you trying to target off-web use cases?

ZB: Not only about a dependency on JS, when we want to cache anything, right now we have to have code in JS and this code is not super cheap. When you do it often. We probably need something out of browser as well. We don’t have a way to do caching.

TL: We could add finalization as a core wasm feature. A lot of people would want, benefit. A slightly simpler way to solve the problem would be to create an importable API from JS for finalization registry so that the calls are super fast, just like we’re doing with strings. That would solve performance and let us get away without having finalization to core Wasm. But for the off-browser use case, producers would need to be sure that the engines provide the API as well. I'm not sure what core Wasm finalization would look like.

ZB: Another direction is, for example we get a parameter and it’s usually anyref and we have to cast it to the method receiver type. Another problem with interface calls is it takes about 7 operations/instructions for a class virtual call about 5 operations. Much slower for us. 

TL: Yes, virtual calls are slow

ZB: Virtual calls today where we can try to improve on our side. Improvements on Binaryen side can halp. VM side.

TL: Certainly we can make devirtualization better in Binaryen a lot better. We’ve put a lot of effort in here because it has such huge performance benefits. We’ll continue improving where we can. For the cast, the receiver cast on virtual method calls, where you have to downcast the receiving object has come up a lot. Two approaches we can take, one is to add a notion of methods into core Wasm, just like Java, so that Wasm would know a downcast is always going to succeed and not have to do anything at runtime. That would be a high level approach. The other is to improve the type system so we can more generally express, using low-level type system, that this downcast will always succeed. I think this is more complex and would require an advanced type system and an area of research, but if we could pull it off, that would be great because low-level primitives are generally more useful.

ZB: Right now we work around it by putting in the start of every function, casting to a local. Insert the local with the right type. 

TL: Yup, that should work. Would be interesting to identify more opps in Binaryen to remove those casts as well. Normally we devirtualize and then you can remove the cast. But maybe we can remove the cast in some places without even fully devirtualizing. Both in the tools and the spec, this is an interesting area to work in.

ZB: Another direction, JS and browser APIs interop. For performance. On JS side, have functions that expect a context object. You can’t import directly such a function because there are no such things in Wasm. Maybe it would be nice to have such imports directly. A lot of work in object model, how your modeling can enable access directly from JS side.

TL: Is your usecase for mapping the objects to each other, people writing handwritten JS that is interacting with the JS modules that are passing back and forth. And you want an ergonomic experience of writing this JS code?

ZB: Yes, would also like to be able to do everything we can’t do with JS right now. Writing web components with Wasm without any JS involvement if we’re speaking about long term. But we need specific steps to go in this direction incrementally.

TL: Long term, every web API is importable into Wasm and then you don’t need to write any JS, but until then, you have to wrap these Web APIs you want to import into your Wasm module and you need to make the process of writing those importable libraries as ergonomic as possible and not worry about interop on the border. Do you know about the shared structs JS proposal that is adding. The idea is that the proposal would interoperate with WasmGC and that’s been the idea but we don’t know how the details are going to work. Going to sync with Shu-yu Guo the champion of that proposal in a couple of weeks and we’ll figure out the details of the interop story.

ZB: Speaking of browser APIs, would like to improve APIs for WebGPU where we need to pass arrays and strings. Would be helpful to pass WasmGC arrays directly to these APIs, right now we have to copy to buffer. Would also be useful to have more instructions to work with WasmGC arrays. You have i42 array but sometimes you need one byte and vice-versa. 

TL: Arbitrary loads and stores on byte arrays. That would be good as well. Thinking about WebGPU use cases you mentioned. Type imports might help there because you can import types from these APIs and manage them as separate types instead of lumping them all together as externref would be helpful in code correctness and performance because fewer type checks. The problem of using Wasm arrays directly instead of copying them to JS buffers, that would be nice a superpower, probably tricky on the implementation side.
"
gc/2020/GC-06-30.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 30th video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: June 30th, 4pm-5pm UTC (June 30th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: criteria/objectives/requirements for GC proposal
1. Closure

## Meeting Notes

### Introduction of attendees

* Ben Smith
* Cheng Shao
* Daniel Wirtz
* Emanuel Ziegler
* Francis McCabe
* George Karachalias
* Gergely Buday
* Jakob Kummerow
* JP Sugarbroad
* Keith Miller
* Lars Hansen
* Luke Wagner
* Ross Tate
* Ryan Hunt
* Sabine
* Syvatoslav Kuzmich
* Tobias Tebbi
* Wouter Van Oortmersson
* Zalim
* Zhi An Ng

### Discussion: criteria/objectives/requirements for GC proposal

[Francis presenting slides]
[TODO: slides]

JS: Worth noting that there is a lot of interest in compiling JS to wasm, where they want to speed up their code. Also swift is reference counted and compiled through LLVM (pointed out by Wouter)

FM: Don't want to digress too much on JS

[back to slides]

RT: What does architectural integrity mean to you?

FM: Simple way -- if you have two concepts that could be separated, they should be separated. Converse of compositionality. There's much more to be said about it, but the reason for focusing on it is that if you have a well-structured design, it's easier to survive into the future.

[back to slides]

Zalim: How about binary size?

FM/KM: I would lump that in with performance.

[back to slides]

KM: when you say ""source language"", you mean the true source or the compiled wasm source?

FM: The true source. Changing C++ to add managed memory for example will make it no longer C++.

[back to slides]

RT: That's useful framing.

KM: I agree with a lot of what you're saying. Not sure about total ordering, but I agree with priority. I don't think we want to overly design with the way things are today...

RT: that’s the one thing i want to suggest in addition to what francis has. Tiobe index, we want those working. But this index reflects old languages, not the new upcoming languages. Since Wasm is going to be around for a long time, it is hard to predict what those upcoming languages are. We want to add some flexibility in plan, leave room for what upcoming languages might need.

KM: Fair.

FM: I do want to push back a bit on that. This is not an academic exercise. It's not a design of a perfect virtual machine. What we're trying to do is satisfy users. Yes, it's possible that some fantastic language will come along and blow everything away. But if you look at that index, it's been stable for 20 years.

RT: agree with your points. Looking at the index, i see C#, it is one of the more forefront language. If we get good support for it, we will get support for upcoming languages. Place emphasis on more modern features on younger features as indicative of upcoming trends. 

DW (in chat): How important is interoperability with JS in this scenario?

KM: Clarify what ""this scenario"" is…?

FM: that’s why I phrase it the way I did. I don’t view JS as being especially privileged. If you adopt the principle that you don’t try to support full hands-on interoperability between languages, but ou support shared resources between languages and modules, then that puts the relationship between Wasm and JS on the same footing as any other language. When we interop with JS, it’s as though it’s a foreign language. We are not trying to support direct access to JS inside Wasm, and conversely we don’t require modifications to JS. Ben Titzer had a proposal some time ago for statistically typed JS objects, you may want to do that, but it’s not for Wasm’s benefit.

KM: I think interop w/ JS is flexible. I do think it's important that we have good interop with host APIs. If you don't have good interop there, then there's a huge amount of code that… I think it would be a bad choice if we don't have good interop there. It's billions of lines of code.

FM: digging into this a bit more, what does it mean to have good interoperability

KM: For example, what the bridging cost is, for wasm to host APIs. If you have to copy all your data at the edge. You don't have to do that for JS, you just hand your objects over to the DOM and it works.

FM: In reality, it’s a bit more complex than that. This is front and center when we were looking at Interface Types, we had a similar starting point. But our experiments have shown us the other side of that, it’s not worth making undue effort for that.

RT: Maybe I can make a concrete suggestion: if you make a GC reference. If you want to support specialized JS interop, you can specify the JS class associated with it, when it goes to JS, it has the structure specified. Another one is: you make a object, then hand it to JS, then JS makes its own wrapper around it. But wasm isn't the one responsible for making that structure.

FM: I will go a bit further still. If I have a module that exports an entity, a shared entity, I am also responsible for exporting functions that access it.

KM: What do you mean by entity here?

FM: yes. Let’s take a DOM for example. A DOM node coming in from browser to Wasm will show up as an externref. I don’t view it as Wasm’s job to also support access to that DOM. If I want to access DOM, I use an API function. Conversely, if I am exporting from Wasm, something to be used in JS, Wasm is not responsible for making JS’s job easier. In particular, JS has bonkers semantics as far as accessing is concerned.

KM: Are we still talking about the same topic? I was saying that, as a criteria, for performance reasons, that we can copy into the DOM everytime. Calling a function is fine, but copying data can be expensive, so if we're going to go that way, we should have data that shows that it doesn't adversely affect, and what the performance difference is.

FM: yea. This isn’t really connected to GC, but it is difficult to run exhaustive experiments, but both Mozilla and Google have done some simple experiments in this area, for accessing DOm and graphics API and trying to optimize that. In the case of the DOM, one of hte most intensive thing is to walk over the DOM, no other computation. If you try and do this from Wasm rather than from JS. With some reasonable approaches, that don’t involve special privileges, then access from JS and access from Wasm basically the same. It’s done through APIs, not that the DOM has special access. Optimizing that doesn’t pay a lot of benefits.

LW: No, that wasn’t our result. 2 to 3x speedup from what Wasm could do before. Faster than JS, huge speedup. Then made something more realistic, VDOM, took an algorithm that did the diff, got 30% faster if it was wasm calling through JS. the diff computation was only a percentage of overall. With further work, the framework could be rewritten to be a fused diff+apply algorithm, and will get speedup. This is a meaningful result, say for WebGL workloads. Right now people avoid crossing Wasm dom boundary because it is slow. Chicken and egg problem. When you do heavy crossing, it can be significant, once it’s not, then people will do it more, and it will matter more. We cannot draw the conclusion that for all time it won’t matter.

RT: My sense is that this is related to conversation next week at CG meeting about intrinsics. There's a separate discussion about that.

LW: that won’t cover DOM access

BS: might want to refocus on the GC aspects than the Interface Type results

LW: afaict, the major relation between GC and web access is cyclist that goes in and out of host, Wasm gc allows those cycles to be collected

TT: I just wanted to mention: I think JS/wasm interop is a huge opportunity for wasm on the web. If you look at v8, then you have one object model. Wasm objects and JS objects are not that different, so it's technically feasible to add access in both directions. Given that JS on the web is so important, and we have legacy access to JS, it's crucially important that we have something smoother than just calling JS functions. I'm also currently working on a proposal to have JS access to wasm objects.

KM: agree, the incremental updating is very valuable. I don’t have any particular valuation on how much balance there should be, the more we can interop, we should do so. Not sure what the barrier where we decide is not worth it. Nonetheless there is a lot of value, especially for incremental adoption. Most large websites won’t be able to throw up an entire codebase with 7000 web devs and replace it with Wasm in a single day.

LW: The really hard problem is trying to bridge between JS objects/wasm objects. It's easier to have wasm objects flow out to JS… JS is so flexible so we should be able to map wasm objects into it. But it's a one-directional thing. It seems like it will be much harder to go the other way.

FM: completely agree

TT: if at least we have 1 of the two directions working, we have a huge gain. We can choose which side we want to do the fine-grained interop

KM: It also helps that JS is one language, and not infinitely many (effectively).

BS: another comment in the chat we should talk about, from Sabine

Sabine (chat): What about Python and Ruby, do we have any concrete interest from there to compile to WebAssembly and use the GC? These are fairly popular languages.

RT (chat): Those are both up in the TIOBE index, so presumably yes.

GK: haskell might not be as high, but since we are actively working on it, i expect there will be some support for it if possible, and more support for it. It is not java but has been around for just as long.

FM: Longer actually, haskell started in '92.

KM: hope that what both francis was proposing and the reality is that, we are not intentionally sabotaging languages not at the top of the index. We should do our best to work with as many languages as possible. What FM was talking about, those languages are important to support, because they have so many uses, we want to get them working well, so that when people migrate, then can reuse existing logic. We are not trying to be arbiters of what languages are popular in Wasm, but it is a reflection of reality of how we define success in terms of how the programming language world works today.

FM: Yes, that is what I was trying to get to. Ross has talked before about ""code migration"". What I'm saying is that we shouldn't require code migration, we shouldn't require people to rewrite their algorithms to use wasm.

RT: That wasn’t what code migration is about, but I agree that we shouldn’t require rewriting algorithms to work on Wasm

FM: It boils down to -- don't lose focus on your customer. They're the ones we're trying to support.

KM: One thing important to people well above me in my org, we shouldn’t have to rewrite source language to work with GC at all. On the web platform there are fundamental paradigms built in that are important, might have to change source to work well with DOM. Run loop is important for people on WebKit… If someone have to rewrite code to work with runloop...

RT: high level -- the web is not just a language, but an ecosystem, so you may need to rewrite some things…

KM: source changes need to be made to work with ecosystem, to work with webassembly gc it shouldn’t require source changes

LW: One of the benefits of the suspend/resume feature is that we could support that kind of functionality. I also want to point that there's ""compiling wasm to GC"" or embedding the wasm engine in the language. Bring python to the web, run in wasm … or bring wasm into python.

FM: want to pick up on something someone said, about compiling JS to wasm (JS raised this). It’s one of the first things I thought of when I joined this activity. Turns out that for historical reasons or whatever, probably not a very fruitful route at the moment. We already have very good JS  on the web, unlikely we will beat that.

KM: I think a better question is other dynamic languages, python or ruby. Where they're close enough… maybe not quite as intense as JS. But they have most of the same optimizations you can do, inline caching...

RT: for dynamic languages, two classes, dynamic with uniform memory model like JS and Python, maybe Ruby. Another is dynamic with lots of casing, lisp family. For GC, they behave differently, so it’s important to recognize those as separate classes.

FM: Why is lisp so different?

RT: lisp scheme racket, they are tons of primitive reference types that they case match on all the time, rather than assuming everything is an object, and always access things in a particular manner.

KM: Are those primitives implemented in the runtime as primitives?

RT: varies. Large cases, many different implementation strategies were explored. There are roughly uniformed dynamic languages, and many-case dynamic languages that behave differently. Lisp is fairly simple, but multiple lineages and variations.

KM: We've talked mostly about host GC here. Should we talk about linear memory GC criteria next time?

RT: one high-level concern, top 20 languages include C# and go and swift, you get a lot of features that you need. So a question we need to discuss is, what plan do we want to have for dealing with timeline pressures and feature richness. There is a tension between doing a fully- featured thin v.s. Getting something out.

FM: do it in order of popularity? That will put C# near the top.

RT: doesn’t help with the number of features you have to build

FM: by solving the GC problem, not necessarily enabling all these problems. It is a big thing, necessary but not sufficient.

KM: On swift, does it make sense for them to use the GC implementation anyway? They're reference counted, and they have value types.

LW: does it have destructors?

KM: yes

LW: hard to emulate precisely

KM: probably isn’t true given the code that i have seen. Can hope that stdlibs are written such that they don’t need to be precise when they are called. My guess is no, probably weird bugs if you run them (destructor) later

BS: not sure we want to talk about linear memory GC with some framing, 10 mins left, probably next meeting.

KM: yea agree

BS: any other comments on what Francis presented? To disagree or add to.

TT: one perspective, we talk a lot about languages, but we also should talk about optimization technologies, like JIT compilers, and how they fit into Wasm GC. most languages need optimizations. E.g. putting dynamic languages onto wasm, what does this mean? Interpreter, or JIT, then you have to build a VM. not clear where you put this VM. you can’t AOT compile dynamic languages in a reasonable way. Same question for Java, someone in the pipeline you have to do the optimizations, we need to decide where this happens.

KM: That's a good point. I know that, given that everyone here probably wors on a runtime, there's a bias toward total control. There are some downsides to that, like binary size if you have your JIT engine. I would err toward giving the host control of things (I'm biased though). The host has knowledge of what's going on in the system, they have sophisticated garbage collectors, they can JIT compile... so I hope that we might be relinquishing some control for the betterment of everyone else.

FM: a way of putting that is that the browser knows how to GC itself, tyvm. You’re right, the host has an environment, it has more context. You’re the host of the party, you get to set the rules. You can leave the party as a guest. Loading a wasm module in the browser, you are running in someone else's environment. Tobias’ question is not really directly connected to GC, more general at the Wasm value.

TT: Building a managed runtime, right. Similar to CLR or JVM. It's pretty open how we build this managed runtime, but we do have one.

FM: there are blockers to Java being adopted to Wasm. The GC is only one of those blockers. JIT is a major one for Java, classloaders another one. We are not solving all the problems for bringing Java onto Wasm, just solving some of them.

KM: I think JITting is something we should consider during the GC proposal. We shouldn't make it impossible. But I don't think we should be trying to solve this part of the proposal.

RT: 1 important consideration, for C#, the plan for it should rely on C# to have JIT… do we want to have the support that C# needs to not require JITting.

KM: Jitting in the wasm runtime or the C# runtime?

RT: two ways to implement C#, fancy polymorphism for dynamic monomorphism We are not going to support the former, then dynamic monomorphism. But if we don’t have an infra for JITting dynamic monomorphism...

FM: Point of clarity here -- you could mean generating wasm code, or you could mean generating native code.

RT: either would solve their problem, are we going to provide reasonable support for either one

FM: I don't think we've been talking about allowing wasm to generate native code. There is a requirement that is connected to this, related to GC. And that's garbage collecting code. That might be a requirement that we adopt. Not just data structures but also code.

LW: we already have the requirement, you can dynamically generate modules, you can leak them. Stack scanning, make sure don’t accidentally delete something live on the stack.

BS: out of time, looks like a good place to stop. There will be a meeting in two weeks, I will create an issue, please add agenda items to that issue.

FM: suggestion to focus on linear memory gc
"
main/2021/WG-02-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 10th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: February 10, 2021 at 4pm-5pm UTC *( February 10th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, registration details to follow shortly.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. POLL: [standardize phase 4 proposals](https://github.com/webassembly/proposals#phase-4---standardize-the-feature-wg) (Andreas Rossberg)
        1. [Bulk Memory operations](https://github.com/WebAssembly/bulk-memory-operations)
        1. [Reference types](https://github.com/WebAssembly/reference-types)
    1. Discuss next steps for the working draft (Eric Prud'hommeaux)
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

## Attendees:

Luke Wagner

Andreas Rossberg

Conrad Watt

Deepti Gandluri

Derek Schuff

Jakob Kummerow

Wouter Van Oortmerssen

Thomas Lively

Sergey Rubanov

Zhi An Ng

Eric Prud'hommeaux


## Proposals and Discussions

Announcement/proposal: New chairs for working group: Luke Wagner, Derek Schuff have agreed to do this.

Consensus poll for LW and DS co-chair for WG.
No objection, passes.

Technically, it turns out Fastly has not finished joining the W3C yet, so we should wait until that happens before making this official.

## 1. POLL: standardize phase 4 proposals (Andreas Rossberg)

### 1a. Bulk Memory operations

<Presenting SLIDES on Reference types and Bulk memory operations>

No relevant open issues on either of the repositories - landing this means we land both of them. Proposals are mutually dependent on each other, so they have to be merged together, not in isolation. 

Current plan: Merge both from the Reference types proposal.

DS: general question, any other proposals in the pipeline that has this kind of mutual dependency?

AR: Don’t think so and hope not - we added some features the wrong way and we didn’t see the implications right away - if done differently would have left out all the tables out of the bulk proposals, etc. There were no technical reasons to separate them this way.

DS: it was because we wanted the memory part for threads, the table part is kinda independent

AR: only place where they were more closely related and kinda ugly if we did one and not other, changes in data and element section. It wouldn’t be a problem but a little ugly. Not aware of any other set of proposals that would have the same problem. Hope we learned a lesson there.

LW: Acyclicy is valuable

AR: we didn’t see that there was a cycle in there at first

TL: Related feature of the bulk memory proposal that we would do differently - I don’t know any use in the wild of the bulk table instructions. If we were doing it now we would be careful that the operations should be something that would be in use.

AR: fair concern, on the other hand, it’s also fair to say that there is some level of consistency within the language, here I think you can argue either way. I wouldn’t take it to the extreme, i have seen it in some discussions that I do not entirely agree with, every instr has to be individually motivated, when there is a set of similar things and not have random holes in the matrix in some form. Different topic I guess.

DS: we can go for a consensus poll, say we want to merge these 2 proposals as outlined in slides. Any discussions/objections on this.

LW:Asked FF implementors if they knew of any outstanding proposals - none so far.

DS: will take that as a yes.

AR: will create this PR, not sure how much work it will be. Think before, the things were merged by Ben, and I did the reviews for that. For this one, it’s a bit larger, and supposedly been reviewed in detail before. Always better if someone looks again.

DS: I can definitely look, one of the things I have to do is figure out how to build the doc and get familiar with all of that aside from technical stuff. I can figure that out as I go.

AR: another thing I want to ask. If i remember correctly, is it Ben or Brad who figured out how to do a diff on the doc somehow?

TL: Rings a bell, don’t remember

EP: are you thinking about doing various editions of Working Draft? I did by hand, and it is miserable.

AR: We have two/three documents we can produce - there is a pdf, and different page html - one of them had an option of producing a diff. 

EP: a lot of variation, they all kinda suck, don’t be optimistic

DS: i can find out and see what...


AR: Another thing that came up was that if there should be some kind of appendix on the spec, not a detailed spec, but just a note about which instructions were added with the spec - we should also cover the ones we’ve already merged. That might be good to add before we have an official W3C branded version of this

EP: it was a big burden before, X and I are trying to figure out. We have this rule about eating our own dogfood, making sure document is accessible. Anyone has idea what happens if you read sphinx docs with screen reader? Speaks in your ear.

AR: Probably horrible.

EP: The rendered on, math is going to be hard, ways to get annotation to make it not suck too badly. That’s what we were trying to do before. Looking for some way to achieve that.

LW: in some ways, the prose description should correspond to the math equations. It’s a alt text for the formulas.

EP: That’s a fair point, maybe the annotations should say don’t read this part aloud

AR: was wondering if we should have nicer kind of layout for the separate formulas, so that some background or frame around them, more nicely separated from prose text. Not sure how to produce that from sphinx.

EP: It’s possible that that would allow us to set CSS media control

AR: There’s still going to be some amount of math in the prose - when you abstract some aprt of the spec - don’t know how you would pronounce that

EP: if you can the attention of T. V. Raman they can probably help. Is there a particular chunk of the document that we can give someone to look at, typical piece that sets a low/high bar for complexity.

AR: I would pick some random parts from validation - for each instruction it has the prose and then...

LW: complex rule, the instantiate rule

AR: that would be the rule, instantiation rule, in the execution section.

EP: instantiate is the top bar, lower bar is either validation or some execution. Will see if I can get his attention.

AR: just pick some instruction in both rule.

AR: Is this something <accessibility - screen reader> someone requested?

EP: part of the w3c process, basically is w3c eating its own dogfood. And a reasonable number of people in the community who need these technologies. Would like to publish sphinx, a bit of css to put w3c in the top.

2. Discuss next steps for the working draft (Eric Prud'hommeaux)

AR: what is our timeline for cutting a new official version of standard. Don’t think we discuss that properly. We have merged a bunch of stuff.

EP :Typically the working group gets to split the difference between keeping the world informed and making a good first impression - we have to worry about keeping the world informed - the other thing is producing the document which we can do with sphinx and a little bit of css

AR: we are still at version 1.0, published ~2 years ago? Wonder if after merging these proposals, will be a natural point in time to have 1.1. Don’t think there are any other proposals that are nearly landing right now.

EP: When Brad set this up, he kept a naming scheme that would allow us to have Wasm 2, 3. We don’t have anything backward incompatible so we can go with 1.1..

AR: yea think the version on the doc is 1.0, so we can use 1.1. From my perspective makes sense, it’s not a fundamental change.

EP: Is this uncontroversial - are there any places where it’s not backward compatible?

AR: Not in any relevant way

TL: if we ask for other proposals, SIMD is about to land, not sure if we want to cut it in so soon.

AR: that’s at phase 3 right?

TL: we’re voting for phase 4 at the next meeting.

AR: still a lot of movement on the PR as far as i can tell, still a lot of code reviews.

TL: right, don’t think it’s ready to move to phase 5 soon, but if we are asking if proposals going to land, maybe wait for SIMD so we can include that as well, since it’s going to be phase 4 soon. Or not, then we can put into the next version.

EP: We can have another working draft any time we want - around november we wanted to talk about if we want a new patent policy. Does anyone have any opinions? Should we switch to the new patent policy - does anyone have an objection to an evergreen policy?

DS: what we were deciding was a new patent policy which will give us the option to move to a living document.

EP: we don’t have to, Philip wants to use new policy anyway, slightly more aggressive towards lawyer, but no one complained, so we have the green light for them. So all WebAssembly members inadvertently given it green light. It is up to us to say if we want to do that. We can make a decision now, or wait 2 weeks and have it on an agenda.

LW: What was the issue - existing discussion?

DS: cg meeting, don’t think there was a thread about it.

LW: I remember there was a discussion...

EP: if you want some details I can give you now, possible for us to figure out which meeting it was. We talked at a couple of consecutive meetings.

LW: Maybe just - links to patent policy would be helpful, what it means to be a living document etc. In general like the sound of it - want more details.

EP: let me go dig that up. Switching to a new patent policy doesn’t commit us to a living doc, it just gives up the latitude to do switch. Living document means you get to stay in CR and iterate there a while. And also that’s what some groups, like HTML, don't’ really remember. Other groups with more formalism, this has been tested as of version 1.1, better meet the needs of customers.

LW: When you iterate in CR, are there no version numbers produced as a part of that? 

EP: don’t think so, you use dates, means less synchronization with the test suite.

LW: There’s the sphinx rendered that goes live, and separately there’s a thing that goes through bikeshed - I don’t think anyone really reads those compared to the web versions...

EP: right, think there might be some reason for a person with a screen reader. It’s a giant monolithic document, real swapper. Think most people would avoid it, because it takes so long to load.

LW: Do they have the hyperlinks between the uses and definitions - that’s my favorite feature

EP: yea. In fact it relies on mathjax, so you can click on stuff.

LW: In the final output I thought maybe the JS would have stripped away

AR: output using Katex. Multi page document uses mathjax, it’s more accurate, then the katex involves brave hacks by brad to make it look ok. Maybe that has improved by now, not sure. We should explore that mathml is coming back?

EP: We could become a usecase for them

LW: that’s how i use in FF, use mathml instead of mathjax.

AR: Would be cool if we could use them - mathjax is crazy but it has limitations and is pretty slow

EP: think that would be fabulous, also make accessibility stuff someone else’s problem. Found links to process documents and stuff like that. This is on my laptop, not on the hangout, will paste them to DS.

Links to process docs:
https://www.w3.org/2020/Process-20200915/
https://www.w3.org/2019/Process-20190301/#GAProcess
https://www.w3.org/Consortium/Patent-Policy-20200915/

LW: is mathml close enough to what’s currently written in sphinx? Or is it totally different?

AR: it would get generated.

LW: is mathml close enough to what’s written in latex.

AR: You mean writing manually? It’s a nightmare you don’t want to do that - whole insanity with SGML syntax - lots of nesting etc.  with formulas etc. it’s not great.

EP: hard to compete with something that’s effectively DSL. will be cool to have that. Other thing to explore, sphinx has svg output, but no links in it. There’s a possibility there, but no one seems to know anyone who knows in sphinx. Need someone interested to dive into that, to get SVG generator to include the links. Not sure who can do that feature quickly.

AR: another problem with Sphinx, pinned fairly old version, cos they keep breaking stuff. Some plugin stuff we did to enable some macros would not work with newer versions. Someone would have to upgrade it. Tried to figure out how it works and failed, can’t be bothered right now. No idea if it would take someone who has intimate knowledge of sphinx.

EP: If we found out someone could answer the questions..

AR: in retrospect we should never have used sphinx

LW: If you would start from scratch, what would you use? 
AR: latex obviously. Initially we decided to ues markdown. Actually much more overhead due to the embeddings and all the markup you have to do to embed tiny pieces of math.

LW: Do you think this is just a matter of paying a contractor to do a manual port?

AR: we have all these proposal repos which are forks, any kind of changes done will create massive conflict across the board.

LW: We can graft the outstanding diffs.. Shared memory work is significant and outstanding, quite a few proposals have spec text written in them

AR: quite a few proposals that already have spec texts. I know because I wrote some of them. Even then it is painful when you have non-trival changes upstream, already merging conflict there. Can’t imagine how bad it would be if you made complete structure change.

LW: Would need a rewrite from scratch with a diff

AR: write a tool to write the conversion.

LW: if the better tool is latex, we should get it in sooner or later.

AR: IF there’s any good point in time to do that, right now certainly sounds like a bad time - if the number of active proposals slows a little with most of the features we were envisioning already being in..

EP: ideally people lose interest and wander off


AR: Latex just produces one big..

ZN: we already can convert the rst to latex? We check in the latex instead of the rst?

AR: We would have to find and investigate tooling to create a multipage webpage

LW: multi-page webpage, yes, i like it.

AR: There are tools that do that, but don’t have experience with that - how difficult in general it will be - I have heard wildly different stories about that

EP: nice opportunity to use a different toolchain

AR: every toolchain has its own set of problems. General fear that this is quite an investment for some time, to switch to some other toolchain. Not entirely sure it is significant and worth the effort. Maybe the pain isn’t high enough yet.

DS: If we’re looking for ways to significantly improve our process, what would the alternative be? Do we keep sphinx, Brad had a made a hack and we got three different outputs - if we don’t want to rewrite everything, or package everything etc..

AR: The tooling is there, it’s a hack but it’s automated and it’s there. There isn’t something much to do unless something breaks.. That could happen - the last change was when Ben rewrote the script for the table, we have various workarounds for the issues, but at least for now they work so there’s no immediate thing to do modulo the release process

LW: just the production of the bikshedded w3c

AR: that’s automatic, but the officially stamped out, not sure if anything else done there

AR: would have to ask brad, not sure what he did, maybe it’s part of automation. I’m pretty sure there are some editorial things. At that time a lot of stuff, mostly involved katex. Maybe it’s all automated now.

DG (Chat): Not to derail the conversation, but I realized we don't have another meeting on the schedule - should we talk about meeting cadence in the last couple of minutes even though it's not on the agenda?

AR: sounds good. Vaguely remember we decided this should be monthly, but cancelled if no agenda.

DS: yea that seems fine, we’ll have a few more things to talk about in the future. That’s what happened, we had things to talk about regularly, then nothing. Monthly sounds about right to the rest of you?

EP: makes sense

AR: no one set up an agenda doc, nowhere to put PRs, if the new chair can put up agenda…

DS: sounds like a problem we can fix. This time slot is good for everyone?

EP: good

AR: good for me too

LW: any reason we can’t splat out the rest of the year, or dynamically? I can set up reminder to make an agenda 2 weeks ahead of each.

DS: don’t see a problem scheduling in advance too.

AR: my impression was that we did it a couple at a time, at least for CG meeting, why not.

<General consensus, time slot mostly works for everyone>

DS: i posted the links to patent policy, probably discuss next time, get that out of the way, AI for anyone who cares to look at that so we can decide on that next week.

EP: vague recollection that we would decide by email/issue. Wll be nice to let philip if we are eligible before a month or two. Do you think we can reach a decision on a charter before a month is up?

AR: the patent issue?

EP: yea.

AR: I’m fine with anything

DS: we could do a auto switch and say, if anyone doesn’t object in a week, we will do it by default.

EP: seems sensible, not sure anyone cares.

DS: Anyone can take a look at the policy..

"
main/2021/CG-03-02.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 2nd video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: March 2nd, 5pm-6pm UTC (March 2nd, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for the link.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Follow-up discussion of [Branch Hinting](https://github.com/WebAssembly/branch-hinting) (Yuri Iozzelli) [20 min]
        1. Poll for phase 2?
    1. Specifying sub-languages (Andreas Rossberg) (15 min)
    1. Presentation and poll for removing support for duplicate imports ([module-linking/#7](https://github.com/WebAssembly/module-linking/issues/7)) ([slides](https://docs.google.com/presentation/d/1uq3uFkmXHRjP5V56wKlmxMH_gveYcigc8DIXYyGpWE4)) (15min)
    
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Introduction of attendees

Derek Schuff

Luke Imhoff

Rick Battagline

Arun Purushan

Yuri Iozzelli

Zalim Bashorov

Ryan Hunt

Sam Clegg

Francis McCabe

Lars Hansen

Petr Penzin

Asumu Takikawa

Paolo Severini

Nick ""fitzgen"" Fitzgerald (he,him)

Ben Titzer

Alex Crichton

Ross Tate

Eric Prud’Hommeaux

Adam Klein

Yury Delendik

Luke Wagner

Jakob Kummerow

Andreas Rossberg

David Piepgrass

Manos Koukoutos

Emanuel Ziegler

Rich Winterton

Sean Jensen-Grey

Zhi An Ng

Nabeel Al-Shamma

Thomas lively

Conrad Watt

Deepti Gandluri

Johnnie Birch

Keith Miller

Flaki

Petr Penzin


### Follow-up discussion of Branch Hinting (Yuri Iozzelli) [20 min]

[slides](https://drive.google.com/file/d/1fzgBZQmLaiH9Qp7tFS8oO13MBzLmU3El/view?usp=sharing)

RW: If you were to provide a capability like PGO, would that eliminate the need for branch hints? 

YI: PGO is not exclusive, branch hinting can be used in conjunction with this. Developers aren’t good at estimating branch hinting, you can use wasm to collect pgo info and feed it back to LLVM, you can use PGO for better hints, not mutually exclusive

RW: why would you need a hint, if you know from PGO that this is usually taken

YI: who is the subject, compiler or the engine?

RW: The compiler would put it in, something there that compile will provide enough information to the engine and then the engine would do something with that information

YI: this is exactly what we’re doing here, the compiler alone cannot do this, but it can add extra information to the engine

KM: Most PGO systems[...] Usually PGO systems talk about I would consider this branch likely or unlikely

RW: that’s what i’m trying to figure out, whats different from the general PGO, llvm will provide the relevant information and clang will generate

KM: llvm starts throwing a lot of the data, it will be gone. Main thing you have at the end is the branch hint

DS: I really see this as a form of PGO, in particular, some of this optimization can't be done by the compiler - LLVM in particular uses this for block placements and this is something we can’t do in Wasm right now, I can see this as something we can integrate with LLVM’s PGO

YI: tried to fiddle with LLVM to try adding support in the compiler. The exact same is used for PGO and manual hints. Manual hints has some default probability values.

RW: There isn’t a way to do LTO, correct?


<in chat>
BT: Branch hinting should be thought of as the wasm binary format by which a PGO system communicates its inferences to a wasm engine.
So this is orthogonal to how we get the hints.

<in chat>
KM: Agreed

<in chat>
RT: +1

DS: LTO happens at toolchain as well, we do that already, we link into a big binary. Emscripten does cross LTO between JS and Wasm, that is pretty much happening now.

RW: You couldn’t do another LTO type thing, that’ll happen in the runtime when generating code. 

DS: I don’t think I understand what you’re suggesting. What BT suggested in chat is right - you would use this as a part of the PGO system

RW: it’s only useful if you have some feedback with that

DS: This is just one component, you would need some way to feed the profiling info, that can be done with instrumentation, that doesn’t need to be standardized.

RW: on board with that, i would agree with that, if we don’t have the PGO, developers won’t be able to take advantage of that

YI: That’s also why it’s difficult to find a benchmark, with PGO you can also start to see something but it’s more work to get it all work

RW: on board

KM: question about benchmarks, can try doing in JSC, can disable engine’s likely and unlikely for native VM code for JS and see how that impacts benchmarks. That will tell you if branch hinting has any value in generated code for some kind of language runtime, it will likely be multiple % points.

YI: Right now in V8, Wasm branch hinting is used for something - for division, experimental branhc on null. On the codebase, we try to add something on null checks, even if there is a lot of overhead, you can already see that it’s making a difference because V8 is using ints for branches for null checks but not everywhere else.

KM: you would see 5-10% benchmark regression, very significant.

DS: should we subsume this functionality to allow tools to do block layout? I.e. proposal like funclets, any thoughts on that beyond what is in chat?

<In chat>
WV: it wouldn't, but at least it would be able to express the structure of an unlikely block being outside a loop naturally, and a VM would not have any reason to undo that

<chat>
BT: PL security checks (e.g. array bounds checks) are unlikely to fail, so an offline compiler may use branch hints without PGO, too.

<chat>
LI: Branch hinting is used for memory allocators a lot too, so those being ported into WASM from Rust, etc could use those hints.

CW: I made a soft promise to talk to CG about unstructured control flow. Expectation was that some optimizing VM cannot generate code for it very well.

PP: toolchain can do layout rather than just create a hint table. Can’t estimate if it will be better.

DS: funclets seems high risk based on discussions we've had before. Good chance there is a lot of resistance, won’t pan out. Should we advance two proposals if they overlap? Okay with that, especially no strong push on funclets. Especially for going from phase 1 to 2.

BT: My understanding of funclets is that it’s trying to do irreducible control flow, it’s to increase the expressiveness of the control flow in wasm - orthogonal to this - we don’t have block layout, it might be useful to extend branch hinting to have stuff for block layouts, my understanding of V8 is that this would be hard to do

DS: we're getting over time for this. Curious to get a sense whether people want to hold this back from phase 2 specifically.

CW: understanding for seeking phase 2 is out of the hope that engines will more likely implement a prototype for benchmarking. It’s the wrong way round.

LH: I have made some comments that format is too limiting, and it should be extending the format so it can support more PGO functionalities

DS: what we heard last week is that you had started one for v8, and Jakob would be supportive of helping that go in.

YI: I already have a prototype for V8, it’s a POC but trying to refine it, I think it’s reasonable that with a little work this could be added to V8.. in a good shape now. 

DS: i’ll be happy to have my team help further down the line when thinking about integration with LLVM. given that environment and one outstanding concern about whether we should broaden the format. Will you be okay with implementation and phase 2 waiting until we nail down the format more.

YI: Yeah, sure. My main concern is that we get to some point that we don’t decide to do this with instructions at some point - I can work on implementing this in a codebase, add to Cheerp compiler etc. If the CG agrees that the custom section is the way to go, Phase 2 then is just a number.

DS: LH’s concern is not with using custom sections

YI: We talked about it in the issues, I wanted to address those things in the spec, didn’t want to change it under the hood. 

DS: We are so far over time - most folks are happy with the direction. Continue working on it - I would be confident going forward in the custom section with the knowledge that we will need to tweak the content. 

YI: Good for me

<chat>
SJG: +1 on that comment
The comment I was agreeing to is the idea of not forcing engines to implement a PoC for benchmarking purposes.
 
 <chat>
CW: to be precise, moving to phase 2 in itself does not make engines more likely to implement PoCs, so the real thing we want isn't a phase vote, it's a commitment by _someone_ to do a PoC for benchmarking purposes

<chat>
BT: Well, some teams might have OKRs such as “implement all phase 2 proposals for Wasm”
 
 




### Specifying sub-languages (Andreas Rossberg) (15 min)

[slides](https://github.com/WebAssembly/meetings/blob/master/main/2021/presentations/2021-03-02-rossberg-sublanguages.pdf)

EP <chat>: is there a way to quantify how much/what fragmentation is inevitable? (gc seems like a compelling example)

AR: Right now, none of these features are in the standard, but some are close - but there are cases where this will already be needed - example - threads introduces non-determinism so block chains can’t use it

DS: there are blockchains already implementing some subset of Wasm like without floating point non-determinism

AR: for FP, you can work around, can make it deterministic if you pay for the performance. With SIMD there is discussion for non-det SIMD. Threads is one useful example, GC also. In some examples you don’t want a GC, like in embedded space. SIMD itself another set, environments which have no benefits from SIMD, Apart from those, no particular ones.

LH: Wouldn’t this change the way we spec things? First of all, bulk memory and reference types depend on each other, Let is independently useful, not sure which proposal it’s in - the proposals may not be the right level of granularity, or we would have to break them down into independently useful components

AR: not implying that proposals are the right granularity, right level of discussing it. Within proposals you can make certain parts optional or not, or you can group multiple proposals into one. Not proposing something concrete here. The risk is that we make it too granular, it has to be decided on a case by case basis.

FM: what about the other half of this, known as feature detection, want to be able to run varying payloads depending on what’s available.

TL: I was just going to mention feature detection, it’s going to be relatively high priority going forward given SIMD status, these can be complementary to that - we definitely need both parts

AR: maybe they could be talking about the same feature, feature detection i would probably think about it at smaller granularity.

DS: When we are defining the subsets, we want to minimize the number of subsets. Feature detection has the problem of if we put a module right now, which browser supports what etc. 

TL: the forces making you desire few large granular features work the same for the spec and feature detection.

AR: It might be true, I still think that for example when you do threads, that future threads instructions, for this kind of things that wouldn’t require a new definition

LW: The fullness of time, vs. eventuality or what we should be doing now..

RT: if you take determinism as an example, that is a positive property you are trying to overlay to Wasm, only applies to certain subset. A way to formalize that is as a separate proposal to say what is determinism in Wasm, a subset of Wasm. A resource constraint Wasm, what are the positive properties you guarantee.



AR: That might be a more suitable way of slicing this, that might make it separable from feature detection

BT: Java was originally for embedded systems, it had this things called profiles, embedded, j2se, j2ee, only a handful of them. They define JVM feature sets, class libraries feature sets, you can write Java to the profile, limited number of profiles.

AR: I wasn’t aware of that, but that sounds like something that makes sense - profiles sound like a good idea

FM: profile is a great idea, goes beyond this too. What about deprecations, can we use something like this to deprecate something.

AR: Interesting, I had thought of that - you could use/abuse it for that

FM: we should plan for obsolescence.

AR: I don’t see any principal problem with this

DS: coming up on time, a lot of interest in this, we should keep talking about this. This won’t be a typical phased proposal, but there's a the diversity of different considerations, I wonder if it makes sense to fork a repo anyway and have multiple bugs inside to discuss this.

AR: Yeah, why not - we may not be able to follow the phased proposal 

DS: sounds like we met phase 1 requirements that we think this is a problem and we should think about solving.

AR: Fair point

DS: any objections?

TL: sounds great, needs more discussion. Important to come to a shared understanding to come up with what this is for.

EP: before forking or before merging it back in?

TL: Before merging it back in

RT: should we have some phase 0 discussion?

EP: That could be a good place to capture this discussion, profiles vs. modules

AR: rephrase this more specifically as profiles, to make it closer to what I’m at getting at. Can create a repo and see how that lines up with feature detection, and how we can widen the scope

BT: profiles might be the end outcome, profile supports certain feature sets, to get there we need to define feature sets and where the boundaries lie.

AR: <Agrees>


SJG<chat>: Semantic weight to parts of proposals, what is the base and what is implemented on the base.

EP<chat>: is there a possibility that WASM engines themselves could be modularized along these partitions ? i.e. link in feature set X

SJG<chat>: extensions, feature testing, versioning

BT<chat>: It gets complicated the more feature sets you have and when they have dependencies

SJG<chat>: Is the goal, ""how do we structure the evolution of wasm so that it doesn't crush under its own weight""
x86, arm, c++ have all approached some maximum complexity
How does RISC-V approach this? Rust?

ZN<chat>: riscv has base + extensions https://en.wikipedia.org/wiki/RISC-V#ISA_base_and_extensions

EP<chat>: another somewhat inevitable parameter is the published version of WASM some impl followed

SC<chat>: J2ME gives me nightmares :)


### Presentation and poll for removing support for duplicate imports (module-linking/#7) (slides) [Luke Wagner]

LW [presenting](https://docs.google.com/presentation/d/1uq3uFkmXHRjP5V56wKlmxMH_gveYcigc8DIXYyGpWE4)

BT: allow anything to be exportable. In the future we might allow import with the type argument, will the duplication take the type argument as well? You might import and give it some other type argument.

LW: I was imagining that it would be simple string equality, you would be importing something in the generic sense

BT: in the jawa use case, you can parameterize module by a type, that’s space prohibitive to do that, you need to import individual things.

LW: Maybe they could be type parametrized? 

BT: since we don’t have params right now, something to think about in the future

CW: Are the exports themselves parametrized, or are they exports of a parameterized module?

AR: a bit out of scope for what LW was talking about. To me is just about removing duplicates, parameters would benefit from that, or orthogonal more or less.

RT: Could someone go into details about how duplicate imports were allowed to begin with?

LW: it took extra work to specify to reject them. They were allowed by asm.js, you can import and use multiple times, log use case, weak reason.

AR: no strong reason to disallow them. We are thinking of use case like that. Overloading case we use at dfinity for a while. If you have a polymorphic host function, this is a way to emulate. You can import same thing with different types, and instantiate with different types, this only works for host function, and not for Wasm modules. In our case it was clearly host API so it didn’t matter. Consider this for versioning, you can import the same function with additional arguments, in the future version you won’t need a new name.

BT: What bad thing happens if we keep allowing this? 

LW: if we try to reframe 2 level imports as single level, then we will have this problem that duplicate imports can’t be reflected as that. We have to allow duplicate exports, in certain cases, or special case in another way. Some weirdness has to arise in some other space.

AR: You have to allow multiple exports.. You will have to map multiple exports to different imports..

CW: some kind of aliasing thing, this space of index space comes from another thing i import before hand

AR: you can no longer supply different values for the multiple imports. Since you are only supplying one instance. This desugaring doesn’t work, you have to make it a special case somehow. Or desugar in 2 separate instance imports.

BT: The duplicate exports is the only place an engine has to inspect import/export strings - because it’s based on strings and positional, that’s why the problem shows up


DS: there’s generally some support for this, it seems a little bit fast to go for a poll today to remove a feature from the web. We should try to get more eyeballs on this; e.g. I wasn’t following the module linking proposal, so I first saw it on agenda here. Maybe we should file a design issue on a more visible avenue. Maybe we don’t need a full on phased proposal, but should have more discussion.

LW: That sounds reasonable, will file a design issue, and follow up again with a meeting

RT: useful to get feel of the room?

KM: curious how single level imports interact with ESM modules proposal. ESM needs two level modules.

LW: default exports

<in chat> BT: It seems like adding a restriction to workaround a previous restriction (duplicate exports)

KM: if it doesn’t have a default then error?

TL: I wouldn’t object, do feel that don’t quite understand the actual motivation - would welcome a design issue. 

DS: Next week’s schedule - our current meeting time is based on US pacific time which changes next week, so please note that time changes for the next meeting by an hour depending on where you are located. 

"
main/2024/CG-07-02.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 2nd video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: 2024-07-02, 16:00-17:00 UTC (2024-07-02, 9am-10am PDT, 18:00-19:00 CEST)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
  1. Ryan Hunt: Present on [compact import section format](https://github.com/WebAssembly/design/issues/1514) and phase 1 vote. (30 minutes)
  1. Continue discussion on spec complexity from [in-person CG meeting](https://github.com/WebAssembly/meetings/blob/main/main/2024/CG-06.md#thursday-june-6) (30 minutes)
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes


### Attendees

- Thomas Lively
- Derek Schuff
- Conrad Watt
- Benjamin Titzer
- Jeff Charles
- Petr Penzin
- Ilya Rezvov
- Paolo Severini
- Francis McCabe
- Zalim Bashorov
- Dan Gohman
- Nuno Pereira
- Ryan Hunt
- Heejin Ahn
- Brendan Dahl
- Nick Fitzgerald
- Luke Wagner
- Jake Enget
- Chris Woods
- Manos Koukoutos
- Mingqiu Sun
- Keith Winstein
- Jakob Kummerow
- Linwei Shang
- Ben Visness
- Michael Ficarra
- Julien Pages
- Emanuel Ziegler
- Andreas Rossberg
- Andrew Brown
- Brendan Dahl
- Slava Kuzmich
- Richard Winterton
- Kevin Moore

### Proposals and discussions

#### Ryan Hunt: Present on [compact import section format](https://github.com/WebAssembly/design/issues/1514) and phase 1 vote. (30 minutes)

RH Presenting [slides](https://docs.google.com/presentation/d/19aZW4pAtPDc6Wgw6XGCBcR9f3DZ95LQm6ORYqLayJNw/edit)

Problem: the module name field of the import descriptor is repeated for every import. For most modules, the module name field is the same for most or all of the imports. This wastes space!
With JS string builtins, there are a lot more imports, all with the same module name.

CW: do you anticipate any need to do something different with the “read the imports” step here or is it just hypothetical?

RH: I imagine that we would change the ""foreach"" in the algorithm to do the ""Get"" for the module object just once. So say you had 1000 imports for the same module, we'd have to do 2k gets for the module object, and then again for the fields. Now you’d do one get for the module, and 1k for the fields.

CW: Is it really so observable that you can't just do that as an optimization?

RH: It did stop me from doing the optimization because of the complexity. It is in principle possible to fix this on the VM side, but it has come up in practice on the JS side that you really do have to follow the spec more strictly and do the right amount of lookups. I have seen proxies used here, we can’t just disallow them. I am open if people have opposition to changing the text and binary format, but I like the idea of doing it this way.

TL: In the dynamic loading use cases where we lazy load secondary modules, the proxies are very useful for that. Not for the modules, but for the fields. If we extend wasm-split to load arbitrary numbers of modules, we’d probably use a proxy for the modules as well.

AR: maybe getting into bikeshedding, but there's a close connection to what's happening in the component module extension where you have this idea of instance imports. This is kind of what that is, where you import a whole instance and you list the fields. So structurally you could make this a new form of import instead of a new section. The CM gives an instance type as a different thing to define separately. But treating it like an instance import would be logical in the text and binary formats. It would be ust a new form of import rather than a new section.

RH: I have a slide that imagines something close to that, but in general i dont’ have all the details worked out yet. So if there’s unification with the CM, we could do that.

NF (chat): What if we had a new import kind that was a vec of sub imports that only provide field names and not module names? that could fit well with the existing binary format and wouldn't need a new section. and maybe would be something we could naturally fit into extending the existing ""read the imports"" algorithm.The weird thing is what to do with the outer import's field name. that could either be ignored or concatenated with each sub import's field name, which maybe allows more deduplication, or at worst the outer import's field name could be an empty string. (this is sort of similar to the instance imports as well.)

RH: there was some reason i thought that wouldn’t work, now I can’t remember. But if we could make it work, that would be ok.

LW: It's because the two strings are hard coded into the import format before you get to the import description.

NF: you could require it to be an empty string, or ignore it, or concatenate it. There are several options

CW: I think the exact binary format can be something we can bikeshed offline on GitHub.

MF: Can you show the algorithm slide? My understanding is that this is the main motivation rather than size. Why can’t we just make the change, if we have 1k imports, to just have 1001 get operations? That would be observably different but, the question is whether anyone is relying on this. I've used a proxy in this position before, but they haven't returned different import objects each time. Why can't we just make the change?

RH: I agree, I hope no proxies are actually relying on this. If we want to change the algorithm we'd need an earlier step that iterates over the modules and does some sort of manual grouping. Maybe you could have some sort of map that caches previous ones? Not sure how that would work.

MF: Yeah, I was thinking of caching the module objects.

RH: I do think it’s possible, but it puts complexity in the engines to find the groupings, and it also doesn't address the fact that engines have to have this in uncompressed memory, so I still have a preference for extending the imports.

BV (chat): is there a limit on the length of an import name? If so, since the first byte you see is the length of the module name, maybe you could use that as a sentinel value for a different type of import.

JK (chat): no, no limit.

BV: Just wanted to emphasize that changing the binary format would guarantee that the imports are grouped, which would also speed up encoding. Not a huge deal but making it explicit is nice.

RH: There's a cost to keeping it all in uncompressed memory. A bunch of minor things but could be eliminated with a small tweak

CW: I just wanted to bring up a more restricted form of this. You could have a different import section, but then whichever one you see first sticks and seeing the other afterward would be an error.

RH: i’d be fine with that too

RH (continues to ""extra"" ideas slides)

JK (chat): another ""extra"" idea, that would save even more module size is if not repeating the type was also supported. I.e. some way to say ""here are 100 imports from module 'env', they all have type 'externref': [name1, name2, name3, ...]""

RH: I thought about that too, I’d be open to that. Would be useful for decoding because you can save some repeated work. Not sure how it would work for combinations of things, would we have a combinatorial explosion where we repeat the type, but not that name? Could be interesting e.g. for the JS string builtins case where they are all the same type.

CWoods (chat): Linking via ordinal value, is something that has been done in Embedded OSes - like EPOC / Symbian. Works ok, and does reduce binary size.... but maintaining inter-module alignment between versions becomes hard, as the index order can change.

JK (chat): function locals already support that, so there is precedent :-)

AR: we discussed memoryref, tableref, etc where we have to type all of them, and name them in the imports.
We could use those in the import definitions the same way we already do for function. So we could do something in a more structured manner that fits into the broader picture in the future.

RH: This is a good opportunity to leave encoding space for things we think we'll need in the future.
Should we do a full poll or unanimous consent?

TL: unanimous consent seems ok for phase 1. Are there any objections to moving this to phase 1?
(none). OK, thanks Ryan.

#### Continue discussion on spec complexity from [in-person CG meeting](https://github.com/WebAssembly/meetings/blob/main/main/2024/CG-06.md#thursday-june-6) 

PP: AR, can you quickly recap some of what you presented?

AR: Sure. (type hierarchy slide) Some of this complexity we expected, but some surprised me, e.g. this type system I discovered when working on the spectec version of the spec. Then discussing SIMD features and the random holes, DG made some points about how it came about. I didn’t mean to blame anyone but, but wanted to highlight this. How leaving things out can actually globally increase costs rather than reducing them. With storage we did a good job where we had a long term plan to fill the holes in the future.

DG (chat): Where does numtype occur in the spec?

CW (chat): https://webassembly.github.io/spec/core/syntax/types.html#number-types, although spectec might rearrange things slightly

DG (chat): Is there an example of a concept that's common to all of i32/i64/f32/f64 but no other types?

DW (chat): I think there are different ways it could be factored - are you thinking vector types could be merged with number types?

DG (chat): I'm not making a proposal here; I'm just curious about what shapes the type graph.

CW (chat): To some extent it's probably inertia from 1.0, where ""numtype"" was essentially all the value types. When we added vectors there was a choice of how to add them to the hierarchy - we could have chosen to add them at the same level, but kind of didn't - I think because they have a suite of different load/store instructions?

CW: One thing is that there's tension between being uniform across the features versus respecting the actual behavior of the chips we're trying to abstract over. To me that seems to be the main objection to f16. It's not spec complexity, it's support for chips in the near term.

DS: In the previous SIMD proposal, we held that line and only included instructions that demonstrated speedups on all architectures.

PP: one of the holes is i8 types, and there are issues with overflow there. But yeah mostly because there’s a gap in the hardware.

AR: We talked about that last time. There's a trade off between having functionality that you want, with granularity and spec simplicity. Many competing goals. Portability as well. In the past we have gravitated toward one corner of that triangle and maybe hasn’t been super balanced with the others, and sometimes there are value judgments. For me as a spec person, I definitely observe a lot of complexity with SIMD in particular that causes a lot of work for me. Again with SpecTec, making things more precise makes the irregularities more apparent. We papered over in the paper spec, but when you have to make it more formal, it comes out. Deepti made the point that this is a problem that comes up in implementations, too. Maybe if there's just one gap in the feature matrix that we can't support efficiently, maybe we should just fill it anyway and the problem might go away over time. Or in the other direction, if there are too many holes, maybe we say it's just too early to add that feature.

CW: I would err more on the side of the latter because putting ourselves at the mercy of future hardware puts us at risk in forward compatibility.

AR: I would too. Maybe being in the middle is the most unfortunate 

TL: If we wait for all underlying architecture to fill in the gaps, we might be waiting for a long time or forever. We can’t make the architecture designers fill those gaps, there’s not much evidence that they even want to. Hope is not a strategy.

CW: But even then, do we want to eagerly spec instructions that are not supported by the underlying architectures?

DS: Goes back to the question from Pittsburgh. Are we abstracting over other architectures only, or are we defining our own architecture? Are we ok with filling gaps? I agree that if we wait for the gaps to be filled below us, that's no good.

PP: If what we think is going to be added eventually might not always be what’s added. With RISC-V vector spec there was an implementation based on in-progress spec, and then the spec went and changed, and now there’s 2 incompatible versions. At the end it’s sort of a balancing act; we can’t wait until there’s no holes but if we don’t want to commit to something that would not happen in the future even though it looked possible at the moment.

CW: I would err more toward the side of stability.

AB: Some of the assumptions we’re making is that everything that exists, will continue to exist, may not be the case

AR: In the early days of Wasm, we very consciously took a conservative approach. We only added things that were common to all modern CPUs that we knew was going to be permanent for the foreseeable future. With SIMD, we left that path and started to drift to the other side.
There is always pressure for features, but sometimes it’s important not to add everything, for the good of the project

AB: Adding 128 bit SIMD, when added, isn’t what the user truly wants when the users truly wants, really they want the max vector length of what they’re working on. We tried to find a common ground but didn’t really give them the feature and it got watered down too much. Wondering if there’s another way to get at the underlying performance that’s there.

PP: Plug for flexible vectors proposal!

AB: Any kind of a new instruction that’s supported differently on different architectures. We’re limited on what we can do.

CW: It's possible that we need to think more about WebAssembly + the host environment as a tuple that people are targeting.

PP: During the relaxed SIMD, there was an idea that we had 2 possible behaviors and spec them both, and one is accelerated. The ARM style vs the x86 style, you can possibly write them in the standard and based on which one you can take that. Someone added another idea that we could maybe express hardware accelerated things in wasm, and they turn into hardware instructions, or turn them into standard wasm. Also its easier to define the behavior when they are expressible in wasm, it can be tested, etc.  i don’t have a solid proposal of how this would look like having something like this reduces the pressure to add more and more instructions.

CW: Maybe where the group has evolved that we didn't have before is the solution for stringref.

AB: What's that approach?

CW: basically a limited form of compile time imports.

TL: There's a big difference there, where with JS string builtins, we are importing something that’s already in the embedder. Doing similar things for SIMD would be tantamount to bringing back SIMD.js and importing that in wasm. Everyone was really happy not to do SIMD.js, and do it in wasm instead. So I'm not sure that’s the best direction.

AR: I don't think you can make that comparison.

PP: you can have these imports be internal to the wasm engine, as opposed to adding that to JS

BT: I think what Wasm is depends on your perspective. If you look up from the hardware you think that wasm should express what you are offering. If you're software looking down, you want an idealized abstraction over the hardware. There are multiple levels of the software that you can think of. Maybe you want it to express the exact instructions that you write, and maybe you want a higher abstraction. We are maybe moving in a direction with string ref that you’re not talking about in terms of hardware. The abstraction mechanisms let us experiment ,and maybe we decide at some point that something belongs in the core, and then we can put it in. we’ve had various priorities for doing that, for SIMD we wanted to deliver on the promise of not having SIMD.js and have it in WebAssembly.

CW: Speaking with some others about this, from our POV , im looking from more of an ecosystem POV where silicon vendors can innovate, and we still maintain portability. E.g. here’s a function, it can have a hardware version but still embedded in the binary in core wasm, you can run it either way, and there's portability. It creates space for innovation without taking up a lot of work in the standards space, but enables ways for vendors to look at how they can accelerate the bytecodes. I know we're not the only ones to run into this. But e.g. using Wasm for SSL is slow compared to native because we can’t use hardware acceleration . That's where we're trying to find alignment between ecosystems to get both portability and innovation.
 
PP: Sounds like a limited form of compiler imports.

AR: Ben mentioned that something more high level is a higher level of abstraction: abstraction is hard, designing a good one may take more iterations of trying it out in practice than some obvious instructions that map to existing hardware. So maybe that's another reason to go with this form of imports because it lets you try out more things. This isn’t similar to SIMD.js because the problem wasn’t the instruction set but because the language was so remote that wasm was a much better palace. I think this problem will come back to use, we always get asked what about GPUs? Wasm is a CPU abstraction but GPUs get more and more important. How can we enable experimentation with domain specific things before they are so established that we can put them in wasm. Maybe static imports can help us try things that are not yet widely available and might go away, maybe that can reduce the risk and also help move faster with a lower bar than with core wasm features. So now that we’ve added machinery for these imports, maybe this is a good escape hatch for domain specific hardware.

AB: Two thumbs up for an escape hatch for this kind of work. The architecture designers are also working under enormous constraints.

AR: I'm sure they do design by committee too, to some extent.

### Closure

"
main/2020/CG-03-31.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 31st video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: March 31st, 4pm-5pm UTC (March 31st, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Form a garbage collection subgroup (Andreas Rossberg),
       [proposed charter](https://github.com/WebAssembly/gc/pull/82/files)
    1. Move [custom annotations](https://github.com/WebAssembly/annotations) to Phase 3 (Andreas Rossberg)
       - also, discuss Phase 4 criteria, since this does not affect engines
    1. [Discuss: should funcref be a subtype of anyref](https://github.com/WebAssembly/reference-types/issues/69)
    1. Discuss global ref.func initializers complicating validation ([reference-types issue#76](https://github.com/WebAssembly/reference-types/issues/76))
    1. Move [bulk instructions](https://github.com/WebAssembly/bulk-memory-operations) and [reference types](https://github.com/WebAssembly/reference-types) to Phase 4 (Andreas Rossberg)
    1. Discuss [removing the maximum initial memory size restriction](https://github.com/WebAssembly/spec/issues/1116#issuecomment-602589199).
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes
### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

Conrad Watt

Arun Purushan

Deepti Gandluri

Ben Smith

Ryan Hunt

Francis McCabe

Lars Hansen 

Paolo Severini

Rick

Wouter Van Oortmerssen

Nick Fitzgerald

Dan Gohman

Derek Schuff

Mitch Moore

Zalim Bashorov

Jkummerow

Ben Smith

Keith miller

Alon Zakaii

Rich Winterton

Zhi An Ng

Nabeel Al-Shamma

Sean Jensen-Grey

Andreas Rossberg

Heejin Ahn

Sam Clegg

Adam Klein

Emanuel Zeigler

Ross Tate

Thomas Lively

JP Sugarbroad

Tatwai Chong

Yury Delendik

Alex Crichton

Ingvar Stepanyan

Thomas Trankler

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Lars Hansen seconds

### Proposals and discussions

#### Discuss [removing the maximum initial memory size restriction](https://github.com/WebAssembly/spec/issues/1116#issuecomment-602589199).

AZ: Lars asked to only allow growing about 2Gib to reduce compat issues. You wouldn't be able to start with 3 or 4 Gigs, but would have to grow to it. Seems like an arbitrary limit, would complicate testing. Lars seems to be OK with removing the limit. I'm proposing allowing up to 4Gb of memory normally. Just allow that. Some risk of compat, but user would have to request explicitly. If they ask and don't need it, it probably won't run in a lot of places anyway. Seems unlikely that user will do it unintentionally. Thoughts?

LH: FWIW, I still don't like it, but I've stopped objecting to it because I don't think it's a battle I think I can win.

AZ: Happy to talk more about it, there’s probably a risk that you see more than i do, happy to talk about it

LH: no need to talk more, we have to be done with it

JG: Should we have a protocol for allocating memory, host and wasm module can negotiate for memory. Is there a place for a protocol for this?

AZ: I don’t have a good idea for a protocol - in general if they know they need some amount of memory - the game will ask for 3G, and not work if the memory isn’t available - we start with an initial memory and grow

#### Form a garbage collection subgroup (Andreas Rossberg), [proposed charter](https://github.com/WebAssembly/gc/pull/82/files)

AR: do we have a procedure for forming a subgroup? Most people already saw the chart for the group, think it’s fine. Let’s just land that? What remains is to find a good time to meet regularly. How do other subgroups organize? Bi-weekly? Case-by-case?

DG: I think it's been organic to what a group needs. So discussing offline is best.

AR: for these meetings,we have agendas in meetings repo, but not for subgroups. Is meetings repository the right place for subgroup meetings notes and agendas?

DS: for debugging and wasi, they have their own repo, mirrors the spec repo, separate folder for notes

AR: what happens when you merge into spec repo?

DS: For debugging, for WASI too, there’s not a spec that’s not intended to be merged

AR: for gc subgroup, we have the gc proposal, might be wrong place to put meeting notes

DS: separate repo for the subgroup just to put notes, one spec fork per proposal

AR: so many repos, why not reuse the meetings repo. Do people think it’s okay?

DG: no objection

AR: You don’t get a good picture of the where the notes are, if you don’t archive them or have them somewhere centrally

DS: separating issues, subgroup related issues will end up in meetings repo, strange?

RT: We could always discuss this was meeting, and point to the meeting notes so it’s discoverable. 

FGM: structure the product of the group itself - e.g. criteria questions, design question, more than 1 piece of documentation. Think about not just during the group, what about after the group is done - how does someone know what is important, how to navigate?

DG: i will open an issue on GH repo to discuss this more

####  Move [custom annotations](https://github.com/WebAssembly/annotations) to Phase 3 (Andreas Rossberg)

AR: At the f2f we decided to move to phase 2, but we didn't want to jump phases. There's one issue, renaming @custom to @customSection, but minor thing. Wondering if we should move to phase 3, since requirements were already met at f2f meeting.

DG: Maybe just unanimous consent? Anybody object, or have concerns about proposal? [silence]

Custom annotation proposal moves to phase 3.

AR: Our process criteria talks about engines, but this is one of the first proposals that has no implications on the engines - what are the requirements for moving this to phase 4? Should we talk about tools - should more than one toolchain implement this? 

DS: think it make sense, should have 2 different code bases implement this (similar to web engine). What criteria should be analogous to “web vm”, don’t feel strongly about this criteria

AR: If Binaryen and Wabt implement it, would that be enough? 

DS: yea, would think so. They are different enough. Firefox wat format perhaps [BS mentioned this in chat].

AR: If we lanbide it in the spec, we should probably support it

LW: Browser doesn’t support it, but the shell does/should? 

RH: rust crate called wat (?), supports text format, used in shell testing, probably supports custom annotations already

AR: question for other folks in binaryen and wabt, LMK when yall implement it, so I know it’s time to move to next stage

####  Discuss [should funcref be a subtype of anyref](https://github.com/WebAssembly/reference-types/issues/69)

AR: open issue discussed at f2f meeting, number of threads + discussions between various people. We don’t have unanimous agreement, but most feel that we should move ahead with what we have. We can discuss all the details again ?! Mainly, Ross doesn’t like it.

Why To Remove Subtyping Slides [(pdf)](presentations/2020-03-31-tate-remove-subtyping.pdf) [(pptx)](presentations/2020-03-31-tate-remove-subtyping.pptx)

RT: for months, no established uses cases

AR: I would disagree w/ no existing use cases. Biggest one is that we need something like this for type imports, and for closures for func.bind. If you want to use them in the uniform representation, you'd need that.

RT: We can discuss those use cases, for func refs, every language expects equality except Haskell, but your func ref proposal doesn’t address it - good to address this ahead of time in the issue that asked for use cases, also type imports..

AR: The point is that, if you do that you put the same constraint on the type. For the type import to work, it needs the same uniform representation.

RT: This says removing subtyping, that’s one of the 6 points on here - use cases for the actual subtyping neither of those are necessary

<back to slides>

AR: The primary purpose of anyref isn't for external references. We discovered that it was a relevant use case, so we pulled it out into a separate proposal. If we thought it was for external references we wouldn't have called it anyref.

RT: Reason why everyone wants this right now, is this purpose? <AR agrees>

<back to slides>

AR: assume you are alluding to your paper, that is heavily geared towards single inheritance, class-based

RT: I worked through a number of languages, it works for OCaml, java, C#, ...

AR: If you encode everything as objects..

RT: No, ... we haven't worked through any other system to know how it will work. So if we rule this system out, we don't know if it is even applicable. If we rule it out, then we have no options.

LW: Is this about ref.null? [RT: yes] IS that the specific problem? What you want is that this would run before wasm compilation? 

RT: The way this technique works -- browsers don't do inference. The languages that use wasm do... the keyword here is practical. To eliminate casts, we need fancier types. It is much fancier than we've seen in any proposal so far. So we'd need all tools to support these fancier types.

LW: Three would be a different language? And there would be a different explicit inference step? 

RT: For this ... we took an additional C# compiler and tacked on the inference. It makes it a tack-onable library that you can add to an existing compiler.

LW: Input to inference isn’t wasm, it’s pre-wasm right? Something that’s type annotated

RT: We gave it x86 -- the point is that your compiler would need.... if there is anything that is above wasm, you'll need another language above that.

LW: That’s already the technique you’re describing, at places you would have to have done an inference type because of explicit blocks - there’s a version of wasm where you have lesser type inference, and then something that’s more complete wasm

RT: The practicality right now is that the types are simple. If we do this otherwise, we need a much more advanced system. The previous work here required 7 phds. Nobody knows how to make this work, so it would require completely new work. 

LW: That would happen before producing Wasm..

RT: You'd produce wasm without types, yes.

AR: This is definitely out of scope for what the engine will be able to handle

RT: The engine would not be doing any inference, right.

TL: I still care about practicality as a tool author, just because it’s not in the engine doesn’t mean we shouldn’t talk about it..

RT: The idea would be... you can write your tools without types, then the tools create types, and the engine can use those types.

JP: Can you help us understand what the cost is to eliminating the subtype - we have a discussion to include it or not? Why can’t we include it later? That doesn’t seem to be an option

RT: That certainly is an option. We can add it later. The problem is that there is code implemented there that uses it.

AR: I can quantify how big a change that is - it’s not exactly time, has implications on other design aspects - for the repo the diff is 600+ lines included tests. That was a change to remove the subtyping - that’s absolutely minimum change - just for removing - if it’s for the whole proposal it’ll be 100s of lines - what’s worse is the impact of this on other proposals which is poorly understood. 

RT: I'm removing subtyping from the current proposal because it's the wrong subtyping.

AR: We’re back to the discussion in the same two months - because the next proposal also has subtyping - like Func refs. You can’t get rid of that then other things will break, or you can’t explain the things

JP: Nobody is proposing banning subtyping...

RT: I’m not.. 

AR: You probably have some different notion of subtyping in mind that would require us to redo our proposals. I'm not sure how long it will take, or what the benefit would be. It feels like a very fundamental and late change in the process. We will need to re-evaluate everything downstream. Doing it now seems like a very bad idea. The other question is what is the benefit -- you brought up a few points, but I'm not sure I agree with them.

AR: You want different representations, for type imports, you don’t want to commit to what type of representations are behind that.. That’s the same case for Anyref too...

JP: In the GH issue, it was proposed that instead of funcref and anyref, you can have boxing and unboxing operators. An explicit cast to have the underlying embedder to compile different representations.

AR: Because then you have to allocate all over the place, it would work, for example you can’t use a closure - you have to box/unbox 

JP: You don't have to box and unbox, you have the option to do so. Your implementation could have it as a no-op.

AR: If you’re only talking about the host, you can do type imports from other wasm modules...

JP: But even if you type-import from other modules, then the thing compiling the code could use compatible representations, then they can use it with a no-op. If we find that all of the implementations use the same reps then we could add the subtyping later.

AR: You have to add the coersions to the language, and every language that uses these will have to add them...

RT: Currently I haven't seen a plan that shows how to compile a language to this road-map. I haven't seen this at all.

AR: There are parts of the roadmap that are clear, and the rest that are unclear.. Parts with GC are less clear

RT: You said that functional languages will use funcrefs for their closures, but they require equality so they can't use that.

AR: Minor detail, that’s not true

RT: OK, but many many languages can't do that.

AR: We left out equality of func refs..

<OVerlapping discussion> 

AR: When you have type imports you want to be able to import something without knowing what it is. What do you base the restrictions on? If you don't know what people want to import as types, then you should not impose restrictions there. We don't want to impose restrictions prematurely.

RT: What restrictions are we imposing prematurely? 

AR: If you say that certain types can't be used as a type import th

JP: We are talking about certain types being explicitly blocked, at the same time there are restrictions on both sides

RT: Many languages can have the assumption… same bitwidth that’s really all you need

AR: IF you need something changeable, you need these to be interchangeable - you may need to differentiate in code whether this is tagged or not

RT: You're talking about GC and cross ... you need a bit-width and a convention about how to collect that value. It still doesn't need uniform representation. There are descriptor modes, ...

AR: Descriptors makes everything more complicated. There doesn't have to be any magic that is passed under the hood... [RT: I didn't say that] You need to pass the descriptor, then you're in reified generics territory.

RT: Import/export doesn’t need... 

AR: Useful to have subtyping against the bound, ...

JP: Another question, w.r..t coercion. the host that has to typecheck. In the face of subtyping, it needs to know where the subtyping is required, why can't it insert the coercions implicitly?

RT: Right now, in the code we’re talking with you could do that - the problem is when you use it recursively in a signature you have covariance and contravariance w.r.t. The signatures - there there’s no coercion going on there (Explains with an example) Where you wan subtyping is where you want covariance and contravariance. 

JP: This subtyping relation makes call complicated in the face of different representations, is that what you're saying?

AR: It makes things simpler as long as you use a uniform representation. All engines do this already. There are very few runtimes that use non-uniform reps currently. You argue that we can add this later -- but that cuts both ways, we could add raw type later too. If you have that type, we need the boxed type later anyway. We can't box and unbox anywhere, we need a type for that too. We need to double the type algebra already.



JP: If they don’t need to be compatible with anyref, they don’t have to box the types - the embedder can augment the types - we’ve talked about being able to represent 

AR: In a way this boils down to having two different types of function types, which one should we do first. I'm saying we should have boxed ones. I don't see a practical world where we only have unboxed ones.

JP: The proposal is creating a two funcrefs, one that is a subtype of anyref and another is not. 

DG: have an off-cadence meeting to discuss just this and make a decision there

JP: I would like to see on a straw poll basis to see if we have any consensus here.

LW: I think we could have maximally conservative position, to not commit to either perspective. But 5 months from now we can determine whether it is appropriate to do so.

AR: IT’s not conservative, you actually have to use subtyping or change the design

LW: It’s in a way that doesn’t change, just adds some waste

RT: most of the burden is on the spec, comment out code and return is_equals

HA: toolchain changes required too

AR: I think the minimal thing is not currently tiny... it may require 1000 lines in the spec.

JS: sounds like - carve off a piece of this, funref subtype, into downstream proposal, unblock ability to have external ref types

AR: I understand that, but it's not a small change to the proposal. It affects other proposals with unclear changes.

JS: we can discuss this in the next proposal

AR: we have to change existing proposals to take this out.

JS: We can defer those downstream changes until... 

AR: have to change instruction sets

DG: let’s stop this, will file and issue to find a timing that works, set up a diff meeting just to talk about subtyping, outside of this CG

AR: doubt we can make any more progress than we have today, or over past period

DG: let’s give it a try, does it make sense to do a poll for bulk memory proposal

AR: nope, doesn’t make sense, bulk memory proposal depends on this subtyping decision, so we cannot advance that

DG: I will find another time for the next meeting. We're exactly at time, going to cut it off now.

### Closure
"
threads/2024/THREADS-03-05.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 5, 2024 video call of WebAssembly's Threads Subgroup

- **Where**: zoom.us
- **When**: March 5, 2024, 5pm-6pm UTC (March 5, 2024, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/mUp4nmiVUTNQDKcD9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Typing shared-suspendable and shared-fixed functions ([#44])
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Andrew Brown
- Nick Fitzgerald
- Manos Koukoutos
- Ryan Hunt
- Sulekha Kulkarni
- Conrad Watt
- Ilya Rezvov
- Zalim Bashorov
- Jakob Kummerow
- Ashley Nelson
- Alex Crichton
- Shu-yo Guo
- Luke Wagner

[#46]: https://github.com/WebAssembly/shared-everything-threads/issues/46
[#44]: https://github.com/WebAssembly/shared-everything-threads/issues/44

### Typing shared-suspendable and shared-fixed functions ([#44])

CW: feeling optimistic about [#46]; everyone seemed to agree on a variant of context-locals.

TL: Tied to context locals, right?

CW: Yes, main concern is it requires a more ambitious design for the function return type.

TL: Still has separate types for shared suspenable.

CW: With the latest variation we should avoid that.

TL: avoiding by only doing shared-suspendable?

CW: Yes, you can have just shared suspendable but you can have non-shared elements, accessed in the barrier block. Change the semantics of non-shared locals to avoid capturing? Currying?

RH: storing things on the VM context–we need an implementation limit. With many functions we may need boxing. Did this require the shared-barriers instruction?

CW: If you want to box them, you’ll need the more general barrier instruction which is fine. One motivation for the fused call instruction is I would expect inlining to be easier if you’re doing speculative evaluation on the shape of the context locals.

RH: random thing–is there an expectation that engines would inline thread-local functions?

CW: Some of the V8 people they feel that is a pretty important requirement.

JK: Concrete example is string.toLowerCase(). When we see it as a string, we can fast-path it and create it to an intrinsic, at the very least reduce call overhead instead of going through javascript. When we built it, was an important optimization, it would be a shame to lose that because of Shared Everything.

RH: V8 would see that a TL function was imported and each thread would need to check that each import was the same one?

JK: need a guarantee that all threads interacting with this module has the same import or provide the same value for the shared global or whatever.

CW: every context change requires a speculative guard–at each JS to Wasm crossing or at some other bind point (like the bind function suggested). Works best with the fused instruction; all calls to that variable can be inlined then.

TL: Can you explain fused?

JK: what I described does not require guards; the check is at instantiation

CW: Yes but these are two different techniques, you’re describing inlining static calls, i would expect it to not work with call ref, right?

JK: True, won’t work for call_ref

RH: In the case where you are instantiating something and you receive a thread local function, you only instantiate it once and you only know provisional threads local value, all the threads will eventually buy into that thread local function. So when you emit the code, you need to have a guard that the thread bound on this thread is the built-in you expect it to be. So I think you will still need the call site guard after that to do the lookup?

JK: (thumbs up)

CW: can get away without a call-site guard if you have a context switch guard; if you eagerly know then you can do this at the context switch. The context-local design makes it easier to do this optimization.

RH: On the topic of context locals, I didn’t fully understand the outcome: what are the concerns with the two types? Is it engine complexity? Type system complexity?

CW: It’s feasible but there is a lot of complexity in the design and ecosystem. You’d forever have this fragmentation of different worlds that you need to take care to move between. There is always going to be one direction that is hard, so we need to stack what does that look like? Toolchain needs to work with these forever. Feasible, but if we avoid it, we avoid complexity that might be unnecessary.

TL: More detail from toolchain side: if the goal is with shared continuations in a toolchains we want to do work stealing AND have shared functions with unshared parameters, the problem is we want indirect calls to work between these two kinds of functions. We should only need the signature, but with this division (shared-fixed (SF) vs shared-suspendable (SS)) we can no longer do this indirect call between the different types. E.g.: vtables, function pointers, closures, any indirect call will run into the split type problem. Toolchain could just give up–choose one or the other–don’t like this. Another solution is to convert from one to the other, likely SS to SF–a wrapper function with a shared barrier. If all you have is a function pointer, then you need some kind of func.bind before doing the barrier, etc. That would be even more complexity; these conversions are pretty unsatisfying, even if possible. Strongly prefer one shared type, even with SS and SF semantics.

RH: You were talking about having a program that has some SF and some SS. My thought, originally, was SF would be useful for cases where you need to call JS, interop points, and need to go into the local world. My hope was that those could be the leaf points of the call stack. If you compile, all your functions would be SS, in the indirect case. But web api, those would go through a suspendable wrapper that does a barrier, or just a barrier that would do the call itself. My goal is that it would not be arbitrary. The ABI would be that languages are all SS and when you need to call out, you make the switch.

CW: The designs we’ve discussed can’t cover that; need the JS function as a parameter, calling SF we don’t have that parameter in the first place.

TL: Assuming we don’t have a way to import thread-bound functions as SF.

CW: In that case we don’t need SF because they can be called from SS.

TL: You still might want SF to pass unshared params around. Maybe that would be easier to get away with, but there is a reasonable world where we want SF anyway.

CW: that’s not a world where we call from SS to SF; there are always some use cases. Need a reasonable semantics without that division, that would be preferable.

TL: RH, your Q would this just be on the boundary? I agree. The use case for SF is on or near the boundary where we’d pass these JS references around. Toolchains, thinking about Emscripten, do not differentiate between functions that are or or aren’t in the boundary. I can declare a function in the header, implemented in JS, so a boundary function, but I can still take its address and make an indirect call to it. Yes it’s on the boundary, but I still think we need to support indirect calls.

RH: On CW’s point with SF, even if they are the leaf, we need to get the shared parameters to them–need the context locals to smuggle them down to the leaf.

CW: That is the design that would require clearing the variables when you suspend, right?

RH: Or the thing you mentioned where the context variables are inherited where with whatever you resume with.

CW: I’d hope if that works SF gives you little as a separate type; hopefully we don’t need a new type.

RH: Interesting, the tricky part is that you need locals and if the type is fixed, then you could have unshared locals. And if you just have that barrier, it gets difficult. We ruled out let which rules out dynamic locals in a shared context. I guess you could just use the value stack. But I believe with let, this is tricky for toolchains to use.

CW: Interesting point; I’ll think about that more. My feeling is that it is ugliness that we could solve some other way, but I see the value.

TL: Because the locals are useful to have SF and SS functions, it’s very plausible we want both. They would be differentiated in their declaration so SF can have unshared locals, but my point is with a single type, once I have a reference to that function, I shouldn’t be able to differentiate. The declarations can be different, it’s the references to the functions that should have the same type.

CW: Maybe that’s possible–need to think through that in more detail.

RH: One other thing I mentioned in the issue, the question of the ordering: which one calls which? Which one needs a barrier? CW had mentioned that SS could call SF to go back down we need a dynamic check. SS could be a subtype of SF and choose SF as the type for all function references. One difficulty: if your function is SS and you do a call ref to a SF, we would need a barrier. 

CW: I think all calls end up needing the barrier if you don’t know whether the ref is SS or SF

CW: How complicated are the calls into JS? How much do we lean on locals?

TL: Need locals all the time: compilers only differentiate between locals and stack values very late. A dumb algorithm at the very end–the majority of the compiler does not differentiate them. It would force more of the compiler to understand the difference.

CW: Then we need to take this seriously as a design constraint.

RH: In the case of the current design (thread-local functions), call `new WebAssembly.Function` my sketch would be to generate a trampoline that either calls or traps if not bound. Every call would have to go through one of these wrappers. If you squint, it’s similar to SS and SF: engines have to implement a shared barrier anyway for TL functions and have a shared continuation capture local state. If you have context locals and shared barriers you could probably emulate what TL is doing.

CW: The problem is the same if we’re talking about…

RH: Thread-local allows a call stack that interleaves local/shared and requires an engine barrier already.

CW: It would not be ok for a…

TL: Right. TL functions would not be able to return non-shared references. For JS, we have toWebAssemblyValue() that is a builtin conversion that will trap if it can’t be represented as shared.

CW: If we think that TL world is ok, then I think the world with context locals is ok, even with just SS, by analogy. In both cases they take shared things and scalars; if not the case, then we need to address SF.

SYG: Q about stack switching, the SS thing is to support the ability to suspend a stack on one thread and resume it from another thread, is that the use case?

CW: Yes and wouldn’t be safe if you have a shared externref of a JS function on a stack, wouldn’t be ...

SYG: is there analogy here to the TLS story: there’s a TL cell and the thread-bound storage only accessible by its bound thread. You can suspend anything but if you capture a local value you bind it to the thread that captured the values?

CW: Can’t–need static annotations everywhere

SYG: Does that need to reflect in the type system?

CW: Need to know statically whether you have a shared or non-shared suspension

SYG: At the point of execution could you just keep a bit? If it’s not a use case then this doesn’t matter.

CW: I believe if you keep the bit you are forced into SS and SF as static annotations.

SYG: Have you thought about restricting the threads on which a continuation may resume?

CW: Interesting idea but how does that gives us an out to the problem? If a continuation is classified as shared so long as there’s one other thread it can be resumed in, seems as bad as the general case

SYG: It makes it a dynamic issue: if the app calls fetch on your stack…. Punts the problem to the application.

TL: An interesting idea… It's like thread-bound continuations that are typed as shared, but trap if you try to resume them on anything but the owning thread. Just like our idea for thread-bound data, which is typed as shared but traps if you try to resume it.

SYG: It is data at that point–maybe extend the thread-bound concept to continuations. Not too familiar with that proposal…

CW: In JS we may have thread-bound things, I expect that to be a shared thing in Wasm. When we suspend and capture a continuation we believe we know whether it’s shared/unshared

RH: How is a runtime check like this implemented? Don’t have a good idea of acceptable costs in stack switching proposal; dynamic checks might have to search through many stacks, suboptimally.

CW: A cost per call stack is acceptable if it is “check a bit” per call but not “walking all the elements of the call stack.”

IR: Right now it is a constant operation; in the future it will be constant as well. You always know where to switch because you know where it came from.

RH: If you search for call frames we would have to maintain that?

CW: Getting into delimited (Andreas) vs non-delimited (Ilya) debate; depending on which one is preferable the costs are different. The hope in delimited is constant per call frame; no scanning.

SYG: My intuition is that it would be more expensive than a bit. You probably need to keep a count of local things pushed and popped. Propagate that count forward on calls. Then check the count when suspending.

CW: in the case where you’re producing a shared or non-shared continuation you just prohibit non-shared continuations from showing up in a shared stack anywhere in the function

TL: when you leave a barrier, need to know how many are stacked up

CW: depends on the strategy for implementing the handler, block structure vs pushing into call sites

LW: missing a constraint: pass unshared stuff into shared and then pluck out an unshared funcref or callref and pass it unshared stuff plucked from the context, seems like there should be some scoped control flow instruction which validation prevents from calling shared–this forces us to be a leaf. Why is that not sufficient?

CW: unshared locals

LW: gets into “let” and all that;...

CW: this is exactly “let;” do we want to reopen that discussion?

LW: it was complicated because it got conflated with other issues…

CW: there was an engine concern that you’d need to dynamically resize the number of locals

LW: don’t know the max local depth up front? Let’s say we solve that; wouldn’t that solve this problem?

CW: In our existing design, we assume parameters are only scalars or other shared things; we can get pretty far with that.

LW: When we call to JS we need an unshared funcref

CW: Still need a shared barrier but don’t need additional locals/let

LW: …

CW: …

LW: Maybe there's an externref that’s unshared, assembling a call stack; a very specific, leaf case. A constrained situation.

CW: This is about interacting with JS from a shared context

SYG: How can we control that the JS doesn’t call back into a shared Wasm?

CW: Suspension barrier… <TODO> Where do we get the unshared externref from in the first place? If we get it from the context, we don’t need locals for that.

LW: If it’s just brute-force currying, maybe that’s sufficient.

CW: Shared barrier protects the <TODO>

TL: Shared barrier is fine. This conversation assumes we have a context we can attach an unshared thing to; not bought into that yet. Prefer thread-local globals but its another form of the same thing. “Let” is problematic.

CW: Can you work with just scalars and shared things as parameters?

TL: If we can pass things but not use them as locals–that sounds very risky.

CW: Our choices: no non-shared locals, or SS + SF, or make “let” work

RH: Another choice: function definition that implicitly has a shared barrier; that function can have locals there.

TL: That’s what I thought SF should be.

CW: I was worried that we start with SF; if we add SS and SF at the same time, maybe that’s more OK. If SF is just a barrier with locals.

TL: In toolchains, only at the very end “do we have non-shared things in this function?” then make it SF

CW: you might end up with type errors if you have a suspension inside

TL: Allow it to validate but trap.

CW: Need to think more about it.

LW: There do seem to be some good options. I like CW’s first proposal. Any strong arguments against?

RH: If you have different modules with different contexts you either have ABI problems or context switches at each boundary. Hash-table lookup for generic contexts.

TL: An ABI break: downcasts, lookups, etc. At that point we should have just put the context in the engine.

CW: Mismatched contexts? Two modules compiled separately that you try to fit them together later?

LW: Or they all follow the same ABI because they use the same toolchain.

TL: A generic ABI means some kind of downcast or lookup to recover the specific context information. Might as well put that overhead in the engine and keep the language simpler and avoid an ABI break.

RH: Performance question: no worse than doing thread-local lookups (some concerns with that)... a longer topic. We are calling into JS after all.

CW: The difference is that with thread-local functions you’re using strings, but with the context you have a dense array, so harder to just work with subsets of it

TL: TL functions can be imported as shared; no need to pass around an imported context.

"
wasi/2023/WASI-10-19.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: October 19 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: October 19, 16:00-17:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Discussion for reframing WASI to stand for ""WebAssembly Standard Interfaces"" (Luke Wagner, 15min)
    1. WasmEdge and WASI Preview 2 (Michael Yuan, 10min)
    1. Sharing feedback and status of Preview 2 ship plan (Pat Hickey, 10min)

    ## Notes
### Attendees
Dan Gohman
Bailey Hayes
Pat Hickey
Jeff Charles
Warre Dujardin
Colin Murphy
Ayako Akasaka
Andrew Brown
Saul Cabrera
Joel Dice
Ivan Font
Timmy Silesmo
Michael Yuan
Matthew Yacobucci
Wouter Hennen
Kyle Brown
Warre Dujardin
Zalim Bashorov
Chris Woods



#### Discussion for reframing WASI to stand for ""WebAssembly Standard Interfaces""

**Luke Wagner**: As a history, Oscar Spencer (Grain PL) in wasm i/o in barcelona last year, suggested to rename WASI to WebAssembly Standard Interfaces. The whole goal of these interfaces is that they are independent of the system and can be implemented virtually. The other part is that interfaces are plural, there are all of these possible interfaces to use, but people panic because thats a lot to implement themselves, we need them to understand that through virtualisation that isnt true, they only need to implement the small world they need.

I’m proposing this now, and we can collect feedback and then vote on it next meeting.

**Bailey** Is there a github issue for this?

**Luke** I will file one


**Bailey**: Personally I am in favor, and I’ve been using it in my presentations ever since I heard it

**Andrew Brown** I wonder if other people making interfaces will feel slighted because now theirs aren't the standard ones?

**Bailey** I’ve been calling them modular interfaces, we’re bootstrapping the ecosystem by making these foundational interfaces but we expect many ecosystems to build their own interfaces in the component model that don’t need to become part of WASI if it doesn’t serve their needs.

**Luke** It's also a problem with “system interfaces” - what, am I not the system if I’m not in WASI? 

**Kyle** (in chat) I like to think of it sort of like a standard library where we're creating some types to bootstrap the common cases and so that two people solving the same common problem are ideally using the same interface


#### WasmEdge and WASI Preview 2

**Michael Yuan**: Thanks Luke for inviting me here. I didn’t have time to prepare a comprehensive talk about our plans but I’ll give a quick introduction to our plans to implement preview 2.

https://github.com/WasmEdge/WasmEdge/issues/2939

**Michael Yuan**: WasmEdge is a CNCF project building a Wasm runtime from the ground up for the server side. We chose C++ to build it because there were two leading Rust based engines already, and we saw value in an independent implementation in a different technology stack to provide more diversity in the ecosystem. There is very little code that is shared at a fundamental level between our runtime and others.
Our goal was to implement WASI from the beginning. We have two WASI implementations: one is integrated into our standalone runtime, and the other is made available as a plugin through our rust sdk, for rust host applications. When people start using WASM embedded in Rust host applications they have specific needs and its easier for the WASI implementation there to be written in Rust to work with their programs.

**Michael Yuan**: Our implementation has supported asynchronous sockets as well, so that a single WASM instance can make many network connections. That implementation of ours is nonstandard and we were looking for ways to get that into a standard. So it looks like Preview 2 provides that.

**Michael Yuan**: We have a Preview2 tracking issue, describing all of the preview 2 proposals we are planning to implement. Most of these already have an engineer assigned to them.

**Michael Yuan**: Our goal with Wasi IO and Sockets is to keep our existing applications working. Our users dont care how the low level implementation details of the sockets implementation work, they just want our Rust SDK and JS SDK to keep working the same when we switch the underlying code to be WASI Sockets. So, our difficult work there is to keep those existing applications working as we switch to WASI Preview 2.

**Michael Yuan**: One part we need help with is the filesystem proposal. For WASI preview 1 we have a solid implementation for linux and mac, and for windows with WSL, but in our community we dont have any true Windows expertise. We have had complaints about our Windows support, and we want our engine to work well on a native Windows system as well. It seems like the Windows filesystem is pretty different than the others, so that is one place where we have various bugs. We want some help from the community with those.

**Michael Yuan**: All of the plans in this tracking issue are about our C++ implementation. We haven’t decided what to do with our host Rust SDK yet. We may be able to borrow code from Wasmtime there, because they have done it. We reuse work that Wasmtime has done for the Rust host side of our SDK, such as fibers.

**Michael Yuan**: We saw that WASI-NN is also working on Preview 2. We are collaborating on WASI-NN and care a lot about it, because there are a lot of use cases. Wasi-NN isnt the low level system interface but it talks to high level functions implemented on the host. We want to work on more backends there to get support for new models and new ways… (notetaker lost track)... When WASI-NN makes it into preview 2 we will definitely support that, and we want to be at the forefront of working on the WASI-NN spec.

**Michael Yuan**: We hope to be in the first 3 runtimes to implement Preview 2, maybe even in the first 2. Our goal is to be a standard compliant runtime.

**Bailey**: Can you share where your implementation of the component model is underway?

**Michael Yuan**: (https://github.com/WasmEdge/WasmEdge/issues/2943) Here is our tracking issue, we are doing a release at the end of this month with a lot of internal refactoring and support for function references, and GC. So in our next release it will bring WasmEdge up to speed for the prerequisite proposals, and then we will have an easier time making progress there. So here is our tracking issue, I know its not as detailed yet, but we are committed to supporting it.

**Luke**: Thank you, its very exciting to see another independent implementation, thats what makes these standards work.

**Bailey**: Wasmedge could really be one of the second implementations required for some of these proposals so we are excited about that.

**Michael Yuan**: One thing that is really valuable is a standard test suite. We have been getting issues filed by users who compare our implementation to Wasmtime, where we may have a different result. When we look into those issues, its often someplace that the spec isnt clear. So, we would like a test suite to help call ourselves compliant.

**Luke**: On test suites, we have work ongoing and plans to improve it a bunch in the coming months. At the component model level, folks from northeastern are working on a Ocaml reference interpreter (based on the wasm reference interpreter). So that will become WAST spec tests at the component model level. Another great idea from Till is to use the Web Platform HTTP tests that run as JS, componentize them, run them on WASI HTTP, and even use jco transpile to run it in the browser in its original test harness, or use a custom test harness to run it outside the browser to test host implementations. 

**Luke**: OCaml https://github.com/WebAssembly/component-model/pull/192 (More work has happened since the, but not yet updated in the PR)

**Andrew Brown**: Checkout https://github.com/WebAssembly/wasi-testsuite

**Till**: Web Platform Tests is used to test Fastly’s JS Compute@Edge runtime. I’m working on porting that runtime over to WASI-HTTP and we can then use that same test suite to test wasmtime, and we expect that test runner can be generalized to run with wasmedge as well. Web Platform Tests is the most comprehensive test suite we know about for HTTP, and because its whats used by browsers it tests the actual Web as it exists.

**Michael Yuan**: Our Sockets implementation for async sockets has all kinds of issues around DNS behavior, how to interact with TLS libraries, whole host of issues. A comprehensive set of networking tests will really help us here.

**Colin**: That test suite doesnt have Preview 2 in it, does it?

**Til**l: The web platform tests isnt a WASI test suite as such, we will just make it one. WPT is a giant suite of shared tests that all the big browser vendors contribute to and run against their engines. Wpt.fyi is a dashboard of all the browsers and who passes what tests. We can reuse the tests that make sense for WASI, written in JavaScript use the Fetch implementation, and run those in a JS runtime that runs inside a Component Model runtime we can use that to exercise the WASI HTTP implementation. It tests the fetch implementation in terms of WASI-HTTP instead of WASI-HTTP directly, but it tells us we can implement a spec-compliant fetch in terms of WASI-HTTP. I’m working on the changes to the JS Fetch implementation that uses Fastly’s Compute@Edge API and make it work in terms of WASI-HTTP instead.

**Andrew Brown**: Shout out to the [WASI Testsuite repo](https://github.com/WebAssembly/wasi-testsuite), Marcen has done the most work in there, the filesystem tests have found differences between different engines which is valuable. It is focused on Preview 1 right now, but we can improve it to deal with component model tests as well.

**Michael Yuan**: I will report back when we make more progress on our Preview 2 implementation.

#### Sharing feedback and status of Preview 2 ship plan

**Pat Hickey**: It wasn’t two weeks ago, but it was four weeks ago that I presented a plan for shipping Preview 2. I got feedback it was great. The earlier you give feedback, the better and more we can do about it. Please continue giving that feedback, you can contact me directly, or you can make an agenda item to deliver feedback to the group in one of these WASI meetings.

**Pat Hickey**: A couple of points from that feedback. Last week we talked about two implementations for the portability criteria in the phase process. There is a third implementation that is just an implementation of the wasi-http proxy world. The entire HTTP layer is written specifically for Fastly’s compute@edge edge daemon. It has a set of requirements that is more stringent than even wasmtime. This is for multitenant and managing backends in a fastly-specific way. Unfortunately this is closed source so we won’t be able to share it in the way that we can share the other implementations with JCO and wasmtime. 

**Pat Hickey**: At some point it will ship to production but it has not shipped yet. Adam Foltzer is the lead on that project, he has given very valuable feedback on the wasi-http spec, and has been raising issues as we implement this spec together.

**Pat Hickey**: I’d like to give an update on wasmtime. Wasmtime 14 is shipping tomorrow and has a lot of new changes for HTTP and also lands resources support. Dan Gohman updated all of the WASI spec repos to use resources instead of u32’s (pseudo-resources). We had to shake out a lot of tooling issues. So wasmtime is shipping with that.

**Pat Hickey**: With wasmtime 15, we will be shipping with release candidates of the WASI Specs. We haven’t cut release candidates yet because the specs were still changing too rapidly. Alex Crichton has been working on getting versioning support through all of the tools so that we can pin to versions by wasmtime 15.

**Pat Hickey**: This means with wasmtime 15 will be able to say we aren’t using wasmtime’s flavor of the specs but the upstream WebAssembly WASI specs, at a particular version.

**Pat Hickey**: Yosh and Wassim from Microsoft have started working on the JCO runtime, bringing the team from 1 engineer to 3. We appreciate their leadership, they are new fresh eyes looking at these specs for the first time. They are both experts in JS and so this adds to the diverse set of expertise implementing these specs.

**Pat Hickey**: Release cadence is something a lot of folks have asked for. Certainly a consensus of the group is that 4 years is too long. This is essentially because we needed to invent the component model. We are never going to make that big of a change again in WASI. This level of big change will be behind us once we ship Preview 2.

**Pat Hickey**: We would like to build consensus to release a WASI preview every year. Historically, we have said async will ship in preview 3, but that may take more time to implement than a year, we can't be sure. So we would like to scope preview 3 to be a year after preview 2 incorporating whatever new features and proposals are done and stable. Stability defined by this consensus-driven process across the many vendors participating in this subgroup.

**Pat Hickey**: The other thing we can do after shipping preview 2 is ship patch releases for individual proposals, as 0.2.1 or 0.2.n+. Additive changes can be made as incremental updates to the current preview. We are not going to try to make super big leaps like changing the ways filesystemswork or something like that - not changes that will divide the ecosystem. The goal is to be able to extend the preview without making breaking changes and reserve breaking changes for the 0.n or Preview level changes.

**Pat Hickey**: One example of work we are setting aside for a patch release, Dan Gohman has done a great deal of work specifying how filesystem permissions might work. But we don't have an implementation done in time for Preview 2. If we can find a way to that as an extension in a 0.2.n, then that would be ideal, it can be shipped without making a breaking change, just new APIs you can opt into using and supporting.

**Pat Hickey**: Doing a preview every year, that makes it so that it is possible to make breaking changes every year so that we have a window to do that so that we are not stuck with major problems for a long time.

**Petr Penzin**: I think the issue is JCO being an implementation is the issue. I think the main concern that I have in using JCO as an implementation is that it’s not a runtime. It doesn’t manage the state of the module in the runtime. There is a difference between managing the state yourself vs providing wrappers around it. Wasm2c even though it is not a web engine, it does manage the state itself. That’s the concern. Somebody said before in the core standard that I’m in the minority on this.

**Pat Hickey**: We’re going to invite the JCO team to come in and present on their work so that they can give more details on this.

**Dan Gohman**: Not just JCO but it’s a combined thing with Node.

**Luke Wagner**: A lot of these WASI implementations it’s calling into another system. It’s not about implementing this thing totally from scratch but be able to meaningfully interact with mac, windows, and linux. So with the sockets, we want to map to the implementations that you want to talk to. Really what JCO is doing is getting from WASI to an existing implementation.

There is also a third, closed source, implementation with wasi HTTP but is distinct from the upstream.

**Petr Penzin**: My concern is that if you take an engine about taking wasmtime and then building a wrapper around wasmtime. I totally understand your argument that you still have the complexity to implement the full spec. In the same ways we think about it, in the web we want web engines. When you implement something in the browser it takes a lot more effort to tie into the browser it’s much more complex. Many things can come your way and usually browsers take more so sets a higher barrier of entry. We’re setting a lower barrier of entry where we’re setting a precedent for allowing wrappers.

**Luke Wagner**: I think you’re right about setting a high-bar before standards. In this case we’re talking about a preview. We’re putting this out there to get feedback. Our relatively lower bar is indicative of a preview stage proposal. This is to get us to a place to where we can advance to the next stage of the standardization process.

**Petr Penzin**: Then yeah, let’s defer this a little further until we get more people.

**Kyle Brown**: It's not like we're counting the browser or node twice. So Wasmtime vs. JCO+browser is two fully independent implementations which address the full complexity of modules and components. That's what we're going for if I'm not mistaken and I don't think it being ""easier"" than other options should hurt the argument.

#### Backtrace API 

**Andrew Brown**: I was troubleshooting, doing some printf style debugging. I realized I needed a backtrace. In this case I couldn’t trap which is how I usually get a backtrace. I talked to Nick about it and we realized that adding an API for this would be helpful. This would let us get a backtrace at anytime. I created a zulip thread for this. If we could and you’re interested, then please chime in. Before I do more work on this, I want to know if this would be generally more useful for others. When you need it, you really need it. https://bytecodealliance.zulipchat.com/#narrow/stream/219900-wasi/topic/new.20backtrace.20API.3F

"
stack/2020/SG-10-19.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 19th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**: October 19th, 16:00-17:00 UTC (October 19th, 9am-10am Pacific Daylight Time)
- **Location**: https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09

## Participants

Francis McCabe
Luke Imhoff
Thomas Lively
Paul Schoenfelder
Zalim Bashorov
Zhi An Ng
Ross Tate
Andreas Rossberg
Daniel Hillerström
Sam Lindley
Alon Zakai
Heejin Ahn
Asumu Takikawa
Derek Schuff

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. [Challenges in implementing Erlang processing in WASM]() (Paul Schoenfelder) [35 mins]
   1. Call for presentations [3 mins].
1. Closure

## Meeting Notes

### Adoption of the agenda

### Discussion:

Presentation by Paul Schoenfelder

Erlang has an actor model.  Everything happens in an actor.  It is its unit of concurrency.  Strongly typed, but dynamically typed.  Kinda pure functional, but does support side-effects.  Variables are immutable.  Usually do mutation by communicating with actors.

A brief overview of terminology: functions in modules, modules in applications, applications in a system.  System is what you deploy.

Actors in Erlang are built on these core primitives: spawn them, exit them, send/receive between them, and link/monitor between them.  Link/monitor allow supervision.  This is important because supervision allows to construct key like structure with root that spawns processes.  By subscribing to those failures, problems can be constrained to a subcomponent of the tree.

In Erlang when you exit and restart a process, you can feed in the same state and start from a clean slate.

[Showing slide 5]

THis is a simple module with a process.  Passing in a function capture.  The `!` is how  you send a process.  The `Pid` is a process identifier.  `self()` is a process’s own Pid that can be sent in a message.

A lower case word like `ping` is an atom, like a string.

[Pointing at `loop`] This function will be run in a new process.  The `receive` loop` is matching on messages to the process.  

Anything uppercase is a variable in Erlang (`Parent`). 

It is matching on a message and sending back to the `Parent` process.  The receive is a blocking operation.

After one 1 second (these values are in milliseconds [points at 1000]).

`throw` is more used for non-local control flow, not exception handling.  There are 3 kinds of exceptions: `exit`, `error`, and `throw`

[Slide 6]

Unit of concurrency is actor, called a process.  Process in Erlang are green threads.  Thereis no `yield` statement in Erlang. There are more processes scheduled on fewer operating system thread.  Pre-emptive scheduling.  Scheduling is done by counting reductions.  When the process exceeds a count, the process is switched.

In Erlang each process has a heap/stack and each is garbage collected independently.  No stop-the-world GC.  If the memory is fixed for a process it is more like region-based GC.

[Slide 7]

The BEAM is a register based virtual machine.  The BEAM Is the reference implementation for Erlang.  It produced BEAM bytecode ahead of time.  At runtime the VM loads the byte code and does some optimizations.

One of the key features of the BEAM, it supports hot code reloading: hot upgrades and downgrades.  It is neat how it does it, but puts limitations on optimizations.

[Slide 8]

How it ties into WASM.  Can we bring BEAM to WASM?  A lot cannot be ported directly because of implementation techniques.  Even if you can port the VM itself, the cost to support hot up/downgrade and fully dynamic functional calls, means not optimizations and have to ship all modules.

TL:  Would be ok if yu had a tool to push up the initial version of the code and if you had hotcode pushing it up later.

PS: it would probably be possible to rework the BEAM code loader to fetch those resources on demand. Right now it assumes access on  local filesystem. Don’t think there’s a reason why it couldn’t be refactored to support something different. That’s part of the rewrite that would need to happen within BEAM to support Wasm. Possible that may happen, also wonder that is attacking the wrong issue. If you can’t strip dead code, you have to load it dynamically, you don’t know what you don’t have. This also happens (depending on system), call function, runtime notices function code isn’t present, attempts to load it.

FM: elaborate on how much bytecode we’re talking about? Whether this is part of std lib or application?

PS: minimum size of installation sits around 25MB of bytecode. Not counting VM itself. One of the libraries that I maintain, written in elixir( generates BEAM bytecode), 16MB. Larger than fair number of libs, but not the biggest you can build. If you do something like strip debug info, you can reduce the size a little bit, but still quite large. Impractical for shipping to browsers. Not a problem for non-browsers.


[Slide 9]

We’re working on lumen, it’s an ahead-of-time, native compiler.  More restrictions, no hot code loading, more optimizations.  WE can also do other optimizations that hte BEAM cannot do because of having the whole program.  Currently we’re using LLVM for the code generation.

[Slide 10]

Here’s where we get into the tricky parts where supporting Erlang vs a native environment: Green/trheading, exception handing and the hooks for garbage collection.  The way that Erlang does stack allocation is different: the stack is in the process heap.  It is more different heap allocators.  When implementing GC on a native stack we need to reason about live values across multiple GC save points.  That is what we’re using LLVM on x86_64.  It is not supported for the WASM target. t hat is one of the problems

I didn’t mentin this, but Erlang does not have a concept of iteration without recursion. There is no for or while loop.  IT is implicit in the implementation that we have proper tail calls.  Currently we are able to get enough of the support we needed.

So, for green threading, we’re getting, each process gets its own native stack.  We use assembly shims to switch between processes and the scheduler.  Swap to the scheduler, then swap to next process.  We insert yield points in the generated code.  From the assmelbpy shim perspective the scheduler is not special.  The shims are saving the state into special structure and returning to the address of the last swap.  We construct hte stack of each process, so when you first jump into the process, the stack frames are setup like you called an init process like it was being called directly.  

It is reliant on being able to save and restore registers and stacks as a standalone object. 

There is no notation of saving and restoring registers in WASM.  On every other architecture we cna use the same scheduler.  For WASM we need a completely different scheduler.  Our currently blocker is we don’t have a way to do this.  The solution to this is a first-class stack.

IF I was going to reason about it.  At native stack-like object that can be suspended, passed around, and resumed.  Create a stack, suspend the stack, resume a stack, and destory one.

Some restrictions so you can’t destroy your own.  A privileged root stack.

The thing that is most important is the first class primitive.  When I was first coming up with the compiler I was looking into using continuations similar to how Scheme uses continuation.  When we come back to WASM there is no way to arbitrarily suspend and resume.  Relooper will not work for a program that is completely based on continuatons.

TL: Can yu take a question?  Have you looked into binaryen to use Asyncify.

PS: did look at the paper for that yes. Trying to remember what the blocker is there…

TL: Was there a paper for Asyncify? There is relooper which restructures control flow. Asyncify is a separate thing, code transform that allows you to resume and suspend stacks. Dumps all local stacks of Wasm VM into memory so you can resume by reloading from memory.

[Link from Alon Zakai: https://kripken.github.io/blog/wasm/2019/07/16/asyncify.html ]


PS: pretty sure i looked at that, will have to look at what the issue was there. What i was thinking of was, code transform on JS to allow it to support first class continutations. Gets tricky when bringin all these features together, not super tied to a particular architectural. Might be some approaches if all we were supporting is Wasm. Need different run time support depending on target. IDeally you want a core runtime with some target specific code, code-gen backend with target specific stuff happening. Ultimately you don’t want two wildly different backends. If you need to go down a different path, you get that problem. To  support Wasm we have to rewrite huge portions.

SL: do you have a JS backend?

PS: no JS backend. Native code via llvm. Technically emscripten will support it.

SL: it soundslike it is possible for you to have different backend..

PS: practical issue, but is every production compiler that wants to support Wasm have to do that? Doesn’t mean  that it’s critical, alot of support already goes that route. Puts a limitation on Wasm as the substrate of the future. For it to be well-rounded, it should be able to take any source language. If you already have an ecosystem in space, want to add Wasm, then becomes a practical issue.We  have some conversation about first-class stack/continutations... 

<meeting cuts off>

PS: what i was saying, those first-class stacks can allow us to compile to Wasm without re-engineering the entire compiler.

LI:  We don’t use asyncify, how does it interact with all the things Wasi want, shared-nothing. Do you have to asyncify the whole program? Does everything have to cooperate.

AZ: anything that is on the stack must have been compiled with asyncify.

LI: I’ld be concerned about that, thinking about how BEAM work son ref interp. You can call C code,doesn’t know called from C code, can’t be preempted, you can call if it  works fast enough.

AZ: if you call c code, it is guaranteed to  exit, only a problem if it pauses inside c code.

PS: how does this interact with switching between thousands of separate threads of execution. Every computation is happening in a process, many of  them. Typically 1000s, tens of 1000s.

LI: we’ve tested the runtime can  spawn 64k of  these in browser tab. Not 10 async,  10s of  1000s.  Browsers already support, can’t compile runtime to use it right now.

RT: process, and  switching. How sensitive are you to the overhead of this. If you double/triple that runtime, do you care about that? Or is it not part of the picture.

PS: definitely noticeable, but depends on what the overhead. If O(milliseconds), will be way too slow for erland system. Typical  switch time is in nanoseconds. We wouldn’t want it to  be  more  than 1 order of magnitude.

RT: sounds like, you’ll take what you can get, if  different options, 2 or 3 x slower, you wil notice that difference.

PS: yea, but if the difference is support v.s.  Not support, then we will  take  what we can  get.

LI: phoneix using websocket going to js can stream video just fine. If we cannot replace js with lumen compiled erlang, that’s annoying. We won’t want it so low that you can’t manage and av stream with it.

RT: GC root collection, shadow stack you maintain, is that reasonable?

PS: definitely one approach. Haven’t tried reworking codegen backend. Where I left off last time was trying to figure out if we can have some sort of stack map support. Done some research into adding support to LLVM. no notion of instruction pointer in Wasm, or return address, not concepts in Wasm. That’s where the stack map support is built in LLVM, without those pieces you have to come at it from a new angle. Provide something in Wasm  similar to how gc staypoint in LLVM works. Wasm if you have something similar, you can  get similar functionality. For us, important thing is to access that root, to follow it, and rewrite it. Use native stack for most things, need to do in shadow stack. It means we have to rework a bunch of codegen backend, accepted that for Wasm that’s a reality.Try to reuse as much as possible. Non-local control flow style imposes a lot of overhead. We are accepting overhead for those cases. C++ style exceptions are ero overhead when not raised. When raised they are expensive, traverse stack, multiple places cleanup. In erlang, it is a stack  of continuation pointers, you can setjmp/longjmp for those. A lot faster than average case for control flow. A lot easier for constructing a parser with deeply nested fn calls, and you want to jump out. If you throw a lot of those kinds of exceptions, overhead of C++ style exceptions become noticeable. How do we implement exceptions without continuations. I would use continuations to implement all tehse, green threads, exceptions. We are similar to scheme in a lot of ways, the kinds of things we need.

FM: one of the reasons we’re in this conversation, we are looking at extending Wasm to include stack switching of some form. Would liek to unpack a number, stack switch measured in nanoseconds?

PS: order of 50 to 200 ns. Specifically the cost of the context switch. ~50 instructions.

RT: you want EH to be similar, you would use cont to implement EH, just jump out of stack to where you want to go instead of unwind.

PS: save the point where the last handler was saved, continuation point, jump straight to there. The strategy I was looking at using was to implement continuations on top of setjmp longjmp, or some other equivalent assembly shim. Quickly realized that won’t translate to Wasm in any meaningful sense. Tried a more tradition codegen, instead of CPS IR and codegen approach, lower things in SSA, tried generating similar to what a C compiler would do. Some things become a bit awkward, worked fairly well, main problem is green threads and scheduling.

LI: on thread about unwind on EH proposal, we use LLVM invoke instructions.

PS: anything that gets added to llvm, we can take advantage of.  Nothing can be added to LLVM to solve our problem, it’s more a runtime thing.

FM: scheduler, you have one that manages all the process in one erlang application. Typical erlang system, you have one scheduler per core on system. In practice there is a separate pool of scheudulers for IO, natively implemented. 

FM: if you do yield, how do you know what scheduler to pas to

PS: the thread runs on a scheduler, when that process suspends, it jumping back to the scheduler, process cannot be moved to another scheduler while running. Each process cooperates with its scheduler. Scheduler can communicate to steal process from other schedulers.

FM: when running on browser, you have to integrate with browser loop. We rewritten how the core scheduler loop works for running in browsers, rather than running our own loop, we let the browser run that loop, we are taking a slice of time to check and see what we need to do, schedule a process for execution, run a bit, then yield back to browser.

LI: run from a frame, assume RAF is 60 fps. Scheduler loop invoked with RAF, made sure to not go ove r16.6ms. If every process is waiting for I/o, we also yield early.

FM: means special scheduler for browser.

LI: no, how we enter the scheduler, how the scheduler is invoked

PS: different entry point, bulk of scheduler remains

LI: scheduler has run call that runs single thing. Another wrapper, that yields. On native we yield to check signals. On browsers, we yield to RAF. Check if there is signal, or allow JS to run. Both have concepts of interrupted. We are shoving signals onto a signal catching thread, instead of signal handlers go into your normal code.

PS: boils down to being able to create stacks, suspend resume them. Most accurate  maps to how our implementation works on all arch. Open to continuations too, first class stacks might be more intuitive, also to other languages. Continuations can be implemented on top of stack-switching. From my POV, they are kinda the same thing.

AR: i was about to ask what is the diff. To me one is the implementation, the other being the concept.

LI: the one place we want to make sure of… effect handler thing where everything has to work together. In order to handle callbacks from JS for like forms, we need an async callback, right now we do JS shim, tell the scheduler go start aprocess, doesn’t immd jump into Wasm, normal RAF is where we’re doing our own loop. Async and await part that the Google team wants, to be able to handle JS api callbacks without having to write our own shins.

SL: Want to get a feel of the range of usecases you have for your particular impl, you mentioned streaming and so forth, does thtt involve a lot of context switching.

PS: not targeting specific usecases, other than being able to build software in browser using BEAM languages.

SL: particularly in browser?

PS: other Wasm platforms will be interesting, primarily in Browsers. Elixir community,  large portion of them building webapps, write frontend and backend using same language, same tooling (not isomorphic like JS). That’s where the biggest win is. No specific use-case in mind. That example is to show how sensitive we are to context switch. Typical erlang systems 1000s of processes, executing some code. THe more I/O heavy you are, the less impt context switch overhead is, more cpu bound, then it becomes noticeable.

SL: you might have though for browser application, you’re likely to be I/O heavy.

LI: whatsapp, gsm phones, on top of erlangs, 2 or 3 companies built on erlang for a/v. Probably interested to use elixir on top of Wasm. We don’t want Wasm to be a thing erlang isn’t supported on.

FM: at the end of the hour.

PS: will send all my notes, less meandering of an explanation of Erlang, and background of our implementation and issues we run into, will try and answer some questions.

### Closure
"
main/2020/CG-07-07.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 7th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: July 7th, 4pm-5pm UTC (July 7th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Vote on [explicit scheduling requirements for online votes](https://github.com/WebAssembly/meetings/pull/579) (Thomas Lively) [5 minutes]
    1. Discussion of [unmodeled side effects and intrinsic imports](https://github.com/WebAssembly/design/issues/1354) (Thomas Lively) [15 minutes]
    1. Discussion: What are the requirements for toolchain support?
       1. If a toolchain doesn't use/implement all instructions, does it support the proposal?
    1. Discussion of [identity of references in wasm vs JS](https://github.com/WebAssembly/design/issues/1351) (Ross Tate) [15-20 minutes]
       * Prior offline discussion in linked issue encouraged as preparation
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Alex Syrotenko
* Alon Zakai
* Andrew Brown
* Arun Purushan
* Ben Smith
* Conrad Watt
* Dan Gohman
* Daniel Hillerström
* David Piepgrass
* Derek Schuff
* Emanuel Ziegler
* Flaki
* Francis McCabe
* Gergely
* Henjin Ahn
* Ioanna Dimitriou
* Jacob Mischka
* Jakob Kummerow
* Jay Phelps
* JS Sugarbroad
* Keith Miller
* Luke Imhoff
* Luke Wagner
* Manos Koukoutos
* mkawalec
* Nick Fitzgerald
* Paolo Severini
* Paul Dworzanski
* Richard Winterton
* Rick
* Ross Tate
* Sabine
* Sam Clegg
* Sergey Rubanov
* Syvatoslav Kuzmich
* TatWai Chong
* Thibault Charbonnier
* Thomas Lively
* Yury Delendik
* Zalim
* Zhi An Ng

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Thomas Lively seconds

### Proposals and discussions

#### Review of action items from prior meeting.

#### Vote on [explicit scheduling requirements for online votes](https://github.com/WebAssembly/meetings/pull/579) (Thomas Lively) [5 minutes]

Poll: Should we accept the PR above?

DS: is 24 hours enough time?

TL: good qns, has been our policy for a while

DS: are we expecting all interested people to check the day before meeting? You want people to have enough time to read and form opinion, in that case is 24 hour enough?

TL: enough time to note that there is a vote, but not enough to read up

JS: It's at least 24 hours, people can be suggested to put agenda items earlier. And the chair can push things back, if necessary. We have a lot of processes that are potentially available. I'm ambivalent here. 24 hours is a minimum, I wouldn't want to make us wait for longer for non-contentious items.

DS: if people are happy with this, i will be okay with going ahead and saying yes

LI: are most people using GitHub’s watch feature, or are they checking issue manually

DS: watch as well, but watching so many repos, easy to miss

JS: someone can add agenda two weeks ago, won’t be able to remember, so should refresh

BS: due to timebox, we have to cut this short, take the vote?

JS: consensus vote?

BS: fine to have normal vote here

SF: 4
F: 17
N: 6
A: 0
SA: 0

#### Discussion of [unmodeled side effects and intrinsic imports](https://github.com/WebAssembly/design/issues/1354) (Thomas Lively) [15 minutes]

[Slides](https://docs.google.com/presentation/d/1he5eaBYfSvoFNAYEgKoe4rorTpniwvjAdnWFwlv8OdI/edit?usp=sharing)

RT: one item to add to the topic, the tracing application isn’t well served by using a call, you want an instruction to be put there in the spot, sort of like an inline call

TL: If you had compile-time imports in some matter then you could inline them.

JS: wondering what unmodelled side effect await has, from the perspective of the abstract Wasm machine, await doesn’t do anything, it stops time, waits for it to come back. Supposed to have a guarantee about the embedder world, but nothing about Wasm itself.

TL: Await is interesting because the host code can make further calls back into the wasm VM when it was waiting.

JS: we could have a version of await that doesn’t have this problem, similar to atomics where you pause the world while waiting.

TL: Even in that more restricted await case, where you can't re-enter, it's more like a no-op. Except that you can't re-order with respect to other instructions. 

RT: want to think about program equivalence, a nop is something that can be removed entirely, and still the same program.

JS: the ITT thing might actually be from an abstract perspective, a nop. A valid implementation can ignore the ITT part.

RT: not my impression of that. Having no effect on module internal state is not the same as a nop.

JS: people are asking for an instruction, that doesn’t do anything on a random implementation, it has to be treated differently from a nop in an optimizer

TL: the discussion now is along the lines of, taking case by case, for each proposal, see how to fit those into the spec, and not making a broad claim that those are out of scope and willbe solved by a new mechanism that we do not yet have. Ideally, CG figure out what the best path forward for all of them as a group, so we don’t need to repeat discussion and come up with divergent design.

BS: The danger i’m seeing here, the await proposal has been dropped, the debugger is a “fake” proposal, ITT is the real one. Concerned that any plan come up with here will be anchoring too much on non-real examples. More tempted to have another real example (phase 1 proposal) before we come up with a plan as a CG

RT: high level item that will be useful to gauge, what is the interest in having compile time intrinsics. Will also solve problems related to composing modules.

DG: Compile time intrinsics would solve some problems… [missed the rest here] (they could be instructions instead)

RT: you still have to have intrinsics standardized, and intrinsics can be implemented while these compile time

TL: still an option, although not a fan

DG: The motivation for making them non-instructions is not clear to me.

TL: on the await discussion, laid out reasoning: if the instruction, semantically, has unmodelled side effects, the best name for that instruction from core wasm POV is “undefined”. Don’t think core Wasm benefits from having an “undefined” instruction, except a host call import which has undefined semantics.

DG: Is there an assumption that core spec should not have non-normative wording?

TL: core spec document, core spec math model described in document, so far it has been the same. Doesn’t include anything except the core spec.

DG: exception to that: alignment hints

TL: The alignment hint… they don't have any semantics, that's true.

RT: but they do have semantic effects, it’s just not visible anywhere inside Wasm

DG: foreach of these features, there is a normative and non-normative component. The former is for all VMs, recognize these instructions; non-normative will say what this thing is for. Can we put non-normative in the core spec, lots of specs have done this.

BS: timebox-ed, sorry to cut off

TL: discussion on github, please chime in.

#### Discussion: What are the requirements for toolchain support?
##### If a toolchain doesn't use/implement all instructions, does it support the proposal?

BS: who brought this up?

TL: i did

JS: basically paired with the previous discussion: if we do add intrinsics, what will the toolchain changes look like. Also related to last meeting on bulk memory

TL: not about unmodelled side effect, about in general, if we have a proposal and toolchain only uses/implements part of the proposal. How did we end up in that place? Should we standardize the current state of the proposal including unused instructions? For bulk memory, we decided it was low risk, so included everything. In the future we want to be more careful, make sure everything in the proposal will be used by toolchain. Hopefully we don’t get into that situation again.

HA: implementing it and using it is different. E.g. for reference types we can quickly implement the rest. The bigger problem is we didn’t have usage for it

TL: we being emscripten.

HA: there were some instructions that even the rust toolchain didn’t have usage for.

RT: the meta problem is, how we figure out how things are being used before they advance this far

NF: my understanding is that the instruction question is table.fill, and the reason why we added it was for symmetry with memory.fill. Nice in principle, but no one has a usecase, we can delay these nice symmetry things, until someone says we have a use case

BS: that’s certainly been the case with instructions in SIMD proposal, they have been removed due to lack of use case or too slow

AK: downside is long lag time between something being useful and it being implemented and available in all engines

JS: that rule is there to make sure we have shaken the tree to make sure that we have gotten enough implementation. We can enhance the requirements to have one producer to implement that instruction, so that there is enough infra in place for someone to use the instruction if they want to. This is not that different from TC39 (?) requiring two major implementers to implement something before approval for standard.

DS: We have a such requirement already, so the question is: does the toolchain requirement mean that they have to use every instruction. If there is a subset of the proposal not being used, does that count? 

JS: good point, these things are brought to CG for a vote, enough though toolchain has incomplete support, we want to encourage champions to not do it

AC: not so much about incomplete support, for rust toolchain it doesn’t make sense, everything else makes sense. It’s complete support, but proposal doesn’t need everything

TL: And part of the issue is that the toolchain requirement doesn't come up in the proposal process until too late.

RT: the purpose is to shake the tree and see things are correct. If you don’t have producer with that code, it’s hard to evaluate that. Needs to have some producer involved to have a thorough evaluation of these things.

BS: what we want here is someone (not in this meeting) think about how to change the process to have toolchain requirements earlier. We are sort of doing this already, need to codify this. For the things we are currently proposed, is there a toolchain doing it.

TL: discussion in proposal repo sounds good

LI: does llvm need to implement something, before toolchain can use it?

TL: No, for example, the wasm-bindgen stuff is all post-link post-LLVM transformations. So when they add reference type stuff in their binaries, it doesn't have to use LLVM.

SC: also true for emscripten, able to use features that llvm doesn’t support, through binaryen

LI: Is the requirement that -- it's not that the toolchain has it, but that it can be used.

TL: maybe not every component of the toolchain has it, but some part of it has it

AC: depends on hwo to define toolchain. If it means LLVM then no

BS: toolchain supposed to be a chain, wasm-bindgen is part of the chain, though we don’t normally think of it that way

AK (chat): I think it's likely this is going to vary a lot between proposals, I don't know if we're going to get much better than case-by-case examination. But agree that maybe having something for phase 3 about ""evaluating how this will be used by toolchains"" (don't know how to pin that down)

BS: probably need wordsmithing, then bring it back to discussion

TL: SG, I can start discussion on proposal repo.


#### Discussion of [identity of references in wasm vs JS](https://github.com/WebAssembly/design/issues/1351) (Ross Tate) [15-20 minutes]

##### Prior offline discussion in linked issue encouraged as preparation

Ross Tate presenting [Reference Identity in wasm vs. JS](https://github.com/WebAssembly/meetings/blob/master/main/2020/presentations/2020-07-07-tate-reference-identity.pptx)

JS: I don't understand how requiring this in JS prevents allocation. It seems like an embedder can do it if they want to.

RT: this is the advantage of it

JS: doing *this* does *this* but doesn’t justify why it is required

RT: When I asked this, the reason I got was that it prevents an allocation.

TL: on the web, the js engine all needs to all do it , or not do it, otherwise there is an observable difference

RT: Right, so we have to agree on some semantics. So the alternative semantics is that you always allocate whenever you ask for a new funcref in JS.

KM (chat): How does this work with tables? Is it a new identity every time you pull it out in JS?


RT: Keith asks about tables… it's related, but I'll get to that in a second.

JS: I now have a corpus of 3000 modules, if someone wants to send me some code that can go through that please talk to me.

KM (chat):  The one downside of this is you’d have the nested constructor problem that JS has if you ever have a wasm constructor.
Each time you get a fresh function you’d have a distinct prototype so all your inline caches would blow up


RT: when you get a funcref and turn it to JS, you have a funcref prototype, everyone will be using it, does that solve your problem?

KM (chat): It’s the allocated object’s from the constructor that’s the problem
You’d have a fresh funcRef.prototype object

SC: Did you talk about tables? Emscripten does this, it checks tables to see whether the table values don't change over time.

RT: you’ll get a new funcref everything, emscripten is doing this?

AZ: For dynamic linking, yes, we do this all the time.

SC: posted a bug where someone found that the table is changed underneath (https://github.com/emscripten-core/emscripten/issues/11458)

AK: It might exist in sites that are already deployed, right?

AZ:  we depend on this for dynamic linking, we depend on this, we can change this but will require a different model for dynamic linking, which we are thinking about anyway.

AK: changing for future users, not for existing users.

TL: Right, we wouldn't want to break existing users that are already using dynamic linking.

RT: currently funcrefs happen very infrequently, but new ref type proposal adds funcref as a more first-class type, dependencies are more likely to build in the following months than now. Right now is just table.get, understanding this emscripten thing will be useful

AZ: things like combining equivalent functions and getting rid of functions in the middle, we do those optimizations at the toolchain level, it is true that VM can do it, but in Wasm we depend on the toolchain to do this

JS: wondering if (thinking in terms of implementing equality and want these optimizations), i want some runtime identity in function prologue, if want to reuse, create a thunk that has the same identity and another code. Does that work?

RT: It means that function references have more content through them...

JS: or the thing they point to

RT: It would be a code pointer with a header, with identity information.

JS: now i’m paying for a load everytime

RT: alon’s feedback is useful. The toolchain doesn’t respect program equivalence, at least on the JS. The toolchain has the behavior that it can transform wasm module such that the JS is not equivalent

AZ: If we know in the toolchain that it's OK to do, then we do it. In practice in emscripten and binaryen we already do this.

HA: related questions, we have a lot of optimization passes that can remove a function, like merging, function inlining, even without those optimizations, every single class of toolchain can optimize a function, semantics is preserved by it’s not the same function, instruction in the function is different. In that respect, every single optimization will not preserve the identity of the JS function.

RT: the toolchain does not preserve this JS identity

AZ: in a typical Wasm program, it is not observable, if you don’t use dynamic linking, different exports, we can merge duplicates.

RT: How are you telling that it's not observable?

AZ: if you have two functions inside Wasm not in the table we can merge them.

RT: You're doing an analysis that they're never exported.

AZ: that changes behavior, we know runtime won’t care about it

RT: In JS you can change semantics

TL: we control the JS too

HA: even without merging functions, optimization passes can change function bodies.

RT: internals of function can change all you want, but the identity of function is what you leak

HA: function in the table, we can still optimize function body, the same slot in the table has the optimized function, most toolchain opts don’t preserve identity

RT: issue is resolved because toolchain does not respect identity

TL: we do change the observable behavior from JS, it’s a small thing, and we also control the JS, so it’s not a problem so far

HA: different thing from TL, unobservable semantics. For example, two functions do the same thing, one optimized and the other not. In that case, are they equal? Guess not.

TL: no. two different functions, merging into one, observable from JS.

HA: not talking about merging.

RT: just talking about changing the function body? That’s totally fine.

RT: there is interest, i should work with JP for research

AK: i think we know there is a problem, should work with Emscripten folks

BS: we are trying timeboxing, follow up with me or on github issue (https://github.com/WebAssembly/meetings/issues/592) to see if this is valuable, whether we should continue or not

### Closure
"
main/2022/CG-08-16.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 16th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: August 16th, 4pm-5pm UTC (August 16th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Announcement: Welcome Conrad Watt as the new co-chair of the CG
    1. Announcement: In-person (with virtual attendance options) CG meeting in San Francisco, tentative dates are 10/26/2022, 10/27/2022
    1. Quick update and discussion on interval primitives (Kloud Koder)[20 mins]
3. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

## Meeting Notes

### Attendees

* Kloud Koder
* Derek Schuff
* Sean Westfall
* Keith Winstein
* Igor Iakovlev
* Conrad Watt
* Yury Delendik
* Rick Battagline
* Paolo Severini
* Yuri Iozzelli
* Johnnie Birch
* Luke Wagner
* Chris Woods
* Ilya Rezvov
* Jacob Abraham
* Chris Fallin
* Francis McCabe
* Alon Zakai
* Sam Clegg
* Mingqiu Sun
* Ben Titzer
* Deepti Gandluri
* Andrew Brown
* Richard Winterton
* Heejin Ahn
* Mossaka
* Jakob Kummerow
* Melanie Riise
* Bailey Hayes

### Announcement: Welcome Conrad Watt as the new co-chair of the CG

Excited to bring Conrad Watt on as a new CG co-chair!

Research fellow in University of Cambridge, interested in finding ways to nudge procedural inefficiencies that have held us back. 

Mozilla and Microsoft financially supporting work - thanks to Bobby Holley (Mozilla) and Ralph Squillace and Karen Chu (Microsoft)

I’ll specifically be working on advancing the Threads proposal.

### Announcement: In-person (with virtual attendance options) CG meeting in San Francisco, tentative dates are 10/26/2022, 10/27/2022

Google will be sponsoring, hosting in San Francisco. Meeting will be hybrid, with virtual options. Google’s policy requires anyone coming to the office to be vaccinated against COVID-19. Format will be similar to previous meetings. Also we’d like to have an onboarding type session for new attendees. If you have other ideas for things to add, please give us feedback. We’d also like to solicit new hosts for future meetings.

### Quick update and discussion on interval primitives (Kloud Koder)[20 mins]

KK: It’s been 14 months, would like to put it in front of the group and see if we can get a decision. Interval arithmetic from e.g. engineering, simulations. The question from 14 months ago was not “is this useful in engineering” but are there sufficiently native functionality that we want to expose directly in wasm in new opcodes but something programmers or libraries should handle. 

So there were 2 questions: 

What performance penalty do you get under native Wasm? Is there a way to condense that into something that gives you accurate intervals, e.g. the max upper and lower bounds. Is there a way to use existing rounding modes? You can, but what is the penalty? 
(see discussion at https://github.com/WebAssembly/design/issues/1456)


I came up with a few ways of doing this, and with contributions from others. The bottom line is that in most cases, 99.9% of computations, you can take some shortcuts and do this well, with maybe a 50% penalty. But you’re always left with corner cases that are very expensive to resolve. 

When signs get involved, some of the comparisons need to be inverted, two way to do intervals, take the raw result, and add/subtract a margin, and it can be within a certain margin. You have to check for sign changes, denormals, potentially infinities. You could assume that you never hit these cases, just use a conditional move to keep track of the min/max, but only do something different when you hit denormals, but that also doesn’t work, because in some cases is 100% penalty.

So the bottom line is tha you and up with hundreds of perent penalties. So my understanding is that we’ve introduced other opcodes for smaller gains. So =I’d like to get consensus for one of 3 things:


We just won’t do this
We will, and I’ll leave it to you, the experts
I’ll end up doing most of the work


It took so long because I wanted an answer from NVIDIA, FP opcodes themselves have rounding modes, and this makes intervals really easy. NVIDIA has of course made their own compilers, e.g. C for CUDA. Are they doing this for wasm? If its’ on their roadmap then maybe we’ll get it for free. They want to push performance from their GPU on wasm, etc. But I wanted to get an answer. But they see wasm along with browsers, it’s more of a toy and not interesting for distributed computing. So they aren’t interested.

CW: Is the ideal world that thre is some instruction sequence in Intel/ARM that we can expose in Wasm that makes this very fast?

KK: definitely. And not even SIMD. even x87 you can do this. YOu load the control word with a rounding mode init, then you do your instructions, and it uses that rounding mode.So you can load the control word before each instruction (and then optimize). Most of the time you can stay in your default mode.

CW: Do you want instructions thatcupport the rounding modes, or are specific to interval modes themselves? 

KK: Yeah i glazed over that. I think the minimal sweet spot has rounding mode flavors of all the FP instructions. So if you just want nearest/even it’s the same. But if you want round toward neg inf, there’s an e.g. add opcode that gives you that rounding mode. IMO, well designed processors do that.

DG: performance penalty for this kind of thing on existing CPUs, e.g. Intel/ARM?

KK: It’s several times. Maybe on the order of 5-10x if you do/don’t have wasm opcodes where you can specify the rounding mode.


KK: I’d say penalty would be even worse on nvidia because you can’t load control word.

TL<chat>: What is the usual developer experience for performing calculations with interval arithmetic? Are there specific libraries, languages, or compiler features developers use?

KK: I’m not aware of all the libraries, some of them specifically use compiler intrinsics to manipulate the control word efficiently. 

CW: it does kind of sound like we could evaluate this similar to how we evaluated SIMD and it’s a question of what instructions would this be compiled to, how would it be compiled on various different architectures.

KK: This came up in the previous call, we could performance benchmark this, it became clear that to actually correctly emulate what intrinsic rounding modes do. It was 

CW: the main question then would be find some source that relies on the rounding mode, and we could go based on that use case

KK: USe something like interval library, and compare how fast a native library runs natively, and on Wasm.

CW: or.. If it relies on a rounding mode missing in wasm, it would be really slow

TL: it was very driven by particular libraries and use cases, the author came and said, this instruction is missing, here’s an example kernel, and showed how the performance was affected in the library. So we’d like to have the library authors do that here too.

DG: not necessarily. … if we do take a library and compile to wasm and get current numbers it can tell us what there is to gain. The other question is who is doing this. We need someone to champion the proposal and do the pre-work, find the minimal use case, find out how it behaves on native and the browser. It’s great to get the feedback loop when we have the baseline, and the concrete set of proposed instructions.

KK: makes sense. My concert would be that ifyou pick a low level library like C++ it would be using rounding mode intrinsics. But that wouldn’t compile to wasm and wouldn’t be a good comparison.

CW: Even a library that can’t target Wasm because we don’t support the rounding modes would be useful to have the feedback. A standard C++ Library that’s using compiler intrinsics, even that would be a good input into the process. There is some set of rounding control instructions that we could add to Wasm

KK: how would you compare it? If you had a proposal it would be different and faster

CW: We could still choose to implement them at the Wasm level, and we could use this to validate

KK: on x86 youd change the rounding control bits, on other platforms it would just pick different instructions.

CW: just for testing you could add a rounding control instruction for wasm.

TL: The library doesn’t say do this for this instruction, but the C global state of setting a rounding mode, sounds like we would have to modify the rounding modes, that won’t have the same performance benefits.

CW: if it was possible for the compiler to infer which mode to do, and do it dynamically as a fallback, then it could work

TL: true but that’s a lot more work than just e.g. putting out some compiler intrinsics in clang.

CW: Have a switch statement on the global state, and see how many of these can eliminate 

BT: what do these libraries do on RISCV which has static encoding?

KK: Don’t know much about RISCV

TL: what’s the name of one of these libraries?

KK: Peripherally familiar with this, you’d have to Google it. 

TL: I think the path forward is to find a specific library, figure out how it gets compared, and see what kind of compiler intrinsics they use, and pretty trivial to whip up some intrinsics. 

KK: Library that has these rounding modes, targeting the right CPU, and compile it to Wasm.

FM: Meta level issue, someone needs to champion it. It would involve driving this navigaiton

DG: to add to that, usually when there’s enough performance on the table, we can look at the numbers and the use ccases, and when that’s compelling enough, people jump in and implement and work on it. There are always 2 questions, one is whether it’s significant vs targeting niche use cases.

<Discussion about next steps>

FM: what really needs to happen is to take ownership of this in the CG. if you just raise an issue you won’t necessarily get much response. You have to bring the rest of it.

KK: Could do x86 library. 

KK: AFAIK there are libraries

CW: What’s the motivation to get interval primitives?

KK: I see wasm as future of distributed computing, could hold the future back for the lack of intervals

CW: so the test of whether they are critical would be finding the use case where we need the feature but it can’t work well today.

TL: Found the platform-specific details for boost::interval https://github.com/boostorg/interval/blob/develop/include/boost/numeric/interval/detail/x86gcc_rounding_control.hpp

KK: I’m not sure that any of these libraries can compile to Wasm. 

DS: Interpretation is not that we want to say we want to compile a specific library to Wasm, we would like to see a use case. A higher level use case - if you compile this to Wasm you can get this to Wasm you get this performance penalty, here is a proposal that can add this to functionality to Wasm. What is the best possible way to compile these to Wasm? The use case is more important than the details

CW1 <Chris Woods>: We might be able to help you with that, have some examples and can IM you with details.

DS: should we create a repo? Phase 0 proposal?


DG: We should have some specific use cases/libraries before we’re able to spin off a proposal

KK: the most famous use case was the superconducting supercolider where they proved it safe using intervals. I don’t know of more recent prominent use case. When I have my own itnerval needs I usually use an assembly language.

FM: Use case may be a little more specific, the case was presented very well in the beginning, i.e. wanting to know the precision of your answers what you would do as the champion is raising an issue, and finding data about performance, it’s more a good description of the problem you’re trying to solve, and how you’ll solve it.

KK do you mean specific implementation or real-world use cases for intervals?

FM: What is the change, why should that be changed, need to make a case for it. 

DS: Super conducting, super collider, when you use intervals you use them in your own program, you use assembly, even smaller use cases are important.

KK e.g. when you want to estimate roots, you want to see certain bounds on algebraic roots.

CW: that sounds like a good example of source code that you would want to see

KK: I guess so, yes

BT: is there anything beyond rounding mode that would benefit intervals, e.g. native instructions for intervals?

KK: Just on newer archs where you have embedded rounding mode controls

BT: but not like “interval add” or anything like that?

KK: Not to my knowledge.

KK: The rounding mode control affects all the instructions the same way so it’s not very flexible

DG: even so, it is something that we’ve had requests for.

TL<in chat>: Found the platform-specific details for boost::interval https://github.com/boostorg/interval/blob/develop/include/boost/numeric/interval/detail/x86gcc_rounding_control.hpp

DS: Do you feel like you have concrete next steps? 

KK: Yes, will file an issue with data, and library specifics. 

CW: Totally ok, if some of the motivating examples are your own code. The most helpful thing is something that already exists, but concocting code is also an option if needed

TL: I found the platform details for boost::interval (in chat). It does look like it’s based on control bits rather than instructions. It would be great even if we could find another library that supports the RISCV style of instructions. To get this one working on something with rounding mode built into the instructions we’d basically have to rewrite the whole thing

KK: Which platform is this library supposed to be compiled to? 

TL: this is boost so it targets mainstream platforms. It uses gcc bultins but doesn’t target any platform that bakes rounding mod einto instructions. So if we prototyped ar ounding control bit this would be easy to target to wasm, but if we do what you proposed (baking rounding mode into each instruction) then this library isn’t really compatible with that design.

CW: How bad would it really be if we were adding instructions with rounding modes, but emulate global state with software? 

TL: If we didn’t have to do that, if we just had a bunch of intrinsics, that’s easy in e.g. LLVM. if we had to do the switch-based thing, thats at least a couple weeks of throwaway work, it would be unlikely to happen.

BT: Switch based thing could be done in user code as well. 

TL: it would boil back down to a handful of intrinsics, I could help with that

CW: Switch would be emitted in Wasm, and Wasm level optimizations would eliminate the Switch

TL: but I did want to emphasize that we don’t need RISCV hardware to test a library that could target it.

KK: So all you’d have to do is implement several instructions, and there would be a switch statement around each instruction, and hopefully it could be optimized away?


TL: That is something that may be built into the boost interval library

CW: When you’re compiling the intrinsic, you can use a switch and that switch gets optimized away

JK<chat>: what I'd like to see is a motivating example that's more concrete than ""someone in web3 might eventually need this"". For _any_ feature: if it's important to add it to Wasm, then it should be possible to find someone in the world who says ""I would use this for my app if it was available, and I'm willing to help with the design/exploration/prototyping"".

KK:Willing to help with use case

CW: it was reassuring to hear that you do write code yourself that uses this, I do think that’s helpful.

KK: Hacks for research, not a “real library” 

BT: question about the in-person CG meeting? I’m looking forward to being there. I had previously thought about holding a wasm “research day” before an upcoming meeting. Is there interest in that?

DG: one of the things I dind’t say is we thought about having optional breakout rooms, there are several interesting tracks (e.g. WASI?). I’d be happy to follow up with ou on that more.

CW1, TL, KW, are interested.

FM: any ideas what we’ll be talking about in the face to face meeting?

DG: usually what we do is a bunch of proposal updates, e.g. ones we haven’t heard from in a while, we have a bunch with active subgroups we bring back to teh CG for wider discussion, phase advancements, early stage discussions, sometimes things that can be contentious, sometimes those are easier in person. Usaulaly peopel propose agenda items and we arrange it.

FM: thanks. Ben what did you have in mind for research?

BT: I’m interested in finding out what kind of research infrastructure people doing research need to help them with their work.

TL: IS the target audience a subset of the audience of the CG meeting? 

BT: I think an intersection of academics who may not want to go to a CG meeting, and also CG regulars who might be interested in research. So i’d invite academic researchers who might not otherwise come.

CW1<chat>: count me in for the research and in-person. Also as a new member I’m really interested in the onboarding/orientation session.

BH<chat>: Can we start a google doc or github issue to start collaborating?
"
main/2022/CG-11-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 22nd video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: November 22nd, 5pm-6pm UTC (November 22nd, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Relaxed-math mode next steps (Dan Gohman) [30 minutes]
       * [relaxed-simd poll](https://github.com/WebAssembly/relaxed-simd/issues/105): 6 for, 3 neutral, 0 against
       * [relaxed-simd feedback and next steps](https://github.com/WebAssembly/relaxed-simd/issues/107)
       * [some profiles discussion](https://github.com/WebAssembly/profiles/pull/3)
       * [more profiles discussion](https://github.com/WebAssembly/profiles/issues/2)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
Thomas Tränkler
Andrew Brown
Sean Jensen-Grey
Alon Zakai
Luke Wagner 
Saul Cabrera
Chris Fallin
Paolo Severini
Yuri Iozzelli
Conrad Watt
Asumu Takikawa
Dan Gohman
Nabeel Al-Shamma
Shoaib Kamil
Ilya Rezvov
Thomas Lively
Brendan Dahl
Manos Koukoutos
David Piepgrass
Zhi An Ng
Alex Chrichton

#### Relaxed-math mode next steps (Dan Gohman) [30 minutes]

DanG Presenting [slides](https://sunfishcode.github.io/RelaxedMathModeNextSteps.pdf)

AR: common misconception, purpose of profile is not to increase fragmentation, but the opposite. it deals with inevitable fragmentation, things that are not implementable everywhere. proposal tries to minimize the inevitable fragmentation.

DanG:  I think there are multiple perspectives on that, let’s finish talking about it and talk about it in the end.

CWatt: ready for people to jump in with hot takes? My opinion: this is a spec organization question. We can get relaxed simd all the way throught standardization (relaxed mode), later if we want to standardize deterministic mode. Don't know if we should block relaxed simd progress until we resolve this. Second take, when we introduce some kind of mode, we should have the non-deterministic profile a clear default, because the safe thing to do when producing code is with fewer assumptions. Don't want to create a situation where users make a mistake of code only working on deterministic mode, but web browsers are relaxed.

FM: I’ve said this before, but over the longer term, the pressure on any given engine is to implement the entire spec. There’s a related problem which is that if you have a moving spec, then at any one point in time, not all engines will implement everything. I view the “inevitable” fragmentation Andreas raised as a non-issue.

AR: I want to reply and disagree on both accounts, FM’s versioning problem is almost impossible to solve, and not the goal of profiles. The purpose of profiles is to legalize a way to not support some features. This is not about the web, and about supporting environments that are more constricted, embedded for example can’t support SIMD or GC, or other proposals, it’s not going to go away, we can either ignore the problem and fail as a standarization group, or propose an alternative

DP (chat): Francis may be forgetting about (1) IoT targets where engines must be small and (2) open source engines that don't have the resources to support everything

SJG (chat): almost identical to risc-v extensions

FM (chat): My counter example dates back to the 1980's-1990's. Micro computers used to run limited versions of almost C. That is no longer a thing.

DP (chat):  Generally there is no ""counterexample"" you can give to an existence proof. But generally speaking, even if Moore's law continues, low-power low-transistor-count devices are *always* useful. If your doorbell starts running a full version of Wasm, your T-shirt may still be more limited

FM (chat): OTOH, this kind of subsetting/profiles was also quoted as a major reason for the failure of jdk me

SJG (chat): capabilities and resource limits, negotiating with the engine in the least number of round trips. https://gist.github.com/dominiksalvet/2a982235957012c51453139668e21fce. WASM64+GC+SIMD maxheap:8G.

DP (chat): I'm not familiar with JDK ME … but honestly I think Wasm has had better management than Oracle thus far

SJG (chat): they are run pretty well now, definitely something to learn from https://openjdk.org/bylaws

FM (chat): JDK ME is a failure because essentially, no-one uses it, including its intended target audience of embedded devices.

DP (chat):  I know a lot more about .NET Compact Framework which I don't think was well-managed (e.g. they chose to develop a completely separate codebase, one with very poor performance; and if the .NET people as a whole had designed .NET more judiciously it would've been more practical to have a subset of .NET that wasn't as limited as .NET CF was.)

DP (chat): ""X is a failure because no-one uses it"" is a confused statement. ""no-one uses it"" is simply the definition of failure itself, not an explanation for the failure. And my point is, you can't point to a project that wasn't executed well to prove that there is no demand or that it can't succeed

SJG (chat): What does the right thing mean? I don't believe sentences of that structure have stood the test of time. :) HTTP and RISC-V seem like models that have

DP (chat): On a personal note, I strongly preferred to use C# for my embedded project but used 100% C++ because .NET CF was just too slow

FM (chat): One of the reasons that JDK ME 'was a failure' was that it was, in practice, virtually impossible for programmers to actually use. The number of interactions between different APIs turned out to be a major source of intractability for programmers. 

DanG: anyone else wants to jump in?

CWoods: from our POV,  want to run Wasm in embedded products for 2 decades, profiles will be useful. Low cost process isolation, when size of runtime reaches a limit, we can use containers, no need to Wasm. Spoke to others, similar views in the embedded non web space. Have interest in solving versioning problem too, for longevity.

CWatt: The versioning problem will have to be solved by feature detection, profiles on its own is the wrong thing to solve this problem

DP (chat): Tend to agree, if you're saying feature detection should be finer-grained than profiles; I think both ideas are good

DeeptiG: what should the goal of this discussion be? The profiles discussion can be very open ended. Hoping we can scope it to some part of relaxed simd / relaxed math mode.

CWatt: how much of this is blocking relaxed simd?

DeeptiG: one way to phrase it, figure out how much of profiles we want to punt for the future

SK: profiles is explicit to reduce number of profiles, tryin to revise that part of profiles proposal is a vastly open ended discussion.

AR: What do you mean by revive or revise? 

SK: it's unclear whether creating a relaxed math mode profile is something the profiles proposers are happy about. When i reviewed the profiles proposal, it explicitly wants to reduce number of profiles (handful rather than a dozen). It already has half dozen proposed profile. We might be at odds with the original profiles proposal.D

AR: Handling determinism was one of the motivations for the profiles proposal, and I don’t think we need any more than that here. For the same reason the profiles profile tries to minimize the number of profiles, we should also try to reduce the number of SIMD modes. They should align quite neatly. As Conrad pointed out, this modes-versus-profiles issues is mostly a spec issue, so I don’t think there would be a problem specifying the deterministic or relaxed mode in an ad hoc manner for now. I would hope that we could move profiles along faster so that such an intermediate step wouldn’t be necessary.

DanG: deterministic and non-deterministic in ad hoc way, with a path towards profiles in the future

DeeptiG: that approach addresses my concern, have ad hoc way that feeds into future later, we can have meta discussion about profiles then

CWoods: risk that we paint ourselves in a corner if profiles come along and we have to reconsider something? It sounds like profiles by the back door.

DeeptiG: in this case we know we want a deterministic mode, spec infrastructure for this, don't know if we are handicapping ourselves for the future.

AR: basically profiles are a general way of doing the same thing, from one special case to a more general mechanism. Spec wise it might not be that different.

CWoods: addresses my concern, thanks

DanG: The current modes proposal doesn’t propose any way of detect which mode we’re in, how do we resolve this? If we had the profiles mechanism, that would be one way of defining flags or some way to say which mode we’re in

AR: don't think it is desirable to do that, as producers, you cannot assume you're running in deterministic mode, this is something an engine or environment decides, it provides that reduced language subset. You want your generated code to work in all environments. Shouldn't depend on accidental invariants that only hold in a subset of the language. You will invite misuse with such a feature.

CW: I guess I’m a little more worried that producers are going to misuse it, realistically producers may already do that depending on what engines would support. Would it be better to have custom sections to have some mechanism where we issue a warning or an error when the incorrect mode is being used. Concerned about the user error portion of this. Taking FMA for example, it’s possible for someone wanting FMA in the deterministic mode to assume that it maps to a single instruction, and that would be an incorrect assumption

SJG (chat): shouldn't the producer *ask* for deterministic mode? 

TL: These problems are still hypothetical, so we can proceed cautiously for now as we don’t have problems that actual users are running into at this time. 

PP: Not hypothetical, we’re changing the precision of FP instructions so it is detectable, maybe not important but definitely detectible. If we make a decision, we should make it consciously, its possible to detect it but it is important way to make it observable. 

AR: not actually detectable in a reliable way, you can assume with some certainty after performing some tests. from profiles perspective, it is a strict subset you are in, you can't change the behavior, you can only rule it out

PP: Re. the FMA example, if you add a number to the same value but opposite signs and multiple, in deterministic mode, you’d get a 0.. In strict mode you would get a deterministic answer and you don’t when you have FMA. I’m in favor of this, I’d like to just make folks aware

DanG: for CPP, we have people working on those toolchains in this meeting. We are on board with not depending on deterministic mode, will not lower CPP FMA to this relaxed instruction.

TL: Yeah, we don’t have all languages in the meeting, but certainly LLVM will never do the wrong thing here. We should aim to reduce complexity.

DeeptiG: This will be the more conservative way of doing this.

DanG: Anyone else who has an opinion here? 

NS: We’re agreed that relaxed mode + relaxed SIMD is a positive feature for a set of libraries and applications, the discussion is more about the mechanism by which we allow it.

DanG: That’s accurate, we’re looking at a way of introducing the proposal in a way that doesn’t harm other proposals. 

NS: Agree with TL, we can use profiles in the future to move this discussion forward

DanG: Summarizing, we’re aligned on introducing a deterministic/relaxed mode for now, and with profiles in the future as one way to include this, but not blocking any future discussion. We will also not be providing any way of detecting profiles

RW (chat): is mode defined on a per process basis?

TL (chat): Rich, mode is determined on an engine-by-engine basis. A single engine might be configurable to be in one mode or the other, but never both at the same time.

RW: Content could come from any provider. What if one provider assumes one mode and another assumes another mode? Then we could have a problem.

DanG: Deterministic behavior is a subset of the relaxed mode, so it should always be possible to run in deterministic mode

TL: Well behaved producers should always assume relaxed mode, so that’s the supersetting behavior that Dan was talking about. There will never be incompatibilities.

DanG: Toolchains like C++, even with ffast-math, we wouldn’t opti-in to this proposal by default. For most users, you won’t be able to generate any of this code unless you explicitly opt into the generating relaxed SIMD instructions

PP (chat): About detecting FMA the example is ""a * b + a * (-b)"": in dual rounding mode it would be zero, in single rounding it would be some multiple of the rounding error. From https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/

SJG (chat): How about the wasm itself has a section that lists the modes that the code requires to run. 

TL (chat): We just decided not to have a section like that because we'll assume that producers do the right thing anyway.

TT: Are we going to have a big-picture discussion, or just case-by-case? This is the first instance of fragmenting the ecosystem, so we should make sure we don’t paint ourselves into a corner.

DanG: Profiles does not have a consensus at this point, it’s a pretty big picture, we’re hoping to move this without blocking this proposal, hopefully profiles gains traction and we can use that in the future

TT: Agree about not blocking relaxed SIMD. Will we also have a big picture discussion in general?

DanG: We’ve had similar discussions before. Do you have specific concerns?

TT: Say you have a module that supports a particular feature, but another hardware doesn’t, how do we minimize the fragmentation of the ecosystem. 

NS: This goes back to versioning and fragmentation, this is already the case that some browsers don’t support some versions of features, this is what FM characterized this as long term fragmentation

AR: To clarify, this is not about CPU architectures, this is about environments, it’s not possible for all environments to support all proposals based on environments. Disjointed environments will exist, and we can’t assume that code will be ported across them. In general the idea is that some environments just won’t have anything to do with each other

TT: Not what I wanted to address, wanted a forum

AR: Start with the profiles repo as that’s the right place to start with this discussion

PP: Pasted code snippets etc.We can follow up offline If we don’t automatically produce FMAs, then that seems to make the proposal less usable.

DeeptiG: want to address usability, having a flag doesn't make it less usable, we are enabling certain set of users who know what they are doing

PP: there won't be a flag right, intrinsics only, no fast math mode. If you see it in the source code, they really mean it.

DeeptiG: we don't want to shoehorn what we are doing with a proposal to fit a compiler flag.

CW: the cloud ecosystem will want deterministic mode because of something, would anyone want to speak to that?

LW: People demoing large amount of Wasm workloads, and just being able to move them on different hardware, the excitement around it was that Wasm is a portable, deterministic ISA, in that context deterministic mode would be the default mode that folks on the cloud would operate on, it’s possible people would decide to opt out of the deterministic mode. The nice thing about this is that we can eventually have some set of canonical lowerings and hardware can converge on behavior, and we can get rid of relaxed mode.

RW: Agree with that. Down the road there might be some merging, but maybe not depending on what CPUs do. Would constant time Wasm be another mode?

CW: Constant time is about the timing behavior, rather than the semantic behavior of the instructions, the spec doesn’t say anything about timing of instructions, and it’s probably not possible for the spec to say anything about timing, but give engines enough information to 

BT: I’d like to mention backwards compatibility. Wasm will last 20 or more years, so we will have modules that compile under today’s assumptions. I’m concerned that we will need to emulate older hardware to successfully run modules that assume specific hardware behavior.

DeeptiG: every relaxed instruction has an equivalent deterministic lowering. We can add it to the appendix. No the union of all behaviors. You can lower to existing SIMD instructions, not as performant but expected to work.

DanG: for QFMA that's not true.

DeeptiG: That's true, we still have the open issue of whether we should add a deterministic FMA, and we can make a decision on that in the subgroup

DanG: overall path forward, don't depend on profiles, race with it to see if it can achieve consensus in time for relaxed simd, go forward with ad-hoc. Toolchains will use relaxed mode responsibly. Fair?

TL: SGTM

CWatt: Even if we’re not going all the way to profiles immediately, I still think we should specify relaxed mode as the default with the deterministic subset as a secondary note. 

DeeptiG: SGTM as well. I think there’s a broader discussion about profiles that would be useful to have at a future CG meeting. Andreas, maybe we can schedule time for that offline.

AR: Sounds good.

DeeptiG: Want to make sure we’re not blocking this proposal, but want to figure out general profiles direction sooner rather than later.

DanG: Conrad, let’s continue that discussion in the context of actually writing the spec.

### Closure
"
gc/2023/GC-06-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 13 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: June 13, 4pm-5pm UTC (June 13, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Status checks
        1. Spec documents
    1. Discussion: relaxing br_on_cast annotation subtype constraint ([#381](https://github.com/WebAssembly/gc/issues/381))
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Slava Kuzmich
- Nick Fitzgerald
- Bruce He
- Ashley Nelson
- Ben Titzer
- Conrad Watt
- Jakob Kummerow
- Zalim Bashorov
- Alon Zakai
- Ilya Rezvov
- Andreas Rossberg
- Emanuel Ziegler


### Status checks

AR: In terms of creating PRs, the big ones are done but they are still under review, so blocked.

CW: I can get on them today and tomorrow, can start.

AR: That would be great, those are the most tricky. Validation, execution, binary format, text format are basically done. Module prose for execution I still have to do. Bunch of smaller appendices I have to do. JS API is also done now. Simplified that a little bit.

### Discussion: relaxing br_on_cast annotation subtype constraint ([#381](https://github.com/WebAssembly/gc/issues/381))

TL: Possibly relaxing br_on_cast and br_on_cast fail annotation rules. Right now it’s required that the cast output annotation needs to be a subtype of the input type annotation. Makes sense since there is no point in doing a downcast, but this lack of flexibility inhibits optimizations in Binaryen. So we’ve had discussion about how relaxing might cause problems with future extensions to the type system. It’s possible an optimizing engine that wants to produce the best possible code for a cast would have to calculate a least upper bound for types in order to generate that optimal code if we relaxed that restriction. Personally I’m unhappy with losing type information and having to insert extra casts and having our optimizations inhibited by this restriction so I would like to remove this.

CW: Having looked at your recent example in the post, it seems like the reason Binaryen would need to inhibit optimizations is because it too early propagates the refined type to the cast. In a situation where it wouldn’t create a well typed program. If you prevent that propagation in the first place, would that be a way to maintain all the same optimizations?

TL: Two ways to look at it. Either Binaryen does something that is overly aggressive and then has to back it out to comply with the subtyping constraint or it takes the subtyping constraint into account throughout the optimization pipeline and does fewer optimizations. Either way we are losing optimization potential

CW: Shouldn’t need to do pure optimizations unless it generates a cast in ??? type

TL: Fewer optimizations, I mean that if we consider the output type throughout the optimization pipeline to be the LUB of the input and the cast types rather than with just the input type. That means that the output type is as refined as possible according to the current typing rules but is not as precise as it could be under relaxed typing rules.

CW: I don’t think that’s the only solution. If I’m understanding, when you have a refined input type, you propagate the input type through the failure case of the cast. But because that doesn’t type check, you need to implement a downcast.

TL: Two options, assuming we don’t change the spec to relax this, we would just not do this to begin with or fix it up afterwards. But if we relaxed the spec, we wouldn’t need to.

CW: In that scenario, aren’t you optimizing a path that wouldn’t be taken because the input type cannot match the output type?

BT: Casts can let nulls through, so I think there are casts that would be illegal for all things not-null but would let null through. What if you just let yourselves put casts that would be illegal under the current rules and then change the casts. Is that possible?

TL: Yes, in our IR we would have a single br_on_cast, more optimal than allowed by the spec, and to fix it up we’d have to insert another cast or a scratch local, possibly a null check. A couple different ways we can fix it. The problem is where we would fix it, is in the binary emitter. We don’t want to have two different validation rules in our IR. Either the IR allows the more aggressive typing or it doesn’t. If it does, then we have to do the fix ups later and maintain the aggressive typing.

CW: The input type is no longer a supertype of the output type, doesn’t that imply that one of the branches wouldn’t be taken?

TL: Sometimes, also the case with nulls that BT said, where the output type would become nullable bottom reference, so a null can get through but no other value. And even in cases where one of the branches is impossible, we have optimizations that would go in and optimize that case, Binaryen runs one pass at a time. And we want to be able to emit a valid module, no matter what passes we’ve run. Even if we haven’t done that optimization, we still want to emit a valid module. We don’t want to depend on the fact that the branches could be optimized out and force ourselves to optimize it out. 

CW: You want to be able to run Binaryen in a mode where it doesn’t need to run optimizations afterwards to get rid of the dead branches.

TL: In the default optimization pipeline it tries to get rid of dead branches but if we’re just running a test that happens to not include the pass to remove dead branches, things should still work.

CW: Things could still work but you lose a couple of opportunities at refinement in the failure branch.

TL: If we apply these expensive fixups or propagate less expressive types

BT: Can we keep weakening the supertype until it’s a supertype of everything.

TL: That would be the fix up, take the LUB of the input and output type, so you weaken the input type, but that also weakens the output type on the failure mode of the branch

CW: Is it the case that low propagation optimization, It’s only if you miss out on one. Propagating less precise type + optimizations that determine the type to be taken.

TL: We can optimize br_on_cast onto some other br or optimize the branch entirely to fix this problem, so if you br_on_non_null, you can transform it to get the more precise typing and optimizations. I think that in general, that would require adding a cast and a null check. So you turn a single cast into two casts.

CW: How does the first of the two casts type check in that scenario if the combined cast doesn’t?

TL: Only the combined cast has this arbitrary rule, we don’t have that on regular casts.

CW: Really?

TL: Regular casts like ref.cast have an input type that is not annotated and the only annotation is the output type. The dynamic type of the input to the cast can be unrelated to the output type to the cast because by subsumption you can treat it like anyref. AR said generating optimal code for casts would also require the engine to do a LUB, so maybe we’ve screwed that up already.

CW: I was thinking that as well.

AR: You may be right, I was never happy with the monolithic design.

CW: In my head, the monolithic design had input and output annotations.

TL: Ref.cast doesn’t have an input annotation because it’s not necessary for principle types. The only reason we have a type annotation on br_on_cast is we have two branch arms so to get principal typing.

CW: I don’t care about relaxing br_on_cast if we’ve already screwed up ref.cast

TL: In the future if we have union types, perhaps you can get more accurate information by getting the exact LUB. 

AR: Wait until you get generics, because then it’s coming back to you and you will have all these problems anyway and then you’ll have to do more work to do the cast path in the engine as well.

CW: If you reference a generic, you need to cast a generic with a type annotation, you can’t use the ref.cast.

AR: Sure, but that wouldn’t change anything. The annotation doesn’t give you additional information. 

CW: In one possible future we have slightly less efficient code gen for casts

TL: Imagine a cast where we have an input type that is the static type of the input, that determines what the output is on the failure arm. The output type annotation that says what you’re casting to, and a third casting annotation that says what the LUB is so the engine can do some nice codegen without calculating LUB.

AR: Assume the LUB is always the input. No value in separate annotation.

TL: There is, then you can refine the output type on the failure arm.

AR: For casts in general, you can make the argument that casts are supposed to check, if you have two types, I want to check this difference, generate code for me for checking this difference. It would be a bit more explicit. That would be a good idea for other casts. I expect you to generate code for these two different types.

BT: Did we decide that just because of space?

TL: Are you asking “did we decide not to have that input annotation just because of space?” Not just to save space, we never talked about putting an input annotation on this cast before because in the MVP, it’s not useful, that’s why it never came up before. In the MVP, all you do to generate optimal cast code is to figure out what the abstract LUB type is. If you have two struct types, casting from their specific LUB is no better than casting from generic struct type.

BT: In a baseline compiler that doesn’t construct types, you only have the immediates, you wouldn’t know the input type is a struct. 

TL: For the baseline compiler, that’s true, so the pessimistic code would have to cast from Any.

BT: I recently had a look at all the baseline compilers, I think SpiderMonkey & V8 reconstruct types as they go, so they have the LUB effectively, but not all baseline compilers, Wizard doesn’t do that. 

TL: For baseline compilers, I’m not as worried, it’s a tradeoff at the baseline. It can choose to reconstruct types or not. Ben, are you advocating that we add an input type to ref.cast as well?

BT: I see its value but no, not really. Given where we are in terms of churn, I don’t see a big enough benefit to do that. 

TL: I would be happy, in the future, when the type system becomes more complex and generating optimal code becomes more complex, I would be happy to add a version to ref.cast instruction that does take a useful input type. Or a version of br_on_cast instructions that takes an additional LUB, to reduce the work the engines have to do. For the MVP, I don’t think it’s necessary. And the benefit of propagating the more precise type information is much bigger than the disadvantage of some work to calculate the optimal codegen, especially if we’re already doing the work in ref.cast.

CW: With this revelation, I agree it would be consistent with ref.cast to go with TL’s suggestion of relaxing br_on_cast.

AR: Still uneasy about the implications it might have.

CW: It seems like the main implications are how efficient the codegen is, so at worse, something naive.

AR: The other was about the type difference and if you want to have something more powerful there. In increasingly expressive type system, the type difference becomes similarly hard to compute as the LUB. That’s my other worry. I don’t have any concrete examples, need to think more deeply. This might easily bite us, is my hunch. Unless we compromise on that, we want to have the most precise output there. There is a catch.

CW: A version of the br_on_cast with the LUB annotation, would it be possible to segregate the types so the more complex types are not allowed to be passed as input into the one without, and you have to use the more annotated version. 

AR: I’m not sure that would be easy but we could do the unannotated version would compute the less 

CW: Currently we have a precise output type but maybe it would be a less precise input type and that doesn’t seem so bad.

TL: Either that or the less annotated version is, the missing LUB annotation is Any. 

AR: That would be ideal, sugar shorthand. Not sure if possible, we’d have to see.

BT: Where we are now, with the types, the branching casts that have the two annotations, everything the engine has to know is in these two annotations. So the validator is between the two type annotations. So it becomes nulltype or unreachable. 

AR: Can you clarify?

BT: Generate code for br_on_cast with two annotations, with the types we have now, you don’t know anything from the abstract stack. So the check the validator does is the same for rejecting the allocated casts, so it’s effectively the same for the code generator to do the same check, and generate a null check or unreachable. 

AR: There is nothing to force the producer to generate the most precise input types. You can try to cast from A to B, and annotate with Any if you don’t want to have the output type be precise. I don’t know if engines are too optimized for A instead of Any, but they could. So this is another place where there is too much machinery for this one instruction, IMO. I was expecting that with two input types it would not do better with optimizing based on the inferred type, but I would assume producers would already insert the best type they can so the engine just uses that and is done. With the observation that cast doesn’t have that information, they can probably do it anyway, so just as well for b_oncast.

JK: Of course optimizing compilers try to optimize. For example for vtables with br_dispatch, the type system forces you to make it generic, then you inline and inlining allows you to drop a bunch of checks. 

CW: Do you see value in having ref.cast with input and output annotations?  

JK: Nope, not for the MVP. Wouldn’t get any value, just burn a few cycles on validating the input type. I’m quite happy with the state the ref.cast is in now. If and when we have a more complicated type system, we can introduce a variant.

CW: Thank you. 

BT: I agree with that, if we get to a place with generics, we can introduce a cast with type parameters that is capable of dealing with type parameters and has more annotations. 

TL: Sounds fantastic to me as well, anything else to discuss?

CW: AR, do you want to think more of hairy scenarios?

AR: Uneasy, probably won’t come up with something in the next couple of days, because of limited time. We can tentatively decide on it now, and if new info comes to light, we can reconsider

TL: I’m happy to reconsider this if new things come to light.

CW: It’s a problem that could be fixed in Binaryen but you’d have to change how types are propagated through branching casts. 

AR: But basically, you want to detect casts that are dead because they can only succeed or fail. It’s a bit weird this can come up. One problem is you don’t want to have two typing rules for the instruction. The other thing is you have the liberally typed way or the rigidly typed one, and when you spit out the wasm code, you transfer one to the other. I’m not sure I’m totally convinced we’re fixing it on the right end, but I don’t have a strong argument at this point. I would prefer having the two annotation casts, but I’m not actually suggesting that right now.

TL: That sounds like a totally reasonable thing to have in the future once it’s more useful. I agree in principle but not on timing. In Binaryen, this is all fixable by transforming the code and it’s a question of for engineering reasons, reducing the number of transformations we have to do in the Binary emitter. It is fixable but it is not one that we would be happy with.

AR: My take is you want some of the transformations, but something looser than the target language. So you would have to have an IR that is a bit relaxed and then translate it back to the real thing, which is not uncommon in compilers. It is how many of them operate.

TL: That’s all right. Hopefully, you can see why from our point of view, the fact that we want to emit something, it seems like a bug in the target language. Please speak up if something with the type annotations does come up.
"
gc/2020/GC-09-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 22nd video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: September 22nd, 4pm-5pm UTC (September 22nd, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: [Incorporate RTTs into the type](https://github.com/WebAssembly/gc/issues/119) (Ross Tate) [20 min presentation, 20 min discussion]
1. Closure

## Meeting Notes

### Introduction of attendees

* Adam Klein
* Andreas Rossberg
* Benjamin Titzer
* Ben Smith
* Ben Titzer
* Conrad Watt
* Daniel Wirtz
* Derek Schuff
* Dmitry Bezhetskov
* Emanuel Ziegler
* Francis McCabe
* Jakob Kummerow
* Keith Miller
* Lars Hansen
* Luke Wagner
* Manos Koukoutos
* Ross Tate
* Ryan Hunt
* Sabine
* Slava Kuzmich
* Thomas Lively
* Tobias Tebbi
* Wouter Van Oortmersson
* Zalim Bashorov
* Zhi An Ng

### Discussion: [Incorporate RTTs into the type](https://github.com/WebAssembly/gc/issues/119) (Ross Tate) [20 min presentation, 20 min discussion]

Ross presenting ""Minimal Change to Nominalize the MVP"" [(pdf)](presentations/2020-09-29-tate-nominalize-mvp.pdf) [(pptx)](presentations/2020-09-29-tate-nominalize-mvp.pptx)

LW: I get the general tension between i31ref and smi -- what if the engine doesn't need to distinguish them?

RT: specs will because JS SMI is conceptually a JS integer, it’s not supposed to  cast to an i31ref

LW: The idea is that the coercion when the i31 flows in can put it into an i31ref...

RT: you’ve picked a winner in Wasm that will always use i31ref, to interact with Wasm it would convert to Wasm mode

LW: No, it would just happen at the toWebAssembly interaction -- it would not be observable at the JS boundary.

RT: formally in terms of abstraction it is compatible, an alternative is an externref, not a subtype of anyref, i don’t need to do any coercion

LW: Do what? A coercion happens in any case, it happens when a JS value flows into Wasm.

RT: we can do all sorts of coercion at boundary, if externref is not subtype of anyref, you don’t need any coercion

LW: Specifically for SMIs, I don't see a conflict where anyone is getting deoptimized. I don't see a tension for this one.

RT: move on to other examples first

[back to slides -- Centralizing Coordination]

AR: coordination for types is not the same as for exceptions, exceptions are generative in source language, nominal aspects map down

RT: Wait, the generative source in source language are not the same as generative source in Wasm...

AR: in that case it's even easier, either it’s a finite set (C++) or translated down from nominal in source language. Completely different from types. If you compile two modules that use structural types, there is no central instance to define the infinite set of types.

RT: I'll get to all this later… plan to have more discussion after that.

[back to slides -- Centralizing Coordination]

FM: Assertion you have about coordination is not generally applicable. In particular in systems like Java application servers, this a central module but the application server has no knowledge of the applications that it's serving. It's not true that this runtime module can know everything about the application -- it's not knowable.

RT: doesn’t have to know everything, if you have app server and exchange strings, all those strings need to be tagged with rtts.

FM: It's true for strings, but not for other types involved...

RT: Should be for other types as well… 

FM: thats why i said tree, it’s not one node that knows all the type, you have a tree of a graph

RT: That's still fine, if I have modules that have the same type, they need to link with the same module that provides that type.

FM: there are scenarios where it’s a distortion to force this, having a central module that knows about all the types

RT: I'm not forcing them, there are other ways to arrange that coordination.

AR: confused about what you said, whole point of rtt.canon is that no coordination for runtime types

RT: You also said that rtt.canon is not excpected to be used for OO languages

AR: if you map something already nominal in source language, this is about compiling something that is not nominal in source

RT: If one module has a string and another has a string, then something needs to coordinate on the RTT

AR: they need to have out of band agreement for what a string representation is.

RT: We explicitly discussed what happens when two structures have the same struct, you said they'd have different RTTs. So are we doing that or not? If not, then we need to add another layer to casts...

AR: not sure i follow the question, there are several levels here, primary use case of rtt is to allow representation level cast, the next kind of thing is how you can piggyback this mechanism to represent/imply source level cast (which can be nominal), we can support that by supporting a generative way to support rtt (rtt.new), we have discussed it. What source semantics is implies what rtt you will be using.

RT: Andreas, it is difficult to take anything concrete since there are not translations for source languages. You said there is a way to make generative RTTs and a TODO. Operating on that response, that's what I'm suggesting.

AR: that’s why i just said, you would have a new rtt.new

RT: Yes, if you have this then you have to communicate shared types.

AR: only for types that are nominal in the source language

RT: the example i gave is Java strings.

CW: Java will need this yes, but the question

AR: with the set of types they can define infinitely many types. For java you have a small fixed set. In general, with a language that lets you define infinite structural types. Even managed CPP, array types are structural, you can’t predefine infinite set of array types.

RT: Can you give me concrete language examples where this couldn't be supplemented with wrapper types?

AR: maybe C# is one example, structural array types

RT: C# arrays are nominal

AR: structural in element type

RT: in casting system it is nominal

CW: I was thinking ocaml, but we need to compile to array of anyrefs, we won’t be able to use this

AR: true in MVP, but not what we want in the future. Ocaml relies on uniform representation, you don’t want any more fancy. The standard examples are arrays and tuples. Not sure what you’re saying that they are nominal in CLR/C#, there is a generic type constructor.

CW: I guess more generally, not just Java or C# that has a need to have a central coordinating module, then you need the module for other reasons. A better example is one that doesn't need a central coordinating module.

AR: the other problem is that, if you have infinite set of types, e.g. tuples

RT: e.g. for ocaml system, with tuple system, tuples are only done up to some size, then turned into arrays, supposed you don’t do that. You can have applications dynamically load this module, link with the standard module anyway, provide standard sizes up to arity 10 tuples. For larger, loader can generate a tiny module that makes rtt for length 11.

AR: You have basically greenspun a structural representation...

RT: for languages that need this construct… <cut off>

AR: cannot be a Wasm module, have to be outside of Wasm. It would have to reflect on..

RT: talking about a theoretical system that doesn’t exist

BS: feel like we have spun off, let’s get back to the main issue

<Back to slides, Understanding rtt.canon (and rtt.sub)

CW: The RTT.canon instruction, not necessarily but at runtime you'll have to do that.

RT: will work on that...

<Back to slides, Understanding rtt.canon (and rtt.sub)

[discussion about whether the complexity is the same between structural and nominal types]

CW: not sure if you saw discussion with RT, each immediate parent lists all its transitive parents, only need to import immediate parent

RT: meeting is now recorded (adamk said in chat)

CW: in all of RT system, when you import definition, you get all the fields including parents, don’t need transitively import all of parents

RT: There's an open issue on this, Andreas. But Conrad and I had a long discussion about this...

AR: but you’ve moved to a more structural thing

CW: You need to do a linear check at each level of inheritance.

[Back to slides -- Concerns with structural typing]

AR: can you explain what you claim to be undecidable

RT: There's an issue where we've gone over this already. At the present the post-MVP is not specced enough so it could be useful for anything. The only way to extend it to make it useful for some examples made it undecidable. Other people have tried this before, and were not able to make it work for Java and C# arrays.

AR: I think I have to remark on something again. The primary purpose of casts is to do representation. I don't think it's possible to do source level casts, it would be a universal type system.

RT: you’re making a slippery slope kind of thing, we aren’t going to be able to represent all. There are existing systems, like c# arrays, you can  reason that a Java string array can only contain strings. We can’t guarantee all things, but we shouldn't try to at least guarantee some things, need a middle ground

AR: Agree with that. Disagree about the reasonable middle grounds.

[Back to slides -- concerns with structural subtyping]

BS: we are still doing the lead-up to the change, how many slides?

RT: few slides left.

AR: dynamic type system intentionally supports both structural and nominal. Currently what’s written down is purely structural. If you consider the extension then it supports both

RT: It's the case that a value -- we can't in the current MVP cast functions to funcref, because it isn't a structural system. Currently the plan is that the function will be tagged with the canonical type for its ref, which is not funcref. Also not subtypes of functions, so it must be a nominal system.


CW: I have a question: your point about the casting of ""this"" pointer, in both nominal and structural systems you need this cast, but with bounded quantification you can prevent this [RT: correct] Have you looked at other systems to remove this?

RT: probably some I have missed, i’ve tried going through a bunch of them, and found that, e.g. AR linked to some of them, none of them are expressive enough. We can go through each case and see what each misses.

BT: While we're on this slide: every ""this"" pointer must be cast? Tobias proposed a mechanism where you could do method dispatch using hashtables, we should not take it as an assumption that we need this cast, where we can do it implicitly… I'm pointing out that this current set of capabilities makes it impossible, but we can get around it by adding new features.

RT: wasy to get around in the future but in MVP we can’t.

TT: But bounded quantification is not necessary, as the object systems demonstrate. There are example with no cast for this, by hiding the dispatch in an abstraction

RT: If build toward a specific language then we can bake in the invariants of that language, we can bake in C# and Java Arrays, so we know that the values extracted from the array have a specific type.

TT: you can also try to find mechanisms that are more general, not language specific

RT: Right, it's an open problem. Existential types may not be the only solution, just the only one I know it exists.

[Back to slides -- Suggestion]

BT: Removing anyref is not related to the nominal type system. There's downsides to removing anyref, it means you need type imports for parametric polymorphism. Anyref is a way to achieve ad-hoc polymorphism.

RT: we gave concurrent examples of how to have polymorphism without anyref

BT: For example, if you think of anyref being java.lang.Object, before generics they are the top type. If you were to build generic objects today in Wasm, you'd build them using anyref.

RT: you can make a module that declares a nominal type that does not have anything in it (e.g. Ocaml)

BT: Without a top-type, you cannot build a generic data structure unless you force every other data structure to extend it.

RT: the thing i described will be the top type for ocaml modules

BT: You're not understanding my example, a generic anyref usable for any language.

TT: either you box them or its part of… <cut off> it’s not possible to have an array....

AR: I agree with Ben that removing anyref is orthogonal to the rest of the discussion. If you don't have anyref… it's just the infinite union. You either need unions or variants for generic data structures. Variants are not enough because we don't have closed world.

RT: who needs this?

AR: if you compile any language and you want to talk to WASI, import abstract types, infinite set, you cannot, at compiler construction type, say what this set is. You need that in your representation somehow.

RT: Import WASI type, then you have something that says how to represent the WASI type.

BT: there’s an implicit assumption that people disagree on: how reusable can we make Wasm module, are they only for a specific language, if yes then we have a module that coordinates runtime, define top type of Ocaml. I do not have this assumption, people will build generic modules. I want to build a tensor library, zero dependencies, usable from any language. Can’t do that if we have to coordinate, and define top types. I can define a union using an imported type, supertype, boxing, but this is a fundamental tension. Are we going to be able to build reusable modules?

RT: Didn't you just answer that you'd use type imports for this?

BT: we don’t have the type import mechanism yet. We have that as part of the GC proposal.

KM: How do you have any two modules do this without type imports?

BT: go back to 1995, like Java, anyref.

KM: how do you downcast?

BT: don’t need to downcast, hashmap doesn’t downcast. You downcast in user code. I’m not proposing it’s an awesome solution, but need to have a solution.

BT: what i was getting at is that are we going to build reusable modules, and what mechanisms to achieve that.

CW: can do that with nominal type system with anyref. More interested in discussion the core nominal and struct system. The core is avoiding canonicalization.

AR: I think there's a conflation of issues here: main issue with canonicalization is that equi-recursion. It is not strictly necessary that structural types imply equi-recursion. We could define iso-recursive semantics, but doesn't have the problem that Ross sees. There are solutions that are orthogonal to structural vs. nominal. They are going to be the interpretations that you have to do at the module boundaries anyway. So we'll need an iso-recursive...

CW: big diff between shallow struct check and a full canonicalization, difficulty of canon on different threads

RT: Canonicalization is one aspect. At present we don't have a mechanism to do things without frequent dynamic casts. It's possible we'll develop a new system that can do this. It's possible that we solve a long-stadium open problem on how to make structural checking.

CW: i like my more specific point to be address (canon and concurrency)

BT: canon is still an optimization, you can represent … don’t think that’s fundamentally unsolvable

CW: I'm not worried that it's unsolvable, you could have data structure with lock around it.

LW: iiuc, it’s only when we get to the function level generics, we have to do anything after instantiation type, type imports. If not using type imports or structural type, you can do that at compile time. Right?

AR: Whenever you have a closed type you can do it.

BT: if rtt will be generative, with type imports you need to fill out structures, allocation.

AR: Tobias and Jakob and I discussed similar topics last week. We realized that one problem with static nominal types, if you want to compile Java -- compiling each class file into separate modules. In Java, as with other OO systems, these classes can be mutually recursive. In Wasm we don't support this. So if your nominal types are static, then you need recursive linking to make that work...

RT: recursively defined types, doesn’t matter nominal or structural. You’re saying recursively defined types are difficult, only in separate modules.

AR: if you don’t care about abstracting, all you care about is the definition…

BT: Java’s type system will never work until you have a runtime system, everything is mentioned by name.

AR: if you want to make that work at Wasm level, then runtime types have to be a form of dynamic system.

CW: tiny point, not sure the details of this proposal with examples, but this represents a very small change in terms of technical effort. TL mentioned alternative prototyping. This would be a small experiment.
"
wasi/2024/WASI-06-13.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: June 13 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: June 13 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Yosh Wuyts: Progressing proposal changes through the phase process ([slides](./presentations/2024-06-13-yosh-wuyts-progressing-proposal-changes-through-the-phase-process.pdf))
    2. Luke Wagner: Adding core wasm ""build targets"" to the Component Model ([slides](https://docs.google.com/presentation/d/13FbrlS1mPcG2nhypU6zLCDfw2Ghdmt-Q2xCcfeOLQ0s))


## Notes
### Attendees

- Bailey Hayes
- Colin Murphy
- Pat Hickey
- Alex Crichton
- Dave Bakker
- David Bryant
- Fedor SMirnov
- Jeff Charles
- Kate Goldenring
- Maximilian Seidler
- Merlijn Sebrechts
- mosakka
- Nick Fitzgerald
- Piotr Sikora
- Marcin Kolny
- Robin Brown
- Sean Isom
- Sehyo Chang
- Dan Gohman
- Taylor Thomas
- Yong He
- Johnnie Birch
- Zalim Bashorov
- Stephen Berard
- Trevor Elliott
- Yosh Wuyts
- Joel Dice
- Mike Warres
- Hung-Ying Tai

##  Progressing proposal amendments through the phase process

**Yosh Wuyts** Two weeks ago presented about since and unstable gates. We are putting that into practice and we realized we want to tweak how proposal changes make it through the phase process.

**Yosh** In my last presentation I said that “extensions to existing specifications need to independently advance through the phase process” and “starting with phase 0”. We all liked the first part, not so much the second part, because it adds a bunch of incremental votes to advance something pretty small. So we are asking, can we advance from phase 0 to phase 3 in a single vote. That seems like a lot of process. So probably amendments to existing proposals that are at phase 3 already meet the phase 2 criteria by definition of being just an amendment. The phase 2 criteria say: portability criteria is documented. Because we are modifying an existing proposal, the criteria is already documented (using wasi-clocks timezone addition as example). Overview document also exists in the repo. And the wit exists. So, adding an extension behind an unstable gate already meets that - its in the wit, its just not part of a release. Final phase 2 criteria is that all dependencies are also phase 2.

**Yosh** When we think about process, I am trying to balance the agency for the proposal champion to develop their proposal, while also having the subgroup ensure that proposals meet our standards and goals. We do that second part by having a vote at releases. So the way I’m interpreting our process is that: making changes to existing proposals is done at the discretion of the proposal champions. Stabilizing changes to existing proposals must always go through a subgroup vote. The biggest guard rail is that changes to existing proposals cannot be backwards-incompatible outside of major revisions.

**Yosh** So here's the process by which i suggest we approach amending proposals: 1. File a change as @unstable to a proposal. 2. Champions submit change as a new phase 2 proposal for wasi, that we track as its own item. 3. Champion lands the change 4. so that it can be used behind the gate by implementors and experimenters. 5. Champion decides the feature is ready for the next release, calls for the subgroup to vote.

**Yosh** Next time I’ll be back here for the actual release process for 0.2.1

**Pat Hickey**: I am in total agreement with this proposal and think this will involve the WASI SG at the appropriate time. Thank you Yosh for talking about rules and process.

**Taylor Thomas**: I am also in favor of this. I think this strikes the right balance as one of the champions for a lot of the wasi-cloud repos. Especially now when we are looking to ramp adoption of a number of interfaces within the community.

**Yosh**: I would like us to present regular changes even if these aren’t for a vote. Encourage champions to share regularly. 

**Pat**: This meeting is a great place to have discussions. In addition that can happen in async communications on the GitHub PRs where these additions are proposed. We want to maximize the number of ways people can give feedback and share their work.

**Dan**: This mirrors the CG process. Shares the flexibility and the same way the CG votes. 

**Yosh** I will follow a PR on the WASI repo that reflects that timezones addition is phase 2, and a separate PR clarifying that amendments are tracked and follow the process I outlined here.


## Adding core wasm ""build targets"" to the Component Model

https://docs.google.com/presentation/d/13FbrlS1mPcG2nhypU6zLCDfw2Ghdmt-Q2xCcfeOLQ0s

**Luke Wagner** This is a slice of the presentation I gave at the WASM CG meeting last week, many of you may have seen it. This is for extra visibility and I gave more detail at the end.

**Luke** Motivation is adding support to new wasip2 functionality to existing core wasm engines. Adding core imports is easier than implementing the whole component model. Supporting incremental development of those existing core wasm engines, and some use cases only want one core module.

**Luke** Idea is to add a core module “build target” to the component model preview 2. So heres an example of taking a wit file, parsing and resolving it and it turns into a component type in the component binary. To target that with a component I compile C into some object files, and package it into a component using `wasm-component-ld`. That component can run in any component runtime that supports that world.

**Luke** Additionally we can take the component type definition and derive, mechanically, the module type signature (according to the canonical abi) that corresponds to that component type. That will have all the same imports. You can take the same object files above and the regular old wasm-ld and it produces a core module that is of that same signature, and any core-only runtime should be able to run it if it provides those imports.

**Luke** for wasi-sdk we are suggesting that if it uses `--target=wasm32-wasip2-component` it takes the wasm-component-ld path, and `--target=wasm32-wasip2-module` takes the wasm-ld path. Over in go, GOOS=wasip2 for both, -buildmode=module|component.

**Luke** All this core module is, is the input to `wasm-tools component new` that trivially turns that module into a component. So really what we are doing is documenting what the input to wasm-tools component new is, which we hadnt gotten to doing before.

**Luke** Why would you use components if these modules exist? Well, components have a bigger feature set - shared everything dynamic linking (e.g. cpython), shared nothing cross-language reuse, tweak the ABI to use different string encoding, or wasm-gc, or a custom realloc. So we arent bringing the full power of components to modules, just the ability to use canonical abi imports and exports, which seems to be what a lot of people want right now.

**Marcin Kolny** Is this just a plan for preview 2 or is this going to happen for every release?

**Luke** This is part of the component model spec so it goes for all releases of WASI that use CM. 

**Maximillian Seidler** How do we treat strings?

**Luke** Default to utf-8. If you need more options you should use full components.

**Merlijn** Are these modules - can runtimes that support full components how do they treat these modules?

**Luke** It makes sense for those runtimes to just automatically accept those core modules and upgrade them to components internally, but thats an implementation decision

**Bailey** This is what two implementations I’m aware of - wasmcloud and spin - already do - they accept a core module and then transform it to a component, and execute the component.

**Alex** Just to clarify the behavior of wasm-tools component new, that tool requires there to be type information in some custom sections, that type information has to come from somewhere so the upgrade tool will need to have its own wit/component type information to map the names to component types if the module is stripped and doesnt provide its own. Also you can play with all these internals in the existing implementations. There are plenty of tweaks we can still make to the exact form of the core module in the spec because some of the decisions we made implementing wasm-tools component new were arbitrary and we never asked for input on them because it wasnt submitted to a spec.

**Colin**: So does this mean this removes the need for the adapter?

**Pat**: The reason the adapter exists, before we standardized p2, rust, go, etc. These all use p1in the standard libraries and so we needed to transform those apis from p1 to p2 rather than build our own custom toolchain as part of p2 development, and p2 was unstable so that was changing constantly. Now that we are past that standardization phase, those core libraries can adopt p2 directly. They need to do that to support this target. The adapter is very complex and is the ladder we want to throw away behind us. Randy is doing this for GOOS in go. wasm-ld will produce component.

**Colin**: I wasn’t sure about the triple?

**Pat**: The triple will have wasip2 in it and not use the wasip1 API’s. That doesn’t work yet in some places like in the wasi-sdk/libc.

**Marcin**: This is great, thanks a lot. I think that basically enables us to do what's described in: https://github.com/WebAssembly/WASI/issues/595

**Merlijn**: What about from the perspective of a host component.

**Luke**: Like for the host implementation side?

**Merlijn**: To get a basic bare bones code, we needed to ensure that we were using the abi correctly from within wasmtime. Now looking at this, it would be possible to use components from within WAMR. How do we write the host side of that interface within WAMR? Will this give us some way to get the right bindings that allows us to get the right interfaces. 

**Luke**: Wit will be the input for a host bindgen that each engine will implement. I don’t know how hard or easy it is for that to exist in e.g. WAMR, it should be possible. 

**Alex**: this alternative lowering will increase the likelihood that there are divergent behaviors between implementations. For example resources have some subtle invariants that are hard to get right. So this makes it more important, to me, to have a test suite that covers the nuanced behavior of these general component model wit to module signature things, its a very complicated problem that we have tried to work on in the past so we know its hard.

**Luke** More implementations means more opportunities to get it subtly wrong so yes more important to have a test suite that makes it easy to get all the implementations conforming.

**Pat**: There is a wasmtime crate for wasmtime host bindgen. The way this works for WAMR, it’s up to the WAMR developers. That’s the tool that creates the host bindings that is specific to the host.

**Robin (in chat)**: It seems like it'd be nice to be able to take a fairly plain module (no semantic custom sections) and pass the name/path for a wit world and have that work.
 
**Joel Dice (in chat)**: You can do that indirectly today by taking a bare module and telling wasm-tools to add a custom section to it using WIT as the source.
`wasm-tools component embed`
 
**Robin (in chat)**: It'd be nice if wasm-tools component new could do that for you some producers could avoid an extra step and make their tool only aware of implementing the module type of the world they care about.

**Merlijn**: What tool does the WAMR runtime use to do this bindings generation?

**Pat**: The whole difficulty of it is, “how does your runtime do stuff?”. Take JCO for example, it uses the standard JS API for WebAssembly and builds a component runtime out of that. Wasmtime has it’s own implementation. So WAMR is still responsible for making an implementation of this wit to core wasm bindings. This is making the work for core runtimes simpler if they don’t need all of the power of the component model, and just want to use canonical abi interfaces.

**Nick (in chat)**: every wasm engine has its own APIs

**Luke**: Student implementation where there could be some shared tooling, a hole that could be filled by a new project.

**Merlijn**: One more question about strings. Since this seems to be the thing used for WAMR. Maybe not all platforms will be using UTF-8 strings natively. Is there a way to describe a non-canonical ABI way to describe a string.

**Luke**: With a single fixed build target, you’d be able to do a copy into linear memory. There is also the externref approach that JS is taking. If you create an abstraction in your language, you can do this by creating an opaque handle. This is what GC languages are doing. Right now we are focused on the linear memory languages work well. We can do better using reference types especially in the GC context in the future.

**Alex** I wouldn't want to go the route of having the -component or -module in the target triple. As a user the only thing they care about is whether they are targeting -wasip2.

**Luke**: Yes that lines up with what the go folks want too. What would be the flag?

**Alex**: I think it should be some additional option - I think a linker flag that defaults to invoke wasm-component-ld, and then if they specify it will just invoke wasm-ld instead.

**Luke**: Yes, that’s why there's a unicode snowman on the slide. We can tweak that together and collaborate on the proposal.

**Joel Dice (in chat)**: Any thoughts on supporting the upcoming async lift/lower ABI (and corresponding built-in functions) at the module level?

**Luke**: When we shift to CM Preview 3 we will have to answer those questions for all the new things that are added in p3. Maybe there are a couple ways to name core functions and you get to pick what signature to use based on the name you choose.

**Luke**: What about avoiding cabi_realloc? I want to address that problem orthogonally. Theres a PR CM/#304 to add fixed-length lists that allows a more efficient canonical abi, so you dont have to pass the length as an argument. So what if we extend the signature of read to pass in a parameter length: u64, and the return type is now list<u8; ..length>. This looks a bit like a dependent type but its enforced dynamically, so its an extra contract captured in the type. This is already an invariant that read documents, but we’d be specifying it mechanically here, and then the canonical ABI says because the caller specified the length then they are passing in a buffer that is already guaranteed to be of that length, and the callee no longer needs cabi_realloc because they already have the buffer.

**Luke**: So these ideas subsumes the “wasit2” idea that we had thrown around in some github discussions, its now been split into two orthogonal parts: define a core module target, and provide a way to avoid cabi_realloc.

**Robin**: What if the function does need realloc?

**Luke**: then the runtime calls the realloc function. We are not forcing anyone to use this, some complex types really do need realloc to be passed across the canonical abi and if the host runtime doesn't want to support using realloc then it just can't support worlds that use types like that. The trick is that in core wasm, you have mutable function tables.

**Luke**: I am writing this up in BuildTargets.md of the component model repo. 

# Bailey: publishing the wit definitions on Github as packages

**Bailey**: We are publishing the wasi 0.2 release on Github as packages now! That makes it easier for many tools to fetch the wit/component type definitions of wasi, which previously there was manual work for.

**Dan**: For wasi proposals that depend on other wasi proposals, can we use this to manage dependencies

**Bailey**: We need a tool that completes that - most of the work is done in wasm-package-tools https://github.com/bytecodealliance/wasm-pkg-tools, the cli is named wackage [editor: spelling, link to this]. Taylor, James, and others have been working on it. The tool isnt 100% complete yet but most of this really just started working for a demo last week. So, please folks who are interest start trying to use it and tell us whats working.

**Dave Bakker**: What is a package on github?

**Bailey**: Github supports GHCR, which is an OCI registry. What we are really publishing are OCI artifacts. We opted for this because we are already publishing tarball releases on Github, so this is just a way Github makes it easier to do this mechanically and works with more tools. We are talking to Github people about improving the UI around this - right now the instructions say to `docker pull` it, which actually doesnt work for these artifacts, we are asking them for tweaks that tell the user how to consume these wasm artifacts.
"
main/2024/CG-01-30.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 30th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: January 30th, 5pm-6pm UTC (January 30th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Resume vote for creation of WebAssembly Benchmarking Subgroup (10 mins;
       Ben Titzer / Peter Penzin)
        1. Proposed charter: https://github.com/WebAssembly/meetings/pull/1455
    1. FP16 proposal introduction (30 mins)
    1. Correct Compilation to WebAssembly (20 mins; Ross Tate)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
 - Paul Dennis
 - Yuri Iozzelli
 - Petr Penzin
 - Deepti Gandluri
 - Derek Schuff
 - Ashley Nelson
 - Daniel Hillerström
 - Heejin Ahn
 - Ilya Rezvov
 - Robin Freyler
 - Keith Winstein
 - Francis McCAbe
 - Conrad Watt
 - Paolo Severini
 - Nuno Pereira
 - Behnaz Pourmohseni
 - Fedor Smirnov
 - Abrown
 - Ryan Hunt
 - Zalim Bashorov
 - Jeff Charles
 - Paul Shoenfelder
 - Michael Ficarra
 - Dan Phillips
 - Benjamin Titzer
 - Emily Ruppel
 - Garret Gu
 - Jakob Kummerow
 - Daniel Lehman
 - Mathew Yacobucci
 - Justin Michaud
 - Oscar Spencer
 - Sean Jensen-Grey
 - Mingqui Sun
 - Thomas Lively
 - Kevin Moore
 - Ross Tate
 - Manos Koukoutos
 - Yury Delendik
 - Emanuel Ziegler
 - Chris Woods
 - Alon Zakai
 - Johnnie Birch

### Proposals and Discussions

#### Resume vote for creation of WebAssembly Benchmarking Subgroup, Ben Titzer / Petr Penzin

Proposed charter: https://github.com/WebAssembly/meetings/pull/1455

PP presenting

PP: All review comments addressed, how should we move forward with the vote? 

CW: We should take a unanimous consensus vote if no one objects

BT: We could go through the charter. there’s a slide deck, presenter couldn’t make it

https://docs.google.com/presentation/d/1sRqdavuuMU5sMwESmcHou4_oZih_SzrIZvhbEhDuWKA/edit#slide=id.p

BT presenting

Deliverables are fully enumerated in the charter in the PR, this slide is condensed.

SJG: this is great, the charter is small enough to make progress and be inclusive of what we want to do. Where do you see this going in the near future?

PP: I think we ‘re just going to start with regular meetings, we’ll be collecting some info on the status of tools & meetings - it’s definitely interesting to track some of the performance data. It’s similar to any subgroup, we have ongoing discussions and some things can come out of it, its not specifically tied to the deliverables

CW: we’re running short of time, if there are no objections, we should take the poll and take extended discussion offline.

SJG: It doesn’t sound like you’ll be working on canonical Wasm benchmarks, it’s not going to be producing “the” standard benchmarks for WebAssembly

BT: right.

CW: Unanimous consent poll for creation of the Benchmarking subgroup Petr Penzin
And Saul Cabrera as co-chairs. Please speak up if anyone has concerns. 

Consent poll passes.


#### FP16 proposal introduction, Ilya Rezvov

IR presenting: https://docs.google.com/presentation/d/1XmpxUW8syWQuWU-zvuyBhCZE6fJ1hWCQo_rcEkuQsnQ/edit#slide=id.p

PP: what happens when you have a CPU that only supports load/store? What’s the overhead?

IR: We expect software emulation will be used, so pretty slow - you also have the Nan propagation - we know who uses this - we only have one use case for F32, but does that apply to F16? 

PP: wrt NaN propagation: we have the rules in the spec: we know who uses this for f32/f64 scalar, i’m not sure the use case extends to SIMD, we dont know of any.

IR: initially it will be emulated. If someone wants to use F16 number, for now it would be a userland library, and I think it can still perform better than emulation in user space, even for vectors. For NaNs, I agree; there are 2 opposing forces: one is consistency with other parts of the spec, the other is more efficient on existing hardware. But I don’t know of any actual need for this logic for F16, we could drop it,


CW: What is the bit pattern you’re suggesting in terms of relaxing the FP16 semantics

PP: probably just the bit patterns, to have a special canonical number. Probably IEEE.

KW [chat]: Could you speak to the determinism of the proposed semantics? Will it be similar to existing f32 and SIMD ops, where the only nondeterminism is in the binary representation of NaN? Will f16 necessarily mean IEEE binary16 (and not bfloat16 or some other f16 format)?

IR: we can do determinism because there’s no divergence yet between ARM and Intel implementations yet. The only open question is NaNs. I think we can get the nto the same umbrella as other FP numbers, and maybe have 2 profiles for deterministic and nondeterministic representation. 

PP[chat]: FP16 is IEEE FP16 :)


CW: we’ll want to get Andreas and others involved, they’ll have opinions

IR: On the list as well, and potentially there will be more proposals to extend BF16. I could imagine it is more controversial. Definitely demand but still need more research to bring to Wasm, but it’s coming.

DG: wanted to mention, FP16 is IEEE FP16, I do prefer to make sure that we preserve those IEEE semantics across the proposal. The other caveat is that we experiment and get data before we make the actual decisions there. Also, when you said this proposal would include some relaxed SIMD ops, is that just FMA, do expect deterministic semantics for that, or relaxed? (e.g. hardware vs software fallback)

FM[chat]: is there also a case for adding i16. This may be important for managed memory languages.



IR: Yeah, as I said we have opportunity to have deterministic semantic for FMA right now. It could be less non-deterministic here.

DG: to clarify, you mean we’d only offer hardware FMA and not the relaxed multiply-addlike the relaxed SIMD proposal?

IR: Yeah

CW: I’m scared of that and want to know better but we don’t need to dig into the details right now.


RF[chat]: 
Could we have F16 SIMD shapes without having an F16 scalar type? Similar to i8 and i16 SIMD shapes without i8 and i16 scalar types in the spec so far.

IR: chat: do we need F16 scalar: good question. Generally we’ll need all the machinery for scalar values anyway for implementation, I can imagine it will be convenient to have scalar representations for the lanes etc. we could use F32 but there is no hardware analog of i16, but there is F16 hardware support, so it makes sense to have scalar type in wasm as well

CW: IIUC one of the complications is having i16 in the SIMD can be apprixmated by i32 Scalars just by taking the lower half, but fp16 isn’t the lower half of fp32. Is that correct?

IR: yes e.g. you can’t easily extract a lane and the precision isn’t the same is just half an F32

PP: BF16, is half 

PP[chat]: bfloat16 can be partially implemented by targeting fp32 ops, at expense of memory usage
for situations when it is possible to take half of a regular float, obviously not bfloat16x8

MF[chat]: FYI the JavaScript Float16Array proposal uses IEEE binary16 and it'd be pretty weird for wasm's f16 to not match

CW: Comment in chat from MF “FYI the JavaScript Float16Array proposal uses IEEE binary16 and it'd be pretty weird for wasm's f16 to not match”

IR: yes, the proposal currently matches JS using IEEE754-binary16 (Opcode space and binary format slide)

BT: IS there a minimal subset of just adding a scalar subset, and a load/store conversions between Fp32 & FP16 - we could introduce just the conversions and not the arithmetic ops? Some operations like addition and Subtraction would have rounding that can be done in the user space

IR: Assume any engine would be able to not be able to extend is lazily to f32 and then perform all operations natively, is that correct?

BT: My understanding is some operations like ….? Can be rounded and back Ben Titzer FIX ME. Frightens me that every engine can do that. Wondering if there is a subset of this proposal that gives the engines software emulation above Wasm.

IR: you’re proposing only a scalar representation with no vector operations?

BT: Not sure which 2 I would prefer but seeing if there is some subset of this proposal that makes sense.

IR: Personally I’d prefer the scalar operations for consistency, for when you want to just load/store having promotion and demotion would be sufficient - It’s not much of a burden to implement it especially if we want to add them

CW: i think as the proposal evolves we should have a document saying what the emulation should be, like we did for relaxed SIMD. Not a requirement for phase 1.
I think it’s reasonable to do a phase 1 poll (previous convention was we don’t need far advance notice for phase 1). I would propose to do it by unanimous consent. Concretely shoudl we move F16 to phase 1. Are there any objections or does anyone want to move to a full poll?

PD[chat]: the rounding variants proposal is planning to use 0cFC instructions as well:
https://github.com/WebAssembly/rounding-mode-control/blob/main/proposals/rounding-mode-control/Overview.md

JK [chat]: the binary encoding is an implementation detail that is highly bikesheddable and can be decided late in the overall process. FWIW, SIMD/relaxed-SIMD already goes all the way up to 0xfd113 (if I didn't miss any), so continuing there (in 0xfd...) with another couple dozen instructions is likely also a viable option.

CW: We can bikeshed on that.

PP: Want to see how slow this would be on emulation without hardware data? 

IR: my initial implemetatino will probably be with emulation, so we’ll see.

CW: I don’t think that needs to be a phase 1 requirement, are you still OK with that?

PP: Depends on what we think is Phase 1?

CW: I think we’ve cleared the bar of whether the proposal is in scope and worth investigating.

AZ [chat]: Just a thought, for the few f16 operations that can't be done using f32 promotion/demotion (iirc, sqrt fits that for f32/f64, but not sure about f16/f32), allowing some nondeterminism is another option. That is, to allow the result that is computed in f32 as well, in the spec.

MF [chat]: I think the scalar portion is much less motivated than the vector portion of the proposal, and it probably shouldn't occupy much of the single-byte opcode space, but no objection to phase 1

#### Correct Compilation to WebAssembly, Ross Tate

RT presenting [Slides](presentations/2024-01-30-tate-correct-compilation.pdf)



CW: at the wasm language level, if something’s not exported it can’t be accessed, but we’re not mitigating logic bugs which might cause unexported memory or functions to be accessed.

RT: I would guess that we agree that you should be able to rely on imports not accessing unexported things.

CW: should only hold so long as linked modules conform to the ABI the program was compiled against.

RT: How would they access memory that they don’t have access to?

CW: if you link a hostile module that could forge pointers in linear memory you’d break the semantics

RT: In this example, the imports/exports don’t have addresses to memory unless they are forged somehow

CW: maybe i’m not fully anticipating your example.

RT: it’s fine these are good questions. I’ve set up tihs example such that there aren’t any of these pointers, so in this setting you should be able to assume there’s no forging

CW: If you have a module that doesn’t export a function that doesn’t do anything weird with exports, that could work, but maybe that is still going to come up

RT: so this program is correct and not doing anything weird, and i’m trying to make it so no other programs can make it do something weird. Here it’s possible to make the program launch missile, not by  messing with its memory but with its control

(slide: launching missiles)


CW: You have to be cautious about the analogy here, you’ve added JS here which is in some way forging the pointer, 

RT: JS isn’t forging a pointer.

CW: You have compiled Wasm and taking an i32 and Wasm interprets that as a pointer, right?

RT: If the Wasm program was to catch the trap, then it wouldn’t be a problem, if you unwind the stack then it’s no problem. The only privilege that JS has here is that it can catch the trap.

CW: Isn’t the point that you can call bar with an arbitrary input? 

RT: bar is callable with arbitrary input in the C program but still won’t have this problem.

BT: The issue is that Wasm allows modules to be reentrant in a way that other embeddings don’t, and because of that if you unwind the Wasm stack, a virtualized thing, if there is state aligned like a shadow stack, because you cant catch traps, you cant fix its state properly. Because the host module can, you’ll be in an invalid state.

RT: yes, thanks. To clarify, this C program can handle reentrancy. The issue that the C runtime relies on certain assumptions that would be tru other places but not in wasm with traps.
So we can use these “mismatches” to make wasm programs do things they shouldn’t be able to. It’s hard to directly compile runtimes to wasm because wasm is able to do things these runtimes need to be able to manage.

Not proposing this now, but a way to fix this would be to enable catching traps, or catchines all exceptions and traps, and allow unwinding from both cases. (slide: fixing traps)

AZ [chat]: +1 to Ben's point. In practice in toolchains JS would be responsible for unwinding the shadow stack as well, to avoid this problem. Otherwise it is breaking the wasm program's ABI.

BT [via chat]: Right, I see this as a problem with the host environment reentering Wasm, and this is fixable at the host boundary to reestablish the ABI (e.g. resetting the shadow stack)

PP [chat]: Wouldn't this require standardizing how shadow stack works? +1 on both of these points

DS: Interesting property of the problem is that this is the interaction between the program, and the host environment that causes this problem. Interfacing with JS, you have reentrancy after traps, and maybe other unexpected control flow (JS exceptions unwinding through C frames) that causes this problem. With the exceptions proposals, we’re allowing the importing the JS exception type, which doesn’t completely mitigate the problem (doesn’t deal with traps), but helps somewhat, giving programs a way to mitigate the JS exception part. I’m not sure I’m sold on giving this as a guarantee for every embedding - we can’t guarantee what the embedder provides, they all at least have access to memory

CW: Kind of like the more intricate version of the obvious problem at the source level, even if you look at your program and have certain guarantees, at the Wasm level, maybe the memory is just exported and JS can inspect it. This is playing with the version of maybe you have problems even if you don’t export the memory. We already kind of accept that as something possible to happen.

AZ [chat]: The wasm and the JS need to agree on the shadow stack, and other ABI details, yes. And they do, as documented in the tool-conventions repo and as implemented in LLVM, Emscripten, and others. It is easy to get wrong, though!

RT: High level thing to ponder: You have  to trust the embedder, what standards of embedders could we provide so that we could have stronger compilation guarantees. My compiler for example has this guarantee that my compiler won’t launch missiles for example, the embedder should be able to guarantee some things.. 

CW: interesting, i think it depends on who “you” is in this scenario. If you take someone else’s wasm module and want to mess with it, you have a lot of power when you instantiate it and what you link it with, you could at least get its memory probably. It’s hard to provide guarantees when you have this capability.

PP: The problem is not that someone can maliciously do something, but there is room for accidentally hitting something.

RT: in security there’s the notion of trusted computing base. Ideally for my program, this is the only program i give missile capability to and i want it to be the case that this is the only program I have to trust, I don’t want to rely on a big expanded trusted computing base, i only want this one program that I’ve analyzed thoroughly

BT: I get where you’re going - the program has a source level guarantee - that’s hard top guarantee - instead you want to specify what the reentrancy model of your program is - you have to stick to what you can specify in terms of guarantees. 

RT: In order to compile this correctly, I should anticipate that the shadow stack would be exposed…

BT: Yes

CW: On the web, this is the wrong way to think about this - the person who cares about the TCB is the person deploying the final blob of wasm and JS - if a separate person compiles the Wasm module, they can’t protect against the deployer messing with it


"
threads/2024/THREADS-01-23.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the Jan 23, 2024 video call of WebAssembly's Threads Subgroup

- **Where**: zoom.us
- **When**: Jan 23, 2024, 5pm-6pm UTC (Jan 23, 2024, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/mUp4nmiVUTNQDKcD9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Continue walkthrough of proposal overview
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Dan Gohman
- Daniel Hillerström
- Conrad Watt
- Sulekha Kulkarni
- Manos Koukoutos
- Francis McCabe
- Luke Wagner
- Andrew Brown
- Nick Fitgerald
- Zalim Bashorov
- Shu-yu Guo
- Ilya Rezvov
- Ashley Nelson
- Alon Zakai
- Emanuel Ziegler
- Jakob Kummerow
- Paolo Severini
- Yosh Wuyts

### Proposal Walkthrough

TL: changes from last meeting are in https://github.com/WebAssembly/shared-everything-threads/pull/28.

TL: presenting https://github.com/WebAssembly/shared-everything-threads/blob/main/proposals/shared-everything-threads/Overview.md

#### Thread management

TL: Discussion about thread management primitives in the component model is happening at: https://github.com/WebAssembly/component-model/pull/291

#### Managed waiter queues

CW: Are we considering the version where we consider an eqref instead of i32?

TL: Yes, there are a few different versions we may want to have. You can imagine you have an i64 control field instead of an i32 field. SYG suggested this so you can have more data in your control word. Extrapolating from that, you can imagine having a version with a shared eqref, let you use references or linked lists. Imagine constructing a WasmGC shared queue structure where it stores references in that control word. I suspect we’ll need these at some point but to avoid having a ton of new types in the initial proposal, right now the normative text says we only add one with i32.

CW: Provocatively, what about just an eqref?

TL: True, if you just had eqref, the problem is if you have eqref, you can store an i31 in there, but you can’t use any arithmetic that we may add for i31.

CW: Still can do the CAS loop trick we described and that's how you’ll have to do all i31 atomic operations anyway.

TL: Could start with that, the reason we started with i32 is its similar to a native lock implementation where you have a couple of bits that are useful and having i32 lets you do all the atomic arithmetic you want on those bits. Not sure how important that is. We can start and have toolchain developers tell us what they need, add more in response to that.

CW: Sure, just thinking if there is one waitqueueref type things are easier; otherwise, types are messy

TL: If you have to pick one, the most general one is the eqref one? I’d be fine changing the text so specify the eqref one first. I suspect we’ll need multiple anyway.

SYG: Not mentioned here, but we need to hammer out the lifetime of the waitqueue; if we lose references to waiters in the queue if ? dies, what happens?

TL: Great idea. Do you have any idea what behavior would make the most sense?

SYG:  From a tool view, it should be kept alive if there are things blocking or in the wait queue itself, that should keep it alive. For a linear memory lock, you wouldn’t expect that your lock would disappear from underneath you.

CW: What happens with SharedArrayBuffer (SAB) today? We can wait on a SAB and then drop it, what happens?

SYG: I think it leaks. This doesn’t show up for blocked threads because it's likely that if your thread is blocked, it's already independently keeping a reference to the SAB. But you do see leaks today with wait-async. Fire some promises and for whatever reason the SAB leaks. For the application, it would be easier not to keep these things alive if there are things in the queue. And I think even in the implementation, this object dying waking up for everything in the queue means there needs to be a finalizer and that's not a cheap operation in every VM. Maybe something we want to avoid.

CW: my instinct is if someone creates a waitqueueref and then drops it, it is the programmers responsibility–you deserve whatever happens at that point

TL: If the thread is blocked, it's not semantically visible whether it gets GC’d or not.

CW: Need to be a little careful about a wait with a timeout–some nuance there

TL: Our  current wait instruction takes a timeout and if you want infinite, you put -1 there, highest possible timeout. CW is that infinite or maximal number of nanoseconds.

CW: infinite

TL: Then you could collect those because they would never wake up on their own.

CW: that’s what I would expect; generalize to other shared things, if the things waiting are dropped, can we drop the thing we’re waiting on?

TL: Why not, no way to observe it if you collect them, right?

CW: What guarantees do we want to give in the spec? This could come up in JS today, we’re making a big deal with waitqueueref but I could imagine constructing these examples with SAB and I don’t think engines are going out of their way to specify what happens in that scenario.

SYG: No guarantees I think. Wait-queue does not add any more expressivity. This just removes the memory address key indirection. I suspect not a lot of thought has not gone into this from the JSVM folks (myself included) because the use cases are pretty well behaved. Not doing novel things here. My bias is to let it be impl driven if the collection of impl in the room say it's hard to implement. 

CW: take our lead from SAB; spec doesn’t say. You could imagine an engine doing it or not–the JS doesn’t say anything, right?

SYG: Spec does say a thing I think because it has to say a thing about finalization registry liveness. If the finalization registry itself dies, the impl is free to not fire the finalizer based on impl feedback. If you work out what the JS spec says about SAB and indefinite? Blocks, technically you can collect it all. Because we spec observable liveness without a rigorous notion of observability because we didn’t know how to write it in a way to prohibit things we didn’t want to. Not a question of reachability. If there exists some possible execution where you can observe (handwavey) the identity (reference equality of something_ if such an execution exists, you say that thing is live. If no possible execution, you say the finalizer can be fired. If a block?? Is blocked indefinitely, it seems like you could collect it all.

CW: If the thread is blocked indefinitely and the engine can prove all the waiters have been dropped, then the roots can be GC-ed.

TL: Wasm core spec says nothing about GC or when things get GC at all. But if there is a finalization registry, we would want to say something in the JS spec for Wasm about when infinitely sleeping threads are allowed to be collected.

SYG: A non-normative note explaining what the JS spec already says.

TL: CW, you agree those notes would go in the JS spec instead of the core spec?

CW: 100% until Wasm gets finalizers.

SYG: eqref is what, the things that have identity?

TL: it’s a subtype of anyref, so only Wasm-internal references (structs, arrays, i31)

CW: it’s all the types you can do a compare-exchange on.

SYG: And the atomic operations are allowed, store, load, swap, compare and swap ..

CW: You need an eqref to do a compare and swap because those are the only types that have comparison defined. You can implement any arithmetic on this type by doing a CAS loop.

NF (via chat): seems like it would be an application error if the wait queue is non-empty but the only references to the wait queue are those waiting threads. That is a deadlock, no?

CW (via chat): only if the wait doesn't have a timeout. but you could wait forever without being notified even if the SAB is kept alive

NF (via chat): we could possibly detect this case and raise traps in the waiting threads

#### Memory model

TL: (presenting)

#### JS API

TL: (presenting)

CW: `nofunc` can also be converted to `shared nofunc`--is that true when we have an exception type?

TL: This isn’t saying that nofunc can be converted to `shared nofunc`, its saying that JS values that can be converted to references to `nofunc` can also be `shared nofunc`. The only JS value that allows this conversion is null. So basically saying null can be converted to `shared nofunc`

CW: Scared of that, but need to think more about it.

TL: This conversion might be a conversion, not a cast; representation can change at the boundary (e.g., JS null is different from reference to none).

CW: Imagine you have an exnref that is unshared, I believe that is a subtype of `nofunc`. No wait, `nofunc` is a func null. Oops I’m totally wrong. Nevermind.

TL: Explaining `nofunc` is the bottom for function references.

TL: (presenting at “JS strings”)

CW: Back to `nofunc`, imagine a case where the non-shared function null has a diff representation from the shared function null which would happen if they are in different heaps. Because of JS, you now need to test the boundary to change their representation of one. I remember JK being scared of that test because you need to add a little cost to every boundary crossing.

TL: For ToWebAssemblyValue(...) the JS-side thing is a JS null; no way to refer to Wasm null, it would get converted to JS null. In SM this has the same representation but V8 does not do this.

CW: Is it already the case that Wasm null is eagerly converted to a JS null representation?

TL: Yes.

CW: Definitely true everywhere? Guess it makes things simpler.

TL: Wasm GC JS spec says this–eager conversions (should double-check this)

CW: The point about any value that can be converted to nofunc etc, the only possible value is a JS null?

TL: I believe so, yes

JK (via chat): no check/conversion happens when the Wasm-side type is externref

TL: Is it because the externref null is the same as the JS null?

JK (via chat): Yes

TL: is null a sharable value in your JS proposal?

SYG: Yes; the shared/unshared distinction does not apply to primitives. Too crazy to split the world on primitives; easy on paper. There is an implementation challenge, but mostly around string. Null is read-only, never changes.

TL: We have several null values, you can imagine saying an externref null is convertible to a shared externref null, must have the same representation. Similar to nullref null and shared null ref.

SYG: Is the set of nulls innumerable?

TL: No, only three of them.

SYG: If there’s a small, finite number of them, what’s the challenge? Make them always shared.

TL: CW, do you know if it's possible in the type system to say that a shared null ref is equivalent to a non-shared null ref. There’s no way you can compare them?

CW: It’s strange: possible in principle but it would not allow you to write more interesting programs. A bit scary…

TL: How is ref.eq going to work? Are we going to have shared ref.eq? Extend the typing of ref.eq to take as either of its arguments, shared eq or non-shared eq, mix & match, and it's fine?

CW: May bother Andreas about principal types. Also, I broadly like the waitqueueref idea but we should show it to him–he will have informed opinions.

TL: Yes we should make him think deeply about it and tell us what he thinks, for sure.

TL: (presenting at shared constructors)

TL: Do I remember correctly SYG that you do not have a strong opinion here?

SYG: No strong opinion on Shared* vs re-using the same constructors. Awkwardness in how they behave very differently if we use the same constructor. If it’s just tools that use them, not too worried. Not much prior art here (e.g., SAB vs AB)

ZB (via chat): we have separate constructors from ArrayBuffers

FM (via chat): JSPI used the same constructor for WebAssembly.Function

CW: Francis made a good point in the chat with the precedent of JSAPI using the same Wasm constructor. 

TL: Those are currently described as an option bag–a mix-and match approach

CW: For SharedGlobal not interesting; SharedFunction has all the new `bind` functions…

TL: That one is also currently specified as an option bag on SharedFunction. I’m in favor of using simple constructors and doing this all with option bags. 

ZB (via chat): in case of using the same constructor, will instances have readonly property like `shared`?

CW: For resizable buffers, is there any way to observe this in JS today?

SYG: Yes, it says false for the existing ones and true for the new ones. I guess it says undefined on the existing ones before the new proposal implemented, which is false-y

CW: Maybe do the same thing for our objects?

SYG: Caveat, for the usual use case there is a read-only property like ZB asked, the difference is resizable buffers have one getter on the prototype that’s shared and this being JS and everything observable, you can tear the getter out and keep it around as a function and observe its reference equality. For the shared stuff, you will not have the same getter. .shared is fine, but storing a reference to the same function for whatever reason, they will be different functions. Not going to be completely analogous. 

CW: Is that because of cross-realm stuff?

SYG: Yes. It’s because of cross-realm stuff, but it’s because we can’t share JS functions, why we have TLS to begin with. If we could, you could imagine having just one shared accessor, but we don’t so we end up duplicating across every realm.

TL: Existing SharedMemory has a read-only shared property; can we do the same thing for all these objects? Is it a getter or a property?

SYG: It's implemented as a getter, no implementation would incur an extra word or constant thing that never changes.

TL: Tricky.

CW: My understanding is one of the things that makes SAB weird in this context, is it's an unshared wrapper on a shared buffer - their decisions about a “shared” bit may not work for us

TL: Important note; these shared things will be different than a Wasm shared memory; SAB is a wrapper under the “actually shared” buffer. Same with WebAssembly.Memory. These new objects would actually be shareable–could postMessage it around and have reference equality. This is important for scalability: many more shared globals, e.g., than shared memories.

#### Thread-local JS Function Wrappers

TL: (presenting)

CW: Throwing around `bind` instead of `set` because we have an idea that you can only bind once per thread, otherwise there would be errors. `Set` sounds like a global variable you can reset if you want to a different value.

TL: True, we do specify that it can only be set once. Maybe `bind` is better there? Name-clashes with existing `bind` function?

CW: Very good point, I’m sorry I forgot JS exists, maybe we need to bikeshed on the name a little bit.

TL: I think `WebAssembly.Function.bind` already does a thing.

CW: Another question about inlining–can it be done with a speculative guard? Something for engine implementers to think about.

TL: I know inlining JS into Wasm is already not possible in V8 so doing it in a thread-local way.

CW: Isn’t it done for certain special-case functions: sqrt? If it’s thread-local, can we get the same benefit.

SYG: One issue: we want not only the steady state to be fast, but also loading to be fast. Need to know the structure of the thread-locals before loading a new thread. Ping-pong communication–not what we want. Hunch is it’s not a problem for Wasm: it could load the same payload on all the threads. They know the TLS structure ahead of time…

CW: Wouldn’t be a serialization point, the toolchain when it gets created by the WebWorker would have this static list of things to initialize.

SYG: Good property to keep in mind; e.g., if class loading has a handshake, it affects load time.

CW: There is a serialization point with this design. The thread that creates these thread local functions initially, is responsible for sending them out to the web workers that are created subsequently. But you could do it easily with a shared table, put all the items there, then you don’t need to serialize as much

SYG: Any postMessage at thread load is a PITA; calls for an implicit communication channel on the JS side.

TL: We’re in that world today with Wasm because today with Wasm you have to post your entire module over when you start it up before you can call into Wasm. In this shared-everything world, you have to post your entry point but also probably your exports.

CW: That’s a win: postMessaging a single function instead of the module + instantiation. We are not getting away from one initial postMessage though.

"
main/2019/CG-05-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 14 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: May 14, 4pm-5pm UTC (May 14, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email Ben Smith to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Discuss: development of a WebAssembly dashboard (similar to [wpt.fyi](https://wpt.fyi) or [test262.report](https://test262.report))
    1. Update on [custom annotations proposal](https://github.com/WebAssembly/annotations/blob/master/proposals/annotations/Overview.md) (Andreas)
       - spec, interpreter, tests complete (see [this PR](https://github.com/WebAssembly/annotations/pull/4) for details)
       - POLL: promote to stage 3?
    1. Adding [Security and Privacy section to spec](https://github.com/WebAssembly/spec/pull/1015)
    1. [Passive element segment binary format](https://github.com/WebAssembly/reference-types/issues/31)
       - [Slides](https://docs.google.com/presentation/d/13F46ycthgp-0a8HP03lVU7QzEBTPJC_A8JGj739THis/edit?usp=sharing)
       - The current format is more general, but larger (~3 bytes for function reference, allows heterogeneous segments)
       - A suggested format is smaller, but less expressive (~1 byte for function reference, only homogeneous segments)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Alex Crichton
* Arun Purushan
* Conrad Watt
* Dan Gebhardt
* Dan Gohman
* David Piepgrass
* Deepti Gandluri
* Derek Schuff
* Francis McCabe
* Guanzhong Chen
* Heejin Ahn
* Jacob Gravelle
* Keith Miller
* Lars Hansen
* Lilit Darbinyan
* Luke Imhoff
* Luke Wagner
* Mark Miller
* Michael Starzinger
* Mingqui Sun
* Mitch Moore
* Nick Fitzgerald
* Pat Hickey
* Paul Dworzanski
* Paul Schoenfelder
* Peter Jensen
* Richard Winterton
* Shravan Narayan
* Sven Sauleau
* TatWai Chong
* Wouter van Oortmerssen

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Jacob Seconds

### Proposals and discussions

#### Review of action items from prior meeting.
BS: Review licensing issues for WASI, CLA specifically does not cover software - we can cover whatever license we like. Do the normal thing with SW licences. They suggest Apache. Any questions?

#### Discuss: development of a WebAssembly dashboard (similar to [wpt.fyi](https://wpt.fyi) or [test262.report](https://test262.report))

BS: Contacted by some people from Bocoup when adding some tests to WPT tests repository. We already have JS and web API tests in WPT. That PR has been stale for a while - concern was that they were not keen to open up an upstream, they are not excited about maintaining that because we need a new tool (Reference interpreter is required to convert wat files to JS). They suggested having a separate dashboard for Wasm tests. One reason, might be useful for non-web VMs to have a different dashboard.

Two questions - Are we interested? Who will pay for it - who will do the work?

AR: Argument that it’s useful for non-web uses, but how is it useful if it’s on the web?

BS: It’s just an easy place to query status. Take a look at test262.report or wpt.fyi for examples.

AR: Seems useful, someone has to do a lot of work initially, someone else has to maintain it. What happens when the engines are not maintained?

BT: They were receptive to doing work (Bocoup). I suggested they work on one-way sync as well.

PH: Fastly is interested in helping out

DE: There was interested in following up on BT’s design, not sure if we should agree so quickly that it should be separate.

BS: Raised a concern that we want to have them on WPT anyway so this may not be an “either” situation but “and”

AR: Why in both places then - seems like extra work?

BS: Maybe for non-web embeddings? 

SS: Could you please send the link to the PR/Issue? I can't find it in the notes/agenda

BS: https://github.com/web-platform-tests/wpt/pull/16321

FM: if we have a non web dashboard, does this involve splitting up the tests themselves - i.e., do the tests rely of web binding?

BS: We already have a precedent for this, tests are run in the environment that they’re relevant to.

BS: Trying to get a flavor of the room here, looks like there’s general interest, but also trying to push forward with WPT as well.

Meeting: [Silence]

BS: Taking it as a yes


#### Update on [custom annotations proposal](https://github.com/WebAssembly/annotations/blob/master/proposals/annotations/Overview.md) (Andreas)
- spec, interpreter, tests complete (see [this PR](https://github.com/WebAssembly/annotations/pull/4) for details)
- POLL: promote to stage 3?

AR: Specced, and implemented it - let me present. 

Generic way of adding annotations to the text format - engines not affected. Have a way of adding s-expressions that start with @ - this could be a way to add custom ways of adding custom syntax. Some examples: binary contents of custom sections, name section, web-idl bindings. … Specifying a list of tokens in the spec
Added name annotations, and custom annotations in the appendix (more informal spec of both of those)
Saw some PRs for wabt?

BS: JG implemented some parts of it

AR: These are treated like a comment/whitespace, can be thrown away by a parser that doesn’t want to parse. Giving update that the Spec, and reference interpreter are complete - meets requirements for phase 3. This was possibly required for WebIDL proposal, so can we move forward to Phase 3?

JG: Have been playing around with this for the WebIDL bindings, useful to have.

TL: Useful for toolchain custom sections, is the producer section, or target feature section. @custom notation an example, or is it a recommended notation?

AR: Can go to the appendix to show it - dumps the contents of the custom sections, you only want to use it for sections you don’t understand.

JG: Is @custom part of the spec or a handshake that’s agreed upon?

AR: It’s like custom sections, you’re free to ignore it. Up to the tools to interpret

TL: Provide both the @custom, and the human readable form -- may have to specify it twice depending on the tools, whether they understand it or not.

AR: Handwaved around the problem, for e.g. you have name collisions it’s basically up to the tools to decide what to do with that - if you’re not able to interpret the names section then you don’t know much. But if you can interpret the name section then you can... don’t know how to define rules for this situation.

JG: Agree that it’s up to the tools - if you’re running your wat through a tool that doesn’t understand the custom section - what does it do?

TL: Preserve it for future tools hopefully.

JG: What about debug information? For metadata, preservation is important, but for others.

AR: There’s a lot we can do here - it’s a problem of the custom sections solution.

BT: There may not be a general solution, but a solution built on top of byte offsets is possible -- so something to think about it. If there was a convention for byte offsets, you could update it.

AR: We’re talking about custom sections now, not annotations. Relocating byte offsets in custom offsets is tricky, doesn’t seem like a general solution.

JG: Solving the general byte offset proposal seems out of scope for this proposal, including more info to indicate whether this is metadata may be useful - more of a tool convention problem.

AR: That’s a problem for custom sections first, right?

JG: It would be a tool convention.

BT: What are the mechanics of implementing a transformation function; do I implement it as an extension to a tool that processes a binary, is that what you had in mind?

JG: Your tool needs to understand the annotation -- it’s hard to specify byte offsets in general.

BT: Is the annotation processor implemented in the assembler, how does this work? I don’t want to create a processor for the entire text file just for my one section.

AR: You mean how to implement a generic parser? Gives you generic information about the custom annotations?

JG: If you’re not shipping your own assembler, then you need a plugin to do it.

AR: We have a version of the reference interpreter where we use custom sections -- the lexer spills out a big table of all custom sections with their source regions, and the AST is annotated with the source regions as well, so you can match them up. You could have a plugin sysmem for this - ultimately this is all out of scope for this spec.

JG: The wabt lexer also does this, where it keeps source information for each token. The parser then skips them if it doesn’t understand them.

TL: Lot’s of tool conventions that come out of this proposal -- if this proposal comes with a non-normative spec with custom annotations for names -- it would be good for them to be unambiguous about them -- how do they behave in custom sections.

AR: It’s in the appendix for a reason - if you find a name section that you don’t understand you can ignore it. For the name annotations I did the same level of preciseness.

FM: Did you consider following what the JVM does? They put a specific semantics in the binary for annotations. This is useful for class-loaders and dependency injection.

AR: You mean annotations in the bytecode stream?

FM:Yes, engine is free to ignore it -- is this an actual annotation or a glorified comment? If an actual annotation, then support modifying the bytestream as well.

JG: I would consider this to be a annotatable lexer comment.

BT: Agree with FM. There should be a default translation to a binary section, that would be the most useful.

JG: Useful, but very complex -- clarification as glorified comments is true, the niceness about this proposal is in its simplicity.

FM: If you modify the name of the function, it’s more than a comment.

AR: But the name has no semantic meaning. This is the same as custom sections -- it’s just a hook that tools can use.

BT: Because this is only in the text format, it’s only useful for the text format. [AR,JG: yes] Annotations don’t roundtrip.

AR: The idea is that you can roundtrip from binary to text and back, because you can use the @custom syntax. The other way only works if you forward annotations you understand.

BT: What Francis is saying is that the JVM doesn’t understand the annotations, but there’s a format to understand. Annotations are inherently tied to syntactic elements and this leaves it totally up to the tools how to use them.

AR: We would need to extend the binary format -- this would be a major change to the binary format.

BT: You don’t have to do that... we should have this discussion with more context about the JVM, and how it handles custom annotations.

FM: You can’t put an annotation anywhere in the JVM, it has to be in specific places the binary format reflects that.

AR: You realize you’re talking about the binary format and not the text format.

BS: We are now moving into the design space -- there seem to be a lot of open questions, design should move to the repository.

JG: I’ll continue to use this... What would be the purpose of standardizing?

BS: Needs to be in the spec.

AR: Having a more structured custom sections format -- we can overlay all of this on the current spec with more structure in tool conventions or someplace else. That was the intention all along, to keep the core spec minimal as possible, so you can overlay with more structure elsewhere. The main spec shouldn’t have all this detail -- does that make sense?

JG: Want to go there, but not in this proposal.

BS: We should have more discussion offline -- there’s enough difference of opinion.

AR: Concrete suggestions on how to move this forward?

BS: Have discussions about binary annotations, and whether it will be in the same proposal or outside.

AR: Should be a separate proposal, not sure if I understand the discussion anywhere.

FM: There is a difference between having a text representation of a custom section and  annotations everywhere. In the case of the latter, is it expected that the tool preserve such annotations? (There are examples of ‘special comments’ in JS that JS tools need to preserve if they want to preserve the semantics of the JS module).

AR: It’s not.

JG: If you do not recognize the section, then don’t preserve this.

BT: Let’s talk about it offline. It’s likely that many tools will want to preserve the annotations by default.

DP (text comment): It seems to me that the @custom annotation specifically should be standardized now to enable round-tripping. Arbitrary annotations can simply be ignored by most tools for now, but the interpretation of them could be standardized later in a separate proposal. I would be curious to hear if people see a risk to allowing arbitrary annotations (e.g. conflicts between tools). Other than such risks, if any, the proposal (in general) seems reasonable to me.


#### Adding [Security and Privacy section to spec](https://github.com/WebAssembly/spec/pull/1015)

BS: This is a bit of an annoying sticky point -- many W3 specs have this specific section, advised by the process document. In the core spec, privacy is hard to have an opinion on -- to what extent do we include the section that’s advised, but not super relevant.

EP: In the case of the W3 core spec, it’s useful to say that it’s a VM, and possibly not relevant to the core spec -- don’t think of it as a part of the spec, but tells people that it’s an annotation on the spec, and sets expectations. I’d like to tack it on to the end where people expect it -- so people that are not reading the spec, can look for it and find it. I also wanted to have a forward reference from the core spec’s privacy and security section out to the JS API spec, since it’s likely someone reading the core spec would wonder about it.

MM: I have questions -- not familiar with W3C practice with regard to specifying privacy/security -- Wasm itself has pretty strong security property, where is a good place to specify that?

EP: Can write a more detailed section, and point to the right place.

MM: Some examples of security properties -- wasm instance is not affected by outside influences, or sense effects other than granted by environment, forms a perfect sandbox for executing untrusted code. The export/import mechanism from one wasm instance to another, in the absence of shared memories or tables -- that’s a perfect domain crossing. The caller/callee can only interact through the semantics of the function. Wasm has no dynamic non-determinism, running single-threaded, in the absence of SABs -- no ability to sense duration -- it can signal, but not sense -- means that it’s protected from side-channels. Where do all these points belong?

EP: Current spec already covers a lot of these points.

AR: It also says explicitly that you can only interact with imports/exports. Talks about side channels vaguely -- don’t want to make specific statements given all that’s happened.

LW: Can count packets over the network, so others can sense duration.

MM: Right, any access to the outside world can enable indirect sensing of duration.

BT: NaN bits are non-deterministic.

MM: That aspect of the spec should be pinned down -- dynamic vs. non-dynamic non-determinism. We should spec that this needs to be stable on any one platform.

AR: That’s not easy -- CPUs do very random things we don’t want to tie it to that.

MM: Are there platforms where it can vary at runtime?

DG: There’s cases where you can migrate wasm across CPU platforms, so it would be a problem there.

EP: More detailed than required for this purpose, it’s really up to the embedder -- just the fact that it offers no attack surface that is not already offered by JS.

MM: It’s not the thing that it makes it weaker, but wasm semantics offer a stronger security guarantee.

EP: Right, we may be able to say a properly scoped embedding will eliminate side-channels.

BT: We should not have anything more about side channels already -- another source of non-determinism if resource exhaustion when trying to grow memory etc.

BS: Added to the discussion because we were discussing privacy -- don’t know the technical distinction between the two -- we can extend the security issues with more discussion. But what about privacy?

AR: Can’t say anything meaningful because it’s an ISA -- it’s not useful for the CPU to say anything about that.

EP: We should just say that.

AR: Do we want to say arbitrary things for people that don’t understand what they’re reading?

EP: Just clarifying that is useful.

AR: We should add in the Web API spec, it makes sense there, but it’s not relevant for the core spec.

EP: People will be looking for it.

EP+AR to follow up offline. 

BS: Want to give an opportunity for someone who hasn’t already spoken up.
[no one speaks up]

#### [Passive element segment binary format](https://github.com/WebAssembly/reference-types/issues/31)

No time for this.

### Closure
"
main/2023/CG-08-01.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 1st video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: August 1st, 4pm-5pm UTC (August 1st, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Proposal update: Exception handling (https://github.com/WebAssembly/exception-handling/issues/280), [slides](presentations/2023-08-01-titzer-revisiting-exnref.pdf) [30 mins]
    1. Follow-up on flexible vectors presentation (https://github.com/WebAssembly/flexible-vectors/issues/60), [slides](presentations/2023-08-01-Penzin_Flexible-vectors-use-cases.pdf) [Petr Penzin, 30 mins]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees

* Ashley Nelson
* Conrad Watt
* Thomas Lively
* Ben Titzer
* Francis McCabe
* Bruce He
* Nuno Pereira
* Deepti Gandluri
* Ryan Hunt
* Alon Zakai
* Bailey
* Zalim Bashorov
* Keith Winstein
* Yuri Iozzelli
* Tal Garfinkel
* Chris Woods
* Paolo Severini
* Yury Delendik
* Shravan Narayan
* Jeff Charles
* Manos Kouboutos
* Brendan Dahl
* Don Gohman
* Chris Woods
* Andrew Brown
* Kenneth Brooks
* Mingqiu Sun
* Petr Penzin
* Nick Fitzgerald
* Jakob Kummerow
* Emmanuel Ziegler
* Luke Wagner
* Justin Michaud
* Sean Jensen-Grey
* Sam Clegg
* Ioanna Dimitriou
* Ilya Rezvov
* Heejin Ahn
* Emanuel Ziegler
* Dan Gohman
* Jonnie Birch
* Pat Hickey
* Thomas Steiner
* Nick Ruff

### Meeting notes

#### Proposal update: Exception handling [30 mins]

BT presenting “Revisiting exnref” [slides](presentations/2023-08-01-titzer-revisiting-exnref.pdf)

DanG (via chat): How did we end up with a phase 3 proposal that we can’t change without breaking the Web?

CW (via chat): Exception handling has been unflagged in (some?) browsers for a while. I agree this isn’t a situation we want to repeat for future proposals.

FM: Helpful if you went over the A&B proposals

BT: Heejin?

CW: Only if comfortable and something prepared

HA: Option A is intended to be similar to current proposal the intention is to minimize the friction of implementation in both the toolchains and engines. And basically it looks like the current proposal the only difference is the catch only pushes instructed values it pushes additionally an exnref. It basically pushes multiple values. For catch_all it only pushes exnref. SO if tag 0 is i32 it pushes the multivalue i32 and the exnref. And if tag consists of two values, like i32 and f32, it pushes i32 and f32 and exnref. Meant to be the minimal delta from the current proposal. The advantage is its minimal delta so we expect less friction or disruption from the toolchain. We care about some amount of disruption but we have to plan accordingly and provide necessary tools for users that don’t want to recompile, we can provide some sort of binary translator. Option B is suggested by AR. The opcode doesn’t have meanings. With the existing proposal we can only rethrow between catch and the end opcode but now we don’t have this lexical rethrow. Catch takes multiple tag label pair so that when the exception is caught by tag 0, you go to label 0 with the exnref value. If exception is caught by tag 1 then you go to label 1 with the value. Block 1 and Block 0, those things should have the return value as exnref. Optionally, only a catch all label. If this exception is not going to be caught by the listed tags, but we still want to catch_all, we should go to this label. This returns exnref for the block, so we need additional br_on_exn. This should be familiar because we have this in the previous proposal. This is for extraction. try/catch is only for jumping. This option is more like the current wasm but it doesn’t have the two-part block structure like try/catch. Does not have an end. May be aesthetically more pleasing. It can involve more code size. In my preliminary experimentation, many applications in the wild, like C++, use very few try/catch and a lot more try/catch_all. The code size is not that different from in the wild applications. 

ID (via chat): This ‘catch’ sounds like the way it’s implemented in firefox

BT: In both options, both catch flavors are new opcodes, so they don’t overlap with existing binary space. Engines must support the previous bytecodes, and they don’t have to change new bytecodes. This catch that pushes the values and the extended exnref, it is also helpful to have the old catch that did not catch the exnref. Because we can completely elide the exnref. So you can effectively throw values from one frame to another without having intermediate storage. 

CW: Can you talk about what you expect the toolchain migration story to be, not just engines. Things like Binaryen, for example.

HA: We also need to have some phase that we support both options. New implementations might have some bugs, and we need a beta testing phase with partners. After testing one option for some time, we can decide to make a switch to it, and if we agree to deprecate it, we can agree to deprecate the current option.

RH: Note about deprecation because that’s a key point. My perspective representing Firefox/SpiderMonkey is we are open to try and doing the deprecation but the thing we want to make sure is thought through is that we have two kinds of exception handling, because we’re not able to deprecate the old thing, then that is a worse outcome than having just the old one. We can’t predict if we can successfully deprecate everything, because we can’t control the users on the web. From some discussions it sounds like we know enough of the users and can communicate to the users that we can make changes quickly and have deprecation on some timeline. But the key thing is to hear from people, are there any toolchains we don’t know about using the EH feature? What unknown unknowns are out there that could handicap us from deprecating down the road? It’s the biggest concern as a browser vendor.

KW (via chat): (I don't quite follow how Option A would enable an asyncify -- how does having the opaque exnref help rewind the stack back to inside a particular catch block?)

HA: It can’t. I think you’re talking about the current option, so rethrow depends on current surroundings, and there is an opaque storage for exnref. One motivation for reintroducing it is to make the it work. Now `rethrow` is going to take the exnref as argument and does not depend on the surroudings. Option A & B can support asyncify.

BT: Put it this way, exnref addresses the dataflow part of the asyncify because it has a handle to the exception package you need to be able to store somewhere, whereas Phase 3 there is no dataflow possible, so the control flow rewrite that gets you back in a try/catch gets you a normal CPS transform that you would need to do. It would be like any operand value that is on the stack, do the CPS transform to pass the values forward or store them in a shadow stack. 

KW: Rethrow would take an externref from the stack instead?

HA: Should have included in the slide as well, I was summarizing too much.

CW: That’s a change common to both options, rethrow will be changed to take a first-class exception package. How do we decide between option A & B now that they are raised?

RH: Option A or B does nothing cause that’s the other one here.

Chris Woods: What’s this giving us again? Is this just allowing us to receive exceptions from the host environment in an easier way?

BT: This slide simplifies the interaction with the host environment, in particular JS, adn the CPS thing, Asyncify was not possible before so that’s a new capability and generally it simplifies things in both engines and the spec.

CW: My understanding is that both would mean we won’t have to duplicate finally blocks.

BT: Indeed that falls under the unnecessary duplication in that point here.

Chris Woods: In the languages we are looking at (C family), we are implementing phase 3 support in WAMR. The spec is elegant, but the compiler generated code doesn’t use half of it. This is great, but why would we implement it if we only see 1 throw and 1 catch. I don’t have visibility in other languages or toolchains, but I see this is an interesting addition, but I need to think about it, but I don’t know what the impact it is in the embedded C environment.

HA: What toolchain are you developing?

Chris Woods: Runtime support for WAMR for phase 3

HA: Is either Option A or Option B going to be a problem for the implementation changes in WAMR?

Chris Woods: Technically no, because we only just started rolling out phase 3 support this month with a branch. We can change it, but looking at pragmatic, what am I going to get out of it when I’m looking at an environment where the toolchain doesn’t use the full spec right now?

DG: Unfortunately we are out of time for this discussion item. We have capped it at 30 minutes).

CW: Follow up in the offline issue DG posted in chat

DG (via chat): Github issue for offline follow up: https://github.com/WebAssembly/exception-handling/issues/280


TL (via chat): Chris, I assume the toolchain you're talking about is clang? If so, you should chat more with Heejin because she implemented the EH use in LLVM.

ChrisW (via chat): 100% - thank you. I do admit my lack of knowledge here, and I'm keen to understand some more.

HA (via chat):@Chris Woods I'm not sure which toolchain you were referring to, but our current LLVM toolchain uses rethrow. I mean our C++ support. (We use it when, when we have 'catch (int)', but the thrown exception is not an int, to rethrow to it to the next enclosing catch)

Chris Woods (via chat): Then I am corrected. Thank you. We've only profiled simple code generation from clang, and it was some time ago, basically just trying to understand what is generated. We did not look at the toolchain code itself, only what we saw being generated by the tool chain. So a superficial level, admittedly. We saw, throw tag 0, catch tag 0, and some handling... so the full nuanced and elegant instruction set didn't really seem to be completely used... which is a shame, cos it's cool. But also, I wonder if this gives rise to understanding the impact of a spec change on existing languages.

BT (via chat): FWIW, I implemented the option A in wizard’s interpreter, and it was a nice simplification. The lexical rethrow in Phase 3 is kind of a pain for interpreters. Andreas also implemented option A in the reference interpreter.

HA (via chat): For toolchains, I don't have a full knowledge on how many (or if any) existing toolchains have implemented EH out there, so I'd like their inputs as well. I don't think the rethrow change is gonna be a big change; it can boil down to just storing it to a local and retrieve it later for rethrowing. I think try~catch side (especially in case of Option B) can be a bigger change for toolchains, if we decide to go down that path. (I heard Blazor was implementing EH recently)

ID (via chat): It sounds like the 3rd proposal’s rethrow is the big problem for async and CPS transformation, is this right?

BT (via chat): Correct

ID (via chat): Makes sense.

BT: Execution summary, IMO, is that exnref for WAMR means a ref-counted exception package

KW (via chat): Preliminarily, both of these options seem (?) to make things more challenging for wasm2c. Right now it never has to malloc or provide GCed or refcounted data, since the scope of a caught exception is purely lexical. I wonder if there is a possible Option C that keeps the status quo intact, but adds an additional pair of instructions (or standardized imported functions!). One that gets the current caught exception and returns an externref, and one that rethrows that externref.

CW (via chat): does this idea make things easier for Wasm2C? Would you not still need to malloc/collect the externref?

KW (via chat): @Conrad: I think one benefit is that I was thinking ""Option C"" could be a totally new proposal (enhanced EH) that layers nicely on top of the existing EH, so the impact would be limited to modules that actually use the feature.

HA (via chat): So you mean wasm2c can support only a part of the EH instructions?

KW (via chat): @Heejin: I believe wasm2c currently implements the entire current EH proposal. But adding an exnref with indefinite scope (and referring to data of indefinite size) would make things harder for us and seems to introduce a dependency on some sort of GC.

BT (via chat): Does wasm2c use setjmp/longjmp for EH?

KW (via chat): wasm2c uses goto for EH within the same function, and setjmp/longjmp when crossing a function boundary.

BT (via chat): Are the semantics of setjmp sufficient to guarantee wasm’s semantics?

KW (via chat): Re: semantics of setjmp, I believe so (when the enclosing try block is in a different function). But happy to discuss.

HA (via chat): If GC'ed, of refcounted data is problem for wasm2c, does it have plans to support GC?

BT (via chat): I was recently looking into setjmp more closely and I was a little surprised at how few guarantees it makes. We can maybe followup offline. IMO the issue comes down to lexical rethrow, which is the complicated thing in phase 3 that gives rise to the other problems

KW (via chat): But #2, perhaps to be easiest for wasm2c, the full API would be something like ""get_current_caught_exn"" [] -> externref, ""rethrow_exn"" externref -> [], and maybe ""free_exnref"" which frees it explicitly.

BT (via chat): Is rethrow used a lot in wasm2c use cases? (If not, then keeping the exnref-less catch should serve those use cases).

KW (via chat): I mean, the intention of wasm2c is to transpile any valid Wasm module into a C program that obeys the Wasm semantics. So if you imagine producers are going to use rethrow, we have to implement it.

BT (via chat): Sure, the question is always one of cost of runtime complexity and performance


#### Follow-up on flexible vectors presentation (https://github.com/WebAssembly/flexible-vectors/issues/60) [30 min]

CW: Our second item is a flexible vectors update given by Petr.

Petr presenting “Flexible vector use cases” [slides](presentations/2023-08-01-Penzin_Flexible-vectors-use-cases.pdf) 

JM (via chat): Re: SIMD, I have heard from some users that they won't even consider supporting WASM for ML workloads because WebGPU is 10x faster, to the point where their model only works with WebGPU. My question: what use cases does this have that 1) widely produce a speedup, and 2) would not be even better if served by WebGPU?

SJ-G (via chat): Why increased SIMD with vs a vector ISA like RISC-V Vector extension?

PP: Well, if vector ISAs were commonly available, then we would use that. The proposal was originally modeled on RISC-V, but full flexible vector won't map very well to fixed-width SIMD without native mask support. Maybe the world eventually would move to vector ISAs, but that is not the case at the moment.

TG (via chat): WebGPU is not a solution for many uses of SIMD compression, media decoding, json decoding, etc.



DeeptiG (via chat): Re. Cryptography and Matrix multiply - can you talk about the tradeoffs of exposing a subset of AMX/AES instructions instead of a more general solution that might leave some performance on the table?


PP: WebGPU the problem of communication overhead with the device. For code that ultimately uses GPU it might be possible to do all processing on it, but for code that won't (let's say signal processing), the cost of round-tripping to the divice would be prohibitive. WebNN supports custom operators using Wasm, that would also not run on GPU.

DeeptiG: A big part of this is webgpu just shipped last month so everything using ML on the web right now is using the CPU, ther eare a bunch of operations that work better on the GPU and will shift in the future. But there is also stuff that is better for the CPU, memory intensive and shorter workloads. For Chrome we see some shifting to GPU but still a bunch needs the CPU

CW: If a platform wanted to be conservative, and reported everything as 128, how much of a penalty would it be if you used flexible vectors instead of the baseline SIMD opcodes?

PP: should be the same, I think Wasmtime experimented with this approach

CW: One thing thaht might be good to document is the mapping of instructions to older Wasm SIMD instructions similar to the way relaxed-simd does

PP: That’s a good idea, write it down in the issue. 

CW: The most interesting situation is if one of the mappings isn’t obvious.

PP: If you try to go back and forth the mappings, especially for shuffles, and masks, I’m not sure what would be the resulting 


### Closure
"
gc/2021/GC-06-29.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 29 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: June 29, 4pm-5pm UTC (June 29, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Isorecursive types recap [Thomas Lively]
    1. Discussion: Nominal types across module boundaries [Thomas Lively]
    1. Discussion: Deferred loading of types [Ross Tate]
    1. Discussion: Wob and Waml examples [Andreas Rossberg]
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Zalim Bashorov
- Francis McCabe
- Ross Tate
- Rick Battagline
- Conrad Watt
- Keith Miller
- Daniel Wirtz
- Andreas Rossberg
- Jakob Kummerow
- Fil Pizlo
- Slava Kuzmich
- Zhi An Ng
- Asumu Takikawa
- Manos Koukoutos

### Discussion: Isorecursive types recap [Thomas Lively]

[Slides](https://docs.google.com/presentation/d/1EhVku1kSN1CzPoZ1QpN9SjHLtd6dAelTLFjeqwwetFI/edit?usp=sharing) 

RT: string is a subtype of object and mutually exclusive with object also cannot be expressed with iso

TL: like this pattern? (on slide titled Isorecursive types recap)

RT: this pattern is 2 mutually recursive extending non recursive, that is 2 mutually recursive, one extending another. String/Object is a concrete real world case

TL: forcing producers to detect this and emit the required checks seems like a lot of work. I’ve not been putting too much time into prototyping isorecursive types, doing more on equirecurisve and nominal.

AR: we keep bumping into this argument that… want to compile Java, but this cannot express Java, so we need casts. We will need casts in many instances, mutual recursion between classes is just one of those. Sure, equirecusrive ones are more convenient in that sense, part of the discussion is how this is related to separate compilation, where you can’t have mutual recursion easily. Overall, just because something requires casts, that is not sufficient reason to dismiss something. There are many things that require casts, and always will be. This isn’t a problem per-se, but how difficult it is to deal with this problem. Covering this case is not very hard, how to deal with them is harder.

RT: typed assembly language for C# that can support this

AR: specifically for OO language, not the same design goals that we have

TL: considering this isorecursive type system, we haven’t discussed how to find all possible cases that won’t work, and insert casts to make them work. I don’t have a great idea of the difficulties and edge cases. We can discuss that offline, try to work it out. Right now, my feeling is that it will be significant work, not clear on details. Agree with AR that casts are necessary for some languages

AR: every language, for some situations

TL: AR, is your feeling that this is a simple problem to solve?

AR: don’t know. From first glance, covering these cases is straightforward, when you have a forward reference. Less clear in separate compilation case. Any type can occur in forward place, go to top type / anyref. Less clear what to do when it occurs inside an Array, where you can’t subsume, as subtyping doesn’t apply there. Suspect that will induce casting obligations propagating to all sorts of places, maybe even impossible in some places. OTOH, suspect will be the same for many places in our type system. We only looked at Java and C#, the question of how much effort we make to tweak the type system to fit Java, is a good question. Do we want to do a JVM or a generic thing. We have to live with these problems and solve these problems, always a problem we will bump into.

TL: we have two teams working on prototype compilers, J2CL for Java and Dart for dart2wasm. Both are Java-like. It’s not just Java, we have Dart, but unless we have other groups prototyping stuff, these are the implementer feedback we have. We do have to listen to our implementer feedback.

AR: don’t disagree.

TL: if others want to pursue more isorecursive, figure out where casts are required, then we can go to J2CL team and tell them how to solve these problems.

RT: AR mentioned that in practice, researches found isorecursive sufficient for describing real functional languages.

AR: very technical and only about edge cases that in practice don’t matter much, when you need the compilation scheme then you run into them. It’s more ML specific, where you have a powerful module system, and depends on type abstraction, especially mutual recursive types. When you can abstract parts of a group in a group of mutually recursive types, then you are outside of what you can express in isorecursive. Isorecursive is monolithic thing, with equirecusrive you can take small pieces. E.g. type T in a module, and type U == something referring to T. You cannot match that with something where T is also mentioning U when you have isorecursive interpretation. That’s something you can do in ML/SML and think in OCaml too.

RT: allows unnamed fixpoint types? Like a type alias thats a fixed point?

AR: allows fixpoint across modules… allows to abstract over something that you don’t know yet is a fixpoint

RT: those are different

AR: you cannot abstract over groups of types before knowing they are recursive. You can still technically write it, they bumped into that in first formalization of standard ml and isorecursive types.

RT: useful to see that example

AR: remember that i wrote it up somewhere, thought had already, maybe not.

### Discussion: Nominal types across module boundaries [Thomas Lively]

[Slides](https://docs.google.com/presentation/d/1EhVku1kSN1CzPoZ1QpN9SjHLtd6dAelTLFjeqwwetFI/edit?usp=sharing) 

AR: example of mutually recursive modules, not sure why it’s worth discussing this? This is something we simply don’t have in Wasm. Even if you can find some ways in which you can compile this, there is no generally good way to deal with things like that, except casts at the type level, and references to tie the recursive knots. Can’t natively express that in Wasm. Headline there is that this example is specific to mutually recursive modules. Forgot where it came up exactly, think it was discussion on separate compilation of mutually recursive modules.

RT: trying to figure out why you claim only equi types can do recursive modules.

AR: a tangential remark on one of my presentation. My take is, this is not something we support

TL: at Wasm level we don’t want to support this, but we do want to be able to compile languages that support this into Wasm. Need to compile this source level module.

AR: answer to that will be language specific, with Haskell, recursive modules aren’t very well thought out, totally implementation dependent how you compile them. GHC allows separate compilation, if you write a signature file manually, kind of abusing the system. More working by accident. Java is completely different, there the linking of modules is very dynamic. Semantics is very dynamic, falls back to dynamic checks as far as semantics is concerned.

TL: all of the objection to using nominal types, come from this kind of situation, that’s my understanding.

AR: they come from linking, not necessarily mutual recursion

TL: this is a particularly interesting case of linking

RT: context was, you claim that we need equi types to support linking with mutual recursion, TL make a new thread asking for example, you gave this example

AR: examples don’t work unless we have equi linking, but i don’t consider it a goal to support this

CW: to be clear, this is about supporting examples like this at the Wasm system. What is needed to compile a whole [source] program with type definitions like this? Is it a goal to allow the definitions to be split into separate modules at the Wasm level and linked? Quite happy to say that this is a non goal. But then what is the goal? What are we expecting to do when you compile this program? I think it is acceptable to say there is a central module where all the types go.

AR: acceptable to say if you have mutually recursive modules, you need to compile into single module, which is what some modules are doing

TL: if we do that, and acceptable, nominal types will just work

AR: no, that discussion is not dependent on nominal types

CW: will remove mutual recursion as objection to nominal types

TL: weak import export, refactoring of modules, for these solutions, you need to know transitive dependencies to break cycles at build types, if we say all mutually recursive modules need to be compiled into same module, then becomes non-issue.

AR: we need to distinguish the general problem of type imports or structural types, and the problem of mutually recursive modules, they are separate problems to solve. The esoteric problem of mutually recursive modules is something we can impose limitations. In general, being able to link DAG-shaped dependency graphs in a reasonable fashion is something we want to support.

TL: let’s take an AI to hash out goals around dynamic linking of modules. It has come up in issues that we cannot use nominal types to support these kind of examples. If we don’t care about these examples, it has a big impact on nominal type discussions.

AR: nominal types is about linking, not at all specific for linking

RT: but when we have those discussion, this problem is brought up to object nominal types

AR: will give a presentation to explain the crucial points and why neither of the proposed solutions are solutions

TL: will be great to hear those points. Will help to be crisp about what we are trying to achieve, the requirements. These examples come directly from conversations where you were arguing that nominal types don’t work. Surprised to hear you say these examples don’t matter.

AR: yea there were many discussions, many confusions, and conflating various things. One of the big problem with the discussion we have, not focused, very tangential, not relevant to problems we are trying to solve.

CW: One way to pare down is to fix a principle saying, we do not care about supporting separate compilation of mutually recursive type declarations. Then we can focus on what you consider to be more realistic objections of nominal types.

AR: yea I can subscribe to those kind of statements.

TL: Let's try to hammer out those principles by our next meeting, then we can be ready with a shared understanding of our goals.

### Discussion: Deferred loading of types [Ross Tate]

Slides: Deferred Loading of Types [(pdf)](presentations/2021-06-29-tate-deferred-loading-of-types.pdf) [(pptx)](presentations/2021-06-29-tate-deferred-loading-of-types.pptx)

RT: do we want to support deferred loading, if we do , how do we want to support it? J2CL is fine with whole program compilation, but wants to support loading deferred parts of loading.

FM: You have to say who “we” means. Absolutely there are people who will take full advantage of deferred load modules.

[SLIDES]

AR: When do we want to support it? Eventually we want to support this, but I don’t see us making this a goal for the MVP

TL: for non-gc, we already support this, and in production for some emscripten users

AR: Let's say to some extent, I'm proposing to support this, part of structural type stories. My compiles have a repl that can do that, and depends on structural types. To that degree I agree. If something more sophisticated, then post-mvp.

CW: A useful question for now is, what potential hazards do we see in current designs that can affect having deferred loading as post-mvp.

LW: also things make sense to support this in MVP GC, can dynamically create modules, have all the building blocks using JS as glue, will be weird not to support this.

TL: even in MVP GC?

LW: Yes, the only thing added is a new type of memory.

AR: agree with that. Maybe I was expecting something different here. What you’re describing here is what I call incremental linking. Where you load types of your programs one after another. How sophisticated is that support. Maybe we should let RT continue to see what he has in mind. It can be solved today with some indirections.

[back to slides]

CW: are you imagining it will be important to do this at the granularity of per module, or per declaration of type, or bit of data.

RT: Java has specific semantics for how loading works. We could support that policy, I was more thinking of, someone wrote a program, then state that X classes will load now, Y classes load later, Z classes load even later. Then they will be in different modules.

CW: TL’s talk about deferred loading currently, what granularity is that?

TL: we start with a monolithic module, then profile, then split into 2 modules introducing all the indirections. From application POV, secondary module gets loading lazily and completely transparently, Wasm module is not aware anything is loaded, handled by Emscripten runtime.

CW: if you call a function that’s in the secondary module, you block until everything is loaded?

TL: yes

[back to slides]

LW: if Foo contained a call to Bar, what will the desired outcome be?

RT: depend on loading policy, the idea is what TL described, if you call that method before Bar is loaded, you have to wait. Don’t have to be ingrained into Wasm, but that’s how I imagine this example will work.

AR: here’s where i see the line for MVP, incremental loading is fine and easy to support, as long as it is bottom up, what RT is proposing here is you can load a module before you load some of its dependencies, much harder to support, and i would argue outside MVP. was wondering what Luke just asked, this example looks very artificial. In practice you call some methods of Bar, you’ll need to know the vtable, you are in the problem space....

RT: small example needs to be handled before we look at the bigger ones

BT: just tip of iceberg, just a mechanism to declare these types, ultimately this has to be implemented in type checking algorithm, what do you do when you get to a type that is not defined yet, you will need to type check them.

RT: if you are treating that abstractly, you can treat it without knowing its type

BT: type checking will run into something that won’t be defined. You have to define what it means when two types, one reference something not defined yet.

RT: a type that is only declared and not defined, it will say cannot compile

BT: type imports can import something that isn’t defined. Module foo has type import, bound to something not defined.

RT: this code works whether Bar is defined or not

CW: that module will only allowed to import the type completely abstractly

BT: you’re going to need to have type constraints, and multiple type constraints to compile Java

RT: just the tip of the iceberg right now yes

CW: in TL’s world, you have the escape valve, when a module is split, you can get all the internals. Here you only can split a module and defer loading if you can identify a boundary where the module deals with types abstractly. How common do you expect this to be? Do you see future features where you can do more with partially loaded types?

RT: more complex examples we can solve with staging, this portion of the module will only be defined at a later stage, and you need to give these imports. If you statically link everything, you get all the stages right away. If you defer some things later on, the later stages will only be accessible later only, your dynamic loader system will be responsible to put into stubs.

BT: if we imagine module Foo type Bar here, add a type constraint to Bar, instantiate foo with something not defined. You have a constraint, by instantiating foo with an incomplete type, you applied its import constraint to this type, when define it, whatever definition you have matches all the constraints of all instantiations you have already done.

AR: that is fine, it will be subtyping, you can’t supply something with stronger constraint. Real problem is how you deal with these constraints, how do you compile code. That can only be done efficiently with staged compilations. It goes to hypothetical extensions with staged compilations. We keep having these discussions without these features. Maybe we should start from there features before going on tangents.

BT: agree totally that this requires staged compilations. For Jawa, we have complete control over the VM. I introduced staging. Things become mutually recursive, they get tanged between modules too.

LW(chat): We’re over time but just one parting thought: if we’re focusing on the Emscripten dynamic-splitting-as-a-transparent-optimization use case, we have the simplifying context that you start with a monolithic module where you know everything, thus $__glue can actually define $Foo and $Bar fully with full structural information, so we’re in the easy case where nominal-vs-structural doesn’t really come up

### Discussion: Wob and Waml examples [Andreas Rossberg]

[Deferred to the next meeting]
"
main/2023/CG-07-18.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 18th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: July 18th, 4pm-5pm UTC (July 18th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Strings in Wasm (Continuing from previous discussions in [06/06](https://github.com/WebAssembly/meetings/blob/main/main/2023/CG-06-06.md) and [05/23](https://github.com/WebAssembly/meetings/blob/main/main/2023/CG-05-23.md))
        1. Introduction, and quick summaries [Adam Klein, Jacob Kummerow, Ryan Hunt, 15 mins]
        1. Discussion [30 mins] 
    1. Phase 1 vote for [Compile-time imports](https://github.com/WebAssembly/design/issues/1479) and [String builtins](https://github.com/WebAssembly/design/issues/1480) [10 mins, Ryan Hunt]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
* Thomas Trankler
* Michael Smith
* Conrad Watt
* Daniel Hillerström 
* Justin MIchaud
* Zalim Bashorov
* Francis McCabe
* Paolo Severini
* Alon Zakai
* Chris Woods
* Yuri Delendik
* Manos Koukoutos
* Johnnie Birch
* Nuno Perieira
* Bruce He
* Yuri Iozzelli
* Adam Klein
* Ilya Rezvov
* Ryan Hunt
* Deepti Gandluri
* Sean Jensen-Grey
* Andreas Rossberg
* Asumu Takikawa
* Ben Titzer
* Thomas Lively
* Dan Philips
* Alex Crichton
* Jakob Kummerow
* Brendan Dahl
* Andrew Brown
* Matthias Liedtke
* Nick Fitzgerald
* Shaoib
* Igor Iakovlev
* Ashley Nelson
* Jeff Charles
* Mingqiu Sun
* Emanuel Ziegler
* Nick Ruff
* Dan Gohman
* Richard Winterton
* Slava Kuzmich
* Heejin Ahn
* Shravan Narayan



### Proposals and Discussions

#### Strings in Wasm

Adam’s quick update:

AK: Hoping to get some resolution (tentative) - hear details on stringref from JK then discussion

* straw polls on direction?
* how positive do we feel about stringref
* how positive do we feel about compile-time imports

JK update - presenting [slides](https://docs.google.com/presentation/d/1rc2M5oYXeRmiAKUNR3FrJQcOhgqHTRlZc11zlZn7PKw/edit?usp=sharing)

RH: QQ about bulk memory operations, about toUpper as a 2x performance difference, can you talk a little bit more about the performance difference?

JK: I haven’t measured all of the ops. I have seen about 3x for int to string conversion, comparing the building v8 implementation that takes all the shortcuts, vs the version from the JVM compiled to wasm. Presumably the JVM is a good implementation. It comes down to iteration performance, bounds checks, ability to operate on more than one char at a time, lots of implementation tricks that add up.

RH: With bulk memory, we did go down the route of having native implementations for common functions, would be hesitant to carry that over to strings, if there’s a way to have better performance across the board, we’d like to look into mitigating them 

JK: I'm certainly not saying we have to add all of these to core wasm. If we have a string type it makes it easy to add those things as imports. We can make case by case decisions and start small, and possibly extend in the future.

CW: This is the hybrid solution that was floated earlier, where we can add a string type to core wasm that doesn’t do much, and then include compile time imports as well


JK: it’s up to us where we draw the line, yeah

FM: I’d like to look more at the gap between wasm and non-wasm implementations. Generally if there's a big gap between native and wasm implementations of the same algorithm, then we have a problem in wasm. It would be worth taking a naive implementation of toUpperCase for example, not a tricky one, and compare in wasm vs non-wasm. If there’s a factor of 4, then there's a problem in wasm that we should fix.

JK: Sure, ideally Wasm would be as fast as native, but in practise thats not the case, we can sufficiently fast compiler optimizations in the fullness of time, but we don’t expect to have that anytime soon

TL: for these performance comparisons, are these comparing implementations in wasm with e.g. i8/i16 arrays, or translating char by char to a JS string, and calling out to JS to do the operation?

JK: Comparing fewer string implementations instead of builtins. Leaving super tight, optimizable ops to the engine is a lot faster than rolling your own. We can also do string builtins so that 3rd parties can roll their own functions, but that’s the case where you’d see the 4x difference. 

AB [chat]: Question for Jakob: with stringref, you expect accesses inside a string to all be bounds-checked, right?

JK: yes. For iterating over string chars, there would be bounds checks, just like iterating over an array, and maybe some could be optimized away.

AB: This proposal would include new instructions for iterating over chars etc. right? Stringref has the key decision of introducing an encoding agnostic type, when something requires a particular encoding, then there’s a view that makes the engine do whatever it needs to do under the hood to ensure that you get that encoding. That’s how we get generic strings that support different source languages that can’t easily change

CW: my interest is really in the embedded space. There is’t usually linear applications like Rust and C. My concerns are around the affected languages and toolchain changes; i haven’t seen the languages you’ve considered. I’m also concerned about the continual growth of the runtime size. As we add more operations that we must support, the runtimes get bigger and the number of devices we can support drops. Have we considered how big runtimes will get, or have a policy about how far we’re willing to go? I like the idea of importing from the host, so I can choose what I have in my runtime. Embedded space is moving away from linear languages toward newer ones, so there’s a bit of a quandary.

JK: Haven’t looked at the smallest possible binary size we can get away with for a naive strings, I have experimented with having the stringref proposal implemented in pure wasm in an afternoon, and given the size of implementing GC, GC + Strings will be a smaller binary size
RH: I do think there’s a question about what is a compliant implementation. In the browser its a lot of code to do all those optimizations, there's a real chance that source modules will expect these optimia

CW: Its either a large binary size or that we have a disproportionately large performance gap

DS: If you want to support these newer GCd languages and have fast string performance, you’ll have to pay for it one way or another. You can either support them in your runtime in the form of stringref, or import them (but you import them from your runtime!), you really can’t choose to not do it if you want the performance benefit, it’s just about where

CW: Practically we can only get C or rust, but not other languages..

DS: There will be environments that just don’t support GC languages

CW: and this may be where profiles help

BT: There was a slide that had future revolutions - would argue having imported strings is easier for future extensions because we don’t need to support them right away, I disagree with how fundamental strings are, there are 80% of platforms that need strings and 20% that don’t so having an extensible choice makes more sense

JK: What I meant by more future proof is that the world is generally moving toward UTF8 but it’s relatively rare now. The stringref will scale without further additions to a world where UTF8 is more common. Importing won’t scale, we’d have to add to the spec. But I think the stringref proposal is more future proof than imported strings in that respect.

BT: I don’t understand that point, views if there are types can also be typed imports, all the functions can also be imported, the only difference is whether you call them type imports or have dedicated bytecode

AR: I would also make the point that abstracting these semantics is not enough to be able to change the representation in the future without braking code, because the performance characteristics matter, e.g .whether a loop is O(n) or O(n^2) and you can’t just argue that away by saying there’s and abstraction. I think this is less of a problem with imported strings because the developer has control of what they pick, they can pick one with the properties they want. But with stringref they are just at the mercy of what the engine picks. That’s a portability/compatibility hazard.

NF [in chat]: The Wasmtime project would prefer not to implement `stringref`. We don't have a managed host string to expose to Wasm guests, and we don't want to have to implement one. We would rather that Wasm guests implement their own strings on top of the GC proposal, where they can build exactly what they need, which can be very different across languages. As far as interoperability of strings across different languages goes, we believe this should be addressed at the component model and interface types layer. For tight integration with JS strings on the Web, string imports seem like a good solution.

CW: We have a position from wasmtime in chat, would anyone like to speak to or respond to that? 

TT [chat]: could you import stringref as a generic type being  backed on browsers engines by domstring?

AK: That's good feedback, it’s pretty clear. I also wanted to address TT’s question. I think that’s effectively what a future version of the imports proposal would do with the addition of a type imports facility where you’d import a type from the host. So you’d import an externref that represents the DOMString. Alternatively a minimal version would be to have something in caore called “string” that was implemented in browsers as JS string or DOMstring.

CW: At the limit you have a type that is a string, where you can interact with the host but nothing else, which fixes boundary issues but it doesn’t mitigate the bulk performance issues that JK mentioned,

RH: one thing i'd like to discuss more, i think JK had a good point about what we should be thinking is a good compile target. I don’t think stringref is a good compile target. There are 2 problems it tries to solve. One is host interop, where you have the same as what the host uses for native APIs. The other is bing a good fast string internally that supports fast operations. With host strings, I view wasm as not really having an opinion about what the host strings are so we can’t say much atou what kinds of encodings nwe use, what operations it supports. So we can’t say much about what you can import from particular hosts. 
With bulk operations you really do want to know about the performance characteristics of what you're importing.

There’s not much you can say about them when importing from specific hosts, for the bulk operations you really want to know about the perf characteristics, It’s not a good compile target because we don’t know how its implemented, it's not so much about the eJS string types, but what hosts have to do to make them performant its more about what you’re mandating the hosts to do or implement based on whats expected. 

If you have a UTF8 languages the hos string is UTF16 and needs to copy, then you will get bad performance.

BT: I think we should be relatively conservative about adding things to core wasm and pick things that have a big bang for the buck, things that are on most machine. If we pick between stringref, which does have a lot of value, but I think compile-time imports and type imports are bigger value because they solve multiple problems at once. They allow for other intrinsics like JS operations, typedarray operations, and things from multiple different platforms. So there's a bit difference in terms of the capabilities. Stringref solves a small set of problems, but type imports solves a whole family of problems.

JK: I think type imports are great top have, and would want them, I also think that strings are also very fundamental that we still want them

CW: theres also a timing issues. Type imports can take a lot longer to spec an put in the platform. What would the impact be on users if they had to wait say a year or more for type imports to get in?

AK: from Jakob’s slides, even without type imports today we can do pretty well on performance today without that. It would be definitely good to add, but externref is workable in the short term.

JK: We can work with exnref for now, having type imports would eliminate some type checks, generally speaking we can do now

RH: you’d want to have a clear migration story to using type imports in the future.

CW: One of the motivations was this boundary problem, where does that show up if its not the difference between exnref and the stringref?

RH: my understanding is that it’s with copies, not so much about the type check, but sharing the representation.

JK: If we did neither, imported strings or stringref, then wasm modules have their own strings rolled in, then when exposing to the outside, then you always have to copy, and then it would still be slow

CW: Even in the case where you're trying to solve the problem of interop performance, that still requires the language to change its representation everywhere to whatever you’re using at the boundary?

JK: Both of these approaches can give fast copy primitives, that does mitigate some of the worst problems, but it is still a copy, I have a microbenchmark, that can demonstrates some of this performance issues scale badly

AR: Going back a bit, I was surprised by the assumption Conrad made that implementing stringref is probably going to happen faster than imported intrinsics. I would assume they are on par at best for an engine that hasn’t started either one, I would guess that imports would more likely be faster. I guess we don’t have real data but I would still guess that imports would be less to implement.

CW: IT does require a change to the way the JS API looks at instantiating a Wasm module

AR: yes but I would still guess that’s a much smaller change.

JK: Probably about the same. Most of the code you need is the same between the 2. Then you either need to implement decoding, or implement the builtins that recognize the builtins and dispatch them to the same place in the end.

CW: In the interest of moving on, we should moving on to the straw polls

AK: Presenting slide of two competing approaches? 

RH: on the “lightweight stringref” i think that could use some discussion, I’m not sure I really understand it.

AK: if it’s useful it might come out of the imports work as we do it.

CW: The way we should do this is how positive do we feel about moving forward with the string ref approach and then a follow up of the next one as well?


Question: how do we feel about moving forward with the stringref approach

* Favorable: 18
* Neutral: 10
* Unfavorable/Against: 9

Q: how do we feel about moving forward with the imported strings approach

* Favorable: 24
* Neutral: 13
* Unfavorable: 0

CW: thanks, that’s useful to inform future discussions

#### Update and Phase 1 vote for [Compile-time imports](https://github.com/WebAssembly/design/issues/1479) and [String builtins](https://github.com/WebAssembly/design/issues/1480) 

RH: [presenting, TODO add slides]

RH: also I don’t know what sort of vote?

CW: Given that we didn’t have any unfavorable results in the straw poll, I think unanimous consent would be sufficient, if anyone objects we can fall back to a full poll. We also need a champion.

RH: i could be the champion

FM: doesn’t this suppose that this proposal is winning in preference to stringref?

CW: Stringref is already phase 1, this is just putting both proposals at par with each other
CW: this looks like unanimous consent. Thanks to all the folks who put in all the work in preparing and discussion

RH: and prototyping, thanks to the V8 folks who did that.

Unanimous consent, Proposal at Phase 1

#### Introduce Mike Smith as the W3C contact

DG: I’d like to introduce Mike our new W3C contact

MS: we’ve been without much staff support from W3C for a while, but I’ve just started out. W3C doesn’t usually devote staff to CGs, only to WGs, but that doesn’t really matter because it’s all one effort with wasm. So I’m here to help support what the group needs to get work done. One area in particular is publishing. I have an action item to help get publishing working. But in general if you need support you can reach out, I can help. I plan to attend more of these meetings in the future

Note about October live meeting: https://github.com/WebAssembly/meetings/blob/main/main/2023/CG-10.md


AZ [chat]: Idea for future polls: rather than F/N/A we could use +/0/- which is less ambiguous

### Closure

"
main/2021/CG-03-30.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 30th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: March 30th, 4pm-5pm UTC (March 30th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Discussion and vote on CG stewardship of the Wasm Discord (Thomas Lively) [10 minutes]
    1. [Wasm/JS API integration for ResizableArrayBuffer and GrowableSharedArrayBuffer](https://github.com/WebAssembly/spec/issues/1292) for phase 1+ (Shu-yu Guo) [20 min]
        1. Poll: Should this go through the phases or a more streamlined process?
    1. Follow-on discussion on irreducible control flow [(previous slides)](https://docs.google.com/presentation/d/1KE7z7ry3VEug3nyIvnLwTtxxPhkp73CrYjpATpnNSF8/edit?usp=sharing) (Conrad Watt) [30 minutes]

### Attendees

 - Thomas Trankler
 - Thomas Lively
 - Derek Schuff
 - Zalim Bashorov
 - Sergey Rubanov
 - Ben Titzer
 - Slava Kuzmich
 - Yury Delendik
 - Ross Tate
 - Yuri Iozzelli
 - Chris Fallin
 - Alon Zakai
 - Jay Krell
 - Mano Koukoutos
 - Shravan Narayan
 - Sabine
 - Daniel Wirtz
 - Zhi An Ng
 - Nick Fitzgerald
 - Luke Wagner
 - Paolo Severini
 - Shu-yu Guo
 - Dan Gohman
 - Sam Clegg
 - Dan Weber
 - Andrew Brown
 - Deepti Gandluri
 - Conrad Watt
 - Ryan Hunt
 - Alex Crichton
 - Adam Kelin
 - Arun Purushan
 - Francis McCabe
 - Nabeel Al-Shamma
 - Asumu Takikawa
 - Petr Penzin
 - Emanuel Ziegler
 - Wouter van Oortmerssen
 - Heejin Ahn
 - Rick Battagline
 - Johnny Birch
 - Sean Jensen-Grey
 - Ioanna Dimitriou
 - Richard Winterton
 - Pixel 4a (???)
 - Jacob Abraham
 - Luke Imhoff
 - Paul Dworzanski
 - Jay Krell

1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Discussion and vote on CG stewardship of the Wasm Discord (Thomas Lively) [10 minutes]


NF: How does moderation work now, is that expected to change?

TT: Currently it’s up to me to decide. That’s the main motivation for asking if the CG wants to take it over. We have a CoC that’s similar to others, but currently I have to make the decisions, but I’d feel better if there were a process to handle any incidents that come up. There have only been 2, one was clearly just spam, it was an easy decision. In other, someone was insulting several members of the chat. I appointed one person as a moderator in that case but it would be good if there were clear responsibility

DG: No objections to pointing to the discord channel, it has become a resource for a lot of the community to go to. Maybe we can start with a vote if there are no other discussion items.

DG: quick question for TT, what your team of moderators look like, we can point to this being owned by CG, but no resource to actively monitor this.

TT: at the moment there’s not so much need for a team, there have only been 2 incidents, and I can handle administrative tasks. I’ve appointed a few people who are leaders in nthe community and I trust, but it would be good, if someone isn’t happy with decisions or wants to become a moderator, it would be good to have a clear path to escalate. Someone could talk to the CG, vote on the CoC, etc. It’s a bit more structured.
For the question of “how much work is it” , are more moderators needed, it doesn’t seem to be urgent need.

DG: thanks for running the channel so far

FM: Is there scope for using discord as community outreach for wasm from the CG?

TL: it’s already been pretty successful for outreach, we aren’t really looking to change anything right now. Is there something you'd like to see?

FM: at the moment, if you don’t know anyone, it’s probably quite intimidating to reach out to the official CG. As a way of lowering the on-ramp, having a discord channel, Ask-CG-Anything kind of thing.

TL: feels like it already acts like that

TT: a lot of members on the CG actively answer questions there. If there is a need we created channels for more specific discussions. If there is a forum needed, happy to create more channels. An AMA event will be interesting. Couple of proposals are in the pipeline, questions like is it done yet, when will it be done, hard for outsiders to answer. From outside it’s difficult to understand what is happening and what to work on.

TL: Don’t want to spend too much time, should we move to a vote?

DS: Haven’t heard anything in opposition, should we do a consensus vote? 

<Unanimous consent>


### [Wasm/JS API integration for ResizableArrayBuffer and GrowableSharedArrayBuffer](https://github.com/WebAssembly/spec/issues/1292) for phase 1+ (Shu-yu Guo) [20 min]
        1. Poll: Should this go through the phases or a more streamlined process?

<SYG Presenting the JS issue, Wasm issue. TODO: Add links>


SG: basically adding 2 new constructors to JS, counterparts to fixed-length array buffer and sharedArrayBuffer, to match the fact that wasm memories can grow, and also to support integration where everytime the memory grows, the existing buffer is detached and remade. So this detaching is a pain for users such as emscripten, where they have to poll or instrument memory accesses where you have to check when you have to invalidate your views. So here you can observe the buffer being grown without making a new one. So the question here is how to integrate with webassembly.memory in the JS API. There’s been discussion in #1292 and #1300 is the actual PR.

The ideas is that we won’t change the .buffer getter; it will still return the buffer. There will be 2 new methods to transition the mode of the memory to surface the fixed or resizable buffer. You can call toResizableBuffer() to get a resizable buffer with the same backing store and detaches any existing buffer. You can transition back and forth this way. If you have a resizable, then the buffer will not detach on growth.
If you call the resize method, it will throw if you try to pass an invalid byte length (that would be incompatible with memory.grow).
So I’d like to hear technical feedback and discussion, and also, should this be a proposal in its own right that goes through the phases, or should we do something more streamlined?

NA: does this change the behavior of growing the buffer on the Wasm side?

SG: This does not change any behavior on the wasm side, the JS proposal is written in such a way that the API allows for a reserve and commit strategy as well as a realloc strategy - the JS API always requires a max. On the wasm side, if you pass in max, then it is used in the memory constructor otherwise it is implementation defined. But should not be observable. The only think that is observable that the buffer object does not change

CW: we discussed in case where you don’t provide a max length, the JS max should be the web API max length. Did we have any more opinions on that

SG: not on my side, love to hear thoughts here

NF: what is the motivation for old buffer only be detached if you’re switching to a different kind?

SG: Good question, CW also brought this up - my hunch is that I don’t want the aliasing of multiple buffers to the same object, if we were to have an aliasing that is not concurrent… I guess I haven’t thought about it

NF: was imagining the other way, no matter what kind the previous kind was, even when going from resizable to resizable

SG: Amenable to that change, always detaching makes sense

CW: you don’t want to resizable to detach all, you don’t want them to call to resizable and never look at .buffer.

<in chat> LI: Side topic: What does the `%` in `%IsDetached(..)` do? I thought `%` could only be used for the modulo operator.

SG: In chat, there is no explicit API, imagine I have an internal API that lets me check that.

PP: would it be better to have some param in the memory constructor to turn it into resizable from the get go?

SG: That is extensible, one of my original ideas, not all wasm memories will be created from the JS side, so you will have to have this, one idea is signal intent during construction, but that seems like an overkill for something JS specific.

DS: any thoughts on how to do this procedurally? Not too many changes that are JS-API only changes. Normally we package those with changes to the core spec.

SG: Procedurally, TC39 has a staging model, similar to the phases model for wasm. One of the requests from TC39 before stage 3 is to have integration with the Wasm CG worke dout. That we’re not gating stage 3 on the wasm side. Should the integration PR go through phases? Or once the integration is finalized, to have a nominal change?

CW: motivation for Wasm side for going through phase structure is to make sure we have tests for JS API side before we move it forward.

SG: before we move on to procedural question, any question about technical stuff?

LW: sounds great. A resizable array buffer can’t be transferred via postmessage, can it?

SG: They have the same detach key, so no. Only memory.grow can detach memory array buffers.

DG: CW brought up a good point, want to make sure this has tests, aside of tests, can we do something more lightweight than phases model, we have no precedent, for the delta changes, mostly touching on JS API, we can do something like that

DS: we can poll phase 1, and go directly to phase 3 once we have tests. And shoot for phase 4 around the time it goes through TC39.

SG: sounds like a good suggestion, next TC39 is in less than a month, if we can get some kind of phase advancement, it will be a good signal for TC39, will ask for phase 3, then come back after some implementation work has been done, with tests, and final version of integration PR, further hash out details, something to play with behind a flag.

DS: In the spec repo, we have all these core tests, do we also have JS tests? 

ZN: <Yes, we do.>

SG: What do we do when merging with the threads proposal? I don’t know quite how to write the PR for that. 

DS: current thread proposal technically still at stage 3…

CW: 2 in fact, we don’t have tests, we need more formal semantics to go to stage 4.

DS: another option to merge this into threads proposal directly

SG: the non-concurrent parts don’t need to be gated on threads proposal. For SharedArrayBuffer parts, the semantics on growing these growable shared array buffers basically designed to be the same across Wasm and JS. We’re both happy with results.

CW: In terms of how we handle the spec, it may make sense to add the non-resizeable parts into the main spec, and then rebase the threads on that.

DS: we do phase 1 today, write some tests, if they are ready in 2 weeks we can poll again to move it along, that should send a clear signal to TC39 that we can fast track the non-concurrent parts

SG: sounds great to me




Poll
SF: 14
F: 17
N:
A:
SA:




### Follow-on discussion on irreducible control flow [(previous slides)](https://docs.google.com/presentation/d/1KE7z7ry3VEug3nyIvnLwTtxxPhkp73CrYjpATpnNSF8/edit?usp=sharing) (Conrad Watt) [30 minutes]

<CW Presenting [slides](https://docs.google.com/presentation/d/1CloQonh4aVfCO-Z2yX98EyWFo3uiBwXkY0symhIwDIU/edit?usp=sharing)>

RT: would like to hear from optimizers/engines, what their perspective is

BT: in V8, the optimizing compiler, not only the reg alloc, the scheduler, both will need to be upgraded to handle irreducible control flow. It would be a pretty substantial amount of work. Reg alloc probably easier than scheduler.

FM: This isn’t full unstructured control flow, this is a nicer target to map unstructured flow to. Not strictly unstructured.

CW: I guess it depends how restrictive your definition is. It can express arbitrary irreducible control flow graphs. But you can argue it’s not “unstructured” in the sense that goto is.

RT: It could be an arbitrary CFG, it doesn’t need to be a multiloop

CW: bikeshedding thing about the name, called it that because of analogy to existing Wasm loop construct.

FM: Multiblock..

CW: Wasm blocks you jump to end, here you jump to start

AZ: What about indirect GOTOs? Would you extend multiloop to support them?

CW: by indirect, do you mean computed? If static, you can use br_table. You’re right that this doesn’t support computed gotos, which are beyond even irreducible control flow.

BT: The problem with computed GOTOs is that you can’t guarantee that you’re using a label is being used in the multiloop construct. Very hard to track them..

CW: this isn’t attempting to express computed GOTO, only about irreducible control flow graphs

BT: would like to see data on how often irreducible control flow shows up, and potential impact. Fil Pizlo has done some experiments, which undoes switch construct, interested to see what performance gap is.

DS: We have some anecdata, when we switched from the fastcomp backend to the new upstream LLVM backend. Conrad mentioned AZ’s relooper paper - the CFG stackify algorithm is the new backend.. When we went to switch the production backend to the new one, we found that most programs have irreducible control flow. It was a noticeable difference so we had to rewrite the irreducible control flow handler.. So there’s evidence that is is there everywhere, also found instances in libc.

YI: cheerp compiler, similar thing, when we implemented stackifier (similar to llvm algorithm), at that time llvm was using unoptimized version, the difference was apparent. If you want some examples of kinds of programs, I remember protobufs autogenerated code, a lot of jumps within a switch in a loop. A lot of improvement in python programs, because of the main loop.

AZ: the big optimization we did in LLVM was actually a bug fix, llvm was identifier things that are reducible as irreducible and generating unnecessary code. Irreducibility is common, it happens in some core libc thing, in musl for example, printf code. Not performance sensitive code, not sure we gained much on benchmarks. The bug fix was a big deal, irreducibility was not a big deal for speed, because critical code tends not to be irreducible, at least on the benchmarks i’ve seen.

AZ: If the main problem is the producer side, we could implement multiloop only on the tools side, we can have cmd line tools that convert multiloop file into something that the VMs can use. This is very interesting at least for the tools side, and I’d be happy to do that work on the tools side. 

RT: on local control flow, where every block is its own thing, when you consider exception handling, what happens when multiple blocks share the same handler, you will get a conflict.

CW: at the level of Wasm semantics, the most natural one is, if you have exception within one body, you break out of the multiloop as a whole, and go one level up. Will there be an issue with preserving source level semantics.

RT: The catch might also be a part of the loop, you have to stagger the CFG, that doesn’t solve the problem unfortunately.

TL: thinking of the transformations we have to do to make multiloops with exception handling, seems complicated

AZ: non-nullable locals, some idea for lets rely on shape of blocks, will need to think of how that fits with multiloops, maybe simpler with exceptions

HA: Currently it is possible to place a handler somewhere outside, then we can target the catch handler somewhere outside the loop using delegate. Maybe I’ll look at multiloop more, we haven’t thought about specifics. 

CW: also my naive expectation how exception interacts with multi loop. If you have a catch inside a loop, then inside the source program you go to inside of catch, how to translate that into multiloop in a semantic preserving way, might work by putting the catch slightly out, or maybe indirection only in the catch block. Not thought about.

HA: The piece I was thinking about is not that, if you’re jumping into the middle of the catch block.. That I have to think about..

RT: AZ mentioned, there may be a few cases where we have parenthesis that spans multiple blocks, don’t’ work well with multiloop

CW: <something about one-pass validation>

ID: are you familiar with common LISP’s TAGBODY go?

CW: No...

ID to post a link on the chat <http://clhs.lisp.se/Body/s_tagbod.htm>

DS: Are you looking for any particular action from people?

CW: will post issue summarizing discussion, on eh interaction with multiloop, and how would we do performance motivation for this.
"
main/2020/CG-06-23.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 23rd video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: June 23rd, 4pm-5pm UTC (June 23rd, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. [WebAssembly Instrument and Tracing Technology](https://github.com/WebAssembly/design/issues/1344) (Richard Winterton)
       1. Poll: Phase 1
    1. Advance [reference types](https://github.com/WebAssembly/reference-types/) to phase 4 (Andreas Rossberg)
       1. Poll on removing type annotation on ref.is_null ([issue](https://github.com/WebAssembly/reference-types/issues/99))
       1. Poll on advancing to phase 4
    1. Advance [bulk memory operations](https://github.com/WebAssembly/bulk-memory-operations/) to phase 4 (Ben Smith)
       1. Poll on advancing to phase 4
    1. Advance numeric values in data segments proposal ([discussion](https://github.com/WebAssembly/design/issues/1348) and [semi-formal description repo](https://github.com/echamudi/numeric-values-in-data-segments-wasm-proposal))
       1. Poll on general interest in this proposal and advancing to phase 1
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Adam Klein
* Alex Crichton
* Alon Zakai
* Andreas Rossberg
* Arun Purushan
* Ben Titzer
* Christophe Scholliers
* Conrad Watt
* Daniel Hillerstrom
* David Piepgrass
* Deepti Gandluri
* Derek Schuff
* Ezzat Chamudi
* Flaki
* Francis McCabe
* Gergely Buday
* Heejin Ahn
* Ioanna Dimitriou
* Jakob Kummerow
* Jay Phelps
* Jlbirtch
* JP Sugarbroad
* Lars Hansen
* Luke Wagner
* Mano Koukoutos
* Mingqiu Sun
* Mkawalec
* Nabeel Al-Shamma
* Nick Fitzgerald
* Paolo Severini
* Pat Hickey
* Paul Dworzanski
* Peter Penzin
* Richard Winterton
* Rick
* Ross Tate
* Ryan Hunt
* Sabine
* Sabine
* Sam Clegg
* Sam Lindley
* Steve
* Steve Sanderson
* Sven Sauleau
* TatWai Chong
* Thomas Lively
* Till Schneidereit
* Wouter Van Oortmersson
* Yury Delendik
* Zalim
* Zhi An Ng

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Richard Winterton seconds

### Proposals and discussions

#### Review of action items from prior meeting.

#### [WebAssembly Instrument and Tracing Technology](https://github.com/WebAssembly/design/issues/1344) (Richard Winterton)

[Richard Winterton presenting]
[Slides](https://docs.google.com/presentation/d/1bkp6QjLqRgw-E7IuDWlVIKJYo9nxetf4eShaHlk1jYw/edit?ts=5ef220c6#slide=id.p1) <TODO: RW to make it link accessible>

RT: What are the semantics of this? How can you reorder this instruction with other instructions? What is the meaning, even if it doesn't have performance implications.

RW: when you see this instruction, you interject into the actual code being generated by the runtime. Usually put it before and after hotspot, so you can narrow down which part of the code is instrumented. You can put it higher, simulator can put it lower, reorder it.

RT: Wasm doesn't have any baked in order of instructions, a compiler doesn't do anything unless it has meaning. It could move it around anywhere.

RW: we ran into that...

KM: should this be considered the same as a call, no re-ordering?

RW: yea. This was optimized away since it wasn’t doing anything. At one point during testing we had to add in a different immediate value to try and not get this optimized away. This needs to be worked out as part of the implementation of runtime.

RT: keith’s suggestion for this as an abstract function call should work.

LH: Atomics also have strong prohibitions against messing with them, so that's possibly another model.

RW: that will work as well

AR: trying to understand this semantic. This behaves like a nop/fence? No observable effect inside the programming model itself.

RW: For the implementation, at least in Intel, we'd need to see a load into the EBX register.

AR: that’s not semantics right? What does this mean? In a portable manner. I’m a producer, emit these instructions, what effects do I expect. If there’s an immediate what does this mean across different platforms. 2nd point is, what can this do that a custom section could not do? E.g. a section that tells you a certain nop is instrumentation.

RW: You could do a custom section with this. It would also work. The only thing I would want is that an end-consumer could use this without having to rebuild the runtime, we could just use the production versions of the runtime. It needs to have a special instruction format in the output, for Intel that's a specific instruction sequence.

AR: in Wasm code, with a certain immediate, you have been discussing this on intel, what about on ARM?

RW: ARM could just do a NOP.

AR: If i Want the instrumentation..

RW: They could do whatever ARM wants with that instruction, they would have to define it.

AR: won’t that you require a platform independent meaning of that immediate, how else can  the producer choose what immediate to emit?

RW: THe immediate is just an identifier in a register -- you need an identifier to say start and stop. Imagine you have an inner and outer loop that you want to trace, you can bracket each one independently. 

AR: So it's an abstract ID?

RW: yea exactly

TL: It's basically a no-op with platform-dependent modeled side-effects, right?

RW: no-op instruction, something we have to figure out how to, e.g. loading ebx register, make sure nothing is corrupted

RT: So semantically it's an abstract function call (or 16 function calls), but it's important to implement those as a concrete instruction that the target platform knows what to do with it.

TL: we didn’t merge that (intrinsics) into schedule, have to talk about that next time.

BS: no further questions, let’s take a poll


#### Poll: Phase 1

Any objections to unanimous consent? [no objections]

DG: Is ITT a trademark?

RW: good question, need to check

LI: intel lower cases it on their docs, only trademarked intel vtune profiler

RW: whether it’s registered by some other company, i don’t know

#### Advance [reference types](https://github.com/WebAssembly/reference-types/) to phase 4 (Andreas Rossberg)

AT: Ben Titzer had a comment on the issue last night, can you talk about that?

BT: We split out funcref from externref since they might be implemented differently on different engines. If we have that type annotation on ref.is_null, then the engine knows which value it can compare against. But otherwise it needs information from the operand stack, which is information from validation. We didn't do this in wasm previously, this would be a place we would deviate from that.

AR: i called this out in my presentation last time, this will be a change in the design direction. So far we have the property that every type is self contained. Except we have polymorphic construction (drop and select). This would be somewhat similar, the polymorphism isn’t over a random value type, but over a heap type. The effect is somewhat similar. In both case, the compiler might specialize based on which operand. Diff opcodes on diff CPUs, maybe depending on floats/size of operands. This is not qualitatively new, maybe. The more relevant qns is where we want to move from here. Before we removed subtyping from ref types, we didn’t need to resolve this. But now we have to decide now. I think this is not a property that’s worth maintaining long term. Will have many instructions that will need heavy type annotation. E.g. GC, every instruction will need to annotate type in some way, seems over the top, since you have to look at the type in the validator anyway. If you have annotation, it’s more work since you have to check, and the validator already does that anyway.

RH: I wasn't around for the initial design here -- what was the motivation for having this property initially?

AR: good qns. I don’t really remember. I do remember: we had a discussion about overloading, which we don’t want. E.g. for addition we have different instructions, not just type annotations. The argument here is that semantically they are different. But for this case, it’s uniform behavior, regardless of specific type, even if for implementation you do type specialization, observably it is the same.

BT: In general it was an argument about inference vs. checking, that we should favor being explicit. You mention you can add an annotation in the AST, but an interpreter can't add a place to annotate. In general an engine doesn't always use an AST.

AR: fair point. The design of Wasm has never been in favor of interpreters, not a design goal initially, may be a mistake? Personally I will be fine with this penalty on interpreters. Is this specialization something you would want to do in the first place?

BT: It's conceivable that you might use the type as an index into a table, but you probably wouldn't specialize.

JS: isn’t that equivalent to the validation that we don’t want people to do now?

BT: Imagine that you have two different types that are nullable that have different representations, one 64-bit and one 128-bit for example. Would it have to look at the top of the stack to determine what to do, or what it already know what to do.

JS: but what does the interpreter do if you get drop?

BT: An interpreter typically makes them all the same size, so it knows it can make it generic.

JS: in the case when these instructions have to do extra work, drop also has to do extra work

KM: For drop at least on 64-bit, it doesn't matter.

JS: most interpreters will make null the same, zero value

KM: agree, not super concerned about this too

BT: It depends, you may have an external reference type, the null isn't up to the engine, it's up to the embedding.

JS: i think the point is made, there is a cost

BT: In the future, in general, null is something that comes with the type. So finding which null you're talking about may come with the type. It seems like there's a symmetry we should keep, but it's not the strongest argument.

AR: That was my thinking initially. But there is a fundamental difference between is_null and null. One is a producer, one consumer. Natural that in a linear type checking, you need to annotate producers but not consumers. Something similar will show up in GC, you need to annotate struct.new, you have to know what to produce, but don’t necessarily want to annotate every get.

RT: For overloading in general, it causes problems when you can refine the input type and that changes semantics. That's the difference between ref.null and ref.is_null, with is_null you can look at the input type and determine the output, but for null you have to guess what to produce.

AR: How strongly do you feel about this, Ben?

BT: small change, it is there now right?

AR: we had an informal poll to remove it, no disagreement. The removal of annotation is done in v8 and spidermonkey

BT: i don’t think we should churn again

AR: should we proceed with poll?

JP: on ref types. The assemblyscript folks talked about... we made the rename of anyref to externref in binaryen, but haven’t remove the subtyping relationship. If the tools/languages have not implemented those, and we move to stage4, it feels premature. I would feel better if there are languages that have moved to supported.

JS: right now we just polling to remove type annotations. Not phase4

JP: got it

JS: by consent?

BS: yea sounds reasonable, especially since we had the straw poll 2 weeks ago. Any objections to removing type annotation on ref.is_null?

#### Poll on removing type annotation on ref.is_null ([issue](https://github.com/WebAssembly/reference-types/issues/99))

[no objections]

Poll passes.

#### Poll on advancing to phase 4

JP: binaryen has not yet done it. No one is using it in the wild. I don’t have evidence of that. On AssemblyScript side, it is a notable change to the AssemblyScript compiler, no limitations now. But feel like phase 4 signals everyone is confident that this is what we want. I don't think we have that signal.

TL: From the binaryen point of view, I wouldn't want to hold up stage 4. It's true that we haven't removed subtyping, but it isn't going to be a big change.

RH: on rust side of things, there is a tool called wasm-bindgen. One of the things is you can introduce anyref on the boundary. That has been updated to support changes. Wasn’t much work since we didn’t rely on that. There is a production tool out there that supports these changes.

JS: did not know that, makes me feel better. No objections if no one else.

KM: what is the toolchain then?

TL: yea wasm-bindgen would count

BS: it was brought up, wasm-bindgen is listed there

AC: has full support, not a ton of benchmarks. Wasm-bindgen is the story for rust and reference types

KM: wasn’t trying to dispute

AC: yea, just clarifying

BS: Any questions about phase 4 toolchain requirements? Or any other questions? We discussed before that we have all the requirements necessary, let’s poll.

Poll:
| SF | F | N | A | SA |
| - | - | - | - | - |
| 22 | 18 | 5 | 0 | 0 |

AR: thanks!

Reference types advances to phase 4 :party:
Congratulations AR!

#### Advance [bulk memory operations](https://github.com/WebAssembly/bulk-memory-operations/) to phase 4 (Ben Smith)

BS: ref types and bulk memory are interlinked in a lot of ways. Advancing ref types since it is dependent on bulk memory kinda means we have to advance it anyway. Any questions or issues?

TL: only memory part implemented, table instructions are not

HA: wasm-bindgen?

TL: I am not concerned about whether we implemented enough. But no toolchain uses table instructions. I don’t think wasm-bindgen uses the bulk table instructions

BS: similarly there is not table.get table.set uses

NF: wasm-bindgen will use those, rewrites the binary after llvm

BS: question is, which instructions are being used. If they are being used by ref types, it’s a question of specific instr, table.init and table.copy

NF: table.set get grow, only use.

AC: we are not using table.copy and init

JS: pretty sure binaryen has implemented this

TL: Binaryen doesn’t fully implement it yet, we have plenty of toolchains that implement half of it, personally not against moving this forward, but wanted to point out that it’s not fully implemented

JS: i think i’m still okay with it

AR: some of the table bulk instructions ended up there

BS: only one is table.fill

AR: grow as well

BS: discussed, table.fill moved to ref types, requires a ref as a value to fill. There is a qns about that, is it required that tools use all instructions from the set? Seems like a strong requirement, some tools will not need. Perhaps we should revisit in 2 weeks, and have a larger discussion.

JS: We wanted a toolchain that allowed - advancing to phase 4 means that toolchain has them, and we can experiment with them.

KM: some concerns in the sense that... it will be weird to have these requirements and not follow them. For JS standards it’s a bit different, we have requirements, and those are valid reasons to object/block. It’s consensus. I’m just strawmanning this. If someone cares, and blocks it. This can be a precedent

HA: even if we go back and implement these instructions, then we are not going to use it in the near future, no use case. Not sure if implementing it is any different from not having it. 

NF: Wams bind-gen is in the same place, as a user facing tool, it doesn’t need them right away which is why it doesn’t have them. 

RT: meta-concern, why are we adding instructions that no one needs?

BS: let’s pause this, we have 1 minute left. Seems to me like agreement - most people not willing to hold up, but we are concerned. We should have a separate discussion about this topic. Let’s plan to have a discussion in 2 weeks time. Can get agreement that no concerns about it.

[Room agrees]

AR: Also worth pointing out, that it’s recursively dependent proposals for bulk memory, reference types mean that we can’t land one without the other


BS: Lots of SFs before this discussion, so would like to move this forward, if anyone objects please voice your concern. 

[No objections from room]

BS: Will be taking this as interest to move the proposal forward

Poll:
SF: 21
[poll cut short due to above discussions]
F:
N:
A:
SA:


#### Poll on advancing to phase 4

#### Advance numeric values in data segments proposal ([discussion](https://github.com/WebAssembly/design/issues/1348) and [semi-formal description repo](https://github.com/echamudi/numeric-values-in-data-segments-wasm-proposal))

#### Poll on general interest in this proposal and advancing to phase 1

BS: poll from 2 weeks go

Consensus poll:
Consensus.
Congratulations to echamudi@!

### Closure
"
wasi/2019/WASI-06-27.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the June 27 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: June 27, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
        - Import names
            - https://github.com/WebAssembly/design/issues/1286
        - Weak imports
            - https://github.com/WebAssembly/WASI/pull/47
    1. Meeting Schedule
        - It was pointed out that having the WASI meetings the same week
          as the CG meetings is inconvenient for some. Should we change
          the schedule?
    1. IDL
        - Cap'n Proto: - https://github.com/WebAssembly/WASI/pull/58
        - What action items can we take here?
    1. Blockchain call extension
        - https://github.com/WebAssembly/WASI/issues/56
        - Meta-discussion: How should we approach new API proposals?

1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

2019-06-27 WebAssembly CG WASI Subgroup Video Meeting Notes

Agenda: https://github.com/WebAssembly/WASI/blob/main/meetings/2019/WASI-06-27.md

Attendees:

Dan Gohman
Luke Imhoff
Sergey Rubanov
Paul Dworzanski
Pat Hickey
Alex Crichton
Martin Becze
Till Schneidereit
Lin Clark
Mark Miller
Mark McCaskey
Sam Clegg
Nick Hynes
Jakub Konka
Jlbirch
vwo

Meeting notes:

DG: Second agenda:
Luke Imhoff seconded. (Till seconds for posterity)

DG: Import names Proposal: presenter is not here, lets move on to the Weak imports proposal

SC: We talked about the weak imports proposal at the Wasm CG meeting about whether to represent weakness in the function name versus a custom section.

DG: … align with the (missed it) proposal

SC: I can update the proposal to go back to being a custom section. The function is imported as normal but whether or not it is allowed to be missing at runtime is specified in a custom section

DG: This allows us to skip all the questions about name mangling, polluting the import/export space

SC: One issue is that the embedders will have programmatic access to the module versus parsing the bytes, e.g. through the javascript api.

DG: It makes sense for there to be a custom section javascript api that can do this for you.

SC: I’ll update the PR to go back to custom sections

DG: What is the point where we can establish a baseline for modularity and move on to breaking up the stuff currently known as wasi core into modules?

LI: Will the JS embedding have a weak imports attribute on imports? What about support in all the browsers?

DG: If someone doesnt support the custom section then they just have to resolve all of the weak imports, and if they cant provide all imports then instantiation will fail.

LI: Can toolchains ship js that detect that instantiation failed, and use a different binary?

SC: The point of weak imports is that only a single binary is needed

DG: In web use cases browsers might not support the weak imports natively but you’ll be shipping a JS polyfill for those to implement WASI anyway. You either support WASI or you don’t. Supporting WASI includes support for weak imports.

LI: Will there be a document that explains the layering of these various features required to support WASI?

DG: Sam’s document is a start on that. We need to do more to clarify on the layering. Sam, Can you add more to the document to show how it fits into the bigger picture?

SC: Yes it makes sense to make all of that part of the core wasi spec. The things we’re talking about being in the core so far are the import system, modularity, naming conventions, application lifecycle

DG: This will be easier to do once we have more of the import stuff in place. I’m proposing we defer more explanation until we have the import system figured out.

LI: There was back-and-forth about different patterns of WASI modules, reactor and command, in the spec - was there more discussion about that?

DG: That is ongoing. This can be an adjunct to snowman bindings - the reactor and command model can be adjunct to the spec about bindings, since bindings are specifically about how to use a module, and so is a description of the lifecycle

SC: ES6 Modules need the same sort of lifecycle support as WASI does

DG: We’ll also want a custom section to say the entry points of applications and so on.

LI: Where do I subscribe to updates on this, how far is it in chromium or mozilla?

DG: I don’t know about that, https://github.com/WebAssembly/esm-integration tracks the ESM integration status but nobody here knows about the status of it in browsers right now.

TS: The status of Node is they have almost complete implementation. I’m not aware of browser implementations that have made significant progress.

LC: I’m not aware of any advances of implementations, apple had an early implementation but i’m not aware of updates given the changes to the proposal.

DG: Let’s move on to the next item, left out of the agenda: last meeting Mark Miller discussed a vision document that laid out the use of Object Capabilities (OCap) in wasi.

MM: Yes thanks for the reminder. It had dropped out of mind.

DG: That’s ok we’re all busy here.

MM: At the wasm blockchain meeting we discussed styles of ocap systems that do not support virtualizability, versus method style, where the behavior of a call on an object is up to the implementer. (...) and I looked at using a Capnp-like IDL to describe APIs in an object style. (unintelligible) looked at an IDL that could fetch type bindings and an adaptor from old style bindings to new style, to realize the virtualizaiblity of ocap systems.

TS: Mark you’re dropping out a third of the time unfortunately.

MM: Ok I will put my concerns in the document that I need to write.

DG: Mark and I discussed this and it is a big idea that I think needs to be explained in detail.

DG: At the CG we had feedback on the meeting schedule. Right now we’re on the same week as the Wasm meeting, an arbitrary choice. Would people prefer to change it to the opposite week?

LI:  I’m the one that brought it up, it would be nice to have more open time around lunch on these weeks (in my time zone).

DG: As a poll, does anyone object to moving it to the opposite week from the CG meeting?

(no objections)
DG: Then we’ll skip next week, the next meeting will be scheduled for 3 weeks out so that it alternates with the WASM CG call.

DG: We also have an agenda item for talking about the CapnP issue: https://github.com/WebAssembly/WASI/issues/56, Martin can you fill us in:

MB: I prototyped what it would look like to describe the interface in terms of capnp, we got feedback on that which was helpful. The impression I got from everyone is that customizing the Capnp idl is appropriate, we’ll write a custom IDL that is influenced by capnp and I’m working on that right now.

MM: You saw my attempt at a BNF of the relevant subset of Capnp?

MB: Yes I want to rework my pull request with that in mind. We want to pull out the versioning integers on all of the methods, and adding (missed it). It would be nice if we could express things like the ability to import globals, memories, tables, as well as functions. It would be nice if it looked like the rest of the webassembly stack, so I was looking at using s-expressions.

MB: We need to figure out how this maps to the snowman bindings, I talked to Dan who explained more about how that worked. I see the point of the snowman bindings now. I think it would be interesting to reuse the ideas from the GC proposal re defining structs and so on, and having a binding section from the snowman proposal to describe how they are bound.

TS: Martin, the original motivation of snowman bindings (prev webidl bindings prev host bindings) was to make DOM apis fast, interacting with them directly from wasm rather than going through javascript. While by now we have lots of reasons to want these bindings, that is still a requirement of the snowman bindings. How are you making sure that your work stays compatible with that, or are you focusing on the syntax layer and it won’t interfere with that?

MB: I’m not considering how we’re binding to JavaScript, just interested in how to express the structures that these interfaces pass around - e.g. how do we express the structure of a directory entry and how do we read and write to it? That is partially covered by what snowman bindings does so we should reuse that. Maybe snowman bindings does cover everything we need. But the syntax should look like everything else

TS: It seems like the syntax is purely in the tooling space

MB: We have the syntax from GC to express struct and arrays, I think that's all we need to express things like directory entries. I want to reuse that syntax, and use that as a path for compatibility with GC implementations in the future.

DG: Take the set of bindings and types we have in wasi core as the base language, and the IDL describes what those are and gives us the clean descriptions we want

MB: The tooling is a big hurdle in webidl right now, we want to make it easier for people to read and write these descriptions.

TS: That makes sense. Luke wagner has had a lot of conversations around this, including with all the webidl people. They are all open to improving things. Its clear that snowman bindings won't be webidl bindings, but they need to be semantically compatible enough to describe the dom bindings pieces. If we end up having different surface syntaxes, thats fine because its mostly about tooling, but I also think we should have something that is not gratuitously different. One constraint is that browser implementers will have to be able to consume webidl in order to make the dom bindings work (already used throughout browsers). Keep in mind that there are constraints that don’t allow us to completely evolve this tooling in ways that break the DOM bindings use case.

DG: If you can go with whats in snowman bindings now, and build on top of that, then we can achieve the parity we’re going for without defining new semantics. The key vocabulary is the types and the operations. Webidl has a lot of things in it that are distracting, even if you reduce it down to just the parts we need there are still syntax things like how “unsigned long” is the way to write u64, so i’m sympathetic to changing that syntax.

MM: When I did my minimal BNF subset of capnp, I did take a look at the WASI ABI document and all of the capnp names for the types like u64 seemed obviously much better. I did not include wasm-specific concepts like memory, I agree that's an important thing to figure out how to accommodate.

DG: Actions going forward: martin will take the capnp PR and make a version with the new syntax.

MB: I will get that done in the next week and get more feedback.

MM: There is a long term issue of how we support, at the wasm level, how we manage method dispatch. There are several ways we could map that to the current wasm, none of which are very natural. This problem goes away with GC but I continue to assume that is a long ways out. The smallest step from where we are to a natural method dispatch binding would be to add sum types, where sum types are passed on the stack rather than by separate allocation of reference counts, and the message - the thing that one invokes - would be a sum type where the constructor is the method name, and the contents of that branch of the sum type are the arguments, and the pattern match at the receiver would be the method dispatch. Given that we’re doing an IDL we dont have to decide up-front what the method dispatch representation is, but it would be good to have a candidate in mind.

DG: My understanding is that not everyone has seen material on dynamic dispatch, so it would be a good thing to start with a paper on how dynamic dispatch works and what use cases it has
MB: Once we have proper function references doesn’t that cover? Are sum types part of GC?

MM: The repr of sum types I’m thinking of would not require dynamic allocation so we could implement it before GC. It would still be a significant additional piece of engineering. The problem with just using function pointers is that method dispatch with what we have now, the options are 1. You pass by copy a record of function references, and the client of the object invokes a method by looking up the method name in that record, the problem with that is the size of the reference to the object is passed by copy and proportional in size to the num of methods on the type.
2. You pass by reference a … it loses the static type information given our current system, so you’d have to cast after the method lookup to the right signature.
None of these are natural for intra-module communication given the current wasm representation of things.

DG: One thing we talked about was virtualizing an API and how we might do that. Dynamic dispatch approach allows you to virtualize in more ways. There are a lot of new ideas here and we need to motivate what problems we’re solving here and spread the ideas more broadly.

DG: Lets move on to the next issue, the blockchain call extension. The main thing I want to address is the meta-discussion of whether this digs inside wasi. Nick are you here?

DG: I encourage folks in the blockchain space to submit proposals, it fits well with our modularization story. It is a bit ahead of the curve as we’re still figuring out how imports and weak import names and so on.

DG: Implementers of wasi that don’t have anything to do with blockchain wouldn’t have to implement these interfaces but its good to have the standard for how they work all in one system.

NH: (missed it)

MB: It would be nice if we had an interface for persistently storing function references and loading them. One idea is that we could extend the number of file types to one that could load a function reference and put it into an anyfunc table. This would require the call-ref operation to call the method, from in the function refs proposal.

MB: The file types we have now are a file, directory, block device, character device. Are there problems with extending those filetypes?

DG: Part of that question we might not quite be ready to answer yet. Does anyone have problems with extending the idea of a stream beyond posix-style streams?

LI: If plan 9 could do it we can to
DG: We can talk more about stream APIs but I think extending streams to be useful for blockchains is a good idea, as long as it does not incur a cost to implementors that dont need blockchain.

LI: We say blockchain but is any o f that not descended from etherium?

NH: I want to generalize this in way for systems beyond etherium descendents

MB: I worked on ewasm and dfinity, I also want this interface to work beyond etherium family as well.

MM: The plan at agoric for using blockchain and wasm is not etherium-like, it is consistent with ocap approach, and the issue of dynamic dispatch becomes important to us.

DG: For some context there's discussion in the CG about webvms and the requirement for 2 implementations that are webvms. In wasi we’ve decided that the committee would accept non webvm implementations and make decisions on what exact vms would be accepted as we go

LI: Whatever system we come up with should handle more than just one currency, it should handle multiple currencies on a single chain

MB: We should standardize that we aren’t dealing with one particular currency. This would probably be a good document to put together.

DG: We should record our thoughts on what requirements we have for blockchains. Martin can you write up … we want diversity, we want to make sure we’re standardizing on something that more than one implementation will use.

NH and MB will collaborate on that document.

DG: Any further items?

Meeting adjourned
"
gc/2020/GC-09-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 9th video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: September 9th, 4pm-5pm UTC (September 9th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Follow-up Q/A on low-level GC research presentation (@RossTate) [10 minutes]
    1. Discussion: Resource Limits [#122](https://github.com/WebAssembly/gc/issues/122), [#35](https://github.com/WebAssembly/gc/issues/35) (@brion) [10 minutes]
    1. Discussion: Requirements [#121](https://github.com/WebAssembly/gc/issues/121) (@fgmccabe) [40 minutes]
1. Closure

## Meeting Notes

### Introduction of attendees

* Adam Klein
* Benjamin Titzer
* Ben Smith
* Brion Vibber
* Daniel Wirtz
* Dmitry Bezhetskov
* Emanuel Ziegler
* Francis McCabe
* Jakob Kummerow
* JP Sugarbroad
* Keith Miller
* Luke Wagner
* Ross Tate
* Ryan Hunt
* Sabine
* Slava Kuzmich
* Thomas Lively
* Tobias Tebbi
* Zalim Bashorov
* Zhi An Ng

### Adoption of the agenda

Francis Seconds

### Discussion: Follow-up Q/A on low-level GC research presentation (@RossTate) [10 minutes]

RT: two weeks ago, i gave presentation, no time to discuss, want to discuss take aways. One topic has been raised that I can follow up on.

FM: One question I have. Been a long time since SOIL initiative has been released. What's the status of that? Compared to the two-types/butterfly proposal.

RT: feedback we have gotten is that we should simplify it. Some ideas on what to do there. Designed to be forward compatible with the direction that current proposal is taking. The butterfly proposal OTOH points out some deficiencies in both that and the current mvp. Double array gives a lot of flexibility. Easy to extend those proposals with that. 

RT: There's an issue… SOIL initiative is drafted as taking these ideas and seeing what you can do with them. There's another issue that's trying to find the smallest steps. Not discussing that today because Andreas isn't here to discuss it.

RT: Because of the presentation, some people brought up issues with importing. We've been trying to go through a bunch of examples and work them out. The pattern seems to be that the examples -- in high level languages there's a difference between nominal and structural, at lower level you need something else. e.g. you need RTTs to be able to cast. So we find that the same number of imports is required for structural and nominal. Maybe discuss at another time.

LW: remember that there are a whole bunch of objectives achieved, validation time and binary size matters a lot. Trying to think if inferability, independent of the other two, matters. It allows the producer toolchain to be unmodified. What could be done is that the whole toolchain works with a set of types, then final stage shared by final steps, with †˙´ final step doing the inference. The wasm that goes over the wire is optimized for the first two objectives.

RT: That's the model that I thought made sense for Wasm. That we have a pre-wasm thing, then a common thing that fills that in on server side. then when you ship it over, it fills it in. Engines shouldn't do inference, the times are reasonable, but...

LW: Balancing act there is binary size and validation time.

RT: inferability important on the producer side, don’t think it has to be part of the Wasm standard

TL: Follow up on that. Binaryen is in a pretty good spot to be a final tool shared across the ecosystem. So if that's something we want to talk about more, we can talk about an API on Binaryen to make that easy for other producers.

RT: we as in you and me, or we as in group.

TL: we as in the group, pull in more binaryen people

BS: about at the time box, next topic

### Discussion: Resource Limits #122, #35 (@brion) [10 minutes]

BV: One of the things that I'm researching is web-based language for user-generated scripts, and I need to sandbox. There's an obvious benefit for GC proposal, one thing that worries me is that you can DoS the host, by allocating a lot of memory. Found that in JS Chrome and FF let's you allocate until system is not responsive, Safari is a little more conservative. If that's something that's still possible in wasm GC, I would worry about that. I'd like an acknowledgment that there's understood restriction, or someway to set resource limits in a specified manner and not host-specific manner. Question is, should it be possible to have resource limits on GC objects. And how to do it? I know it's difficult to add, but I think we should discuss.

FM: are you proposing resource constrained computation as an idea?

BV: something to consider, at the higher level, browsers are able to protect browser shell from JS environment, but coarse, like killing an entire process, or they don’t do it at all. It is non-trivial, otherwise browsers will do it more.

FM: The trick is to do it without losing performance.

BV: if you have to annotate +/- count on every alloc/dealloc, it may be unacceptable.

RT: Right now we have memory as a thing that has to be imported or created. Maybe you should also have to allocate a heap space, and each allocation has to say which heap space they allocate from.

BV: really like that idea, think it would be a straightforward way to implement, not sure if browsers will want to implement that

RT: I can see making that happen. It would hook into other ideas that are circulating. How easy would it be for a browser to track which space they're in. Whether they would know which space they're in.

BV: suspecting that linking objects with references between heaps will be difficult in that scenario, difficult for interoperability

LW: I've thought a little about this, about quota and resource management. Maybe there's a role for a holistic approach for GC memory, and stack, and resource that could grow unboundedly. I've seen this come up. Where there's an inner program and and outer program, and the outer program is more trusted. Wasm is pretty good here, aside from this case. Maybe a more holistic approach…

TT: also really depends on trust level, if we don’t trust a program, then you probably want to be safe from it from security, you probably wanna be safe from spectre, want process boundary with e.g. untrusted iframe. It’s not interesting as a Wasm feature anymore.

BV: At some point you can no longer call it directly, and it's less exciting.

LW: interesting use case, figma uses Wasm to sandbox plugins. Not absolutely zero trust, it’s a question which side of the line resource utilization falls on. In that case they use an interpreter.

BV: any more comments? Or out of time?

BS: is concerning that you can take down the entire browser/OS in this case. Does feel like a separate issue.

LW: taking down more than a tab seems like a browser issue.

BV: I have reported this bug to FF in the past, but it hasn't been fixed yet.

### Discussion: Requirements #121 (@fgmccabe) [40 minutes]

FM: I revised my slides from before, I can at least start that. Should I do that?

[Francis presenting slides]

[TODO(francis): link to slides]

LW: One of things I've realized talking to folks outside the browser. the need outside the browser is lower, since inside the browser you need to collect cycles across browser GC. Outside of the browser we don't care about this as much. The major consumer is browser GC, the major stakeholder to make happy is the browser. It seems increasingly likely that...

JS: two different ways i would disagree, first is that we’re seeing, e.g. WASI, designed under the assumption that GC isn’t available, to create coherent distributed lifetime between embedder and module. If this was available, they may have decided to use lifetime tracked externrefs, or some minimal GC. There’s an aspect of, if you build it they will come. The other one is that, I work in Android, one of the requisite for coherent binding, will be ability to pass objects across boundary. In the absence of this, you’ll need some kind of wasm-bindgen style shim, so far this has been unpalatable in the Android context.

LW: Let me ask follow-up… does Android currently in the design of its APIs lead to cycles between guest and host, with GC. [JS: yes, lots and lots of callbacks] That puts it in the same context as the DOM, then. It would make sense then that Android is a significant target for host-cycle collections. On the former item, as being part of the WASI discussions. The design of an API can force a host-guest cycle collection, I think we want to prevent that. Some languages can't use GC, like C, so we put C in a bad place if we have a GC requirement for the system. So I wouldn't include the first one as a motivating case.

TL: how much energy is there in the active WASI ecosystem for bringing languages that will require GC in order to target Wasm at all. Currently WASI seems focused on linear memory languages.

LW: The assumption here that is proven out by Blazor and Go, is that you can port these languages to wasm and use linear memory...

TL: in the WASI context where download size is not a big deal, perfectly acceptable

LW: We've heard from these languages that, when if we ask whether they'd use wasm gc, they say no, they want to do their own tricks, they need their own GC. So you're making a tradeoff. The benefit from the host of using a GC specific to the device… for languages that are not size-limited, not restricted by host, may choose to compile to wasm GC.

TL: wonder if we will get into a situation where the same language will compile to linear memory for WASI, but compile to GC to run on the web.

LW: With Interface Types, if WASI is expressed with Interface Types, then you should be able to use no linear memory at all, that's another design goal.

TL: related note, there was a lot of discussion in the comments of the requirements doc about how great it would be to just use linear memory and have languages bring their own GC. This came up from the OCaml and Erlang folks. If only they could collect cycles, while using their own linear memory GC. Francis, you got the impression that we shouldn’t look at this? I got the opposite impression. If we think we can solve that problem, then we should put all our resources into it. But no one has a tenable foothold on that problem, some resources put in, but none seem to end up with production quality. If someone has a burst of inspiration to make this possible, it will be good to follow up on that.

FM: Part of my reasoning was not technical. Some of the browser vendors basically expressed a hard line that we should focus on host GC first.

TL: is Keith on the call?

RT: They are concerned setting up the wrong system for wasm, where there are garbage collectors everywhere, so they don't have a good way to collect cycles.

TL: if we have a solution for the smooth collection of cycles with linear memory, they would be happy.

RT: The question is nobody knows how to solve that problem yet.

TT: even if you collect cycles, you will still ship heavy runtimes on the web.

LW: If we then say, there's a bias toward the web and Android, then as key stakeholders, then the criterion is the likelihood of bringing people to these key stakeholders, there are some languages that are based on large class libraries, that aren't going to bring a large number of people to the web. It seems like we will want to focus on these languages. That's why Java and Kotlin are interesting languages for this platform.

TT: we can look at languages that already compile to JS

FM: An alternative to popularity of languages is something that identifies adoption-ready communities, prioritizing adoption… what's most likely to spark adoption is something we could focus on.

BT: one thing i saw in the reqs doc, java and python came up on top on the TIOBE index. Both will require a significant runtime language, will need JITting and late binding. Need to think about that as a possible architecture. Now we have whole prog compilation, offline translation and lowering. Need to think about phrasing, expect runtime systems on Wasm, need to think about that when we think about requirements.

FM: I agree completely, and I also think that GC isn't the only thing that's stopping Java or Go adoption. But we can't solve all of the problems, are brief is to look at GC, not solve Java. Eventually we'll het to Java, but having GC is not enough. I agree that support for Jitting is important, several of us have been thinking about how to do that. I'm OK with focusing on adoption as a criteria. It makes it explicit what we're trying to do.

LW: I will push back a bit on the JIT aspect, hard to do a good JIT on a small amount of bytes. We don’t want them shipping their own JITs. For thinking about immediate adoption on Web, sub-100k download size. Whole program compilation and maximal AOT will be the winner in the short-term, to be competitive with JS in size.

BT: I'm thinking more broadly in terms of … yes, you don't want to have every language bring a JIT. So you have to think about what can make it usable. You want the engine to do the work. We need to be able to reuse the wasm execution tier. Part of this is cloudy, but part is more clear after some of the work I've done here.

RT: in the middle space, being able to ship programs components-by-components. People will find that useful, you can do whole program compilation, but can send components to get faster loading.

BT: We should maybe talk about the fidelity of language support. Plenty of solutions that compile Java to JS, they aren't completely language compliant, cut corners. So we should think about what is the end-goal. Are we going to support all of the JDK compliance tests. Maybe we should have a clause about fidelity.

FM: will push back against that, it’s up to the Java community to decide what the fidelity they are looking for

BT: Here's the thing, some of those things are really hard. They need specific mechanisms. Some are really hard to support. It may impose requirements on us to get to 100%.

LW: specifically for the references, we can’t expect to support 100% of these industrial strengths, there’s just too many. We have to assume we hit a subset of each particular language.

FM: having an adoption criteria will square this circle. We may not need all of the Java community, we just need some fraction of the community. The more esoteric feature… I would argue that, if Java needs a given feature, it’s up to a Java rep to come to us and argue the case. We are motivated to get as much adoption as possible, for any given feature, it’s up to the community of the language to argue their case.

TT: I don't think it's about languages, it's about users. There are users who are happy with compiling to JS, and the question is about how much effort to port.

AK: q for FM, what do you see as the future of this reqs doc. How will it change over time? Will it become a common thing at meetings, with PRS to amend requirements.

FM: Two roles, first is to get as clear up-front about what the problem we're trying to solve is. Someone who's coming in later on can use it to get up to speed. Also, I hope that it helps take the steam out of some of the discussions. It is a living document, and we have to be ready to change. Sometimes the change means that the problem we're solving is different. I don't foresee a ton of changes to the requirements document. But requirements do change, so when that happens we should reflect that in the document. It is something that shows to someone from the outside what problem we're solving.

RT: we’re not supporting any GC.. prioritize widely used features. That might more directly address what you’re trying to achieve.

### Closure
"
main/2022/CG-03-15.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 15th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: March 15th, 4pm-5pm UTC (March 15th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Update on [Extended Const Expressions](https://github.com/WebAssembly/extended-const) (Sam Clegg) [10 min]
        1. Poll to Phase 2 or Phase 3
    1. Phase 1 poll for a split-off WasmGC JS Customization proposal (Thomas Lively) [5 min]
    1. Discussion on [Feature Detection](https://github.com/WebAssembly/feature-detection/blob/main/proposals/feature-detection/Overview.md) (Thomas Lively) [45 min]
        1. [How should features be specified?](https://github.com/WebAssembly/feature-detection/issues/3)
        1. [What features should be specified?](https://github.com/WebAssembly/feature-detection/issues/4)
        1. [Should feature detection be decode-only?](https://github.com/WebAssembly/feature-detection/issues/2)
        1. Possible poll to phase 2
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
* Derek Schuff
* Yuri Iozelli 
* Bailey Hayes
* Frank Denis
* George Kulakowski
* Yury Delendik
* Jeff Charles
* Saul Cabrera
* Sam Clegg
* Conrad Watt
* Thomas Lively
* Francis McCabe
* Luke Wagner
* Jay Phelps
* Lars Hansen
* Paolo Severini
* Rick Battagline
* Alex Crichton
* Zhi An Ng
* Ryan Hunt
* Chris Fallin
* Jakob Kummerow
* Michał Kawalec
* Manos Koukoutos
* Andrew Brown
* Ben Titzer
* Adam Klein
* Mingqiu Sun
* Jacob Abraham
* Ioanna Dimitriou
* Emanuel Ziegler
* Dan Gohman
* Richard Winterton
* Asumu Takikawa
* Andreas Rossberg
* Jonnnie Birch
* Zalim Bashorov


### Update on [Extended Const Expressions](https://github.com/WebAssembly/extended-const) (Sam Clegg) [10 min]

SC presenting [slides](https://docs.google.com/presentation/d/1tjxc_pLa86YhjtR7NjWskHjC--C8JhyaEjkYpEQCtiI/edit#slide=id.gc6fa3c898_0_0)

CW: what’s the situation with the test suite right now? 

SC: It has some tests that I wrote. In V8, the implementation is just C code rather than using the VM’s existing codegen. I’m not sure if we want to try to exercise the same edge cases we currently test for regular instructions, since it’s basically a different implementation. 

So we could go straight to phase 3 since we have tests and implementations

DS: Have we tried 64 bit memories with this proposal?


SC: Not yet, no. First end-to-end test done yesterday. Different implementations have implemented this differently. For example WABT uses its normal interpreter.

AR: My only suggestion to add would be conversion for i32/i64. It could come up if you’re mixing 32-bit code, especially with address spaces. They can’t trap, right? It seems easy to add.

SC: Yeah, we can do that. Wouter suggested it too


POLL for phase 3:
SF: 9
F: 18
N: 2
A: 0
SA: 0



### Phase 1 poll for a split-off WasmGC JS Customization proposal (Thomas Lively) [5 min]


TL: The GC subgroup voted to defer a “rich” JS API, where “rich” means you can attach custom methods, accessors, prototypes, JS Stuff to GC objects. We were considering that but decided to defer that to a followup proposal. We have a phase 0 repo for that, called gc-js-customization. We just wanted to get an official vote to move it to phase 1. Entry requirements are that we agree that this is within scope and worth solving.

SC: That means that if you have a GC object and you try to get a property that’s not there, it traps?


TL: yeah either trap, or throw some kind of exception (type error?). SO we aren’t completely deferring any kind of JS API. we’ll have something and it will be well-specified. But the way you interact with the objects will be via imported/exported functions.

TL: the champion will be Asumu

TL: we can do a consensus poll, I haven’t heard any concerns on this.

Consensus poll: any objections to phase 1 for gc-js-customization?

No objections, poll passes.


### Discussion on [Feature Detection](https://github.com/WebAssembly/feature-detection/blob/main/proposals/feature-detection/Overview.md) (Thomas Lively) [45 min]

[slides](https://docs.google.com/presentation/d/1UlwhMEpmIubwBRoF31l9QMoUJsxkgcypygveiu5LV0U/edit?usp=sharing)

AR: can you clarify what you mean by saying SIMD users are “used to” having feature detection?

TL: the mechanism they’re used to queries the CPUID (e.g. cpuinfo) and tells whether features are present. So they query whether the CPU cupports instructions xyz. If so, go down this codepath that uses those instructions, otherwise fall back to one that doesn’t. In clang and gcc, there’s a compiler extension that you can use to make this easy where you define multiple versions of the same function, with an attribute that says which hardware features each version requires, and the compiler can generate code that switches between the versions depending on the features. So we hope to implement that extension using this proposal.

AR: did we ever explore the possibility of restricting conditional sections such that they are required to produce sections with the same type and size, which would fix this issue (unstable indices)

TL: I think it was raised as something to maybe look at, but ultimately would be more complexity on the conditional sections. Now you have some sort of type or size for the section itself.

AR: we currently have that, every section has size. There is a lot of discussion about complexity here, I believe that the current proposal down the road will be way more complicated.

TL: it’s a little bit a matter of taste. You said that the new proposal is ad-hoc. But I would say that adding side conditions on sections re: the size is rather ad-hoc. So I guess there’s different valid ways of looking at the complexity here.

FM: don't think having a constraint on the conditional sections would work, if you have to replace implementation of SIMD or something else, will have different number of functions there

AR: that was the argument at the time but the current proposal has even stricter restrictions. It would certainly subsume what we have in the current proposal.

BT: one argument for having indices match up, you can save work. if they are validated and don't reference conditionally defined things, they would still be valid.

AR: maybe we should postpone this discussion until after the presentation?

FM: is there a negated version of that? This rewrites to a block if feature is there. What about if feature is not there, for feature block.

TL: it becomes unreachable. For the opposite. Can't think of what's useful, you always check for features before using instructions, can't think of where you want to check for absence of features

BT: you could provide an alternative implementation when the feature is missing, feature_block, else.

TL: I see. So building the alternative block body into the same construct. That would be possible. I’m not sure it would be any simpler for code generators, but might be worth looking into.

JB: Is it possible that an engine could skip(?) validating code but then somehow still execute it?

TL: this is all resolved at decode time, before validation. So after decode you end up with only instructions and types that the engine can validate. So there are no changes to validation here. If you end up with an instruction that the engine doesnt understand after decode you still have a validation failure

FM: how does this interact with code annotations?

TL: that works via byte offsets into the code section, so because this is not instruction count, but not byte offsets, it is stable, no matter what the feature set ends up being.

FM: thought it was relative to function?

TL: yes, it is. All of these only appear in functions, so the byte count is still stable. So I think that should just work.

FM: even though this is resolved at decode time, the byte offsets persist after decoding?

TL: yes. E.g. if I attach an annotation to the middle of the feature block; if the features are supported they attach to whatever instruction it is. If the feature is not supported, then the feature block becomes a long encoding of unreachable, and the annotation just points to the middle of this long unreachable instruction. I don’t remember what we specified a code annotation to mean if it points to the middle of an instruction.

YI: for branch hinting, spec says that it's wrong to have annotation attached to something that is not a branch instruction, we are considering relaxing this to say to do nothing if not attached to a branch instruction.

CW: more generally we decided that invalid custom sections can’t result in errors.

YI: right but we did decide that the engine stops processing hints if it finds an invalid one. So we could change that.

CW: not observable either way, will still be safe if engine gives up on processing future hints or not

LW: even in longer term, if everyone implemented this, this feature can support instructions not being optimized for the hardware. Is that a use case that also matters?

TL: yeah i could definitely see that working. It would be a little tricky because you want to differentiate those use cases. If you have the same features and one producer is interpreting the presence as “validates and is fast” and the other is “validates but I don’t know if this is fast” then…

LW: scoping to SIMD makes sense, a lot of value in supporting these use cases. Seems like the need to do at decode type and unknown bytes, if you can support the feature and be unoptimized, it's a low effort.

TL: yeah this is getting back to your suggestsinos from conditional sections too. My concern there is that there’s already such limited bandwidth to update all th engines in the ecosystem. The motivation to support a performance-oriented proposal that won’t be fast. The effort even just to support and validate all the instructions, would that be there?

BT: in the middle of implementing SIMD in an engine that won't optimize it very well. If feature block has features.is_fast, easy for me to say not fast.

LW: can say that they are slow, and trap if you try running them

TL: I think that would work. It would certainly be useful to be able to detect whether they’d be optimized or not. What would you say the advantage is, having them validate, over having the instructions being skipped over by the decoder?

LW: generic fear that this becomes how non standard features get shipped

CW: that’s my fear too.

BT: in wizard, unlikely will emit Intel instructions to make this fast, polyfill, will be 100x slower. Having this feature will probably make applications a lot faster, they can use scalar code.

CW: you could still essentially lie, and say you don’t support SIMD at all, but if someone gives you a module that only has SIMD you could still run it.

BT: definitely a gray area

TL: we can have is_fast be a separate feature from is_supported, or you can lie about support. few options, worth discussion offline. A lot of utility to tell if SIMD will be fast. For non-standard instructions fear, if anyone want's to implement them, this will be a good way to get it in. Non-standard instructions are already possible, just have a new opcode prefix, no one has done that yet.

LW: it’s not been done because it’s not practical, you can’t ship that code anywhere

LH: you can't ship it very many places

TL: how much do we have modules being use portably across engines at all so far? One end-to-end provider with toolchain + engine can do whatever they want already but we haven’t seen that. But yeah it’s a valid fear and this would lower the bar to adding nonstandard stuff. Given that nobody had done this already, I do wonder if they would.

BT: recent thread about versions and version 1.0 and ecosystem, some discussion there. Talked about profiles, we need a larger discussion and plan overall. Conditional sections is part of that, at least some document of what we're going to do versioning wise.

CW: speaking of, if we do end up with conditional sections, is the mechanism kind of married to feature testing or are they totally separate things?

TL: won't want to commit up front being the same, I want to scope this to SIMD. Conditional sections will necessarily be much more general.

CW: my immediate concern is, it seems like you’ll end up needing conditional type sections too. There are too many situations where you want to swap out a function and need a type annotation, so it ends up just looking like conditional sections

TL: in producers, LLVM especially, this scoped down feature detection will be way easier to emit than conditional sections.

CW: will be reassured by binaryen people saying we are not so worried about type annotations

TL: for types, it should mostly just be in locals, in code section. The feature type thing, would work in the type section, no reason to prohibit it in type section, don't think it would need to. In practice most SIMD functions don't take SIMD types, take pointers to memory, and loop over that.

CW: if you wanted to take advantage of that you’d have to have no functions taking or producing SIMD

TL: you could use the feature type thing, even in the type section. It would have large code size overhead, so will want to minimize that.

AR: im not sure that’s enough. If you have a function and want to switch between SIMD and non, you might have one SIMD vs 3 i32 params, which isn’t something you can express this way.

TL: in pratice, you take a pointer to memory, this would never come up.

AR: famous last words, don't think I buy that. In combination with GC proposal, struct with SIMD type, array of i32. Current thing won't scale.

CW: even if naturally generated code doesn’t end up with  SIMD in arguments, you can imagine optimizations hosting the values directly into arguments.

AR: generally deeply concerned that this is considering too narrow use case, not scaling well, and at the same time very intrusive, not a simple feature.

TL: how do you mean intrusive? You mean that it only applies to decoding?

AR: for one, it makes decoding non deterministic, changes one fundamental property of the language. Fear it will be a rabbit hole, will add more conditionals to grammatical phrases of the language, very cross-cutting. Whereas something like conditional section creates a separate layer where all this is handled, without adding separate things to handle everywhere. More modular and scalable in that way.

DS: conditional sections for SIMD, what you want in SIMD is hve 90% of code be the same, only 10% different. A conditional code section will have SIMD and duplicated non-SIMD, even though most of it is the same.

AR: part of the proposal is that you can have multiple sections, only part of it duplicated. My abstract feeling is that this is trying to bring a form of meta programming to the language, a bit of a smell to mix meta programming with the programing layer.

FM: I have a slightly different followon: Ben said he’s currently implementing SIMD poorly. If he wants his engine to be competitive, he’ll have to implement it properly. That’s true for all engines and features: developers will be motivated to implement the whole language. For long term I don’t see an advantage for a developer to not implement the features.

BT: The issue is that some hardware just doesn’t have SIMD instructions, e.g. embedded systems. Best you can do there is scalar code, so it would be better to have the module use originally scalar code.

CW: I would be convinced by that if we believe that on average would be much slower. But if it can be made about the same then it wouldn’t be a problem.

TL: IME emulation is usually slower than a good scalar version by the application

BT: for f32x4 it's a toss up, i8x16 will be slower for engine to scalarize.

AR: engines have to be more strict, producers have more leeway, if compiling from C, more ways to optimize

BT: for i8x16, have to unpack and repack it every time, can't see beyond a single instruction, want static compiler to avoid unpack and repacking.

CW: given that we’re getting close to time and will discuss more i’d be interested to see a version of condition sections where we restrict based on the index spaces as we discussed.

TL: action items, work through conditional sections for that restriction, file issue on this proposal for detecting is_fast rather than just if it’s supported.

For folks with even vague concerns about the direction here, it would be really helpful to get those in the form of issues, even if it’s just “i don’t like this proposal, it’s too narrow” would be great to hear.

"
simd/2022/SIMD-11-04.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the 2022-11-04 video call of WebAssembly's SIMD Subgroup

- **Dates**: 2022-11-04
- **Times**:
    - 4pm-5pm UTC (9am-10am PDT)
- **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this [form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking
1. Adoption of the agenda
1. Proposals and discussions
    1. 
1. Closure

## Meeting notes

### Attendees

- Andrew Brown
- Anton Kirilov
- Benjamin Titzer
- Conrad Watt
- Dan Gohman
- Deepti Gandluri
- Johnnie Birch
- Luke Wagner
- Marat Dukhan
- Nabeel Al-Shamma
- Petr Penzin
- Richard Winterton
- Ryan Hunt
- Thomas Lively
- Yury Delendik
- Zhi An Ng

### Discussion on CG meeting feedback

DeeptiG: Hoping to discuss some of the feedback from the CG meeting. Deterministic lowering, what we can do about implementation-defined behavior, etc. Anything else we should address? 

(No)

DeeptiG: Deterministic and canonical lowerings mean different things. Assume that environments that need det lowerings should be supported. What environments are there?


DanG: I have a proposal!

PP: I also filed an issue talking about floating point versus the rest of the instructions. We can talk about that later.

DanG presenting slides https://sunfishcode.github.io/RelaxedMathMode.pdf

CW: By framing, you're talking about editorial arrangement of the spec?

DanG: Yes, mostly. I’ll also be proposing a new “mode.”

RW: encourage Intel AMD to add IEEE754, we are compliant with that with 2008 spec with this, not the 2019.

DanG: not IEEE754 compliant, SSE asymmetric min and max

PP: AVX512 instructions are compliant

RW: talked to some people, it doesn't add to accuracy, just a consistency, not more or less accurate

DG: Semantics in Wasm are the same in JS & Java, so there is incentive for Intel to add them

PP: not true, doesn't distinguish NaN bits

DG: distinguish which NaN you get, and -0.0

PP: different IEEE version, Wasm is the only spec that supports canonical NaN

RW: an action item to take on our end, have talked to architects about that, can look at that potentially in future arch, but that's years out

DG: take this offline

(back on slide titled ""fma"")

ZN: How would you turn on relaxed math mode?

DanG: will just be enabled, implementations can pick one mode or another, relaxed math mode or other things. cloud vendor will opt in to default or strict mode

CW: This is essentially ARs profiles idea, essentially editorially split out the, and separate them into different deterministic, and non-deterministic semantics

MD: for bfloat 16 dot product, the current deterministic is to extract even elements of vector, extend them to 32 bits, do fused multiply add with accumulation, then do the same for odd. This semantics can be implemented on all CPUs with FMA, and can be implemented on ARM with BF16 with bit exact way.

DG: Is that fast enough to be practical? 

MD: expect so, no worse than software emulation

DG: can change this to keep bf16, use what you suggested

CW: want to bring up a subtlety, let the hands go first

TL: Wanted to clarify my understanding of the modes, we have an engine that have the one that supports strict mode and not, what do they support? Different instructions? Different lowerings? 

DanG: exact same instructions in both, the one with the relaxed math mode has a superset of behaviors the one that doesn't

TL: same instruction sets, then engines with relaxed math mode, some of the non-det is allowed

CW: the mechanism in the spec is general, you can define 2 disjoint modes for different instructions, only define modes that make sense for the ecosystem. Having 1 mode be a superset of another is relatively safe.

DeeptiG: clarification about bf16, looking at canonical what hardware do, or looking for a deterministic lowering? We talk about canonical lowering that will converge on what hardware supports, for this instruction, it probably won't be that. What are we looking for here?

DanG: The goal is to have defined single deterministic semantic, then define extra semantic in relaxed math mode.

DeeptiG: want to point out, we don't expect this to converge with any support on hardware?

CW: In deterministic mode you want single rounding FMA? 

DanG: Z mentioned in chat ARM FP16 extension that adds single rounding 

MD: BF16 extension

DanG: some sort of convergence there

MD: some deeper details, practically 4 ways to implement bf dot product, our spec allows more options. Either we extract even number elements, extend to fp32, then FMA, then do the same for odd, this is ARM BF16 with 2 instructions. Another semantics is similar except subnormals are treated as 0. This is BFDOT in ARMv9.2 and also Intel AVX512 BF16 extension. There is an option in software without FMA, don't think any hardware implements this semantics. Last is ARMv8.6 CPUs do for BFDOT, dot product computed separately with non-standard round-to-odd, dot product accumulated with normal rounding mode.

DanG: will need background research on this, not sure which option will be best here

CW: Predicting that there will be no one lowering that hardware convergence, because most of the hardware don’t need to converge based on the use cases

MD: if we look at latest CPU, the semantics they support is extract even, extend FP32 flush denormals to 0, then do FMA, then same for odd elements.

CW: is this something we can software emulate?

MD: We can, but it would be slightly more expensive than the one that opts for software denormals

DanG: Set flags to flush denormals

MD: that's one option, flush denormals using software comparisons

DanG: This is a part of the proposal, and I’m not prepared to drive in, let's complete the proposal

CW: want to flag out that we should try to do the conceptually consistent thing if we are aiming for convergent FMA single rounding behavior. If it looks like there is a path for that.

PP: bf16 is different datatype, use case for this is different, affects different categories of software, IMO maybe we have to converge, or not, open to discussion. How do you see switching between relaxed and non-relaxed mode.

DanG: not user-configurable mode, engines just decide what it is

CW: It’s more about communication than anything else, engine can signal which mode it’s in, only very special platforms like cloud computing that would signify that they would run in the strict mode

PP: instead of a way to turn it on off

CW: probably no way to test this programmatically, is a way for the service provider to signal this

PP: user cannot tell if this is running in strict or relaxed mode

CW: has to be the granularity of where you are deploying Wasm, if deploying to Cloud, you expetthat strict mode, if on the Web, can't assume anything, must be relaxed.

DanG: this instructions not used by default in toolchain, need special compile flags

CW: This gets back to what I was saying about modes or profiles, it’s a powerful and very generous mechanism, we want to make sure that we’re not fragmenting the ecosystem with too many modes

PP: same instructions, relaxed mode v.s. strict mode, is it possible to accidentally provide the wrong module. Can we ensure the module cannot run in the wrong environment?

CW: I think it’d be a bad idea to have a bit in the module that introduces that. If you’re taking the responsibility about building this type of relaxed module, you’re doing that intentionally, you know you're able to signal which one you’re building, so that’s enough of a threshold to signal what kind of module you want

DeeptiG: if you take strict module and run on the web...

CW: if you take a module that is relaxed, then run on strict, is fine. If module is strict then run on relax, it might break.

BT: in the spec, there is a list of acceptable behavior for every instruction, this is an enumeration of the list we care about. Will there be divergent hardware instructions that change the semantics of these instructions?

MD: We don’t control hardware vendors, and don’t guarantee that no new lowerings will be added, but it’s not required for engines to implement new lowerings when new instructions are added to hardware

CW: at least with most relaxed instructions, including fma, little chance of hardware doing what we listed out. Hypothetically, for bf16, other arch can choose different rounding?

DanG: that's my understanding yes

BT: not comfortable about that, can't do anything about that, but uncomfortable about changing behaviors

MD: Wasm engines wouldn't be able to introduce new behavior, Wasm engines won't' use new hardware instructions

CW: hypothetically, imagine we spec a deterministic bf16, blesses a certain set of rounding modes. A new chip comes out with different rounding, we can't support it.

ZN: We can have a new proposal to add new instruction if the chip is popular enough.

DG: engines use a bunch of instructions, we spec semantics, not instructions. BF16 is a special case, it's so new that we don't know what's going to happen in that space. Other instructions have been around long enough.

CW: my thought as well, specifying BF16 has hazard above the level of everything else

PP: BF16 is improving in terms of hardware support, but not as common as other operations 

MD: not very happy with renaming relaxed madd to alternate fma. We don't want to create a perception that something is FMA when something is not guaranteed to be.

CW: We can table the naming of FMA, but we should table that discussion and handle that as the very last thing we do

DanG: happy to table it

BT: the idea of the union, it corresponds to listing out the potential behaviors and naming all of them. I don't understand how big that set is, and how much work there is.

CW: not so far off list non-det already, we need to enumerate all that's going to happen.

BT: I agree, how big is that set? 

MD: BT's idea is to explicitly provide deterministic variant of each list-non-det semantics. We would have 2 for relaxed madd, 2 for relaxed nmadd, 4 for relaxed swizzle, probably 2 for 2 wide int dot product, 4 for 4 wide int dot product

DanG: not sure if we need to dive into enumerations right now. Question to BT, what advantages?

BT: What advantage do we have for doing these? 

CW: Ben I don’t know if this is exactly what you wanted, if we had something along the lines of a profile, that would be exactly the kind of irresponsible kind of abstraction in terms of fragmentation.

PP: if you think about the union, there are 2 distinct groups in the proposal. One is floating point, where differences between archs is more fundamental. For example, emulating single rounding on dual rounding is expensive. Existing non-float operations we are trying to relax have Arm semantics, and the difference between Arm and x86 is much more philosophical (as in what is the encoding of invalid value), it is possible to imagine those two semantics coexist. I have a write up in https://github.com/WebAssembly/relaxed-simd/issues/104

MD: uncomfortable with changing Wasm NaN semantics

DanG: have a slide for that

CW: not at the core for Phase 4 on this proposal, if we can skip the discussion on Scalar NaNs somehow

DeeptiG: do we see this as a stopgap to having profiles, then build that in, then not have modes in the spec?

CW: we have to see it as the first profile

DeeptiG: like the direction, implies for engines pretty much what we have today. One comment on bf16 dot product, given that new hardware doesn't have new bf16 instruction supported, we don't expect to use the FMA lowering, probaby lower to wasm semantics, until new hardware that uses it. Only new hardware is M2 chips.

AK: it's supported ARMv9 SOCs, exynos (S22), graviton 3

BT: about the mode, it's binary right now, support relaxed mode or deterministic. no alignment between semantics of one thing you get and another. Will programs want all the Intel versions of this instruction, is that guaranteed?

CW: if we start with List non-det, we can strengthen it to something like that

BT: part of the reason Wasm succeeded, already standards for floating point, and twos complement everywhere, this is us running ahead of non-standardized things, out on a limb here that makes it difficult, until there are other standards developed, e.g. for bf16.

RW: BFloat is only available on AVX512 on server based systems, any client based hardware is very far out.

MD: AMD4 supports bf16 extensions

RW: yea not Intel, AMD supports because they support AVX512.

MD: We have desktop and laptop systems that support AVX512

CW: don't think the bar for including instructions should be some systems support that, especially what Deepti said about how V8 is going to compile it.

ZN: Maybe support bfloat16 in relaxed mode only

RW: not against BF16, just stating what is available on Intel

CW: If we’re expecting that this are exposed for 2-3 years, not what will be available in 2-3 years, makes me less comfortable about adding this instruction

DanG: relaxed SIMD already has 3 nondet for bf16, can imagine future generations will need different things. In the future, new hardware might not conform to whatever we spec.

DeeptiG: vote for general mode, and also bf16 dot. was there more?

DanG: only other slide is NaN bits, which we will table

MD: important to keep BF16, even with lowering that keeps deterministic behavior, we see close to 2x speedup in benchmarks, we see 3x speedup if we allow semantics that treats denormals as 0. It is a bit forward looking, at least performance benefit is clear.

CW: sounded to me like BF16 is lowered to Wasm SIMD instructions as a pass in V8, how are we getting that speedup? Can't we simply emit Wasm SIMD?

DeeptiG: when we would support it, we will lower to Wasm instructions yes. We don't implement it, not sure about the MD numbers.

MD: in native ISA but using different variants of lowering, emulating how Relaxed SIMD instructions will be lowered with different options

CW: don't expect BF16 in v8 will give you any performance wins.

MD: today, yes. In the future, V8 will start supporting optimized lowering. Some asymmetry here, if we don't include this, we are missing out on 2x or 3x performance in neural network for 5-10 years. If we include, and not useful, not very wasteful.

BT: not sure I agree with that. You can make the same argument for implementing union, you can emulate everything. Uncomfortable speccing instructions that don't exist widely in hardware.

MD: It exists widely in newer hardware, it hasn't propagated to the whole spectrum of hardware

ZN: Let’s focus on Dan’s proposal and punt the BFloat16 discussion to the github issue

PP: no strong opinions on BF16, regarding the mode, neutral, slightly for. Pragmatically, looking at how CG meeting, will have opposition there, a module will not know where it is running.

CW: modes or profiles is potentially the right way to square the circle. Should instill in our hearts, a great fear of using profiles to solve the problem. Might be the right solution here, think carefully before we introduce modes. In 5 years, we don't end up with 20 different modes.

RW: agree with that. Saying that we won't have BF16 in client software. As long as there is a path to minimize number of modes, can reduce number of modes if hardware supports it.

LW: like this proposal, this deterministic mode might seem niche, this is a mainstream thing, whole bunch of Wasm will run on many hardware. Might be deploying on platforms, then deploying on platforms. Deterministic instructions are not pessimal, it is optimistic, maybe it has to be emulated, if everyone implemented that it will be optimal.

PP: can be a problem....

CW: putting ourselves in a position that an implementation can only morally signal deterministic, if it is running on hardware that is fast, or okay with being slow and emulated.

PP: this would be default in a way, wouldn't that be?...

CW: default is relaxed, that's what web engines do

LW: for cloud platforms, it will be opposite, however they have newer hardware

CW: cloud can be more ...

MD: do we feel comfortable voting

CW: poll on an issue?

DG: BT has hand up

BT: agree with CW, modes should be used extremely sparingly, improvement here to have a mode, especially a deterministic mode, not pick 1 of 5. If we have guidance that you are expected to test in deterministic mode.

CW: separate poll

DG: only heard from Dan, if others have ideas, follow up. If we decide to move forward with this approach, we should 

CW: we start with this proposal to phase 4, then add mode later
"
threads/2024/THREADS-04-30.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 30, 2024 video call of WebAssembly's Threads Subgroup

- **Where**: zoom.us
- **When**: April 30, 2024, 4pm-5pm UTC (April 30, 2024, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/mUp4nmiVUTNQDKcD9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Overview of overview changes since last meeting
    1. Thread-bound data [#53](https://github.com/WebAssembly/shared-everything-threads/pull/53)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Luke Wagner
- Derek Schuff
- Conrad Watt
- Manos Koukoutos
- Andrew Brown
- Deepti Gandluri
- Jakob Kummerow
- Ilya Rezvov
- Zalim Bashorov
- Matthias Liedtke
- Nick Fitzgerald
- Emanuel Ziegler
- Adam Klein
- Shu-yu Guo
- Francis McCabe

### Discussions

#### Overview of overview changes since last meeting 

TL presenting overview of changes since last meeting

FM: one thing we’ve been discussing re: WebAssembly.Function, the current semantics mimics a singleton module. This is a nice property of WA.Function, one of the reasons we moved away from using it is that we wanted to preserve that. I would recommend the same here, so if we’re doing any marking, we should do it on the imports.

TL: Yes, thank you for that. We definitely want to come back and think of the JS API

CW: describes new pause instruction to optimize busy waits and minimize power consumption

SG: note that pause doesn’t yield to other threads; it keeps the current thread but hints the CPU to yield other parts of the execution pipeline (e.g. to other hyperthreads).

CW: It’s about yielding cache line resources etc. 

SG: yes, distinct from OS-level thread yield and also from blocking completely and giving up the CPU

CW: Explanation makes sense as an instruction at the CPU level

SG: this was originally a JS-side equivalent, recently renamed from microwait() to pause.

CW: Isn’t the JS one more clever? It has a built-in loop? 

SG: That's right. On the JS side the call overhead is high, so if you were writing as if you were writing assembly, the function call overhead would dominate. The JS API takes an iteration number hint that the implementation can use to implement exponential backoff. Maybe it can be used differently between baseline and optimized tiers.
I would imagine the wasm side is literally just one instruction

CW: The differences make sense, you can implement the JS behavior in the user space for Wasm by putting a loop around the pause instructions. Yeah if we have this in JS it makes even more sense to add it to wasm now too.

TL: yeah it’s one of those mutually-reinforcing things where we do the same thing on both sides

CW: Forgot to make a PR about this, but if you have a global variable that's a v128, it’s hard to define an atomic load/store values because the architectures don’t guarantee it. Brutal solution would just be to not load/store global v128s?


AB: this came up when trying to implement some of these instructions in decoding/validation in wasm-tools. I saw your comment about this, thinking it through again. Now i’m conflicted because I think there maybe a way to do lock-free atomics on these

NF (chat): Portably, though?

DS: I think Intel has 128-bit atomic instruction.  On arm, you might need to do a load-linked / store conditional, not sure how lock-free you consider that.

CW: it’s more complex to spec the fact that if you have racing stores, you might get a mix of the bytes.

AK: is there a use case for this? It seems a strange thing to do, to have v128 globals

DG: We just allow v128 globals for consistency with other types.

TL: I’ve never heard of anyone using a v128 global. I don’t know of use cases for a shared v128 global. For now I’m happy to disallow it.

CW: in principle this applies to any type larger than the native word size. The reason it shows up for v128 is that it has a defined size we can’t get around. In principle if you had funcref or externref larger than the native word size, you might be able to do that for unshared but have to use a different representation for shared because of that. So this could affect some implementations.

FM: both bag of stacks and typed continuations are expected to use a fat value to represent the suspended computation.

CW: my impression was that there was a separate boxed strategy to use native word-size values, they may have to use that for shared

FM: that would cause a lot of overhead and GC churn to collect. Why spec this at all?

CW: then you might also have to consider adding lock-like constructs and penalize the non-shared writes as well. If you abstractly spec that writing a continuation to a global and reading it on another thread, then you have to ensure that you avoid this tearing when you implement it.

FM: Why is this in the spec and not rather just an implementation detail.

CW: this surfaces in the spec with v128 because it has a defined size. With other types it doesn’t really show up in the spec level. I just wanted to raise it as a possible implementation issue

FM: IMO I would not call out v128 specially in this case. Say any type can be in a global. Then implementations would have to lock their v128.

CW: the question would be, would anyone actually want a packed representation, or would they want a boxed representation

FM: my guess is that if you have v128 you wouldn’t want to box it

TL: we won’t mention in the spec what instruction sequence people will use but we saw what we’ll allow to be global/shared. My gut feeling is to just say that the spec allows everything and implementations do what they need to do to make it work, but it’s early and we don’t have implementation feedback yet. We can’t reason about every case of every type in all engines here, we can be uniform. If it’s more trouble than it’s worth we can find out.

CW: I'm a little concerned about things working really well on one architecture but having penalties on others.

DG: There's a way to do this without a loop on Aarch64. v128 globals shouldn't be performance-sensitive anyway. So going forward there should be good support, so I don't think there's a large portability concern. +1 for not having a special exclusion.

SG: about comparison: what other systems do is they say something about requiring atomicity, but expose a primitive like isLockFree that means you can find out whether the implementation is lock free. 
Technically it means “can you make forward progress in a bounded number of steps,” but in practice means ""is this fast.""

JS exposes this, C++ exposes this on std::atomic too. I was looking in the wasm spec, it looks like wasm doesn’t expose this?

TL: yes, it would expose nondeterminism, which we’ve tried to avoid. About globals, people use them because they are the only reasonable things to use, and not otherwise. So I'm not worried about people being incentivized to use globals because it’s not lock free  and then getting stuff. They generally don’t use them if they don’t have to, so i’m not worried about performance problems with globals.

AB: what i meant early on was, let’s wait and see what it looks like when we implement, leaving all types of globals possible ensures that implementers will have to grapple with this and come back and re-evaluate whether we should eliminate some types.

CW: Yes, I think that makes sense. And it sounds like people are ok with keeping the specification of v128 globals to be tear-free.

AK: because I said I was fine disallowing them: I'm also fine going down this path. Implementations may leave it out on the first round if they don’t want to deal with it, but given that we don’t really expect people to depend heavily on the performance of v128 globals

TL: CW, can you add a note to the overview?

CW: yes, will do

TL continues with recent commits, GC tradeoffs.

CW: aside from the decision about strong vs weak semantics. There’s also Luke/Ryan’s idea about <?>

TL: yeah currently the overview doesn’t mention that but it should. Overview outlines all the thinking about the proposal in addition to saying here’s what's currently actually being prototyped so we can interoperate. So it’s good to draw the distinction between those 2. In V8 we currently plan to prototype thread-local globals and see how fast we can make them. I wouldn’t want to replace the mention of tha tin the overview but mentioning multiple possibilities makes sense.

CW: is this one of those plans on deferring initialization to boundary crossing or something like that?

TL: not sure yet but probably. We haven’t started on the thread-local global part yet because we’re looking at prerequisites like shared structs.

CW: yeah and we’ll need that no matter which feature surface we have.


#### Thread-bound data [#53](https://github.com/WebAssembly/shared-everything-threads/pull/53)

TL: This was a concern raised by Dart who looked at the proposal and said they wanted shared structs to hold externrefs, to DOM objects, etc. that’s a shared->unshared edge. We haven’t figured out whether we’ll have those at all but this is an idea for how they might work. Sort of a smart pointer; in JS you can create a wrapper around an y JS object, and the wrapper can convert to a shared externref and pass it around, put it in a shared struct, etc then when you pass it to JS, if JS tries to get() the wrapped object, it will throw if it’s not on the the thread the wrapper was created on. So even though the wrapper can go to different threads, the wrapped object can’t. The dynamic check lets you sidestep the normal static restrictions.

AB (chat): bikeshed: WorkerBoundData?

CW: seems sensible, it seems the same if we have the strong or weak semantics. I imagine in most use cases the wrapped object will stay on the thread. 

TL: yeah could be a case where the compilation scheme means that everything has to be a shared struct, but most of them aren't actually shared.

CW: and this isn’t  a solution for calling JS functions, just for holding JS objects

TL: but it’s very similar to thread-local function idea. But yeah currently a separate utility.

CW: yeah it seems we need both. In the linked issue, Shu sketched what an analogous feature would look like it JS. will there be confusion if we add a nerfed version of it to wasm but then get something better in JS later?

TL: i.e. what happens if we get thread-bound fields of shared structs in JS?

SYG: I think there's a case to be made that if Wasm gets this first via a programmatic API, then there's less need for the JS thing. There's two parts to the JS thing: syntax support, which isn't very important, then the explicit getters if it's an explicit smart pointer rather than a special property type.
But it’s not critical to the expressivity. My guess would be that this will mostly be used by frameworks and not by end users, it’s hard to think about and incurs cost, etc. there will have to be some education that says this isn’t something  you should use just because you got an error about shared->unshared. So given the audience the ergonomic difference doesn’t seem like a huge deal. It's Fine for wasm to get this first, and if it does, JS might not even need a parallel API unless there’s demand for implementations without wasm.


CW: I’d expect the hardest part is the web implementation because it’s effectively the ephemeron story, when you wrap this object it’s creating an ephemeron on the side

SYG: That depends on the strong or weak semantics, I think. 

CW: I’m glad you think the weak semantics is possible. Thomas says the first experiment is the strong semantics, which is the full ephemeron story?

TL: I think we think that the strong semantics is the only reasonable one.

SYG: yeah i think it’s possible but not desirable.

LW: has the shared->unshared issue been brought to TC39 with the full gory details?

SYG: Yes and no. I have presented the gory details, but it did not inspire the kind of engine deep dive I had hoped. The audience at the time was not engine hackers. People believe the shared-to-unshared restriction is right.
And the ability to use shared references as keys in weakmaps is important to continue to be possible. I think the symmetry runs deep in the language, and to carve out a subset of objects that can’t be weakmap keys is fishy and would need a lot of convincing. So from the invariant that any object can be a weakmap key a lot of the semantics come out.

CW: If engine people are saying that, that sounds like they're signing up to do the work.

SG: that’s my position but TC39 has fewer engine people than this group.
I would love to get more engine people to look at it more. Ian from SpiderMonkey has taken a look, and I know SM has concerns because of how their collector works.

LW: JSC also had a special fixpoint iteration thing that’s not just a GC. so it would be interesting to see how they think about this

SYG: on the V8 side, I think they believe that the strong semantics is what we want in the long term.
In the short term our architecture isn't set up for strong semantics either.
The way the implementation works is that  the shared space isn’t separate from all other heaps, it’s a part of the main thread heap, a subspace. 
You collect the shared space when you do a collection on the main thread. If you have cycles, the hunch is that a lot of the cycles involve DOM so they will be on the main thread, so then the shared space GC will be able to collect the cycles.

TL: so if you have a cycle that’s not involving the main thread, it won’t get collected?

SYG:  in the short term, without a global marking thing that can mark every world and see all the edges between them, yes. I”ve prototyped a global marking phase without a global sweep/compaction. There are tradeoffs, and the v8 team isn’t convinced we want something like that but it’s certainly possible.

AB: where we went with that topic was talking about what the browser vendors think and that’s why we didn’t merge it. I wanted to get some feedback or acknowledgement that at least we understand it, from e.g. Firefox and JSC. Has anyone heard anything from them?

CW: my feeling was that one reason why Ryan was going so hard about the context local alternative was that he was concerned about the full ephemeron story. So I think there’s still concern there.

AK: On the JSC side, I talked to Justin Michaud about it, but he didn't have bandwidth and has since left apple.

AB: so should we not merge the PR?

TL: it’s still that the overview is for showing what the current plan of record is, plus what else are we thinking about. So in the first category I think it’s important to to add it since this is what we are currently prototyping. Plus it’s the first request we’ve gotten from real users, the Dart folks said they wanted this. But yeah we want to respect what we’ve heard to far about the concerns. So we should make it clear that this isn’t really settled and a done deal but we should get it in the overview.

LW: once you get the prerequisites  in, would it be possible to emulate it with a finalization registry?

TL: yeah it might be possible, but distasteful

CW: Would need to have the finalization registry support in place, otherwise everything would just leak.

TL: I'll go back to the PR and make sure it has enough language making the current state clear.

AB: I did ping Ryan to try to get some feedback in the PR, that would be helpful.

TL: good discussion even though it wasn’t all on the agenda, seems worth meeting somewhat regularly and we find stuff. But having said that, please liberally add things to the agenda!
"
wasi/2023/WASI-11-02.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: November 2 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: November 2, 16:00-17:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1.  Poll for reframing WASI to stand for ""WebAssembly Standard Interfaces"" ([WASI/#563](https://github.com/WebAssembly/WASI/issues/563)) (Luke Wagner)
    1. Wasmtime implementation status update (Pat Hickey, 20 mins)
    1. Jco implementation status update (Guy Bedford, 20 mins)
    1. Propose wasi-backtrace (Andrew Brown, 10 mins)
    2. _Submit a PR to add your announcement here_

## Notes
### Attendees

- Pat Hickey
- Bailey Hayes
- Ben Green
- Jeff Charles
- Piotr Sikora
- Guy Bedford
- Luke Wagner
- Andrew Brown
- Yong He
- David Peipgrass
- Hung-ying Tai
- Syrus Akbary
- Jorge Prendes
- Joel Dice
- Colin Murphy
- Johnny Birch
- Jiaxiao Zhou
- Chris Woods
- Thomas Trenner
- Zalim Bashorov
- Johnnie Birch


### Poll for reframing WASI to stand for ""WebAssembly Standard Interfaces"" (WASI/#563) (Luke Wagner)

**Luke Wagner**: Last week we had an agenda to discuss and give the rationale for it. No one disagreed and no one has disagreed on the issue. Would someone like the rationale?

**Syrus Akbary**: I would like the rationale

**Luke Wagner**: This is an Oscar Spencer idea. This could be committed by other Wasm that can then be composed together to run on another host. We are not talking about a single monolithic set of interfaces that a host must implement all of them, instead a modular set. There is not one singular instead this is a transition to plural interfaces.

**Luke Wagner**: Any other discussion before we vote?

**Syrus Akbary**: I have concerns. One of those is because we are centralizing on what it means on an interface. Who this decides on the right one. Concern is on decentralization of what is official and what is not official. 

**Luke Wagner**: Is your concern specific to the naming concern?

**Syrus Akbary**: Yes, we’re moving from very similar to the POSIX. Centralizing what it looks like with what not general APIs look like. Central entity that defines what DBs, events, etc look like.

**Luke Wagner** That makes sense to have as a discussion in each individual proposal, the content of that particular proposal. But this is a standards group so we are establishing standards. The only shift we are proposing here is whether the interfaces we are proposing are exclusively implemented by the system. Otherwise there could be meta-discussion about the proposals and the scope, but the name change isn’t the place to sort that out.

**Syrus Akbary**: OK, we can discuss the other these. I do not want to hold the vote so if no one has any other discussion then I am ok with moving forward with the vote.

**Pat Hickey**: OK going to hold for 30 seconds to give time for any other concerns.

**Pat Hickey**: We hold these with unanimous consent. Speak up or comment in the zoom chat to object to the name change proposal.

**Syrus Akbary**: Concerned about centralizing certain ABIs. 

**Pat Hickey**: OK then the vote has not passed.

**Luke Wagner** In the Wasm CG, most votes are in the strongly in favor with strongly in favor. This is not a unanimously consent. 

**Syrus Akbary**: Would appreciate the chance to discuss a little bit more.

**Luke Wagner**: Ok we can delay it two weeks

### Wasmtime implementation status update (Pat Hickey, 20 mins)

**Pat Hickey**: I don’t have slides. The implementation of wasmtime for preview 2 is going really well we think. What we have completed so far is a wasi-cli command world. The basic I/O, sockets, filesystem, CLI specific things, stdio, and a couple other things. That has been implemented for a little while now with additional work in particular landing for sockets. 

The second world we are targeting is the wasi-http proxy world. In wasmtime 14 which is out now is the first time we have shipped an implementation of that with the new wasmtime CLI with `wasmtime serve` that implements as an http server using a wasi-http proxy component.. 

We are working on contributing to the wasi-http spec for how to represent errors. That is what we believe to be one of the last pieces of the puzzle to figure out. We are taking care of things like getters and setters for requests and responses, and how to handle and describe those errors. The PR that is up now includes this description.

That is the implementation status. Our goal for wasmtime 15 is to stop changing the WIT specs. As we approach preview 2, we are aiming to be stable. We will do this with a release candidate of all of the WASI preview 2 proposals. This includes WASI I/O, random, clocks, filesystem, and sockets. 

In short we will create a version with 0.2.0-rc-<date>. We have been working to stay in sync and so in wasmtime 15 we will do everything we can do to be stable. This will allow for interop with the other implementations that are in progress. 

The other goal there is that anyone making changes, then they can make their own services stable and keep their components running. The goal is to be able to turn this release candidate into Preview 2 with a vote if it remains stable.

Any questions, concerns, or comments?

**Colin**: We’ll lockdown wasi-clocks? Will this be a graduated approach?

**Pat Hickey**: We will be locking in the WebAssembly org wasi repos. This is separate from locking down the cap-std project. We have always been on an eventual consistency between wasmtime and upstream wasi specs. The implementation can change.

**Colin Murphy**: To make changes to wasi-clocks, it required changes to cap-std. I’m imagining this requires a waterfall of releases from WebAssembly org into cap-std. There are WIT interfaces that had to be updated to cross between the three repos.

**Pat Hickey**: In WebAssembly org, we think we are very close to settling those WIT specs. We have a project board that keeps this project tracking board that we use to keep track of various Preview 2 things between individual contributors. wasi-sockets tweaks and wasi-http implementations needed to be reflected up to WebAssembly org. 

Whatever changes we have to do between wasmtime or cap-std we will do to sync with the WebAssembly org.

Are there any other comments before we move on to the next presentation?

###Jco implementation status update (Guy Bedford, 20 mins)

**Guy Bedford**: JCO implementation of WASI. Update on where we are currently and how that implementation is working. For those of you who don’t know, JCO is a JavaScript toolchain for Wasm components with npm install -g jco

**Guy Bedford**: What we have been adding is full WASI support for these components.

**Guy Bedford**: Who is working on it? Myself, I have been at Fastly for a year and I have a background as a Node.js Collaborator and I am a TC-39 delegate. As well as help from Microsoft engineers Yoshua Wuyts, and Wassim Chegam, who is also a Node.js Collaborator.

**Guy Bedford**: WASI on Node.js. Our hope is that the experience we get when implementing WASI with jco is that we can have WASI work well in the Node.js project. I am also a maintainer of the Node.js project.

**Guy Bedford**: JCO recently added support for running command line components with the CLI world and now we are working on adding a serve command similar to wasmtime. This will let us demonstrate the wasi-http-proxy world.

**Guy Bedford**: Our implementation goals will let us get full support for all component model features. Now the focus is on full WASI conformance for both the serverside in Node.js and on the browser side. We are pulling in the wasm test suite and making sure we can pass all of those tests.

**Guy Bedford**: Experimental support right now while figuring out the architecture. Partial implementations on I/O. HTTP supports basic request/response. HTTP on the web is not yet supported. Sockets is not yet supported on server-side but should have this updated soon. Clocks shouldn’t be too tricky to finish up. Filesystem has partial support and internally JCO uses it’s own filesystem implementation.

**Guy Bedford**: The current implementation is experimental but come to good grips with the architecture at this point. Expecting to reach full support for WASI APIs on Node.js /JS server runtimes by EOY. Delay into Jan/Feb may be possible.

**Syrus Akbary**: Is JCO for supporting the core node libraries?

**Guy Bedford**: When you say using the Node.js API do you mean building on top of the Node libraries?

**Syrus Akbary**:  Not exactly, I meant being able to run Node.js Applications in JCO

**Guy Bedford**: That’s not exactly what JCO is doing. As a general toolchain project is that it is a little bit like a swiss army knife. When running a component in Node.js, we are supporting the WASI component APIs in Node.js. We want to maintain full correctness of the Node.js APIs with what we are implementing. There is a path for lowering the values to the platform via the C APIs for performance but for now the goal is for correctness first.

**Guy Bedford**: Supporting in Node.js and supporting in a browser have two implementations. In the immediate term, we are focusing entirely on ensuring compliant server-side implementation. The browser implementations are important, but to avoid diverting effort, we’re focusing on the Node.js Perview 2 support until after the Preview 2 release.

**Luke Wagner**: Who will use this in production? Likely node.js, bun, and deno that will likely use this meaningfully first. The current language says “browser fetch API”, and it would have been better to have the language say two implementations as we say in other proposals. Based on this feedback and implementation experience, it would make sense to tweak that criteria to two implementations.

**Pat**: We were hoping to vote to launch Preview 2 by the end of the year. If we remove this particular criteria, then we will have met that with working in the Node.js implementation. We think that doing fetch is really good and useful, but by deferring for right now, this makes sense for meeting our timeline.

**Pat**: Luke will make a PR to wasi-http with the language change. Since that language has already been voted on as part of making wasi-http phase 2, we will vote to change it. If folks want to discuss that in this meeting now, feedback is welcome now as well as outside of this meeting, comment on the wasi-http PR or talk to Luke or I via email, zulip, or schedule a call.

**Colin Murphy**: I have a question for Guy if we have time at the end.

**Pat**: Does anyone have feedback specifically on this criteria change? Luke is going to create a PR for this change. Thank you Guy and Luke.

### Propose wasi-backtrace (Andrew Brown, 10 mins)

**Andrew Brown**: wasi-backtrace. The reason for proposing this now is to gather feedback is to learn if we should target this in WASI. The reason I started working into wasi-backtraces as an option was triggered from conversations with Nick Fitzgerald. I was debugging a deadlock and because we don’t have full debugging support yet in WebAssembly engines. If I can insert a backtrace call, then I can get the backtrace I needed. Nick suggested we should make this a WASI API. I started asking around who is interested in this idea. Java devs thinks this would be helpful for them to print exception stacktraces in Java.

**Joel Dice**: I am very interested in this but I’m not sure when I’ll be in a place to work on this now.

**Andrew Brown**: This looks like a function with a capture-backtrace that prints a list of frames. This could give us easier to read stacktrace. Nick pointed out that this could be used also to help with coredump stacktraces. 

**Colin Murphy**: Is this compatible with what Chrome did?

**Andrew Brown**: Not sure?

**Piotr**: Why do we need this in Wasm applications when this is something that Wasm engines add?

**Andrew Brown**: If I trap, then I take down all of the threads. I need something to capture backtraces as it goes along without trapping. Ideally if we had old client/server debugging, this might have also helped answer this problem.

**Andrew Brown**: Due to how wasmtime implements it’s APIs. The backtrace is only accessible on the store, and that’s only on a caller. You can’t touch the caller thus the store. This is one of the cases where we need to touch the host properties in order to get to the backtrace. Lifting and lowering this frame structure would be complex and fragile. Hoping we can have a better way of doing that and just flagging this as an issue. Requesting this as a chance for feedback. I want to know if people think we shouldn’t do this. If folks are interested in this, I want to know that too. I want some feedback on this idea. 

**Luke Wagner**: Is the direction towards programming and diagnostic or do you imagine that this could be a critical part of the runtime via a language feature.

**Andrew Brown**: Motivated by my own needs here. I think Joel may be able to add his needs.

**Joel Dice**: Yes it would be helpful for exceptions in Java. Manually maintaining frame metadata is complex and having something built into the runtime like a stacktrace capability would be really nice. 

**Luke Wagner**: I am asking because over the years there has been discussion of walking the stack proposals. It could be a core wasm proposal and if it is a part of the core part of a wasm proposal. 

**Andrew Brown**: Someone did mention this but I thought maybe not today.

**Luke Wagner**: We want to make these locals opt-in. There is a lot of serious low-level compilery constraints that have to be addressed by this.

**Andrew Brown**: One of the benefits of this is a way to gauge the need for something like this in WASI then motivates pushing that stack walking proposal in core wasm.

**Colin Murphy**: I think this is great especially if we’re going to have multiple languages implement this. 

**Zalim Bashorov**: Yeah! o/ Let's have it!

**Syrus Akbary**: I agree that this should sit in the Wasm Core, it would be useful for Wasm runtimes in general

**Syrus Akbary**: I disagree placing it on WASI, but would agree placing it on the Wasm Core

**Kyle Brown**: I'm somewhat curious if the implementation complexity in Wasmtime indicates that this isn't the right place for it, but I am personally neutral

**coshvji cujmlqef**: what about 64 bit wasi? they forced address to be 32 bit

**Andrew Brown**: You're talking about this PR, right? ttps://github.com/WebAssembly/wasi-libc/pull/444 Let’s push this to two weeks from now. Bring the wasi-sdk and libc and we can have a discussion on why this needs to be a WASI thing and not a library thing. 

**Colin Murphy**: Question for Guy. Is this really so that you can fit into other kinds of frameworks? Is that the number one argument for WebAssembly for Node.js? How do you try to convince people to use it for node applications.

**Guy Bedford**: There is no really convincing at the end of the day. Node.js already supports wasi preview 1 and we’d like to support preview 2. To have it include this js toolchain technology is helpful so that js devs have access to components. Treating Node.js as an embedding target is valuable.

**Colin Murphy**: So JCO is really an enablement tool for users who want to embed their code in existing Node.js apps and infrastructure. If you want to run CLI or reactor style components then you can have it embedded in js to be called respectively.

**Luke Wagner**: You can have this run on existing Node.js infrastructures. 

**Colin Murphy**: The question is if JCO brings something new for Node.

**Joel Dice**: running sandboxed components written in any language from within a JS app (browser or Node) has appeal for a lot of people

**coshvji cujmlqef**: there is a project which is wasm2lua. world of Warcraft runs lua as its addons.

**Colin Murphy**: Sounds like it is all of the key why Wasm arguments.

—------

Straw vote in chat results: 1 SF, 5 F, 2 N, Syrus prefers it be in core Wasm instead of WASI.
"
gc/2020/GC-10-06.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 6th video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: October 6th, 4pm-5pm UTC (October 6th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: [Superfluous Casts](https://github.com/WebAssembly/gc/issues/120) (Ross Tate) [30 min]
    1. Discussion: Shared and Separate GC Heaps (Francis McCabe) [30 min]
1. Closure

## Meeting Notes

### Introduction of attendees

Thomas Lively
Ryan Hunt
Daniel Wirtz
Luke Wagner
Zalim Bashorov
Jakob Kummerow
Derek Schuff
Ross Tate
Manos Koukoutos
Wouter van Oortmerssen
Tim Steenvoorden
Rick Battagline
Conrad Watt
Benjamin Titzer
Keith Miller
Slava Kuzmich
Sabine
Lars Hansen
Yulia Startsev
Emanuel Ziegler
Adam Klein
Andreas Rossberg
Daniel Ehrenberg
Francis McCabe

### Discussion: [Superfluous Casts](https://github.com/WebAssembly/gc/issues/120) (Ross Tate) [30 min]

Slides: [(pdf)](presentations/2020-10-06-tate-superfluous-casts.pdf) [(pptx)](presentations/2020-10-06-tate-superfluous-casts.pptx)

RT: <Presentation> Goal is to get the group’s ideas on superfluous casts: casts that will never fail but that the generator cannot communicate because the type system is not expressive enough.

CW: question: Is the reason that MVP can’t guarantee safety that the source language has no variance on it’s array types?

RT: covariance makes it harder, but still a problem anyway, e.g. kotlin array. For Kotlin, let’s say they are invariant, only covariants if backend needs it. Kotlin array still and object, need some way to cast to kotlin array, on some backends they are reified. Need Foo array, get arguments and check it is a Foo array. None of the MVP can express that invariants. Even invariant arrays are not expressible, covariant ones are even harder to express.

CW: The covariant examples are already compelling, was just trying to understand more.

RT: at anypoint in Wasm type system, if it cannot reason enough about surface type, surface has to fallback to cast mechanism, then same problem with the casting mechanism to express that

CW: In abstract, there could be lots of reasons for that. But this seems particularly bad for langs with invariant arrays.

AR: can you explain the invariant problem again?

RT: Are you thinking about polymorphic or monomorphic system?

AR: monomorphic is fine.

RT: with a purely monomorphic system you can’t express many languages, then you need some way to deal with polymorphic system, to reason across arrays, arrays of T. If just monomphophic then just RTT for each type. Don’t think that will work for polymorphic setting.

CW: Fine to concentrate on source languages with covariant arrays. It seems that simple monomorphic array languages would map down ok.

??: generic library processing arrays, same problem

RT: Depends on whether it’s generic and reified or generic and not reified. The point is that there are systems where this is all possible to express, i.e. that can maintain these invariants. But not in our MVP.

DE: Is it a problem to have monomophic type system in Wasm, forcing you to insert casts when you have polymorphic types?

RT: if you take a monomorphic system… you have to prove polymorphic code respects monomorphic. Difficulty with invariance is that if you have one spot that breaks that, it’s broken everywhere. Sometimes you can restore that with a cast mechanism.

FM: If you focus on Java, you can’t have a reified implementation due to other things going on in the language.

RT: java arrays are reified, known pain point

CW: this is the way they escape the unsound, they carry runtime type of array.

RT: It’s not just escape covariance. If I have an array of objects and someone says it’s an array of Strings, I have to be able to check that. Need reification if you want the property that you can only put Strings into a String array.

FM: was thinking about specialization not reification.

RT: yea, related but different

FM: think you’re saying, even if you reify, there is an additional cost because of the MVP. java has its own cost, there is an additional cost.

RT: Yes, the benchmark show’s the cost due to the MVP. This happens with many generic data structures, not just arrays. Do people care about these overheads? Do we

TL: I would like to eliminate overheads, the meat in that discussion is, what is it going to take to make that happen.

CW: from my POV, it’s switch to nominal type system with bounded quantification.

RT: that’s how i know to get rid of it, another way is to find a way to extend current mvp, but I don’t know how to do that. Another question is do we want to get rid of it. Do we want it and what tradeoffs are we willing to consider.

FM: no one likes paying taxes

CW: 12% overhead on real code is extremely optimistic for java compiled to Wasm

FM: what do you mean optimistic?


CW: think it will be worse, especiall MVP

RT: purely cast, there will be other overhead

TL: any early estimates on what the overall overhead is attributable to superfluous cast? We have a more nuanced understanding once we have more experimental results from early partners.

FM: have to run the experiment to find out.

RT: can try to see if we can get someone to do these experiments. Have to build full MVP, then need generator to mark which casts are not necessary, need engine to emit those casts when running in a trusted setting

CW: you can do something dumber, delete all cast, put as switch in engine to not typecheck and generate code blindly. It wouldn’t be safe, only offline benchmark.

RT: still need type information for direct compilation, we need some mechanism to ignore casts, trust that they are true casts. Other issues are, when you break invariance in one spot, everywhere is broken. Say ML, other aspects of ML that mvp and post mvp can’t typecheck, same for Haskell, you have to reify the entire system, all polymorphism just to get invariants working. Generating a different implementation of these languages because you can’t typecheck them.

TL: question for JK, is this sort of tweak a thing and do a performance measurement something you’ll be interested in doing? Once we have full end-to-end prototype.

RT: can’t hear you, mic turn off and on

JK (chat): I can certainly try to get numbers like this. Shouldn't be too hard to hack the prototype to just not emit any machine code for casts

TL: on a good path to do an experiment, agree that will be useful

RT: about half an hour, FM mic working?

CW: quick question for AR, any idea for how MVP will accept these casts

AR: accepted overhead either way

CW: moving forward from mvp

AR: i can envision various ways to incorporate more advance type system features, honestly don’t understand how nominal type system will work here, might fix some problems but cause others. Don’t have a good answer

CW: for nominal, all the arrays getting a type X extend real type, with bounded quant you can push it everywhere.

RT: multiple papers showing how to do that, known how to do it.

AR: one where arrays are kind of primitive

RT: primitive in the sense of a bunch of values

AR: where arrays are structural, or arrays of generic type, whatever you cal lit. Unless we have generics, i don’t see how we can model arrays in nominal way.

CW: then we need generics

AR: then we need a whole new thing before we can get there

CW: that’s exactly the hypothetical bounded quantification extension

TL: continue diving into this on github

### Discussion: Shared and Separate GC Heaps (Francis McCabe) [30 min]

[Slides](https://docs.google.com/presentation/d/13MaCHhGH6pP7jE10vCYJ2h7KR4qvDqfkAO0UdlfVEJg/edit?usp=sharing)

FM: <presentation on GC & threads> Explains requirement in requirements doc for having multiple GC memories.

CW: By not allowing JS to be threaded, do you mean concurrent access to JS values (as opposed to e.g. SharedArrayBuffer).

FM: we’re talking about giving access to JS objects here, if we are not careful about supporting multiple threads, it will allow JS to be multithreaded

TL: seems like we don’t need to design this for MVP in particular, whatever we do for MVP is forward compatible

FM: worth thinking about how one might solve the problem, without actually nailing everything down. Have roadmap so we don’t box ourselves in unnecessarily

CW: at least some people have though, we can mark table and refs as shared. Semantically what does that mean? But that’s how we support threads in java.

LW: To add to that, any shared thing can only point to other shared things. Sharedness has to be known at creation time. Single-threaded things can point to shared things, though. If you had a way to start another thread that had unshared things, that would imply that there is a new disjoint heap.

AR: in addition you want shared attribute on functions, this is all in our weak memory paper actually, in the appendix

WO: full multithreaded java program wants to communicate with JS, has to do it via copy or serialization

LW: I think there could be a notion of a “home thread” that would be able to call out to <I didn’t understand this>

CW: the idea would be to have two different web workers in JS, each has a ref to a shared table, instantiate Wasm modules to that table, sharing it, accessing it concurrently.

FM: Not talking about tables here, talking about memory with direct pointers.

LW: that’s an extension of tables

RT: java object that points to js object

CW: Transitivity property of sharedness works with JS objects always being unshared.

LW: if you had that restriction, then you have a non-shared table with all JS objects, stick an index to a shared java index. A home thread notion. Force upon us by the constraint FM brought up

TT: is it a constraint? Simpler model where we don’t allow non-shared heap, scavengers and minor gcs will be stop the world. Then you can allow several threads sharing objects, as long as you don’t access JS object except from main thread. If you try to access from off-thread, either stop the world or fails.

LW: shared things don’t point to unshared things is the main restriction, not the main thread. Big problem on main thread in the spec is you can’t use atomic.wait, although you can spinlock by accessing shared memory. We don’t allow blocking on main thread, limits what you can do on shared memory.

RT: I remember in the requirements discussion, there was a subdiscussion that Erlang wouldn’t be able to use GC for some reason?

FM: two scenarios, java shares everything in multiple threads, or multiple threads that don’t share. In erlang they want a super fast dispose that get rid of the entire process

LW: a spawn instruction, that doesn’t share with caller. WIth this spawn instruction, use totally unshared GC memory, each spawned thread has its own process, with green threading as the implementation, a cheap segmented stack, then that could be a reasonable basis to base erland spawn off of.

FM: we’re talking about… not just the stack, but also the heap you need to spawn off. What should we put in the requirements document. Thou shalt have threads

CW: makes sense to note it down. In my head it exists, but not surfaced in documents.

TL: possible that we can have threads without a segmented heap idea? Those seem intertwined, we discussed how impl of thread would use disjoint heaps, this disjoint heaps has been proposed as own feature independent of threads, e.g. for Erlang. Independent of threads, is disjoint heap important enough that it should get its own requirement?

RT: if you can have heap that are disjoint, but you know where the x-refs are, then becomes easier to collect cycles within heap space. Then do a larger occasional cross-space cycle thing.

FM: just to follow through, in the current world without GC. WIth GC, you have a worker thread, you have multiple memories, each module instantiated differently. We’re in danger of getting to, coalesce multiple memories into a single one, then the pressure on renderer becomes important. We don’t have multiple memories then pressure becomes and issue, and performance becomes an issue.

WO: I have argued that having multiple heaps for GC has many advantages and I wasn’t even thinking about threads. Shared references seems inherently problematic and should use interface types instead.

TT: in such a model you can’t do java right?

CW: we’ll need truly concurrent GC at some point due to the language we want to support

LW: These are not mutually exclusive. It’s desirable to have a shared GC heap and also to have isolated heaps.

CW: at the language level, when creating a new gc object, can it be a particular kind of symbol where all family of the same objects sit

LW: I think that will be hard. We’ve considered the symmetric problem in C/C++ world. And it’s not feasible to tag every pointer with its memory. Want to run different languages in different “processes” and have them communicate without sharing.

RT: region based heap and gc, in the surface language it’s too complicated for what most languages want, but when generating the code, it’s easier to imagine generating code to deal with regions.

CW: It is something that could be forwards compatible. If we want to add annotations

TL: in mvp wasm, single memory, then later expanded to multiple memories. Even in the beginning with single memory, that memory was declared in the module even with just 1, with limits, import and export. If we exactly mirror that design, then in the MVP we should have a GC heap to declare possibly with limits, but only 1 of them. In the future extend that to multiple GC heaps. Nothing like that has been proposed, though. Should we consider doing that?

FM: that’s a beginning, you’ll have to have a spawn instruction.

RT: TL is saying tha can happen later. Should struct.new or whatever instruction, should that have an immediat that must be 0, that refers to the index space of GC heaps?

RT: then you might need to bake them into the types, so you know which refs belong to which heaps

AR: what’s the exact benefit?

TL: if all the concepts are in place, and instructions have these immediates, then the future extension to support multiple gc heaps is trivial, relax those constraints.

AR: but what do you get if you can be explicit about multiple gc heaps? How would it be observable. There would be an instruction that make use of this?

TL: isolated gc heaps can’t reference each other, some shared some unshared

RT: instruction making a new struct in a given heap, the tyeps correspond to that heap

AR: all that is imposing restrictions, what do you get out of those restriction?

TL: theorized to have perf benefits

CW: concrete example is to throw away entire gc heap at once. Fast green thread

RT: … for free, shared heap

AR: don’t understand how throwing away heap, if you still have refs you can’t throw it away, it won’t be observable in anyway, maybe just be an optimization hint. Like a page in the larger heap, or a set of pages, maybe GC has some hint to evacuate them. SEmantically i don’t see what you get out of it.

TT: main benefit is separate collection

RT: maybe not a semantic thing, lets you maintain separation that are then useful for various performance things

BT: this is going in the direction of doing region analysis, problem is that we need to have region annotation everywhere, args to all functions, returns, you need to param function over region, a completely orthogonal dimension in type system that goes viral. Not sure if see benefit from this region inference, if you already have a GC.

TL: we are out of time, need to explore cost and benefit ideas more, including using it for threads.

JK (chat, and not in the right timeline): I think the Erlang memory management model doesn't _necessarily_ need separate memories. For instance, V8's GC cost is proportional to the number of live objects. So having a short-lived thread create a bunch of garbage and then die would be fairly efficient -- maybe slightly less efficient than per-thread memories (as native Erlang has), but not necessarily deal-breakingly so. (Which _isn't_ to say that Wasm _shouldn't_ have multiple disjoint memories.)
"
main/2021/CG-06-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 8th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: June 8th, 4pm-5pm UTC (June 8th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Present and discuss [Interval Primitives](https://github.com/WebAssembly/design/issues/1384) (Kloud Koder)[40 mins]
    1. Present and discuss [Multiprecision Primitives](https://github.com/WebAssembly/design/issues/1386) (Kloud Koder)[10 mins]
    1. Status update on [Branch Hinting](https://github.com/WebAssembly/branch-hinting) (Yuri Iozzelli)[10 mins]
1. Closure

## Agenda items for future meetings

1. Present and discuss [Multiprecision Primitives](https://github.com/WebAssembly/design/issues/1386) (Kloud Koder)[10 mins]

### Attendees

- Derek Schuff
- Elle Imhoff
- Frank Denis
- Kloud Koder
- Chris Fallin
- Garret Gu
- Zhi An Ng
- Francis McCabe
- Thomas Lively
- Yuri Iozzelli
- Jacob Abraham
- Emanuel Ziegler
- Dan Gohman
- Keith Miller
- Sabine
- Alex Crichton
- Sean Westfall
- Alon Zakai
- Paolo Severini
- Lars Hansen
- Andrew Brown
- Sergey Rubanov
- Rick
- Ryan Hunt
- Asumu Takikawa
- Nabeel Al-Shamma
- Daniel Wirtz
- Sam Clegg
- Ross Tate
- Petr Penzin
- Flaki
- Zalim Bashorov
- Jakob Kummerow
- Richard Winterton
- Slava Kuzmich
- Yury Delendik
- Adam Klein
- Pat
- Jlbirch
- Vivek Sekhar
- David Piepgrass
- Andreas Rossberg



## Meeting Notes

### 1. Present and discuss [Interval Primitives](https://github.com/WebAssembly/design/issues/1384) (Kloud Koder)[40 mins]

TL: ultimately this is a performance feature, higher level languages would unlock this extra performance if Wasm supported these ops. Reminds me of the SIMD proposal, which was just standardized recently; in the early days of SIMD, the approach we took to justify doing anything at all was to get estimates of the actual performance benefits. Two parts: performance benefits that could be unlocked by baking these things into Wasm, and then the impact of the new instructions, what applications will use them. To justify all this work, it would be really good to have similar estimates of the performance and impacts on applications. On SIMD we took some native code that used SIMD, and looked at the performance difference when it didn’t use SIMD, used only instructions that were only available in Wasm, but native versions, and looked at the performance difference between that and when the code could use SIMD. Will be great to see a similar exercise done here to justify the additions to the spec.


KK: that would be creating a benchmark, and we could argue about how representative it is. If i did this it would use the intel instruction set. But you'd see a lot more benefit with e.g. nvidia which has native rounding mode. But that’s a hard hurdle to overcome.

TL: we also don’t have a precedent for these future facing features where we add something to Wasm with the expectation that hardware will support that and make them fast in the future. In SIMD it’s about what performance we can get now. To my knowledge, Wasm is not being run on GPUs in any significant amount.

PP: available on CPUs too, all the primitives are in standard math library


KM: i thought gpus don’t handle function calls in the same way CPUs do. Doesn’t that cause problems?

KK: what do you mean by function calls?

KM: there’s some Web Gpu stuff, whistle or something? [WHLSL] It can’t do recursion or functions must be inlined.

KK: yeah you’d run out of stack fast

KM: you can’t translate wasm directly into that, a lot of modules may not compile.

KK: would compile and run out of stack really fast but whole thing would crash. That’s sort of a parallel issue.

PP: could validate module, but GPU is different. C and C++ has all this facilities. Some of this is available in standard math library.

KK: yeah in x86or C they'd use this floating point environment stuff which is very dangerous. But the capability to change rounding modes is there.

PP: we can actually use this on CPU already. The comment that this is future facing and only on GPUs is inaccurate.

FM: AFAIK we haven't made any real effort to design wasm or run it on GPUs. so anything that refers to being better on GPUs isn’t really in scope (at least temporarily).

KK: agree, will emphasis on the word temporary, i think it is inevitable with the backing behind it

FM: I think it would be a completely different standard

KM: on FM point, since there isn’t production Wasm engine targeting GPU, seems premature to add instructions that benefits only GPU

FM: the other part is to pick up on Thomas’ point, to get convincing evidence, even a small benchmark would be a lot better than nothing

KK: would it be compelling if i were to do that on Intel, in order to change rounding mode, have to touch the control mode, will be a lot faster than in Wasm. I can do in Wasm, and in assembly, and measure performance ratio. Will that be compelling? Is that a good test.

KM: what we did for SIMD was… one of the main goals is to be portable. So for SIMD we tested on most of the major CPU architectures (a bunch of ARM and x86). We checked that it at least didn’t work. And it was focused on how you’d write SIMD in C++ e.g. the SIMD support available in the language rather than doing it in assembly.

KK: if i were to do the equivalent, i would be using some open source C++ interval library?

KM: yea something like that, where it generates actual… there isn’t native instruction, assume interval library is changing the rounding instructions already

PP: we tried to do this test: in SIMD we can process the same data in SIMD or not. But right now we don’t have rounding mode support at all. So this would enable it rather than just making it faster.

FM: another thing to try, taking one of the engines, say wasmtime, trialing the instructions that you want to do on that.

PP: sounds like making an actual implementation

KM where we don’t have a control. With SIMD, just don’t do the vectorization, just do it serial. But here, how would you do it? The main concern I have with rounding mode is that for a browser, every time you make a function call out of your module, you have to restore back to the rounding mode used by the browser, and it has to have the rounding mode that JS uses. Every time you call into another module, you have to set it, and on entry.

KK: but it wouldn’t, if you do it per instruction, it only affects the instruction, you wouldn’t worry about global state

KM: assuming every instruction in a function has the same mode, you’d be setting in a function. Not sure how that would perform.

KK: discussed this a bit in the issue, if you compile interval code, you want to group instructions by common rounding mode, but under this proposal, rounding mode only applies to a single operation, reset to default every time. If you use the existing instructions, nearest-or-even. If you want, up you use an instruction that rounds up.

KM: sure but once you compile it, you can see. E.g. on ARM the mode is per-instruction.

KK: which is exactly what we want.

KM: all Wasm needs to be portable, we have to make sure it isn’t horrendously bad on intel as well.

KK: yeah the irony is that it would be really bad compared to arm or nvidia. But in the absence of any support it would be even more horrendous. Also, regarding the control: it is possible to write correct interval arithmetic with nearest-or-even, you just get wider intervals. So we could hack that up. You could compare that against the same “nearest-or-even only” mode in assembly or C.

TL: seems like a good control to me

FM: we are not really comparing assembler with Wasm

KK: that’s why i said i can write it in C, actually C is quite close to assembler, GCC can optimize it well

KM: we try to avoid tests where people handroll assembly. We focus on Wasm being a compiler target, certainly possible to inline wasm in clang. Compiling a giant library is the general use case.

FM: there isn’t enough expertise in the group to have a clear idea of what the benefit will be, can you suggest a potential experiment that we can use to evaluate the benefit of this?

KK: performance benefit, or others?

FM: since this is a performance feature, then performance.  Generally we need to know what the benefit would be.

KK: transcendental function like taylor series, it’s extremely taxing on conventional systems

FM: what would a good experiment look like?

KK: computing a bunch of sin, cos, logarithms?

FM: what is the a and b?

KK: a will be compile to wasm, and b will be native

FM: that won’t be a good experiment

TL I think you’d want to compare native to native or wasm to wasm. Probably you’d compare native to native since it’s not in wasm yet. This is what we di din SIMD. in the control case youd limit to the capabilities already in wasm. So youd make a native build with just th eone rounding mode and build everything on top of that. Then the other case you’d use all the proposed capabilities, and find the performance ratio. And we assume you could get the same ratio.

KK: this is where comparison with SIMD breaks down. If i were to use nearest-to-even and compare to optimized impl with 4 rounding modes, it will be a comparison of precision and not performance. The real problem is that the way things stands, the sheer number of instructions will affect the performance… code verbosity is a roughly proxy for performance.

KM: can’t you keep refining it until you get to the precision that native has. You’re comparing the exact same results, you want both to return the same results. That would be apples-to-apples.

DS: we’ve eaten into our other allocated time, wanted to see if you want to continue this conversation or go to the next presentation.

KK: we can defer the next presentation. You want the test to come out with the same answer. The question is how much time, how many lines of code. Maybe the real apples-to-apples will be wasm as it exists, and a wasm with some support for the interval instructions, e.g. 10 instructions, and make a loop out of it, and compare performance that way.

KM: that sounds like a good test, but that seems harder than doing it in C, right?

KK: yea, someone would have to help me a lot about that, i know nothing about the guts of wasm.

KM: you do it in c you can get a lot of it without help

KK: write this interval arithmetic loop computing sin/cos in C, and what is the a/b case.

KM: the other case is using native rounding mode. One loop will use nearest to even, has a loop where it keeps refining, to get the same precision. The other is just natively.

KK: they both ultimately get the same exact answer

KM: right and you see what the performance difference is 

PP: handicap one side until it looks like wasm

KK: i’m not sure how to handicap it. The easiest way would be to compile to wasm? The deficit in performance isn’t so much due to the lack of rounding mode, but having to issue so many instructions that treat integers as floats and back.

KM: that’s fine, that’s exactly what you’re trying to show. Right now if you have to do that, you have to issue those instructions. What we are trying to show to motivate this is that by having thes support in Wasm, you see a similar improvement in what the experiments will show.

KK: so, but as petr said I’d have to know how to handicap my C so it works more like wasm?

KM: write a c library that does the repeated refinement. Don’t think GCC/Clang knows that you implementat a different rounding mode in floating point.

KK: I think i see what you’re getting at. So they end up the same result, and I do whatever i’d have to do to implement outward rounding.

KM: yea you should put a good faith effort to try and optimize, i can make any experiment an infinite loop. We want it to be a fair experiment, but that’s what everyone was getting at for what the first experiment will be.

DS: thanks for the presentations and all the suggestion

### 2. Present and discuss [Multiprecision Primitives](https://github.com/WebAssembly/design/issues/1386) (Kloud Koder)[10 mins]

[POSTPONED TO NEXT SLOT]

### 3. Status update on [Branch Hinting](https://github.com/WebAssembly/branch-hinting) (Yuri Iozzelli)[10 mins]

YI: [Presentation](https://drive.google.com/file/d/1NYFMqDtikAr7ClLK-4XUPQme_ftDZb3T/view?usp=sharing)

RW: where do the gains come from?


YI: for this test, i don ‘thave that data. I can get it I think because I can use perf on the generated code. On previous experiments, I think its both cache locality and register allocation. (this is v8; it didn’t generate very good code for this case before). I think it’s mostly cache locality, pushing these unlikely code down away from the hot code. But it does seem that register allocation is a bit better too, just from looking at the code. I can make the binaries available on the web.

RW: i will be interested to see where the gains came from, code locality… doubt it is the branch prediction

YI: <something> v8 issues branch hints, just generates different assembly code

DS: in general sense, there’s no good way for end-to-end test, non-observable behavior in the engine. One way in the standard unit testing system is to design a system with some other kind of side entry api that will let you observe these differences. In this case that could mean providing some way in the reference interpreter to observe some of these expected effects, not sure if that’s something we want.

YI: right now, for names section, it’s kind of similar, how is that handled in the test.

DS: having no test is another answer

DP (chat): Well, you could run all tests with and without hinting to ensure (1) same behavior and (2) branch hinting isn't slower

KM: is there a flag to tell the interpret to treat custom section failures as failures? Can give you an idea of how the custom section is parsed, you won’t test the actual feature of emitting the hints. I can see parsing tests, not sure about code-gen tests. Engines probably have a way to check these, e.g. assembler. Not really portable.

YI: will open issue, and see if there is easy way to add parsing test

PP: this can only be used from one particular machine simulator, no toolchain support or other stuff.

YI: at the moment here isn’t

PP: how is this supposed to work? Adding a feature to one interpreter.

YI: idea is to add support to toolchains, if writing C, there are builtins to add hints, in native code, LLVM has this and pass it to Wasm

PP: do we know who will use it

DS: in toolchain, llvm has this,exposed to languages, can use profile information to add hints. Ideally we can do code layout optimizations. It is a requirement for phase 4 for implementation in toolchain, when we get there, we can discuss if 1 interpreter is enough.


PP: yea, my concern is slightly different from what branch hinting in normal toolchain.

YI: i expect that for most code, in c/c++, even in native, those hints are not that effective, they are manually put there by programmer, they don’t know actually how likely. An interesting thing i see is that this can be hooked up to profile-guided optimizations, the hints will then be much more reliable.

PP: on native, we get profile, recompile. But if we run on x86, profile, then run on arm, what happens?

YI: the idea would be that you’d run it in the VM and have a way to get that information from the VM, it would be portable.

DS: we are over time, we’ll have to continue the PGO discussion later.





"
main/2021/CG-05-25.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 25th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: May 25th, 4pm-5pm UTC (May 25th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Follow-up discussion from the [CG-04-27 presentation](https://docs.google.com/presentation/d/1PSC3Q5oFsJEaYyV5lNJvVgh-SNxhySWUqZ6puyojMi8) and [design/#1415](https://github.com/WebAssembly/design/issues/1415) (20 min)
       1. Poll: Does the proposed direction sound good?
       1. Poll: Should we proceed with the [next steps](https://docs.google.com/presentation/d/1PSC3Q5oFsJEaYyV5lNJvVgh-SNxhySWUqZ6puyojMi8/edit#slide=id.gcd82cd8251_3_6)?
    1. Present and discuss [Wasm Signatures](https://github.com/WebAssembly/design/issues/1413) (Asra Ali, Frank Denis, Piotr Sikora, Luke Wagner)[40 mins]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

###  Introduction of attendees

Alon Zakai

Dan Gohman

Frank Denis

Luke Wagner

Derek Schuff

David Piepgrass

Lars Hansen

Deepti Gandluri

Ross Tate

Dan Gohman

Francis McCabe

Mingqiu Sun

Connor Hicks

jlbirch

Conrad Watt

Paolo Severini

Alex Crichton

Andrew Brown

Emanuel Ziegler

Jay Phelps

Yury Delendik

Thomas Lively

Nick ""fitzgen"" Fitzgerald (he,him)

Jacob Abraham

Thomas Tränkler

Adam Klein

Rick Battagline

Asumu Takikawa

Manos Koukoutos

Daniel Wirtz

Lin Clark

Piotr Sikora

Zalim Bashorov

Chris Fallin

Andreas Rossberg

Asra Ali

Jakob Kummerow

Luke Imhoff (@kronicdeth) (they/them)

Ryan Hunt

Sergey Rubanov

Daniel Miller

Nabeel Al-Shamma

Keith Miller

Richard Winterton

Zhi An Ng

Daniel Ehrenberg

Sam Clegg

Ioanna Dimitriou

Ben Titzer

Slava Kuzmich

Sabine


### Find volunteers for note taking

Acting chair to volunteer

### Proposals and discussions

#### Follow-up discussion from the [CG-04-27 presentation](https://docs.google.com/presentation/d/1PSC3Q5oFsJEaYyV5lNJvVgh-SNxhySWUqZ6puyojMi8) and [design/#1415](https://github.com/WebAssembly/design/issues/1415) (20 min)

<LW presenting high level summary>

**POLL: Does the proposed direction sound good?**
    
|SF|F|N|A|SA|
|--|-|-|-|--|
|13|18|7|0|0|


LI: Are we going to transfer issues to move current issues into new repos?

LW: Discussions are already in IT/Module linking proposals, are you talking about individual repos?

LI: you can move individual issues with all of their comments, but you can’t fork

LW: in that case there are probably a few adapter-function-specific issues in the interface-types repo that we could move.

SC: all the repositories will get merged in as they become staged. Will any of them be optional? Or will all of them be part of the core component model?

LW: Should IT be optional? Do they only want module linking, they’re self contained we can make them optional - we will see if particular hosts want to do that

FM: why are you separating module linking from component model, and why module linking on top of component model

LW: It’s more like the component model is the current spec, it is for high level discussion of goals etc. The other repos would get merged into it, the way proposals are moved into the spec. So the module liunking is just a feature proposal so it goes into the archive mode.

TL: Is it correct that the module linking is the first feature, before it gets merged there is no technical content at all?

LW: precisely, only high level docs, looks like the design repo until the module linking thing gets merged in

ZB <chat>: Are there any rules or recommendations (to read?) about what should be part of core wasm? What should/could be part of the new component-model in the future?

LW: there is a high bar on things that goes into the core, somewhat universal, fundamental, such that it applies to a wide scenario. Part of the goal to have a layered spec is to allow us to focus on the things i described earlier, not every possible use of Wasm will want those way, that’s an opinionated way to design modules. When something feels universal, like i32.load, pretty fundamental, then they go into core proposal. If you can’t meet that, then it makes sense to look at existing layered proposal or start a new one.

CW: We will be privileging a particular linking model

LW: in slides i have a spectrum of linking with 5 different features, all of them make sense for different use cases, but reasons to only have a subset of them. One way to relieve that tension is a layered spec with limited scopes.

RT: Core wasm about a composition of instructions, and this is for linking systems and both of them can evolve in separate directions

LW: If you look at our partners in the networking space, there are a lot of requirements and we see this evolving over the next few years

DW: this does not include string encoding, in the proposed steps, there is this link to a draft PR that essentially proposes UTF-8 and lock it in, how strongly connected is that PR to the next steps.

LW: We can iterate on the PR, it’s a draft of what the canonical API would look like

CW: it would be appropriate to have a vote on what would be in the canonical ABI (i.e. later, not in this meeting)

LW: yea

RT: The poll right now is to have a canonical ABI, and not what the ABI is

LW: yes

DW: in this case, i’ve outlined a few concerns in a recent presentation in the design repository, one concern i identified is that if we choose to have a canonical ABI, we most likely have 1 string encoding that is attached to the canonical ABI, and if we do one encoding, which is UTF-8, there are certain issues, if we use another string encoding, like WTF-16, then other languages will be unhappy. I would recommend checking out my presentations, I have concerns there that I would like to be addressed. Picking a canonical ABI will result in us having to make a choice on a single encoding. There is still a lot of time to check this out.


LW: There is a tension, in general any sys call API etc, there are always some things that get fixed, it’s a natural progression

DW: WTF-16 as the canonical, necessary superset of utf-8 and represent JS encoding, and C#. NO need to trap the ABI, cannot represent isolated surrogates.

FM: This discussion should be probably be had offline

RT: the meta point is that it will be useful to be cognizant of canonicalization can cause partition, and there are multiple ways to address that. That opinion should be heard, i also share the opinion that we should find a solution to that. We are not going to solve that this minute.

DG: make a quick note that we have a slot in a meeting 4 weeks from now to discuss this general idea in DW’s presentation, we can continue this discussion. Moving forward to the poll doesn’t mean we won’t have this discussion in the future.

AZ: question about process, the slide mentions MVP, doesn’t say anything about phases, this doesn’t move anything in terms of phases, Interface Types stays at Phase 1?

LW: That’s right

AZ: MVP in the sense that it is the current idea we are thinking, open to change as we move through the phases?

LW: yup, definitely

**POLL: Should we proceed with proposed next steps?**

|SF|F|N|A|SA|
|--|-|-|-|--|
|10|20|8|2|0|

DG: R would you like to say why you are A

R: I have been talking to DW a lot about this, I’m not sure a canonical ABI is the best idea, I can be convinced otherwise, but I’m feeling uneasy about it, based on conversations we have had.

DG: is there anything you can say about how you can be convinced otherwise?

R: want to see more discussion on the topic

DP<chat>: UTF-8 and UTF-16 are isomorphic; both can hold isolated (invalid) surrogates. Obviously any choice will favor some languages over others, but I don't see that anything is to be gained by not making a (canonical) choice.

DE<chat>: imo wtf-16 is a reasonable canonical representation

CW<chat>: I think there’s some more nuance, depending on how isolated surrogates are dealt with at the boundary
Especially when compiling legacy code that may have WTF-16 binary strings
^ to David’s comment

DP: oic,, WTF-16 is what I meant even though I'm just hearing about it today
Or rather, WTF-8

#### Present and discuss [Wasm Signatures](https://github.com/WebAssembly/design/issues/1413) (Asra Ali, Frank Denis, Piotr Sikora, Luke Wagner)[40 mins]

AA Presenting [slides](https://docs.google.com/presentation/d/18eKvlIjq8YImBMR2IKe8UlM33q2ppdHxWUsftZNkyzU/edit?usp=sharing)

AA: This is my first time presenting, Piotr and Frank will jump in as well.

AA: Some context: there’ been some history on signatures in wasm modules, including work by Frank Denis and others. We wanted to give a <pre-proposal?> vote: we’ve been having biweekly meetings and other discussions [linked].

<motivation slide>
AA: questions/comments?

FM: what’s an OCI image?

AA :In some cases people are distributing wasm modules - packaging them as an image format so that you can upload them in certain registry - you would have to extract the wasm bytes from the image

FD: OCI is basically like docker.

AA: Some specifications for docker images are already being made, but don’t know of any efforts to standardize them

FM: if you’re putting the signature inside the module itself, what exactly are you signing? (since you can’t sign the signature)

AA: This comes into the implementation details, the signature may appear as a custom section, and be signing a previous section - an additional section against the runtime code - parse and verify previous sections.

<in chat, regarding previous question>
CH: Commonly used for Docker registries

TL: OCI is “open container initiative”

DM: Would nested signatures be allowed in this pattern? Multiple signers in sequence on a module?

PS: Yes (in most of the designs) - will be discussed in later slides

FD: @Daniel: yes (and we have enough time left, I can demo this).

CH: <chat> Love all of this, I have some use-cases to contribute later, too :)

<AA continues presentation at Use Cases slide>

NA<chat>: When streaming wasm, what is tradeoff to put signature at beginning of file vs end?

FD<chat>: With the signature at the beginning, the module can be immediately rejected if it doesn’t verify for any public key; no need to download the rest of the module.

FD<chat>: With option (d), downloading the header is enough to check if the rest of the module will verify. (Design slides)

FM: This seems pretty complicated design, and it is also not obvious to me why this is specific to wasm, I assume that there are document structures that one could have and then if you want the wasm out of it, you strip the metadata out of it, why does it have to be a part of the wasm structure, and not a layer on top of wasm?

AA: for example if I only wanted to sign an additional section, i have to be aware that it’s a sectionalized file

FM: One could have the concept of a signed blob of bits, and have delimiters inside the blob, this would have to be a separate layer, and not embedded into the structure

AA: one advantage over having be in a separate structure is that any runtime able to parse a custom section could get that signature. Otherwise a runtime might not be able to easily verify the signature.

FM: I don’t follow that argument, don’t want to derail the discussion

AA: We can go into that a little bit more, figure out what is needed

RT<chat>: apologies if I missed this, but could a design be to have a ""signature"" section list the numbers of the sections it is signing - those numbers could reference sections before or after the given signature section

FD<chat>: This is option (e) which is on the next slide.

CH<chat> ++ runtimes with built-in verification sounds like the right call

AA: I only have signatures..

CH<chat>:++ runtimes with built-in verification sounds like the right call

DE: Web Bundles may be another future standard to give a file format which can contain signatures, but the presented proposal has a nice fallback property where it just works if the signature is ignored.

AA: <links> The proxy-wasm link is an example of a prototype that verifies the module on load

NA:  I'm only moderately familiar with this space. I think it would help to have the use cases say more about whether the scenarios… they are written more like “this is the existing state” of a bunch of different use cases. As a developer i mostly want to validate that the wasm the browser is loading is the one i generated. So I’m not clear on how the designs fit into that.

AA: The use case that you mentioned is the obvious use case, the authenticity of the module, the use cases that we have are more niche, why we need multiple signatures, or why we need different signatures for signatures for different parts, that’s why we’d like to have specification, or common ground for it

FM: i’m curious how this will interoperate with module-linking and component-model?

AA: Luke has been talking to us about it - a runtime could be aware if the two modules have the same level of trust, or if they are signed with the same key - or on the converse, no, I should not accept an unsigned module to link, in developing this specification we want to keep this use case in mind, we are not aware of anyone using signatures when linking modules, but seems appropriate

sbc<chat> FWIW both ELF and MachO have specific container-aware signing systems

DM<chat> In my mind the next steps this flows to is a module declaring a link to a module defined by a url and a signature, like how some JS is done right now.

FD<chat>: Or a URL and public keys

AA: not sure how to run the poll?

DG: as this is a pre-proposal, we could just do a consensus poll.

TL: should we go for phase 1, since this seems to clear the bar for phase 1 by a large margin?

DG: depends on whether the presenters are ready

AA: i think our intention is to go to a proposal. We’d love to have feedback as more people become aware.

DG: we could see if there are concerns in this meeting. We didn’t have the poll on the agenda ahead of time.

Are there concerns about a proposal?

FM: I’m not yet convinced this needs to be a design in wasm itself.

JK: I'd agree with Francis, especially from the runtime perspective, it would be very hard for us to implement in e.g. V8. It would probably make more sense like HTTPS on the web where it’s done at a higher layer 

AA: Those concerns were echoed before, the module signatures are complimentary to that, in this case we want more granularity, which could be done externally as well. Redistribution  without resigning would be possible if you were transferring across different boundaries, independent of distribution mechanisms

BT: the nice thing about wasm modules is that the format is has headers with section+length, so it’s easy for engines to ignore sections they don’t understand.

RT: it sounds like you’re proposing a “standardized” custom section. 

RT: You are assuming a standardized custom section, and for implementations that don’t want it they can skip it

AA: The intention is that all of these design options are custom sections

FM example of a scenario that would be difficult, would be an application which is a combination of JS and wasm and I want to sign it as a whole. The mechanisms would work for the wasm part but not the JS part. It’s a common scenario, if you want to sign the wasm you’d probably also want to sign the JS.

DE: Web Bundles may be another future standard to give a file format which can contain signatures, but the presented proposal has a nice fallback property where it just works if the signature is ignored.

SC: FWIW both ELF and MachO have specific container-aware signing systems

FD<chat>All the options we have just use custom sections, to leverage existing parsers.

DE<chat> he Web Platform has some mechanisms for verification like SRI, where signature-based SRI is under consideration. If this is intended to ship on the web, we should consider the relationship/interaction between them.

DG we are running out of time, are there some github issues where we can continue this?

AA: ill post a link to the design repo and the wasm issue, we’ll post it there.

https://github.com/wasm-signatures/design

https://github.com/WebAssembly/design/issues/1413

### Closure
"
main/2023/CG-05-23.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 23rd video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: May 23rd, 4pm-5pm UTC (May 23rd, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. GC & strings (presentation + discussion) [Adam Klein, 45min]
1. Closure

## Agenda items for future meetings

Followup discussion scheduled for [June 6](https://github.com/WebAssembly/meetings/blob/main/main/2023/CG-06-06.md)

## Meeting Notes

### Attendees

* Conrad Watt
* Anne van Kesteren
* Adam Klein
* Justin Michaud
* Alon Zakai
* Slava Kuzmich
* Jeff Charles
* Francis McCabe
* Yuri Iozzelli
* Yury Delendik
* Paolo Severini
* Andrew Brown
* Ilya Rezvov
* Calvin Prewitt
* Ryan Hunt
* Luke Wagner
* Asumu Takikawa
* Nick Ruff
* Sam Clegg
* Andreas Rossberg
* Zalim Bashrorov
* Jakob Kummerow
* Matthias Liedtke
* Ashley Nelson
* Alex Crichton
* Johnnie Birch
* Emanuel Ziegler
* Derek Schuff
* Deepti Gandluri
* Bruce He
* Heejin Ahn
* dbezhetskov
* Sergei Rubanov
* Andy Wingo
* Brendan Dahl
* Nick Fitzgerald
* Petr Penzin

### Discussions

#### GC & strings

AK: presenting [slides](https://docs.google.com/presentation/d/17T5-btFn-kzOxGyh41LqA7NHx995PhyNjJsXbTxHCCQ/edit)

AVK: in principle stringref allows for zero cost but that assumes that the host has a particular representation for what you invoke, this could change over time. E.g in firefox the CSS parser changed from WTF16 to UTF8. if there were existing callers, it would be a perf regression.

AK: Yes that’s true, platform owners would need to take this into consideration when making sure what APIs they chose. There’s always a tradeoff when changes are made - it allows zero copy, it doesn’t guarantee zero copy

AVK: yeah, i guess are there more engines that want to use UTF8 internally because it uses less memory. Would this prevent that from happening?

JM: If I was going to describe it, it's more about what is the purpose of Wasm? We don’t want abstractions that hide their cost. We don’t want an abstraction whose cost changes dramatically, no personal strong opinion yet, but definitely interesting

AK: yeah it does echo that I listed this among the cons for stringref

RH: question about the Sheets perf result. User space vs. string optimized? What does that mean

AK: this is character by char copying from i16 array to a string, via a buffer. Vs string.new_from_wtf16. I.e. the handwritten approach vs stringref conversion

RH: were they using stringref across their runtime? Or only when they’re boundary crossing? 

AK: For this we’re only using stringref on the boundary, an experiment we ran to isolate different aspects of the performance here. They also have a configuration where they use stringref everywhere but it’s less clear that it makes a big difference.

ZB: In the case of Kotlin we use stringref for the internal representation, and we use the same references for the browser APIs

AK: Pulled this from the jetbrains slides at I/O, the dom benchmarks are not microbenchmarks, but when you’re actually in a realistic environment, so stringref was a big difference

JM: For engines that would have to do the copy between UTF16 and UTF8 anyway, do you know what the numbers look like? Neutral or basically an improvement?

AK: I don’t know for sure. V8 and chrome don’t use UTF8 internally in most places. We could guess but no hard numbers. It would be interesting if there were engines where they do use 
UTF8 in some places, would be interesting in practice.

AVK: One thing you could measure is cost for UTF8 languages, that might also be tricky

AK: there’s discussion later about the difference between copying in userspace wasm vs doing it in the engine, I think it would be cheaper in the engine, will address that.

ZB(via chat): Kotlin/Wasm demo with strings
https://zal.im/wasm/dbmonster/
https://zal.im/wasm/dbmonster-stringref/
Same compiled with Kotlin/JS
https://zal.im/wasm/dbmonster-kjs/
Pure JS implementation
https://zal.im/dom-monster/

AVK: There’s no support for latin-1 string?

AK: the stringref doesn’t currently expose latin-1. You can get a view over a latin-1 string but it’s not currently mentioned in the proposal. Mentioned stringref in this proposal as a solution to a particular problem, ex. For regular expressions, you run into this very early, to be able to compete with the existing JS engine. Obviously stringref provides a lot more than what you need for that particular use case

JK(via chat): Anne: the key principle of the stringref proposal is to *make it possible* to avoid avoidable encoding changes. That includes allowing engines to use whatever encoding (including multiple encodings, including changing their preferred encoding) under the hood. In your example, a Wasm module creating a string from UTF-8 data can reasonably expect that no re-encodings will happen when sending such strings to Firefox's UTF-8 based CSS parser. (At least in the long term, assuming engines have had enough time to optimize.)

AVK(via chat): I understand. I'm worried about the ossification risks.

FM: can I ask about Java as an example: any language has its own semantics for strings. J2wasm doesn’t need to honor Java semantics, it has its own. When you actually try to honor java semantics, that will introduce additional complexity to any support for strings. Do you know whether there are issues with “true” java semantics that would not be supported by stringref?

AK: Do you have an example of something that might not be supported? 

FM: Java has a very rich locale/i18n library. It’s not fair to push the implementation burden of that into the platform.

ZB: It is not about semantics, but more about the API that you have in Java, isn’t it? 

FM: you’ll replace the existing APIs in Java with those provided by stringref

ZB: You can use basic things and implement other APIs on top.

AK: for example locale toLower, thats not in stringref, it’s in the intl library in JS. I would expect stringref to be low-level enough that issues about library support would be out of scope.

CW: Even in linear memory, you would have the same overhead of copying it in and copying out back? 

AR: I don’t buy that it’s as simple as that. There's a very strong slippery slope. This is already pulling some amount of unicode logic into the engine/platform and people seem to be already requesting more. So this is a very real risk that we do end up putting things from Java into the platform. These arguments are a fallacy because you could use them to argue for integrating any feature from JS or another language. So if you want to integrate with that then of course you'd benefit from adding those elements. But this is 
The opposite of what we want to do for wasm, where we want to add as little on top of the hardware as we can get away with. It has big implications beyond looking at this feature.

CW: even with some existing features, that sometimes we’ve understood the power of exposing the engine APIs for exceptions, GC for example, where the engine can operate much faster than in user space

AR: true but even there we try to not hide costs, but this proposal hides a lot of cost, including allocations, assumes rope implementation strings, hidden branches, etc. not true of other proposals (other than GC). the GC instructions have been carefully designed not to hide costs.

AK: First of all, I want to object to the claim these are fallacious benefits, these are actual benefits are strings the question is whether to add the strings or not.

AR: the fallacy is to use this arguments to argue for certain features.

CW: In abstract, but we’re always going to look at quantitative benefits, which may outweigh the aesthetics

AR: The narrative that this is about aesthetics only I want to pushback on that, it’s about philosophical direction of the whole language which we took for a reason, because that’s mainly the value proposition of Wasm, that it not try to do what VMs before did, not build in high-level things when it can get away with

CW: What quantitative benefit is necessary to compromise on that philosophy?

JM: i just wanted to express my support for Adam, nothing in particular.

AK: More philosophy to be had. Happy to continue that discussion maybe further down in the presentation, AR does that work for you?

NR(via chat): Is there an impact on memory usage? (via voice): Wondering, is there any kind of hidden implication in memory in either direction.

AK: In zero copy case, you’re avoiding duplicating memory, depending on what things are in memory, it might have significant or not memory savings, but it does offer the opportunity to memory savings

AW(via chat): there is also the 1-byte utf-16 thing that most js engines do.  but that’s marginal i think

AVK (via chat): Yeah, that's the ""Latin1"" strings I asked. about.

AK presenting import-based strings

AR: it’s worth pointing out that type imports are not strictly necessary. You can get pretty far with just externref. I would be interested in seeing how far you get, especially given all the other stuff JS engines do.

CW: Would this still be externref with pre-imports though?

AR: If you don’t use pre-imports, I would expect externref to be more expensive with all the deopts,
Of all the bullets on your previous slide, I think only the first 2 would remain with pre-imports

AK: Jakob did do measurements with externref without imports and for some things that is okay but for things like accessing individual code units, the overhead of the type check is big enough to be noticeable

AR: as a thing to get off the ground… as you said we want type imports eventually. But this might be good enough to make progress as an intermediate solution, with a path toward getting the best solution later on.

AK: presenting stringref vs import-based strings

AVK(in chat): Aside: I'd kinda dislike if we further double downed on charCodeAt(). JavaScript itself is slowly moving away from it. Nobody really wants code units.

AR: assuming we have preimports, how advanced would these optimizations be? Afaics you only have to specialize certain calls, but then you’d do exactly the same thing as with instructions? All the other advance things go away with pre-imports

AK: We don’t know what pre-imports look like right now 

AR: The baseline thing would be very simple, the only thing we need to do is extend the JS API to get a JS object and then you have that available when you compile instead of just when you link. As simple as that and that would be an easy change in terms of spec work and I would hope even implementation.

AK: i think there’s a bunch of implementation details that depend on the separate compilation, i’m not sure it would be that simple. But we don’t yet have practical experience with that yet.
Also, we’ve heard folks say they don’t want engines to be required to do hidden advanced optimizations that aren’t specified

FM: Don’t you have the same kind of problem if you are accessing a JS String and you do an index that is represented as a rope? Then you have an under the covers conversion. So you get this unexpected O(n) operation.

AK: that’s this con ”user code doesn’t control underlying representation”

FM: Have the same surprise in both ways of doing it.

AR: The whole brittle performance thing seems to be orthogonal.

AK: stringref performance isn’t nearly as brittle as this.

AR: Why not? In  In principle you have the exact same knowledge  in the engine and the user has the same logic in both use cases.

AK there’ no need for the toolchain to import  a bunch of random operations from the host, they are just opcodes that exist in the spec

AR: Sure but you will import these things and you know what they are, so the end result is the same. Yes the tool has to do an extra step here but other than that, I don’t see that it’s brittle in principle.

CW: i’m a little surprised you brought it up. My understanding is that even with stringref, you want fast regex which you have to get from the host.

AK: We’re not inlining the JIT into wasm, the fastpass thing is the strings being passed to and from that function. I don’t disagree there are similarities but it’s not totally orthogonal, it’s not as brittle in the import case because you can’t make that mistake if you have an opcode you call.

RH: That was my understanding of the brittleness, when you have an import base scheme you have to specify how that works. If there’s a WebAssembly.string type, you have to specify what it does, e.g. if someone monkeypatches the methods then everything is different

AR: You are talking about monkeypatching on the JS side? Yeah okay, I don’t know if that’s something we need to worry about and if we did, we could make these objects frozen, right?

RH: If we’re adding new objects for every operation specialized but if you’re pattern matching things into the existing JS environment.

AR: you have to pass in an import object. Then the JS API could provide a WebAssembly.string object, and if it’s frozen then you can’t mess with it. So i don’t think it's a serious concern either way.

RH: Don’t want to focus on this too much.


JK(chat): JS charCodeAt isn't what matters. Operations like java.lang.String.hashCode() depend on iterating over characters. Implementing library functions that (for good reason, because they're source language specific) won't be in Wasm often requires iterating over characters. Iterating over codepoints (instead of code units) doesn't really affect the performance situation in these tight loops over strings.

AZ(chat): As an example of a potential advanced optimization (beyond just replacing calls with code), if after runtime inlining some code ends up as ""a"" + ""b"" + c (two added string constants + an added unknown string) then that can be optimized to ""ab"" + c. (I don't know how important that specifically is, but just as an example of the space.)

AK presenting “lack of polyfill => unintended consequences”, and “optimized copy-at-the-border API”

AR: you’re making one assumption which is that all languages can equally benefit. But you’re measuring on just the language that just happen to have the same string semantics as JS. this is true for certain major languages but not true for the majority if you just count them. So most will end up doing the third thing anyway. Is it fair to privilege some of these languages, at the risk of having this in wasm in the future when this utf16 legacy goes away? You're supporting UTF8 but thats also not necessarily reflective of what languages do.

AK: Yes UTF8 is supported and that covers a lot today but there is certainly a tradeoff between supporting the languages targeting us and the unknown future encodings we haven’t thought of yet. Of course stringref can be modified to support additional views and the implementations can tweak to support the demands of their users.

AR: even in the case where i’m a UTF8 language, don't i essentially also pay the copying cost on the boundary as long as JS is optimized for UTF16, depending on what it does in the future?

AK: There is a lot of ‘ifs’ there, if your language discourages users from indexing into strings, you might be able to get away with not exposing the UTF16-ness or engines may decide to implement a UTF8 encoding alongside a WTF16 encoding. I think there is a lot of freedom in the StringRef approach. I would love for someone who doesn’t use WTF16 to take a look and generate some numbers, that would be awesome.

RH: that was very helpful. We should probably extend and have another meeting in the future, since there seems to be more to discuss, would be helpful to have it live

ZB(in chat): do we need one more meeting for discussion?

CW: The agenda for the next few meetings feels light.

DG: We don’t have anything, so we can cover some time in the next couple of weeks for this discussion.

CW: At time, declaring this meeting over. We’ll get follow ups scheduled.


"
gc/2021/GC-08-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 10 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: August 10, 4pm-5pm UTC (9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Taming type recursion [Andreas Rossberg] (20 minutes + 10 minutes discussion)
    1. Minimal delta for evaluating nominal types [Ben Titzer] (remaining time)
1. Closure

## Meeting Notes

### Introduction of attendees

- Adam Klein
- Deepti Gandluri
- Tim Steenvoorden
- Sergey Rubanov
- Aske Simon Christensen
- Ben Titzer
- Rick Battagline
- Kieran Gill
- Zalim Bashorov
- Alon Zakai
- Lars Hansen
- Yulia Startsev
- Igor Sheludko
- Ross Tate
- Ryan Hunt
- Dmitry Bezhetskov
- Andreas Rossberg
- Conrad Watt
- Jakob Kummerow
- Francis McCabe
- Emanuel Ziegler
- Asumu Takikawa
- Luke Wagner
- Slava Kuzmich
- Daniel Ehrenberg
- Keith Miller
- Zhi An Ng
- Michael Knyszek
- Manos Koukoutos

### Taming type recursion (Andreas Rossberg)

AR: Presenting [slides](presentations/2021-08-10-rossberg-taming-recursion.pdf)

RT: can you explain why antisymmetry property is not important?

AR: Antisymmetry means if you have two types that are both subtypes of each other, they are equivalent. That property is not actually needed for anything, not what you rely on in practise, and does not hold in all subtype systems.

BT: which equivalent is this $t == $u here?

AR: structural isorecursive equivalence.

AR: it is nominal except you do everything up to structural equivalence.

BT: only one supertype?

AR: will get to that

ZB (chat): Do we still need RTTs in this case?

RT (chat): you still need something to cast with

ZB (chat): Can’t we use type for that?

RT (chat): it'd replace a constant-time run-time subtyping check with a super-linear subtyping check

BT: that is a choice whether you want engine to enforce if multiple supertype constraints can be satisfied, can make a case where you don’t want engine to check that

AR: You need to check it because you might use it in one of your instructions - example: You have two supertypes that make contrary assumptions about the type of a field and then you access that field, what type do you get? I don’t think you can allow inconsistent supertypes. There may be ways around that problem, not sure if we need to solve it for MVP

RT: don’t think anyone has currently implemented RTT according to current spec

AR: there is an expected technique, separate problem, the idea is like the Java style vector of supertypes

CW: The part that AR is talking about is the part of RTT mechanism that has already been implemented. Not recursive canonicalization

[end of presentation]

BT: does this get rid of the need for recursion groups?

AR: you still have recursion groups, that’s what type equivalence is based on. Degenerate case: one recursion group for the whole module, then it's indistinguishable from nominal. Except that if you have recursion groups defined in multiple modules, you can still merge/link these modules without having unique type definitions. Usually you only want recursion group span a minimum number of types

FM: what about private fields?

AR: talking about an assembly language

FM: you still need to prevent accesses to structure, otherwise you get the same problem that BT outlined, language can’t implement the constraints, a purely nominal system will allow you to model this, since all the subtype relations are explicit

DE: aren’t private fields going to be implemented by type imports proposal that has an encapsulation mechanism?

AR: yeah..

RT: That doesn’t implement private fields, have to dynamically wrap objects, don’t have direct access to private fields, everything has to go through a layer of indirection

DE: yea but maybe that’s acceptable, my understanding is that’s how encapsulation is supposed to work in the current design. Not sure if people are working on type imports or that part, or if there is interest in other approaches to privacy

AR: We have to be careful not to conflate multiple issues. GC types are a replacement for linear memory, there are no private fields in linear memory. The main use case for encapsulation is where you want to pass an object to untrusted functions, from other language runtimes, this is in the realm of interface types. That is what the private types feature in the import types proposal tries to support. We’ve agreed that running against incomplete types is out of scope for MVP two meetings ago

RT: in the JS world, they have private fields, so you can give your objects to other modules without them tinkering with it

AR: That is a source level language, we’re talking about an assembly language, different problems

RT: think people want Wasm objects to go to JS space and not be able to have untrusted modules tinker with private fields

AR: You’re in the cross-language realm where you could use private types 

CW: separate question of how JS views Wasm objects. Maybe a JS mechanism to mark part of Wasm object as private

BT: This has a tendency to explode into various paths, this is an implementation level pass will not be able to expose source level details. 

DE (chat): ​​I don't really understand how this group decided on Andreas's hierarchy of goals. I think private fields is probably more important than being able to link modules in different languages without having a support module that coordinates things. (structural typing is also a bunch of twisty passages, as we've learned...)
I'd like to come back to the question of the Wasm GC JS API as well

RT: don’t think you have to add mechanism to support this…

AK: unlikely to resolve this here, clear that this doesn’t support private fields

AR: Yes. Not a goal of the proposal.

CW: Add one more sentence - we should explicitly have a discussion about private fields and whether they are in scope.

LW: will be good to know if that's the only remaining open issue

CW: One of the many things people have conflicting opinions about, can be teased apart in the future.

AR: have tried to make clear on every occasion that this type system is an assembly level representation of data layout, that’s the role. You can come up with many additional requirements, but that’s not the declared goal of the proposal.

RT: Let’s move on.

RT: For the slides that you have right now, nominal types modulo canonicalization, what languages would benefit from that?

AR: if you compile structural types into that, you still have structural equivalence, so basically all languages that have those, which is almost all languages, as long as you want to do something else than just whole program compilation or linking

BT: One implication is you get the advantages of nominal subtypes but don’t have the canonicalization problem where you have to import all the types..

LW: when we did call_indirect, discussed the question of multiple modules and call_indirect, should we treat as structural, or should we require unique def for all other modules to import, we didn’t have to think about recursion. Decided that it will be easier for toolchain if you don’t have to worry about that, so use structural equivalence. Only thing new with this is worrying about recursion without being expensive. If this idea solves recursion problem, then the same rationale that leds to structural func sigs would lead to the same here.

RT: The issue has the iso recursion problems - two groups that have the same recursion groups but different order.

LW: yea so we can look if does it solve the problems, if there are no problems this is the default choice since we do it for func types. Nice for toolchain.

RT: If those modules made their recursion groups in different ways they wont be linkable.

LW: have to see if recursion has problem in practice, if not, it will help out the toolchain

AR: A producer has to make sure that the type definitions it produces are canonical in certain ways, for example always picks a consistent order - also true for fields. Producer may want to reorder but needs to make sure it does so consistently. When you want to link things together type defs you usually link modules that come from the same producer, that is the use case. 

FM: thank you to AR for the creative solution



### Minimal delta for evaluating nominal types (Ben Titzer)

BT: we have had lots of disagreement about particular flavor of the type system, around structural v.s. Nominal types. Amount of effort everyone has put into discussion is not commensurate with outcome, we are not empirical enough. Most progress we made recently is due to people implementing things, trying things out, measuring them. TL and others implementing canon of equi-recursive types discovered it was a performance problem. Issue #234 (https://github.com/WebAssembly/gc/issues/234), to implement delta on top of current proposal which adds nominal types. Should evaluate nominal types in all seriousness. Add smallest possible delta to proposal, they go through all toolchain, spec interp, in vm. These are implemented, rogue actions to see if nominal types solve the problem. Will be great if those are not side experiments but are serious things in our repo. Don’t think the delta is big, given what AR proposed today, it is even smaller. It’s a contingency plan, if this iteration of structural types doesn’t solve the problem, and if we have also done nominal types, we are not screwed. Nominal types is a backup plan. JVM has nominal type, it works. Having a backup plan is valuable. If they are implemented in the same system, we can do side-by-side comparison, whether in V8 or ref interp, makes our arguments empirical. Write a wat can run them to see perf difference. One implication of using nominal types is that we can get rid of RTT and make it implicit, you can test that, implement in V8, and measure it.

AR: More like an orthogonal thing, RTT is for forward compatibility with adding generics in a way that doesn’t suck

BT: if someone proposes that nominal types can be better for a reason, onus on them to show so. This requires work to prove that what is proposed is actually better.

BT: We shouldn’t commit to a particular approach, we should implement the union, and everyone should be opk with whatever the empirical evaluation comes up with. I don’t think all of those outcomes are equally likely, if we can evaluate that in an objective way that gives us a way forward. We have to face up to the fact that people will generate code for this - if it turns out that some producers work better with nominal types, to be honest about how usable it is, we have to implement it. “Pay as you go” requirement, we can evaluate this. We can’t do that if are not able to implement nominal types, I have a view, but we must do due diligence.

FM: agree that having implementations changes the conversation, however it costs money to develop these proposals, a nominal type system. If talking about V8, it’s a disproportionate burden on Google. If we can do this on a lighter weight implementation, it will be easier for people to develop alternatives, and maybe easier to compare and contrast. Signal from changing reference interp might not be accurate.

BT: agree it is work, compared to the work that might occur if we don’t have that, the mental effort arguing about things that can't reach resolution, is an opportunity cost. Jakob probably implemented most of this.

AK: JK mic is not working

DE: excited about V8’s implementation, agree that unfair if all the burden went to Google. Igalia working on doing what it can, this is mostly in terms of related proposals, like typed func refs or exception handling. Want to raise attention to JS API. V8 team presented interesting approach to Wasm GC JS API, nominal v.s. Strutural questions has implication for the form of this API. In particular the V8 team used RTT for this, maybe types can be used, maybe it affects previous point about what’s in custom section v.s. Instruction. Will be good to collectively marshall resources to prototype or design different approaches to JS API, to enable usage without as many expensive wrappers, to see how nominal v.s. Structural affects all that.

JK: We have not implemented everything yet, don’t have full implementation of structural types, have not done the work for iso recursive types, relying on binaryen for nominal types, willing to implement more as long as it’s reasonable.

RT: a lot of stuff has been at the validation level, doesn’t affect the runtime or GC besides things like RTT possibly. Will reduce the amount that it will cost people.

KM: For some platforms, the validation is a part of the runtime, you have to validate it when you receive the data

CW: about where the engineering effort goes, if nominal v.s. Structural is just validation then no need to do 2 end-to-end. STrongly second BT’s point, however much time we spend prototype, we will waste less time than years of discussion with nothing to show.

<KM agrees>

AR: One question is how do you want to evaluate them? Outcome: Java implementation is ncier/faster, but ignores other sets of use cases. How much onus is on the people advocating for these approaches? 

BT: good question, don’t have complete answer. Still a bit of disagreement about the requirements as stated. Will need to discuss what is a fair evaluation. What J2CL team is doing, their feedback is something we should account for. Not something we can just write our own programs and benchmarks. Requires interfacing with groups trying to use this.

RT: We had someone working on targeting ocaml. Haven’t seen them for some time, same with haskell

AK: part of prototyping is to figure out the criteria. Requirements around performing better than JS, validation mentioned by KM as something we care about. In general, performance is what is important for MVP.

AR: performance of what? In early days of Wasm, a strong C++ bias on the group. We were fairly successful not baking in too much or any C++ bias. Currently see a heavy Java bias, probably a greater risk than earlier. My question is how to avoid falling into that trap, and building something that is essentially a Java type system that only serves Java well. We need a good answer to this beforehand before we do all the work experimenting, then disagree on evaluation.

CW: That’s too high a bar to start experimentation 

BT: the languages that really want to come to Wasm GC are all Java like, we designed structural type system that we believe is more general, maybe it is not even needed. Realistically, we have to look at use cases that are coming and design for that. If we implement a nominal types thing, then we can say we try to implement things for Java well.

AR: how to avoid falling into Java trap, at its heart it is a dynamic language. Might be tempted to take shortcuts that only work for Java.

BT: Not sure I agree that Java is as dynamic as you think, different conversation. How do we evaluate it? 

FM: our true competition is JS, someone has to implement the X to Wasm compiler, probably also has a to JS compiler. If Wasm is slower than JS, Wasm won’t win.

CW: IT would be horrifying if some version didn’t beat JS or OCaml for example

FM: ideally for all languages that need garbage collection

AK: some interest in this approach, and requirements for how to measure this.

BT: have discussion on issue, people can weigh in, next meeting we can have a poll.

TS (chat): There are a lot of functional languages for the web, compiling to JavaScript. PureScript, Elm, Gleam. Maybe ask in those communities?

CW (chat):I think as a compilation target, it makes sense to think of it as a competitor, somewhat separate to smoothness of interop

DE (chat): Yes, that's a good case to validate this approach: those will only work well if the Wasm GC/JS API works well
"
main/2021/CG-08-03.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 3rd video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: August 3rd, 4pm-5pm UTC (August 3rd, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Update on JS API for Stack Switching (Ross/Luke/Francis) [10 mins]
        1. Poll for phase 1?
    1. Summary of [interface-types/#135](https://github.com/WebAssembly/interface-types/issues/135) ([slides](https://docs.google.com/presentation/d/1qVbBsDFmremBGVKiOAzRk7svjinNq6LXfJ1DzeFwKtc)) and discussion.
    2. [Discussion of concerns](https://github.com/WebAssembly/interface-types/issues/135#issuecomment-888878363) by W/UTF-16 languages (possibly including one concrete [suggestion](https://github.com/WebAssembly/interface-types/issues/135#issuecomment-889502869))
    4. Poll for supporting [UTF-16](https://github.com/WebAssembly/interface-types/issues/136#issuecomment-861799460) lifting and lowering
    5. Poll for maintaining single list-of-USV `string` type
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees

- Thomas Lively
- Derek Schuff
- Nick Fitzgerald
- Jacob Mischka
- Wouter van Oortmerssen
- Igor Laevsky
- Francis McCabe
- Yamamoto Yuji
- Dan Gohman
- Garret Gu
- Zalim Bashorov
- Luke Wagner
- Thomas Traenkler
- Rick Battagline
- Andrew Brown
- Ross Tate
- Willem Wyndham
- Bailey Hayes
- Lars Hansen
- Chris Fallin
- Pat Hickey
- Francis McCabe
- Conrad Watt
- Ben Titzer
- Alex Crichton
- Lin Clark
- Paolo Severini
- Zhi An Ng
- Deepti Gandluri
- Jay Phelps
- Yury Delendik
- Sven Sauleau
- Ryan Hunt
- Till Schneidereit
- Sergey Rubanov
- Yuri Iozzelli
- Alon Zakai
- Slava Kuzmich
- Daniel Ehrenberg
- Peter Huene
- Arun Purushan
- Sean Jensen-Grey
- Daniel Wirtz
- Jacob Abraham
- Connor Hicks
- Adam Klein
- Saul Cabrera
- Radu Matei
- Mingqiu Sun
- Andreas Rossberg
- Jakob Kummerow
- Aaron Turner
- Piotr Sikora
- Domenic Denicola
- Keith Miller
- Vivek Sekhar
- Johnnie Birch
- Heejin Ahn
- Pat Hickey
- Anne van Kesteren
- Michał Kawalec
- Amin Yahyaabadi
- Dan Gohman
- Oscar Spencer
- Jairus Tanaka
- Jay Phelps
- Joe Pea

### Discussions

#### Update on JS API for Stack Switching (Ross/Luke/Francis) [10 mins]

Design issue [link](https://github.com/WebAssembly/design/issues/1425)

CW: No questions, looks cool.

RT: Process wise, we did something different. Iterated between a handful of people and ran ideas by the stack subgroup. Result incorporates a lot of ideas and iteration but is nice and simple.

DS: Seems non contentious, let’s do a consensus poll. Any objections to moving this to phase 1?

<No objections>

DS: Poll passes, will create a repo for this. 

#### Interface types discussion

<LW Presenting, [slides](https://docs.google.com/presentation/d/1qVbBsDFmremBGVKiOAzRk7svjinNq6LXfJ1DzeFwKtc)>

DE (chat): Also Factor uses a list of code points!

DD (chat): LE or BE or both? (about UTF-16)

CW (chat): just LE, same as Wasm

LW: just LE

BT (chat): Just to clarify: the binary format of modules has chosen UTF-8 for import and export names. We are not talking about changing that, correct? Just runtime strings in interface types?

LW: correct, import names unchanged

RB (chat): Isn't the UTF-8 replacement character multiple bytes?  How does that work?

CW (chat): There’s a copy anyway when sanitising, and the updated length is transmitted along with the string

LW: UTF-8 is multi-byte, the replacement character turns into multiple bytes in encoding, that’s expected

RT: Guessing a related question is whether the number of bytes is different from the original one with invalid characters, the length is different?

RB (chat): So the replacement string could be longer than the original?

LW: yea, that’s possible

CW: in Interface Types, the updated length is translated along with the string

LW: in general with transcoding you expect the length to change, this (replacement) is an instance of that. In general, we don’t know the length up front.

RT: Using the replacement path, you can’t use it if you don’t know the length upfront

LW: common case can be there is a single malloc of the right size, general case there is a realloc to account for different lengths, when going from UTF-8 to UTF-16, malloc first, then realloc, can be specified precisely in canonical abi.

KM (chat): Do these strings live in linear memory or in “host” memory?

DS: linear memory, communication between Wasm modules

LW: In the future when we have GC memory, that can be another option, but right now they will only live in linear memory.

DW (chat): Is Swift really UTF-8? It uses breadcrumbs (incl. many encodings), and would naturally end up with WTF-8 underneath.

AvK (chat): https://swift.org/blog/utf8-string/ suggests so. “Swift 5, like Rust, performs encoding validation once on creation, when it is far more efficient to do so. NSStrings, which are lazily bridged (zero-copy) into Swift and use UTF-16, may contain invalid content (i.e. isolated surrogates). As in Swift 4.2, these are lazily validated when read from.”

DW (chat): Yeah, wasn't able to figure this out as it only speaks about UTF-8

DW (chat): Does it replace lazily?

DW (chat): I don't think that the requirements for HTTP APIs are applicable here. When operating synchronously, these languages try to preserve integrity.

KM (chat): It looks like the possible encodings are exposed as part of the string ABI for Swift: https://forums.swift.org/t/piercing-the-string-veil/21700

DW (chat): But wouldn't the Component Model Scope unnecessarily disallow a language like AssemblyScript, that is deliberately like JavaScript to aid interop, to exchange its strings unchanged?

ZN (chat): ​​if you have a second string type, won't there be a signature mismatch? (when a component not using Wobbly is linked with a component using Wobbly)

CW (chat): that would be the “link-time error” scenario Luke mentioned - the other option would be implicit casts

DW (chat): We could make linking domstring to usvstring a warning falling back to replacement, if there are concerns about erroring. I think people would be fine with that. 

DW(chat): Isn't AssemblyScript <-> JavaScript a real world use case?

AvK (chat): It is a use case, but it doesn’t necessitate unpaired surrogates to be successful.

DD (chat): The ""use your own internal ABI inside your component"" slide gave one example of how

DW (chat): But isn't that unnecessary and could be easily supported?

KM (chat): Do we have any data about how much overhead copying strings eagerly has? Vs the “lazy” JS approach due to immutability

NF (chat): I don't personally have data, but it seems irrelevant to me bc the lazy approach is unavailable for wasm because linear memory is mutable, unlike js strings

TS (chat): we can't do lazy copying anyway, at least in cases where one side uses linear memory

DW (chat): It sounds like we cannot guarantee that unpaired surrogates don't lead to problems. Why are we voting on having a ""single"" list-of-USV abstraction? Wouldn't we have a separate poll anyhow?

KM (chat): Well, in theory we could have something like a primitive “gc” type for strings. Since you can’t have cycles it doesn’t actually have to be garbage collected e.g. you could use ref counting.

<LW is finished presenting. DS summarizing questions in chat>

DS: There is a summary of concerns here (https://github.com/WebAssembly/interface-types/issues/135#issuecomment-890743678) Would anyone like to elaborate on those points, or talk more about this?

DW (chat): I would like to make a case for a separate domstring :)

DW (chat): Yeah, my microphone is broken somehow, really bad timing :(

DS: DW asks in chat “Why are we voting on having a ""single"" list-of-USV abstraction? Wouldn't we have a separate poll anyhow?”. The “single abstraction"" poll is to start with a single type, in the IT MVP. The thing we are trying to do with separate polls is to ask the community for a signal. Anything can be added later, particularly if we get real-world experience. 

DW (chat): I can also offer to do some of the legwork for domstring if there is interest.

CW (chat): There is interest, although most naturally at a different layer of abstraction from the general component model

TS: sounds like we cannot guarantee that unpaired surrogates don’t lead to problems. We rarely can guarantee something on the Web Platform. Any addition of a builtin method can cause problems. Always possible to demonstrate a piece of code that can be broken if it was in the wild. That cannot be the bar. The bar is: does it cause problems in practice to a large amount of existing content. That is what the standardization body has to figure out. LW expressed this well in talking through the existence of more than one toolchain having the exact proposed semantics here, and not encounter security bugs, whereas we do have security bugs caused by not sanitizing strings. That clears the bar for MVP, practically it is not a problem we need to address right now.

AvK(in chat): Can you type out why we couldn’t do domstring later if needed?

DW (chat): In web standardization there is WebIDL, though, which has both DOMString and USVString for reasons I believe

DW (chat) I think that is a good bar

DD (chat): Reasons which don't apply to wasm, as explained in the presentation.

TT (chat): i think my main question is are interface types string types constrained to USV only at the component boundary, or would we also be constrained to USV inside of components

DW (chat): I also had a code example in my presentation to show what can go wrong, and will likely go wrong on Web scale :)
CW (chat): Definitely only at the component boundary

NF (chat): Thomas, Luke's slides had examples of custom ABIs within a component, eg C family or Ocaml or JVM

TT (chat): so would it be possible to annotate string semantics with IT inside of components?

DW (chat): I think there are many examples of practical errors, for example the JSON proposal linked fixes a roundtrip bug

TT (chat): or just with shared everything?

CW (chat): You could choose to stick to the constraints of IT even within a component

AvK (chat): Yeah, Web IDL’s DOMString is primarily about it targeting JS, doesn’t really apply to cross-lang interop.

CW (chat): But it wouldn’t be necessary

<DS summarizing questions in chat>

RT (chat): how well does a utf-8 copy-and-validate written in wasm perform relative to bulk copy?

DW (chat): My general concern is that disallowing WTF-16 languages (Java, C#, JS, AS by extension, Dart, who cannot really change) to exchange their idomatic strings is not only unnecessary, but can (and most likely will) lead to all sorts of issues, as many issues show. I suggest to allow these languages to exchange their idomatic strings unchanged with each other (while keeping everything else as suggested), one way (integrated into string) or another (separate domstring), so these languages can use this string both internally and externally (like UTF-8 languages can do with string), and the Web embedding can use it as well without risking breakage. We could also make linking domstring to string a link-time warning for the developer for good measure.

TS (chat): it doesn't have to be written in wasm: the runtime would do the validation

DS: One thing to note about the polls: The details of what it means to support UTF-16 changes depending on whether we choose to support only USV-strings or not.

AR: wouldn’t it make more sense to switch the polls around then?

DS: we had some discussion about that in agenda doc, i’m not inclined to do that right now, polls we had in the past have often have similar issues, the exact details of the spec or implementation is determined after the meeting.

KM (chat): @Ross Tate That also seems like a question that can be answered during the MVP. If we have problems with copying then it’s likely any copying will be prohibitive.

DaG (chat): warning vs. error doesn't significantly change the outcomes; either developers will avoid components which cause warnings (fragmentation) or use toolchains which introduce the coersions

BT (chat): I think we should move forward with the poll

NF (chat): does the fetch API, which uses usv string, disallow WTF-16 languages? clearly not

DW (chat): It's really sad I cannot give my presentation :)

DW (chat): I hope everyone has seen the slides, I think this is important

DD (chat): I think everything was addressed in the presentation; moving forward with the poll makes a lot of sense to me.

DW (chat): :(

ZB (chat): For lans like Java, AS & co it would be nice to have built in string, but probably it’s something separate

DG: DW has concern about WTF-16 languages in chat, the presentation doesn’t disallow WTF languages, maybe LW can chime in to address the concerns again.

RT: LW made an argument for semantics, we can have USV as semantics as a start, add more as needed. What are the overhead for adding encoding validation when copying, could be multiple times?

LW: As KM said in the chat, this is something we can profile, and learn from languages in the wild. 

TL: this is open to be revisited once we have users, real applications using this, then we can empirically see that validation is a problem or not. We can revisit as needed.

RT: Sounds good

DS: Agree with TL, one principle used in the past to revisit decisions is when assumptions that don’t hold or we get new information

**POLL**: Poll for supporting [UTF-16](https://github.com/WebAssembly/interface-types/issues/136#issuecomment-861799460) lifting and lowering

|SF|F|N|A|SA|
|--|-|-|-|--|
|29|15|6|2|0|

DS: AR, WO are the “against” votes:  anything you want to note, especially that is not already a part of the presentation?

AR: the desire for UTF-16 lowering based on various assumptions about what implementations do, which are probably not what modern implementations do. Think that we don’t have data to decide if it is a valuable optimization.

DD (chat): Fair point, that downgrades me from F to N. (Not that matters much I imagine?)

AvK (chat): (I was also wondering in what way the outcome influences things.)

**POLL**: Poll for maintaining single list-of-USV `string` type

|SF|F|N|A|SA|
|--|-|-|-|--|
|31|8|6|0|2|

DS: dcode, Joe, anything you would like to say?

JP: This could be a hit for JS, maybe we could provide the fastest path possible for JS? Possibly valuable to have more discussions.

DW (chat): This is really bad for AssemblyScript, for the reasons I have presented. Killed by specification. Congrats.

CW (chat): Disagree, especially considering AS accidentally implemented sanitisation already.

DW (chat): Nonsense!

DD (chat) I guess AssemblyScript was dead from September 2020 through June 2021…

DW (chat): Just add a domstring, doesn't harm what's anticipated :(

JP (chat): Please don't use that argument Conrad: if someone already accidentally crashed without a seatbelt, should cars not have seat belts? Hence it is not a great argument.

DW (chat): (lol @Domenic)

DW (chat): Logically invalid. Fallacy.
AT (chat): I think we can encourage a positive tone @dcode @Joe :)

DW (chat): I think positive tone is over.

ZB (chat): For langs like Java, AS & co it would be nice to have built-in string or other ways to have fast/cheap interop with browser API, but probably it’s something separate.

AT (chat): We can figure thigns out back in the AS side of things :)

DW (chat): This is not what the spec is supposed to do.

DW (chat): I could not disagree more with this.

JP (chat): I think both sides are being disrespectful, regardless of the outcome.

DW (chat): You should account for concerns by implementers, not this.

JP (chat): If language match with each other (f.e. JS + AS) why not have the best interface?
Java + C#, Java + JS, etc.

DD (chat): They can use one-off interfaces, but the purpose of standard interop is... standard interop.

JP (chat): Will we want to make separate specs for new interfaces? Seems like more work, and not guaranteed

KM: given the strings have to be copied, the transformation makes more sense. You can choose your behavior as a consumer. You can come back in the future and say, and hope doesn’t preclude data coming back that says some applications have problems under the sanitization world, and reconsider. But at this time it seems reasonable to start here.

TT: I've tried to find a middle ground between both sides. I wonder if it’s possible that inside of a component to have additional interface types that are not language agnostic but can take into account shared encodings between modules.

### Closure
"
wasi/2023/WASI-07-27.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: July 27 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: July 27, 16:00-17:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Dan Gohman: Rebase the Phase Process description on the CG's current
       process (https://github.com/WebAssembly/WASI/pull/549)
    1. Dan Gohman: Preview 2 definition plan (https://github.com/WebAssembly/WASI/pull/550)
    1. Marcin Kolny: The future of WASI threads proposal (https://github.com/WebAssembly/wasi-threads/issues/48)

## Notes

### Attendees

- Bailey Hayes
- Pat Hickey
- Luke Wagner
- Dan Gohman
- Colin Murphy
- Ben Green
- Macin Kolny
- Conrad Watt
- Deepti
- Kate Goldenring
- Andrew Brown
- Jeff Charles
- Kyle Brown
- Yong He
- Mingqiu Sun
- Julien Fabre
- Wilson Wang
- Jamey Sharp
- Kevin Moore
- Joel Dice
- Timmy Silesmo
- Hung-Ying Tai
- Zalim Bashorov
- Sam Clegg
- Thomas Tränkler
- Chris Woods
- Ken Brooks

#### Phase Process

Will end at 45 minutes after

**Dan Gohman**: Set the stage for what is happening here. Preview 2 has been progress for a long time at this point. Handles and resources are one of the last really big pieces. We will very soon have the pieces in place to start building things and using them in real settings.
 
Previous presentation we talked about the difference between preview 2 and 3 (async).

What does it mean to be in preview 2 and how do we know when preview 2 is ready to “launch”.

WebAssembly/WASI#549

Brief background, this is the CONTRIBUTING.md. 

In the core CG version of this, this is a separate document. The WASI subgroup has a side-version of the CG process. The core CG has updated their phase process since the last time WASI was copied off. Updating WASI now in the same way CG updated.

Phase 0: someone has an idea. No vote required. Intentionally very easy to achieve. Identify champions and the people responsible for moving the proposal through stages. Decide if things are in scope.

Phase 1: To enter this phase, SG determines if this is in-scope.

Note that this document should be talking about the subgroup (SG) and not the community group (CG).

To enter phase 2, we must establish portability. Champions define the acceptance criteria for Phase 4. Phase 4 is effectively standardization. WASI in particular is looking at things that are not browsers and so it makes sense that its not tied to 2 or more web VMs. 

Additionally it should establish consensus - this is a feature we believe should be standardized.

WIT description is defined to enter phase 2.

Phase 2: Implementations proceed through prototypes.

Phase 3: Feature is expected to be fairly stable at this point. Preview 2 will be proposals that have reached phase 3. Not quite a standard but pretty close to being stable.

At this point in time, Preview 2 is the closest we’ve come to define a standard out of the subgroup. At this point in time we are in this “preview” phase. 

Updating the text to have the same structure as the CG phases.

#### Preview 2 Definition Plan

**Dan Gohman**: WebAssembly/WASI#550

This will become the document that defines what preview 2 is. First thing in this document is the Launch criteria AKA how do we know when this is done? Let’s talk about this instead in how a window is opened.

Preview 2 will be considered launched once preview 2 has two worlds advanced to phase 3.

We will live this window open until we wind down preview 2 for preview 3.

We want to be able to show that we have at least two different worlds. This is important to show that WASI is about more than just POSIX. Are all the engines expected to implement all of the APIs? The vision for worlds is that not all engines will have to implement all of these worlds. Some engines may implement all of the worlds, but they would not be required to.

Side note: the two proposals that are the furthest along are WASI CLI and WASI HTTP Proxy worlds. Those are the furthest along but it’s not specifically defined as being those two. The only requirement is that it’s at least two worlds.

WASI Preview 2 Contents is a table that currently contains no elements. As proposals reach phase 3, then we will add them to the table.

This will be as official as a markdown document in GitHub can be in that it’s not an official standard but a statement of stability.

What does it mean to be part of this list? Reach phase 3, as I talked about in the previous agenda item. It must satisfy its own phase 4 acceptance criteria. Phase 4 in the core CG is effectively standardization. We are holding off on that for now, so we are defining a preview and creating a place to grow and evolve things.

In order to define the contents of Preview 2, it must be voted for inclusion by the WASI Subgroup.

Proposals may be added to WASI Preview 2 at any time until Preview 3.
Any questions?

**Conrad Watt**: It has to be virtualizable using a component. 

**Dan Gohman**: We require that all APIs are defined in WIT. There is a possibility that APIs could be awkward to virtualize, but by requiring things be expressed in WIT then we know that everything can be virtualized. 

**Dan Gohman**: I looked around and I found this unofficial rule that when something is posted we wait a week to vote on these things. We are not going to vote now, but we will vote on this process change next week. 2 weeks from now.

**Pat Hickey**: I put this on the agenda.

**Dan Gohman**: Should we document this 1 week wait before an agenda?

**Conrad Watts**: Up to the subgroup on rules. CG follows one day beforehand for a poll. 

**Deepti**: Just 24 hours before in CG.

 **Pat Hickey**: OK then we can follow this in the future but not change for this vote.


**Conrad Watt**: Your point about WIT IDL can be subtly be virtualized. The question of a side-effects of the virtual machine state.

**Dan Gohman**: Today, most modules define and export a linear memory. In wasi-threads, all of the threads have their own module that imports the linear memory. That is a construct that is not possible to represent in WIT.

**Luke Wagner**: In theory you could have a u32 that the host could modify. That’s not readily virtualizable so we wouldn’t want this API. 

**Pat Hickey**: Modules are a core webassmebly unit. There is no concept of exporting a memory from a component. WIT is the interface definition, then you have to implement it in terms of a component. A WIT IDL doesn’t express anything in terms of a core module. The only thing that exists in a module is the canonical ABI.

**Conrad Watt**:The point is that you would want something expressed in the IDL that would express exchanging memory which you cannot do.

**Andrew Brown**: WIT will not be able to express transferring funcrefs across any interfaces.
**Dan Gohman**: There is no funcref type in WIT. The preview 3 plan with async streams and futures. It looks a lot like a callback system with funcrefs. We can do different kinds of control with futures and streams.

**Andrew Brown**: I was thinking of a way to pass in spawn for threads in a way that a funcref is passed in the Core Wasm Threads proposal.

**Pat Hickey**: We’re jumping the gun on threads. Do we have any non-threads questions? Before moving to the next item.

#### The future of WASI threads proposal

**Marcin Kolny**: What should we do about wasi-threads?

The proposal essentially targets a WASI interface to spawn a new thread. The new instance has a copy of its own copies of globals and tables. The only thing that is shared is the memory. This proposal was started over a year ago. Quite a lot of work was done as part of this proposals. Progress has been made across toolchains. There is a PR to enable wasi-threads in rust std. We have places with support in wasmtime, WAMR, and others. 

There is another proposal for having threads as a core wasm feature. I think the wasi-threads proposal will be replaced by the core proposal. 

It may be worth discussing if we need to make any changes before freezing the proposal. 

We perhaps could somehow backport it to WASI Preview 1. There are some complications already discussed in this meeting. 

Technically the only reasonable way to do this is to backport it to wasi Preview 1. It’s already public and part of the toolchains. Part of wasi-libc but not formally part of preview 1.

We should have information and recommendations for how to move to the new Wasm Threads proposal. 

We risk fragmentation of the community if we completely abandon wasi-threads. I am not completely convinced that we should totally wasi-threads.

We should acknowledge that it is already in use and many people already rely on it.

In my case, we ship products in which the runtime can not readily be updated. We need to ensure that the binaries that run on top of that runtime will be able to run on it. We need to find a way to use the latest toolchain and still be able to run older hosts that support wasi-threads. First of all, I really want to know everyone’s opinion on that. On not moving the proposal further. 
In the future, if there are binaries that support this new core proposal, there might be a way to rewrite those binaries in terms of wasi-threads.

One option: maintain the toolchain so that it can work in two modes. One for wasi-threads and one for the new core threads.

Concerns: Not concerned about resourcing because my org will be able to fund this effort. The primary concern is that no one here can guarantee that we won’t want this legacy path.

We will not be able to fork LLVM and provide patches if it is decided in the future to no longer support this path.

Second option: In the binary translated path, we can replace some instructions and magic on the binary to make it compatible with wasi-threads. The primary concern here is that it’s not possible. After brainstorming, we pretty sure this path will work, but no one can guarantee that.

There will always be a risk. 

**Conrad Watt**: One thing that the new proposal will not give you is that the new proposal will not give you at runtime spawn.

**Luke Wagner**: The idea is that you would rewrite if you see a global then use a library. 

**Marcin**: Complex to implement that. But do not know if we can do that for the next 5-6 years.

**Pat Hickey**: We should keep some compatibility within wasi-libc for some amount of time but it is difficult to say how long that will be until this future proposal takes shape. It seems that it should be possible to keep this implementation working. If your team is able to keep this branch alive while newer things move forward and meet that significant amount of effort to bring them forward. 

**Pat Hickey**: These are implementations that live under the WebAssembly org that are implementations and standards. Historically there are implementations like binaryen and others that have always been in WebAssembly. Being in the WebAssembly org, wasi-libc it is in a somewhat strange commons place. We need to err on the side of keeping these implementations in until whatever replaces it is sufficiently stable. That could be time for implementing option 1 or 2. 

**Marcin**: I think that makes sense. One of the concerns that I have is that is it only in wasi-libc or in LLVM or other projects like LLVM where this could happen in other projects.

**Dan Gohman**: LLVM doesn’t know about the spawn side of this. It seems like LLVM should be relatively safe here but I can’t give guarantees. LLVM would need to know about thread local storage. 
**Sam**: I hope we can tell LLVM which ABI to use. There is no reason to have it live in global memory and use something like stack pointer. Move in a direction. This new proposal is no where near phase 4. I imagine wasi-sdk will need wasi-thread path for at least 1 year.

**Marcin**: I need wasi-threads path around for 5-6 years. It looks like there are some ways. We can progress with the toolchains supporting both options. If that gets deleted then we can look for a binary rewrite. 



**Deepti**: Minor clarifying question around what Pat had said in the WebAssembly org versus the Bytecode Alliance org. If you want to respond to the concrete threading we can go ahead with that.

**Pat**: In the Bytecode Alliance, we designate maintainers and have a governance process. Do we have to put it to a vote for these contentious maintenance concerns since this is managed by the subgroup?

**Deepti**: That answers that.

**Luke Wagner**: Security disclosure process is another concern. 

**Pat Hickey**: Right, that was the original concern. When someone reported a security vuln we didn’t have a process within the WebAssembly org to handle that. 

**Conrad Watt**: This is a concern that will continue to come up in non-web embeddings. It is really common to have a MVP version of that proposal is that it is off-loaded to the host in some way. Currently we have a problem that wasi-threads has a way to create a thread in the host. In the future we think we will have native stack switch support in Wasm. Initially you are relying on some kind of web support. The general philosophy has been in non-web to wait for the Core Spec. I can understand why wasi-threads doesn’t fit around the WIT IDL clarifications for virtualization. What is the story for having that work in WASI? Do we decide that we are just not going to add support until the core spec has this support?

Here we are talking about host functions that are about somehow manipulating some part of the Wasm virtual machine. This is the general question for WASI, do we wait for core?

**Luke Wagner**: In WASI we have this concept of builtins. Initially the two builtins were lift and lower. This is where you specify the ABI details like utf-8. If we liked wasi-threads, then we could add a canon thread new. If we liked the core proposal, then we can sort of jam it in as a builtin. This is a third option compared to add it as a host function or wait for the core spec. 

Preferable to have a core instruction, but a builtin is an answer. 

**Conrad Watt**: While it might not be the ideal semantics, it is the incumbent. 

**Luke Wagner**: How do we handle concurrent components. 

**Conrad Watt**: Is it about cross-component?

**Luke Wagner**: Builtins are core to the component. Internal to the component. For core computational things like stacks, threads, grow, etc then builtins are the right place. 

**Conrad Watt**: Are builtins forever?

**Luke Wagner**: Are wasi-threads the semantics we want to keep around forever? I think if we blessed it, it would be exponentially more pain.

**Luke Wagner**: If we think about what we want, we don’t duplicate a function table.

**Conrad Watt**: I think a lot of this is going to still be done because this is how it already is implemented in JavaScript side.

**Luke Wagner**: Even the toolchains aren’t doing this quite yet. It’s really the instance per thread that is the problem.

**Andrew Brown**: What does it mean to freeze wasi-threads? I think we should discuss the stability of wasi-threads; currently it has an experimental ABI with large warnings in all the various repositories that this ABI could change in the future. If Marcin and co. start using wasi-threads, that ABI will become de facto ""frozen""--should we fix any of the problems Marcin listed before this ""freeze""?

**Pat Hickey**: We are at time so need to end the call. Please use the wasi-threads github.
"
main/2019/CG-10-01.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 1st video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: October 1st, 4pm-5pm UTC (October 1st, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. SIMD 64x2 instructions, poll for inclusion back into the spec
       (https://github.com/WebAssembly/simd/issues/101)
    1. Trapping semantics of bulk memory operations
       (https://github.com/WebAssembly/bulk-memory-operations/issues/111)
1. Closure

## Agenda items for future meetings

1. Continue discussion on Trapping semantics of bulk memory operations in a future meeting (see notes)

### Schedule constraints

*None*

## Meeting Notes

### Attendees

* Luke Wagner
* Derek Schuff
* Deepti Gandluri
* Thomas Lively
* Mingqiu Sun
* Conrad Watt
* Rick Battagline
* Alex Chricton
* TatWai Chong
* Adam Klein
* Jay Phelps
* Zhi An Ng
* Bill Ticehurst
* Alon Zakai
* Peter Jensen
* Jacob Gravelle
* Dan Gohman
* Paul Dworzanski
* Shravan Narayan
* Ms2ger
* Ross Tate
* Ryan Hunt
* Jakob Kummerow
* Francis McCabe
* Lars Hansen
* Alon Zakai
* Andreas Rossberg
* Petr Penzin

### Proposals and discussions

#### Include SIMD 64x2 instructions back into the spec (https://github.com/WebAssembly/simd/issues/101)

Zhi An Ng: We discussed adding these ops back to the spec in linked github issue.
Informal poll has had folks show interest in option 3 (f64x2 ops and common i64x2 ops).
Not sure if I should take a poll for each, or what?

DS: Does anyone want to express opinions on the options here?
... [no response]

DS: maybe it's best to make a particular recommendation if this was discussed separately.
It looks like option 3 was definitely what people wanted in the issue. So maybe we should poll for that?
 
TL we've seen benchmark numbers showing good results for most of these instructions, right?

ZN: yes

JP: it looks like there was a discussion about these ops before. Were any of the folks there also here? Why were they removed in the first place?

DG: we originally polled to remove them due to lack of benchmarks showing they were valuable. So it was uncontroversial.
Also it was in line with our originally-agreed approach to only add operations with good benchmark evidence for inclusion
Zhi's work has been to collect that info, and now we have good evidence that they perform well.

TL: what about more niche stuff like sqrt and min/max? Do we want those?

DG: you mean 64x2?

TL: yes

DG: for now we've only tried to include the ones we've seen actual usage/benefit for, but we haven't for those.


Poll:
Include in the SIMD spec all the discussed f64x2 operations, and a subset of i64x2. Specifically:
* f64x2.{splat,extract_lane,replace_lane}
* f64x2.{add,sub,mul,neg}
* f64x2.{div,sqrt}
* f64x2.{shl,shr_s,shr_u}
* f64x2.{any_true,all_true}
* f64x2.{eq,le,lt,ge,gt}
* f64x2.{abs,min,max}
* f64x2.convert_{s,u}/i64x2
* i64x2.{splat,extract_lane,replace_lane}
* i64x2.{add,sub,mul,neg}
* i64x2.{shl,shr_s,shr_u}


SF: 6
F: 5
N: 5
A: 0
SA: 0

#### Trapping semantics of bulk memory operations (https://github.com/WebAssembly/bulk-memory-operations/issues/111)

Ryan Hunt: [presenting](https://docs.google.com/presentation/d/1ceBIAXBMgIeNhPrURpnEMozkutqd1iUpyPVoE_5mAzk/edit?usp=sharing)
We've seen a performance regression since LLVM started including memory.copy instructions. 
The current Spidermonkey implementation is not very optimized, Started looking at optimizing it for this use case. 

LH: You’re giving memory.copy load multiple/store multiple semantics without specifying the semantics, and letting the wasm compiler infer

AR: if you can’t fit everything into registers you'd still have to go low-to-high?

RH: In that case, we know the length is constant, we should know as we’re compiling whether we have enough space, if we
don’t we have to fall back to the slow path which is bounds check + memmove which is as it is today. Testing is not
exhaustive, but my tests haven’t needed more space than SSE right now

PP: some platforms have hardware support for move byte, could we use those

RH: like rep movsb? I did some [benchmarking](https://docs.google.com/spreadsheets/d/1vf9EeRRi9gTc0JokKUcWwvL8wR0yKR24xL5QP4j6xbM/edit#gid=1662652199). We weren't seeing very good performance, but we might not have been doing it optimally

PP: What platform were you running on?

RH: Macbook pro x64, can copy disassembly if needed

RH: it’s public, there’s a patch on the bug

PP: I can take a look to see if I can help with anything, in theory you should be able to use byte moves, but they are not
consistent across different x64 checks, didn’t get the part about alignment hints, can you elaborate?

PP: can you elaborate on the alignment hint alternative?

RH: if the instruction had an immediate which specifies the min alignment of the src and dest, similar to current loads and
stores. We could have a branch that checks the alignment, and we could use loads and stores of that size to implement
inline. I tried and it seems ok, but if LLVM emits just 1 because its unknown, it would fall back to just a byte copy.

PP: For example, the way LLVM would give you the hint is the alignment if 4 bytes?

RH: It’s not super well formed, I don’t know how LLVM would optimize this

TL: from the toolchain, when we implemented bulk mem, we just optimized for code size, since we didn't’ have benchmark data.
We changed it back now that we have some info. The initial regression is gone now with the current trunk. So this is fixed 
in the toolchain now. SO it depends on what we think the memmove instruction is for. If it’s for constant small moves, then 
this spc change makes sense. But if that’s not what it’s for, and we shouldn’t need to optimize for this case, then there’s
not really a problem?

I'm sympathetic to making it more useful, this seems like an extra complication, and unknowns for spec work, we've already 
gone back and forth on the instruction - if we do want an extra instructions, adding it to the spec in the form of a new 
multi load/store instruction would be more appropriate.

LH: we had these semantics already, right? We changed it to the current semantics to make space for memory.map/protect/grow. 
But there is some issue about whether those are plausible. So it’s possible that the motivation that caused us to create the 
current semantics was flawed?

Initially we talked about memory.copy for large chunks of memory, and now it’s tempting to use it for smaller chunks, we should make it possible to use for smaller chunks - there seems to be no reason to change it apart from the fact that Chrome already ships it?

AR: basically this assumes that memory accessibility stays monotonic forever, right? It seems a pretty strong assumption. Given that, I’m sympathetic to Thomas’ argument, why not have a dedicated instruction?

LH: Wouldn’t a store multiple have the same type of problems in terms of monotonicity?

AR: If we are given alignment, we can specify more of the details, but in general you are right

PP: You are using a register that you could be using for anything else, maybe there could be different instructions for doing the short version…

LH: The original version was to specify a constant length, and then the page size became large, so now we have bytes … <discussion> Anyone working on a JS engine knows that people will use it and assume that it works fast


RT: one issue is that small is variable. Memcpy could have a flag to specify the checking semantics, strict vs lazy.

CW: Wouldn’t address the original issue why we include the semantics originally, the semantics will get non-deterministic if we introduce something in the future that relies on monotonicity

RT: non-monotonicity means you’d revoke/protect memory in the future?

CW: right. So it would be nondeterministic what gets written in that case where a write races with a protect

AR: That’s alsos semantics we could introduce now, but that seems not particularly attractive, trapping in-between a memory.copy/fill right now is undefined because the order is not defined

RT: this is only when we have parallelism and nondeterminism anyway?
CW: right, this in the presence of shrink or protect racing with a copy

RT: Shrink/Protect in parallel with this operation?
<Agreement>

AR: What about alignment hints? 
RH: It would need to be used
TL: When LLVM emits small constant size loads, it does have alignment info, or we could easily get it

AR: We can always modify the proposal to add alignment hints right now, how hard would that be? 

AZ: there’s a benchmark with inline/align guard. Could you do the check differently <e.g. separate the OOB from alignment?>

LH: Tried coming up with a good code sequence for that, it’s been difficult, there’s source, and destination alignments… it wasn’t obvious how to do that correctly, feedback welcome?

AZ: why does the alignment matter, compared to checking just OOB?

RH: if you know the alignment is 4 and you write 4 at a time, you won’t do a partial write, you'll do full-size writes up to the bound.

AZ: You would have a check inline, saying I’m doing a copy from x - x+ k, do a check if x+k is in bounds, if it’s out of bounds we can go into the case that handles all the things? Another way to phrase it is whether it’s going to trap, or whether it’s aligned? They seem different enough to handle separately? Why do they need to be intertwined?

CW: fundamentally if you had that fast path, if we end up implementing protect, that wouldn’t satisfy the byte-by-byte semantics anyway. So maybe this idea of byte-by-byte wouldn’t really help and we should have nondeterminism anyway?

AR: I have the same question as Alon, the proposal is to add for add bounds checks before the operation, why can’t we add that in the user space? 

CW: Having explicit memory.length semantics will be expensive

AR: sorry the engine could implement that as the fast path

LH: Several constraints, minimize code size, alignment requirements, other constraints as well, so it’s hard to handle the combination of all these..

AR: Still don’t understand why alignment, or out of bounds matters


If you know you can do multibyte copies, and the alignment is right, it’s still faster

AR: for the OOB thing that seems to be unrelated to alignment. If you check OOB, then why do you still care about alignment?

LH:  Suppose your destination pointer is not aligned,  you will hit the end of memory before you write, you do the fast path in line, in response to Alon, when implementing it I found it to be a very complicated check for something that was only copying a few bytes

AR: I don't understand why it's more than 1 branch?

LH: we should take it offline, it's hard to discuss details without the code in front of me.

CW: even if you successfully did that, if we were to have memory protect later, you wouldn't conform. So maybe the byte-by-byte wasn't a good idea.

AR: The only answer would be completely non-deterministic?

CW:  Correct, that’s just what we have to Spec

AR: why would you bound-check in the beginning, in that case?

CW: in the usual case, then nothing changes and we have determinism, only in races would there be nondeterminism.


AR: All  options seem fairly unpleasant, I would punt to saying this is a toolchain issue - take LH’s point that this will just be an engine race

RT: can we discuss this offline on an issue?

PP: we should, it's hard to discuss these details in a meeting.

RH: Posted the github issue in the chat, it’s in the agenda, will link the benchmark, and the SpiderMonkey patch in the issue

AR: what is the sentiment… what’s the promise that C compilers have? Do they promise that it’s always fast?


PP: Not necessarily, it’s expected to be a call to a library routine

AR: Many compilers inline that check

DS: C compilers freely turn load/stores into memcpy and back, will do it if it thinks it will make it fast

PP: right, hw doesn’t have a bulk memory store. If you’re copying values that can be a register, that should become load/store.

LH: One point I made a couple of times, memory.copy is not memcpy, the semantics that the C compiler expects are not mapped to memcpy, it’s memmove + extra overhead, so the name is confusing

PP: yeah it's definitely true that it's not like anything in native

TL: the current state is that i reverted LLVM’s change to always use memory.copy. But when bulk memory is enabled, it uses memory.move anywhere there’s a memcpy intrinsic (e.g. if the user writes it or if the compiler detects it). But as lars said that’s technically different semantics than memcpy. So can the instruction be at least as fast as a wasm implementation of memcpy? Because that’s what it’s really replacing. So is that a good choice?

LH: Except for the very smallest sizes, yes.

RH: I'd guess yes, ive not done benchmarking in unrolled wasm load/store vs memory.copy. We still have some low-hanging fruit to optimized though.

TL: If this gets really complicated, we have the fallback of saying this is a tools problem,  and we can solve it

DS: We don’t want to be in a bad situation where the LLVM toolchain is generating a bunch of wasm code, but engines are under pressure to optimize it anyway because of other toolchains.

AR: we should at least document what the expected use is.

TL: If we have dozens of implementations, then we can add a note to say don’t use it

LH it would still be nice to pick the best semantics we can for our constraints. So if the current semantics don’t help the memory.protect case and the old ones are still better for the cases we want, we should still consider changing

CW: Starting to think this as well

TL: Fine with me

DS: It sounds like that folks would continue to discuss this offline, should we bring it back if there’s more progress offline? 

LH: Only concern I have is that Chrome has already shipped this, how long before it becomes a problem? 

DS: The only problem is when you are trapping - when you are importing/exporting the memory and you trap (and then later read the memory e.g. from JS), that’s when this would come into  the picture. Emscripten does technically support this, but seems like a niche use case. It’s definitely UB for C,  it seems to be only a thing if you compile with a language that has more well defined semantics on top of LLVM, so not super concerned, does anyone else see other concerns?

AR: Meta concern of why have you shipped this already when this hasn’t been fully specified, seems against the process? 

DS: It’s never happened outside of the threads proposal, (and bulk memory was pulled out of the threads proposal); without bulk memory you don’t have conditional segment initialization, so it made toolchain support problematic.

AK: We don’t want to be shipping things at the stage, but history of threads, and SABs has been complicated, I don’t think the intent to do this in general.

DS: One other general comment, we want to keep the door open to refine the proposal based on memory model changes;  if we don’t say something in the spec about the map/protect/shrink idea, embedders will do it anyway via APIs, possibly in different or incompatible ways. I would prefer that we have non-determinism of the same type as the one we have for threads, compared to giving up on that completely.

AR: You make a good point that embedders will invent a way to do that anyway, very concretely this has been suggested in my company that we should have something like memory.shrink to reduce memory usage, but this would break compilers if they hoist out bounds checks etc. ?If the embedders start inventing stuff, it will be incompatible.. I would rather anticipate the possibility of features like this, just the fact that embedders might like to invent something is already at risk.. We should proactively handle that

DS: we are out of time. We can continue discussing the specifics on https://github.com/WebAssembly/bulk-memory-operations/issues/111 and bring this back to a future meeting.

"
main/2023/CG-09-26.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 26th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: September 26th, 4pm-5pm UTC (September 26th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Flexible vectors, announcement: add Tal Garfienkel as proposal co-champion
       [5 min]
    1. Exception handling: Potential discussions about the upcoming vote
       [15 min]
    1. Profiles discussion (rescheduled from 06/20/2023) [30 mins]
        1. Poll: Deterministic mode will be defined in the profiles proposal
        1. Poll: Phase 4 for Relaxed SIMD 
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
 - Conrad Watt
 - Deepti Gandluri
 - Derek Schuff
 - Andrew Brown
 - Adam Klein
 - Alex Crichton
 - Alon Zakai
 - Andreas Rossberg
 - Antoni Bofarull
 - Ashley Nelson
 - Bailey Hayes
 - Ben Visness
 - Benjamin Titzer
 - Chris Fallin
 - Chris Woods
 - Daniel Hillerström
 - Nick Fitzgerald
 - Francis McCabe
 - Gordon Aplin
 - Heejin Ahn
 - Ilya  Rezvov
 - Jeff Charles
 - Johnnie Birch
 - Kartikey Rawat
 - Luke Wagner
 - Marat Duhkan
 - Matthew Yacobucci
 - Mike Smith
 - Mingqui Sun
 - Paolo Severini
 - Petr Penzin
 - Ryan Hunt
 - Saul Cabrera
 - Sam Clegg
 - Sergey Rubanov
 - Tal Garfinkel
 - Usuario de Zoom
 - Yuri Iozelli
 - Yury Delendik
 - Brendan Dahl
 - Dan Gohman
 - Richard Winterton
 - Nick Ruff
 - Dan Srebnik
 - Keith Winstein
 - Kartikey Rawat
 - 
### Discussion

#### Flexible vectors, announcement: add Tal Garfienkel as proposal co-champion


#### Exception handling: Potential discussions about the upcoming vote

HA presenting [slides](presentations/2023-9-26-ahn-eh-instruction-format.pdf)

This format was posted on GH about a month ago (https://github.com/WebAssembly/exception-handling/issues/281)
Would like to vote on whether to go this route in October meeting

FM: one of the merits of one of the precious proposals was that you could do analysis of an exnref outside a try context. That was useful for a CPS transform where exceptions are used outside of a try/catch. Is that possible now? I.e. decompose a caught exception without throwing it

HA: What do you mean by decomposing without throwing? 

FM: If you’re doing a CPS transform, instead of using a throw instruction, you pass the exnref as an argument to another function, which can look at it. But you’re not throwing it.

CW: There are 2 different answers, if you really want to use exnref, you can try to rethrow it in the catch block immediately after the exception, the other option is to have the toolchain say that it doesn’t handle exnref directly, but needs a wrapper

FM: I’d be forced to use the first of those I think. (forced, but it wouldn’t be ideal)

BT: br_on_exn is syntactic sugar for what Conrad mentioned, we could consider that as a performance optimization, it's the same type of expressiveness, but better for performance

HA: in case it wasn’t clear, this try/catch block extracts the exception. In case there’s a tag match, we extract the values and the exnref (multivalue). So you get both on top of the stack at the end of the block. For catch_all we only push the exnref. 

We did consider where try block doesn’t extract and use an additional br_on_exn like construct, but found that increased code size slightly with basically the same semantics.

#### Profiles discussion (rescheduled from 06/20/2023) [30 mins]

DG: Some context: in the hybrid meeting last year, we discussed one of the prerequisites of moving relaxed SIMD to full phase 4 was a discussion about profiles. That lets you define language subsets with reduced functionality or restricted subsets, defined in a spec. Profiles have a spec and syntax, currently phase 1. I was hoping to use this time on some of the discussion that came up. A disagreement on how many profiles there should be, and some concerns about fragmentation. Also how do we add new profiles. It’s a slightly different paradigm than we have so far. Also since we took a dependency on an earlier stage proposal, and wanted to try to make sure we at least agree about the deterministic profile.

AR: clarifying that there are 2 separable things: the profiles proposal is mostly about the spec framework, a formal way to define them. But does not imply any specific use of that framework. We could have separate discussions about each profile we care about. This is about having the ability to express it. The deterministic profile is the first use case. But just defining a semantic framework doesn’t affect what the standard specifies, just mmakes it possible. So it doesn’t seem mlike a big risk as long as we’re clear that specific profiles need separate discussions. Because of that we can probably just move ahead with the profiles proposal if we wanted to get over the weird dependency situation. That’s what I would suggest. Maybe not today but maybe at the face to face meeting, move it forward (even to phase 4). Since its mostly editorial. I.e. do we want to have this ability at all in the spec, and given that we already wwant the deterministic profilek the answer seems yes.

DG: agree that we should move profiles forward. We discussed that folks just wanted soem time to look at it and figure out how they would try to incorporate it. But as AR said its really just the ability to have it in the spec. But the 2 points of disagreement came up when we discussed this before.  I’m not sure we could poll to movie profiles forward today since it wasn’t on the agend, but no objection

RH: so the profiles proposal, just add infrastructure for defining profiles, but doesn’t define specific profiles? It’s just spec machinery?

AR: as written it suggests certain proposed profiles, but we can separate out. It mentions deterministic, but has open questions for certain others

RH: just thinking about the procedure. If you wanted to advance something like that. We might want a different process since it’s infrastructure

CW: we’d want to discuss how toolchains and the ecosystems would use it tests etc

AR: we might want language about what is expected of profiles how they interact and compatibility. But it’s still case by case which ones we want to have. I would want to discuss a profile that doesn’t have GC, that seems like an obvious thing. Back when we started talking about GC there was preference expressed in the CG that GC would be optional. But that’s also a separate discussion.

AB [chat]: Has anyone looked at what it would look like to target a specific profile from the toolchains?

DS: We are already living in the world where we’re supporting multiple variants of Wasm, some of the users want to support the latest versions, we want to target arbitrary features, most fo the applications in production only want to target the lowest common denominator, the world with profile wouldn’t be very different, that we’d have a flag and the world would be any different

CW: How will runtimes that don’t target GC target exnref, we could imagine typing a no GC profile to the structure of a tag, would be more fine grained than a feature tag

AR: one other small thing to DS: the deterministic profile is an easy case because it doesn’t actually affect toolchains; it only affects engines, in that it restricts what the engine can do, i.e. what execution paths the engine can take; it doesn’t restrict producers.

CW: We have to promise that no producer to rely on it, otherwise we can be messy

AR: yeah,m we dont’ want producers to do anything special for it. So it’s not that they have to, it’s that they shoudln’t.

PP: the procedural part of moving phases, normally we have tests and implementations. Just want to understand more. Is the only thing we change that certain things become optional? 

AR: Not sure what you’re asking, but GC would be different from the deterministic profile, where it would take away some features

CW: I was interpreting it as a procedural question: how do we decide whether to add a new profile?

PP: Yes, if we define a profile that’s not in browsers, how do we standardize that?

CW: we don’t have a perfect answer for that yet

AR: In general, the way we decide this which is having a discussion, with GC, the way we make that a part of the GC proposal, but for features that have shipped where we want to introduce a profile later, that would be a feature discussion, a proposal even that goes through phases, we have to decide there has to be tools support, we have to apply our process to that as well with having tools that target that as well, with engines as well, that could be a requirement for having a switch for turning off, Our framework of profiles, 

PP: Our acceptance criteria is 2 web implementations. Are we going to relax?

CW: it’s definitely arguable, we’ll certainly need new criteria for advancing things through the process.

AR: yeah, some parts will apply and some won't. We have this already e.g. for changes that only affect the JS API, only apply to JS engines. Also the annotations proposal doesn’t affect web engines. So we already have this problem, how to deal with proposals where the 2-web-engine proposal doesn’t make sense.

DG: one thing we should do is build this into the phase 2 vote for profiles, I think this is where we’ll have the mmosmt contention. We should discuss on the repo and document it. But we want to address where we have the most design contention ,and get consensus on that first.

BT: one of the stated non-goals is versioning. I don’t disagree but lots of people, implementers, etc do care about version number. So while it’s technically orthogonal there might be interactions. So we can’t completely ignore the problem of versioning.

CW: Hope we can keep it orthogonal, there have been several feature detection proposals, don’t think we have the bandwidth to pick that up

AR: if i understand Ben correctly it’s more about structuring e.g. teh test suite in a way that you can select versions and profiles, etc
BT: also the toolchain perspective. If there’s an engine stuck at 2.0 forever, it may make sense to have the option in the toolchain

CW: Do we think we need additional spec mechanisms to make that happen?

BT: i don’t think it’s anything in the spec doc, it’s more about structuring the test suite. We have the approach that we don’t add behaviors to existing instructions. Considering that profiles is a subsetting mechanism, but we don’t want to add behavior to an existing feature that requires us to add a profile that restricts to previous behaviors.

CW: My hope is that’s not done with profiles, but we would have different opinions

PP[chat]: My second comment is on toolchain: they have to be ultimately aware of profiles, as in example already mentioned, targeting relaxed simd while assuming deterministic profile can easily break when running in non-deterministic environment. Maybe there needs to be a way to programmatically detect this.

AR: in terms of the artifacts we produce in the spec, it’s the test suite, and maybe we need a way to annotate tests with which profile or version they apply to. We have subdirectories now, but maybe if there are cross-cutting constraints, maybe we need to annotate individually. Haven’t thought it through yet.

RH: looking at the phases again: the only entry requirement that seems to apply here is mostly just consensus, that there’s a procedure that we understand and agree on. Doesn’t seem there will be spec interpreter, engine implementations, etc. so once we get consensus on the details, we can vote on whether to accept it? Doesn’t seem a lot of value in phase 2, 3, 4

CW: I wouldn’t be against a vote of supporting profiles in the web, 

RH: yeah that’s good to separate out. I would guess that the profiles proposal could specify a future process? Proposals then could specify that they introduce a new profile

DG: also wanted to mention that as part of relaxed SIMD discussion, we did have one agreement that says that we are willing to adopt profiles methodology to the spec. Didn’t seem contentious, ,we can always codify it into a poll.

AR: another way to phrase, it would be acceptable to fast–path just the framework part

CW: We’re effectively having a consensus vote on a new procedure

RH: yeah that’s what I imagined. Having the infrastructure, we could just vote to accept it once we have the issues pinned down. Relaxed SIMD could advance with it. Doesn’t seem much value in individual phases.

CW: We shouldn’t tie it closely to relaxed SIMD, we can 

AR: isn’t that a discussion we already had, that we agreed that we wanted a deterministic mode (where profiles was just the mechanism)?

DG: I would like to push on it, there hasn’t been a lot of discussion in the cg on it yet, I wouldn’t want to hold relaxed SIMD back. We did have some kind of consensus on having a deterministic mode. I would like to solidify that we agree that we will include a deterministic mode in the future, ,and if we formall agree on that I think it’s good enough to decouple relaxed SIMD from it.

CW: so we can agree that there will be a deterministic profile and relaxed SIMD can go forward and mention profiles

AR: the requirement for phase 4 is a complete spec, but the relaxed SIMD spec uses the profiles language. We are implicitly fast-tracking it already

CW: but it doesn’t commit us to a particular procedure. Teh editorial framework isn’t controversial, but the procedural part needs more discussion.

AR: it is kind of like fast–tracking the procedural part

CW: I wouldn’t want to hold back SIMD on getting agreement on the procedural  part

AR: once we use it in the spec, it’s already written there

CW: but the failure case is, we end up with 2 profiles defined in the spec now (deterministic and full) but fail to agree on the procedure for more profiles and just end up with the 2. That wouldn’t be the worst thing.

BT: are the profiles going to be integrated in the spec document itself?

CW: with relaxed SIMD it will enumerate full and deterministic profiles, and future  discussion will determine how to add more profiles.

AR: there’s an appendix where the profiles are listed in the spec

DG: I added a couple of polls, one that the spec will have a deterministic profile. That’s maybe a little premature, but we still do want to move forward with that soon. This also assumes what Andread mesntioned earlier, codifying the syntatic portion

RH: so this accepts the framework of having profiles in the spec, but not the procedure to add new profiles? So this makes deterministic and non–deterministic profiles and allows SIMD to go forward?

DG: I can also file issues, e.g. producural part, artifacts we need, and how to move infrastrcutre/syntactic things forward.

RH: I think it would be good to wait 2 weeks on relaxed SIMD and do it with the other stuff.

AR: agree with Ryan, we want to clarify what exactly we are voting on. I think we are more or less on the same page, it’s just about the procedural question and not conflating things.

DG: I agree but really want to make sure that relaxed SIMD gets wrapped up.

CW: is this about browser release windows?

DG: it’s more that the champions are moving on to other things and we want to make sure things are wrapped up and they don’t need to worry. It’s been depending on this nebulous thing for a year,

AR: I think we’ll be able to resolve it soon.

DG: thanks to Marat and Zhi for championing

### Closure
"
simd/2021/SIMD-10-01.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the 2021-10-01 video call of WebAssembly's SIMD Subgroup

- **Dates**: 2021-10-01
- **Times**:
    - 4pm-5pm UTC (9am-10am PDT)
- **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this [form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking
1. Adoption of the agenda
1. Proposals and discussions
    1. [fpenv](https://github.com/WebAssembly/relaxed-simd/issues/19)
    1. Smaller groups of SIMD instructions (like [AES](https://github.com/WebAssembly/relaxed-simd/issues/31))
    1. [i32x4.trunc_sat_f32x4_u](https://github.com/WebAssembly/relaxed-simd/issues/21#issuecomment-929425797)
    1. [wasi-parallel](https://github.com/WebAssembly/wasi-parallel)
    1. Instructions beyond scope of relaxed-simd
1. Closure

## Meeting notes

### Attendees

- Arseny Kapoulkine
- Dan Gohman
- Deepti Gandluri
- Enrico Galli
- Evan Nemerson
- Marat Dukhan
- Lars Hansen
- Petr Penzin
- Richard Winterton
- Yury Delendik
- Zhi An Ng

### [fpenv](https://github.com/WebAssembly/relaxed-simd/issues/19)

DanG: fpenv is about things are not adding to the spec. If we don't have fpenv, we have to add some state somewhere. fpenv doesn't really have motivating use cases, it's about wasm having properties like modularity, and helping preserve this.

DeG: if tools default to 0 anyway, hard to connect the dots, what would we do with this if we implemented it? Don't want something to default to zero

DanG: realistically, most implementation won't do anything with it, if you're running on a single cpu/arch, you only have the same behavior. There are potential discussions where we tied fpenv to rounding modes etc, but right now fpenv represents the coprocessor you're linked with. Fpenv might not be a great name, coprocessor is the other name i've come up with. It represents the state that we want. No one ever wants a fully non-det construction. We want to do one thing or the other.

PP: we already have different behaviors on diff platforms, people are actively exploiting.

DanG: yea NaN bits, people are exploiting it just to exploit it. for FMA, people who are trying to use FMA, it might be discontiguous, or not symmetric, will mess up algorithm. Whereas nan bits, most programs don't care

PP: What if somebody uses it? Code is going to be broken?

DanG: NaN bits are what they are, it's not about preventing programs form observing non-det, it's about programs that aren't trying to observe non-det, just trying to use FMA, doesn't have smooth curves, if you have non-det that jumps between mul+add and FMA.

PP: Image rendering, multi threaded node, far fetched? The current behavior is that you can test for something, and those programs won’t work as expected. If you have a test for platform specific code, you are going to be moved to a different node with different semantics.

DanG: use case is, matmul, don't do any test, just do matrix mul, use qfma thing to do matmul and its fast. Now you discover that when your program is running, this fma is changing behavior. This is what we don't want.

PP: The current behavior is that you can have different code on different platforms, that operation

DanG: don't think we break anything here

DG: agree with Dan that we won't break anything here, when talking about NaN det, you have to explicitly test for it, this is something programmers will run into. it's a corner case if existing code test for NaN-det.

PP: if we do test for non-det and we do something based on that test

DanG: programs today test nan behavior and assume that are probably broken. You can get different NaN patterns everytime you divide 0 by 0. But programs get away with that, since we don't change NaN bits all the time. With FMA, we do want state, we don't want programs FMA changing behavior, people rely on FMA having a consistent behavior. We don't have any state now, since its NaN bits, with FMA we want state. Where do we put this state?

AK: I guess the way I’ve been thinking about this is that implementations and users won’t care about fpenv. Fpenv provides guarantees from a semantic perspective. We want fma to be deterministic across modules, if we assume instructions are consistent across modules, if a module or another module is using fma is there a way to specify a construct that guarantees that doesn’t change the semantics instead of a bytecode stream? Is there a way for us to say that the behavior within the module is same? In practice an engine will look at the CPU will uniquely determine what the lowering is.

LH: tiering up is an issue

AK: We never want the behavior to change even with FMA. USe cases - (1) Don’t care about rounding, tiering up doesn’t matter, (2) FP algorithms that reluy on FMA, but otherwise have to write a slow fall back path. If tier up breaks/changes FMA that will be a problem. It’s useful to say that in the lifetime of the module it’s useful to guarantee FMA will behave the same way.

LH: agree with that. As i said earlier, there aren't really use cases here, we need scnearios that are plausible. Believe that we don't want non-det, we want something that looks like state. About code migrating to GPU is not really credible. Need to outline what precisely we are trying to solve here.

DanG: Would it be helpful to outline use cases for algorithms that need determinism?

LH: important to talk about how they would be exposed to non-determinism, we agree that det is fine and we like that. How fpenv should solve that problem.

DaG: USe cases: GPUs come up, heterogeneous architectures, bridging modules with RPC calls, RPC calls are going through the network and talking to a different architectures. Don’t have an immediate use case, but we would be enabling these use cases.

LH: don't understand how fpenv solves that problem

DaG: It sets up an import/export relationship - that my RPC call will have the same fpenv.

LH: are you talking about fpenv with a representation on the wire? The RPC protocol actual move that from local to remote.


LH: Still useful, farfetched but applicable.

AK: Difficult to expect a system like this to work - you have to force the other system to have FMA. Then you have a negotiation across the network to have a minimum supported requirement. It feels like it could be outside of the realm of the current proposal - this new construct isn’t about,.. Existing fpenv doesn’t solve this problem, maybe you need something else to solve this.

DaG: fpenv isn't complicated, it uses module index spaces, uses imports/exports, doesn't have dynamic state, a token like linear memory, you import/export at the same time as linear memory. I'm surprised at the entire reaction that it's a complicated thing

LH: I don’t think it works as expected, it’s more to figure out a concrete use case, and how would this work in a particular scenario that solves a particular problem. How would this work in the RPC scenario?

DaG: if you don't have fpenv, you can't do this use case at all, it's never safe. Having fpenv tells you when you can and when you can't. It doesn't tell you how to do it though.

LH: That needs to be fleshed out - how is this satisfied in a practical computer, there seems to be some missing bit I’m not getting?

DaG: Can write something out - that may help explain this more.

MD: afaiu, 2 types of Wasm engines, the ones where maximal performance is requested specialized for target CPU, if host have FMA, they always generate FMA. Another implementation where code is migrated live across different systems, for this type of Wasm engine, we specify in terms of reference Wasm instructions, that's the only way the code can move and not have non-det behavior. Don't see a situation where you want to use processor specific features and still migrate this code.

ZA: We probably want to flesh this out in terms of examples, and consider what MD’s said about code migration. Another CG discussion item: Assuming we have fpenv, would we have more than one? Do we need more than one in a single module? Does anyone have some use cses?

DanG: no user will sit down and say that you have multiple fpenv in a same module, the scenario is linking, when 2 modules with fpenv are linked, then you end up with 2 fpenvs

PP: From the pov of writing code, if you have a user writing code you could have two right?

DanG: 2 can exist, not hard to implement, you can do the same thing for both of them, they don't have to be distinct.

PP: Depends on how you instantiate. There’s state that you cannot copy.. If we don’t allow for instantiating that tries to instantiate with two distinct fpenvs..

DanG: fpenv is not a first class value, a module index space, not first class, you can reference by immediate indices. fpenv is also designed where the programmer doesn't specify it. Initial version it is imported fpenv. Now it's a module construct that host initializes

PP: What about module linking/splitting? Could you hand one of your fpenv to a different one?

DanG: it's a immediate on the instruction, you can mix them however you want

LH: when you merge 2 modules, they each have fpenv, so you get 2 in the merged module. You want to use the merged module in the RPC example. What's the constrain? do they have to be the same?

DanG: Does the RPC import the fpenv? The fpenv doesn’t do anything, if the API that we’re using uses fpenv, then we should guarantee that it works, if not maybe don’t run at all?

LH: the other concern that this remoting has fpenv, otoh this thing doesn't have first class nature, it feels vague what exactly we are looking at


DanG: Similar to exporting memories/tables etc. The details are for the implementation to figure out

PP: we don't want fpenv to be first class, but we want rpcs to specify what fpenv they want

DanG: they are imports/exports, resolved at link time, in RPC that could be protocol negotiation

AK: for RPCs the future use case, there are 2 worlds, fpenv is a spec construct because we want formal, leave it in the spec without going into the implementation, another world is where there is a practical manifestation of spec langauge in the future, like the RPC, but we should have a sketch of how it would work in that use case. fpenv seems like a compromise, or at least not clear how rpc would work in the current spec. Drafting that will be helpful. If it doesn't work, we should make the construct stronger, or keep it to the spec language.

DeG: wait for Dan to write something up, then we can come back to this.

AK: can we also close some issues, multiple things

ZA: AI to consolidate the issues.

### Smaller groups of SIMD instructions (like AES)

DeG: if we are introducing extensions to SIMD, we can move to design to see if we can move this through, i would like to see use case, real applications using it, driven by use cases. One use case for 64x2 is that it's hard to do some things without them. Performance is another aspect. Can have some design consensus within this group, before presenting to CG. We can streamline and have multiple instructions, but still need strong use cases.

PP: we want to do the use cases in this group? then surface it to the CG/ move to main spec.

DeG: If someone is interested in adding an extension, we should document it ahead of time, get a first pass from this group.

PP: if someone has a SIMD instruction to explore, they can come to us first

DeG: what do you have in mind for AES? what are you looking to get out of this?

PP: I’m trying to find what else we can use AES for? From instructions perspective, relatively straightforward to implement..

LH: issue 31 about AES, decided it is not for relaxed-simd, suggested it would be spun off as its own proposal


ZA: We haven’t really had small proposals about testing how fast we can get through the process. This is one example we can try if we want to streamlined. We need use cases - PP are you interested in driving this forward?

PP: Will follow up on the issue.

ZA: Out of scope for relaxed SIMD, but in scope for the subgroup as a SIMD adjacent proposal.


### [i32x4.trunc_sat_f32x4_u](https://github.com/WebAssembly/relaxed-simd/issues/21#issuecomment-929425797)

ZA: Relaxed version for the unsigned instructions is the only one in the current proposal that is 8 instructions long, still better than the non-relaxed version.

MD: we never had a formal req for 1 instruction lowering

ZA: Anyone disagrees/agrees?

LH: no objections

(No objections)

### [wasi-parallel](https://github.com/WebAssembly/wasi-parallel)

PP: Announcement about WASI parallel: officially published the parallel proposal for WASI, it’s now at phase 1 in the WASI process. The idea behind this is that you have a parallel construct that can be used to run parts of the module in parallel, like how you would use OpenMP.

MD: does it only provide 1 dimensional loops?

PP: It is that at this point, it provides a way to block things, still working on figuring out what envs it will work in. We have a way to run things on the GPU, at the moment they consume CPU code. It’s WIP.

ZA: New instructions?

PP: WASI functions, uses funcrefs

DaG: Could be polyfilled potentially.

PP: Challenge is WebGPU. Less universal, OpenMP has the same problem

LH: giving a function pointer, assume entire Wasm instruction set is supported

PP: There will be things that are missing, translating to GPU operations may not always work

MD: not clear what the target of this proposal is, multi thread?

PP: To a degree both, hard to achieve both, will see what materializes. We try to add parallel programming constructs, not specifying which hardware we will be targeting. Both have pros/cons. For multithreading - lower weight threads. For GPU - if you don’t have a GPU can’t do miuch.

Welcome to Enrico!

### Instructions beyond scope of relaxed-simd

MD: considering other instructions beyond the the scope of relaxed-simd, like AES instructions?

DG: don't need to wait for big proposals, will experiment with streamlined process. soft dependency on feature-detection

MD: will be helpful to have a list of instructions for the next SIMD proposal. Right now we have everything in SSE4.1, but we go beyond that, not much. Crypto instructions for example.

ZA: Will go to the design repo and kick off a new proposal - we could come up with a SIMD v2 proposal, and would need a champion to push this forward. Would probably be useful to have a checklist for new instructions to frame the discussion.

MD: Would prefer to keep AES instructions outside of SIMD, cryptominers will hurt SIMD adoption

PP: not sure if we want to go into SIMD 2.0, unless we have a specific idea. When we do SIMD 2, it's hard to understand what it's going to do.

AK: The general topic was, when we worked a baseline of of instructions. Seems like AES, and other interesting instructions - you have to have a high baseline of SIMD instructions, the problem is that if you want all the instructions to be implementable at once, the hardware baseline becomes a problem. You will run into the problem of different hardware support, enables more fingerprinting, or polyfilling will result in a performance cliff.

PP: const 0 encoding. something like this could be in SIMD 2.0.

MD: substantial number of instructions that we didn't add in the first version that produce multiple output, e.g. NEON load struct of elements, there are also instructions to extend low and high parts. Can basically create a new proposal just out of this use case

LH: in favor of examining those more, instructions with multiple outputs. More tricky in Wasm because it is a stack machine, order of output is difficult to deal with sometimes. Can drive this from the SIMD realm, flag bits are especially hard.

DG: multi-value proposal is merged into the spec, having a dependency on that is not longer blocking.

PP: some of the things may be platform dependent, can have fallbacks. They don’t all work the same on all platforms.
"
threads/2024/THREADS-01-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 9 video call of WebAssembly's Threads Subgroup

- **Where**: zoom.us
- **When**: January 9, 5pm-6pm UTC (January 9, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/mUp4nmiVUTNQDKcD9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Walk through and discussion of proposal overview (Thomas Lively)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Conrad Watt
- Zalim Bashorov
- Paul Dennis
- Paolo Severini
- Alon Zakai
- Nick Fitzgerald
- Shu-yu Guo
- Andrew Brown
- Ilya Rezvov
- Sulekha Kulkarni
- Ryan Hunt
- Manos Koukoutos
- Alex Crichton
- Ashley Nelson
- Adam Klein
- Yosh Wuyts
- Emanuel Ziegler
- Johnnie Birch
- Deepti Gandluri
- Matthias Liedtke
- Luis Fernando Pardo Sixtos

### Walk through and discussion of proposal overview (Thomas Lively)

tlively presenting [overview](https://github.com/WebAssembly/shared-everything-threads/blob/0c23f3f4b80cbc5e0cb3ebf4db02cb755a1eb25f/proposals/shared-everything-threads/Overview.md)

#### `shared` annotations

YW: does “subtyping” in this context just mean new type aliases, or also things like one type containing another?

TL: Subtyping just meaning subsumption, like how an i31ref can be received wherever an eqref is expected. Non-shared structs could contain a shared field but not vice-versa.

CW: Data segments, can we get away without shared annotations? think about memory.initl to a shared and unshared memory. You wouldn't want to have to duplicate the data segment.

CW: If you catch an exception, rethrow and catch it again, do we guarantee that you’re not rematerializing, do you have reference equality between the two exceptions in any meaningful way?

RH: exnref is not a subtype of eqref so there’s nothing you can observe for equality right now

TL: In the engine is the identity the same, even if that's not observable?

CW: The point is engines could do either right now, is that correct?

RH: Tricky because JS can throw exceptions so there has been talk of rationalizing throwing JS string, how those things materialize as an exnref. My understanding is JS can throw primitive values that are auto wrapped into a tag defined by the host. Right now, because there is no reference equality, that's all observable but it could be more observable, not the reference equality part, if we expose this tag.

CW: I’m wondering if it is possible for the existing catch all ref to blindly catch all exnref even if the thing thrown was a shared exnref. Maybe that’s suspicious and some implementations would need to materialize a separate wrapper in that case. This is very speculative.

RH: Tricky, need to think. A shared exnref means its payload can only contain shared things. There’s no subtyping relationship between exnrefs and shared exnrefs. So you couldn’t have a catch_all_ref catch all the shared type of the relationship, it needs to be one or the other.

TL: Would be nice to be a subtype so you can catch the two. But that would be consistent with everything else.

CW: Thinking of something with even less thought. If you’re in catch_all_ref you just unconditionally get a non-shared exnref, even if the thing was shared. Is that too weird?

TL: In a shared function, you would only be able to catch a shared exnref, so if the non-shared exnref appeared as a shared exnref, it would allow the non-shared payload to be observed on another thread.

CW: Totally right. Everything I said earlier was leading to nothing [nb: my train of thought was wrong]

TL: What if we had a nonshared ref with a nonshared type. If you shared it and then rethrew it on a different thread.

CW: Exactly. Maybe we need to have a total bifurcation. If you have a catch_all shared you can only catch the shared things.

TL: What do you do when you’re a JS thread local function throws a thread local exception and that ends up being caught in a shared function?

CW: Its desirable to not be able to express a non-shared catch all in a shared function

TL: You'd need two different catch_alls on your try tables, one for shared and for non-shared. They have different types so they need to go to different places, it’s quite ugly.

CW: The point is with shared continuations, a shared function shouldn’t be able to capture a non-shared exnref

RH: Exnref shows on the JS side as a prototype and it has properties and those are writable. So if you have an exnref and it puts properties on it, it can have JS strings associated with it. If you’re thinking about what is a shared exnref, you might need to think about that too. Not the case for GC objects today, but with the exception handling rules of today you can totally catch an exception and add properties to it which would make it unshared.

TL: Hadn’t thought of that, speccing shared exnref on the JS side might be weird.

CW: Is it not true in Wasm, with our new concept of exnref that has a tag you can check, it's only if you can add JS properties that things get suspicious?

TL: Right.

#### TLS

tlively asking for feedback on decision to make thread-local globals as realm local in JS

AN: What’s a realm?

TL: JS has a concept of ""realms"" which are essentially different copies of the JS environment, e.g. different copies of console.log, that all coexist and can interact with each other. This comes up in iframes, for instance, which have their own realms that can interact with the realm from their parent frame.

CW: Think of the interaction we do with JS in regular Wasm. When we import a Wasm function to JS, it's analogous to bringing a new function into JS and even in JS you’re allowed to bring a closure into cross-realm. And you expect the realm you’re referring to refer to inner realms. If you move that module to another realm, just because that module was a shared module, you have to redeclare your imports. Where you wouldn’t have to do that with non-shared. And even if in the non-shared Wasm world you’d potentially want some dynamic access…

TL: Simply more consistent with the things currently working if we have thread locals instead of realm locals.

RH: What's the motivation for realm locals instead of thread locals?

SYG: I take the opposite opinion to CW. DX is a good thing to focus on for sure and I think for the usual case, it doesn’t matter for DX. I imagine the usual case is 1:1 of realms and threads. I imagine people are not running Sphinx in a synchronous iFrame. How I arrived at realm-local makes more sense than thread local is if you have the mental model that JS is the syscall for Wasm, then you need to hook that up somehow. Currently you look that up in a shared world by whatever thing you’re executing. In a shared world, you end up moving to a more dynamic shared place because you don’t know what thread you’re going to be running in. Technically the syscall you’re embedding is different thread to thread and realm to realm if you make the decision to be thread local, it doesn’t take away the fact that there are multiple executions on the same thread. If your JS embedding has installed polyfill, some globals inside of an iFrame and your outer realm. If you’re running some shared payload that has some TLS table setup with JS APIs. 

CW: The scenario you’re describing where an individual iframe is doing a polyfill, the question of threads or not is orthogonal. What will happen in wasm is you’ll take the definition you originally imported at instantiation-time (fixing the realm) - if you’re in the single-threaded world and you transfer the Wasm to a new realm, you already have the issue of not seeing the new realm’s definition

SYG: True but in a single threaded world, there is no surprise because it's a lexical scope thing. You closed over them. In the shared world, it's more dynamic. You cannot access the original context. You’re running in a new thread so where do you pick up the new context.

CW: Not inconsistent to say you have a context per thread and in the same way you fix the content in the first thread by ??? you fix the content in the second by binding the secondary function.  

…

<TL, CW, SYG… too quick of an interchange to capture>

SYG: want to think more about the bad DX question; it’s only a surprise if you’re a JS wonk.

CW: My bet is 99% of the realm local storage surprises show up in the single-thread cases already.

TL: Let’s file an issue. SYG, we can have more deep discussion too.

<back to presenting>

RH: You said that you can do global.get in the initializer of a thread local?

TL: Yes it works the same way as global.get in a global initializer today, newly valid with WasmGC.

RH: When does this run? Still the very first function run on a thread? Not sure if it's observable or not.

CW: Shouldn’t be observable.

RH: I can never remember… that sounds right

CW: The timing should not be observable otherwise we should forbid these initializers.

TL: If it was a problem, it would already be a problem in WasmGC because you can already initialize globals if you want. So we must have restricted it to be immutable globals otherwise WasmGC has a bug.

CW: The main thing I’m scared about is not functional behavior but the resource budget; if you allow allocations to happen lazily that could have surprising performance implications…

TL: On the other hand, a separate allocation on each thread is very possibly exactly what you want. For example, in the C world, pthreads have a pthread struct that lives in memory of course. Each thread gets one. Has all sorts of context info. If you port that naively to a Wasm world, you can imagine having a pthread struct that is also thread specific.

CW: Do you want that allocation to happen at an unpredictable time or in a start function ???

TL: Something we should keep in mind and evaluate as we get implementer feedback, unless someone else has a strong opinion.

PD: Less features! Can always add more later!

TL: In this case, I wouldn't categorize it as adding or not adding a feature. We definitely need thread local globals as a feature. The question is how it should behave.

CW: I interpret PD’s comment to support my restricted initializers.

TL: Fine, updating the document with that and switching the note. We’ll have to spec out a subset of the instructions that are non-allocating but that seems fine.

CW: Restricts certain non-nullable thread-local globals…

RH: Could we restrict to defaultable only and not allow any sort of initializer?

CW: Yes, that’s what I’m advocating for.

RH: We could instantiate blocks eagerly. We might not be able to run the initializers….

CW: Is it the case that for every defaultable type can we initialize with zeroes?

TL: In v8, the Wasm null is not zero for anyrefs.

RH: Is it a per-thread or per-process number?

TL: Good question, shared references must be the same value across all threads. And we’re only allowing shared references and TLS globals for now.

RH: In SpiderMonkey 0 is the default value for all shared globals

TL: What if I have an i32 thread-local global and want to initialize it to 5–can I do that? We could start out super-conservative: no initializers.

RH: I have not implemented thread-local stuff but that seems to be what would work for almost anyone who needs it. 

CW: Functionally this will always work.

TL: I expect we’ll want to relax it to allow initializers. Especially concerned if we don’t allow allocations we won’t be able to have non-nullable globals.

CW: That is an implication of this and all initializers need to be default values; globals must be initialized…

PD: I was surprised it was a high-level feature, it seemed like a low-level feature. 

TL: Are you talking about having TLS globals at all?

PD: Yes, they're like thread local globals that get initialized by the C++ runtime. Hidden by the compiler.

TL: If we allowed arbitrary initializers we still wouldn’t be calling constructors; still very constrained. But your point stands–more stuff for the engine to do if we allow that.

#### Thread Management

AB: Created a draft PR (https://github.com/WebAssembly/component-model/pull/291) for adding these built-ins to the component model and Luke has already added a bunch of comments about that. And if we wanted to discuss more, that PR is a great place to discuss that.

PD: Philosophically, spawning a thread is like a goto–worse in fact (splits into two executions). WebAssembly does not have gotos; spawn reintroduces this. Found literature to do this differently: nurseries. Every spawn is “de-spawned” at some point.

TL: I’m not sure I see thread spawn and goto as similar, seems like you’re spawning a function, so it's more like a function call. The nursery idea seems like a generalization of thread spawn. If you spawn a nursery of just one thread in it. That seems awfully similar to thread spawn. Seems like a higher level feature, the nurseries. 

CW: Nurseries have a lifetime, like in structured concurrency, right?

PD: Yes, my usage point of view is less features in the sense that you can do less with Wasm and if you have to program more stuff in the runtime, you have less things you can do.

CW: The philosophical tension is Wasm is a compilation target; thus the lowest common denominator of targets people compile to Wasm. I spec-ed what goto would look like; not having goto causes a lot of pain and means that people are forced to “reloop”. The fact that there is no goto is problematic… JS backend sharing story.

PD: You can have a second function that breaks the encapsulation, the same as if you have a small function. You could have this low-level thing like for pthreads. How wuld this improve performance because if the compiler knows the parallel executions are done at some time, it could do some performance optimizations that wouldn’t be possible without. Because if you do it with Wasi, I assume it will be lots of function calls. Let's say you have two threads, one for memory 1 and one for memory 2 and they are not shared, and the threads are accessing the memory separately, no connection between them. You could actually have parallelism. Still in JS, the problem would be you can’t observe different executions, because whether it's single threaded or multi-threaded you don’t know. I would be interested if someone knows whether this cannot work or not?

AB: If you have feedback, add it to Paul’s open discussion thread: https://github.com/WebAssembly/shared-everything-threads/discussions/22. 

ZB (chat): Could shared functions access browser APIs (through import)?

SYG (chat): yes, that's what the TLS mechanism is intended to enable

ZB (chat): by storing to shared TLS global? Observation: It seems like in languages without concepts similar to ""shared"" (is there any?), e.g. Kotlin and Java, we will be forced to use shared annotation for everything.

CW (chat): Zalim: that's correct

SYG (chat): yeah, you can set up a TLS table that has per-thread/realm imports of say, `fetch`. each thread/realm has to re-import it before first execution, but afterwards execution on T1 will call T1's copy of `fetch` and execution on T2 will call T2's copy of `fetch`. the conceit on the web embedding is something like, yes, they can technically be different, but all the threads' copy of `fetch` is going to be the same most of the time

CW: Will start a discussion about thread-local vs realm-local

SYG: Let’s talk now if you have 30 minutes. 

TL: SYG, please drop a meet link anyone can join if they want to.
"
main/2024/CG-07-16.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 16th video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: 2024-07-16, 16:00-17:00 UTC (2024-07-16, 9am-10am PDT, 18:00-19:00 CEST)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
   1. Phase 4 vote for
      [Exception handling](https://github.com/WebAssembly/exception-handling)
      (Heejin Ahn, 10 minutes)
   1. Vote to increase Web import limit to 200k ([issue](https://github.com/WebAssembly/design/issues/1520), Thomas Lively, 5 minutes)
   1. FP16 proposal: next steps (Ilya Rezvov, 45 minutes)
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

### Attendees

 - Paul Dennis
 - Robin Freyler
 - Derek Schuff
 - Ben Titzer
 - Francis McCabe
 - Jeff Charles
 - Paolo Severini
 - Daniel Lehmann
 - Mats Brorsson
 - Nick Fitzgerald
 - David Degazio
 - Johnnie Birch
 - Ryan Hunt
 - Chris Fallin
 - Sam Clegg
 - Yuri Delendik
 - Daniel Hillerström
 - Chris Woods
 - Ilya Rezvov
 - AlonZakai
 - Jakob Kummerow
 - Ben Visness
 - Conrad Watt
 - Linwei Shang
 - Emanuel Ziegler
 - Deepti Gandluri
 - Jake Enget
 - Chris Woods
 - Alon Zakai
 - Matthais Liedtke
 - Julien Pages
 - Heejin Ahn
 - Adam Klein
 - Andrew Brown
 - Luke Wagner
 - Brendan Dahl
 - Alex Crichton
 - Michael Ficarra
 - Andreas Rossberg
 - Nuno Pereira
 - Richard Winterton
 - Dan Phillips
 - Keith Winstein



### Proposals and discussions

#### Phase 4 vote for [Exception handling](https://github.com/WebAssembly/exception-handling)

AH: Discussed in the June CG meeting: introduced exnref in the October meeting. In June, agreed EH was ready for phase 4 but needed some JS API tests. These have been added now.

CWoods: We’re about to add exnref to Wamr, is there a plan or a timeline for when the new EH will be enabled in emscripten, so we know what’s happening in the Wasi SDK, and the rest of the buildchain

HA: As soon as we go to phase 4, it can be available in VMs without a flag. Emscripten has support if you use a flag. If you use just upstream LLVM/clang, it does not have support yet. I am currently working on it. For wasi, I’m not sure about the status. BTW, Voting to phase 4 doesn’t mean we are removing the previous support anytime soon.

CW: We’d use the new implementation for code size, its just working out what’s required on the toolchain - we can follow up offline

HA: exnref doesn’t reduce code size.

CW: We don’t want the code maintenance costs going forward, will just keep the one code path

DS: Wasi SDK uses bare clang & LLVM and a pretty minimal libcxx changes - I assume once exnref is in upstream LLVM, it’ll be in WASI SDK pretty quickly.

CW: we’ve already ported setjmp/longjmp over to old EH, which has been useful.

BT: I was wondering the state of setjmp, lngjmp, will that be upstreamed into LLVM?

CW: good question. We have an internal port, but we should do that.

HA: upstream LLVM has sj/lj support, and it shouldn't really have to change with exnref, exnref is orthogonal to that.

**Poll:** Vote to advance the Exception handling proposal to phase 4:

|SF|F|N|A|SA|
|--|-|-|-|--|
|25|6|3|0|0|

#### Vote to increase Web import limit to 200k ([issue](https://github.com/WebAssembly/design/issues/1520), Thomas Lively)

TL: The limitation on the number of imports is currently 100k. These limits are generally meant for compatibility on the web so that the engines agree on them. But if real-world apps have a good reason to go over them, historically we’ve just raised them to allow the app to run. So the question is, is this a reasonable use case. The use case is that Photoshop is using wasm-split to get deferred loading. This is what David Sankel from Adobe came and brought up in the Pittsburg meeting. Our feedback to them was to use wasm-split. When they do that they end up with ~130k imports, where functions are split out from the primary to secondary module. Since this isn’t a human written API boundary you end up with a lot of imports. So i’d like to increase the limit to 200k to allow splitting very large applications without exceeding the limit. Details on the issue show various workarounds, indirection etc to reduce the number necessary. But I think we shouldn’t have to work around this in the tools and it’s reasonable to raise the limit.

CW: I’m totally happy to increase the limit, but: my first question is - are we in danger of hitting an analogous limit on exports? 

TL: good question, I’m not actually sure. I imagine if there is a limit we should keep them in sync. I’m not sure if there’s a limit or what.

BT (in chat): There is a limit, and it's the same.

CW: I support keeping them in sync and raising both. Also I don’t think we need to work around, but it’s about moving work from active segments to JS. it seems like you don’t need the limit if you move the segment work to JS, would that be better than having all the imports in the long term?

TL: We did talk about it when Ryan brought up compat import format - there is a requirement in the spec of the imports being looped over and how its hard to optimize. That said it would be hard to do that anyway when coming from JS - we’d need someone from the V8 team to confirm that

BT: if we’re going to 200k, we might hit the limit again, should we just increase it to the number of functions, 1M?

TL: I’d be ok with that.

JK: Regarding performance, it might be hard to estimate what the performance impact would be - iterating over 100k+ or a 1M of anything has a cost. The compact imports proposal if it does materialize, that would change the calculus

CW: would you have any concerns to rasing import/export limit to 1 million?

JK: I don't think we’d have any issue with 1M. We might hit a limit at ~16M. Obviously it could be slow to iterate over that many on instantiation, but I assume if you create such a big module, you are willing to pay for that.

RH: We don’t have any technical reasons not to do it - it’s more a social reason

BT: My reason for matching the number of functions is that there is a nice symmetry. You could have passthrough which imports all the functions and exports them all again.

TL: Does the million include imported functions? Not clear. I guess if you can define a million functions maybe you want to export them all.

BT (chat): I think the maximum number of functions limit is for defined functions.

TL: Anyone object to raising both the import and export limits to 1M?

No objections raised.

#### FP16 proposal: next steps (Ilya Rezvov)

IR presenting [TODO slides]

Performance numbers

AB: help understanding the table: the RH column, is that speedup or slowdown? (slowdown) for F16 GEMM or M32 GEMM are those 2 different algorithms? Or are they just multiplying different matrixes

IR: not totally different algorithms, i just compared performance of float operations, measured in FLOPS

AB: in the first row you multiply an f16 matrix and in the 2nd row you multiply an f32 matrix

PP: Its the same algorithm, but different 

CW: i would be surprised to see more than a 2x speed up, but I guess the number of lanes is 2x

IR: less memory, better cache optimization helps too

PP: (missed in the notes)

DG: Question for you: did you run this by the XNNPACK team? Some of these are surprising. They’ve done a lot of native benchmarking, did you check this with them?

IR: To clarify, it’s not running native F16 GEMM, its F16 GEMM compiled to wasm on hardware with native F16

AB: to go with that, did you compare the pure native version of this benchmark with the compile to wasm version of this benchmark?

IR: no

AB: would be interesting to see how far we are from true native

NF: wanted to clarify, is native F32, that’s wasm running the F32 gemm benchmarks, not using F32 to implement the F16 benchmark? So the most direct comparisons are native F16 and F16C and software?

BT: do you have more insight into why F16C is so slow?

IR: Unfortunately no, there’s nothing 

CW: also related to F16C+AVX column. Is this the strategy older AVX versions of X86 will need to use to emulate F16? So you’d never really want them to generate F16 in the first place you’d rather have them using F32?

DG: In F16, where in V8 is that implemented? Some of that is only in Liftoff.

IR: all of these are liftoff

DG: That’s not always a fully accurate comparison. It’s still not the optimizing compiler, so comparing baseline to native will be helpful

IR: yeah we probably need to implement turbofan for x64

DG: I mean, these are all wasm numbers: how they compare to native just in terms of the factor

CW: To expand on the earlier point on the F16 emulation. If you don’t have native F16 on your X64 you really would want the website to use F32 wasm instead of F16 wasm. So as an ecosystem do we want to encourage sites to use F16 if they can’t predict which platform they’d be running on

IR: So that's the next topic. Because of those I think we need a way for the app to figure out if the implementation is fast enough to run it. It could of course run anything for portability reasons, but for real world you’d want to know if the platform supports it. But I think you’d want the app to run in different ways based on the hardware. So to keep the performance predictable, I think we want to introduce some way of using emulation detection. [predictable performance slide]

IR: IMO this machinery solves the issue raised that we need feature detection support. Are there other opinions?

AR: Different definition of predictable performance - you’re saying you can reflect on the environment and know whether it supports the feature.. But  I meant to say that when you generate some WebAssembly code, you have a rough performance model for what you have in mind, and that it’ll map predictable across hardware. Anything that has feature detection in WebAssembly is a red flag for me. It's a sign that it's premature to add to the language.

CW: The numbers for the emulation make me wonder, are we just adding FP16 a couple of years too early? It seems very different from how we’ve done this before, running ahead of the de facto hardware landscape. Not that we could never do this but it does give me pause.

DG: I agree with you on the basis of these numbers, but we need more introspection about whether they are actually representative. We need to go back to partners who were seeing benefit.
It’s more analyzing why it’s slow, i’m not sure these are fully reflective of the actual hardware.

CW: I would in particular be curious about whether the partners are excited about speeding up like 10% of their users or if they are expecting across-the-board speedups.

DG: I don't think it will be a majority of the user base, but a percentage. It won’t be consistent across all hardware,but it will be a set. There’s excitement about F16 especially on mobile. It will be interesting in how we slice it. We’ll have to think about where we draw the line, but it’s premature until we know better where and how we’re falling off the cliff.

CW: I think that's the best possible answer we can get at this stage. I appreciate that you're going to get more information.

DG: yeah, this comes from an explicit request for CPU inference and there’s a class of hardware that’s ready for it. And we’ll have to slice the numbers. And we’ll want apples to apples, and also native vs wasm. If we see F16C+AVX get to maybe 6x, that’s still very different from 100x

AB: It looks like the slide is proposing feature detection more broadly than just F16. We've had those discussions in the past. Why did we abandon this in the past?

TL: Those past feature detection proposals were different, there were standalone proposals so a little different. Conditional sections was way too general, there were a lot of design issues that came up because of that. The second was conditional blocks, much less general and targeted toward SIMD use cases. But because it was standalone there was an expectation that it be more general, so it kind of died because it wasn’t general enough. So I think that leaves room for more specific feature detection that goes with a particular feature, so this is a new kind of feature detection.

DD: I concur on the performance numbers we see are realistic, the emulation cost is very surprising especially for F16C+AVX
Also concur that it seems a little premature if hardware is not really in a unanimous place. My position and Apple's position is that if we want to open the can of worms for feature detection or if we want to have this unbalanced performance, then we want evidence that it's uniquely useful. Is there a reason this has to be done in WebAssembly rather than WebGPU, which already supports float16. Why does it specifically need to exist in Wasm?

DG: the reason for adding some of these ML features to wasm is that what we see is that a lot of the production code is still running in wasm. WebGPU is a good fit, but a lot of those backends are experimental. The other use case is small models, and GPU bringup is expensive, so it’s more efficient to run it on the CPU. Also useful as a fallback for GPU especially for low end devices. There’s also a use case of wasm as an entry point where we want to minimize JS (JS has no F16 array yet)

CW: For the interop use case, are the conversions enough, or do we also need the lane operations that come in later architectures?

DG: for the interop bit I think it’s just the conversion we care about. For the running part we care about the other things

DD: conversion seems much easier, it's much more widely supported and more direct. From the perspective of models not adopting it yet, I don't think that's very compelling because it's so early and it's possible that WebGPU adoption picks up later. The point about smaller models does seem compelling though.

DG: There's also an inherent use for running intensive compute on the web, but we haven’t yet seen how it will break down in the wild, the split between wasm and GPU. There may also be NPU usage on the web, but the base case will stay relevant. Also there are non-massively-parallel models. Segmentation isn’t as extremely computationally expensive for example, and it doesn’t really need the GPU. so part of it will always be relevant.

AR: I feel this is premature and I think other people do too. I think it's important for WebAssembly to provide features for newer features that are not ready to be added to core Wasm. We should look at opening ways for wasm to have features that are not ust extensions of the instruction set, for quicker turnaround, more experimentation, and deprecations. We talked about builtins for that in the past. We can use that as a first step to iron things out and mature over time, and then in a couple of years we see what CPUs do and how people use it, then it could maybe move into core wasm. As skeptical as I am bout ths, I don’t think we should block it, we can hopefully move it forward in a safer way.

AB and ChrisW and PP (in chat): +1 for builtins.

IR: that’s what I’m calling the import based approach, there’s an example on the slide that we di dn’t get to, but we can follow up.



### Closure
"
main/2022/CG-08-30.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 30th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: August 30th, 4pm-5pm UTC (August 30th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discuss reserved/illegal opcodes prefixes (issue)[https://github.com/WebAssembly/spec/issues/1419] [10 mins]
    2. Resolve handling of const expressions (issue)[https://github.com/WebAssembly/spec/issues/1522] [15 mins]
       - Poll: pick web/interpreter semantics or pick spec semantics?
3. Closure

## Agenda items for future meetings

*None*


## Meeting Notes

### Attendees

* Deepti Gandluri
* Derek Schuff
* Sean Westfall
* Zalim Bashorov
* Yury Delendik
* Justin Michaud
* Francis McCabe
* Rick Battagline
* Jeff Charles
* Nick Fitzgerald
* Sebastien Deleuze
* Asumu Takikawa
* Ezzat Chamudi
* Ryan Hunt
* Andrew Brown
* Paolo Severini
* Jacob Abraham
* Brendan Dahl
* Richard Winterton
* Conrad Watt
* Luke Wagner
* Saul Cabrera
* Ilya Rezvov
* Sam Lindley
* Andreas Rossberg
* Jakob Kummerow
* Alon Zakai
* Manos Koukoutos
* Thomas Lively
* Yuri Iozzelli
* Alex Crichton
* Petr Penzin
* Benjamin Titzer
* Johnnie Birch
* Melanie Riise
* Bailey Hayes
* Yuri Rashovskii
* David Piepgrass

###  Discuss reserved/illegal opcodes prefixes (issue)[https://github.com/WebAssembly/spec/issues/1419] [10 mins]

DG: Several engines use 0xff opcodes for internal use. They are illegal now, but there was some appetite for a stronger assurance that it doesn’t get used in the future.

CW: there did seem to be at least some divergence. Thomas was saying we should still have the freedom to use ff if we run out of opcodes in the future, whereas some wanted assurance we’d never use it. Any decision we make now can of course be reversed in the future, but it would be good to see what people think.

RH: Our use case is generating Wasm bytecode for an asm.js module, the bytecode is internal to the engine, we just want to be able to reuse the decoder flag, we have runtime flag for the asm.js mode, we could still work around having a single opcode, reuse the single prefix for example. There could be other use cases where single bytecodes that BT  mentioned for instrumentation, for SpiderMonkey it’s not a big deal, we can add a non-normative note

DG: From V8 perspective, we also have these internal asm.js opcodes so we could probably also use a prefixed or 2 byte opcode as well.

BT: Conrad posted a link to JVM spec, theres a couple of paragraphs. I think I’d support something similar.

CW; I’m interested in hearing, is there anyone who would feel bad about us adopting the position now that we plan never to use the 0xff opcode?

RH: No concerns personally, between the single byte prefixed, and the last one there’s 36 single byte opcodes, having one of them be unallocated seems reasonable to me. 

TL: do we still think it’s important to have an escape hatch for the future if we run out of single byte opcode and need to do something? Currently that’s 0xff. If we say we’d never use it we regress that preparedness. Maybe it doesnt matter but, or want to address in a different way? eIther way, not urgent.

AR: I’m curious to understand the single opcode would make a big difference in that case, not hanging on one opcode when we run out makes more sense to me

TL: What we’d previously planned with 0xff was make it a new encoding scheme, so it’s an escape hatch to introduce something new

RH: when we get to where we’re down to 2 single byte opcodes, is that the time to declare a scheme like that?

AR: We can just reassign a single opcode

DG: the only thing is that everyone who is using it now is only using it for internal opcodes… 

[temporary notes outage, lost my connection]

FM: They mark areas of future expansion as reserved.

AR: We essentially do that, at least in the appendix with the opcodes. It just says reserved. Technically it doesn’t mean anything but expresses the intent. Reserved can mean different things… really this discussion is about “what is the meaning of reserved”

BT: This is why having some language in the spec like VM does might make sense.

AR: that makes sense. 

CW: do people feel like we need to have more coordination at a higher level about which opecodes are being used by proposals, maybe at the CG level?

TL: Sounds helpful, but probably separate

FM: do we have any measure about how many opcodes are coming?

AR: The most ones are not single byte ones, no single byte ones in the pipeline asfaik. Call_ref, control flow related

DG: wrt the opcode prefixes for proposals, it seems fairly simple to add to the proposal repo which opcodes are being used. Not set in stone or merged but a reasonable way to surface

AR: could also be used for type opcodes, where we had minor conflicts

BT: could also have a convention where proposals never use final opcodes, until they get merged into the spec.

BT: Basically when you get a prefix, and then it gets recycled when it’s ready to be merged.

CW: that would probably work better once we start seeing fewer proposals with foundational changes to the type system. Right now not everything we’re adding is neatly under a prefix

AR: Other than Simd, we don’t have proposals with a large number of instructions. For GC for example, I would assume that we would do some renumbering before merge, seems unavoidable that such a thing would have to be coordinated somehow

DG: one note about that is that usually with renumbering, we do sometimes have to coordinate with tools and engine, so the churn is hard sometimes

AR: yeah thats why to only do it once at the end.

DG: on the original issue, maybe we could do a consensus poll to add a non-normative note in the spec and leave the opcode as is. do es anyone object?

AR: no objections but ill say that currently the spec doesn’t say anything about backwards compatibility. We could even remove random opcodes. If we say something very specific about 0xff we should maybe say something about our intent regarding compatibility too.

CW: If there should be a wider scheme for someone that might use it shouldn’t use 0xff, there’s no way to say that instead of a non-normative note

TL: agree that we should say something about our intent generally but i think it ‘s fine if we do something about this case first, independently.

AR: It doesn’t have something fancy, can have a couple of points in the appendix about what types of changes we are ok with and what we aren’t. And the 0xff one could be another bullet there

TL: If that would be simple to do, we do have a pretty clear what our backwards compat there

AR: We can list it, and say []

CW: or just that it’s not exhaustive….

DG: It sounds like we like this idea. We can take the specifics offline.  Does anyone want to start this up with a draft?

AR: I can. I guess I should reopen the issue?

DG: I think I already did.. So, we can follow up on GH, I don’t think there’s anything else we need to discuss live here.


### Resolve handling of const expressions (issue)[https://github.com/WebAssembly/spec/issues/1522] [15 mins]
       - Poll: pick web/interpreter semantics or pick spec semantics?

AR: This has to do with our constraints on constexprs. They occur in global initializers, offsets for element segments, and as elements themselves (since 2.0). I think those are the only places. We are also introducing a default for table elements. For global initializers, we intended that they cannot refer to other globals except imported ones. There was an inconsistency between the spec and reference interpreter (other implementations mostly match the ref interpreter)

I think the spec said the other one could use globals, and the reference interpreter implemented it the other way, no real test coverage except for some commented out spec tests, that leads to some divergence for this corner case. We can disallow global.get, the web engines all follow the interpreter, 

Web engines all follow the spec interpreter, wasm3 and wasmtime agree with the spec. Wasmer also agrees with the ref interpreter. I would propose to follow the majority (the reference interpreter) and change the spec. It’s very minor, we could almost regard it as a typo. Technically that’s a breaking change in the spec since it restricts things that were allowed before

I doubt any real program would depend on this behavior, none of the web engines practice have this so we may not be breaking anything


NF (chat): wasmtime disallows non-imported globals, the issue opened doesn't reflect actual behavior

AR: so that’s what the interpreter does. So the majority is even bigger in favor of that behavior so that seems lke it makes the decision even easier to make the spec match the implementations.

RH: I would agree with that, it’s not trivial to implement the change, we can just make the minor change, and would be for that

AR: i agree, and it also seems more consistent in general, you don’t need different rules in different places.

AR: Does anyone disagree with that? We can do a unanimous poll

BT: are we clear that it is more general to allow them, rather than the restriction that was in the spec?

AR: yes. I think that’s why the engines ended up the way they did too.

RH: I may be remembering this wrong, doesn’t GC relax this behavior and what does that mean for data segments?

AR: yeah that may be true. So they become more linear.

RH what would that imply about data segments?

AR: we seem to be converging that all declaration should be kind of sequentlal. If we want to allow things to refer to others, it’s seemed to come up that we want to allow repeated sections. I would propose that all sections that come after globals and refer to them, and ones before can’t.


CW: Data after globals, 

AR: all of them can refer to all of globals. Are tables after globals? 

AR: Are tables after globals?

CW: they seem to be after globals.

AR: not sure why.

AR: There seems to be no way around us relaxing this order..

CW: the table section just declares the types of tables. Would there be need to refer to globals there?

AR: Not right now, but with reference proposal there will be a default element defined there. In the tables section, we shouldn’t mess up the ordering but that’s a separate discussion for later. Only comes with the GC proposal later

RH: something like this does seem inevitable but i’d still prefer to deal with it later and just handle the current issue.

BT: Since we’re only talking about using globals at start of global initialization, it doesn’t restrict what can be in the global initializer

CW: nor at the level of instructions but it might affect which globals can be referred to.

BT: Global initializers are separate than the table offset

AR: offsets only appear in segments, not in table definitions. They go after globals.

CW: The problem with the tables will be the non defaultable types, but that’s something for the GC proposal to work out.

AR: yeah. Technically we could already discuss it in the funcref proposal but it’s just not pressing enough there.

CW: We have time for bikeshedding, in the long term should we have table initializers after the global initializers?

AR: I think the general fix is just relaxing the section ordering and allowing repeated sections. It’s come up so many times that I think we’ll have to do that.

TL: Not to get into a big discussion right now, we can introduce new section types that allow separate declarations/definitions

AR: That's more complex though because you have to define what it means to use something. Is it enough to have a declaration or does it have to go after the definition. It would make a difference what kind of use it is. We discussed that before but after some thought I decided it didn’t seem like a good idea.


TL: We should keep it on the table and discuss that more, the arbitrarily ordered section have overhead for producers, theyd  probably have to construct a DAG etc, which is more complex than right now

CW: Relaxing sections vs. repeating sections could that be a non-controversial thing to do right now

TL: you can get into situations where you need to merge

AR: For most sections relative sections don’t matter. You could reorder based on abstract dependency ordering

CW: Assuming such ordering exists, we should make sure that whatever relaxing we make, we don’t make that ordering not exist

AR: you can still define a total ordering that always works and your tools would use that

TL: Ideally we want to be where we don’t have such an ordering. We have uses where we can refer to globals fro mseg initzilizers, and also for referring to initizliers from globals. So we want to be able to support cycles.

AR: Then we really want repeated sections, otherwise you can get into a world with cycles which is bad

BT: I think we should just bite the bullet and do repeated sections. In wizard I had to refactor the code for it but it ended up better. It made it easier where you just an have as many sections as you want.

AR: I agree, but also see TL’s point but you would still have to compute the dependency upfront, but probably not too hard

TL: I’m willing to be convinced that repeated sections is better, but from what I’ve worked on it doesn’t seem like it. So we should at least discuss it more.

AR: General opinion is to avoid recursion when you can
AR: but getting back to the original issue, it sounds lke we’re on the same page wrt fixing the spec to match the implementations? I have PRs already for that, so can we just merge it?

<no objections raised, consensus is unanimous>

DG: any other comments?

LW: Somewhat against later repeated sections, working through module linking, came around to being in favor of repeated, but acyclic sections, then hopefully sometime when we get module linkling in the core spec, that’s something we would need

AR: the mutual recursion already comes up if we have type imports, since they will be recursive with type definitions. That will get ugly if we don’t have dependency ordering.

BT: Exactly why I needed to implement repeated sections

TL: Are we going to get where the ordering of types in the type section is overly constrained? There are some now, and if we impose additional constraints about interleaving with other sections, could we be in a situation where there is no correct ordering?

AR: That could only happen if you wanted some kind of recursive type that refers to an import or vice versa, which is something the current semantics won’t be able to support anyway, we are weaker than what equi-recursive types would support anyway. Theoretically that could happen

LW: seems nice if the general rule is that definitions are acyclic. And then if there are exceptions we call them out specially and make sure we are careful about it, the way we do with isorecursive.

TL: No reason to hold the meeting up for these brain teasers


AR: it is relevant. With module systems if you want recursive modules and want to instantiate something whose type depends on [the imported?] module, but then you are also into recursive modules, where you don’t want to be anyway.


"
main/2024/WG-06-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the 2024-06-12 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: 2024-06-12 at 15:00-16:00 UTC *( June 12th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
   1. Next (final??) steps / vote for releasing Wasm 2.0
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

## Meeting Notes

### Attendees

 - Mike Smith
 - Derek Schuff
 - Luke Wagner
 - Thomas Lively
 - Ms2ger
 - Andreas Rossberg
 - Bailey Hayes
 - Ryan Hunt


DS: Previously we talked about what it would take to move the current spec to a CR, and worked out some publication pipeline issues on our end.  I found https://www.w3.org/Guide/transitions/?cr=draft&profile=CR listing requirements.
 
MS: https://www.w3.org/2023/Process-20231103/#transition-cr is the normative document. The other has an amplified checklist that expands on the normative requirements.
One thing I’m unclear on, is that I noticed that we must specify a deadline for comments. As far as I understand, we can keep the document in CR forever. We have this idea of  evergreen CR, which means we just assert that we don’t plan to take the document to REC status. In that case, I think that we don’t need to provide a date for when we transition out. I’ll have to ask about the details for that.

AR: Can we just make up a deadline as a fallback?

MS: right, if we do state a deadline it just needs to be 28 days out. In the first doc, I don’t see anything about the date in there. So either we omit it completely or just set some arbitrary date.

AR: Whatever is fastest.

MS: all that said, the thing that is required, the group has to be explicitly asked in some way. However we record formal decisions from the group. Send out a notification, give 2 weeks for objections, and say silence is agreement. But we do have to give the opportunity to express support or objections.


DS: We typically record formal decisions in the meeting notes, so maybe we'll just copy and paste those.

MS: one other thing about the decision: if you look at the charter wording, it we have boilerplate language about this:

> ""To afford asynchronous decisions and organizational deliberation, any resolution (including publication decisions) taken in a face-to-face meeting or teleconference will be considered provisional. A call for consensus (CfC) will be issued for all resolutions (for example, via email and/or web-based survey), with a response period from one week to 10 working days, depending on the chair's evaluation of the group consensus on the issue.""

So it seems like we do have to do that, according to the charter requirements. We can only provisionally make the decision here.


MS: another thing I’m remembering, why this is important, why a member org might want to object (even unlikely), is that when we transition to CR it triggers process steps around patent disclosure opportunities. So it may be something that lawyers at companies might want a heads-up about. I’m not sure but I’ll look for that right now. If so, that’s why it would be important that all the member companies know what’s going on.

AR: Do we have obvious owners for all steps that need to be taken?

DS: so, a list of the steps:
CfC: DS
2nd notification: DS
...

DS: Actually, can we put the implementation experience documentation in the notice? Mike, what form do the implementation experience and notifications take?

MS: we do write the text in the formal transition request that I would send to the director (now we have a different org structure) but I send the formal request, but that’s the only place we need these details. I’ll just copy from where I’ve done it before. There are no requirements for what we send out to the group. Something like, does anyone object to transitioning to CR. there’s boilerplate there too making it clear that if there are no objections, silence is  taken as agreement. Other than that, no requirements.

DS: Does that go in the CfC or the second notification?

MS: There is only one that goes to the group: the CfC. Could be just one or 2 sentences

AR: After these two periods are over and it's in CR, we're done? Or is there something else after that?

DS: My understanding is that we want to stay in the permanent evergreen CR state.

MS: and in that case theres nothing more as far as formal requirements

MS2ger: so after that, do we push directly from CI for every change?

MS: right we don’t have to do working drafts, we have a TR document just like we do now, and continuously update it. There’s no process for publication, limitations that prevent us from doing that.

AR: the only reason we might want to do versioning, we can discuss that another time.

MS: yeah the versioning thing can be kind of a pain, just for those of us that have to deal with the publication, that’s a one time cost, just making sure we have the old spec in the right  place, the frozen version at whatever point we freeze it, and getting it updated.

TL: IIUC it was the TR that we just push to continuously from CI, but it’s the CR that’s this evergreen thing. How do changes get into the CR?

MS: The CR URL is the same as the TR, we don’t change it. We have 2 things: these dated versions (i.e. there’s an actual date substring in the URL) but the tr/wasm-{version} is essentially a symlink to some dated version, so that the URL doesn’t change when the dated versions change but the contents change

TL: so the whole notification thing, we do that once, and then we change the contents as they come in.

MS: exactly.

LW: The CR URL has the version number ""2"" in it, right?

MS: right, if we’re versioning then that’s what we do. Call it 2 and that’s something I’ll talk with the person on staff, that’s the one thing in I can’t do myself, there’s just one person who updates things in the tr/ space, i can request that the URL gets set up, as a one-time thing

LW: To Andreas's point, if we wanted to switch the version to 3, we would have to go through the process again to get a new URL with a ""3"" in it. Is there anything we should do to get the number just in the doc instead so that we can live push version changes in the doc without going through the process?

MS: we can do that. We have tr/wasm but actually looking at that right now, it doesn’t exist. Everytime it’s been published, its with a version substring

LW: so we could make the unversioned URL be the evergreen URL?


MS: we could do that. It’s a WG choice if we want that unversioned substring to point to the latest version. BTW are we only transitioning the core spec (not JS API etc?)

AR: All of them.

MS: Ok, we can do the same for all of them. We have to make it clear in the process precisely which documents are going to CR.

Ms2ger (chat): https://www.w3.org/TR/wasm-core/

LW: from the link in chat, there is an unversioned TR link. Do we just get an unversioned CR link?

Ms2ger: All specs are under TR/. There is no CR/.

MS: “TR” just means “technical report”. you can just think of “TR” as shorthand for “standard” it’s just wan abbreviation we use for standards, there’s no CR URLs. I was just looking for e.g. wasm-core. So we do already have these unversioned URLs and we can indicate to W3C where we want those symlinks to point to.

DS: it sounds like we do want to use the unversioned link then, right?

[general agreement]

DS: OK.

TL: if the URL always has TR in it, then if we go to CR, the doc just says that somewhere?

MS: yes. This is an implementation detail, but we don't need to manually change anything because the generator that adds the boilerplate also adds the ""working draft"" or ""candidate recommendation"" or whatever string.

AR: so when we go to evergreen, we should change it to no longer say “working draft” but make it say “canidate recommendation” to make the status clear?

MS: yes.

AR: do you do that manually?

MS: we can. I forget whether bikeshed does it automatically, but you can just set a status field and bikeshed just spits it out the right way.
Btw to what TL just asked: bikeshed does generate a dated URL for us. And it does include along with it, it’s prefixed with cr- it’s part of the path portion that comes after the tr. so something like tr/cr-{date} is what the symlink points to. So those dated URLs will be visible. Its just a thing that we flip a bit and the publication pipeline takes care of it.

AR: our makefile for the bikeshed target uses an environment variable? But I don’t see where that gets defined.

MS: I think that's something I messed around with. I was setting that environment var manually. Can't recall why I did it that way. We could hard-code it in the makefile.

AR: it makes sense to have it as a variable, but maybe we want to define it in the makefile.

MS: I will go in and try it. I don't remember why it's that way.

AR: what are valid values for status then?

MS: ""WD"", ""CR"", and ""REC"" for groups that want to go to recommendation. Also ""LS"" and maybe ""LS/CR"" or something like that. These are discrete values that bikeshed recognizes. I can check on that.

AR: What is LS/CR?

MS: LS is for living standard. If it exists, LS/CR means evergreen candidate recommendation. That's what we would want to use.

AR: i see in the workflow file you set the actual value includes “WG”

MS: Not sure why it's in the workflow file instead of the makefile.

AR: i can play around with it and see what happens. So if we try to clobber the link for the live standard in the future, we have to figure out some way to doing our internal version independently of the W3C versioning. Before we thought we might want to use a minor version, but maybe we want to bump the major version without interfering with the W3C process. For that reason it makes sense to have an unversioned link as well. We can hide away the W3C version as much as we can.

MS: right. Part of that the W3C  publication process is agnostic toward but we care about that internally, but the only people who have to deal with that would be you and i and whoever is working on the publication steps. It’s just a one-time process to figure out what we want.

AR: Ok, to make sure everything has an owner: I will investigate the status parameter in the makefile.
MS, can you look into updating the unversioned link?

MS: i can talk to our publication person about that. I’m looking in the bikeshed doc now, not sure I can link but if you look at the part that says “statuses useable by W3C groups” there’s no CR/LS, there’s only CR and CRD. I think we just want CR.

AR: what’s a “proposed recommendation”?

MS: That's another thing we don't have to care about unless we're going to REC. There's a small transitional state between CR and REC. I can’t recall why it’s that way but we don’t need to use it.

DS: Ok, we have owners for the status and links. And I will send the CfC notification.

Poll to send the current wasm 2.0 spec (including the JS API and web API specs) to CR, with intention to use as a living standard.

SF: 6
F: 1
N: 0
A: 0
SA: 0



DS: I realized yesterday that we have a bunch of proposals in phase 4, and there's nothing stopping us (the WG) from voting them to phase 5.

AR: FWIW I've had a branch called wasm-3.0 that I've been using as a staging ground for merging these proposals. I've been waiting on pushing 2.0 out.

DS: We can advance to phase 5 independently and before actually doing the merge. I will put that on the agenda for next month.

AR: one thing I’d point out there is that most of the stage 4 proposals are in a state where i can merge them other than threads, there’s a little work left. So maybe we don’t propose that one for stage 5.

That was a last-minute thing that we moved it phase 4 and it was a bit premature.

TL: if we care about not moving things that were maybe premature to phase 5, with tail calls I believe that it came out that the 2nd implemetation isn’t quite complete. But the spec is fine.

AR: i believe the regression has been fixed. I think they re-shipped tail calls so we should be in good shape.

TL: Cool, I missed that update.

RH: i’m also pretty sure that spidermonkey has tail calls now, so we should be fine.

LW: There's going to be an unversioned URL and we're going to push the versioning into Wasm. We were originally going to do minor versioning, but had to move to 2.0 because of W3C process. We could go back to minor versioning now since we're not breaking things. We have 2.0 out and Andreas has been saying ""3.0"" a lot, so there would be some walking back, but it's worth thinking about.

AR: I don't know… we’ve been calling it that for a long time, it would be quite confusing, and I’m not sure it would be buying us anything useful.

LW: the future is much longer than the past.

AR: it’s already embarrassing enough that it took so long, i wouldn’t want to walk it backward. What i would do instead is: it’s justified that it’s a major version because we merged so many proposals in.

I would suggest that we keep bumping the major version when we merge ""gamechanger"" proposals like SIMD or GC. It's so much clearer if you can say ""wasm 1, 2, 3"", etc.

LW: I guess it depends on how much semver has gotten into people’s thinking. A lot of people thing breaking changes when they see major versions

AR: In a way it is breaking because it changes some properties of Wasm…

LW: from a browser perspective it’s not breaking

MS: there’s no limitation on the W3C side that would prevent the group from doing dot versions. The URL would have to be -11, we can’t put a dot in there. I’ve never done one with dotted versions,

AR: i would stick to the unversioned URL and make that orthogonal to this discussion

LW: Right, I like the unversioned URL. It's just how communicate about versions in the CG.

DS: The downside of major+minor versions is that we then have to argue about what's a big enough change the major version. I would favor minor versions over major versions (or just going to integer versioning), but not a strong opinion.

MS: In the body of the spec, it says 1.0. In Wasm 2.0, we could just put ""2"" there instead of ""2.0"" to avoid the appearance of semver.

LW: Let's think about that in the background.

"
main/2021/CG-09-28.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 28th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: September 28th, 4pm-5pm UTC (September 28th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Update on [Code Annotations](https://github.com/WebAssembly/tool-conventions/issues/167) (Yuri Iozzelli) [10 mins]
    1. Discuss [streamlined process for simple proposals](https://github.com/WebAssembly/meetings/issues/857) (Petr Penzin) [15 min] - [slides][ftpdf], [source][fttex]
    1. Update on [Relaxed SIMD](https://github.com/WebAssembly/relaxed-simd/) and poll for phase 2 [15 min]
    1. Update on [Flexible Vectors](https://github.com/WebAssembly/flexible-vectors/) and poll for phase 2 (Petr Penzin) [15 min] - [slides][fvpdf], [source][fvtex]
1. Closure

[ftpdf]: presentations/2021-09-28-penzin-fasttrack-proposals.pdf
[fttex]: presentations/2021-09-28-penzin-fasttrack-proposals.tex

[fvpdf]: 2021-09-28-penzin-flexible-vectors-update.pdf
[fvtex]: 2021-09-28-penzin-flexible-vectors-update.tex

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

###  Introduction of attendees

Igor

Dan Gohman

Yuri Iozzelli

Francis McCabe

Petr Penzin

Chris Fallin

Conrad Watt

Derek Schuff

Deepti Gandluri

Mingqiu Sun

Alex Chrichton

Saul Cabrera

Jacob Abraham

Zhi An Ng

Steven Prine

Ryan Hunt

ALon Zakai

Nick Fitzgerald

David Piepgrass

Rick Battagline

Paolo Severini

Heejin Ahn

Adam Klein

Shravan Narayan

Lars Hansen

Peter Huene

Andreas Rossberg

Jakob Kummerow

Daniel Miller

Luke Wagner

Sean

Emanuel Ziegler

Nabell Al-Shamma

Rich Winterton

Ethan Lee

Ben Titzer

Sam Clegg

Ross Tate

Bailey Hayes

Zalim Bashorov

### Find volunteers for note taking

Acting chair to volunteer

### Proposals and discussions

#### Update on [Code Annotations](https://github.com/WebAssembly/tool-conventions/issues/167) (Yuri Iozzelli) [10 mins]

YI presenting [slides](https://drive.google.com/file/d/1DC4iLQMT9m7MLqdAq6IZFwXmxJtCjgDN/view?usp=sharing).

AZ: does offset 0 mean the function itself, so we could annotate functions?

YI: yes

RW: from instruction tracing POV, this makes sense, I like this.

YI: Since branch hunting and IT are similar proposals, it makes sense that we are on the same page, and can continue to work on it

TL: I’m also eager to use this for non-standards-track annotations in LLVM, that would be useful.

BT: Looks good, we had discussed some time ago about constant-time wasm, and there were new instructions proposed there, BH does not include new instructions but maybe we should add a note of what is added/excluded in this proposal. May make sense to have a discussion, and document when we use this mechanism, vs. something else. 

YI: I think for CT, the space ovhearhead would be high, there would be a lot of annotations, i think we can think about having a guideline on when to use it and when not.

BT: Makes sense, thanks

RW: I’d be interested in understanding the guidelines a bit more when we get there. There could be variants of SIMD instructions, maybe rounding or differences between different architectures might go into this kind of section.

AR: One criteria - only stuff that doesn’t execution semantics should go there, anything else should be more explicit, and not be in a custom section. 

CW: I think as a general rule, some optimizer that doesn’t understand the custom section should be comfortable throwing it away

DS: LLVM has a similar construct - metadata, their guidelines are that a pass that doesn’t understand the metadata “must” throw it away. We can’t necessarily mandate that tools do that but we should provide similar guidelines. 

YI: we can use the same language in our guidelines

AR: ct wasm also doesn't affect execution semantics, but it is supposed to affect validation, but you can make that option i guess, so it could still be a custom section in a way

CW: It’s an example of a borderline case, how wide do you expect the semantic guarantees tobe? Constant time is a guarantee that some semantics are preserved, and it might be unsafe to not preserve them. 

BT: my reasoning is that all execution tiers need to look at those annotations, otherwise the engine is wrong, doesn't preserve the security properties. for interpreter, it's nice to be in bytecode so you know you need to implement constant time instructions there

#### Discuss [streamlined process for simple proposals](https://github.com/WebAssembly/meetings/issues/857) (Petr Penzin)

PP: Do we need this? 

AR: this sounds like the simplification would mainly be collapsing some of the phases. That might not require something new, could we just allow proposals to advance 2 phases at once. Other than that, have you looked at actual criteria that could be removed for simple ones? I’m not sure there are real ones that can be skipped (other than ones that obviously don’t apply to a particular proposal). 

LH: This came up because I was trying to hold up the relaxed-simd proposal because proposing a new instruction and getting it through the process is a heavy weight process, and for an already established framework, we can make the process more lightweight and not have to go through the multiple steps would be nice

AR: moving faster definitely makes sense. My question was really, is there anything else, and if not, do we need to do something concrete, other than have general agreement that we can move faster for appropriate proposals

DG: what is the accepted framework where we decide to even move faster? Even to move to phase 2 we need design consensus, e.g. is it a good instruction even to add (for SIMD)?

AR: isn’t it enough just to say, we are here now at phase 0 but we have all the deliverables for phase 2, why not move directly if the requirements are there? It’s a judgement call if the proposal is simple enough, but it could be case-by-case. But it seems enough just to have all the requirements so we can just skip phases.

FM: when someone makes a presentation, they can propose to skip a number of phases, and justify it

PP: do we want to have limits on this? If we want to skip, say, phase 3, would that be ok?

FM: If someone wants to skip, they can propose and justify and we could vote. 

BT: wouldn’t that justification just consist of meeting the requirements? They all have to be met in the end.

FM: someone in the group proposes, and someone disposes

AR: There’s nothing in the process that requires having time intervals, you can ask for phase 1,2,3, whenever, but the CG can decide whether we have consensus and whether we have an obvious improvement.

BT: one thing that might be interesting: we should have records of when each proposal advanced, so we should have data about how long each proposal speds in each phase, and see if we have a bottleneck

TL: last time we promoted a small trivial proposal was probably years ago, sign extension instructions. At a high level, recently we haven't tried advancing a tiny proposal through the phases. We have experience with phases being heavyweight, because in recent memory all the proposals are heavy. I will be interested to see someone try to push a proposal as quickly as possible, see how it performs under certain guidelines. Then we have concrete but anecdotal evidence on how to make adjustments.

DG: I think even the written guidelines haven’t changed since then. We could just add a note to the doc saying that you can actually propose more than 1 at a time. We could just have something to let people know that it’s ok, and try it out with a small proposal.

LH: that sounds good

DS: anyone has concerns about this, if we shouldn't make a note like what we discussed?

<No objections>

#### Update on [Relaxed SIMD](https://github.com/WebAssembly/relaxed-simd/) and poll for phase 2 [15 min]

ZA presenting [slides](https://docs.google.com/presentation/d/12QU5Jb2BXvPmhkLWlI2-1XDzVVDzSlLwJIkCGucxPMo/edit?usp=sharing)

AR: They don’t exist on other platforms, web not the only platform

ZA: That is true

CW: Surprisingly powerful based on the problem statement described earlier, this means that different environments can describe different fpenvs, is there a use case for that? 

ZA: Distributed over different arches/engines and you could have different fpenvs, not immediately useful but there are different 

CW: when I heard that the point of this is that youll target instruction sequences that are small but might have different outcomes on different architectures. It sounds like the motivation for fpenv is to guarantee that 2 different instructions have the same output? Is this for optimization?

ZA: Two different instructions have the same output, when the same inputs if they have the same fpenv, it’s to prevent something funny like this example happening <consistency slides>

TL: it’s basically to help programmers reason about what will happen and give a stronger guarantee than “it willbe nondeterministicn every time you call it”. For systems that migrate workloads across systems, they will have to check that they don’t move workloads across architectures if that will violate the way the fpenvs are used. A pure function can be pure and always return the same result.

BT: Is the rounding mode going to be a part of this env? Or will it need something different? 

ZA: Right now no, rounding mored are still non-deterministic

RT: i would describe that the instructions are underspecified but determinized by an an external environment,

ZA: yea, the instructions are non-deterministic until the module is instantiated.

AR: The code mobility usecase confused about it, it wouldn’t give the same output anyway

TL: this is for engines that transparently migrate workloads without re-instantiating.

BT:  Not the same fpenv they instantiated on?

TL: yes or just not move code to environments with inconsistent behavior.

AR: In that case why would you need the fpecnv anyway?

DG: it tells implementations when they can and can’t move things in this way

CW: You could have the same result by underspecifying the instruction in the spec

DaG: a more helpful use case could be tiling a large image, maybe you don’t care about the exact mode, but you don’t want to have visible boundaries where they change

AR: I’m still confused, the assumption seems to be that within the same engines this could give different outputs for different environments in the same engine

BT: one use case might be GPUs, they might put a kernel onto a GPU

CW: you’d need an explicit fpenv if you have more than one, or swap them out. Unless you need to make it explicit which version you’re relying on, i don’t see why you’d need an explicit fpenv

BT: You can specify in different pieces of code that pieces of code need to be self consistent but they can be different.

ZA: The union of consistency needs to include a module, fpenv is the way we want to say that we have consistency, we want to have some sort of environment/module but we don’t have a way to say that right now  

CW: that sounds like a problem of the language of the spec, to say what needs to happen in a particular environment

AR: It makes sense if you want to allow multiple behaviors within the same engine - this is the right design - if you want to see different realms of behavior to coexist.

CW: Doesn’t sound like any examples so far need this feature

AR: if you allow multiple realms, you’d want to allow a module to have more than one, otherwise they aren’t composable. I just don’t know why you’d need to have more than one at a time.

TL: The plan of record is to have the linker produce a simple fpenv for the output module, and not import/export. In the future, in other toolchains may have more flexibility

BT: would it be reasonable to just say we have a 0 byte in these instructions, and extend it in the future?

CW: I guess that could work for now, that would mean that the default byte would be implicit, and the others would be explicit

RT: we can argue whether this is necessary, but is there a problem with doing this?

CW: it’s not idiomatic, we should have a reason why we’re having this explicit environment

BT: I can see the use case, but is it necessary, can we add a zero byte? And extend it in the future.

DG: It captures the intent of the odules, especially with shared nothing module linking, they don’t have enough information about the modules

LW: if we didn’t have this feature, when you statically link modules, they get the same env. I still don’t really see a use case where when modules call each other synchronously, they need to have different fpenvs.

ZA: Went over the allocated time, will take an AI to capture more concrete motivation and report back to the group.

#### Update on [Flexible Vectors](https://github.com/WebAssembly/flexible-vectors/) and poll for phase 2 [15 min]

DS: Length of vector determined statically, there is a kind of non-determinism, at the time of compilation we don’t know what the vector length will be, so would it be useful to have an fpenv type of construct here as well? 

PP: I tried to avoid the kind of behavior we have in relaxed simd, I don’t know how you’d be able to mix things. I don’t think this is an MVP feature. I’d consider something along the lines of fpenv to be a future thing

CW: would this be another case where you’d add a 0 now and possibly an fpenv later then?

PP: Open to adding it, if you’re talking about vector lengths exclusively - in theory we could add to other instructions as well.. It’s a good question. Leaning against adding it as a first cut, but can discuss further

BT (chat): Seems like there could be space for a mechanism for different kinds of “envs”

TL: i do think the abstract problem of having a hardware environment determining part of the semantics is similar. So I think it would be good to have a consistent solution for that

PP: Don’t agree that we have to tie the semantics together, not the same thing

TL: is there any way in this proposal to observe the vector length?

PP: you can run some values and see how many have changed, it is observable in the same “fingerprinting” sense.

TL: similarity between this and fpenv is an observable value (a non det SIMD, or vector length), as long as there is a way to observe that, you have a non-deterministic value.

PP: the intent is different. The intent is to make users write algorithms that are agnostic to the vector length, and make them universal. So someone would run the same code on both architectures.

AR: You still have to distinguish between language semantics, it’s still observable that there is some heavy non-determinism here and is similar to the relaxed-simd case, it kind of leaks through the hardware

BT: is it the case that the only variable is the vector length? Or are there other things?

PP: yes, just the vector length

AR: It seems like accessing a lane takes a static lane index, if I don’t know how many lanes there are, how would I access a lane? 

DG: what kind of workloads will you be measuring this on? when it comes to wider vectors, a concern is e.g. alignment requirement. What will benefit from flexible vectors?

PP: the same things you’d use AVX for, e.g. image processing
DG: if we could call out the performance guarantees we are giving, right now it’s not clear, it could even vary on dfiferent Intel hardware. So it would be useful to say what kidn of performance we’d be providing.

DP (chat): Note that this proposal is very similar to what .NET did, which is has been in production for years. My impression was that the main problem with the .NET approach was that very few platform-independent operations were available for variable-size vectors, but the idea of variable size vectors is still, I think, a good one.

### Closure
"
main/2017/CG-10-17.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 17th video call of WebAssembly's Community Group

- **Host**: Google Hangouts
- **Dates**: Tuesday October 17th, 2017
- **Times**: 9:00am–10:00am Pacific Time
- **Location**: *same Google Hangouts link as before*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

None required if you've attended before. Email JF Bastien to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. [Versioning of external standard dependencies](https://github.com/WebAssembly/spec/issues/566) (Andreas Rossberg).
    1. Create new github.com/webassembly/workloads repo?
       1. We're all probably over-specializing on Tanks just because it's the easiest workload to run a quick experiment on.
       1. It seems useful to provide a common place to collect large test workloads that we keep up-to-date:
           1. Should test realistic paths through real codebases
           1. Load-time and throughput measurements
           1. Include source files if possible and link to author
           1. Updated as toolchain or codebase is updated, so always on the recommended path
           1. Primarily for engine and toolchain engineers to test and guide optimizations
           1. Non-goal: official ""wasm benchmark"" with overall ""score""
       1. Two initial workloads to seed the repo:
           1. Unity: https://files.unity3d.com/marcot/benchmarks/
           1. Godot: http://godot.eska.me/pub/wasm-benchmark/
       1. Polls:
           1. POLL: create 'workload' repo with abovementioned goals?
           1. POLL: seed with above two workloads?
    1. Web platform test repository, discussion, and poll (Ben Titzer).
       1. Background: The [Web Platform Tests repository](https://github.com/w3c/web-platform-tests) is W3C-coordinated attempt to build a cross-browser testsuite for the Web-platform stack. It incorporates tests from many sources and offers, for example, a two-way sync feature between the Chromium repository and WPT in an effort to make it much easier to expand the WPT tests. The WPT effort would like to incorporate as many WASM tests as possible and run them in a cross-browser fashion, and make it easy to add tests.
       The issue is complicated by a build step that is necessary, since WASM spec tests are almost all written using the text format, which requires translation to binaries and JS files for running in engines that have a JS embedding.
       1. Discussion of proposals
           1. Preserve status quo, add additional mirroring in WPT of WASM spec repository
              1. WASM spec repo continues to be source of truth
              1. 1-way sync WASM spec -> WPT (automated)
              1. Enforce no-editing in WPT mirror of subdirectory
              1. Wasm participants can land spec tests. PRs welcome from browser engines.
           1. Change status quo, spec repo continues to be the source of truth
              1. 2-way sync of spec repo into stand-alone engine repos V8/Chakra, and browser engines Firefox/JSC.
              1. Running Ocaml conversion etc. requires a pre-submit step done by committer, with output included in the commit.
              1. V8/Chakra/SpiderMonkey/JSC contributors can land spec tests (in their home project repos, or in the spec repo directly)
           1. Change status quo, WPT becomes the source of truth
              1. Build a 2-way sync between V8 + Chakra for a slice of WPT (reuse existing mirror for others)
              1. V8/Chromium/Chakra/SpiderMonkey/JSC contributors can land spec tests (in their home project repos, or in WPT directly)
              1. WASM spec changes must include a spec branch/PR and a WPT branch/PR
           1. [Detailed (v8 specific) doc](https://docs.google.com/document/d/1FEjBpsIj1vu5ZUJI6ki6xKBFIijxlPj_rQmsucMMQrg/edit#)
       1. Poll on proposals
           1. POLL: Tests contributed to the WASM spec repo should receive review from core contributors. 
           1. POLL: WASM should maintain the source of truth by having compliance tests in the spec repo, as today.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Dates and locations of future meetings

| Dates                    | Location          | Host       |
|--------------------------|-------------------|------------|
| 2017-11-01 to 2017-11-02 | Santa Clara, CA   | Intel      |
| 2017-11-06 to 2017-11-07 | Burlingame, CA    | TPAC       |

## Meeting notes

### Roll Call

* Arun Purushan
* Ben L. Titzer
* Benjamin Bouvier
* Bradley Nelson
* Dan Ehrenberg
* Deepti Gandluri
* Derek Schuff
* Dru Knox
* Eric Holk
* Heejin Ahn
* JF Bastien
* Jacob Gravelle
* Keith Miller
* Kyle Buzby
* Limin Zhu
* Luke Wagner
* Malcolm White
* Mark Miller
* Michael Ferris
* Michael Hablich
* Michael Holman
* Paolo Serverini
* Patrick Hickey
* Peter Jensen
* Sergey Rubanov
* Tyler McMullen
* Winterton Richard
* Yury Delendik

### Opening

### Adoption of the agenda

Seconded by Brad.

### Proposals and discussions

#### Versioning of external standard dependencies

*Andreas Rossberg presenting*

[Issue](https://github.com/WebAssembly/spec/issues/566)

We depend on IEEE 754 and Unicode. How do we reference external standards that we depend on, and which have versions? For both we don’t really rely on what has changed or is likely to change in the future.

1. Without a specific version, always applying the latest.
2. Pinned to an exact version.
3. Pinned to a minimum version.

JavaScript recently changed from minimum to latest version of Unicode. AWB told Andreas some history, see issue for details. It’s easier than updating Unicode every year for new emojis. There’s a feeling that referencing a specific version means it should be up to date. There’s a recommendation by Unicode and ISO that recommends no version, but AWB didn’t provide the reference. Andreas found a reference in Unicode, but it seems different and they seem to say that for a case like ours we want the minimum version approach. But it’s also very vague.

For Unicode we only depend on the range of code points (21 bits plus the gap), and UTF-8. For the text format we depend on the ASCII subset of Unicode. Andreas thinks 21 bit and UTF-8 as added in Unicode version 3 as far as he can tell, maybe that should be our minimum. Specifically, if new emojis come in or any new codepoint gets a meaning is totally irrelevant for WebAssembly (other than for the text format). Dan submitted pretty substantial tests for Unicode and UTF-8 to the spec test suite.

IEEE 754 sees less churn. Current version is 2008. Andreas doesn’t think that we depend on anything new from 2008. Dan points out that a new one might come in 2018, Andreas doesn’t think we’ll need anything from it. Dan had mentioned some changes in minnum / maxnum, had we adopted them that would require more thought from us.

The group doesn’t think that breaking changes for WebAssembly are likely in either standard (Andreas / Ben and others).

**Consensus to float the Unicode version to latest, and pin IEEE 754-2008.**

We’ll revisit when IEEE 754-2018 comes out.


#### New github.com/webassembly/workloads repo

*Luke Wagner presenting*

       1. We're all probably over-specializing on Tanks just because it's the easiest workload to run a quick experiment on.
       1. It seems useful to provide a common place to collect large test workloads that we keep up-to-date:
           1. Should test realistic paths through real codebases
           1. Load-time and throughput measurements
           1. Include source files if possible and link to author
           1. Updated as toolchain or codebase is updated, so always on the recommended path
           1. Primarily for engine and toolchain engineers to test and guide optimizations
           1. Non-goal: official ""wasm benchmark"" with overall ""score""
       1. Two initial workloads to seed the repo:
           1. Unity: https://files.unity3d.com/marcot/benchmarks/
           1. Godot: http://godot.eska.me/pub/wasm-benchmark/
       1. Polls:
           1. POLL: create 'workload' repo with abovementioned goals?
           1. POLL: seed with above two workloads?

* JF played with Unity benchmarks. Very modal, high variance, and measures WebGL 2 with fallback to WebGL 1. Luke says Jukka has a stripped down version, agrees we’d want to not draw.
* JF asks if we want all of these to be runnable without a browser, in say the reference interpreter. Is that a goal, or do we rely on non-browser people to contribute such measurements? Luke thinks this would take much work, and might reduce the thing we’re measuring.
* Titzer asks if we’re trying to attract workloads. Open the floodgates. If they’re not relevant or too say WebGL then we’d remove.
* Derek: should we require source? Once we change toolchains, have threads, etc, we’ll want to reflect the new compilation patterns. I want to use it to benchmark my toolchains too.
* Titzer: we can even check in older toolchain-compiled versions.
* Derek: we can also allow some binary things that are critically important.
* Brad: should we care about licenses?
* Luke: we should ask for sufficiently permissive license. Sub-directories, separate licenses, readme to build and point to author, etc.
* JF: any non-browser people interested in measuring or uploading workloads?
* Pat (Fastly): doing non-browser, maybe 6 months from being able to contribute workloads.

*Unanimous consent for Luke to create repo, create PRs for README, Godot, and Unity-lite*


#### Web platform test repository, discussion, and poll

*Ben Titzer presenting*

       1. Background: The [Web Platform Tests repository](https://github.com/w3c/web-platform-tests) is W3C-coordinated attempt to build a cross-browser testsuite for the Web-platform stack. It incorporates tests from many sources and offers, for example, a two-way sync feature between the Chromium repository and WPT in an effort to make it much easier to expand the WPT tests. The WPT effort would like to incorporate as many WASM tests as possible and run them in a cross-browser fashion, and make it easy to add tests.
       The issue is complicated by a build step that is necessary, since WASM spec tests are almost all written using the text format, which requires translation to binaries and JS files for running in engines that have a JS embedding.
       1. Discussion of proposals
           1. Preserve status quo, add additional mirroring in WPT of WASM spec repository
              1. WASM spec repo continues to be source of truth
              1. 1-way sync WASM spec -> WPT (automated)
              1. Enforce no-editing in WPT mirror of subdirectory
              1. Wasm participants can land spec tests. PRs welcome from browser engines.
           1. Change status quo, spec repo continues to be the source of truth
              1. 2-way sync of spec repo into stand-alone engine repos V8/Chakra, and browser engines Firefox/JSC.
              1. Running Ocaml conversion etc. requires a pre-submit step done by committer, with output included in the commit.
              1. V8/Chakra/SpiderMonkey/JSC contributors can land spec tests (in their home project repos, or in the spec repo directly)
           1. Change status quo, WPT becomes the source of truth
              1. Build a 2-way sync between V8 + Chakra for a slice of WPT (reuse existing mirror for others)
              1. V8/Chromium/Chakra/SpiderMonkey/JSC contributors can land spec tests (in their home project repos, or in WPT directly)
              1. WASM spec changes must include a spec branch/PR and a WPT branch/PR
           1. [Detailed (v8 specific) doc](https://docs.google.com/document/d/1FEjBpsIj1vu5ZUJI6ki6xKBFIijxlPj_rQmsucMMQrg/edit#)
       1. Poll on proposals
           1. POLL: Tests contributed to the WASM spec repo should receive review from core contributors. 
           1. POLL: WASM should maintain the source of truth by having compliance tests in the spec repo, as today.

* JF: Core and JS tests must still be runnable in a JS shell, as well as in a non-JS embedding. This is critical to fast VM iteration (both for our VM and non-web embedders). That doesn’t seem to be the case if we move to WPT. If this is the intent, the polls should be predicated on it.
* Titzer / Brad: agree on V8 side.
* JF: We’d like to understand how much slower tests will run with the WPT harness. These costs must remain low. Can you provide such comparison?
* Titzer: JS tests in wasm spec repo use same framework as WPT (was added by Mozilla). Wouldn’t be slower. For HTML it’s a whole-browser, so of course slower.
* JF: We want to reduce friction when adding WebAssembly tests and when importing them. It’s unclear at this time that WPT friction is low enough.
* Brad: intent is: commit to your own repo, and automation just pushes to WPT. Bots do the work.
* Andreas: that assumes infrastructure which isn’t there, policies, etc.
* Brad: some willingness on Google side for support. Attempting to use infrastructure to fix the problem.
* Dan Ehrenberg: the assumption is that there is infrastructure, otherwise two-way sync makes no sense.
* Mike Holman: I’m against 2-way sync into browser engines. I don’t want random tests to break Chakra CI. Adds overhead. Sounds way simpler if source of truth is spec repo. We don’t need all this sync.
* Brad: context for where it is used: a commit can come in to one browser and break others. Automation updates test expectation files so new, failing tests are disabled. Downside is auto turn-off, upside is no breakage. You do have to stay vigilant.
* JF: seems premature adoption of WPT a bit. Heard concerns about random people adding WebAssembly tests. Such a situation would indeed be very troubling. Is there a concept of ""owner""?
* Titzer: I’m personally for status-quo. If we need to pay people to write compliance tests I think it’s better. I don’t think tests define WebAssembly. Tests are often bugs that were found, not really defining compliance.
* Andreas: affects proposal process for evolving WebAssembly. Our current process involves forking spec repo, and adding tests there. It’s all worked on and committed together.
* Brad: maybe we can rule out discussing source of truth, and instead focus on sync?
* JF: It would be informative to hear why JavaScript’s own tests aren’t on WPT. WebAssembly being the new standard, We would rather follow the lead of JavaScript here instead of re-hash discussions that occurred in TC39. If anything WebAssembly is *less* “Web” than JavaScript is, so I’d think we shouldn’t be on the “Web” platform tests before JS? The WebKit team’s current position w.r.t. WPT applies to Web tests only. All things being equal we think being on WPT is good, but we also don’t consider WebAssembly and JavaScript as equal to other Web things.
* Dan Ehrenberg: JS would probably benefit from two-way sync; even though we have similar requirements to have conformance tests with proposals, these tests have historically had holes in them, which were filled in by individual browser tests and could’ve been upstreamed sooner with fixing other browser bugs faster, if we had two-way sync.
* Andreas: we can do things one at a time. Try to downstream to WPT, and see how that goes. Right now 2-way doesn’t solve a real problem, solution looking for a problem.
* Titzer: spec repo has reference impl and tests so that by design changes and bug fixes are tested as part of the process.
* Andreas: historically test262 was quite verbose, and people didn’t contribute to it. It’s not a good comparison, not about automation, just that test262 had too much bureaucracy.
* Luke: questions about 1-way sync. There’s wast, JS, and HTML tests? We already mocked wast running in WPT harness, that would still work?
* Andreas: yes. We also could just build the JS version in the test repo, and push it over the fence.
* Luke: we certainly need to keep wast tests, and the JS one. HTML ones I can imagine in different place, but I can imagine problems with a split source of truth.
* Brad: seems strong consensus to keep source of truth in spec repo.

**Unanimous consent to keep spec repo as source of truth.**

* Brad: I like that 1-way sync help us learn more.
* JF: review is already a thing we need to do for spec repo. Presumably new tests are covering missing things that are already spec’d, or something new being spec’d. Ownership is already part of our proposal process.
* Brad: maybe we want curated as well as un-curated tests?
* Titzer: we don’t have a reference interpreter for the JS embedding, so there’s a higher chance that engine quirks could leak into tests for JS embedding.
* JF: we’re over time, let’s continue that discussion at the in-person meeting hosted by Intel.


### Closure

*Adjourned*
"
main/2018/CG-07-24.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 24 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: July 24, 4pm-5pm UTC (July 24, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email JF Bastien or Ben Smith to sign
up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Discussion: C++ `volatile` in WebAssembly (https://reviews.llvm.org/D49194)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Andreas Rossberg
* Arun Purushan
* Ben Smith
* Ben Titzer
* Dan Gohman
* Deepti Gandluri
* Heejin Ahn
* Jacob Gravelle
* Jay Phelps
* JF Bastien
* Lars Hansen
* Luke Wagner
* Pat Hickey
* Peter Jensen
* Richard Winterton
* Sergey Rubanov
* Sven Sauleau
* Thomas Yeun
* Yury Delendik

### Find volunteers for note taking (acting chair to volunteer)

Pat this time

### Adoption of the agenda

JF seconds

### Proposals and discussions

#### Review of action items from prior meeting.

AI(Ben): Move import/export limit of 1,000,000 to an issue
https://github.com/WebAssembly/spec/issues/607

BS: I did this before but perhaps misunderstood the purpose of the item. I
moved it to the spec issue 607. Lars brought up that we need to loop in
implementers directly if we want to do this. I did talk to Kevin (Autodesk) who
was asking for a higher limit, he’s been working with Alon so maybe the limit
is not necessary. Hopefully he will follow up on github issue to see if that is
true. For implementers here: were there any issues with the 1 million limit?

JF: (inaudible)

BS: Lars said perhaps we want to file issues on implementers bug trackers, is
that needed?

BT: We’ll land our limits changes in one big chunk

BS: JF you were nodding along

JF: All implementers should be in this call, so they should be aware of the
change.

AI(Ben, JF): Create a meeting page on GitHub for TPAC CG

https://github.com/WebAssembly/meetings/blob/master/main/2018/TPAC.md

BS: If you know something you want to discuss at TPAC, file a PR or tell me the
topic and I will.

JF: Will Andreas be there? That will affect what we can discuss - he’s
championing some of the proposals

BT: The odds are 80% he’ll be there

BS: Action item to follow up with AR

#### Discussion: C++ volatile in WebAssembly (https://reviews.llvm.org/D49194)

BS: Idk if the CG is the exact right forum for this, but there’s been
discussion on the LLVM issue. JF or Dan can correct me if i make mistakes:

BS: Volatile as spec’d by C++ doesn't have anything to do (directly) with
atomics, some compilers have stronger guarantees about what it means than
others. What should WebAssembly do when you specify something as volatile? If
you drop the volatile, thats ignoring semantics the programmer may have wanted,
but we don’t want it to be stronger either.

JF: Volatile is used to make sure side effects are visible across
setjmp/longjmp (which we don’t have to worry about because of the way
javascript implements those), and also (missed it) and also shared array
buffers are not allowed to reorder volatile events. And then there’s a bunch of
misuses of volatile. When you put it in your source code, the compiler has to
touch every byte you said to touch. It can tear, it can’t be reordered, but
there is no fence between them. No fusion, elision, speculation. It is sorta
usable as a sync mechanism even though its not correct - guarantees effects.
With relaxed atomic you are not guaranteed the effects unless you synchronize.
If you want to preserve the basic semantics, we can lower to three things. We
can error out (very hostile), lower to nonatomic memory accesses, and lower to
atomic sequentially consistent accesses.

Nonatomic memory accesses can be elided and fused. Sequentially consistent
accesses is the closest we have.

BT: You said that every byte is touched, what does that mean in webassembly
memories?

JF: Touched just means you did a store instruction. If the volatile is bigger
than the store instruction there may be multiple stores. Sequentially
consistent is a stronger guarantee than needed but if you are really doing sync
you should be using different primitives.

CW: Is this a memory model question?

LH: For background: this came up with asm.js, spidermonkey hoists code out of
loops, if we strip volatile then it breaks a bunch of code. So we lower to seq
cst as well.

JF: That code is technically incorrect but we don’t want to break it if we
don't have to. We might add actual shared memory that has effect semantics in
wasm. We might add setjmp/longjmp or signals as well. If we strengthen the
guarantees that volatile gives us, we can't un-strengthen it in the future to
relaxed atomics - there’s () in c++ that has the same semantics as volatile
except it can’t tear.

CW: This code that’s being compiled that incorrectly is using volatile. What
guarantee are they relying on?

JF: on MSVC we might have been relying that volatiles are sequentially
consistent - that’s a guarantee that compiler makes and is available in LLVM by
an option. They may be relying that the effects are visible at some point.
There could be reordering or tearing by the hardware. Volatile is guaranteeing
that the stores occur. If those are in a loop you can't lift it out. There’s a
bunch of technically incorrect code that relies on this to work.

CW: If having the store be eventually visible is part of the guarantee of
volatiles, then it seems as though it wouldn’t be correct to lower non-atomics.

JF: visibility is not guaranteed but it will eventually occur. The store
instructions will happen “eventually”.

CW: “we” here is some combination of emscripten and binaryen.

JF: It could be a knob where the user can select the meaning of volatile, we
just want to figure out the default for emscripten.

DG: Clang has this knob already, it has independently determined that this knob
should be off by default. Why different for wasm?

JF: It has semantics in clang that it does not have in Wasm. The volatile stays
there in clang and will not hoist out of loops.

DG: The hoisting out of loops is the same for all targets -- it’s the same
optimizer.

LW: Within the wasm engine, browser-side.

DG: In llvm there is one ().cpp and if we set that flag it will turn volatiles
into atomics in the front end. If we don't do that the optimizer can do
different things.

LW: The ISA -- x86 won’t hoist stores out of loops, but wasm will.

JF: The wasm engine’s optimizer.

LW: Our ISA is a bit more aggressive than the physical one

DG: A guarantee that we never had, may break in wasm… in practice this usually
doesn’t break.

JF: The only valid thing to do to a volatile in a loop is to unroll the loop
and hoist all the stores out of it, then do all the stores then do the rest of
the loop. Nobody actually does this. Standard guarantees every iteration of the
loop, whatever you said to be touched, was touched once.

LW: To Dan’s question, the difference with wasm is that it’s a backend thing.

JF: Discarding the volatile flag means we’re removing semantic information that
the implementation may need when the optimizer looks at loops.

BS: Do we need an additional thing in wasm to express this?

JF: We do if we add setjmp/longjmp, or signals

BS: We could have an additional constraint in wasm that says ”dont hoist this”

BT: To meet the requirements of C++ you have to emit this constraint

DG: If we add signal handlers -- asynchronous or synchronous -- raising the
signal yourself or otherwise, then volatile may be useful, so we can guarantee
behaviors in wasm. Do we want to add this in preparation for the future if we
add this behavior.

JF: That's another option we didn't discuss, we could do it but I’m not sure we
should.

TY: Is there a middle way to handle signal handlers (inaudible)

HA: If the (clang) implements volatile arg is specified, what do other
architectures do?

DG: It is implemented entirely in the frontend - it turns volatile into atomic,
so it works on all architectures.

JF: It works on all architectures, but the optimizer needs to know that it is
volatile.

CW: Doesn’t it depend, since we don’t know which guarantee they are relying on.
Hoisting vs atomicity.

JF: It's not allowed to hoist and then not do the things - there's an ordering
guarantee in effect

BT: volatile requires accesses matches the program order -- we’re in the
situation that we have a second compiler. If we have to communicate that, we
need a second mechanism.

JF: Right, and i think we should not discuss adding volatile to the memory
model because it's a lot of work for something that doesn’t matter.

Luke: If we added something later that was weaker, we would be in trouble if we
tried to change the way code works because it would break implementations that
rely on it

HA: If the clang option does what the user wants than they can already just use
it

JF: The question is about what the default should be.

CW: The question is, do we introduce the weaker target, so that code doesn't
break in the future.

BT: It seems like it's impossible to implement volatile correctly without
sequential consistency in the memory model, which is what we have now.

BS: The tenor of the room is: We maybe need to switch volatile to be atomic, or
there's a thought that we need to add an additional piece of functionality that
might be of pretty limited utility, or should we tell people to use the clang
people (should it be the default)

JP: Is there someone here representing LLVM’s opinion on this? If we make a
choice here to make more guarantees than volatile gives, then introduce the
weaker primitive later, is LLVM comfortable giving a higher commitment than the
code provides?

DG: I am the LLVM code owner for the wasm backend. I’m uncomfortable with
outputting code that's incorrect to the standard, by default. My instinct is to
leave the default as it is, even if it will break things in wasm, they should
use the flag.

JF: Things as they are drops the knowledge that a load or store is volatile.

DG: Without setjmp.longjmp or signals then we don't need it. I need to satisfy
people who expect aggressive optimizations. If your semantics are defined by
the C++ standard this would not trigger anything incorrect.

BT: Do we make all accesses volatile? In order to support c++ without this
flag, thats what we’d need to do.

HA: I think what JF wanted was to make the (frontend translation) option the
default, plus tearing volatiles

JF: I think the language should deprecate everything but loads and stores to
volatiles, im working on that, but thats orthogonal to our conversation. The
only thing that makes sense for volatile is loads and stores that can tear. I
want to make the code that people wrote already still work - if they wrote a
load and store in the source code thats what happens. Some of these corner
cases never happen in real code.

BS: We need to gather more information, how likely is this to cause users
problems that they can’t diagnose themselves

DG: This isn't being brought up by the users, this is brought up because we’re
working on threads and having a debate about how volatile should work there.

HA: Does asm.js currently turn volatiles into atomics?

LH: Emscripten does

BS: We should see if this can be pushed down the stack. Maybe emscripten can
pass this flag to clang when it is compiling, with the expectation that users
are going that way. When we have a primitive that more effectively maps to
volatile, we can get clang to do things that way.

BT: This flag turns volatiles into atomics so early in the pipeline, is this
concern this won't be optimized?

DG: The compiler can do different things with volatiles and atomics. If the
users are writing code that needs this, we should support it, but if they
should be using the flag we should advocate clang to put it on by default.

JF: Clang transforms volatile stores and loads into sequential stores and
loads, only when you jump the boundary to no way to express volatility, then
you only have atomics to use.

DG: That is different than the MSVC volatile semantics

JF: This is the precedent, the semantics are not quite right but it's what
exists

DG: What about a third category that's stronger than volatile but less strong
than atomic?

JF: They’re not a lattice

DG: One part of the compiler thinks of it as volatile, and then later in the
compiler it thinks of it as atomic - it will have some of the properties of
both. I’ll need to think more about this.

JF: If you want me to raise that point on the CFP mailing list I can do that.
If I ask them or standards committee, I suspect I will get whatever I propose
as an answer

CW: You said there is a precedent for lowering volatile at the last minute

JF: There’s a precedent for making volatile mean sequentially consistent
atomic, that's what MSVC does because they did this very early on and they’re
stuck with it. LLVM mimics this behavior in order to be compatible with MSVC.
So there’s precedent for something similar (early). The precedent for doing it
late is in asm.js

DG: I was previously unaware that asm.js did this in clang, so I will study
this more. There may be room for some difference here. Emscripten was very much
focused on compatibility, I’m more focused now on doing the right thing.

JF: If you want to make an argument on lost optimizations I’d like to see
concrete examples. Volatile doesn't happen all that much. The authors may have
certain expectations that are incorrect but it doesn't come up all that often.
If you break user code and then get no real-world performance out of it, that's
not worth it. I want to understand the tradeoff.

BS: Thank you for an engaging discussion

JF: Do we want to conclude this in two weeks?

BS: Yes hopefully with more concrete examples, we can wrap it up.

BT: I think the thing we should discuss is not what clang does for C++, but
instead we need to discuss the intersection with the memory model and what the
default for wasm engines.

CW: Are you proposing to include release/acquire in the memory model?

BT: I think it would be a volatile annotation

BS: I noticed Andreas is here.

AR: I will be going to the wasm meeting at TPAC, yes.

JP: Thomas messaged in chat. He got an answer to that.

BS: Thank you let's adjourn

(Thanks for taking notes, Pat!)

### Closure
"
main/2019/CG-07-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 9 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: July 9, 4pm-5pm UTC (July 9, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email Ben Smith to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. [Extended name section](https://github.com/AndrewScheidecker/wasm-extended-name-section)
       1. Poll: Phase 1?
    1. Discuss [WebAssembly Benchmarks](https://github.com/WebAssembly/benchmarks) repo
    1. [Single Module Feature testing](https://github.com/WebAssembly/design/issues/1280)
       1. Poll: Phase 1?
    1. [TPAC 2019](https://www.w3.org/2019/09/TPAC/) Wasm presence
    1. WebAssembly Discord server
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees
 - Alon Zakai
 - Luke Imhoff
 - Sam Warfield
 - Ben Smith
 - Deepti Gandluri
 - Derek Schuff
 - Francis McCabe
 - Jacob Gravelle
 - Sam Clegg
 - Andrew Scheidecker
 - Deepti Gandluri
 - Thomas Tränkler
 - Lars Hansen
 - Thomas Lively
 - Alex Crichton
 - Ryan Hunt
 - Andreas Rossberg
 - Petr Penzin
 - Jay Phelps
 - Arun Purushan
 - Sergey Rubanov
 - Adam Klein
 - Keith Miller
 - Pat Hickey
 - Lilit Darbinyan
 - Sven Sauleau
 - Fisher Darling
 - Peter Jensen
 - Rich Winterton
 - Ben Titzer
 - Michael Starzinger

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

### Proposals and discussions

#### Review of action items from prior meeting.

None.

#### [Extended name section](https://github.com/AndrewScheidecker/wasm-extended-name-section)

AS: Old PR that I had, gist is to add the missing components to the name section that are currently stopping round tripping from wast file to binary format - type names, table names, memories, global names… everything that can be named in the text format in the MVP.
WAVM has implemented this for a long time, along with an lld fork that implements some of these.

Open to using byte offsets, but for consistency indices are more robust and easier to implement, for WAVM at least. Encourage folks to look at the overview. https://github.com/AndrewScheidecker/wasm-extended-name-section/blob/master/proposals/extended-name-section/Overview.md

SC: Seems non-controversial except for label names. It would have to come from the debug information, haven’t looked at the fork yet. What are we looking at for this proposal today?

AS: Moving from phase 0 to phase 1. Not sure how much it affects the process here, but this doesn’t add any changes that affect the Wasm spec, so it’s not clear. The name sections are not tested by the spec test suite.

LI: Purpose is to round trip, so we should have tests that test that

AS: If you have a producer that puts something useful in the names then that’ll come out in the discussion

KM: For functions in the JSAPI, useful to expose as .name for exposing the function name for exported functions. We could add it to the proposal - Doubtful if it’s a breaking change. Have tests for it

AR: It’s reasonable to extend the JS API, but difficult to specify. Name section is a custom section, so it could be garbled, but we can spec that it’s not well formed then it doesn’t return anything. You have to be restrictive about what you specify. Makes sense? 

KM: Sounds reasonable

AS: Not in my interest to specify anything related to JS. Proposal is for folks only on the Wasm side of things. One other note, I also have names for data and element segments - is the right place to put this in the bulk memory proposal? 

TL: Bulk memory proposal is far enough along, but let’s not add anything new there - having them in a  new proposal sgtm.
DS: Fairly uncontroversial in terms of the proposal. Any objections to moving this to phase 1?

KM: When is the scope of the feature decided?

BS: Phase 1 is meant to be that this is a problem we want to address, reasonably happy in the design direction, some of the details can be hashed out later. 

PP: Is this going to be used for debug info?

AS: Not exactly, wouldn’t be replacing existing debug information. This is names that are in the text format
DS: Nobody is proposing that browsers parse debug info, but the names section would specify the need for names to be parsed correctly. 

TL: Is it easily extensible to add new types of sections? I.e. events section - will it be trivial to extend? 

AS: This proposal doesn’t change any of that from the MVP, WAVM has names for what you’re calling events, so pretty straightforward to add

DS: Any objections to move to phase 1? No objections. [AI: File an issue/Fork a repo] 

#### Discuss [WebAssembly Benchmarks](https://github.com/WebAssembly/benchmarks) repo

BT: Created a repo, seems to have good support about having this be a public repo. I have some ideas, but would like to run them by the group. Talked about requiring certain type of line items - licensing, understanding the benchmarking algorithm, and how it works. We should avoid the knowledge of how the benchmarks are implemented being lost, so they are easily modifiable and understandable.

BT: Also methodology, lots of academic literature here. Sigplan has recommendations, 6 page explainer. We can follow suit here. I’d like to put up some info here on the repo. Want to gather more info here from folks.

BT: Right process is to propose line items as github issues
LI: one way we might allow kernels is if we have a minimal reproduction case that documents the history of why the code snippet matters. But it’s better to have the relevant code in a tight loop rather than in a whole web page. But it’s good to have e.g. a link to a bug with the context

BT: Definitely agree that we should allow kernels, microbenchmarks, applications, domain specific applications. Kernels are vital, motivation for having algorithmic descriptions is so that we understand the implementation

BS: Some people were commenting in the issues in the design repos with bechmarks they were interested in, have you looked at any of those?

BT: Haven’t looked at them yet, will look through them. Have someone on my team that will be looking into this. People interested please subscribe to the issue if interested. DS: Any questions/comments?

LW: Was previously interested in load time benchmarks, I had some workloads but there were problems, can I delete that repo as it’s subsumed by this one? 

BT: Propose them as an issue on the current repo so they’re not lost? 

LW: one of those was godot, which was good but it was problematic because it depends on WebGL2

BS: Let’s archive instead of deleting. 

LW: Trying to reduce visual noise, strart with archiving

BT: Looked at a lot of benchmarks, just a bunch of C code, no licensing, possibly from the 80s. HAving it licensed, and documented is useful.

PP: this is good, it’s been missing from a lot of recent conversations about web performance.

BT: File issues first, and then Pull requests. Casting a wide net first, and then narrowing them down.

BS: Maybe have them in a separate branch, so people only see official benchmarks on master

FD: Thoughts on augmenting the wast format or other format to load up the description of e.g. the benchmark type? It’s convenient to be able to automatically fetch tests when developing an implementation.

BT: What kind of an extension were you thinking of?

FD [??]

PP: Chakra has a wrapper for wabt, JS interface for wabt. Not sure if that’s helpful

??: When we get the collection of benchmarks together, when there is some code, have the documentation with it so we know why it’s there. 

BT: Yes

??: Should we figure out the format through issues?

BT: Yes

DS: Any other comments or questions for Ben?

BT: Thanks

####[Single Module Feature testing](https://github.com/WebAssembly/design/issues/1280)

BS: also related to “fat binaries” e.g. multiple formats in a single binary
One observation is that I think a lot of the code would be common between modules that do or don’t use the feature (for many of the features at least). Hopefully adding a second feature to a module wouldn’t increase the size by 2x.

RW: SIMD easy to test for single versions, should we think of this as a growable section? Because new instructions can be added as additional proposals

BS: I have a couple of different ways this could work. If some new iteration of simd adds horizontal adds, you can have them as separate bits that you check for in the module. Will get into the alternatives later. 

BS: High level idea is that for the binary format we add two new section types, feature test section, and conditional section

<See slides>

BT: If you have a feature that adds new types you need multiple sections, and that are combined together? 

BS: Sections are easy to extend..

BT: How do you reference them stabilly?

BS: That’s a tooling concern, index means different things, if you want it to be stable, you have to pad it out or make sure they occur earlier.

BT: e.g. if the feature is true, use these 12 functions but otherwise use these other functions

BS: This is a relatively simple way of specifying that

LI: since we use byte offsets, how does that work as if they were compacted in memory?

BS: We don’t use byte offsets for anything currently. We only use them in some of the custom sections. All of the official known sections use indices

LI: does it matter that the index space has holes in it afterwards?

BS: the idea is that there wouldn’t be holes, you’d have to put in dummy elements or know how to remap those values.

AR: This feature test section contains modules essentially? IS this completely recursive?

BS: Wasn’t my intention, we want to constrain that in some ways. This part of the feature is most controversial, maybe we should have strings instead. It does have some troubling aspects

AR: requires the decoder/validator to be reentrant, so that’s a bit concerning, may not be worth the complexity

BT1: Does this add complexity to the names section, or other debug info we’ve discussed?

BS: Yes, if you have new sections you have to add a custom section that’s conditional

LI: if we need multiple sections with the same condition, could you include multiple with the same condition so the impl doesn’t have to re-evaluate?

BS: Let me talk about the conditions - at a high level conditions should be simple to evaluate. Shouldn’t be more complicated than the types of sections we currently evaluate. For each feature test bit we get 0/1 and then we can combine them. Local.get would be a way to get the 0th feature and combine with and/or eqz with the condition you want. So it’s possible you need multiple evaluations, tl has a proposal that i will later discuss

FM: is there a possibility of not loading the module if the feature test fails?

BS: you could have a section which was invalid, so yes but it would be clunky

FM: You might want to add that capability, gating feature

TL: Question about conditional section, would be nice if they were custom sections. We need some way to say don’t include.. If you have an MVP section, and you want to replace it with some feature, you don’t want the mvp to be strange in any way, you want all MVP engines to recognize it the same way. If you can only mark customs as being the ones that can be turned on, and not have the capability to turn off MVP sections, it’s not gracefully backwards compatible.

BS: yeah i agree it would be nice. I'm a little uncomfortable using custom sections, but it's probably the only way to make it work with MVP

TL: Alternatively we could figure out what the cost is, and then explicitly say that it’s not compatible, but worth looking closer

BS: ultimate goal is that we have some way to specify in a single module, multiple modules with different features and validate different ways. With a native binary you can just add instructions, and if they dont run it doesn't matter. With validation we need a way to not validate part of the binary. So we have section boundaries as the most natural division so we need to figure out how to combine sections, etc. maybe having a way to exclude sections.

LI: How will this interact with WASI’s optional import feature? Will it subsume? 

BS: Orthogonal.. Engine decides the implementation. Think of it as something separate - what kind of sections will validate, and not what imports are available. 

RW: Could see a use case where I’d like to know what features are available through JS. Have you thought about what we can expose to JS?

BS: you can already do that using feature test modules. This is meant to avoid having to do a second fetch. If you want to expose features like that, you could e.g. have a conditional global section which returns true if the feature is present. A bit clunky but you could do it that way.

AS: would it be simpler to have a way to embed multiple modules, and your conditions enable/disable that, and yo specify how the inner modules map to imports/exports of the outer module?

TL: One of the ideas is that you can have a module that’s 95% the same, one uses SIMD and the other doesn’t. For that one little hot loop you want a SIMD/non-SIMD version and nothing else.

AS: Proposing that you have module level conditionals instead of section level conditionals. The feature test specs at the top of the module defines how the main module that is not conditionally compiled will import the SIMD/non-SIMD a nd the feature test section will figure out which function to import. 

BS: one of the things i tried to solve is that putting the sections in the same place allows streaming compilation like normal; separating into modules would make that harder.

BT: By having a conditionals sections the modules have access to the internals, so if you have two modules that need to share state that will need to be imported/exported

<alternative feature test section, alternative conditional section from slides>

SW: sponsorship for college students is still open, can we discuss this soon so people can take advantage of that?

DG: I’ll start a github issue to discuss

BS: should we poll for phase 1 for feature testing?

Objections for phase 1?

SC: have concerns about the complexity it puts on the tools, but that doesn’t need to block phase 1.

AR: I have more fundamental concerns, but shouldn’t block phase 1.
[no other objections, so unanimous consent for phase 1]


DG: can move discussion to a future meeting. But briefly:
TPAC early registration is closed. Folks interested in attending, but won’t be an official CG meeting. We should talk about what we want the wasm presence to be. We can add that to a future CG meeting.
Also: previously we discussed an official chat other than the IRC which hasn’t got much traction. Pasted a discord invite link, folks can try it out, and we can discuss online in future meetings.

### Closure

"
main/2020/CG-07-21.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 21st video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: July 21st, 4pm-5pm UTC (July 21st, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Phase 1 Proposal for [Dispatch Tags](https://github.com/WebAssembly/design/issues/1346) (Ross Tate) [15 minutes]
       * Ideally with vote
    1. Discussion of stack inspection (Ross Tate) [15 minutes]
       * Need CG feedback in preparation for stack-switching design
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Adam Klein
* Alex Syrotenko
* Alon Zakai
* Andreas Rossberg
* Arun Purushan
* Ben Smith
* Conrad Watt
* David Piepgrass
* Derek Schuff
* Francis McCabe
* Heejin Ahn
* Ioanna Dimitrou
* Jacob Mischka
* Jakob Kummerow
* Jay Phelps
* Jlbirch
* Keith Miller
* Luke Imhoff
* Luke Wagner
* Mingqiu Sun
* Nick Fitzgerald
* Paolo Severini
* Paul Dworzanski
* Petr Penzin
* Rich Winterton
* Rick
* Ross Tate
* Ryan Hunt
* Sabine
* Sam Clegg
* Sergey Rubanov
* Sven Sauleau
* Syvatoslav Kuzmich
* Thomas Lively
* Tobias Tebbi
* Wouter Van Oortmersson
* Zalim Basharov
* Zhi An Ng

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Francis McCabe seconds

### Proposals and discussions

#### Review of action items from prior meeting.

#### Phase 1 Proposal for [Dispatch Tags](https://github.com/WebAssembly/design/issues/1346) (Ross Tate) [15 minutes]

Slides for Dispatch Tags [(pdf)](presentations/2020-07-21-tate-dispatch-tags.pdf) [(pptx)](presentations/2020-07-21-tate-dispatch-tags.pptx)

[Ross discussing capability leaking slide]

AR: That's not what's going to happen in the current proposal… 

RT: You're describing the new process where you're sealing and unsealing a type, but it can still happen. It's also just one of the issues that can happen here.

[Back to slides]

AR: How is that different from the RTT in the GC proposal. Seems similar, except it also allows you to specify tag on function definition. Then call_indirect is downcast.

RT: RTT currently has a nesting depth, and array lookup, etc. This is much smaller.

AR: I agree, that is more general… is it a subset of that?

RT: There's no connection to GC for this

AR: In what sense?

RT: This could just be a code pointer, if you're in a setting where a funcref is just a code pointer.

AR: I agree, it's just about GC types. You could factor out RTT from GC proposal, and so I think it's kind of the same thing.

KM: Does the GC proposal give you a way to show that a tag doesn't escape the module?

AR: Escaping means that you export it or pass it out in some other way. There's no difference there.

KM: i can fork my tag, they are identical tag, one is internal and another is exported, how would you say the same thing in the GC proposal, maybe i’m just confused.

RT: Another thing is that you can do multiple tags, useful for OO, you have a tag for each interface method. They don't have to have a subtype relationship.

LW: call_indirect will do a sequence for each interface method

RT: If we do allow multitag thing -- then the receiver has associated multiple tags then it can do multiple checks, it could be a switch or some other way. I can go into more detail later.

LW: can see how the more general case can allow more general things, nice thing about current RTT (with the number to order), you can always do the check in a single constant load comp, if tag, it is as certain offset, constant instruction to do the check regardless of how many tags it has

RT: Generally with this strategy its the callee that does the tag checking. The applications of this -- the tags are all the same depth.

AR: isn’t it an implementation detail who does the actual check?

RT: It's an implementation detail, yeah.

LW: even if callee does the check (with RTT), seems like callee can do a single constant time check, could they?

RT: With the RTT one you have to cast on the first side, to know if you even want to do it.

AR: Here you kind of fuse these two operations, which gives you the ability to do it on the other side, I wonder what you gain by it. So far it looks like we don’t gain anything. Will be the same check on either side.

RT: Right now it's a little hard to compare against something that doesn't exist yet -- your function ref proposal has meta information that is associated with it. This requires two indirect reads.

RT: no rtt with this

AR: but the object has one, if it’s not in the object, it is in the function prefix. Different function type then.

RT: let me go with the extension. Will concretize.

BS: usually we will timebox, but you have both agenda items.

[Ross presenting extension slides]

AR: These functions, if you want to do the dispatch callee-side, you need the tag. Which means that they have different calling conventions, so they would need other types as well.

RT: the way this is implemented, for interface method systems. You push all args on stack, also push tag onto stack, then receever looks at tag, then it check if it’s the tag it is looking for. If it is not the one, it traps.

AR: I mean that this assumes that both sides know -- callee knows and caller knows that they have an indirect dispatch call.

LW: need a separate indirect_call entry point, there is a separate prologue called by call indirect as a constant offset from typed entry point. For n=1 how we implement call indirect, if stack matches it is the right layout, callee starts with a branch. If we add more tags it will be a sequence of checks.

AR: So every function in your implementation has this extra prefix that allows it to be called with call_indirect.

LW: only a few bytes, can optimize using is_alias predicate

AR: This would become a required implementation technique, then.

LW: if you add dispatch funcs, seems useful in general, powerful tool

##### Ideally with vote

BS: unanimous vote for phase 1?

No objections, proceed to phase 1.

#### Discussion of stack inspection (Ross Tate) [15 minutes]
##### Need CG feedback in preparation for stack-switching design

Slides for Stack Inspection [(pdf)](presentations/2020-07-21-tate-stack-inspection.pdf) [(pptx)](presentations/2020-07-21-tate-stack-inspection.pptx)

RT: Discussion I want to have: do we want stack inspection or not? What are the challenges? This will affect how we design stack switching.

FM: looking at slide on two-phase exception handling, the last call_stack_from $outer, the function you’re calling is at the bottom of the stack (most recent part), “this” function is executing at the bottom of the stack

RT: call_stack_from to ignore part of the stack, start searching from this place up

FM: Ah, I see. That's complicated to figure out how to do...

RT: one more slide on stack walking

[Ross presenting ""Stack Walking"" slide]

AR: Meta-thing -- on the web you have to be very careful with features like this. In JS, they tried to restrict the things you can learn about the stack. .caller and .properties, those were very....

RT: you can only look for very specific information (based on the tag)

AR: You might still want to be able to protect against -- there have to be boundaries. When you use delimited continuations, it allows you to put in those boundaries.

RT: there’s stack walls, can’t walk up past this point, like timing behavior, leaks information. There are devices people use to limit stack walking, trying to get at the basics here.

AR: I think once you put that all into place, it seems like it will end up being delimited continuations or effect handlers. I'm just curious if that will solve the problem, instead of specialized mechanisms. It's unclear how they would all work together. W.R.T. stack walking, on the web at least is that the stack is heterogeneous, you'll have host stack frames or JS frames, or from wasm stack frames from another runtime. There might be some of your own further up. If you want to implement GC with this, I think you'll have to answer some hard questions about this, walking stack for frames you don't understand.

RT: already answered, you can only look for tags you can answer. You explicitly state what you look for, people have to explicitly state they have information for a tag.

KM: host function that has a mean to give it some reference, some callback that can vend you back an object pointer. Holding it in some heterogenous frame you don’t know about. I”m module A, I need to call some host function that has a callback which will call me later, at some future time, e.g. schedule task on run loop, need to give it my object. I need to know that the closure variable is in the other frame. Either the caller has to flush it somewhere (like ref count).

RT: It sounds like what you're talking about is a linear memory GC, not stack walking. Yeah, if you give one of your objects elsewhere, you need to give a root.

KM: it wouldn’t solve all your problems..

RT: Right, it would solve some problems, like the problem of dealing with a shadow stack (which is inefficient)...

KM: I’m unconvinced it is inefficient. You’re maintaining a shadow stack of all your frames to iterate, you only have to flush whenever you make a call, identical to what the VM is doing, vm has to save values somewhere it can find value later.

AR: Storing all these answer handlers won't be cheap either.

KM: you need a stack map, hash map of stack maps for values and where you save them, there are possibly optimizations you can do, you can allow callee saved registers, and asked callee where it was saved, only possible optimization VM can do that shadow stack can do, not convinced it is valuable.

RT: are you saying vms, does Java vm maintain a stack trace wherever you go? Do you think java maintains a shadow stack everytime it executes the code.

KM: You can recover that already from existing things -- at least in the web VMs, you can get the wasm stack, and recover the information from it.

RT: you can do that

KM: java vm can do that

RT: java vm can do that because it knows return address

KM: I could write a Java VM in wasm that could recompute this data. You would need to know what java line offset maps to which wasm offset.

RT: you have to maintain the return address. You’re asking people to maintain that, which the host vm has.

LI: Have either of you gone to the debugging meeting? They have a way to handle code mapping with DWARF that already works. There's a meeting this Thursday.

LW: the debugging support isn’t exposed to live content, only activated from browser debuggers, what RT is talking about there is a first class feature

LI: Only for the debugging purpose. For other stack walking… Keith what you're talking about is what the debugging DWARF support does.

KM: you can still implement… today if you want you can implement this, not saying there’s never any world you wouldn’t want this first-class in Wasm. This functionality exists. I don’t know how performance sensitive that is. Agree that it will be a large burden on producers to do it the way I was describing.

RT: Similar to exception handling. We could implement EH as it is, but it's way better for code compactness, for performance,...

AR: i don’t think you can implement it, can you. Heterogenous stack problem, how do you unwind over host frames.

KM: You just need to know your own frames, right?

RT: composability issue. The shadow stack works well if you code stays within itself. Once you go into someone else, it’s much more difficult to coordinate the unwinding across modules.

AR: The problem isn't the shadow stack, the problem is convincing the other code to unwind...

RT: coordination

AR: you cannot do that without exposing… e.g. higher-order functions, you cannot do that without changing its type, not a local transformation. Exceptions are adding expressively.

RT: But that also applies to everything I have here [AR: I agree] So if we agree that exceptions require this, then it seems weird to say stack inspection doesn't.

AR: q isn’t what way you want to provide, whether ad-hoc, whether it is expressible with more general - that is an effect handler isn’t it, you are invoking an effect, and handler answers

RT: The details matter, your effect handler mechanism requires continuations...

AR: more general, this is one of the specific cases. Have one general case, rather than specific ones, and how they interact

RT: To be clear, your mechanism says that to build this requires a new continuation, right?

AR: not necessarily, i’m not saying i have all the answers, i’m asking how many of these special mechanisms we want to have. One thing clear to me is, you want to separate the general part where you need continuations, from the specific part where you don’t need separate stacks. There are two mechanisms, do we need more than that? E.g. current EH proposal, with a simple resume mechanism which is not first-class, that is equivalent to what you are describing - answer is a try.

RT: High level, you agree that we need stack inspection, but the question is how to do it.

AR: more generally, you want to be able to express stack inspection, but does that require specialized mechanism

RT: not sure how to implement these except what KM suggested

AR: For example, if you add restricted resumption to EH then you have an equivalent thing.

FM: beg to differ, how would you use that for debugging

AR: for debugging, we need to be careful, separate from language semantics. There are things debugging should include that the language shouldn’t, need to keep them separate. Might have reasons to include some features in both.

FM: important principle there that when you are debugging, you want to be doing it in the semantics of the language you are debugging (source), not Wasm.

AR: you want to expose source level

RT: you want to be able to …

AR: agree that debugging interface, whether language feature or not, has to have a place to do that

LW: debugging subgroup working on this, and has made progress, and +1 to separate debugging interface with core language

BS: RT, do you feel like you have some answers?

RT: no definitive answer, discussion went productively

KM: one possible useful point, regardless of my feelings on stack inspection, I can guarantee that i will be blocked from shipping this (by my bosses), until GC proposals is in place, for the fear that people will use this

BS: more discussion should go on GitHub issue.

[Follow-Up Issue on Stack Inspection](https://github.com/WebAssembly/design/issues/1356)

### Closure
"
main/2024/CG-06-18.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 18th video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: 2024-06-18, 16:00-17:00 UTC (2024-06-18, 9am-10am PDT, 18:00-19:00 CEST)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
  1. Presentation: Transactions and Persistence (Eliot Moss, 45 minutes)
1. Closure

## Agenda items for future meetings

## Meeting Notes

### Attendees

 - Chris Woods
 - Paolo Severini
 - Ben Titzer
 - Francis McCabe
 - Conrad Watt
 - Yury Delendik
 - Eliot Moss
 - Adam Bratschi-Kaye
 - Andrew Brown
 - Adam Klein
 - Alex Crichton
 - Bailey Hayes
 - Ilya Rezvov
 - Jeff Charles
 - Keith Winstein
 - Linwei Shang
 - Michael Ficarra
 - Nick Fitzgerald
 - Nuno Pereira
 - Paolo Severini
 - Petr Penzin
 - Richard Winterton
 - Thomas Trenner
 - Luke Wagner
 - Julien Pages
 - Yuri Iozzelli
 - Derek Schuff
 - Andreas Rossberg
 - Heejin Ahn
 - Ben Visness
 - Robin Freyler
 - Emanuel Ziegler
 - Kevin Moore
 - Jakob Kummerow
 - Slava Kuzmich
 - Brendan Dahl
 - Zalim Bashorov
 - Oscar Spencer
 - Elizabeth Gilbert
 - Thomas Lively
 - Sergey Rubanov
 - Deepti Gandluri



### Proposals and discussions

#### Transactions and Persistence (Eliot Moss, 45 minutes)
EM presenting [slides](https://docs.google.com/presentation/d/1DDGBU-HIHyTEwvjMnCeckJUPoBhcnp-5XrpxDWvJygw/edit)

Status slide: comments?

CW: Do you think of this feature as exposing HW transactional memory to Wasm, or does it have to be implemented in software? Also, are the casts implemented by having a lock in the runtime for each location? What does that look like if implemented in core Wasm rather than in a language extension?

EM: about HTM: one design goal is to allow most transactions to at least attempt to carry out with hardwareTM. Implementations have limitations about how big transactions can be, so any system has to have a SW fallback.

Second question: the idea is that each granule has a memory location associated with it, that would have a version number and/or packed into one word, and a current transaction owner which you could use to implement “optimistic reads” and “pessimistic write” so if you are writing you take a lock but if you read you check the version number and see if it’s changed when you finished. You don’t have to do it that way but it’s a typical implementation. I modeled it that way in the reference interpreter.


CW: Is the concept that if we tried to do this with regular Wasm instructions, it would be much slower?

EM: maybe. It would be a lot more complicated. Because you’d have to build up all this underlying structure yourself. Build up a data structure of all the things you’re locking, you might be able to do it more efficiently in a runtime system than using wasm types for it. You could link directly through things rather than having to allocate object to build a list.

CW: that story makes sense… I'm just thinking how we would evaluate it if we were thinking of putting it in the language

AR: You said we could use exceptions for signaling conflicts, but how do the conflicts become observable in the semantics in the first place?

EM: you would typically detect conflict either when you try to acquire an item in a transaction for read/write and another transaction has e.g. locked it for writing, then one of the transactions loses.

AR: What happens in that case?

EM: In the reference interpreter, the longer running transaction wins based on timestamps. The other has to be rolled back. 
So far so good. But not only is that unwinding happening, you can also think of there being an exception thrown to indicate that this one failed.

AR: What does unwind mean? What happens after you have unwound the failed transaction? Do you get a trap, or an error code?

EM: if you have no handler, then I guess it’s what wasm would call a trap, but if you have a handler of some kind then you go down an alternate execution path.

AR: We normally use traps only for real fatal failures. Doesn't seem to be the right thing here.

EM: if no handler with retry was provided. So I think the way you’d typically translate a higher level language, you would have a handler that says if it aborts we’ll retry it up to k times and if you fail that many times, then you give up.

AR: The point is the retry has to be programmed in user code, it's not automatic?

EM: right. That seemed to me a better design than building some fixed retry mechanism into the system. 
You could do that, it’s the kind of thing we could discuss. You could also say we’ll have the lower level system retry some number of times, perhaps controllable by parameter.

AR: I think that makes sense given the low-level nature of the language. Another comment you said is that there are no proposals you could find that would interfere. How would it interact with stack switching?

EM: if you view switching from one continuation to antler as effectively switching execution contexts, then if you’re in the middle of a transaction, it’s just not p;rogressing but you wouldn’t bring it with you. You wouldn't bring that transaction context with you to the new context.

AR: But the continuation you switch to, wouldn't it have to be on the same side of the transactional/non-transactional fence?

EM: I guess it depends on whether you want the continuations to be in the same or different transactions. I haven't thought about how you would express that.

AR: or maybe another answer could be that the transaction could not run across a stack switch.

EM: That's the simplest way to do things. I guess we're assuming there's no thread parallelism within a transaction. Continuations within a transaction would be an intermediate thing. Then you have to start wondering if we need nested transactions in case the continuations conflict.

BT: about nested vs flat transactions: if you try to open a nested transaction, does that succeed?

EM: Like one tfunc calling another tfunc? It just flattens the nesting rather than creating a new transaction scope.

AR: just slightly more detail about the type system. The transactionality attribute on all the things is sort of a generalization of the shared-everything proposal.

EM: I'm not aware of that.

AR: Same idea, you can add shared to everything, not just memories. In our case, the attribute is not on the reference but on the referenced type. So you would have a transactional struct type, then every reference to it would be transactional. Is it useful to have a non-transactional reference to a transactional thing?

EM: I suppose it could be, you're just passing the identity of something around ,and then some other part of the code might want to access it transactionally. I added the access permissions to the reference types. So a tref none… i don’t know if those could be brought into a single type conveniently or not. But underneath yeah they're just a pointer to something in a heap.

AR: Thanks.

EM returns to slides on persistence

PP: with shared vs transactional, if you add persistence, it's another dimension. It almost sounds like it needs to be an attribute, so we can remove the distinction instead of having separate types, we almost need parameters to the types. It could be simpler, but the intersection could get large.

EM: There could be issues with not every subset of the attributes making sense together. This shows up in the encoding.

PP: some of the things, runtimes would have an an encoding, and de-facto have something like that ‘kind’ byte

TL: I'm wondering about users. Are there languages, libraries or toolchains that would be eager to adopt this?

EM: short answer is, not yet, we’re hoping that if we start this, they will come. It’s a bit of a chicken and egg thing. If there’s not good infrastructure, it’s a huge amount of work to make a transactional/persistent version of a system or language. This grew out of an NSF project with the goal to provide an infrastructure to make it easy for languages to get a well-engineered transactional version.

AR: Usually doing something on module boundaries is the wrong idea because they're just grouping mechanisms.

EM: I would apply that to the heaps for sure. Objects can point to any other object in the heap and it doesn’t matter which module they came from, but every module has its own global variables. That’s really the only sense i meant

AR: The thing is you can import and export between modules, so there are not clear boundaries. With references you don't see that.

EM: oh no you wouldn't. I’m saying there's a single persistent heap, but each module could declare a memory, and those are distinct.

CW: So each instance does not have its own heap, they all use a single heap off to the side?

EM: what i was calling a store would have a persistent heap and a collection of persistent linear memories, tables, etc. I think they would have names that would maybe match up with module export names.

AR: In the store, you're right you have a sequence of memories, but they can be arbitrarily shared. So there is nothing that naturally ties them to module boundaries.

EM: maybe thinking of them as boundaries isn’t the right word, but some module declares a memory and you have to have the idea that memory is in a certain store.

CW: i think it’s ok, we could have written point 5 as “there is a single persistent store where these memories live”

EM: When I wrote ""instance"" I meant what the spec calls a ""store""

AR: yeah that is actually what the spec also calls a “store”. you don't even have a way to observe different stores.

BT: are there runtime optimizations that you're envisioning, beyond just using the available HTM? e.g. are there things the engine would be expected to do, e.g. combining transactions?

EM: Not a lot. For my PhD students to dig in I hope. Combining a number of short transactions is a possibility. Maybe optimizing very short transactions. Mostly paring down all the checks and data copying work to get inherent overheads as low as possible.

CWoods: partly an answer to “is there anyone interested with use cases”: Maybe? We might have something we can discuss offline.

PP: High assurance systems would be interested in this with persistence.

CW: one interesting way to really get this moving and attract people to use it, might be to investigate a version of wasm with these extensions vs one that has the features implemented on top, and see if people can target the userspace version to bootstrap.

EM: If you want to access multiple data items and do so atomically, even if you're not concerned about rollback, then it's really hard to design a system that avoids deadlock. It's easy to grab the locks out of order. Imagine moving items in a data structure, locking the items in the wrong order could lead to deadlock.

CW: are you saying it would be feasible for a runtime to work out how to do this, but not a static elaboration to webassembly?

EM: it’s hard to e.g. make guarantees about locks, acquiring them in the right order

CW: If you start with all the Wasm modules that have these types, could you come up with a total order between all the locks ahead of time?

EM: no, because you can create new objects on the fly. You can come up with an ordering but you can’t guarantee to acquire the locks in that order.

CW: You might need something like a generation number on the object.

EM: that’s not the problem, the object are put in particular places, how do you make your code grab them in a particular order.

CW: Is this a problem of the user-written code or a problem of the engine trying to implement transactions?

EM it’s a problem of the user code, there's the possibility of conflict and deadlock, a general transaction mechanism will detect it and undo the transaction

CW: My suggestion was to imagine a wasm-to-wasm compilation pass that lowers the new primitives to core Wasm.

EM: you might be able to write a transactional runtime in wasm, if that’s what you're saying. Like writing a garbage collector in userspace.

CW: Sure, I'm suggesting this as a method to get it in front of people easily. The standards process would take a long time.

EM: It's right there in the OCaml reference implementation already. So that's one of the questions for next steps. Should i do some sort of pull request or what

CW: For the standards process, we would eventually have to get Web engines to implement it, and this would be an easy way for folks to try it out.

NF: do we have any reason to believe that this lock ordering is more likely to be implemented correctly or more easily in the engine, rather than a wasm producer?

EM: that it’s easier to build a transactional runtime rather than a user trying to build it on top?

NF: the choice is the engine runtime engineers vs the producer engineers, i.e. the toolchain.

EM: I think that's similar to what Conrad was saying. Could we build all this mechanism in pure Wasm? Yes because it's Turing complete, but it might not be good.

CW: theres a slight difference between what i’m suggesting is you could imagine a conversion from your instructions to pure wasm.

Or you could convince the producers to do all that themselves.

NF: It makes sense that if there's hardware support for transactions, then the host would have to provide that. But for the parts that aren't hardware-backed, would it make more sense to allow folks to build on top of core Wasm without extension?

If it’s the same amount of work to do the software inside the engine or inside wasm, then it makes sense to do it in inside wasm

EM: you’re throwing the burden back on the user community, as opposed to the implementer community. My theory about that (with GC it certainly holds) you’re going to get more correct more performant implementations from experts who really know how to do it i you build it inside the engine. And you also save the user communities from doing it over and over in each user program. That's opinion, but you save the user communities from having to do it over and over again. But I'm not involved in the business community side of things.

FM: there’s been some discussion about a macro extension capability. If you had something liek that you could use it to prototype TM also about GC: even with wasmGC there are languages that can’t use wasmGC for their garbage collection so it’s not just about expertise. Definitely the ergonomic question, e.g. go, Prolog and scheme can’t use it. Beyond your presentation but might be worth revitalizing it. 

PP [chat]:
Another concern for user-implemented transactions is size of such a runtime, how much extra binary producer would have to ship

BT [chat]:
My point was going to be: sometimes exposing the details of the abstraction allows malicious / broken code to break the abstraction, so just a locking discipline can be violated, leading to deadlock. Deadlock is a global property that cannot be effectively policed at the implementation level.

### Closure
"
main/2020/CG-10-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 13th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: October 13th, 4pm-5pm UTC (October 13th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Announce next SOIL Seminar presentation for Friday, Oct 23rd (Ross Tate) [2 min]
    1. Discussion on [relaxed dead code validation](https://github.com/WebAssembly/relaxed-dead-code-validation) (Conrad Watt) [30 min]
    1. SIMD-specific [feature detection](https://github.com/WebAssembly/simd/issues/356) (Thomas Lively) [15 min]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

Thomas Lively
Alon Zakai
Andreas Rossberg
Sam Clegg
Fatih Bakir
Daniel Hillerström
Arun Purushan
Ioanna Dimitriou
Zalim Bashorov
Ben Titzer
Francis McCabe
Ryan Hunt
Lars Hansen
Petr Penzin
Rick Battagline
Mitch Moore
Yury Delendik
Sergey Rubanov
Ross Tate
Sabine
Paolo Severin
Heejin Ahn
Conrad Watt
Paul Dworzanski
Yuri Iozzelli
Jay Phelps
Emanuel Ziegler
Luke Imhoff
Adam Klein
Mingqiu Sun
Asumu Takikawa
Rich Winterton
Zhi An Ng
Till Schneidereit
Manos Koukoutos
Pat Hickey
Luke Wagner
Nick Fitzgerald
Steve
Alex Crichton
Jacob Mischka

### Find volunteers for note taking (acting chair to volunteer)

Zhi An Ng volunteers.

### Adoption of the agenda

Arun Purushan seconds.

### Proposals and discussions

#### Review of action items from prior meeting.

#### Announce next SOIL Seminar presentation for Friday, Oct 23rd (Ross Tate) [2 min]

RT: TL gave the first seminar, link to recording, http://soil-initiative.org/seminar/#20201012, next meeting is Fri Oct 23. Donald, student of Arjun, presenting wasm-k. Adding continuations to Wasm, implemented in wasmtime.

#### Discussion on [relaxed dead code validation](https://github.com/WebAssembly/relaxed-dead-code-validation) (Conrad Watt) [30 min]

CW: Following from the previous discussion. Detailed discussion and flag off edge cases.Presenting..

[Slides](https://docs.google.com/presentation/d/1QFzClx2zZDcosC7vgSqmRJp6Rsq5JEG-sFzf6P98lZU/edit?usp=sharing)

AR: Can you repeat that?

CW: the way currently proposing to handle bottom type is in the rule for appending instruction sequences. If you have e1* and e2*, result of e1* if it has a bottom, it can be subtype into value types or ref types.

AR: yup

CW: issue is, memref type, if you’re within a module that declares no memory type, then no possible memref type you can pick. You just want to skip it. If we had load.memref the current won’t work anymore.

AR: original wasm didn't have this problem as every instruction was self describing. With Gc there will be a lot of annotations.

CW: something i want to speak about. This load.memref example is not real, it’s the cleanest example. There are already instructions in pipeline that are missing annotations. From my POV, we are only adding them in to handle dead code typing, with this proposal we wouldn’t need them.

AR: ben’s argument was that he wants them for an interpreter, doesn’t want to have to look to the actual value in the interpreter

CW: in interpreter during validation, you can tag validation with the type. Maybe I shouldn’t try to argue.

AR: side remark, agree with general analysis.

BT: the point of having more type annotations on instructions is so that you don’t require values to have metadata that you wouldn’t otherwise need. Something that is statically derivable by checking types, the interpreter doesn’t have that, you need to attach that to values. It’s not just performance overhead, and also memory overhead.

CW: depends how the interpreter implements validation. If validation is ahead, then can set it up.

RT: side topic

CW: we have 30mins

BT: try to save memory as much as possible, interpreter typically does not have another pr of the code other than bytes. Maybe side table (small) to annotate some instructions, but not every instruction, waste code space.

RT: annotations you are adding to the side table are annotations you would have to have in the original code anyway. Think this is a side discussion.

CW: this is quite related for interpreters. Already the case that the select instr needs this information, depending on repr of values in the interpreter, some implementations may need to tag select.

<BACK TO SLIDES, last slide on “NOT this meeting - phase 2 poll”>

AR: do you have a slide showing change in typing rules for this proposal?

CW: I can just show it in the proposal I wrote. There is a cheap way to change typing rules that is rather fragile. For the MVP, you could get away with the following change. For things like funcrefs, special case for them, or more involved change.

RT: the bottom row covers boilerplate cases, can add special cases for things like memref

AR: what is OT?

CW: defined above, stealing your operand type thing.

AR: there the OT was slightly different. Not sure how OT is related, it can be anything?


CW: it needs to be OT to match the result type of enclosing block.

BT: something you might have glossed over that i recently realized. If you open a new block in dead code, new block’s body is not dead code anymore. Within the new block, the new code is dead, with this proposal.

CW: we can talk about what we want to have, the rules we have written here haven’t considered that yet. We can change the rules.

BT: won’t work if you have a bytecode iterator, it would have to keep track of control structure, and drop back to regular validation algorithm.

AR: wish we had notes when we discussed it first time round, various cases we weren’t sure what the nicest definition is.

CW: nested block in dead code is not something we thought about, have to go away and think

RT: according to our rules, the block will be typed with what it annotated with, thats sound, can make it better by special case block when input type is bottom

TL: under the current proposed rules, the nested dead block body would not be typed as dead code, will be type of block

CW: also matches the implementation sketch, Ben sketched earlier, the current type stack effect marks as dead, the new block doesn’t have a dead bit set.

AR: you have to remember what is outside

CW: you already have to do that, you have to set the bit

?: not always a stack

RT: can add a rule for blocks. Block has a special rule, if input is bot, ignore the annotated type

CW: the thing that most closely matches what current impl do, is to type the body of a block as not dead.

RT: probably

BT: my interest is making it dead obvious that actual impl of validation is correct and least amount of work with dead code. Allowing blocks in dead code to not be typed as dead code means you have to switch back when you enter a nested block, and seems more complicated.

CW: you already have to do that

BT: a decoder , once reached unreachable, goes to end, don’t mix up validation of imms with validation of type stack.

CW: i talked a bit about it before, my high level intuition is that more code sharing if we just switch off some checks. Impl has logic to switch on opcodes…

BT: don’t think you want to write two versions of validation and put it into the same switch case. You want to factor it such that for an immediate type, you can go from opcode to immediate type, and for immd type you skip, or validate and skip. You don’t want two versions of every bytecode.

RT: currently if you have a block after unreachable, you wil step in, typecheck, step out, then back into a poly stack case. Figuring out how this introduces complexities that aren’t there.

BT: pick any one bytecode, i32.add. If this doesn’t get type check in unreachable, you won’t even push or pop.

CW: in terms of burden on existing impl, v8 already templates validation case pushing and popping. Webkit also has a template that doesn’t push/pop.

AR: wonder why, though

CW: no idea, i’ll use it to my advantage

RT: ref interp, 1 line change

CW: delta for current impl isn’t big.

BT: wrote a substantial part of v8 validator as it is, it is 4k LOC, templated like crazy, for 3 different execution tiers can use it. Don’t think this is the right way to use a validation algorithm. It is this way for a different purpose.

CW: A complicated thing gets a bit less complicated, but not as far as the less complicated thing you’re advocating for.

RT: currently, instructions have to have rules…

CW: in most cases, for current mvp, you can hide a lot behind push and pop. I get Ben's point on code hygiene. A lot of people won’t be set up to deal with that if we go with Ben’s item. This idea doesn’t expose any different between instruction syntax and validation.

AR: with current approach, you can hide completely push and pop.

RT: not true

CW: not true for post-mvp, e.g. load memref

AR: agree, with proposed change, you can’t do that anymore. You have to check every instruction

RT: in ref interpreter, abstraction

AR: ref interpreter is not how you’ll do it

CW: extra slides here to concretize. How SpiderMonkey does the fused decode validate loop.

RT: if type stack is bottom then remains bottom

BT: validation of other immediates, like nesting depth of target of br, suppose you have dead br in unreachable code, invalid depth, you have to track control depth. Which means you need to mix all the logic into the decoding invalidation loop. Cannot make it bytecode iteration thing. At this point you will probably save 0 lines of code in any validation algorithm in any engine.

CW: don’t care as much about LOC, but save some brain power. Which is what this proposal is trying to do.

BT: from implementers, they want confidence that they have handled dead code properly. Up till now, you can hide behind push/pop, but not going to fly. You need to handle dead code directly.

RT: typestack.push can prefers the stack abstraction, if it is bottom it remains bottom

CW: that is true for MVP instructions. But for load.memref you need to condition more, need to condition more on the memref.

RT: if it’s a bottom type there you have to do the same thing anyway.

CW: we both agree, Ben's proposal goes further, have a flat bytecode skipper, chew up opcodes and immediates without doing any sort of checks.

RT: something even more relaxed

CW: essentially

BT: which i think is off the table, because you have to check contro depth to validate br targets.

CW: it’s clear you have an alternative version

AR: can’t just be skipped bytes, you need to at least match brackets.

CW: true, much more simply with a counter, if you’re doing a naive

AR: yea.

BT: canonical example why this breaks down, which we discussed on an issue, return call ref. Tail call where it pops a first-class fn, you need to check that its return type matches enclosing fn. The actual validation algorithm has to check if you are unreachable, no real type you can return, even bottom. You have to have a rule that bottom matches any function return type. That’s ugly.

CW: analogous to how you have to implement memref. Have to condition how you pop immediate.

RT: boilerplate rule, otherwise the validator has to check reachable/unreachable

CW: sounds like we have two philosophies… aren’t strong objections to doing any kind of change, but division between whether we should do this as “switching off individual checks” in the existing decode-validate logic (current proposal), or a separate simple skip-bytes algorithm. Maybe I should write both ideas, have implementers feedback on github issue. Sounds like a good summary?

BT: i would phrase differently, i think the skip-bytes thing is dying a slow death.

CW: selfishly that works for me, would still like to hear from others.

AR: i fear it would have additional problems, just an intuition, can’t point at anything. Would make the distinction between decoding and validation even…

CW: starker

AR: yea.

TL: end of time

CW: 30s plead, rather light on input from people who need to make these changes in the browser. Would like people to comment whether okay or not, a general thumbs up or down.

AR: in practice they won’t find out until they actually try.

#### SIMD-specific [feature detection](https://github.com/WebAssembly/simd/issues/356) (Thomas Lively) [15 min]

[Slides](https://docs.google.com/presentation/d/1Rny2KazvO5SUm0I7aU2jWH17_kXc4Ls2ZDifpAfZ85w/edit?usp=sharing)

AR: it is a bit difficult to answer that without seeing how the proposal looks like

TL: true. The concrete thing is extremely strange, no sugar coating. Didn’t get into technical details, we might want to change it later. If we can’t come up with something CG approves before Phase 4, then we won’t do it. More of a question for CG, should this be a goal.

BT: are you asking if it is acceptable to include feature detection in SIMD?

TL: yes, current simd proposal

PP: the danger is we end up with the same overload, one class of instructions per day

TL: yea, we will need to come back to the CG with the updates on instructions

RT: will this feature detection help you with that?

TL: hard to say, not something we can tell people so far. If we have a good story for deferring instructions to post-mvp, will help us finalize the instruction set

PP: that’s the logic we told people, danger to some degree, scope creep on all the extra instructions, need to extend to 256 bits, non-det and so on.

AR: similar question i wanted to ask, underlying this proposal seems to be that SIMD will keep growing, or is that a wrong perception. I find that scary in itself, separate of FD.

TL: can’t keep growing without CG’s blessing. We have pressure from users to continue growing the set, business needs to keep growing. There will be new proposals to keep growing it.

FM: slippery slope argument, one reason why people are not expressing an opinion. We are starting down a slippery slope which might be an innocuous idea. If you have any kind of variability or optionality, you have the combinatorial explosion, not solving anything by permitting that.

TL: e.g. webgl extensions are an existing case on the web, pretty good experience so far for users. Problem is that the combinatorial explosions exposed to users due to the many builds they have to deal with. Feature detection can hide that.

FM: that’s the main issue, instead of combinatorial explosion, anticipate only incremental changes, if new extension, it’s on top of all the other extensions.

PP: that post from marat supporting both sse and neon, it should be incremental.

LW: speak in favor, hard problem in general, if you zoom into SIMD, you can have a local polyfill, purely computation, does become different and solvable problem

AR: question this a bit, will we ever need this in function sigs. Can’t put that into separate fns

LW: different fns, use but trap.

TL: I can make a more concrete design and come back to present.

### Closure
"
gc/2020/GC-07-28.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 28th video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: July 28th, 4pm-5pm UTC (July 28th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Wasm interop with host languages like JavaScript (@tebbi)
1. Closure

## Meeting Notes

### Introduction of attendees

* Adam Klein
* Andreas Rossberg
* Ben Smith
* Daniel Wirtz
* Emanuel Ziegler
* Francis McCabe
* Jakob Kummerow
* JP Sugarbroad
* Lars Hansen
* Luke Wagner
* Ross Tate
* Ryan Hunt
* Sabine
* Slava Kuzmich
* Tobias Tebbi
* Wouter Van Oortmersson
* Zalim Bashorov
* Zhi An Ng

### Discussion: Wasm interop with host languages like JavaScript (@tebbi)

Slides: https://docs.google.com/presentation/d/1BqRlDrQIYdkRHHtoZ7F8a2tpFwYoumCCbqQ4SpULajI/
Issue: https://github.com/WebAssembly/gc/issues/107

[Talking about hash maps / identities]

AR: I'm not sure that I share your assessment that most languages need identity. Even for OO types, languages with tuples would not have identity.

TT: Right, that's why it would be an opt-in feature.

LW: Do you need something separate than identity for hashes?

TT: Not in the spec, but if you need to put an object into the hash map you can't use pointer.

LW: Isn't that an implementation detail?

TT: Yes, but to do so you need to add it to the header, which may be something you don't want to pay for.

FM: there’s more to it, take Java for example, hash in java is a user-definable function, you implement it yourself. If you were compiling Java to Wasm GC, you will compile these hash functions. You have to make sure now that the hash value that the Java class has implemented, is going to be the same as the hash value that JS sees. I don’t see how you can do that if you bake it in at that level.

RT: I don't know enough about how this is done in JS -- but there's an issue filed on this topic. There's system.identityhashcode, but it's not implemented with a field of hash code. Instead there's a weak hash map that's maintained, so for objects that are asked the VM stores it in the table and stores it for you. It's provided on demand.

SK (chat): Java has a notion of identity hash code. It is used by default if you don’t override hashCode(): int

FM: talking about two kinds of hashes... if JS applications see the hash value, it should be the same “normal” hash value that Java applications see it

TT: I'm not sure they actually need to be the same. But you at least need some kind of identity to implement maps and sets. But many languages expose this value as some kind of pointer identity. What you want is that JS maps/sets expose as identity. Given that languages expose the identity code, you need to expose that...

FM: should drop the hash code from the phrase. From average Java POV, you’re just doing pointer comparison.

RT: Java has a class called weakidentityhashmap, which uses hash codes for lazy fields/on-demand fields.

AK: this question is very specific to map and set in JS, implementation specific, can dig into it a lot but maybe should move on for now.

TT: Right, separate discussion. We can move on.

RT: certainly dig into at some point.

[Tobias goes back to ""Alternative"" slide]

FM: Comment + question. You talk about wasm GC as language, but it isn't really, it's target of many different languages. So you're really talking about interop between Java + JS, etc. Each one of those languages has their own strategy for doing stuff. The question is, did you look at -- some of the issues you talked about are reminiscent of Interface Types. Have you looked at IT at all, in particular for attaching methods.

TT: I have not, but will be curious to learn how this would look like.

FM: The main difference is that we're not attaching stuff to data. Everything is done through an adapter structure that lifts the semantics from your language to some common language. It won't give you everything, e.g. we don't provide access to cyclic structures. Some of the principles are -- the style is different to the RTT -- but I think it more accurately reflects the language interoperability problem. You don't know what the other side is doing until you have a more limited style of interoperability.

AK: one of the use cases TT raised, you do know the surface language is the same, the one generating code knows both sides. Second one of the initial slide, you have a compile to JS app that you are transforming into compile to Wasm.

FM: I do think that's an important use case, but I think that we shouldn't use that to modify wasm in itself. You're talking about compiling Java to JS, but there's a more general problem, taking a JS application...

TT: you could extend your Java to JS compiler to also target Wasm GC for some parts of it. This one compiler can cut a boundary wherever it wants to make sure interop works. JS itself will be a reasonable denominator.

FM: No, if you're a Java bigot (which I'm not), then JS is just a target. The language I'm trying to port is Java and not JS.

LW: different and compelling use case. TS or Flow, permanently output both JS or Wasm, depending on how much you opt in to static typing. Existing languages need to output JS because they are dynamic. A TS app can have some modules JS or some modules Wasm, in a transition period.

FM: right, is this a reason for modifying Wasm?

LW: I think there are a number of ways to achieve that goal.

SK (chat): Could we also have computed JS properties on Wasm objects by adding special get/set functions on RTTs?

ZB:(chat): Have you considered having an ability to add “interceptors”? In other word “accessors”.

TT: That's something we thought about. I didn't present it now, but technically we could do that.

AR: this is the problem, you’re pulling the JS object model in there. This is what dynamic languages would need, I am skeptical of that claim. THere are many instructions there very specific to JS. First the methods, this is OO. then named properties, and ability to put named properties on any object including arrays, JS-specific probably… That’s one part of the problem I see, another is, what do these instructions mean? They don’t really have meaning within Wasm, how do we describe what they mean. Another instance of the case of, intrinsics. You want something to be able to use in the language which is not really part of the language itself, no meaning, but you want it to be efficient somehow. My feeling is that we should be solving that problem, then it might be a neat use case for adding intrinsics if you want to interop with JS, for e.g..

TT: In principle I think I agree. Independently, I think this is solving a problem we have in browsers. So I think we need some kind of answer. I'm not saying adding instructions is the only answer, but we need some answer.

RT: this is an important problem. Trying to play with the ideas. What are your reasons why creating a prototype for objects upon it leaving the Wasm module is a bad approach… Easiest thing to do without your stuff is, export some ref to a structure, JS takes that and it’s a raw structure, no prototype. Then make an object that is a pointer to the struct and has a prototype for accessing a struct. Involves making a wrapper. Why is that so problematic? Want to hear your reasons.

TT: It would be really nice if it was zero overhead. Wrappers are a problem if you need to pass them back and forth. If you pass and forth you need to re-wrap, or have them point in both directions.

LW: you want to know what’s the right shape/map/structure to use on construction of the object. You have to thread that to the allocation instruction, one way or another.

TT: The only alternative to this -- the alternative dosn't really need this. It requires RTT having identity, but later you can add the information to it. But it has its own problems.

LW: an alternative… if we assume rtts have some js api reflection, runtime object that represent wasm export rtt, we need those in any case, probably a way to construct a wasm type, construct an rtt from js using js api. If we have to have those anyway, wil it be okay to say JS construct RTT, from the JS api, you can say what is the prototype to use. From wasm perspective it’s just an rtt that is imported, struct new with that rtt. That’s how you wire it up. You incur some run-once overhead with this. But with hidden classes it’s not free.

TT: I was actually referring to hidden classes that you use to create object literals for example. JS incurs additional cost for this in many places.

LW: you suppose that can be where we start. Then optimize it. As a baseline we can synthesize rtt in JS, set them up, import in wasm, that’s a starting point.

TT: It's possible, but there are other problems. I suggested that methods should be wasm functions. In this proposal you wouldn't have reasonable access by default. It sounds like you're making it into an array (numeric access to wasm fields)...

LW: That’s something we can tweak, how does one write these methods/accessors. They can be tiny little shims that can be inlined, how can I write a method shim in JS that then does the real access to the Wasm object, and what even is the real access? Don’t like the array access, it’s too public-y.

RT: A variant on the idea is that you can import RTT that represents JS layout. It has identity, etc. When people make sub-RTTs of that, in wasm, the engine can generate prototypes for them Afterward, people can modify those to add fields to RTTs, but they know that those are all safe because they type check.

TT: I tried to avoid prototypes for everything. All The methods and properties are done without using prototypes, making them easier to optimize. Want to mention 1 more thing, i was talking about methods because it’s hard to produce RTT on JS side, you can’t refer to Wasm before you have the module.

LW: I would assume that the wasm object takes the receiver as the first parameter, and the glue code would pass ""this"" as the first argument, in the glue function.

TT: you still have the problem, export something from Wasm... because you use late binding mechanism of JS. A lot more direct if you just have everything together. If you directly export fields without any additional shim, e.g. first tiers in JS (interpreters) can already optimize that. If you always go through getter setter, worse performance until you JIT.

RT: Another thing is -- there are wasm modules, and in interface types that are adapters. There could be specific ways that you could interface with JS. There is a way that you could hook in, this requires you to hook in directly with the wasm module itself. You could imagine that there is a RTT mapping, but maybe in the JS ""code"", so you could use this instead.

TT: you don’t get this kind of lazy initialization as you construct rtt. Global initializers, you create RTT and JS view right at the same time, you don’t have to run any code until then. Any solution that doesn’t hook into the global initializers won’t have this property.

LW: Speaking to the earlier point about fast data access. If we're saying that the types and RTT are constructed from the JS API, then you can imagine that when you describe the structural layout, you can describe the name. Then you can give public property names to them, and then they wouldn't have a shim.

TT: True, you could do this same thing. But for methods you would always need a shim because of late binding.

LW: right, probably get inlined.

TT: From implementation perspective, adding these instructions is not complicated. Should be part of a bigger discussion. These instructions make sense at the moment for browsers. It would be fine if just browsers implement them.

RT: There's also the intrinsic idea, that Andreas was mentioning earlier.

TT: I think you generally know when you're shipping for browser, or not. You usually know when you're shipping in module.

FM: not quite accurate, there are scenarios where computation may be run in the server or browser, that’s a choice made relatively late at runtime.

TT: Sure you could have modules that don't have JS interaction -- but when you write the module you know when you're interacting with JS or not.

RT: currently that’s the case, will that always be the case? Will people compile Wasm and have it work in a variety of settings or compile specifically to the platform they are targeting. That's why we have embedder specific adaptors. Think you have interesting ideas, trying to work with you to play with ideas and combine them with constraints in the space.

BS: wanted to mention this comment in chat: “How about to be able to define whole shape  simultaneously? (w/o intermediate RTTs)
Maybe even define it statically” - ZB

TT: proposed mostly for simplicity. You can also have more complex form, a section describing tree shape of complete thing, then single instruction to write everything at once. A complication instruction that takes all the information as an immediate. Easiest to present this way but not necessary the best.

ZB: another question, have you considered having an ability to add interceptors, something like accessors.

TT: yes, in the earlier version of proposal we had that, I don’t see any technical reasons you couldn’t have it. Similar to method, you can install something like a getter, that actually calls a Wasm function. The reason why I presented it this way is because having the JS interpreter fast, simple case fast, you want directly readable and writable fields without any calling.

LW: can it be useful for JS to create/consume GC objects even without Wasm around. Just wanting to use these as objects that are more JIT optimizable, maybe want stricter typing.

TT: I would like that. I think that's missing from JS language. Can't comment on how difficult it would be to get through ES, but I would like it.

RT: like the typed objects paper

LW: if it was in JS, a first class extension to the class syntax to declare this with extra keywords… when you think about that, how does that interact with Wasm, use that only, or with Wasm?

BS: probably a good place to leave it. Thanks TT. Continue discussion on [GitHub issue](https://github.com/WebAssembly/gc/issues/107).

### Closure
"
stack/2021/sg-2-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 22nd video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**: February 22nd, 17:00-18:00 UTC (February 22nd, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Ross Tate
Arjun Guha
Luke Imhoff
Zalim Bashorov
Emanuel Ziegler
Daan Leijen
Sam Lindley
Thibaud Michaud
Thomas Lively
Paul Schoenfelder
Zhi An Ng
Luke Wagner
Paul Dworzanski
Derek Shuff
Andreas Rossberg
Asumu Takikawa
Adam Klein
Ioanna Dimitriou
Daniel Hillerström


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. Capturing foreign frames
      1. Point of view 1 (Ross Tate) [10 mins]
      1. Point of view 2 (Arjun Guha) [10 mins]
      1. Discussion
   1. Ensuring coherence with external async code (Francis McCabe) [5 min].
   1. Next meeting [2 mins].
1. Closure

## Meeting Notes


### Adoption of the agenda

### Discussion:

RT: Why to Localize Non-Local Control. Slides: [(pdf)](presentations/2021-02-22-tate-why-to-localize-nonlocal-control.pdf) [(pptx)](presentations/2021-02-22-tate-why-to-localize-nonlocal-control.pptx)

RT: Dynamic enforcement: either suspend up to host frame automatically or trap on host frame. Either choice makes migration of code between host and Wasm difficult. Static enforcement: put an effect signature on each function. Most source has same signature. Adapter code handles effects not understood by embedder.

LI: The type signature looked similar as the effect handlers signatures earlier. Is this signature the same as the signatures in the multi-core OCaml paper?

RT: not sure the multicore ml paper had effect signatures. Daan’s work does. The one that you linked by Yizhou Zhang and Andrew Myers had explicitly effect signatures.

LI: explicit so you didn’t get confused, you didn’t mean to handle this effect…

RT: you're talking about lexically scoped effect handlers by Zhang and Myers
AR: You mentioned reasons effect signatures didn’t work in Java. Another reason is that you need polymorphism over effects for e.g. function pointers. Signatures won’t scale.

RT: worked through some concrete example like async/await, no need for effect polymorphism, you can have a concrete effect. For use cases that people have said they need, in earlier requirements document, this works.

LI: works with effect pass through? How would you declare the type that you would be allowed to pass through, without knowing the exact type. Is this called “row types”?

AR: one way to make it polymorphic, need some way of quantification over effects you don’t care or don't know about.

RT: Right, you need that when you have fine-grained effect systems. For our needs it looks like we just need a course-grained effect system.

SL: i’m a big fan of static effect type systems… wondering how much evidence we have that this is really necessary. None of this is implemented anyway. Will be good to know whether we do get performance problems if doing this dynamically, or we can take a conservative approach and always insert some sort of delimiter when making a call from the host into Wasm. You are certain this will have a performance hit, do we know this for sure?

FM: let’s pick up on this after Arjun’s discussion.

Presentation from Arjun Guha [slides](https://drive.google.com/file/d/1Xkewt42HwqGVyRRMhmE7OeXW3LpkR4e4/view?usp=sharing)

DL: this looks like multi prong delimited control, restore is resume.

AG: even lazier than that, no multiple prong. No reason that we could not…

DL: good to be simple first

FM: How would you make the continuation ID unforgeable?

AG: you cannot do that here, because they are numbers, it would be difficult to pull off if you can store into linear memory.

AR: you’ll need reference types to achieve that

LI: similar to WASI using ints until we have unforgeables

AG: yes, this is just designed to fit into Wasm 1.0

AR: they probably can’t be cyclic, can’t create any cycle between continuations and other memories, some simple ref counting strategies should be sufficient to automatically handle memory and resources, you don’t need full GC. Is that the case in your semantic as well? Or can create cycles?

AG: I’m not familiar with this discussion. Talking about cycles between... ?

AR: do you need full GC? Or is ref counting enough? And that depends on whether cycles can form between continuations and other things in the engine

AG: We don’t use GC or reference counting.

AR: if you had references, then you could hide reference counting behind those, and engine can free them automatically. But that subtly depends on the property that you can’t form cycles between these things, i think is the case if you only have one-shot.

AG: if you have multi-shot continuations then things get significantly more complicated

DL: You cannot cross Rust/JS with a control operation?

AG: Right, you can neither capture this frame, probably obvious, but also can’t discard the Rust frame entire without returning to it. Some destructor that needs to run, forcing to return to Rust is essential.

AR: What happens if you suspend while a Rust frame is on the stack?

AG: rust frame on the stack, capture a continuation below, i get an id for the continuation, that refers to the delimiter up to in between rust and current frame. I can restore the continuation, which takes me to the delimiter, then returns control to Rust.

FM: How do you prevent using a token from earlier?

AG: there is a table that maps continuation ids to real continuation values under the hood, every time you push/pop, you push a fresh new table of continuation ids. The delimiter says that the continuation ids you have earlier are no longer in use.

FM: But there’s nothing to prevent me from using a previous ID?

AG: it’s a dynamic check, when you try to restore a continuation, we check if it’s valid. There is a set of continuation ids that are in scope, when you push a delimiter, the existing set goes out of scope.

AR: if you capture continuation and if you don’t know if there is an implicit delimiter in between, at that level it is an untyped language, in terms of higher level language compiled to that, you get a different continuation as expected. You can’t even detect that I think, how do you know you have a different continuation than expected.

AG: While compiling a high-level language to Wasm, it presumably generates calls to the host language... 

AR: the compiler might not know, might be something the module imports. Might have a native frame in the middle of calling the imports.

AG: I wonder if it is feasible to do modular compilation with the assumption that we have one module that uses high level control and another module which doesn’t use it at all

TL: as an example, in c toolchain for Wasm, when you compile an object file, a module with relocations, you don’t know if the undefined functions will be host functions or other wasm functions from another object file. You could mark that in source code and do something, explicitly put delimiters in.

AG: it’s a thorny issue. Implicit delimiter is not necessarily the right thing to do. In Racket, it’s a continuation barrier, blows up with an exception if you try to capture in an unsupported context, runtime error instead of weird behavior. The other option is static error, what RT proposes.

AR: that would be a third option, dynamic error is a right thing if there is a way to catch it, a trap in Wasm is not necessarily the right thing, you cannot catch them. Another option is that the operation that does the capture (control) has another failure continuation where it jumps to when it can’t capture. Then it’s notified it cannot do that and can handle it.

LW: It seems like you could turn it into the host’s version of an exception and propagate it normally, turning it back into the suspension above the glue code frame.

AG: that would be cool.

AR: that presumes you have some glue code, that’s the model on the Web, but not necessarily else where

LW: the code in the middle knows it is glue code, then it can be expected to do that (contract of being glue code), or it is not glue, or some other code that is linked, then it seems weird to be reentering and be expected to do that.

SL: current status of exception proposal? If we forget about continuations and think of it as raising exceptions, does it smoothly propagate through the Rust frame?

LW: if in JS we defined it it pops up as Wasm Exception, in Rust less clear. The exception basically carries an continuation inside of it.

SL: I’ve worked in a similar scenario, but the different frames might be on different machines. We had implicit barriers that prevented any effects or exceptions from crossing them, but also had a static effects system to guarantee that nothing went wrong.

AG: going back to LW’s original suggestion, it gets tricky to resume continuation. You want to resume, and need to reconstruct the stack top to bottom. It gets tricky to do.

SL: that’s where exceptions are much easier, there is no continuation to resume.

LW: If the rust code in the example, propogates by returning, it is taken the frame out of the stack. JS can return promises, JS can get itself out of the stack as it bubbles out.

AG: Is that what you want?

SL: need a mechanism for Rust JS to tidy itself up

RT: There’s also the issue that the removed Rust frame might have accepted and returned different types, so removing leaves an improperly typed call stack.

AG: we fudged it here by saying we only return ints, but it is more than just types. If the Rust code is doing useful work, chances are that there is useful work to do even on resumption. If on restore you take the Rust frame off entirely, you end up limited expressivity a little bit.

FM: Everyone’s been talking about foreign frames, but the same problem comes up when it’s another Wasm module, potentially from a different language. For example if the other module is compiled from C, which is not control-aware.

LW: It’s not an exception that needs to bubble up. Imagine the middle is just JS. When an uncaught suspension bubbles out, it pops out as a Promise since it hasn’t returned, it suspended. If you call an async function, it returns a Promise. I can return Promise up the stack, until it returns to outer wasm. If it has a particular promise, that suspends outer wasm until that promise resumes.

RT: But from JS perspective it calls a function that returns i32.

LW: Yes, then you just get a promise instead. 

FM: Wasm doesn’t know what a promise is, there is a type mismatch, Wasm function cannot return a promise at the moment, what is the type of a Wasm function that can suspend?

LI: How does the browser know that a function is async?

FM: we can discuss this next time, it is compiled to a function that returns a promise. You can’t use await outside of a function that is marked as async.

AR: that is a limitation of JS. If you have delimited continuations you don’t need that limitation. The question is how do the two mechanisms interact.

LW: ignore async await, think of it as sugar for Promise, and only think of Promise

AR: You will probably need to import some operations on Promises in order to work with them from Wasm.

LW: there could be a default thing that just works in JS API, what happens when effect bubbles out

RT: Oh you mean some sort of implicit conversion in the JS API.

LW: Yep.

AG: we are now getting into GC-ing continuations

LW: in browser, no problem, already have GC, just when embeder does not have GC

AR: Wasm makes a distinction between Wasm core and JS interaciton, completely separate document, this kind of things will not be in core, but will be in JS API. If that is sufficient, and LW’s idea of treating it as conversion, then we don’t worry about adding anything specific to Wasm

LI: I don’t know if this work for all types of effects, but in our Rust we got the Web executor from web-sys, and ... and if the promise dies, we call reject on the promise.gf

LW: a lot of different ways to interact with Promises, use externrefs

FM: anyone willing to sign up to give a presentation on this next time?

RT: on what?

FM: i don’t think my question has been addressed. If you call a function, you need to know if it can suspend, JS has a promise structure but it is not just JS involved here. Do we need to mark a function in a special type to reflect that it might suspend.

SL: isn’t that what RT was proposing.

FM: he was proposing that in terms of capturing foreign frame

SL: seems like the same mechanism. The mechanism that LW was describing sounds intriguing. If you can describe that to us more. LI’s mechanism was interesting, in terms of presentation.

LI: yea I did it in a talk, i can do that

LW: can make a sketch, but a little code out there

FM: LI and LW will present for next talk

SL: I still have my question about the performance consideration Ross was talking about, but I guess to answer those we would need to build and measure something.

FM: in the case of a C++ program using effects or continuations to implement async await, you are going to have a very deep stack between where you do await and where the thing is captured. It could be many hundreds of frames. Q for AG, in that scenario, what is the cost of doing a suspension.

AG: you think we will have a stack frame hundreds of frames.

FM: in C code, it doesn’t know async/await itself, using it to do asyncio, you’re deep in your application. You are making a synchronous call to i/o but converted to async i/o. Not a language which knows anything about async await.

AG: don’t have an answer to that, different kind of experient we can run. There is something simple we could do, we can take the safety checks and throw them out, and if doesn’t get faster, it tells you something.

SL: you also experimented with implementing async/await on top of C, C with handlers, have to tried an experiment along the lines of what FM was talking about.

DL: What I did with algebraic effects in C was capturing an entire callstack wholesale. Then it doesn’t matter how big the stack is except that you have to copy it. Since you know it’s just one contiguous piece of memory, it’s cheap to copy. If you can build in the write primitives, it shouldn’t matter how deep the stack is.

FM: we cannot allow host frames.. When we suspend we cannot capture any host frames, part of this discussion is how to prevent this, make sure you’re not capturing host frames.

DL: The host frames are related to linear resources. If you suspend, it’s good to know whether you will be resumed at most once, at least once, or exactly once. There may be resources that always need to be cleaned up once no matter what. Related [publication](https://www.microsoft.com/en-us/research/publication/algebraic-effect-handlers-resources-deep-finalization/).


### Adjourn



"
simd/2022/SIMD-08-05.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 5th video call of WebAssembly's SIMD Subgroup

- **Dates**: 2022-08-05
- **Times**:
    - 4pm-5pm UTC (9am-10am PDT)
- **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this [form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking
1. Adoption of the agenda
1. Proposals and discussions
    1. BFloat16 experiments (Marat Dukhan)
    2. Meta discussion on adding instructions for future hardware
1. Closure

## Meeting notes

### Attendees

- Andrew Brown
- Anton Kirilov
- Deepti Gandluri
- Johnnie Birch
- Justin Michaud
- Marat Dukhan
- Petr Penzin
- Richard Winterton
- Zhi An Ng

### BFloat16 experiments (Marat Dukhan)

MD: on cpus like X2 with native FP16 support, 2x speedup v.s. fp32 on instruction level, using fp16 dot product compared to fp32 FMA, approximately 2x faster, 4x faster compared to without relaxed simd. haven't done matrix multiplication test. want to discuss whether such matrix mult benchmarks will be adequate to make a decision or not. Won't completely close the gap with native, at least on ARM, there are native isntructions which do native fp16 matrix mul. this is a simple way to get the benefit of bfloat16 with just 1 instruction

DG: was this ARM64?

MD: yes, all current CPUs which support BFloat 16, same throughput as for FP32, but BFloat16 will produce twice as many results

DG: this is if you were to use bfloat16 on arm64, diff is purely performance, any semantic difference?

MD: if we use dot product there will be semantic diff, we can use 2 instructions isntead of 2, some small speed up to avoid conversion between bfloat and f32, will need to try after complete impl

AB: any x64 tests?

MD: no access to x64 CPUs with BFloat 16 extension, Raptor Lake should have it, Alder Lake with efficiency cores disabled unofficially support it.

PP: that's turned off in BIOS now, won't be able to do that

PP: extremely rare, only supported in XEON, not usable by everyday users

MD: Wasm is not restricted to desktops

PP: only want to note this

MD: will be AMD systems, with support for BFloat 16

PP: any link for this?

MD: linked in the PR https://www.anandtech.com/show/17399/amd-ryzen-7000-announced-zen4-pcie5-ddr5-am5-coming-fall

DG: elaborate on the 2 instructions?

MD: base line, unpack odd bfloat, unpack even bfloat, do 2 fmas. We can save unpack instructions with 2 instructions, will preserver bit exact compatibility with simulation code that would use four for olden CPUs.

JM: for performance numbers, have anything more holistic? not just instruction itself, but a more representative use case?

MD: no complete matrix multiplication benchmark, expect to have it over the weekend

JM: would like to know with the 2 instructions what performance will be. If there is a risk of compat difference between 2 versions of ARM chips, that's not something we want to risk.

MD: 2 ways to lower, directly bf dot instructions in bf16 instruction, this has different semantics than simulation code (even, odd, fmas). ARM also has bfmla instructions, specifically for this use case, when we want to bit exact with emulation code with previous generation CPUs. These instructions come with cost, twice as expensive as bfdot, but are on today's CPU. if we target bit-exact compat, then it is acceptable.

JM: want to make sure we have this data point, thanks

DG: from chrome perspective, still trying to get user data of how we slice down user stats, for fingerprinting, depending on how many people are on the newer subset. We still have older users we have to support, don't want to increase fingerprinting. Engines can dynamically make that decision, depending on what exactly we want to support, how we see that performance to deterministic trade off. Risk of fingerprinting on this instruction seems high. Not opposed to include in spec, but won't see us getting the performance off the bat.

MD: would be acceptable to start with 2 instructions today, bfloat16 in armv9, and eventually all CPUs will be on armv9 and later, then we can switch to bfdot

DG: to JM, curious about how you think about including something in spec v.s. how deterministic engine can be

JM: agree with you so far, Apple cares a lot about fingerprinting, in this instance more concerned about compatibility. Haven't seen a lot of applications using relaxed simd, my impression is that this instruction is very early, most users don't have a computer that supports it, from that perspective, we should be cautious to not introduce compatibility cliffs

MD: is your concern about performance cliffs when instruction is simulated?

JM: concerned about a bug where some website works fine in Intel but doesn't work on ARM. Acceptable if there is an enormous performance benefit. If it is 2%, seems not worth the risk or extra complexity. Other parts of the spec are clearer on performance benefit on wide range of data. Curious about actual performance of this instruction.

MD: do you know if Apple M2 supports bfloat 16

JM: no idea, haven't figured it out yet

MD: Apple recently added M2 detection to cpuinfo library, probably already supported or maybe in future iterations

JM: i don't have an M2 yet

ZA: AI on Marat for matrix multiplication benchmarks

### Meta discussion on adding instructions for future hardware

DG: where do we stand on adding new instructions to make it more future proof? we have to spin off relaxed-simd spec because we didn't include instructions, so we don't have to spin off another new proposals.

PP: we realize that the determinism was an obstacle in some case, relaxed simd explores slightly different aspects, need to relax the spec, if we stick to original assumptions to SIMD, won't be adding any of these. flexible vectors explore something different also.

DG: say we don't add bfloat16... some things i run into is that applications run into performance bottlenecks with out of scope instructions.

PP: realistically, this is a separate aspect, so far there is an instruction for this, so far we are talking about speculation, targeting future, not yet implemented instruction

DG: started to think about this for bfloat16. Posing it as an open question.

MD: would be problematic to have an extension for just one instruction, a lot of organization to go through all the phases. An instruction would need some strong champion to push it through, if it is not in relaxed-simd, probably won't happen at all. Wasm doesn't have any runtime instruction detection, if Wasm modules have instructions not supported, engine will reject entire module, any subset of Wasm instruction extensions have to be treated as a different instruction set. Already today there are many combination, MVP, MVP+SIMD, MVP+SIMD+Threads, MVP+threads. The more instruction extensions we add, the bigger support matrix. Software designed for particular subset supported by web browsers, we risk getting into situation where developers start targeting particular browsers. Overhead and risk in adding small extensions. Hard to manage to library and application devs.

PP: super important, there is a problem with our process, need to resolve it somehow. Just adding extra things people have to buy wholesale.

JM: very reasonable, the other point is, if CPU vendor adds a bfloat16 with semantics just subtly different, that don't match what we decide to spec, could be a huge performance cliff. Not sure if the safe option is to add the instruction, or not have it. Have to look at performance numbers. Very hard to predict that. Was there any discussion of other ways to get this performance? Perhaps allowing speculative optimizations or allow instruction selections in the engine, applications can hint that they are fine with some rounding behavior for different instruction patterns.

DG: had couple of approaches, could still come in the future, something similar to clang fast math. In the tools (Thomas Lively will know more), applications can specify this, and they can generate. The autovectorizer won't use this directly. If you want fast math, can generated relaxed simd, probably. Right now the only way is to use intrinsics. We still need these SIMD instructions, especially for Wasm, there is no way to say we can reduce determinism a bit. Engines can do this at some point, but probably not the right way, each engine can have different behaviors.

PP: what happened in SIMD discussion a lot is compare different lowerings between architectures, don't think hints were really discussed. question about relaxed simd and autovectorizer, is that the plan?

DG: depends on a bunch of different things, if you enable it in autovectorizer, easy for random applications to pick it up when we won't want them. Have compiler flags to enable these instructions.

PP: if fast math enables this in autovectorizer, that's' fine. If this can only be used in intrinsics in the future, we cut out 90% of developers

MD: target here is dev who write matrix multiplications, you don't accidentally write bfloat 16 matrix mul

DG: Marat and Zhi are library authors, assuming authors know what they are writing, applications just use the libraries, we are seeing this a lot in Wasm and SIMD specifically, they are built into backends, they are mostly not going to try this new intrinsic out. It is based on how library support them, this is the case of XNNPack, Halide, Draco. We are enabling them from behind the scenes. That usage model for me is the right one.

PP: what i mean is that 90% of people who write arithmetic in their source

DG: we are not expecting them to use Wasm intrinsics, they are using C or Rust and compiling. If the autovectorizer is not using them, how are these visible to them

PP: if they write arithmetic, would they get relaxed simd instructions

DG: potentially if they use fast math, otherwise they won't

PP: don't know if it requires platform detection to work correctly, needs to be tested in toolchain

DG: engines decide what code to generate based on extension (SSE2, SSE4), they do a lot of work to ensure that same outputs

PP: for some libraries like XNNPack, they have different code based on runtime arch.

DG: toolchain person not around, we should talk about what toolchain support looks like

MD: back to original question on whether we need a fast math mode to give this ability to engines, that mode was originally in relaxed simd proposal, discussed and the conclusion is that it shouldn't be in relaxed simd, it can't guarantee that scalar computations follow semantics, first due to vectorizations, second due to cpu modes, this modes affect both scalar and simd computations, if this semantic is added to Wasm, should be higher level, not as part of relaxed-simd proposal.

PP: there was a proposal for adding different arithmetic modes in general

JM: thanks, does anyone know what the status is feature detection in Wasm, any proposals? If that area is what is holding us back, then it is worth pushing harder on that.

DG: two proposals, conditional segments, newer feature detection proposal https://github.com/webassembly/feature-detection. runs into issue of how to make this proposal generic enough to be used outside of SIMD. E.g. for threads, how to detect shared memory, worker based threads. Other thing is also libraries built on top of Wasm, there is a wasm-feature-detect JS library. Tried to make a hard push at some point to get feature detection across the board in conjuction with relaxed-simd. Given the number of issues, we split them, relaxed-simd has a better defined scope.

JM: has anyone discussed about requiring engines supporting all the semantic behaviors? do we have a mode where the engine is required to run in all of them, so application developers can't forget to test against configurations? When they have SLAs they artificially have downtime so downtime services don't depend on too high SLA.

MD: some features are hard to emulated when not supported in hardware, e.g. FMA, emulation is very slow, it would negate all the impact of SIMD. Not really possible to support all options on CPU which don't support them.

JM: i guess most web browser implementations are tiered, a lot of the SIMD instructions, as long as instructions tier up, potentially haven't a few iterations running in the slow mode might not be enough to offset. If instructions doesn't perform a big enough performance benefit to offset that performance.

MD: we guaranteed that runtime will always lowered the same. If you have FMA, it will also be FMA, or non-fused. Will break in software

JM: It would break on CPUs which developers didn't test on

MD: there are algorithms which require FMA, and algorithms that completely break if compiler fuse certain computations. There is a good chance it would break on platforms that aren't tested. We discussed an option for Wasm engine to use some non-standard behavior, not behavior that is native in this platform. At least not in V8.

DG: for fused or unfused results, the baseline compiler and optimizing compiler, we try to make sure they are emitting similar code. We don't support all of the lower end hardware, it is a decode error.

JM: my concern is that application developer will write it, and only test on intel on chrome on a new PC, then it will be broken on ARM, or browsers with different lowering, if there is anything to try to encourage developers to test on all configurations.

DG: been talking about this, platform test for web api features. Maybe you can run in a sandbox environment to test compatibility, but we could not find a feasible path to emulation.

MD: already possible to distinguish between x86 and ARM, in principle, possible to write software that is broken on one v.s. another, unlikely you can accidentally write such it.

PP: OpenIPC, demo of h264 or h265 on the web, using SIMD performance was not the same, some browsers have 2x speedup, others have 4x (not terrible though).

DG: one thing we tried in V8 is have a scalarizer in engine, got too hard, and maintaining semantics correctly, it didn't justify what we were seeing. If relaxed-simd had scalar lowering, to make it accurate will be really hard.

JM: make sense, we've had a bug report where a website that worked in Chrome but not Safari, turns out we didn't expose the number of logical processors, we always return 1, fingerprinting risk. Chrome and Firefox returns actual numbers, they have code that did something divided by processors - 1. Worry that some hardware configurations, which are hard for users to get, for example for developers in other countries. The concern is that we create a future where some platforms have a higher risk of bug, because devs don't test on them as frequently.

DG: one thing we can do for this proposal specifically, is to talk about entropy of this proposal specifically. Discuss fingerprinting risk in more detail

JM: helpful

MD: we discuss fingerprinting risk in each instruction proposal, do you want summary?

GD: there is also guideline for webplatform, 3 things, what are we exposing, relative to web platform baseline, what are probability that applications run into it?

PP: helpful and can guide future proposals

ZA: Deepti if you can add that via an issue, that would be great
"
main/2022/CG-10-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 11th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: October 11th, 4pm-5pm UTC (October 11th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Proposal: Linear-Memory GC-Root Marking [#1459](https://github.com/WebAssembly/design/issues/1459) (Ross Tate) [20 minutes]
       * Poll for Phase 1
    1. Presentation: Performance Analysis of WebAssembly Calls (Ross Tate) [40 minutes]
       * Designed a very call-intensive program using very little memory
       * Wrote 19 implementations of it
         * 3 in JavaScript
         * 8 in (hand-written) core WebAssembly
         * 8 in C
       * Measured the performance of each
         * on Safari, Chrome, and Firefox in the case of JS and Wasm
         * natively in the case of C, compiled using gcc with different optimization flags: -O0, -O1, -O2, and -O3
       * Will present the findings of those measurements
1. Closure

## Agenda items for future meetings

*None*

### Schedule notes

Reach out to the [WebAssembly CG chairs](mailto:webassembly-cg-chair@chromium.org) for agenda items that are time sensitive but can't be scheduled in one of the existing meetings.

## Meeting Notes

DG: Don’t forget to fill out the registration form for the in-person/hybrid meeting (even if you plan to attend remotely)

###  Proposal: Linear-Memory GC-Root Marking [#1459](https://github.com/WebAssembly/design/issues/1459) (Ross Tate) [20 minutes]

Slides: [(pdf)](presentations/2022-10-11-tate-garbage-collection-root-scanning.pdf) [(pptx)](presentations/2022-10-11-tate-garbage-collection-root-scanning.pptx)

CW: how do you expect this to be implemented? The engine maintains a shadow stack?

RT: The idea is when you have a function with smart locals command at the top of it, on the stack frame it will enumerate which locals there are, stack map trick to implement natively

CW: so the point is that each time a frame is created you have a bitmap that shows where the locals are?

RT: Yeah, the tagged locals. Does that make sense? 

FM: when you enter a function, those locals aren’t initialized. How does the GC know which local variables it should scan?

RT: So first off, the language is in charge of its own garbage collection so it’ll say when to run the garbage collection. It’s the application’s job to provide valid safepoints, and they should have correct values, the engine should provide the functionality to trigger GC

FM: so there’s just one bitmap for the whole function then.

RT: right.

PP: how does the scanning get initiated? (i.e. what’s the interface like)

RT: `enumerate-marked-locals` instruction will look at the first instruction, then the next and so on

PP: so it basically walls the stack from that point and finds them for you

AZ: the option to modify the roots seems like it would add overhead because it would inhibit optimizations? I guess that’s why it’s optional?

RT: It’s a part of the mark, anything that’s not marked is safe from all of this. What’s important for the VM, is that if I do a call and that has marked locals, after the call those locals are changed, if it’s not marked mutable then you can do the same optimizations if not, then don’t make assumptions about locals

CW: a high level comment about language direction. When we designed the GC proposal we talked about whether we wanted to to GC in linear memory and we decided that the direction we wanted to go. We’re just about to have a workable version of the GC proposal just about ready. Is this a good time to consider this?

RT: Concretely, these teams from the teams have looked at the GC proposal and have decided not to look at the current GC proposals

CW: i would like to hear from them directly, rather than mediated via your presentations.

AZ: Aside from the languages listed here, there are game engines etc. that will want to scan the stack - both the proposals have separate/important use cases and in the long run we will probably need both

RT: a concrete example we’ve discussed in meetings is the Erlang Beam team is that to implement the heap efficiently they need a discardable heap model. They did request that ability in the GC proposal but we decided not to do that. Also Julia really cares about concurrency/parallelism. Racket said that they wanted more control over finalizers and pointer tagging and wanted to control their own GC. Also last week we talked about Haskell, who said they needed lazy values, but the i31ref design doesn’t work with that.

AK: Can you address the high level question of doing n things, for the attention of the group not to be distributed amongst different proposals in the same space?

RT: this comes up with the stack proposal a lot. When meeting people about the stacks proposal, the majority told us they’d like to have this along with the stack proposal because they would have a bundh of GC roots on each stack. So that’s how this came up now.

CW: Would you say this is dependent on the stacks proposal? 

RT: Orthogonal, but seemed to come up quite a bit, addressing the timing question

AR: how would this interact with the stack proposal?

RT:  <Fiber reference?>

FM: that detail would have to be resolved in future stack. The main question is “why now”. I’d say the GC proposal… this is much earlier in the cycle than GC is. It’s a bit overlapping but not really parallel.


RT: You can tell people the only way to get a GC, the only way to have a GC is to use the current proposal, they have to use the existing one. 

JM: Has anyone tried this and measured performance of some kind of GC within wasm itself? Compared to <> what is the performance difference?

RT: In Wasm no one can know because it’s not available. Natively, there’s no one that has compared the two approaches

PP: By GC, do you mean the GC proposal?

JM: For the previous discussion on the GC proposal there has been a discussion about use cases we won’t address immediately. Are there a proof of concept or prototypes that have compared performance? 

RT: as in “have these languages tried compiling to wasm and performance compared to

AZ: there are just going to be languages that can’t use the wasm GC proposal, so comparison really isn’t possible. Also this isn’t really about performance. We already have major languages/companies that are already doing it in wasm, e.g. in game engines. They are managing their own stack, and they have to do GC only when nothing is on the stack because they can’t get the roots. So it’s not just about speed, it's even just having the ability to do this at all.

CW: This bitmap is a more efficient way of using a shadow stack? 

RT: it sounds like what Alon is saying is that they aren’t even opting to do it, because it’s too cumbersome. But yes you can do it without this using a shadow stack, and this would mean you wouldn’t have to do that.

PP: C# uses linear memory
C# and go are both languages who are using this because

RT: This is linear memory, and not this proposal in particular

CW: This is not accurate because the GC proposal hasn’t been standardized, so we won’t know who can’t use it. 

RT: for Go’s performance considerations, if you read their stuff on GC, ,they rely heavily on the fact that a lot of objects are allocated on the stack. That’s not anywhere on the plans for the GC proposal.


JM: In that case the performance difference is still not clear, they don’t know what the performance would look like natively? 

AR: i’d say that there will always be reasons to use linear memory. So the interesting comparison is between this and just using the shadow stack in linear memory.

AZ: That’s a valid thing to compare, maybe I want to be clear that there are cases where people that can’t use a shadow stack, there are use cases that can’t use a shadow stack because of the size of data structures, they rely on conservative stack scanning, and this would give them a way to do that

AR: how is that true? If they can’t know what to put in the shadow stack, they can’t know what to mark?

AZ: but if they scan the whole stack conservatively they can always find the roots

AR: You could conservatively put everything ont he shadow stack, but that’s probably not what you want.

AZ: maybe so. There might be something to measure. But I do think that doing this worst-case with the shadow stack manually, the performance seems like it would be obviously bad. But I guess you’d need to measure even when putting every i32 on the stack.

LW: i wonder if Binaryen could even polyfill this using a second memory, you could just put the whole stack in that 

TL: There’s work underway to have asyncify have a second memory, basically this would be the same thing. Related work is underway, there could be a way to measure this

PP: I think it’s necessary to use a second memory. If you enter functions you just adjust the pointer, like how we do the C stack.

RT: I tried looking up performance of shadow stacks, it’s hard to get performance numbers of the shadow stack that’s recent

PP: realistically what’s going to be the difference between writing code in the engine that will walk the stack for you, vs writing that code in wasm, it seems like it wouldn’t be much. Bounds checks could affect it. If you're using a shadow stack, as soon as you try to compile 2 modules that both use it, they could affect each other’s choices, it gets complex. 

AR: We have some data points about performance/implementation complexity of shadow stacks from C/C++ for different purposes, we have some data points that it’s not as performance intensive in itself

DS: It’ll be a lot more expensive for a GC language, because you’ll have more tracking <>
In general I agree with Alon, and you that there will be use cases that will want to try this so that’s sufficient for a Phase 1.

CW: who is going to try this? Do we have anyone interested in doing an experiment?

RT: They’re not involved at the moment, but I can reach out

CW: to me the bottleneck would be engine implementers, right?

PP: To measure it wouldn’t be a bottleneck because you don’t have to merge it into the engine

RT: it sounds like either we need an engine team to put together a prototype, or get a compiler team to do a native implementation and compare a shadow stack in memory vs. something like this?

AR: to me you really need an engine, the latter comparison wouldn’t be very useful because there are so many confounding factors.

RT: Should we poll for Phase 1? 

CW: I would like to see some concrete numbers before we move too far forward

DS: I would like to get a sense of who is interested this before just punting it

RH: Compared to other Phase 1 proposals, we’ve haven’t had commitment for other folks to work on this

JM: it seems like having a phase 1 proposal is a good way to say that we have something out here and get

AR: I think a phase 1 proposal is fine, it’s not totally ridiculous and i would like to see the results, it’s just not clear that we have commitments to implement it.

RT: One idea is that someone targeting this, can make a post compilation step instead of polyfilling 

DS: Let’s poll for phase 1, 

SF: 2

F: 28

N: 8


CW: I would like to say that we should be careful about confusing people who can’t adopt the GC proposal with people who just haven’t for other reasons.


### Presentation: Performance Analysis of WebAssembly Calls (Ross Tate) [40 minutes]

Slides: [(pdf)](presentations/2022-10-11-tate-performance-analysis-of-webassembly-calls.pdf) [(pptx)](presentations/2022-10-11-tate-performance-analysis-of-webassembly-calls.pptx)

Microbenchmark Source: [(gist)](https://gist.github.com/RossTate/63438c8b7fd793b39afe93893386186e)

FM: what’s the difference in factors in the different steps between the C and wasm version?

RT: In the C version you get performance cut in half by inlining, every percentage after, in Wasm you get double-triple, and varying after. It’s very common for the list library to be compiled in a separate module from the module compiling that’s  compiling the foreach loop over, so there will be an overhead in Wasm that’s not comparable to native

PP: Separate compilation has an overhead, what happens if you run it in 
Binaryen?

AZ: if it places the global in linear memory, if the address is taken, then the optimizer can’t help, but it depends on that.

PP: The middle line doesn’t do that, not sure

RT: natively, separate compilation doesn’t add a lot of overhead, but with wasm it’s adding a lot. I should clarify that i’m compiling with O1. if I do O2 it’s all the same, except that it inlines the switch.

PP: The very right side of slide, that’s the offset, what’s the difference overall, what would be a way to get there? What’s your baseiline? [Breaking down performance slide]

RT: that last line is basically if I were to compile say an ahead of tiem version of Java (but ignore GC), but I have classes, my list library get imported, it imports the vtable for the program, and what are the offsets in the vtable, and it calls indirect from those. 
PP: That 590 vs 640, what’s the difference between those two? (to the right)

RT: here, I’m doing direct calls. Natively it’s the sort object file has imported global addresses and i use that as function pointers, you load an offset from that and call through it.

PP: Do you have sources anywhere? Wasn’t sure what to do with them

RT: On my computer, have a small web page for the browser comparisons? 

PP: it would also be interesting to test with standalone engines.

SC: <chat> by “separate compilation” do you also mean “separate deployment” where the runtime is doing the linking?

(RT adding response to the missed above question after the fact: Yes. The separately compiled native binaries are generated such that they reflect the image of what a runtime *could* generate when compiling/instantiating/linking at run time, in line with what common runtimes for other common virtual machines do.)

RT: I don’t know why switching is more expensive in Wasm than natively, again for whole program compilation you can bypass that to use a switch and bypass call-indirect. Firefox vs. Chrome performance difference is significant, Firefox does better - implementation details between the engines cause this <> callee side signature side works better, it’s more expressive in a variety of a different ways, arbitrarily large functions can be used without a performance cliff. 

CW: are any of these benchmarks using web workers?

RT: No, we’re building expectation that instantiate is a cheap operation
"
main/2023/CG-11-21.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 21st video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: November 21st, 5pm-6pm UTC (November 21st, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Shared-everything threads [Thomas Lively, 40 mins]
    1. Rounding mode phase 2 discussion & vote [whirlicote & Kloud Koder, 20 mins]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
 - Deepti Gandluri
 - Derek Schuff
 - Thomas Lively
 - Pauldennis
 - Kloud Koder
 - Abrown
 - Michael Ficarra
 - Conrad Watt
 - Yuri Delendik
 - Mingqiu Sun
 - Jeff Charles
 - Alon Zakai
 - Alex Chrichton
 - Slava Kuzmich
 - Ilya Rezvov
 - Emily Ruppel
 - Paolo Severini
 - Zalim Bashorov
 - Till Schneidereit
 - Nuno Pereira
 - Ryan Hunt
 - Yuri Iozzelli
 - Emanuel Ziegler
 - Heejin Ahn
 - Chris Woods
 - Daniel Hillerström
 - Jakob Kummerow
 - Adam Klein
 - Matthew Yacobucci
 - Bailey Hayes
 - Andreas Rossberg
 - Keith Winstein
 - Julien Pages
 - Ashley Nelson
 - Luke Wagner
 - Armando Faz Hernandez
 - Saul Cabrera
 - Brendan Dahl
 - Francis McCabe
 - Jakob Kummerow
 - Sergey Rubanov

### Proposals and Discussions

#### Shared-everything threads [Thomas Lively, 40 mins] ([slides](https://docs.google.com/presentation/d/10GN6_ok29Da3_N6y5WddeMFUV3k0LGg-33Tjd5ewqZk/edit?usp=sharing))

TL: We’ve been exploring what a full threads proposal would look like, and talking a lot with Andrew around what he’s been proposing.
So we have what we call an omnibus threads proposal that has what several different groups have been asking for. Some mostly for web, some mostly for off-web and some intersection.

Shared attributes: Imagine 2 separate JS contexts, and there’s some wasm that wants to be multithreaded. We can’t have a JS object referring to objects on another thread, even via wasm. So we need to statically disallow all references from shared to non-shared.

CW: clarification: you’ve focused a lot on wasmGC, but the issue of shared -> nonshared also applies to MVP constructs and instances.

TL: You could replace the GC structs with globals referring to references held in other globals, or tables with references to globals, anything where one thing refers to another can exhibit this problem. 

PP: the function is shared, but the position in the function is different across threads, but there will be some extra state, you’ll still need thread-local state?

TL: I don’t have a diagram for the implementation, the idea is.. 

CW: broadly, it should be the same way that TLS variable work in native implementations but the runtime will be managing it under the hood.

TL: More detail there, in the instance per thread model, we had 2 different instantiations of this function - under the cover they would still share code in the engine, the engine will pin a register pointing to the current insatncae, when we’re running the different functions, the pinned registers will know which registers to refer to, so the global will already be referenced from the pinned register, so there is already a redirection

AR: 2 questions: what kind of attribute is thread-local, where does it live?

CW: Exclusive with shared is the idea. Only for Global variables right now.

AR: In the same space as shared, the other thing is, you didn’t explain how the different copies come to be? Is it over postMessage? 

TL: About to explain how this interacts with JS, we’ll mostly cover that question in a second here. Please ask any follow-ups.

CW: this seems to be combining 2 sets of mechanisms from our early version of the doc. Is this an evolution of what we talked about? Or are you just skipping details?

TL: Not going to all the details, its not intended to be an evolution of the edsign

CW: You can’t put a non-shared function into the shared global 

TL: yeah this is skipped detail. 

CW: I wouldn’t expect globals would need the bind mechanism, you can just get/set like you need for function?

TL: yes, correct

AR: Can you explain what the difference is? 

TL: under the assumption that we'll have shared continuations in the future, we can’t let TLS globals contain non-shared references. Because when you global.get from a shared function, then you have a non-shared value in the activated frame, and shared continuations don’t work. So we constrain the TLS globals to only contain shared references. But we want console.log and it’s not a shared reference, its JS. 

On the JSAPI level, we still need these thread local functions where you create wasm functions, and you mark it local, that create this shared local,
So you can’t put raw console.log in there, you need to wrap it up in some shared thing

CW: In principle you could import the wrapped function without importing it, you can rebind it without going through the thread local global

TL: yeah and in that case you could import it as a shared function.


CW: Are there separate slides explaining what the thread local functions are? 

TL: There are not

AR: my intuition was that the whole point of thread local is that you could work around this restriction that share can only point to shared? Because now you have thread local and thread local  can point to… what, is what we’re trying to answer. So i can see that we coil push TLS through the type system like shared. But don’t you at some point need to point to something that is truly unshared?

CW: The thread local global is not the mechanism for this, the slide doesn’t introduce the mechanism for this, which is the thread local function

AR: Guess I’m missing some detail here then.

TL: the thread local globals are not intended to allow you to point from shared to unshared, somewhat counterintuitive. But they are really just for getting the base of thread-local data, linear stack, etc. and you can use them to call out to JS. 
[Slide: open questions]

FM: how do you know who is responsible for identifying when you postMessage, who identifies which variables are supposed to be reset?

TL: That’ll be up to the language toolchain, if emscripten was using tables, it would post message the tables, and would know how to set up those tables

CW: I would also add from a runtime POV, whether something is thread local is statically annotated, so the engine can see which are really shared things.

TL: Anything else about TLS?

CW: even though thread local functions aren't explained here: if a runtime can handle thread local globals as shown here, I think functions will work fine too

PP: Not a TLS question, implementation strategy where you take an instance and pin a pointer to the instance in a register, is that one way to do it, or is that something that’s required? 

TL: That’s one way, you don’t necessarily need to pin the register: but somehow it has to go back to something that’s thread local in the hardware. So a pinned register or a native pthread implementation, or something. So as long as the underlying system supports TLS somehow it can be made to work. Pinning a register is just one way.

[slide: waiter queues for wasmGC]



PP: It’s quite complex, you have to introduce a bunch of new stuff, it stems from the fact that JS is single threaded, the host language on the web, and what Wasm does is somewhat at odds, do you see challenges on introducing this to JS? 

TL: no, actually. There’s a proposal on the JS side with Shu (who came up with the watier queue idea) called shared structs. So the technology for shared GC is already in V8 because of the JS work.

CW: If we’re not pursuing thread.spawn, that’s the most controversial instruction from the web platform end, the rest of the spec should be fairly non controversial

KW: it really would be nice to retain the simplicity of the core spec. To accommodate the web adds a lot of complexity, it’s hard for new entrants. Is there a way to layer this on the top to keep the core spec approachable?

AB: Profiles

TL: Interesting question. Profiles let you delete it out of the core spec easily but they are still in there.

CW: A future idea is to have a syntactic version of the spec, with different profiles enabled. For shared attributes specifically, that lives in the core spec, the way it interacts with the validation algorithm, it needs to be in the core spec, we could do something simpler or split it out, but it’s unlikely to be too simple


TL: any objections for renaming the repo to shared-everything-threads, and add Thomas as a co-champion (along with Conrad and Andrew)

#### Rounding mode phase 2 discussion & vote [whirlicote & Kloud Koder, 20 mins]

KK: started prototyping floating point rounding mode instructions last year. Paul Dennis prototyped all the instructions and wanted help testing. So he had C++ code with a mix of wasm2c/wabt and implemented the proposed instructions and I prototyped in x87. So we went through a list of corner cases and instruction inputs and combined them, to test the implementations against each other. In all cases that didn’t involve a NaN matched between the hardware and the C++. we may have to adhere to the NaN canonicalization proposal. I’ll send a link to the doc with the opcode map, it has 4 pages, each corresponding to one of the rounding modes.

Opcode map: https://github.com/WebAssembly/rounding-mode-control/blob/main/proposals/rounding-mode-control/Overview.md

https://github.com/WebAssembly/rounding-mode-control/issues/2

There’s a symmetry in the geometry of all the pages, its better to be symmetric than to be opcode efficient - in the initial implementation, when you add two numbers together and add a rounding mode, we’ll statically add the mode. In the future, there is a lot of performance to be had for integer arithmetic. In theory you could get all of that performance, but that would be a future proposal. <TODO: Kloud Koder to validate, fill in>

We’re proposing phase 2 because we have the overview doc and test cases, and Paul has a repository with the code.

CW: All of the rounding modes are static in the opcode? Each instruction will know whether it’s rounding up or down

KK: yes. Also we originally proposed a separate opcode byte, but ended up walking that back. 

CW: Have you thought about how performant this will be on architectures where the rounding mode has to be set different? 

KK: you mean if you have e.g. a global rounding mode register? Yes, so thats easy to implement but inefficient. We might want a follow on proposal e.g. so the toolchain could assume different behavior e.g. chopping.

PP: Is there a way that this would interact with simd now or later? 

KK: initially I had proposed some SIMD equivalents, but it was pulled out. It’s not quite as straightforward. But at some point it gets weird if you have different rounding modes for those. So we might want a follow-on.

Initially I was thinking of making integer arithmetic primitives, so you could do the same thing that SIMD was doing, but that was too high level, and not efficiently lowerable. For the record, there ended up being 21000 test cases, the 16000 that did not involve NaNs verified correctly

CW: have any engines signalled that they’re interested in prototyping this?

KK: It’s in the different discussion threads, its references in the discussion  (2) or three different projects that want to implement it. 

PD: haven’t done work for talking to the runtime engine, but implemented the instructions in the reference interpreter, and also a wasm module that implements the instructions.

CW: that’s probably good for phase 2, but to go further we’ll probably need other engines/runtime as well.

AR: I skimmed through the list and most of them have obvious meaning, but the overview doesn't explain the binary/ternary sign operators.

PD: Floating point numbers, ven NaNs have a sign bit. Usually it’s the first one. If you have the binary sign extractor you extract the first bit and it’s either 0 or 1. Also for numericdal analysis for algorithm you want to check if the sign is 0 or -0 or +0 or negative number or positive number. These are two different things when you want to [??].

AR: so it’s basically the sign function and abs?

PD: Two different sign functions. In C++, one is called sign bit and the other one does not have a C++ std library. Usually there is a formula for a comparison and subtraction. Then you get the 0 or -1.

AR: but thats the signum function essentially

PD: Yes it is. In one proposal iteration, I wrote sigNum or something. I think binary or ternary sign are ??? as well. 

DG: wondering if there was going to be a little more detail in the performance section about what the expected performance characteristics would be on different hardware and workloads, and what we should expect about that.

KK: Assume you mean perf delta between having it and not having it.

DG: yes, and we talked about hardware that uses a global flag. The part agbout avoiding different modes seems a little ambiguous, I’d like to see more detail there. Also, for V8: I don’t think we’re going to be actively looking at this but happy to partner with anyone interested in working on an implementation.

KK: would you recommend approaching the V8 community for phase 2?

DG: for now I’d recommend fleshing out the performance section and we can talk more about approaching V8 later.

CW: I would say that implementer interest isn’t strictly a requirement for phase 2, but since there were some questions, i wonder if we should move the poll

PD: Just the instruction is quite easy, like 10 lines of code and you have the instruction. You have to copy the already existing abstractions and put 10 different lines in it. The complexity is very low. More of a problem organizing a new version and version editor and everything I assume.

DS: If we’re punting the vote, do we have clear guidelines on what is next, just the performance section?

DG: Doesn’t seem like a blocker for phase 2, just wanted to know what engines should expect when trying to implement it.



Poll: 
SF: 1
F: 4
N: 15
A: 0
SA: 0


DS: This doesn’t look like consensus in favor of advancing the proposal.

CW: It might also help if we get some library users who are interested in using this and get some public feedback from them 

DS: The chairs will follow up with the champions offline and we’ll try to get some concrete next steps to try to help.




"
gc/2022/GC-03-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: March 8, 5pm-6pm UTC (March 8, 9am-11am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: No-frills JS API and moving a richer API to post-MVP ([#279](https://github.com/WebAssembly/gc/issues/279)) (30 min)
1. Closure

## Meeting Notes

### Introduction of attendees

 - Thomas Lively
 - Slava Kuzmich
 - Lars Hansen
 - Francis McCabe
 - Zalim Bashorov
 - Conrad Watt
 - Rick Battagline
 - Luke Wager
 - Ben Titzer
 - Adam Klein
 - Jakob Kummerow
 - Keith Miller
 - Aske Simon Christenson 
 - Andreas Rossberg

### Discussion: No-frills JS API and moving a richer API to post-MVP ([#279](https://github.com/WebAssembly/gc/issues/279)) 

TL: Partners have told me that custom accessors or prototypes for structs aren’t necessary for the MVP, but they’re concerned about the performance of arrays and avoiding unnecessary overhead when using e.g. regex methods that return arrays of strings that need to be moved into Wasm.

AR: What is specific about arrays…?

TL: …

BT: Are there open issues about arrays?

TL: Not yet, most existing discussion has focused on structs.

CW: How much would duck typing to make GC arrays array-like in JS work?

TL: Unclear, but it might be sufficient. We haven’t been able to get implementer feedback on this yet.

LW: This seems solvable without custom prototypes. Array-like methods.

BT: Typed arrays?

JK: Personal opinion is that there will be no exposable arraybuffer underneath. Pretending they do would require a copy and negate any benefits of that approach.

AR: Besides basics, any requests?

KM: …

BT: Backing store of exposable arrays would have to be off heap

KM: Passing these arrays to audio, blink, etc. is probably going to be a common use case.

JK: That would be the biggest implementation challenge: exposing WasmGC arrays as TypedArrays on the JS/web API side is going to be much harder than just exposing duck-typed arrays.

KM: That could be one advantage of making a WasmGC array of u8 an alias of the JS u8 typed array. Kind of gross for implementation, but good for interop.

JK: There are also disadvantages, e.g. allocating TypedArrays is more expensive than allocating Wasm GC arrays in V8.

KM: I see. That’s not the case in JSC.

LW: Spidermonkey stored a few elements inline in the header to make the small cases fast.

BT: Is it still the case in JSC that TypedArrays are gigacaged?

KM: Yes

AR: Luke, are you suggesting having diverse representations of arrays in Wasm?

LW: You would store a pointer to the actual array

AR: That would also be another indirection.

LW: Yeah, not advocating this. Detachability is another tricky point.

KM: Why is allocating TypedArrays slower in V8?

JK: Not sure, and not sure what the current state is regarding small backing stores (whether those are stored on the GC heap or not). But don't have enough knowledge off the top of my head.

BT: As I left it when I left, there’s a C++ managed pointer that needs to be allocated for all backing stores and that requires popping out to C++, which is slow.

AR: I wouldn't just worry about the cost of allocation, also the size of the thing would be bigger than arrays, which doesn't align with the goals of the proposal.

KM: Not sure in JSC whether it’s any bigger.

CW: Somewhat of a rabbit hole, partners may end up being happy with basic array-like accesses.

KM: Could special case some special kind of array for the audio use case maybe.

BT: Another alternative would be to make TypedArrays allocated in JS reflected as a Wasm array; this might be easier.

CW: That might mean calling out to JS to create arrays to get that kind of special array.

BT: Yes, but only for the ones you get from JS.

KM: The risk is you don't know how your arrays travel through code.

CW: That suggests a constrained version of the kind of custom section we were discussing before, where you'd say ""this is the kind of array that needs to be more complicated""

AR: Want to note that if you can customize RTTs then you can reuse them for this as well.

CW: Like that, but specifically for arrays

LW: Regarding representation, if we don't statically know the size of arrays doesn't that mean we'd always need to have an indirection?

BT: Probably we’re slicing this too finely because it’s just a couple machine instructions, so it needs to be measured.

LW: If there was always this indirection to the array contents, possibly cheap, then doing the original array-as-arraybuffer becomes feasible again.

AR: My understanding is that the reason you want to store them out-of-line is because you want to be able to pass just the backing store to some web API. For Wasm arrays, why would you not want to store the elements inline?

BT: The key thing is that you need to make it non-moving.

AR: So you would have some section of your heap where objects don’t move.

CW: What’s the Wasm type for byte arrays? Do we support arrays of i8? (Yes)

JK: With the GC proposal, yes you can.

CW: My impression was that there exist JS functions that process arrays of strings.

JK: The background there is that apps want to process strings, e.g. splitting via regexes. Without a JITting regex engine in Wasm, calling out to JS might make sense, but then you have to do the splitting on the JS side. One array is a primitive array of character data. The other is a JS array of JS strings. How can we make it possible to make a JS array, then extract elements on the Wasm side? Could export a WasmGC array constructor.

AR: I'd assume the JS API would provide ways to construct [Wasm] arrays and structs on the JS side. So the way to handle this would be to pass an optional constructor to operations that output arrays so you could pass in the Wasm versions.

JK: This touches on the strategic question of how we want to go about JS API design. No-frills approach would only use exports for this. Other approaches might have a richer JS API, but that’s a deep rabbit hole.

AR: I was assuming that the no-frills approach would include a constructor on the JS side. It's not clear you'd want to throw that out.

CW: The constructor is only part of the story. The other story is to change the regex functions to know to use that constructor.

AR: Yes it would be an extension to the JS regex API, but I don't know what else you could do.

JK: Theoretically we could specify automatic conversion of JS array to array of externref.

AR: That's probably even more expensive, depending on how big it is. But sure, that's the other approach.

CW: Didn’t this already come up as something the JS side wasn’t thrilled about doing? Arraybuffer interop - didn’t want to change all functions to choose what kind of array to write to.

AR: I could definitely see that being reacted negatively too.

AK: Thinking about @@species. There’s a lot of push back against that in TC39 these days.

JK: We also don’t want to use it - probably wouldn’t help.

AK: Changing JS APIs is a much bigger rabbit hole than just JS interop.

CW: For regex with strings, if what you get back as an array of externref, then that's another wart.

AR: It seems the real answer can only be interface types and small ad hoc solutions will not get us there.

CW: Interface types bites the bullet, though, and says there's always going to be a copy, and a deep copy at that. Not clear that meets the use-cases.

LW: I think there could be smaller intermediate solutions that aren’t shared-nothing. For example WebAssembly.Function for converting JS to Wasm functions. Could extend that with additional things, like having a flag for using a receiver. Could have another option for coercing result to GC array. Then could add an optimization to the built in to construct the GC array eagerly.

AR: Don't you quickly wind up needing the same type algebra to compose these cases?

LW: Scoping down goals to just high-value use cases, should be tractable. GC types are way simpler than linear memory types, too.

AR: It goes both ways, you might need a way to convert a Wasm thing into some JS thing.

LW: If you know you're calling into something that takes a JS value, then you let ToJSValue take care of the high value cases. It wouldn't be a complete fix but it might be sufficient.

FM: To add one point to the interface types discussions. People assume there will always be a copy, but it’s always been true that we could optimize to not copy for e.g. immutable arrays and strings.

LW: Indeed, and likewise for strings which are immutable.

CW: Has Andy Wingo’s strings proposal been presented to the CG yet? (No)

TL: This has been a great discussion of arrays, which we haven't yet had on Github. Clear next step would be to create an issue on GH. Popping back up, apart from what we do with arrays, regarding custom struct accessors, is anyone not happy with moving custom struct accessors to post-MVP?

BT: In lieu of that, what would we have?

TL: For structs you could export getters & setters and use those to access structs from the outside. For arrays I don't want to commit to anything today, maybe it would just be accessors or maybe something richer.

JK: For structs, an advantage of accessors vs index-based access gives tools the opportunity to know which fields are used externally. Allows optimizations like field reordering. Whereas if there's index-based field access (like struct.get) then all bets are off.

AR: Wouldn't it need to know what the accessors do?

JK: Yes, but the tools can see that, since it can see all code in the module.

TL: Example, Binaryen optimizes out fields that are never read?

AR: How often does that happen?

TL: Happens a lot in practice with the Java code we've been looking at. This is also how dead code elimination on vtables works.

AR: But this would preclude no-frills approaches for the entire future?

JK: As long as we provide some way to limit access to fields in that future API.

AR: Seems like overkill.

CW: This could also be left to the toolchain to figure out how much of this information it wants to carry around.

BT: Bikeshedding, the right way to access which fields are read is to export a type. Assumes that you'll be able to reflect on exported types, and not reflect types that are not exported.

AR: Reflection allows even more uses.

TL: This is definitely something we could solve on the toolchain side with a manifest that describes what gets accessed. Emscripten does something similar with Meta DCE, which allows dead code elimination across the Wasm/JS boundary. But of course that's way more complicated than just looking at the Wasm module. The point, though, is that only exposing accessors for now will be simpler for tools today to deal with. If we add fancier stuff in the future, we can also do fancier work in tools to keep those optimizations working.

TL: Not hearing any objections to moving custom struct access to post-MVP, propose creating a new phase 0 repo for this and add an agenda item for the full CG to announce this split. I will take care of these.

TL: Naming? ""GC JS API"" is too broad…will post an issue and we can bikeshed there.

AR: ""GC JS customization?""

TL: Sounds fine, we can always change it later.

ZB [in chat]: ""Wasm GC JS interop""

FM: Listening to the conversation, the first thing we're going to need is requirements. I heard a lot of different ideas today, we need to be clear on what the actual requirements are in order to make anything useful.

JK: Absolutely. That’s the biggest reason to do no-frills now and expand later. We need to figure out what problems we want to solve.

ASC: One thing I was thinking about for the interop is how GC objects behave more generally on the JS side. Can you compare them by reference? Can you put them in weak maps and finalization registries?

[general nodding agreement]

TL: Absolutely

AR: Putting them in Maps will require hash values in many implementations, a little nasty.

JK: In V8, we already have that hash value field because we expected that use case.

BT: Isn’t that inescapable because any JS value can go into a map?
AR: JS is already irregular, so throwing in that case wouldn’t be too out there.

CW: For WeakMaps specifically, if we go to a world where we have shared Wasm objects, those should not be allowed as keys because then you could keep things alive across threads.
In that case could trap if you try to use a shared object as a key but not a shared one.

AK: Though JS is irregular in many ways, one of the benefits of WasmGC is to be able to interact with the host side in ways that interact with the GC, so it would be a shame not to support finalization registry.

AR: That is fine as long as it does not make WasmGC fundamentally more expensive.

JK: I’m not concerned about the cost of storing a hash value. Could even expose it in a new future instruction since many languages need their own hash value.

BT: I don't want to expose the hash, that's a mistake the JVM made

AR: In typical functional languages, a tuple that's a pair is 3 words, I'd hate to make this much more expensive.

SK (chat): non-determenism of hash codes is a bit scary, but duplicating hashes is would be silly indeed

JK (chat): Slava: the hash is not directly exposed to JS, it's engine-internal. For now, you'll have to duplicate it if you need it.

BT: I generally agree with Andreas. Lost battle in Java, but generally want a 1-word header in Wasm.

TL: Thanks, ASC, indeed as part of the MVP we'll need to specify even in the no-frills approach how these things look from JS. Hopefully we can pull in a JS expert to help with this.

SK (chat): Maybe JS function to get a hash code then? Importing it would avoid changes to core wasm

TL: I'll put this on the agenda for the next CG meeting.
"
wasi/2019/WASI-07-18.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the July 18 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: July 18, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Import names
        - https://github.com/WebAssembly/design/issues/1286
        - There's a lot of big-picture design work to be done here.
        - To unblock modularization and general design work, can we adopt
          a new temporary scheme, still containing ""wasi_unstable""?
    1. Weak Imports
        - https://github.com/WebAssembly/WASI/issues/36
    1. IDL
        - WatIDL: https://github.com/WebAssembly/WASI/pull/64
    1. What other blockers do we have before we can start designing new
       ""wasi_unstable"" APIs?

1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

2019-07-18 WebAssembly CG WASI Subgroup Video Meeting Notes

Agenda: https://github.com/WebAssembly/WASI/blob/main/meetings/2019/WASI-07-18.md

Attendees:

Dan Gohman
Martin Becze
Mark McCaskey
Alex Crichton
Andrew Brown
Sam Clegg
Yury Delendik
Arun Purushan
Pat Hickey
Jacob Gravelle
Luke Wagner
Till Schneidereit
Luke Imhoff

Meeting notes:

Pat - agenda seconded

DG:
Import resolution outside of the scope of WASI.

Pick naming convention that involves the name wasi_unstable + a possible additional identifier, to allow us to continue designing APIs.

SC: wasi_unstable implies a bulk rename in the future

DG: agreeing but bringing up additional prefix to clarify.  Does anyone have an opinion. Suggested wasi_unstable/<file | network | …>

_ : Is there any reason to use a /

DG: We want to split the existing wasi_unstable into multiple modules, :, $, the specific character doesn’t matter.

DG: is there a problem with /

_ : Agreeing that separator doesn’t matter, but we should move everything into namespaces

DG: it will allow us to start design work on other APIs…

DG: wasi_unstable/identifier is the current proposal.  We’ll call that a decision, we can use that to unblock things and start modularizing things.  We’ll start queueing up those issues for the next meetings.  Let’s have those issues and we’ll start tagging them.  Part of that work will be deciding what goes in what modules

DG: next agenda item.  Weak imports

SC: I got as far as implementing the custom section and realized that there’s quite a lot of redundancy, we’ll have a global corresponding to each global import.  All we need is a way of finding that list of globals, we’ll probably use name mangling, so all we need to do is specify the suffix and the runtime can find all imports matching that pattern.  Name mangling just for is_present.  It would just be a simple custom section saying “is present”

DG: that strikes me as overkill

SC: (something)… we can find all weak imports by looking for that suffix

SC: someone asked why we weren’t going forward with the official Wasm spec proposal of weak imports

DG: one possibility is that we can take weak imports as being in the same bucket as snowman bindings.  It’s a way of describing an interface to Wasm, so maybe we should put it in the snowman bindings custom section.  If that’s the case, we can roll it into the snowman bindings proposal.  I think it aligns pretty well with the snowman bindings things, because it’s a custom section, and (justification regarding name mangling)

PH:  if you have a whole bunch of weak imports, you can map them to the same global if you want to.  So that’s an advantage of a custom section

SC: what does that mean, if anyone of them is missing

PH: that’s useful if you’re importing an entire module of things

SC: that’s useful for all-or-none situations

SC: yeah, I like it

DG: alright, so with that, I’ll put that to the group, is this a good way to go forward, put it in a custom section and roll it into snowman bindings?

(Luke allegedly nods head)

SC: I don’t see how it fits into snowman bindings
DG: it’s part of a custom section that is the interpretation of the module; it’s not quite the same thing but it’s in the same category.  It would be in a different part of the custom section, and eventually things like specifying the entry point

LW: (missed)... this is in the same kind of layer

SC: that makes sense when you put it like that

DG: does anyone want to comment on the issue then?  Someone in the WASI repo brought up the question of using a custom section

J: if that is the case then we should put it in the webidl bindings repo

LW: the webidl bindings repo is itself a layer of ….

J: should add assuming it does exist (snowman bindings)

PH: there’s a large overlap in the people working on both, so it’s probably a non-issue

J: do we want to use weak imports for something else?  Mentioning it there will get more eyes on it. Weak imports in contexts outside of WASI

…

SC: should I keep going with specing that in the WASI repo?

DG: yeah, for now.. We’ll figure it out as it goes

DG: next agenda item: WAT IDL proposal

M: So where we got stuck last week is with conflating two things, the way watidl was written made the interface an object, that’s a mistake because an interface is a Wasm module.  I rewrote it and I’ll push up the changes today.  We should take a key from webidl we can add the extra field that this is a method and then we know that the bindings need to bind some sort of context, so I’ll introduce a method field.  It’s also important to remember what the whole point of this was which was partially virtualization, ideally we should be able to have an IDL that Wasm binaries can bind to in two different ways, one using aztrack? Data ADT where all the functions are imported, the other way that would be easy to virtualize, I’m also trying to, I wrote up a little doc on how to do virtualization which I’ll throw up today, so that’s where we’re at with watidl.

LW: what does virtualization specifically mean?  You’ve requested to import this fn but I’ll give you a virtualized one instead

M: the ability for a Wasm module that a Wasm module can implement a given interface and another module can use that, there’s 2 types of virt. Static: another module importing fd_close, open, sync, which another imports. Dynamic: a module being able to on the fly create a file descriptor or implement it to hand to another module, which is what I meant

LW: do you mean as a reference to a struct that contains fn refs?

M: yeah, exactly.  SO in that case, the WASI interface, ref to structs of fns, you would just import types at that point.   It would be nice to have an IDL that can describe both ways of interacting.

LW: and who would use the IDL?

M: used to describe interface and then you’d write bindings.

LW: so this would be the interface of WASI?

M: yeah

LW: would this be equivalent to a list of Wasm function signatures that would be allowed to use snowman binding types in their signatures along with module and field name

M: list of functions of types, it’s pretty basic

LW: If we go the snowman bindings format and have a Wasm style and there were fn sigs that could use these types instead of core Wasm types.  What if I make a module that just describes the interface… just a subset of the text format.

M: that’s pretty much what this is + the addition of whether a function can be virtualized or not

LW: that has some pretty significant runtime and compile time implications

M: We don’t even have structs or fields, we need partial GC and func ref before we can do dynamic dispatch properly anyways, so we’re looking ahead.

LW: thanks for explaining that

M: it’s the text format - bodies, just types and function signatures

MM: Wasm interfaces are overlapping, we should consolidate these or figure out what’s going on
SC: virtualization isn’t needed for what we need right now, so maybe we shouldn’t push on that too hard if we don’t need it right now.

M: agreement/partial agreement

M: I think virt. Is important in a context where you have multiple untrusted modules working together.  As WASI is now, it’s generally a single module, they can add object capabilities to each other.  In that context it’s not as useful, once we have func refs, …. Then the capab to virt interfaces is more important

TS: I thought that was a different layer, instead of the runtime built-in you use this instead.  I don’t see how that would interact with the IDL, can you explain that more?

SC: you’re talking about interposition vs method calls, interposition is like intercepting a method call.

M: Are you all familiar with ADT style?  RIght now everything is ADT style, so you can’t really virtualize ADT style.  A module can’t really implement those functions, it can’t generate them on the fly.  So to be able to generate or implement a file descriptor, that’s /udev/random , so a module can do this and generate a FD on the file when requested by creating a struct and hand it off to the requester, why this matters at an IDL level is, a module may only want to use OO interface and in that scenario, you’d only implement types and the entrypoint fn would only receive capabilities, references to structs which point to functions.  One use case for an IDL here is the host system would know that the module wants OO type vs ADT style, does that make sense?

TS: I think so, thanks for the clarification

M: that said, since we don’t have, since it’s not given we don’t have GC or func ref, (func ref?) looks more promising, it might not be worthwhile to worry about this.  It might not be worth worrying about this yet and just focus on ADT style

DG: as far as next steps, martin you mentioned that you’ll post an updated version of the proposal?

M: yep

DG: we’ll iterate from there.  Anything else we want to cover in this meeting?

M: I also wrote up some stuff about virtualization, should I add that to the repo?

DG: Sure, make a PR and we can discuss it and decide if we want to incorporate it

DG: that’s a good point, virt. Is an interesting enough point that we should document what we’re going to do in this space

DG: next on the agenda, with the theme of setting up the wasi_unstable namespace, what are the blockers that we have before we can split up wasi_unstable into modules and working on them.  Having an IDL nicer than a C header file or markdown is good, are there other blockers?

LW: do you think we should hold off until we can make use of reference types and type imports? Or do we want to do it later

DG: I think that’s something we can deal with later.  When we have full snowman bindings, we’ll want to convert them into that form, and emulating lower level concepts with our higher level types.  We need to figure out what is a file and that doesn’t need to wait for (those things)

TS: maybe we should say that the changes we make going forward should take these concepts into mind, (describes using indirection of fds in a table of anyref to make transition easier)

DG: that seems reasonable and I think that will somewhat naturally fallout given API design.  We want a vocab to talk about things until we have an actual IDL, we can do API design with C headers but it’s not ideal, so we should figure out what to do there.  MAking it easier to migrate to future bindings systems seems great

TS: two advantages, we can do API design now knowing thta API design can map well, later on we have a straight forward way to make it easy to consume in C/CPP/Rust.  Two APIs with the AnyRef being the fundamental and an indice-only one on top of it

DG: how much do we want to do now vs waiting for snowman bindings?  If we just design with this in mind, it will be pretty straight forward to retro fit this, that’s my gut feeling here.

TS: All I’m proposing is making that explicit that we want to have this 1-to-1 relationship, making that relationship straight-forward

DG: should we have a document about “How to design a WASI API”

M: that sounds like a good idea

DG: martin or till do you want to start a document like that?

TS: I can start that document by writing what I just said and then we can flesh it out with more content

DG: it can evolve as we get snowman bindings and other tools

LW: it might be good to have a “future intended steps” section.  The intent to move to ref types and binding types are only in our own heads and we should document that somewhere

DG: looking for someone to document OCAP vision and put it in a repo, if someone wants to do that, that’d be great.  It’s been discussed in various places, but we don’t have a document in the repo describing the plan.  IF someone could digest that down and start that, that’s what we’re looking for

LW: I can help there

DG: we have the docs directory in the WASI repo.  Alright, I’m trying to push forward to the point where we can do API design.  Are there any other blockers?  We’ll have a document, (somethinG) in progress, and a plan … for a module naming system, temporary one, pending discussion about import naming schemes.  That’s the end of the agenda.  Is there anything else?

SC: presumably we’ll need an IDL to header file conversion after, 
DG: yes (..) + rust interface generation

M: …
LW: …
TS: s-expressions as type definitions minus the body is the obvious way to define the functions.  WHat’s missing is how to fit the binding expressions in there

LW: importantly, binding expressions don’t fit in there, interface is just the types

M: to generate a header file, you’d need the IDL and the bindings and they do need to be separate because different languages want different bindings

LW: I’m not quite sure what you mean by supplying the bindings.  You could generate for say, C, there’d be policy choices like what to do with strings, but it’s possible.  Sounds like a cool tool though

DG: that sounds like the end of the meeting, see you all in 2 weeks
"
gc/2021/GC-09-07.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 7 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: September 7, 4pm-6pm UTC (September 7, 9am-11am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. JS API requirements and design space (Daniel Ehrenberg and Asumu Takikawa, 30 min)
    1. Separate compilation (Ross Tate, 30 minutes)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Leo Andres
- Chambart Pierre
- Asumu Takikawa
- Francis McCabe
- Zhi An Ng
- Conrad Watt
- Rick Battagline
- Aske Simon Christensen
- Luke Wagner
- Jakob Kummerow
- Zalim Bashorov
- Ben Titzer
- Ryan Hunt
- Deepti Gandluri
- Slava Kuzmich
- Emanuel Ziegler
- Ross Tate
- Manos Koukoutos
- Lars Hansen
- Andreas Rossberg
- Ioanna Dimitriou
- Adam Klein
- Fil Pizlo
- Daniel Ehrenberg
- Michael Knyszek
- Derek Schuff
- Alon Zakai
- Ben Titzer

###  JS API requirements and design space (Daniel Ehrenberg and Asumu Takikawa, 30 min)

[Slides](https://docs.google.com/presentation/d/1XwCwOQvTTuV5mU74d2wLnEqsdpi20ReCxtFRZLcW0EA)

AR: I’m surprised that you consider construction of Wasm GC objects to be harder. I was assuming that this would be necessary, but also that we would still have JS typed objects.

AT: agree that this is desirable, will talk about this more when talking about proposals on JS side, and how that complements Wasm GC

BT (chat): You can always define new types by JITing modules, so you could have a prototype API that is polyfilled

AR: Can you explain the nature of the casts you’re talking about?

AT: a specific example, a function defined in Wasm that takes a GC struct as an arg, and you export it. What checks should there be to ensure that JS passes in will match the struct type, you could do a rtt check for example. If you choose the canonical rtt for that type, that may not necessarily be the cast you want.

AR: Not sure why the canonical RTT is not correct?

DE: you could be too forgiving, two different types in source language, fields with the same position of the same corresponding type, you have to distinguish them at some level, not allowed to cast from one to another. They need different RTT, checks will need to be done statically by tooling, or at runtime by producer.

AR: Are we talking about checks to protect Wasm invariants or something else?

DE: to protect source language invariants. There will be different definitions for casting. For nominal, there will be a stronger check.

AR: Right, this is kind of at the intersection of Wasm types being low-level types, but you’re thinking about the high-level types. Those are different universes and need to be bridged, but I’m not sure lowering all the high level types into Wasm is the best solution.

DE: further in the presentation we will see some concrete examples

LW (chat): Could one instead import a (const (global rtt))?

DE (chat): Sure, same thing IMO

AR: Why do you need the callback? Why not import the RTT as a global?

AT: you can't get the parent, you need to pass the parent RTT to JS somehow. Are you saying you have multiple modules and thread them through?

AR: this is a canon rtt, you can create on the JS side

AT: in general, it might not be a canon rtt, might be deep in nested hierarchy, can't specify in JS side

LW (chat): Oh I see, the function call allows more-dynamically weaving rtt parent chains

DE: illustrates flexibility of the API

AR: seems complicated

AT: for simpler cases, if the hierarchy was all definable on JS side, with canon RTT and some children of it, then yes you can import RTTs itself, and do all definitions on JS

AR: another more realistic example, parent RTT comes from another module, you don't need this callback pattern, will be surprised if this is a common pattern, although can imagine use cases.

AT: original Wasm module, exports to JS, then JS exports to another Wasm module, which gets all the RTT at the end. If you do it that way, you still have the coupling between JS and Wasm.

DE (chat): I don't understand the purpose of this line of questioning. This slide was intended to present a possible solution for the JS API, not to make a case about something being too complex or something like that.

RT: I thought about a nuance with the imports/exports and the ordering of things. The methods you want to attach to the RTT are produced by the same module, so you already need it to be instantiated.

LW: Prototypes are dynamic, you can call an imports that passes out the funcrefs, a lot of dynamism.

RT: we're trying to reduce dynamism in multithreaded support

DE: build a little trampoline, ordering issues exist, there are solutions

AR: for structural design, the JS API would have the same primitives as in the language intself, rtt canon, rtt.sub, you can construct these in either JS or Wasm, whoever owns the type defines it. That's no different from how you'll do it in Wasm itself. most of the time you have someone defining the TT.

DE: are you disagreeing with the stated goals of adding field names and methods?

AR: this is something you have to do on the JS side, it is purely a JS issue. If you want something with custom JS behaviors, you should be doing it in JS.

CW: the discussed approach of importing something from JS to create RTT, that's the right approach?

AR: yes, also right approach for nominal

DE: think what you're saying is consistent with AT's presentation

AR: just wanted to clarify what the primitives are

CW: also interpreted AR's comment as violent agreement

AT: an API that has canon and sub makes sense, as a refinement of this

LW (chat): Can shared struct objects have a prototype and, if so, can you have functions on the prototype? (Functions would seem not-shareable)

AK (chat): @Luke very early, but there are some thoughts on shared functions alongside this proposal: https://github.com/syg/proposal-structs/blob/main/CODE-SHARING-IDEAS.md

AR: x; is a field declaration?

DE: you can have initializers, through the whole class hierarchy, which is immutable, all the fields are gathered in the beginning, all the fields are undefined, and non-configurable. Initializers replace the undefined with something else.

AR: if these are untyped, then not sure how an engine will make them interchangeable with Wasm structs?

DE: they can share a lot of the implementation, internal mechanism, but will be differences that the JS ones are not typed. There are some things engine can do with Wsm structs that they can't do with JS structs.

RT: need to view each field as extern ref

DE: that doesn't match up with how these things will be implemented

AT: at the conceptual level, yes, you can think of it like that, but it won't behave the same as extern ref

DE: if you export JS struct to Wasm module, can you make it show up as a Wasm struct? That would add al ot of implementation complexity.

RT: there is a diff in having a field, and ordering. Can someone import type for SharedBox, and alos import field accessor for x

DE: the SharedBox itself is a big externref. No particular structure when you export something that creates a SharedBox, just externref. This problem is not expressible in Wasm, only in JS, where it's all just strings.

AR: this only works in one-way, you can view Wasm struct as JS struct, but not the other way around?

DE: yes, they share implementation, to reduce maintenance burden, and better ergonomics.

AT: leaves it extensible, when we have shared gc structs, will be smooth transition to smooth structs at JS boundary. Structs from Wasm have type checking, internal to engine.

AR: would have to be part of JS api semantics, they are observable

DE: type constructors take the types of the fields, that's one way to express it

AR: run time tests in JS to dynamically check what the Wasm check statically, assumes you have all the type information around in runtime in Wasm objects, particularly references. It might e a significant cost.

CW: sounds like for MVP types, not necessarily a problem, assumings JS engine knows how the RTT is calculated. With post-mvp extension, harder to add this. Are you thinking of generics?

AR: maybe not generics, maybe continuations. Should we require that continuations references are self-describing in terms of their type.

DE: checking for struct fields read writes, same as checking or arguments and return values.

AR: with SIMD types, you can't use for the interface with JS functions, just type errors

RT: Wasm types only going to be approximation, accessors for the field could be in general a Wasm function, custom code

AR: you could have additional meta information in custom sections, so far our take on custom section is something that is not semantically relevant to engine, can be ignored, but in this case, will change external semantics, JS API. It doesn't affect Wasm itself, but affects how JS sees Wasm

CW: can argue that instrument tracing is something like that

RT: like custom section, deals with who-comes-first problem, also isolates from Wasm

AR: agree with that, if it is in Wasm, it will be in the custom section. What if you have other embeddings? Becomes part of the JS API as well. Makes it specific to JS, what if you use it in an environment that is not JS, you don't have that information there? It is privileging JS with additional information. Any other embedding can come up with something similar, unlikely that toolchains will serve this equally well.

RT: IT doing same thing, special bridging code for some environments.

DE: custom sections give languages a chance, some languages have field names, hard to link together. As well as methods. Even if we define a custom section around the needs of JS, it will serve other embeddings. We will need this imperative API anyway, for a good reflection, start with an imperative API, then do a custom section. Okay to explore custom section in parallel.

SK (chat): Wouldn’t single-purposed custom section with JS API definitions be faster to parse compared to evaluating a bunch of WebAssembly.RTT JS code? This might be an initialisation time issue for large Wasm modules.

RT (chat): yes.

JK (chat): @Slava: yes, big +1 to finding some declarative way that doesn't require calling back and forth

LW: you probably want the imperative API in general, to handle more complicated situations that you can't do in declarative thing in custom section. Prior examples in Web platform APIs that start with declarative, then had to ass imperative API.

DE: also easier for producers, to not generate all this back and forth

LW: would we make a new kind of mini imperative language in the custom section? maybe it would look like JS?

DE: will need little expressiveness, field name, parent, rtt, index, indices of different methods. Could go crazy and have accessors.

RT: might have a declarative section, you have simple names for them, build complex things on top of it on the JS sides.

CW: love every part of this presentation

RT: great presentation

AR: about asymmetry, should we make a stretch goal where JS can create Wasm GC objects. So far for all features, for anything you can export to JS, we always provided ways to construct them

CW: having a reflection API in JS to create Wasm typed objects will just happen.

LW: if you look at Wasm.RTT, it looks like a type object, it's a constructor when call will create an object with RTT

RT: for struct thing, the list of fields people provide is not meant to be a fixed order, have to deal with field ordering differences

DE: those fields are in fixed order

RT: not allowed to rearrange the fields?

DE: js structs are normally typed, in Wasm RTT type, they would be new RTT that have different prototypes, just be different things

RT: for the JS space, if a JS program has the fields ""a b c"", inserting a field in the middle of those will break the program.

DE: on the usage side, the usages are untyped, goes by names

RT: field order is not fixed from the JS perspective

CW: if someone on the JS side, edit their struct declaration in that way, the glue code (in custom or calling reflection), will need to be updated to handle that new field

DE: yes, but unsupported in MVP

LW: Wasm.RTT, different from the general purpose struct constructor

DE: we can have an API to allocate things based on wasm RTT, wouldn't consider that this full bidirectional. It's important to support an ergonomic and usable on the JS side.

LW: what would be wrong making the Wasm.RTT be a constructor function, if called, produce an instance that was an instance of an RTT

DE: what would that achieve?

LW: you can make these things from JS

DE: whether a constructor or explicit function is a minor issue, either way you can create from JS. Class, struct don't support the full expressiveness.

LW: agree on the value of the syntax, could there be a variation on the syntax that does actually turn to RTT in dynamic semantics?

DE: talked at lengths in side meetings, including with JS engine maintainers, we discussed the possibility of type system used in struct fields. THe consensus is we don't want to do this right now, Wasm is far too limiting for what we need in JS. Need something more like typescript (erasure). premature to mix these together.

RT: for untyped fields, still always a JS value, proxied by externref. Is there a reason why we can't view them as extern refs

DE: in some engines, externrefs represented differently from JS value. Are we going to make it a requirement? Given that they don't line up today, and we don't have a good use case.

AT: struct defined in JS, import into Wasm, and say it is a struct of extern refs? In SpiderMonkey, an externrefs can be a value from JS, it's not an identity operation, if it's not a ref in JS, some wrapping/boxing. You have do unbox when fields are extracted, in the middle of Wasm code. Engines aren't set up to do that, and performance overhead.

### Separate compilation (Ross Tate, 30 minutes)

Deferred to next meeting.
"
main/2020/CG-09-29.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 29th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: September 29th, 4pm-5pm UTC (September 29th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. POLL: [Memory 64 to phase 2](https://github.com/webassembly/memory64) (Wouter Van Oortmerssen) [5-10 min]
    1. Presentation and feedback gathering on branch hinting ([issue](https://github.com/WebAssembly/design/issues/1363)) (Yuri Iozzelli) [20 min]
    1. Fix typing of `select` (WebAssembly/reference-types#116) (Andreas Rossberg) [20 min]
    1. POLL: [Relaxed dead code validation to phase 1](https://github.com/WebAssembly/design/issues/1379) (Conrad Watt and Ross Tate) [5-10 min]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
* Derek Schuff
* Wouter Van Oortmerssen
* Zalim Basharov
* Sergey Rubanov
* Sabine
* Fatih Bakir
* Conrad Watt
* Yuri Iozzelli
* Ingvar Stepanyan
* Ross Tate
* Francis McGabe
* Paolo Severini
* Daniel Hillerström
* Rick
* Sven Sauleau
* Lars Hansen
* Nick Fitzgerald
* Yury Delendik
* Ioanna Dimitriou
* Paul Dworzanski
* Arun Purushan
* Thomas Lively
* Jay Phelps
* Daniel Wirtz
* Benjamin Titzer
* Luke Wagner
* Tobias Tebbi
* Keith Miller
* Asumu Takikawa
* Nabeel Al-Shamma
* Steve Sanderson
* Jakob Kummerow
* Rich Winterton
* Zhi An Ng

### Memory64 proposal to phase 2 (Wouter Van Oortmerssen)

Wouter Van Oortmerssen is taking over as the champion for this proposal.

WV: This proposal now has had some discussion, and implementations in LLVM/lld and wabt; working on Binaryen currently. There is one open question right now,
namely how constant offsets in loads/stores are applied. The current text says that they wrap, but discussion is happening
on the [issue](https://github.com/WebAssembly/memory64/issues/3).

KM: I haven't had a chance to look at that yet.

WV: load and store have an offset in addition to the address. So you end up with a 65 bit result, so you have to figure out how to handle it. 
There are several options.
We could check with branches. That would be slow.
We could wrap around at 64 bits, which could result in people addressing low memory unintentionally instead of high memory. 
So far this is the status quo, easy to implement and doesn’t require lots of checking.
We could also disallow offsets in 64 bit memories. But the offset is very useful for things like accessing structs.

KM: Also thinking about the implementation questions, around VM tricks like we use in wasm32

WV: Yeah it’s definitely harder. There’s a risk that wasm64 will be slower because of the bounds checks; any input on techniques is welcome.

LW: is that issue #3 on the repo?

WV: that’s the right one, if you look at Ben’s comment, it lists 6 options to do the wrapping, for completeness sake. I recommend everyone to read those 6 options and list those in preference. So far option 2 looks like the only one that will be fast enough.

DS: I'm not hearing any objections or more questions, let's have the poll for phase 2:

####  Poll: Memory64 to phase 2

| SF | F | N | A | SA |
| - | - | - | - | - |
| 13 | 16 | 4 | 0 | 0 |

Poll passes

switching presenter; meanwhile:

### Announcement from Ross Tate:

RT: SOIL Initiative is starting a [seminar series](http://soil-initiative.org/#seminar). First one is Monday October 12 at 12 PM EDT/9 AM PDT
Then next one on Friday Oct 23 at 4 PM EDT/1 PM PDT

First up is Thomas Lively on module splitting

## Presentation and feedback-gathering on branch hinting ([issue](https://github.com/WebAssembly/design/issues/1363)) (Yuri Iozzelli)

Yuri Iozzelli [presenting](https://drive.google.com/file/d/1LGqAVJYjBnFbhx2ANUuuA9YMELHI6gEw/view?usp=sharing)

WV: is the reason for having this proposal mostly to delay compilation of these unlikely blocks? Most modern CPUs seem to ignore such branch hinting.

YI: AFAIK, x86 doesn’t really care about branch hinting, actually saying this branch is more likely doesn’t do anything. No knowledge on other archs. It’s still useful to do these kind of things, in C++20 there is new likely/unlikely for forcing compiler to move code that is not hot out of the hot path or do different instruction selection. E.g. better to do a branch on +ve or -ve version of conditions. That can inform engine to generate different instructions. In practice we know this can make a difference, we saw it in Wasm and also people are doing it for native compilation. This could also be useful for profile-guided optimization.

WV: have you compared this against optimization that LLVM can do?

YI: problem is that for Wasm, there is no control on layout of machine code. No way of saying this if block in the middle of Wasm, you can’t say where it is in the final machine code. We tried some workaround, put it in a loop, then put at the end, other downsides, loop has more instructions. These are workarounds, if we can convince v8 to do that, it might stop working next version.

PP: in gcc compatible compilers, it moves the code around, less likely branch get moved to the end. Can we implement this in clang?

YI: clang in this case produce Wasm, but how can you say what the VM will do in the final compilation?

KM: at least in JSC, we do different optimizations if we see an unlikely block, we won’t hoist things out of unlikely block into hot path, we assume that code isn’t executed a lot, we don’t want to do tail duplication etc.

PP: will affect code gen for sure, in C++ native, when you use builtin, you’re not producing instruction that is different, you are affecting codegen of the native code, in that slow path gets lower priority and not hoisted to hot path. We can do the same for Clang in Wasm. Make it similar to native compilers.

TL: we can do all that normal clang side optimizations for unlikely blocks, most of that should work today, Clang supports C++20 attributes.

PP: if it doesn’t then it’s a bug

TL: won’t be surprised if adding that information to binary, so engine can continue to make decisions based on likely/unlikely blocks, can improve perf. Open question before standardization, we want to measure how much of the win can be gotten from toolchain improvements, and how much is really locked on the engine, and we need to tell the engine that.

RW: If you want to send me some POC code, we wan look at why it got faster. We can determine if it was caches, what caused performance gains.

TT: reg allocator is affected. We put all the reg moves in deferred code, might be the biggest in V8.

YI: yea think that is it, we see reg alloc is better.

RW: you’re seeing reg alloc is better?

KM: also icache

YI: yea both of that. Knowing one of it is deferred in the end.

RW: that’s what I want to measure, to make sure we know what is helping performance.

YI: we don’t have a small test case, we can trace our actual application and get some of the codegen. I can make an artificial test case that can have an if branch taken 1% of the time and loops forever. For small examples, the reg alloc benefits won’t be realized.

DS: It looks like there is some interest in this proposal. The procedure is that you put an issue on the proposal. Next step is call to advance to stage 1, if there is enough interest, at which point you get your own forked repo.

AR: before that, another question. Previous times, anytime optimization hints came up, we ask if it can be done in a custom section, why does it have to be a language extension.

DS: It does seem similar to name section, where we do have a spec through the CG for it.

AR: then it’s a tool convention, not in the core spec. Might affect how you work on the proposal. Make sense to keep options open. This keeps coming back, we need to have a more general answer on how to deal with optimization hints. Need to have a more scalable story.


YI: that’s a possibly we didn’t talk about

RT: also some hints aren’t semantics preserving, toolchain can optimize, but engines won’t trust it, might be only useful for toolchains. Agree with AR, good space to explore

TL: moving this to phase 1 repo does not preclude any of the outcomes, good thing to do

DS: one difference between this and tool conventions is that we will expect engines to interpret this. That's like the name section but unlike
the things in the tool-conventions repo where we haven't gone through any kind of standards process. Anyway, nothing needs to be done today.

TL: do we want to take a vote? We have that carve out for phase 1 (where we don't need advance notice).

DS: YI do you want to take a vote today? You’ll be the champion.

YI: I wanted to see reaction. If there is a possibly of doing a vote for Phase 1, sure.

[some other discussion]

DS: we are running a bit behind on time, maybe we take this offline and discuss more, e.g. how we want to scope this; we can easily bring it back.


### Fix typing of `select` (WebAssembly/reference-types#116) (Andreas Rossberg)

TODO(AR): slides

WV: discussion somewhere suggestion that we might want to change how we handle unreachable in terms of type checking, if that goes through, will this still be required?

AR: this is more conservative, that will subsume this. I assume that discussion, judging from previous discussion, will take a long time, and much more implementation work. Will not want to block on that.

CW: we’re going to be talking about wider change to unreachable in the later talk. Agree that we can go ahead with this.

RT: bottom type will have long term problems, unreachable changes will resolve this. So this SGTM to as a short-term.

AR: I'm not aware of any problems with use of bottom type here?

DS: Before we go into more general issues, I'm hearing agreement on this particular tweak; we should go ahead with unanimous consent, any objections?

<no objections>

### Add type for unreachable states (https://github.com/WebAssembly/design/issues/1379) (Conrad Watt and Ross Tate)

CW [presenting](https://docs.google.com/presentation/d/1-ajjGZpjAiGYOJlwswij9Mq6YGltmuELg3tbhu30VrI/edit?usp=sharing)

AR: you keep saying there is a special case for select. There is an abstraction that pops and operand from the abstract stack, all you have is that there is an extra type that is unknown which accepts anything. Select does not require any special handling there.

CW: it's not just special casing of select, and of other instructions that consume the type select produces. There is another question of what to do with this unknown type. In the spec, you can say x subtype y then you can type this instruction. In impl, need to have short circuits.

AR: that’s why we have a bottom type, which didn’t affect anything else

RT: e.g. adding dup instructions.

CW: i think AR’s proposal can handle dup, which is why i didn’t bring it up here. AR is completely right that adding Bot type gives you a consistent view. But you’ll have to consider it when adding new operations.

AR: no, it only show up in subtyping, bot is subtype of everything. Pretty much the only place.

RT: branch on null will have to say that bot -> bot.

CW: It’s not that it is impossible to handle, it just looks like more trouble than it should be

AR: you’ll still have special case, that’s your mode

CW: you have to know the mode when doing validation…

AR: i will predict this is more complicated, because currently you can completely encapsulate in pop instruction, but now you have to make that distinction in every check you want to skip

CW: plan to talk about it in more details, not necessarily now, maybe next meeting. You say encapsulated in Pop abstraction, it is pretty big, especially if proposal add new types.

AR: pop abstraction is like 5 lines. None of these discussions is new.

CW: Specifically now, the web compat, practical pain that implementors have faced

KM: what’s the web compat issue?

AR: everyone need to agree on what is dead

CW: one path for making things simpler is not allow dead code. But now due to web compat, we cant think of that at all, since there are already modules with dead code after unreachable.

AR: some of us argued strongly against dead code, more work for codegen

CW: my point is that the discussion is simpler since some paths are closed out

KM: in JSC we ignore the stack once you get past unreachable.

CW: that’s what this proposal is suggesting

BT: don’t think you can hide things behind Pop, in particular, return call ref, you have to pop funcref off stack, then check signature against function you’re in, since it’s a tail call, you can’t hide that behind pop

CW: you can’t hide not doing it

BT: nothing to do with select

CW: we can think about a little more, we have 2 mins left, great discussion points on hopefully proposal repository and future presentations

<BACK TO SLIDES>

RT: haven’t heard from implementors yet

CW: maybe they can express opinions in the form of a consensus vote

AR: there are various concerns from previous discussion, you make it observable distinction between decoding and validation. Currently not having this observable gives a lot of leeway to spec and implementation. E.g. in SIMD discussion, we keep moving stuff around, should it be validation/decoding error...

CW: if we are putting in effort into moving it around, people are already caring about it. If we are only moving a small thing like magnitude of immediates.

AR: practical issue, spec might optimize it for one way, implementation might optimize it for another way

CW: agree that there needs to be more discussion

AR: i think you’re pretty native about this, underestimating the amount of work

CW: checking immediates will let them reuse a lot of work, looked at existing implemetors

DS: clearly this needs a lot more discussion, but the bar for phase 1 is quite low.


#### Poll: Relaxed dead code validation to phase 1 

| SF | F | N | A | SA |
| - | - | - | - | - |
| 9 | 15 | 10 | 0 | 0 |
"
main/2020/CG-04-21-Subtyping.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 21st video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: April 21st, 4pm-5pm UTC (April 21st, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. [Special edition of the meeting to discuss subtyping](https://github.com/WebAssembly/meetings/issues/529)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

Ben Smith

Jacob Mischka

Ross Tate

Clemens Backes

Francis McCabe

Alex Crichton

Deepti Gandluri

Derek Schuff

Lars Hansen

Thibaud Michaud

Ryan Hunt

Mingqiu Sun

Sean Jensen-Grey

Ioanna Dimitriou

Emmanuel Ziegler

Andreas Rossberg

JP Sugarbroad

Heejin Ahn

Nabeel Al-Shamma

Thomas Lively

Bill Budge

Jakob Kummerow

Rick Baggatline

Adam Klein

Pat Hickey

Rich Winterton

Wouter Van Oortmerssen

Dan Gohman

Zalim

Zhi An Ng


### Proposals and discussions

Ben Smith Presenting [Slides](https://docs.google.com/presentation/d/1yzfLkStEjlLeK3L1WcOEijb0hfERBh9GxcNbxBjWi-Y/edit). 

AR: Point to add there that there is a eqref type - if there is a eqref type, then there’s no reason not to have anyref as well, as there’s no good way to have equality without eqref <BS Agrees>

AR: I have a slide that lists all the changes to the ref types proposal - can present that later. 

<AT Slide: Incompatible with superfluous casts>

AR: counter argument is that this is unlikely to  be applicable to Wasm, not sure how relevant it is, because we have way more annotations, and avoid inference. This will be a different design direction from what we have done so far. Might be interesting from the tooling side. If there are IL that compiles to Wasm, but again this is not relevant to Wasm, would be a separate language, with a separate type system, that does not impact Wasm (inside the engine).


TL: It does become relevant as a secondary argument. It becomes relevant when all the tools are using a separate language and type imports.. There is a risk here that if we say it’s a tooling feature and not a VM feature, we might end up with something that no one used. 

AR: this isn’t about features that no one uses, this is about potential problems that might be introduced into the type system. This system is very special, the problem there is through a combination of some hairy features. It’s not clear what conclusions we can draw here. It’s a really specialised case. Not clear to me how this would carry over to the toolchain side.


RT: The high level of phrasing this is, currently we don’t have a way of getting rid of superfluous casts, there’s only one technology that has managed to get rid of them, the argument is here is it worth implementing something that’s hard to get rid of to begin with?

BS: any other For arguments that are missed?

RT: another For argument on type imports, can wait till later.

<BACK TO SLIDES>

AR: some amount of churn expected, that's why we have stages, process

<Slide Against #2>

AR: I think this is conflating other things, but not worth going into the details right now. 

<Slide Against #3>

TL: Most of the proposals that would be impacted, that would have this churn are phase 1 proposals, taking action to avoid churn in Phase 1 isn’t a precedent we should set

BS: although, there will be churn in phase 4 proposal

AR: Which phase is Exceptions?

BS: 2, I believe, almost 3.

<Slide Against #4>

AR: This came with the argument that even if we don’t have subtyping, we can have conversion operations, I would argue that this is not enough, we also need both versions boxed and unboxed types so you’re not converting back and forth in an expensive manner. If you have the unboxed types, once you have more precise types, you will still need boxed types in addition to the unboxed types.

<Slide Against #5>

JP: not a big fan of having null ref, only to support default values in table, should say undefined entries in table is bad, almost like a trap value, but a little late to make that change

HA: We still need null values for local initialized values, so if you have locals for reference types, you still need them for initializing those values. 

AR: it’s hard to avoid having something like this, there are things that become more difficult if you have no way to represent an uninitialized thing explicitly. We still want to make the distinction later, know if something is inhabited by null or not

JP: Wasn’t trying to argue that we should remove null, just pointing out that null is already a wart, so we’re not without warts anyway

AR: I don’t think anybody particularly likes it

BS: end of slides, any other arguments, please share

EVERYONE: thanks Ben

BS: Hopefully fair to both sides

FGM: I’m kinda neutral, prefer there was no subtyping at all, as far as interface types, we will not be using subtyping in any meaningful way. Reason being, when you invoke a func across module boundaries, you will be coercing the data, not casting. In that world, subtype loses all meaning. If the motivation is to support inter-module operation, then IT is saying “we don’t need it for that”

AR: You would probably need it if you want some kind of cross language interop where you have a certain family of languages where you want to pass objects along. You would need some kind of abstract API like the JVM and have several languages compile to the API, that’s where you would need more explicit typing..

FGM: The thing that worried me about that; you're already talking about representing Java types in wasm. Wasm is a meta-level wr.t. to Java, you don't need it at a meta-level.

AR: Not sure I follow. Think this is unclear territory anyway, we don’t really know how/whether we can do it. Main use case for subtyping is not at boundary, but within single lang/runtime, might involve multiple modules, but won’t go through IT.

JP: Just to check one of my assumptions; the goal of removing, is to avoid the need for the runtime to use the same rep for two types, or to reduce need to boxing/unboxing correct?

RT: I have some slides on concreting what that means, can present that. 

AR: One quick comment; for any subtyping we do, it's always coercion free. It's supposed to be closely representing the value rep, we only want to have subtyping that has representations that are fully compatible.

JP: we don’t have any normative guidance in the spec for that

AR: More like a design principle that we want to follow - like a rationale - more meta level

RT: pops up in two spots, implicit direct handling between instructions, if we ever do func refs with some variance, then if a <: b, and func returns a, another func returns b, you can’t dynamically wrap func and do the coercion, has to automatically happen

AR: Right, if you have coercive subtyping then it doesn't compose...

JP: As of last conversation, we were not talking about having coercive subtyping <AR Agrees>, or variance? 

AR: We don't currently have variance, but we may want it in the future.

JP: It’s not that we prevent runtimes from using boxed references...

RT: It's not known that future features will be compatible with it. Languages with subtyping will make it so we would have to coercions.

JP: that might be something you wanna put in the spec

AR: There are always ways to do them, it’s not going to be efficient.

JP: thinking ahead, someone reading the spec, i know whenever funcref becomes anyref, i’ll just coerce, and they get bitten

AR: Problem in general, if you look at Wasm as-is, you can miss the broader picture

JP: It factors into the cost calculation -- if we add subtyping, a VM shouldn't use coercion to implement it.

AR: currently, there are notes in the spec, or you could add notes of some kind, future versions of Wasm likely to have more subtyping

JP: Do we want to look at RT’s slides? 

Ross Tate presenting slides [(pdf)](presentations/2020-04-21-tate-embracing-heterogeneity.pdf) [(pptx)](presentations/2020-04-21-tate-embracing-heterogeneity.pptx)

LH: Spidermonkey uses NAn boxing, similar tricks with high tagging have been used, and everytime they are used, someone comes along to replace them. Just want to emphasize that it’s not as simple as presented here. 

RT: Just trying to lay out the possibilities -- I know it's not trivial to make it work efficiently. Also not insisting that everyone has to do this. This is looking toward the future, what an engine may want to do. To try to get Wasm VMs to match performance of specialized engines.


<back to slides>



AR: I don’t see why that’s the case  <LH Agrees>

RT: Imagine a Kotlin value is an anyref, so is a Scheme value, how do I interpret those bits?


LH: You’ll need contextual information <RT: You don’t have it> That’s not a problem for type safety

RT: You want deterministic encoding -- if Scheme and Kotlin have the same encoding, anyref, how do you make them work together?

LH: That’s a problem the compiler needs to solve to make sure that does not happen

RT: I can import/export my anyref

AR: Anyref is the same everywhere... but this is ignoring the abstraction level you need between the compiler and architecture they're running on. They have no way to tell the engine that they have 5 bits to use ... so how can you provide optimizations like that?

RT: This why we wrote up a whole thing to show it can happen

AR: You have to go through some abstraction, you need some types of reference types. You need to define them so you can use those bits.

JP: We’re at 14 mins..

RT: At a high level the engine needs to figure out how to adapt, and not be conflict with the GC proposal

AR: I don’t see that being in conflict with the top type. You also say, for imports, we don’t need the top type, but if you don’t have top type as a bound, you still have the same kind of isomorphic type, you have the same situation where you can mix all the types

RT: The thing about type imports is that you can still have… everybody follows the same convention that’s totally fine. The issue that comes up is that if you have anyref, all the info gets put in the same place, and there isn’t a convention of what bits represent.. Unless we dowcast.. Not sure how this would work

AR: Almost all engines out there that use GC use uniform representations. Through NaN boxing or pointer tagging. anyref is the universal type of pointer types. The difference is the pointer tagging scheme, using more or less bits. We can't easily represent that in Wasm, we can't make many assumptions about the number of bits to use. We could have some sort of abstraction with the number of bits, where those bits may end up in an allocation.


RT: You compete at the right architecture level.. If you had everything flow into the same part, then we have to have a consistent way to represent this

TL: Talking about GC proposals right now. IIUC, you're saying that using anyref as uniform rep. would prohibit the use of different language-specific optimizations. Does existence of anyref prohibit optimizations?

RT: The existence, and the assumption that it’s the top type, then any type imports being a subtype then it does

AR: I think this is false. anyref represents the thing that the GC knows about. It has to understand something about the representation. Something minimal. Everything on the GC heap has to share this representation.

<RT pointing to 64-bit machines slides: This is what it’s representing>

AR: But none of these are independent of the architecture you're running on. The anyref is the sum of all things to distinguish refs from non-refs.

TL: Can we agree that we want to leave our options open, about how this would work in the future? And that we can look at RT’s GC proposal, and agree that we leave the door open. 

AR: I don't think we're closing anything. There are assumptions here that don't make sense. It seems unrelated. If you ever want to have a built-in GC, then we need to have commonality between them. The anyref is the type of thing that the GC understands. There is no implication here that it would prohibit anything.

JP: I think the call is for general conservatism - the question is whether a funcref should be a subtype of anyref.. And not to enforce

AR: Of course. It's just capturing what is common to all implementations.


LH: RT is overstate his case, but I agree that it would be useful to have a tagging system and we’re left with anyref which is completely opaque.. As far as we’re concerned, we will probably need something like funcref being a subtype of anyref, but don’t want to commit to anything right now

AR: I don't see how that's related...

LH: Leave the relationship open without assuming it too early..

AR: Sure, if everything else is equal, yes we should defer.

LH: The engineering cost is non-trivial, I really agree with you that we will end up with some type of subtyping but we can afford to defer while we explore this further. 

AR: There are three options. 1) go ahead with what we have 2) we modify ref-type proposal to remove subtyping 3) defer ref-type proposal until we know more

LH: Not an attractive option for the web, we want to ship anyref as a container type for passing host types to WebAssembly

JP: We can include hostref type. [LH: anyref is host ref] otherwise it's just exnref and funcref.

LH: Right now, anyref only uses host types, and exn ref if we count that

AR: We should rename anyref then..

LH: Don’t care what it’s called

JP: Jakob has asked to see Rossberg's slides on chat.

<AR Presenting a slide on required design changes>

[Slides](https://github.com/WebAssembly/meetings/blob/master/main/2020/presentations/2020-04-21-rossberg-ref-type-subtyping.pdf)

RT: It could be useful to leave in the spec where we expect subtyping to be used in the future.

AR: It's not good to specify rules that can't be tested.

JP: It's guidance.

DG: Should we have a poll in the next CG meeting?

<discussion about how to handle poll in the next meeting>

### Closure
"
main/2019/CG-04-02.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 2 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: April 2, 4pm-5pm UTC (April 2, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email Ben Smith to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    2. Discuss issues with js-types [proposal](https://github.com/WebAssembly/js-types/blob/master/proposals/js-types/Overview.md) ([issue 1](https://github.com/WebAssembly/js-types/issues/6), [issue 2](https://github.com/WebAssembly/js-types/issues/5)).
    3. Discuss [new PR for Host Bindings](https://github.com/WebAssembly/host-bindings/pull/21)
      * Replacing Brad Nelson as co-champion with Francis McCabe
      * General questions / discussion?
      * Any initial thoughts on the [open question](https://github.com/WebAssembly/host-bindings/blob/ee4f4f173e85b4d08117e4004ee35c17fd17c97b/proposals/webidl-bindings/Explainer.md#open-questions) of whether to depend on Type Imports?
      * Poll: rename this feature from ""Host Bindings"" to ""Web IDL Bindings"" (and thus the repo along with it)
    4. Discuss starting a new CG Subgroup for WASI
      * For background, see [the WASI blog post](https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/).
      * We propose a Subgroup, to iterate on and eventually standardize WASI Core, as well as other modules in the future.
      * Poll: Create a new Subgroup with this charter (based on the Debugging subgroup's charter): https://github.com/CraneStation/wasmtime/blob/master/docs/WASI-proposed-CG-subgroup-charter.md
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Adam Klein
* Alex Crichton
* Alon Zakai
* Aseem Garg
* Ben Smith
* Ben Titzer
* Conrad Watt
* Dan Gohman (DG)
* Daniel Ehrenberg
* David Piepgrass
* Deepti Gandluri
* Flaki
* Francis McCabe
* Jacob Gravelle
* Keith Miller
* Kevin Hoffman
* Lachlan Sneff
* Lars Hansen
* Lin Clark
* Luke Imhoff
* Luke Wagner
* Mark Miller
* Mitch Moore
* Nathaniel McCallum
* Nick Fitzgerald
* Paul Dworzanski
* Peter Jensen
* Sam Clegg
* Shu-yu Guo
* Sven Sauleau
* TatWai Chong
* Thomas Lively
* Till Schneidereit
* Venkat
* Yury Delendik

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Luke seconds

### Proposals and discussions

#### Review of action items from prior meeting.

#### Discuss issues with js-types [proposal](https://github.com/WebAssembly/js-types/blob/master/proposals/js-types/Overview.md) ([issue 1](https://github.com/WebAssembly/js-types/issues/6), [issue 2](https://github.com/WebAssembly/js-types/issues/5)).

AG: brief introduction. We want to be able to reflect the wasm types in JS. So the tools can use it. We want to wrap a JS function webassembly type. We should be able to add the wrapped function into a table. We don’t need to import into a module and export. The other feature is to inspect other things about the module.

AG: It says we should be able to specify the minimum and maximum. We currently use the words minimum and maximum. Right now use initial and maximum, new proposal says min and max which breaks backward compat. OK with that?

DE: Sounds good to me.

AG: Since we’re adding new minimum, proposal says we should be able to add initial or minimum, but not both. But the way things are set up, we can give them both. In that case minimum is discarded. I propose that in case both are given, we should use initial. I believe that is the way forward to not break backward compatibility. Thoughts?

LI: Allowing both … erlang allows both. Both but they don’t have an effect could confuse people.

AG: We’ll have to change a spec test for this.

BS: The issue is you could have already passed in an initial, so it may be that it worked before but now would break.

AK: If you already had a minimum there… the general assumption is that people pass object literals. So there isn’t the expectation that these are filled with random keys.

DE: I don’t understand the exact concern. The assumption when evolving is that you use the initial if it’s there and the minimum if it’s not.

??: It probably should be an error then, because that points to the options might not mean what they think they mean.

LI: Maybe an error if they disagree.

DE: I wouldn’t want it to be an error maybe… asserting that there both equal, I don’t see the point.

LI: Erlang has both things, so it may confuse users.

DE: I don’t feel strongly about this, but this is not something expressible in wasm (shrinking memory). If we did add that capability, it would seem wrong to assert that they are equal. It doesn’t seem to be validation of unused arguments in JS option bags.

JG: It’s confusing if they don’t match.

DE: It seems like the appropriate check is minimum < initial.

JG: Currently doesn’t say that. They’re the same, so it’s confusing. I wouldn’t know which is recognized.

DE: We can continue discussing in issue.

JG: I like validating if they’re not equal. If they’re equal then you validate user intent.

BT: Why adding this name?

AG: The proposal says that it makes less sense when the memory is grown. We need to keep initial around for backwards compatibility but minimum makes more sense.

BT: I don’t see a strong use case for making it complicated.

DE: Follow up on github.

#### Discuss [new PR for Host Bindings](https://github.com/WebAssembly/host-bindings/pull/21)

* Replacing Brad Nelson as co-champion with Francis McCabe
* General questions / discussion?
* Any initial thoughts on the [open question](https://github.com/WebAssembly/host-bindings/blob/ee4f4f173e85b4d08117e4004ee35c17fd17c97b/proposals/webidl-bindings/Explainer.md#open-questions) of whether to depend on Type Imports?
* Poll: rename this feature from ""Host Bindings"" to ""Web IDL Bindings"" (and thus the repo along with it)

LW: New PR, follow up from TPAC meeting. Adds new explainer with more detail. It continues with proposal to scope host bindings to WebIDL. Please check it out. If there are general questions here, high-level questions. As an update, Brad Nelson is no longer with CG, so we’d like to have Francis as co-chair. Finally, would like to rename to webidl bindings. Any questions?

[no comments]

BT: should be unanimous consent.

BS: POLL: rename host-bindings to webidl-bindings. 

[Unanimous consent.]

#### Discuss starting a new CG Subgroup for WASI

* For background, see [the WASI blog post](https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/).
* We propose a Subgroup, to iterate on and eventually standardize WASI Core, as well as other modules in the future.
* Poll: Create a new Subgroup with this charter (based on the Debugging subgroup's charter): https://github.com/CraneStation/wasmtime/blob/master/docs/WASI-proposed-CG-subgroup-charter.md

DG: We published a blog post a week ago, starter WASI api. We’ve seen support for various languages. WASI is inspired by cloud abi, it uses the capability model of security. We expect it to evolve. The API will be more module. There will be additional modules, so we think it should have a CG subgroup. Any questions?

BT: Is WASI going to look at host references -- adding them to the API. When of the capability security concepts is that you can’t forge them.

DG: Yes, currently we use integers, but we want to use references in the future. Potentially we’ll make the current API a polyfill, with a core with references underneath.

BT: So basically it’s references under the hood.

DG: Yes. The current API uses integers because reference types aren’t available everywhere yet, and it’s friendlier to C-like languages. But we’ll be able to do more in the future.

MM: Can you speak about timeline of anyref proposal?

BT: Landed in v8, but not shipped.

KM: It hasn’t started really at all on JSC. For how long it would take, not sure.

LW: Mostly the work is adding stack maps.

LH: We’re done except for table.fill. Don’t have function types, we are not planning on immediately adding them either.

KM: You need stack maps for GC? We just scan the whole stack

LH: Yes

MM: What is the spec progress of reference types? [phase 3]

KM: Were you hoping to make use of function references?

MM: Both. Do object pointers lead to function references? I haven’t followed what’s up with object pointers. I assumed reference pointers.

LH: You can reference a function from JS, and you can invoke it that way.

MM: What about from one wasm instance to another wasm instance? Can you pass something through the call interface from one wasm instance to another, such that the receiving wasm instance can invoke in the namespace where it created, not called.

LH: You can do that, we don’t plan to support the function reference type or func.call yet. But if you can store that in a table, then you can store it in a table, and use it that way.

MM: I’m assuming a case where two wasm instances are not sharing a memory or a table.

LH: In the case of tables you can choose that, you can have shared and private tables. You aren’t not forced to.

MM: What’s the calling convention, such that a caller can dynamically give access to a given function. Sounds like they have to have a table that share. 

LH: You have a private table, you use table.get to get the reference to anyfunc, you pass it around as an anyref parameter. But… can you turn the anyref into a function and store it in a table and invoke it? You probably can’t...

BS: I don’t think you can because you need to downcast.

BT: You can declare a table of type anyfunc/funcref.

LH: The reference type proposal has this, but we chose not to implement it.

BT: I think we implemented all of this.

LW: Easy enough to implement, but it may end up slow.

[some discussion about funcref vs. typed function references]

MM: Reason I bring this up -- as we proceed to define WASI APIs, we should assume working first-class functions that can be passed. Designing APIs around anything else would be more awkward.

KM: Are there any reason they are integers? In C++ you could make them an opaque pointer type.

BT: You could still forge them with reinterpret cast.

LW: The current proposal is a starter, but the real API would be to use reference types. It’s not enough to have void pointers. You can’t do that with anyref. You have to go to i32 at some point. This currently happens on the WASI side, but as things evolve this will go over to the other side.

NM: Some implementations would cause a performance overhead. It would add a translation layer on top of whatever is integer.

DG: The plan is that we have WASI apis -- could have a polyfill for i32, one with references. Some could implement i32 version directly, rather than using references. You can implement it however you want depending.

NM: We would end up implementing multiple APIs there.

BT: One benefit of ref types is that they are unforgeable. Emulator inside emulator. Also gives you automatic reference reclamation, you get GC of file handles for example.

DG: Not clear that all systems want that. Some people want i32 and some want references.

LW: You might want safety…. If I just pass an i32 to a syscall, then I can pass untrusted bit.

NM: You don’t get unforgeability via pointers…

LW: Reference types you can’t forge that way. You can only get them from your own local module.

LI: How does host capabilities interact with WASI. For erlang support, you find the number of logical cores, spin up those. We don’t have a way to ask that currently. Is there a way to do that in WASI, or would it be in wasm proper. Are threads part of wasm or WASI?

DG: Threads are part of wasm, in the threads proposal…

LI: Confused because fork was mentioned in lin’s article.

DG: WASI could define an API for this, has been some discussion about pure wasm threads… [LI: would help us a lot], this could be a path forward for that. We could add a thread create/thread join and use it that way. Then parts could be in WASI platform, thread is an object that would provide fork/join … browers could it too, not sure what that do.

DG: For # of CPU cores. That would differentiate to the embedding, so it would probably be in WASI. It’s meant to be modular though, so we could have APIs for number of cores, and embeddings could decide how to implement that.

LI: For the web embedding, we can’t lock up main thread. We need to have a web-specific way to do that. Is there a way to ask about the main thread, in WASI?

DG: ongoing discussion about that. We could have application modes, a command vs. reactor. Reactor stays present and responds to events. Applications declare via manifest whether which they want to be.

LI: Our current plan is to … [ some description of erlang ]

DG: Reactor has other advantages too, it can be completely off the stack. That concept is very new, we need to work on that going forward.

LI: If any worker wants to interact with DOM API, is there anything to make that transparent? Event dispatch thread for Java in swing, create a runner?

DG: I haven’t thought about this -- we want to have APIs that are generic, policy is handled in libraries and polyfills. Things may be end state… implemented about whether in worker on main thread.

BT: Implemented in rust?

DG: In Rust and currently some C code from CloudABI

BT: Since we are also working on v8 embedding API, can’t we implement this so any embedding could use it?

DG: Seems possible. Other questions and follow-up.

POLL: Create a CG subgroup for WASI

| SF | F | N | A | SA |
| -- | -- | -- | -- | -- |
| 22 | 5 | 0 | 0 | 0 |

BT: I assume the name of imports is WASI?

DG: currently wasi_unstable for now. Wasm module with no prefixes. We have a special feature in C that allows us to declare this independently from C name. If you want to file issues about this, we have a WASI repo for this. But we’ll add a new repo.

LS: Would we have a module with wasi/module_name?

DG: Not sure what the right name mangling there. But yes, they would be separate names.

TS: Does it make sense to transfer it from cranestation? Or make a new repo.

DG: Probably make a new repo.

TS: Mainly thinking of issues.

LI: You can transfer issues in GH now.

BS: Any other topics?

LS: I remember hearing about a whitepaper on the wasm type system. Is that happening?

LW: Most up-to-date is the GC repo

LS: Heard about this a couple months ago? Not sure.

### Closure
"
gc/2022/GC-07-26.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 26 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: July 26, 5pm-6pm UTC (July 26, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: usefulness of a `wasm` type (Ben Titzer, 30 minutes)
    2. Discussion: type annotations on accessor instructions
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Sergey Rubanov
- Aske Simon Christensen
- Rick Battagline
- Justin Michaud
- Asumu Takikawa
- Ben Titzer
- Conrad Watt
- Yulia Startsev
- Andreas Rossberg
- Ilya Rezvov
- Francis McCabe
- Adam Klein
- Alon Zakai
- Deepti Gandluri
- Manos Koukoutos
- Luke Wagner
- Jakob Kummerow
- Emanuel Ziegler
- Zalim Bashorov
- Matthias Liedtke
 






### Discussion: usefulness of a `wasm` type (Ben Titzer, 30 minutes)

BT: Introduce a supertype of all the Wasm things that excludes internalized external things. But given that we decided on a three-prong hierarchy, I think data already serves this purpose.

CW: We should have a wider discussion about how wide we want casts to be.

BT: The principle I was after was to give modules the ability to be specific about types they don’t want to include. To allow negative reasoning.

TL: The casting discussion is one we have a start to, but I expect that we’ll be actively discussing this soon


### Discussion: type annotations on accessor instructions

TL: I think we shouldn’t have type annotations because the size savings seemed significant.

CW: We should look at relaxed dead code validation
TL: How much work would it be? It’s a NOP in binaryen

CW: We came to the conclusion that we shouldn’t have a distinbction between decode/validation errors. We have only one path forward, and does that implementation effect validation performance?

CW: <TODO: Link proposal for context> When we only have a bottom stack type, in terms of validation rules does this degrade validation performance? 

BT: My 2c. All the checks for validation in Wizard look like “if we’re in unreachable code, don’t do X.” This is easier than actually tracking a bottom type.

CW: That’s a way to do it.

TL: Don’t want the GC proposal blocked on the dead code validation proposal, but if it is simple, we should get it through, we have several issues to figure out in the GC world, we could explore advancing this in parallel

AR: Depending on how the implementation works, it might make it more complicated because you have more case distinction, makes the spec complicated as well. As it sits right now, you would have a whole set of adhoc rules added to the spec. Wr.r.t implementations you’d have to figure out whether it makes their lives simpler, depends on how they work. If you’re using the right implementation, the current semantics may be easier to handle. Hard to predict

TL: If we decide not to have type annotations, from the spec side we end up having adhoc rules anyway, would it be worse to have explicit rules from the dead code validation? Is one worse than the other?

AR: There would be fewer ad hoc rules.

CW: It would be similar. In worst case, you have two separate rules: one for reachable code and one for unreachable code.

TL: On the issue, JK said we should make this decision based on reachable code, and not unreachable code. I agree with that, but this is good background for what needs to happen in the spec

BT: Tools that process code cannot understand what the stack effects are unless they also model types, there’s different manifestation in different tiers, interpreters, baseline compilers fall into the same category where they don’t have types rolled into it. Not all baseline compilers are going to be using types, you need atleast ⅔ instructions to model types. These two tiers are stand ins for tools that process bytecodes, they will not have to replicate the extra work for types, which means they’ll be doing work they don’t need to, we should be cautious about what we decide to do. 

AR: Was at the first program analysis workshop for Wasm a few weeks ago. Don’t know if these particular problems would be problematic for them, but explicitness was definitely a selling point.

TL: What type of tooling doesn’t need to reason about types? In the context of a whole tool I assume they need to do something with types. Without an additional concrete use cases, not willing to put much stock into..

AR: They already exist, it’s just much harder for existing tools. 

LW: We’ve invested a lot of time into linear type validation, so we could lean into that. It is cheap and easy to do, both V8, and spider monkey have factored that into a templatized iterator

JK: Once you do have a wasm-aware tool, it is really easy to recover the types. If writing an analyzer from scratch, I can see that it would be more work to track types, but in practice it would be easy for existing disassemblers to emit types as well.

TL: Binaryen already has a mode where we print types alongside code.

BT: We can’t really know what all consumers look like, we’ve talked about streaming decoders, people will look at less work, avoiding overloading is one thing we should do

TL: How do you think it stacks up against the size savings that we were seeing? 5-6%

BT: Those were the compressed savings, it’s closer to 2-3% uncompressed, different value systems, personally don’t care that much about the 5% savings

AK: It seems weird to me to focus on researchers rather than Web users. Libraries are an easy solution for the research need, but at the scale of the Web that 5% savings becomes very large.

BT: I understand the priority, there are other things that we should do that get bigger wins

AR: I’m concerned by code size discussions, we had long discussions about this early on, the producer can design their own bytecode if needed, we decided that this was not immediately obvious as a thing to do, if needed, we could introduce a MACRO language or a compression scheme for example that would have bigger size savings instead of micro optimizations that don’t result in much

TL: We should investigate those options, but I’m not for adding extra bytes when the 2-3% savings are significant

JM: Implementers are already concerned about numbers much smaller than 5%

AR: We’re talking about space, or not time

JM: Not familiar with Layer 1 compression, what are the comparative savings? 

TL: In the presence of a Wasm specific compression scheme, these extra bytes wouldn’t matter at all because it would remove them altogether

BT: Should we just move it out of the GC space into the main space and just save the byte? 

JK: We could do that and I posted some numbers from that experiment. I found that removing the type index is more impactful than removing GC prefixes under brotli. The type annotations have sufficient entropy that they are hard to compress, unlike replacing fixed two-byte sequences with a one-byte sequence.

JK presenting [data](#issuecomment-1194749304)

BT: It feels like hard for us to optimize against a specific compression algorithm, we can measure these things, but how do we argue that this specific compression algorithm works in a certain way, and make some design decisions based on these findings.

JK: I don’t think we need to be so specific. You can also look at gzip or some other compressor.

BT: We can do it at any point of time in the future, we don’t have to do it now

AR: We should keep the overall type system in mind, example with select, I don’t see a particular issue, but I’m not for trading the robustness for the overall type system for a 2% size saving

JK: The 2% on this module will get bigger as we take advantage of other opportunities for size 
savings. Aske reported 5-6% on the barista3 dart benchmark.

AS: Only looked at the code section, I was seeing these as 5.7 uncompressed ~6 uncompressed, that’s an interesting number, you could have a module with ⅔ of the module being data and we wouldn’t save anything

TL: How do we make progress? We can go either way. Different enough opinions here that we won’t get unanimous consensus one way or the other. We could do one of the polls on a github issue to measure the temperature and take it from there

LW: Could validation time data help make a decision here? 

BT: Since this is a space optimization, it could fit into an optimization phase, there could be more wins overall instead of making a one off design decision on this case

CW: Validation time differences would make that a weaker argument.

LW: Also will need to do additional validation checks

AR: We don’t really know how much that affects overall compilation time, would be interesting to know. Have changed my position on this a couple of times, now deciding to err on the side of maintaining the robustness of the type systems because type systems are definitely brittle, can’t really prove it in any way, 

TL: The select fix of adding a new instruction with annotation is pretty simple in practice.

AR: Hard to say whether it would be simple in a different situation. We don’t know what would break, so it’s hard to say what the fix would look like.

DG: What size wins would be large enough now?

AZ: We’re aware of code size issues, there’s a very large overhead of string overhead, I would expect these size savings to be significantly larger depending on how optimized the binary is

CW: Are these numbers we could get by just building with a different flag?

AZ: We can test it, but it’s not optimized very much, we could potentially wait a bit and get better numbers, it’ll be significantly more, can’t quantify it yet, but expect it to be significant

JM: Even if it is only 5% or 2 %, we would expect users to download that extra overhead for type system robustness, but if it’s only for tooling that’s not probably worth it

TL: It’s a guard against future breakage that may or may not happen, 

CW: Some thing polymorphic gets on the type stack, maybe we accidentally let implicit typing into the languages as examples of concrete breakage. 

AR: We can’t add something in the language because of implicit typing

LW: Incidentally, concerned about adding all the validation rules fior dead code validation, but maybe relaxed dead code validation might help

CW: We keep hitting up against needing relaxed dead code validation in different proposals

BT: With the local initialization, 1a is based on some inference. Types from the stack can be more precise than the annotations, so for example nullability can change. Annotations are a nice “check” to make sure everyone is looking at the same type rather than depending on having the right type from the stack.

MK: What if we add the instruction, but add type annotations to other instructions, in the cases where there is type confusion, you can annotate those with types

CW: If we get into the bad situation of needing annotations later, you would need to figure out how to add them, so from the wasm perspective it’s the same as any other instruction

MK: I would assume this would be a rare fallback.

AR: Problem is not future features, but future instructions that conflict with existing instructions, you can add annotations then, but they’re optional and you would still handle the case when they’re not there

MK: I guess it would be a validation error if you couldn’t infer the type.

CW: You would have to find some way to make the distinction, in the wors case, allk these problems are solvable, but it’s just avoiding a pit to fall into

AR: You can’t randomly rule out some types without breaking some properties like substitutability. and some positions, don’t think this problem is that hard to avoid. Hard to predict, but also very fragile

MK: Point of the annotations is that engine doesn’t need to do inference

AR: Problem is defining the problem when you don’t have annotations, and now when you don’t have them you have to do it in a way that breaks the type system, it’s not obvious that that’s possible

BT: We talked about this very early on, e.g. can you use the expected return type of an AST node to compress the next opcode? We could go deep down this road.

AR: similarly with overloading, you just add it to one instruction, I’m sure that compression will be beneficial overall, this is really a type of overloading

TL: Given that you have a concrete type on top of your stack, but that doesn’t need an annotation because you can get it from the top of your stack, if we end up in a situation where you don’t know the type of your stack, and can’t infer it..

BT: You can get into a lot of weirdness with generics, not comfortable with this line of reasoning

TL: If that means we need to add type annotations to a future proposal, so be it

AR: It could maneuver you into a position where you might not be able to add them

TL: Comes down to value systems, there’s some risk of breakage, the solution of adding a whole slew of annotated instructions even though ugly it’s solvable. Good next step is to do a quick poll and get a better sense of where everyone stands. 
ASC: Adding annotated instructions doesn’t sound so bad in my opinion. We have different places where we have special cases of instructions

AK: Is there a blocker to get validation time numbers? Binary size isn’t the thing I care most about for web users

TL: Would anyone individually change their opinion if there was improvements in validation time? 

CW: On the fence, but if the validation time is bad, then I would vote for removing

AR: We should look at validation as a % of compile time, it would have to be significant for me to change my mind, more than 2% definitely

TL: Might be useful to get this data

JK: It’s doable.
"
gc/2021/GC-02-23.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 23rd video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: February 23rd, 5pm-6pm UTC (December 15th, 9am-10am Pacific Standard Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. V8 status update [Jakob Kummerow]
    1. Spidermonkey status update [Ryan Hunt]
    1. Binaryen status update [Thomas Lively]
    1. Wizard status update [Ben Titzer]
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Sergey Rubanov
- Francis McCabe
- Sabine
- Tim Steenvoorden
- Zalim Bashorov
- Ryan Hunt
- Adam Klein
- Ross Tate
- Rick Battagline
- Jakob Kummerow
- Lars Hansen
- Paulo Matos
- Conrad Watt
- Luke Wagner
- Slava Kuzmich
- Daniel Ehrenberg
- Asumu Takikawa
- Dmitry Bezhetskov
- Ioanna Dimitriou
- Igor Sheludko
- Ben Titzer
- Manos Koukoutos
- Keith Miller (Apple)
- Wouter van Oortmerssen
- Andreas Rossberg
- Emanuel Ziegler
- Deepti
- Yulia Startsev
- Zhi An Ng

### Presentation: V8 status update [Jakob Kummerow]

[Slides](https://docs.google.com/presentation/d/1uCcaP4lxb7whLRTrClgZZhlnlykOuTVf-m88fnXG-ps/edit?usp=sharing)

AR: Performance is not quite there yet. Do you have an idea of why?

JK: too early to say something definitive, only just started investigating. One reason is the various checks that we do. The JS versions is good at optimizing away type checks, we spent a lot of time doing that. In Wasm GC we do a lot of subtyping and null checks. Unclear how much the difference is due to such checks. We will learn more.

BT: I would imagine that the languages compiling to Wasm GC benefit from inlining and that V8 is not inlining yet.

JK: correct, we do not inline yet, we assume module producer does the inline. Have not looked at how much difference that would make.

BT: question about testing strategy. There are no tests in spec repo for gc, did you write your own?

JK: Yes, we have our own tests. We are prepared to fix bugs that toolchains find.

BT: i have an implementation in wizard, i wrote my tests too, will be useful to get some standardized tests, the blocker is getting it into wabt?

JK: that would be the most maintainable. My most recent devtools related work, i’ve been adding wasm modules by hand (array literals), because no tools readily available that supports the feature

AR: should at least implement binary to text conversion in reference interpreter to make that possible

JK: that would be useful

RT: how are people implementing dynamic dispatch in GC? Func refs?

JK: not sure

RT: how are you implementing func refs currently?

JK: Need to abstract over many different kinds of functions that are the actual backing. It could be a JS function imported, could be a function on the same Wasm module, or an imported Wasm module, which in turn could have any kind of backing. That makes the implementation of func refs and call ref instruction fairly complicated and probably fairly slow.

RT: Kotlin is probably going from getting all the JS optimizations to getting a lot of indirection, so I was just wondering...

JK: For first version they are planning to use tables with function indices, rely on classic function calls

SK: we use table with anyfuncs

AR: Why would call_ref be slower than call_indirect? It’s essentially doing the same thing.

JK: i think it should be comparable to call indirect

BT: If you just have to do a signature check, it should be faster. No bounds check.

AR: unless it is a type table then that’s not the case

RT: call indirect, will it be fast? I don’t know if either solution will be all that great

AR: if you directly call an import, it’s no diff from an import, you don’t know statically what it is

BT: call indirect that goes through table, has to bounds check, load signature, and may have to load the instance too, ~12 instructions. Call to import, it loads 2 things from table, no bounds check. Call ref should be indirect load from ref you got, maybe null check, and jump to that.

AR: why is call ref slower than indirect call?

BT: They should both be about 3-4 instructions.

RT: the ref has to contain module instance as part of the closure, direct has module instance. Call ref has an indirect reference.

AR: no, why should it need to know

BT: both should be about 3-4 instructions

JK: looking at last implementation, we need first 4 load then branch into different cases, and then do another 2 - 4 loads, until actual call then we can jump to it. Just to give you a rough idea.

AR: for an import, you presumably have to do something similar

JK: it’s modelled after call indirect. Call ref has a bit more work to do

AR: direct call to import

BT: instance pointer floating around in register, table off of that, and table has 2 entries, instance and actual target code, you load those 2 things, then you jump. If it is a call to Wasm, directly there, if JS then land in adapter

JK: diff the call ref is not in any table at all, could be coming straight from JS as an object, or load from global or something, that does add more work for the engine

AR: why wouldn’t you do that work when you pass the ref from JS to Wasm, as a kind of conversion

LW: semantically required, difference between JS func and exported Wasm function. Only latter can be directly passed. YOu can’t assign a JS func with table.set, that will throw

JK: you can create that on JS side and put it as arg, it doesn’t show up in any table

LW: you only ca

### Presentation: Spidermonkey status update [Ryan Hunt]

RH: We are also working on GC in Spidermonkey behind a flag only available on nightly. Based on old implementation of structured types. Working to catch up with V8’s milestone 3. Targeting baseline compiler rather than optimizing compiler. Working on structs, arrays, rtts, storage types, eqref, and dataref. Should be ready soon and we will provide updates as things land. We do not initially plan to implement low priority parts of typed function references. We do not plan to do i31ref to start. Open question about type canonicalization to start.

AR: the func ref proposal dropped any form of subtyping on func types.

JK: func bind listed as potential optional future proposal, not implemented yet

BT: implemented, found an issue, filed something, fine if it’s move to a future thing

CW: given the feedback implementers have given about type canonicalization, i’m worried that we implement the proposal minus type canonicalization, there’s no reason for implementers to shift because no one relies on canonicalization, [if this happens] we will want to redesign the proposal in a more principled way.

DE: Can you say more about implications on the design?

CW: If implementers don’t want to implement canonicalization, we would probably want to go to explicit nominal types with a parent declaration for each struct.

RH: if you don’t implement type canonicalization, you can have something workable for basic tests to get things running. Type canonicalization is useful for cross module scenarios, to get things running and performance data to see if we are on the right track, it is not on a critical path. I am interested in implementing, but it is a lower priority. Agree that if it turns out to be unnecessary, it may make sense to rework different aspects of the proposal.

CW: We don’t want to get stuck with a half-assed version of the current proposal.

JK: on board, we have no intention to block that aspect of the proposal, it is a question of prioritization, decided to focus on what’s important to get data. There’s been a lot of discussion about the type system, there seems to be a chance that if we did the work it will be ripped out later. If there are use cases, we will implement it to match the spec.



### Presentation: Binaryen status update [Thomas Lively]

[slides](https://docs.google.com/presentation/d/1yPcThMN-XuzLXU_ubg0wlhV3Q1BsYP4VVxDJA3ppvIk/edit?usp=sharing)

AR: non-funcref tables, already part of func ref proposals right?

TL: yup we still don’t implement them, also type imports exports also not yet implemented, people doing prototyping are not doing modular compilation yet.

DE??: is struct and array subtyping planned to be implemented?

TL: Yes, there’s no particular reason that hasn’t been implemented yet. Mostly an oversight. [Update: Implemented in [Binaryen #3597](https://github.com/WebAssembly/binaryen/pull/3597)]

ZB: plan to convert wasm with gc to wasm without gc?

TL: no concrete plan, but will be interesting to convert, probably doable, probably a good match for Binaryen, if anyone is interested to work on that, happy to work with you on that


### Presentation: Wizard status update [Ben Titzer]

BT: presented back in Nov, build a Wasm engine to do research on Wasm, not as fast as production. Interpreter tier only. Thinking about runtime systems developed on top of this engine. Implemented funcref and gc proposal together, union. Safe language, already GC-ed. Trickiest things were to get recursive types to work properly, and rethink how the engine represented modules, so that forward refs to get recursive types works. I did not implement rtt  canon. Implemented everything else, maybe except let. Implemented Java on top of GC proposal, lower to GC proposal. If you look at source of wizard engine, you can see the lowering for all of java bytecodes, enough to implement Java’s object model. Funcrefs for vtables. Rtt canon not necessarily for Java, nominally typed. We need a use case for rtt canon, we only have languages that don’t need that, we got at an impasse. Agree with the view that we shouldnt’ ship something that is not used anywhere, need a use case to motivate that. I can go up to work on Java, or going down to make the engine better, new execution tier to make wizard faster. If you implement java model on top of Wasm GC, space overhead, Wasm has headers, Java has headers for objects. My GC language has headers too, so now there are 3 layers of headers, 6 words of header for every object. The Java object has 2 words of headers, do we need a mechanism in Wasm GC (past MVP), where user level language can combine some meta information with Wasm engine in the engines, and also can I combine Wasm headers with implementing language headers.

JK: the idea to share the has code between running module and engine is an idea that came up before, can make sense as a post-mvp follow-up proposal. It affects only 1 field, but it should be a straightforward field to allow deduplication. In V8, we came upon this for map usage. If we want to use wasm struct/array as keys in JS weakmaps, then we need a hash code. If that module come from Java, then we also need hash code to support Java semantics.

BT: several of my techniques are exploiting 64bit machine to make header word smaller. If limited Wasm types, put them in a table, use only 20 bits, now you have 44 bits for other things. It is reasonable for engine to pack 1 32-bit user level field into header, probably not more than that. If we want to shrink things down, need actual language mechanism.

TL: is hash code something user visible in JS? In Java every object comes with identity hash code fixed for lifetime and not changed.

RT: JS or Java

TL: JS

JK: completely internal

BT: JS has weak hashmap

AR: objects in JS can also be keys in strong map

BT: map actually keeps them alive. In Java, without moving gc, use address of object. With moving GC, you have bits in header indicating if it has been moved or not moved, if moved the hash code hiding somewhere. Ultimately you need some space somewhere.

ZB: In Kotlin, it is important to have cheap access or calls for nullable refs, and any other language with nullable types.

TL: JK talked a lot about cost, what goes into a call ref, is it on the roadmap to rework that and make it faster? Would that have to be spurred by empirical data?

JK: everything needs to be supported by data. Unaware of specific plans to make things faster. Anything is fair game if we have data indicating it is a bottleneck. Too many possibilities to look at.

TL: is there low hanging fruit there? Or tough nut to crack?

JK: think it is a tough nut to crack. If we know fun call is high overhead we will look at inlining. Hard to do with vtables. No specific ideas of quick things we can do to improve call ref performance. If it turns out to be important, we will look at it.

ZB: if we want to support OO languages like Java… e.g. nullable refs could be reduced if we have a way to freeze object after creation. We need to have nullable fields during creation, during calling constructor, but after that we can freeze the object and after that some of the fields could be treated as non-nullable

TL: freezing after creation has come up on GitHub, seems like we should continue those discussions, seems common and important

RT: we have been talking about type canon. There might be an issue that canonicalization costs us various properties, was going to talk about encapsulation, because you are not implementing canon, you have encapsulation for free. When you implement that, you lose encapsulation. For debugging you have names, different rtts for the same struct within module or cross module, when you canonicalize that goes away. Metadata in rtt, canon doesn’t work with metadata. For JS interop, when you ship an object to JS land, has data for how to interpret that in JS. Canon will break all those use cases.

TL: a note on debugging, in C++ land that just having source maps or original variable names have been insufficient for having a good debugging experience. No matter what happens, we want to do a bunch of work on debugging, probably a whole bunch of metadata, something like DWARF, maybe reuse Wasm DWARF or something else. So much extra layer and information for debugging. Debugging considerations on low level semantics of language probably won’t matter that much.














"
main/2023/CG-06-20.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 20th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: June 20th, 4pm-5pm UTC (June 20th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Flexible vectors update and possible phase 2 poll, [slides](main/2023/presentations/2023-06-20-Penzin_Flexible-vectors.pdf) [Petr Penzin, 30 mins]
    1. Source Phase Imports ESM Integration Update [slides](https://docs.google.com/presentation/d/1hDFL8y7fmrXY9CdYgDbZDyIsY5C65mtCT7F5M9hgGZc/edit?usp=sharing)
1. Closure

## Agenda items for future meetings

 1. Profiles discussion [30 mins] (Not enough time at the meeting for this discussion, moved to 09/26/2023.)

### Schedule constraints

*None*

## Meeting Notes

### Attendees

* Petr Penzin
* Jeff Charles
* Derek Schuff
* Deepti Gandluri
* Conrad Watt
* Chris Woods
* Alon Zakai
* Zalim Bashorov
* Yury Delendik
* Yuri Iozzelli
* Paolo Severini
* Mingqiu Sun
* Luke Wagner
* Alex Crichton
* Ryan Hunt
* Daniel Hillerström
* Andreas Rossberg
* Paolo Severini
* Andrew Brown
* Dan Philips 
* Bruce He
* Nick Ruff
* Brendan Dahl
* Ashley Nelson
* Guy Bedford
* Nick Fitzgerald
* Heejin Ahn
* Chris Woods
* Manos Koukoutos
* Emanuel Ziegler
* Sam Clegg
* Sean Jensen-Grey
* Jakob Kummerow
* Richard Winterton
* Sergey Rubanov

### Proposals and discussions

#### Flexible vectors update and possible phase 2 poll [Petr Penzin, 30 mins]

PP presenting [slides](main/2023/presentations/2023-06-20-Penzin_Flexible-vectors.pdf)

CW: would like to understand the platform dependent behaviors.  IIRC there’s a length operation, which would be nondeterministic based on the platform you’re running on?

PP: That’s right.. 

CW: I’ve heard from some that hope to migrate wasm modules between heterogeneous environments, but if you checked that property once, if you migrate to a different platform that would cause a problem?

PP: The intent is not to hardcode the length, but use it for loops, or generate code, if you end up in a different environment, you should still be able to run the same code

CW: you’d have to compile the code to be robust to that right? You could imagine checking it once and caching the result and then you don’t need to do that again.

PP: Good point, the expectation is that the code will be running in a robust manner, you do have to be mindful of that and not assume you have 128 bits, I have an example for having to check the length.. In reality you could materialize the length without using extra variables

I had an example in an old slice deck where you would check the lengths. You’d have to put them in a local or global.

CW: I guess the analogy is to relaxed SIMD. do we guarantee a fixed value, or leave open in the spec that it’s more variable than that?

PP: I actually don’t think its necessary to fix it, probably would work better that it wasn’t fixed, then it might be better 

CW: I think it becomes hard if you allow it to be that nondeterministic 

AR: can you remind me how loads and stores would work if you don’t know how large these things are?

PP: That’s the purpose of the length variable

AR: so a load is basically nondeterministic how much memory it accesses, or runs into a bounds check? It might depend on how large the read is?

PP: there is a realistic bounds on that depending on how big the SIMD register is, and will only happen when the SIMD register length runs out, its not expected to be the common case. We could cap this explicitly in the spec. 

AR: One thing conrad was getting at is code mobility, e.g. if i stored some values in memory and carry my process to another architecture, there’s no guarantee that i can read these value back, because the reads might mean something different?

PP: Not sure I understand why, if you do check lengths again, if you go in a different architecture, your length changes but you’re still reading the same data

CW: that suggests that you have to recheck the length and use a different codepath for different granularity? I would imagine most people would check the length at the start and maybe serve a different module as opposed to doing it dynamically.

PP: That wasn’t the intended use, but I can see how someone may use it that way. We don’t load a different module, but we don’t have a precedent for it

AR: even if i were super careful and checked and assume i have some safe points where I check the length again. How would I be able to react on that, if the vectors are already stored in memory with a certain length, and my architecture is a different length, how can I read them?

PP: We’re not storing a vector type in memory, we’re storing the memory that corresponds to the vector. If you’re storing 256 bytes. And if you have a different architecture then you need to load 4x4, or whatever the architecture provides, so its a bag of bytes

AR: that would mean that the load/store instructions you have aren’t useful in that case, you would always have to load individual values and reconstruct the vectors from scratch if you wanted that kind of mobility. (again a hypothetical)

CW: Are there people working on this? 

[PP showing example]
PP: This is an example from the original presentation, a vector value corresponds to a SIMD register. So you would load, the amount of bytes required to fill the operands of the operation, then perform the operation and get a value in a (potentially) different SIMD register, then store the same number of bytes. But if you have different lengths, you’d check that against previous operation, which is harder. If you have different lengths, then you are suspended and have a different architecture?

CW: so you'd have to remember the previous length of the store

PP: Why would you? You have a current index that you can pull from, increment in terms of the lane size, but don’t need sizes of chunks upfront. Write your loop in terms of the number of elements

DG: slightly different question: given how different codegen can be on different platforms, how do you expect the performance to scale? We had a higher bar for e.g. relaxed SIMD about experiments or performance estimates.

PP: The estimate is when we do work in converting SSE benchmarks to AVX2 benchmarks, that 1.5 - 2. Sort of obvious but YMMV depending on how good your 128 vs your 256 implementation is. In straightforward case where you are multiplying numbers, you should expect 2x speedup but those are straightforward and synthetic. In more complex cases numbers might be somewhat lower.

DG: we see performance loss at a few different layers e,.g. At compiling wasm. The entire set of operations is hard to support. With that baseline assumption of losing some for any kind of SIMD ,and now we’re talking about adding lane checks, and runtimes will have to do some extra work so I’m wondering what kind of guarantees we can offer.

PP: That’s the reason we’re doing it, the upper bound is 2x with 128->256, realistic gains are 1.4x etc. I think that’s what we should expect, 50%, we’re talking about performance here, so 50% is significant.

CW: does this proposal introduce any new fingerprinting signals? that was a concern with relaxed SIMD, e.g. with FMA support.

PP: Beyond that, no we don’t expect it to do nondeterministic ways, aside from the lengths.

CW: Do we expect that on the web the length will expose finger printing surfaces? What can you do with the length information? 

PP: it won’t vary a lot. Basically you have AVX and SSE on x86, 2 options. On ARM, SVE is coming. Generally those can be detected by timing operations. Also AVX2 is really widespread. The only processors that don’t support it are the low power cores. So just having AVX2 doesn’t tell you much. The presence of 256 bit doesn’t really tell you anything other than maybe the class of device such as a laptop

DG: A poll might be ok, for experiments. We need more data on which applications would use this what the performance gains might be. Very specific application performance, would be helpful for deciding whether to implement this in Chrome or not. I think as CW pointed out, we do have to do a little more intensive looking at fingerprinting services would be exposed, especially between different versions of Intel chipsets, ARM chipsets. What does that look like? Having looked at that, I could guess that this would be a significant change from where we are now.

TG: using wasm for sandboxing at UCSD with firefox, we’ve seen that SIMD performance is quite bad e.g. audio/video decoding etc. SIMD128 is just embarrassingly bad on common workloads, we really need something better. On fingerprinting, i’ve done some work on VMs,, can point you to some research. Hiding the architecture is impossible, i don’t think it should be significant consideration.

DG: The tradeoff we make is the performance we get for the information we’re going to expose. Especially for flexible vectors, I’m not certain we are able to perform the same optimizations across the board, vs the alternatives are introducing regular instruction sets that are able to map to hardware SIMD. Cutting out all the layers in-between has been the fastest way to this. I understand PP’s motivation, which is how many experiments are we doing for the future???

PP: integer ops generally is one of the targets to accelerate for this proposal. I don’t know about performance but that’s why we have a prototyping phase. So the questions we have, what applications ,fingerprinting, etc . just because we go to phase 2 doesn’t mean we’ll standardize.

CW: Phase 2 implies consensus around the direction and I’m not seeing that here because the alternative is we have specific instructions instead of going for the general thing.

PP: What about the vector size? 

CW: TBH I kind of agree with Tal that fingerprinting is a lost battle, but my main concern is the code migration story. With relaxed SIMD we at least can emulate the new instructions with existing ones.

PP you can still do that, and say that “my length is 128” and it goes back to the existing state.

AR: This way of doing SIMD only allows point wise operations? In the current SIMD proposals, there are instructions that are not pointwise operations, its not clear how they would be able to use this scheme of instructions. Is it right to assume that we can’t actually use those instructions with wider widths? 

PP: what do you mean by pointwise?

AR: Pointwise means both operands have the same number of lanes and it’s a per-lane operator.

PP: Yes but obviously the path out of there is the length is 128 multiple, so you can easily get to a point where you do a half or double. If you can do those things. There are libraries that do that, that’s doable. You can even define semantics within the existing set, because for example, you do ½ of the vector, then ½ gets unfilled or filled with 0s. That is a possibility. Things like expand. That’s on the table. Not completely freeform of course.

Poll

* SF: 1
* F: 3
* N: 20
* A: 1
* SA: 0

There’s not a clear consensus, we probably need some more discussion, motivation, collect some of the main concerns etc.


#### Profiles discussion [30 mins]
Due to lack of time, profiles is moved to a future meeting

#### Update on TC39 phase imports [ Guy Bedford ]

GB Presenting [TODO: link]

AR: What is the difference between attaching and linking for modules? 

GB: the record has a field for the environment which references the local bindings, and realm, it’s a little arbitrary but you’re getting a different module instance in different realms in JS

AR: IIUC, the main question is whether this change to the proto chain of wasm.module is breaking or not? IIRC we had a similar discussion wih the type reflection proposal which introduced a new class for wasm functions, which also changed the protochain there. I don’t think we found any compatibility issues with that, at least I haven’t heard of any. It seems most people depend on that.

GB: These changes happen surprisingly frequently in the Web IDL world, so we don’t have anything specific concerns about that, but we wanted to present an update here, and integrate this with the ESM modules proposal in the future. 

CW: one clarifying question. Does changing the prototype of webassembly.module have implications for posting modules across workers?

GB: Right, obviously because of that they don’t have the same instance. There is no state associated with the abstract module that would need to participate in the serialization process, yes.

CW: could that change if we had compile-time imports?

AR: I wouldn’t know how we use compile time imports with this, seems orthogonal I think

RH: I can’t give a great answer right now, I’ll think about that

AR: One other question, this is somehow abstracted away, what happens if you apply this to JS imports? 

GB: this is kind of the amazing thing, that we’ve been able to build consensus that this is useful for JS. there are folks in TC39 who would like to see this so it gives us ability to follow up on the JS side. There is a risk in shipping a feature that doesn’t have full JS integration yet. So you’d get an import error if you tried to use this at first and we’re figuring out exactly how this will work on the JS side.

PP: Does it affect the reinstantiation in any way. There was a complaint that you have to recompile the module from bytes if you want to drop the memory and ???

GB: this is for webassembly.module? We are mostly focused on the ergonomic/ecosystem/tooling benefits here rather than performance. If there’s enough usage then the browsers will know more.

ZB [chat]: Probably ""Import Attributes"" could help integrate it with compile time imports https://github.com/tc39/proposal-import-attributes

AR [chat]: @Zalim, yes, that sounds plausible

### Closure
"
main/2024/CG-04-23.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 23rd video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: April 23rd, 16:00-17:00 UTC (09:00-10:00 PDT, 18:00-19:00 CEST)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Announcement: registration for June CG meeting at CMU is live: https://forms.gle/ahNN9e7Nwc8W9PtQ7
    1. [custom-page-sizes proposal](https://github.com/WebAssembly/custom-page-sizes)  (Nick Fitzgerald, 30 minutes)
       * update
       * discussion of [exact constraints for valid page sizes](https://github.com/WebAssembly/custom-page-sizes/issues/2)
       * vote for [phase 2](https://github.com/WebAssembly/meetings/blob/main/process/phases.md#2-feature-description-available-community--working-group)
    1. poll: [add table64 instructions to memory64 proposal](https://github.com/WebAssembly/memory64/issues/46#issuecomment-1957860383) (Sam Clegg / Conrad Watt, 10 minutes)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

#### Announcement: registration for June CG meeting at CMU is live: https://forms.gle/ahNN9e7Nwc8W9PtQ7

TL: CMU, Pittsburgh, registration deadline May 24th

BT: If you’re interested in giving a talk at research day email Ben 

#### [custom-page-sizes proposal](https://github.com/WebAssembly/custom-page-sizes)  (Nick Fitzgerald, 30 minutes)

NF Presenting

Slides: custom-page-sizes update

CW: when we have the “shared” annotation, where does that go in the text format relative to the page size?

NF: Haven’t done these changes on top of the threads proposal, can add an issue to the repository

CW: yeah it shouldn’t be hard to work out, I just realized we hadn’t thought about it yet.

Toolchain integration slide:
CW: when you say “linking modules here” what kind of linking do you mean?

NF: Not talking about Wasm instantiating linking - so toolchain linking and not runtime linking. Linking multiple .o files 

KW: from the consumer, is the demand for finer granularity for growing memory, or from the producer is the desire for memories that are smaller than one page?

NH: It’s mostly smaller than one page, it is also smaller than two pages and larger than one page

KW: Is there a desire for being able to grow those memories?

NH: Haven’t seen a lot of interest in growing. Maybe you’re getting at an alternative design for a fixed size memory, working with the existing framework for the spec and implementations we have now, it would be easier to tweak the existing rules instead of adding 

KW: I wasn’t sure. It seems form the consumer perspective that some use of memory control might be adequate

NH: what kind of use were you thinking?


KW: if you have one page where only part of it could be read or written, you could use that

BV: this doesn’t seem like it would help much with embedded systems, which is what this proposal is designed to target

PP: []

NH: []

DG: runtimes usually try to reserve the max up front if they can, to try to avoid moving. But it’s not the best fit for embedded, trying to fit based on available resources.

KW: allowing the max size in byte or small page size units seems like it might be easier than trying to change the whole page size.

PP: also what is the chance that someone who wants less than one page would want 64 bit pointers?

TT: What I’ve got from the discussions is can we shrink the RAM if we need to? That was the original motivation of it - how do we not use 64-bit RAM? Is it possible to keep it orthogonal? If you don’t have the possibility of shrinking the RAM, otherwise the discussion points here seem orthogonal 

CW: i think there’s a question of, if we weren’t pursuing this at all, an adjust doing memory protection, would we want a feature where we’d declare some subset of the memory not readable/writable, would we want this kind of feature too?

KW: What about a byte granularity max? 

CW: I think it kind of ends up being the same.

BT (chat): +1 for the composability argument of memory control and custom page sizes

NF: I also want to point out that as far as I know, the memory control proposal does not make things inaccessible, it just zeroes them out. It maintains read/write access to the discarded memory. That won't be usable to implement small memories.

BV: yeah that’s the discard component of memory control. I think a custom page size composes well with the memory features. I don’t see a lot of conflict there, and I also don’t see many use cases for that in the embedded case

KW(in chat): From my point of view, it does seem simpler for the consumer and toolchains if there's simply a static ""byte-granularity max"" on memories vs. if custom page sizes have to be plumbed through the object format and supported by every runtime (especially through memory.grow, page sizes less than the platform page size, etc.).

NH: Moving onto discussion

JK (chat) is there any use case for byte-granularity memory size control? What if the page size choice was ""either exactly 64KiB or exactly 1KiB""?

CW: In favor of option 2 as the most conservative option, that can be extended in the future. If it turns out there’s an embedded runtime that really needs specific page sizes, we can vote on that when we need

FM(chat): +1 for conrad's perspective.
Also, +1 for simply specifying max memory size in bytes.

DS: I Like that option as well - how would toolchains choose between different page sizes, and different users + applications would make different choices even for the same use case, and we have to deal with them. Having just a defined option would make things simpler

BT: Generality unlocks usecases we haven’t thought of it yet - it may not be easy to do in toolchains, but not all toolchains are the same. They may not have a narrow hardware in mind, there are x86 platforms with 4k pages upfront.
Also engine work: implementing the general thing is more work up front but even the lightweight spec process means more work in engines.

BV: PArticular difficulty with arbitrary page sizes are lower than the platform page sizes that how do we support them? 1 is a special case where you can decide not to do virtual memory tricks, but more than that, what should engines do?

NF: FWIW, that's what I intended to do with wasmtime. We support running without virtual memory guard pages, even when we can. For most page sizes, we would just fall back to that.

BT: that’s what I expected, that the implementation burden for arbitrary page sizes: below some arbitrary size, you just don’t use bounds checks anymore

CW: That’s one of the scenarios im worried about, where the engine uses the smallest page size for doing virtual memory tricks, will lead to mid sized pages not being able to optimize, this will lead to a mudddled ecosystem

BV(chat): +1 to the concern of unclear performance

TL: I agree that option 2 makes it clear: you can be small or fast

NF: given the way the discussion is going, we should probably move forward with option (2), we don’t really seem to have consensus for option1

CW: I’m In favor of arranging of the spec so that we’re able to make minimal edits when adding custom page sizes

NF: yeah expect it won’t need much additional engineering work for runtimes either at that point. It’s more of an eco

JK: Is there any use case for bytewise control over the memory size? Don't want to check for bounds in the middle of an i32 load. If the minimum size were the size of a v128, that would be convenient.

NH: There was some discussion about that before, we can make the minimum page size the largest load or store page size. There’s no guarantee that it would stay that way of course, if we have flexible vectors or something.

JK: so make the minimum size 1KB, does that block any of the use cases?

TT: From my point of view, going down to 1 doesn’t make sense, i was thinking of 1k, 4k, 16k as a good stage, not to have an arbitrary number of log2, just have customizable settings that you can choose from that you can then make reasonable choices about performance

CW: I think if we had, say, 1k, 4k, 16k, i would still have most of the same concerns about unclear performance since we’d have systems that might make different decisions about performance at the intermediate sizes.

NF: What does it actually get us in terms of simplifying engine implementations? My understanding is that then you have to do a full bounds check if you can’t do virtual memory tricks

As soon as you can't rely on virtual memory at all, you have to do a full bounds check that includes the size of the access, so it doesn't matter in practice whether the bounds are aligned.

JK: it does matter. If you have a decently aligned memory size you can check the address as being less than the limit, whereas if it could end at any byte then you have to add the size and then check the bounds, its another check on every load.

NH: Doesn’t that rely on having guard pages though? 

CW: Are you saying that you have to do a second more precise check?

JK: no, if your memory can end anywhere you have to do addition arithmetic then you have to check the end of the access as opposed to the start

TL: but not all accesses are aligned, you could still have i32 loads fall off the end.

CW: You could even have this today, where you can have an i64 load at the end of the page

JK: you’re right, for unaligned loads that problem exists already.

NF: if you have at least one guard page, you can use that and rely on that for overflow. But if you don’t you still have to do the full check whether it’s 1 byte or 1k. So in that case I’d prefer 1, since what benefit is there from the coarser granularity there.

CW: I think maybe calling it a ""one-byte page size"" sounds silly. I've been thinking about it like just turning on explicit bounds checks.

NH: It’s more of a how do we fit into the existing spec

DG: a question about that: it’s probably true of wasmtime would want this to fit well into the existing framework. Is that also true of other engines that are targeting embedded systems? 

NF: I can't really speak for other runtimes

KW(chat): From my point of view, it does seem simpler for the consumer and toolchains if there's simply a static ""byte-granularity max"" on memories vs. if custom page sizes have to be plumbed through the object format and supported by every runtime (especially through memory.grow, page sizes less than the platform page size, etc.).

DG: curious if there are cases where we want the higher customizability. I was wondering if there was more that we should to in terms of outreach to find those.

KW(chat): What is the right procedural mechanism to discuss the merits of ""1-byte page sizes"" vs. ""1-byte-granularity limits""? Another proposal? Right now?

CW: there are at least 2 asking for more discussion about whether we should think of 1 byte pages vs granularity limits. Should we still go to phase 2 with this unresolved?

TL: relative to the size of the proposal it seems like a big enough deal that maybe we should resolve it before going to phase 2. I wouldn’t want it to drag it out, maybe we could timebox it to a couple of weeks or something.

NH: FWIW, it comes down to one line of code in the spec + validator, the biggest change is making the page size anything other than the constant size it is right now. The question is important, but it’s not the

DS: We should agree on the mechanism of the proposal before the vote to phase 2 - it seems like we are making progress so I’ll agree with Thomas that we can wait for a couple of weeks

JK: one other point to raise: maybe a way to get the concerns of different engines and use cases accounted for, is spec it more flexibly: maybe a way to allow the size to be rounded up somehow. This would make it more agreeable if we could keep doing what we’re doing. And guard pages should be orthogonal, it could be an explicit mechanism rather than piggybacking on weird memory sizes that make guard pages impossible.

FM(chat): is there any use case for byte-granularity memory size control? What if the page size choice was ""either exactly 64KiB or exactly 1KiB""?

NH: I have no qualms with about some kind of hinting proposal - it is a fact of the way things work. That if you have a page size, wa

Regarding rounding up, that would require introducing new instructions

KW: The question is whether OOB access would be a deterministic trap. If I can hint that I only use the first N bytes of memory and after that it might or might not be a trap, then that would allow all the desired implementation strategies.

CW: I’d be pretty uncomfortable sneaking this kind of nondeterminism into the proposal.

NF: in general we do try to minimize nondeterminsm, and then … []

KW: Ok, I withdraw this remark.

DG: we are running short on time, we should work offline and schedule more time to discuss in a meeting

NF: can we do it in a month?



#### poll: [add table64 instructions to memory64 proposal](https://github.com/WebAssembly/memory64/issues/46#issuecomment-1957860383) (Sam Clegg / Conrad Watt, 10 minutes)


SC: we took a straw poll on GH, it seems worth doing a real poll in this meeting

Poll: Inclusion of table64 in the memory64 proposal

SF: 2
F: 14
N: 9
A: 0
SA: 0

CW: Ryan gave a pretty good comment in the linked issue on how we should support table64 

2 questions; the first was should table.grow return i32 or i64; I think i64 to match what we do for memory.
The second was JS api access of 64 bit tables - 64 bit ints or implementation limit 53 bit ints?
I think we should also do whatever we do for 64 bit memory JS api

"
gc/2023/GC-05-16.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 16 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: May 16, 4pm-5pm UTC (May 16, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Status checks
        1. Spec documents
    1. Presentation: TypeScript on WasmGC (Jun Xu, 40 minutes)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Jérôme Vouillon
- Conrad Watt
- Jun Xu
- Ashley Nelson
- Alon Zakai
- Ryan Hunt
- Bruce He
- Emanuel Ziegler
- Jakob Kummerow
- Ben Titzer
- Nick Fitzgerald
- Adam Klein
- Andreas Rossberg
- Petr Penzin
- Sergey Rubanov
- Zalim Bashorov
- Igor Iakovlev

### Status checks

TL: I did a PR adding the bulk_array instructions to the MVP doc and I saw some movement on Conrad’s PR adding to the spec interpreter as well. AR, I know you’ve been hard at work writing the formal spec, great to see movement there. Anyone else have any status they want to share? Ryan, how’s the FF impl?

RH: Quite a bit of perf work this half, also some of the final features we missed in our first impl pass. So we have i31 wrapped up, should be landing soon. I think just a couple random edge cases, we don’t handle element segments correctly, maybe something else small. Hoping to finish this soon, and then some performance work. Should be fully standards compliant pretty soon.

### Presentation: TypeScript on WasmGC (Jun Xu, 40 minutes)

JX prexenting [slides](presentations/2023-05-16-jun-typescript.pdf)

AR: In what sense are you lowering to nominal types? Because the Wasm types aren’t nominal either.

JX: In the compiler we check to make sure two different types with the same structure cannot be assigned to each other.

AR: But what about dynamic typing? I guess there’s no need to go too deep into it here, but right now you’re talking only about the static type system?

JX: Right, the static type system is nominal.

AR: Question about Any. In TypeScript it’s not a top type, it’s supposed to be compatible in both directions. How can this work when you have two different representations of static and dynamic objects?

JX: Static and dynamic world are absolutely separate. In this case, how to create and manage the basic structure of the dynamic objects. Maybe after the next page, you can see a bridge between the dynamic and static world.

BT: One idea is to have a table of func refs of the right types then use an index in the table to get a property or interface?. So, effectively you need an interface dispatch, right? So you need to do sa dynamic search, and you can’t use a struct for that, you have to use an array of some kind if using GC memory You can also use a table for that, so the list would just be the index of functions into that table?

JX: When we access the field of an interface, we need to access it through the field name rather than a static calculated index.

BT: So you have two dynamic lookups, that’s the issue.

JX: We store the name information in the runtime representation.

TL: Is this a nonstandard instruction you’re using or you’re emulating it with a function?

JX: We extend this code to support this feature and we use a function to emulate this behavior and it works.

TL: Have you prototyped this opcode in any implementation and seen the performance benefits?

JX: No, we use the native APIs to emulate this behavior but we haven’t measured the performance. We think this is supported for some limited dynamic typing semantics. We know wasmGC isn’t created for dynamic typing languages. It would be more efficient in their development. We think this indirect function call/get would have lower performance but wouldn’t influence the original opcode. 

TL: It would obviously be great for codesize to have this struct.get_indirect opcode because you wouldn't have to generate these dynamic getter  functions for every field of the struct, but it would be interesting to see if there are any performance benefits to

JX: Great suggestion.

BT: If you want to take a struct reference and turn it into the Any type, you need to use the extern.externalize instruction? So you rely on the engine to do the externalization?

JX: Yes, we do rely on the engine or host environment to do externalization.

CW: I imagine for a lot of users of TS, the alternative is to compile to JS, which will be pretty fast. Is the intention to compete with compiling to JS, or just to use TS in an environment where JS isn’t available?

JX: Currently we want to bring more application development languages to Wasm. We don’t expect this approach will be much faster than JS.

CW: Who do you imagine will use this as this first choice?

JX: Developers for IoT devices, an app-developer friendly language based on WebAssembly may help build a larger ecosystem for IoT world. In the browser, WebAssembly can be some part of the project, the part more related to UI can be still compiled to JavaScript, while other parts more related to computation can be compiled to WebAssembly, and the developer don't need to write two languages for these two parts. This is more flexible than the current solution.

AR: You mentioned gradual typing here but the approach you are using is something akin to coercive subtyping and that’s difficult. You definitely need sound subtyping to make it work. But for gradual typing you need to be even more flexible, and I’m not sure how that would work with two competing representations. With gradual typing I should be able to pass an array of C as an array of Any and vice versa. And that could be a mutable array, so you can’t just convert an array to fit the right implementation that you need. You have to keep it in this original presentation, so I’m not sure how you would support that in this approach.

JX: I mentioned the gradual type here, but just want to explain the language. For the static languages, they are trying to support dynamic language features and for dynamic languages, javascript/typescript we are trying to bring more type information to their code. So for gradual typing, wasm might be a good package to bring benefits to these kinds of languages. That does not mean we are going to support all the gradual typing semantics in the languages.

AR: Understood, but how do you even support the most basic gradual semantics with this approach? In your language, can you assign an array of C to an array of Any?

JX: Not sure what the C to array means.

AR: So C is some static class and you can have an array of C, right? And with basic gradual typing you should be able to assign that array to a variable of array of type Any. In that case, you cannot wrap the individual objects, it would be expensive and in fact, violate the identity of the objects because this is a mutable array so you can observe the members changing. How do you support that?

NF (chat): Array<C> my_concrete_array = ...; Array<Any> my_any_array = my_concrete_array; This, right?

JX: Good question, I think our POC hasn’t covered this feature. But in our design, we need to static C into dynamic object. So this would bridge the immutable semantics of the array. For the performance impact, we think that if the director uses Any, then they should pay for the performance impact.

BT: Along the lines of AR’s question, this arises because you’re using externref and you need to have a coercion there, but it would also arise if you had an array of Ints too. Is that supported? Array of Ints can be assigned to Array of Any.

JX: … missed response ...

AR: How can you have any form of gradual typing if you don’t have uniform representation? You are converting between dynamic and static objects

CW: Am I interpreting your ..making everything uniform by putting a box around everything?

JX: We are starting from the static type and at the start we want to represent everything as static typing and then we find that adding an interface results in a special design. Proposed opcode? There may be some gaps between static type and dynamic type.

TL: If I understand correctly, you are mostly interested in supporting static type non-gradual subset of the language and because Any does exist and people use it, you also have this escape hatch for representing Any values but it’s not necessarily a goal to perfectly implement all of the original gradual type semantics of typescript, right?

JX: Yeah, we are not experts in type systems or program languages, we are supporting the features that are required by engineering.

TL: Have you looked at existing typescript code and validated how much is compatible with the type system features you support and how much uses the gradual typing features you don’t support?

JX: Currently, no statistics, just started this POC recently. We just support basic features. To get any, we can define properties and pass these to any functions and then access these properties. For some apps, this is good. Not a fully supported language feature.

JX: Key idea of this presentation is to introduce this new op code struct.get/set_indirect, we think it would be useful for many languages. 

CW: To implement the dynamic check, if the runtime didn’t want to carry around information about the fields, you’d have to use the tag on the object and effectively work out from there how the bounds check needs to happen. Engine folks, does that sound right?

JX: In this table, we would have an additional column to store runtime type information and we can use that information to do that check.

CW: I was referring to the actual wasm engine implementation, but presumably if you pass the struct ref, the dynamic representation of the struct ref needs to tell whether the index is in bounds at runtime and if the field matches the annotation. And reconstituting the field 

JX: The runtime type information is bound to the struct type reference and when we pass the struct ref to that opcode, the runtime can check.

CW: I wouldn’t expect implementations to have all that machinery setup. Maybe the tags are simpler now because you only need enough for the downcasts. I’ll stop speculating.

JX: Because we need to do the downcasts for this, we also need the runtime checking, so we didn’t require additional environment in the runtime.

RH: In SM, we have a link to the full type information from the RTT. We need that for tracing for GC anyway. If we didn’t have tracing, we could perhaps omit it. Theoretically we could load the type information, index into a field, then compare the type.

BT: There would need to be a subtype check there, too, not just an identity check.

RH: Good point

PP: Bottom line is that we require to be implemented

CW: Depends on the implementation strategy of the engine for downcasts.

PP: TL, know anything about it in v8?

TL: Jakob?

JK: Similar to what Ryan has described, we do have the information but the implementation is not optimized for doing fast access, so that would be pretty slow for getting the field offset. Orthogonal, the type issue on the result, when there are reference and non-reference types in there, I’m not sure how we would do that at all. Our existing subtyping expects all ref types. I think if I had to implement a system like this, I would take a very hard look at something based on virtual vTables you can auto-generate that you can generate from the interface information that the compiler sees. Accessors in the vTable to access the fields. My initial reaction.

TL: Was that describing how you would implement it in the engines or how you would fulfill the functionality in userspace.

JK: TypeScript to Wasm compiler.

RH: You’d need performance data to see why to implement it and what it solves. How much performance work to get it to an acceptable level. I could have a built-in that groks the type information, but it would be very slow. Making it fast would be a considerable amount of work, would need to know if its worth it.

JX: Need performance data for the engines to support this implementation?

RH: That would be one thing

CW: Presumably if you are doing the faster for the user code to generate the separate getters and setters, it would probably be faster, though a little annoying. 

RH: I would guess it would be in that case. but I’m sure we could put the type information in that shape so it would be really fast. Right now it’s not, so we’d need a reason to do the work like that. There might be extra metadata costs too.

AR: This is a form of reflection right? It’s about putting reflection into core wasm. As you might guess, I’m not a big fan of that idea, it seems to be something that should be handled at a higher level than the basic asm instruction set.

JX: I’ll check our implementation to see if we are adding performance impact for supporting this. In our experiments, we didn’t change any runtime type information.

CW: What’s the implementation you are extending, Intel interpreter or another one?

JX: WAMR. Wasm micro runtime.

BT: Implementation of wasmGC in WAMR?

JX: Yes, we are developing it in a separate branch.

BT: What garbage collector are you using underneath?

JX: It is a mark and sweep collector. Currently tested on the WAMR engine.

JX (chat): https://github.com/bytecodealliance/wasm-micro-runtime/tree/dev/gc_refactor

PP: Jun, are you doing this as part of the Bytecode alliance SIG? If the SIG is public, you can also share a link.

JX: Not sure about this

PP: Okay, because the Bytecode alliance has initiatives along the same lines.
"
simd/2022/SIMD-10-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 14th video call of WebAssembly's SIMD Subgroup

- **Dates**: 2022-10-14
- **Times**:
    - 4pm-5pm UTC (9am-10am PDT)
- **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this [form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking
1. Adoption of the agenda
1. Proposals and discussions
    1. Formalizing non-determinism in relaxed SIMD 
1. Closure

## Meeting notes

### Attendees

- Andrew Brown
- Anton Kirilov
- Arseny Kapoulkine
- Conrad Watt
- Deepti Gandluri
- Johnnie Birch
- Justin Michaud
- Marat Dukhan
- Nicholas Frechette
- Petr Penzin
- Richard Winterton
- Ryan Hunt
- Zhi An Ng


### Formalizing non-determinism in relaxed SIMD

MD (about dot products and fma):

AK: for other operations we don’t have the same use case when we can test edge cases like this

MD: there is lane select and others, other can be used this way too

CW: we want to give guarantees about what programs can rely on

DG: Areseny, you mention engine can pick FMA vs two ops. If one can detect single fma, they can get it, but it would be slower.

AK: yes, there are classes of algos, where you can use either single or double, and others when you need one or the other. We don’t want people replacing qfma with fma unless they understand the cost.

CW: wrt to your recent post, for programs that want to take mul ad to replace with qfma, do they rely error state within tolerance, or result is exactly repeatable when doing calculation twice?

AK: it depends, some cases where it doesn't matter, some cases where the paths in the program differs. It is hard to know. Large class of C programs, GCC -O3 can occasionally lower a*b+c to fma. Large class of programs compiled from C to assembly with this setting, and it works. If we have set non-det for qfma, it is not end of the world. Not sure if this is a better world than list-non-determinism. What are we gaining from set non-det, while a lot of implementations will be list non-determinism, we are losing some valuable properties, and it is worth it? Every time i need to do a feature gate, it's a major pain, as an application developer on top of Wasm, won't use any of this tricks, maybe not worth it, gets complicated fast.

MD: very hard to do, not the target use case for this proposal. Looking at which instructions you can test for behavior and specialize, pretty much of all them.

AK: if there is a use case for qfma, support it as a principle, might as well support for other instructions?

CW: main benefit for set non-det, is keeping the spec editorially not perturbed by this proposal. Trying to work this out if it is possible.

DG: also minor benefit to deterministic fma. There are cases in engine we assume list determinsm, that's something the spec allows, set-non-det gives engine more leeway. From engine perspective, if a less inform application dev uses this without any sort of checking, the only thing is checking is that their algo is slow, better than not working.

AK: there is a special question if we should have a separate FMA instruction. Haven't seen the lowering?

DG: will call out to c intrinsics

AK: there is a lowering to intrinsics, ignores all edge case inputs, can all to c element per element, will be slow. If we add this it should not be called FMA, call it precise FMA, has to be specific qualifier to indicate so.

PP: CW gave a presentation last time about care v.s. not care. This matters for FMA because of single v.s. double rounding. Important to test for corner cases. Second point is that from toolchain POV, having a don't care FMA can be either is beneficial then compilers don't have to worry if user really wanted a single or double rounding.

AK: that part is same between list and set. By default, the compiler will not automatically synthesize it. Assume -ffast-math, if targeting relaxed-simd, using mul+add, will then use qfma. This will be the same between set and list. Doesn't matter for compiler/toolchain whether the spec says list or set. The user needs to tell toolchain it doesn't care anyway.

PP: it's less concerning because there is a special instruction.

CW: practically reproducing bugs, what's in the spec doesn't matter, what matters is formal blanket, if the result is not something you expect, does the spec cover it?

AK: in overview we are saying we use set non-determinism

CW: this looks out of date

AK: if we have the list non det, the scope of this guarantee is ambiguous, has to work within the same module, does it work across different modules, what’s the formalism. Set guarantees you nothing.

CW: Writing the guarantee down formally is tough.

AK: what actually happens, for example web workers? same result? what is the actual scope?

CW: some mobile phones have different CPU cores, could it be FMA changes between low and core?

MD: behavior doesn't, performance does.

AK: weird bugs on Android versions where instructions not available on some cores, code migrated and it crashes

PP: super unlikely

MD: for practical purposes, all ARM devices have FMA

MD: if guarantee is single module, would it work for what you have in mind. Either compile time or runtime, everything that links together.

CW: has to be all modules using a single store, where all modules can see one another

AK: classic technique where you have a tiny detector module where you run, then pick a different wasm module to load based on that. This are in different stores?

CW: formally they are in the same store once they are loaded

MD: for detecting Wasm SIMD, this is done in JS, if you try to run Wasm SIMD that don't run it. That's different for Relaxed SIMD, you can test fo specific semantics within the binary itself.

PP: you can still can do it, you can run a small module that makes the checks. Can write modules with different semantics baked in, and load based on it.

MD: that's not guaranteed to work, and don't think we should try to make it work.

CW: they way we formalize list non det will allow that to work.

PP: if you depend on CPUID, you won't write code like that

PP: an example that has been brought up is a future runtime can that move code across arch and servers, caveat that it doesn't yet exist, there are people who want it. will set-non-det break stuff?

CW: set-non-det actually allows that, if we formalize list on-det, but allow stuff to migrate, it will break

DG: cannot confuse what spec allows v.s. what implementations do, treat them separately

CW: not hanging my hat for why set non-det is a good thing, based on the hypotheticals

AK: one option, change list-non-det to set-non-det, as part of that, add precise fma, no option of not adding itl. We get optimal implementation of various algos that require single rounding FMA, we get theoretical problems about not-det runs, invalidate some techniques that Marat talking about, for some instructions, you have no option to check instructions behavior. Other possibility is to keep list-non-det, results in problems in the spec, may restrict engine optimizations in some ways, still under this option may or may not add precise FMA. In that world. precise FMA feels less defendable.

CW: accurate summation.

MD: without list-non-det, can't test if FMA is fast

AK: test if qfma is rounding once, very likely that FMA is fast, no guarantees, but no guarantee that it is fast. But unlikely that single rounding is a slow FMA. Engines that runs on hardware that supports single rounded fma may choose to do mul+add on QFMA, maybe 1 cycle fast or 2 cycle faster, some imbalance there. An engine can ever return you a single rounded result is unlikely to implement it using a software fallback. If it is double rounded, something is wrong, fallback, if single rounded, likely precise FMA is good.

CW: will absolutely put a note about this in the spec, unless an Engine wants to trick

NC (chat): AMD Ryzen FMA has fast throughput but slow latency. Separate mul/add is generally better there if you care about latency.

AK: this might be why we want precise FMA regardless

MD: this is a reason to not go with set-non-det, will make it untestable, an engine can for each QFMA, detect if latency or throughput constraint, use FMA for some, or mul+add. If you try to test, it would have always use double rounding.

AK: say we spec gfma and precise with set, then we can end up with two classes of programs: on tests qfma, and the other might replace everything with qfma for speed.

CW: each set and list will have analogous failure more in both. If we spec set non-det, we can move to list non-det, that refines it if we get it wrong. If we spec list, we are stuck with it.

MD: in practice, have a lot of software depend on list-non-det.

AK: see a lot in C world, actual practical spec is stricter, it can break the world. This is almost optimal, we have to upgrade the spec in a sense.

MD: will prefer to have this guarantee right away

AK: there is a danger that there is a gap

PP: set-style is less strict of a specification

MD: worried about lack of formal guarantees for testing, if we don't guarantee that same inputs produce same outputs

PP: lke floats?

AK: there are some, programs rely on it

MD: set-non-det for NaNs, not user visible, no function in C to get the payload

AK: sign also

MD: NaN propagation, no standard function in C to get this non-det components, not visible for programmers, what we have here is user-visible effects

CW: not user-visible from a looser specification that fast math lets you do, but practically visible

AK: one reason to prefer list, if we can specific FMA with single round, performance cliff. The idea of list determinism, what is the closest we can get to full determinism without performance cliff. MVP SIMD was not doing this. Here, what is the strictest possible behavior that is feasible and useful. Impact of set-non-det in spec to user is minimal, impact in this proposal is more obvious, may be reasons to try to see how to make list works. Or something stricter?

CW: even stricter is correlation between instructions.

PP: in practice you get one result from a particular platform, you can't emulate them efficiently

AK: edge cases where some specific cpus with this slow instruction

PP: understand the argument that with list-determinism, can see what results you will get, danger is that they write and test on one platform and not others

AK: say you have triplets of FP values, and sorting is on FMA of values. Comparator under set-non-det is wrong. Can have different results on for FMA on the same element, if you use QFMA for this predicate, you problem under set-non-det, invokes C++ undefined behavior. Under list non-det, you aren't getting the deterministic sort order on every arch, but it works, produces a correct sort order. Programs is more often sound than not.

PP: why is it undefined?

MD: if you use predicate to sort, it can produce different results on same element

AK: every program using fastmats, is set-non-det. Program switch fastmath don't care.

MD: more than fast math, same code in same function produces same results, inline in multiple places, actually in multiple places, multiple lowerings.

PP: also different flavors of fast math

AK: not end of the world if we do set non-det, I'm suggesting that there are simple programs where you use QFMA with set-non-det, and the breakage is not obvious from spec perspective, whether you observe it in practice.

PP: forgot about the different ways to lower in the same program. Fastmath is argument to use set non-det, though one can argue we can try to be stricter than the C compiler.

AK: for programs that use relaxed simd and simd in general, as a by product of running either fast math on a SIMD program with intrinsics, or by product of autovectorizing a c program, none of which pushes us to list or set. Requirements is that they need strict, or completely don't care.

PP: list non det falls between strict C compiler and fast math mode. realistically we can go all the way to set, that's what fast math does

CW: if talking about people hand writing instrinsics, talking about someone who knows what they are doing, are they facilitated in writing the program they want to.

AK: example in [thread](https://github.com/WebAssembly/relaxed-simd/issues/86#issuecomment-1279181850), small set of core libraries optimized with intrinsics, can have a matrix by vector multiply, implemented once and used widely, do we want to subject all users of this to non-det, which kind is appropriate? Beneficial to have stronger guarantees.

CW: morally, can be written using fastmath C, but chose to write intrinsics

MD: i have code that breaks with fastmath, but still can use qfma

AK: biggest worry if all implementation have list, programs are relying on this promise, compiler can be broken by optimizer, and engines introducing random behavior.

CW: the kind of hazards we are imagining are people hand writing, assumes a level of deliberateness.

AK: it is still a hazard, easy to miss. Like this sort example, if you do the same computation on the same data, have to be aware that it could produce different result. Increases the barrier. If QFMA produces set-non-det, we will likely see experts using intrinsics, end up writing programs per spec, not working properly, don't expect qfma returns different results. Not everyone who learns Wasm/Relaxed SIMD will write code that QFMA can result different results every time.

DG: should we take a poll?

ZN: maybe we should postpone Phase 4 vote

DG: we can still take a vote and present it to the group when we discuss it

CW: list vs set is not to delay next phase

AK: we should agree if we should add deterministic FMA.

DG: set det + det FMA or list det without det FMA.

ZN: we will set up a poll on Github
"
gc/2020/GC-10-20.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 20th video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: October 20th, 4pm-5pm UTC (October 20th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Observations about Types in Wasm (Andreas Rossberg) [1 hr]
1. Closure

## Meeting Notes

### Introduction of attendees

Thomas Lively
Wouter van Oortmerssen
Francis McCabe
Tim Steenvoorden
Ben Titzer
Slava Kuzmich
Conrad Watt
Zhi An Ng
Daniel Wirtz
Drew Youngwerth
Ben Smith
Rick Battagline
Emanuel Ziegler
Jakob Kummerow
Tobias Tebbi
Andreas Rossberg
Ross Tate
Zalim Bashorov
Manos Koukoutos
Adam Klein
Alexander Syrotenko
Daniel Ehrenberg
Ryan Hunt

### Discussion: Observations about Types in Wasm (Andreas Rossberg) [1 hr]

[slides](presentations/2020-10-20-rossberg-types.pdf)

TL: You mentioned that anyref corresponds to the top ref in the source language...

AR: not quite but similar concept u use in similar language, Java will use type Object

TL: In Java you wouldn’t literally have anyref there, you’d have something that maps to Object?

AR: if you compile Java… Java already does erasure in semantics, you don’t have this problem. Java added generics after the fact, JVM can’t deal with generics. Language is defined in a way that solves the problem for you. Not the case with C#. C# has fully reified generics, more accurate runtime type system.

TL: Would C# literally use anyref here or would it have its own type?

AR: C# would have a full generic here. It would understand generic definitions, and would instantiate generic definition at call site. Same thing happens at byte code in dotnet. It monomorphises at runtime at the JIT wrt to different instantiations of the generics, but not wrt to source, only wrt to low level representation. Something a bit in between, hard to mirror in Wasm, then you’ll need a two-level JIT. C# runtime have first JIT into Wasm, then JIT into actual native code. Which I think is something we eventually want to be able to do, but as a first step its not an impl approach, would be pretty courageous to try that.

RT: Thomas’s question is that you wouldn’t use anyref here… in the compilation of Wasm.

AR: for C# you would use type T here.

TL: in the compilation of C# to Wasm would we use anyref for the param

AR: Yeah, you probably would be using Object, that’s true.

RT: likely compile bar t here …

AR: actually won’t use Object. C# also allows you to instantiate with primitive types, e.g. int, might want to pass in i31ref for example.

RT: C# when you compile to wasm, would likely use partially monomorphized/partially not, where T becomes a runtime argument, specifying which type it is.

AR: sure but you’ll still need anyref to cover unboxed types, you probably want to be able to run with unboxed types

[back to slides]

FM: if you have a topology of dependencies between two modules, you might introduce additional connections that are in some sense parallel. Source-level graph could be viewed as a subgraph or abstracted graph of the actual graph. If you introduce additional dependencies but they happen to flow along the lines of existing source-level dependencies...

AR: Transitively?

FM: not necessarily, between A and B, at the source-level. At that level there’s just one dependency. At wasm level, you might have a set of dependencies.

AR: I’m only talking about dependencies on the module-granularity level

FM: i mean that yea

AR: Individual entities along the edges, that set can be extended. If you have additional things like metadata, etc. that’s ok. This is only talking about edges on the whole. The interface might include additional things, different things. But you don’t want additional edges between modules.

FM: factorizable. The wasm graph must be factorizable to the source level graph.

AR: Yes, maybe. I’m not sure what factorizable means there.

FM: divide the graph

AR: partition it

FM: not quite the same, it’s like difference between a set and an equivalence class

TL: You said that this end-to-end modularity has to hold for user modules, does that observation allow for a system module that all user modules have to depend on?

AR: this is for user modules, have some backup slides on that, can discuss it now. Most languages will also have some sort of runtime, that everybody depends on. Can think of that as an ambient module in the background of everything, since you compile to that language, it always exists, factor it out of the picture.

RT: For source-linking, languages like C# that link nominally, does that mean that wasm will link nominally too?

AR: nominally in what sense?

RT: A C# module refers to classes by name, when it is linked it will use matching names.

AR: that is something your runtime system has to figure out how to do. That is mostly orthogonal to what I’m talking about. How you resolve them and how you find them is separate problem.

[back to slides]

RT: You’re referring to structural in terms of the source language’s grammar, correct?

AR: In this case these are source types yes. To go back to the example, if I want to compile those to different modules without any form of collaboration, the two types have to compile to the same thing in Wasm.

RT: I already know how to solve all that, but let’s go on.

[back to slides]

[AR displaying observation 8]

RT: You mean with the language’s structure right?

AR: as soon as you have to use Wasm cast somewhere, the same has to apply to Wasm cast.

RT: YOu can canonicalize within the language’s grammar correct? Because you already said the language’s runtime can be used to resolve it.

AR: how would the language runtime canonicalize Wasm types in Wasm?

RT: It could canonicalize the RTT’s for you… [provides example]

AR: once you show me how you implement that in Wasm, and make that accessible through a Wasm module, I believe you.

RT: OK, can do.

[back to slides]

[On slide with class C<T> { … }]

BT: Suppose that in addition to this program you have a D<T> that had the same shape as C, where you replace Cs with Ds, if you replace them in Wasm then you would have the same structure. But then you can’t tell apart Ds from Cs.

AR: Yes, if you just used Wasm canonical rtts, then not sufficient to implement this. I’m not even talking about that, i’m only making the observation that whatever mechanism has to do dynamic canonicalization at some level. The only way I can see that being… generative nature such source level types piggy back on Wasm, you need to add 2 things. 1 is primitive to create a fresh rtt, generative version of rtt.canon, not enough to instantiate it, also have the kind of parameterization, need a parameterized generative rtts. You need to have an rtt version of nominal generics.

BT: I understand the polymorphic recursion requires you to canonicalize cross-modules, because otherwise you have to look it up. But you have to do it anyway because you have to find the “seed” RTT… which means a registry. It’s implicit in the runtime or the engine.

AR: it has to be somewhere, either in the engine or in the runtime system of the language you implement. Strictly speaking, you don’t have to canonicalize, you can do tree comparisons, you don’t want to do that, want to canonicalize types. Already what dotnet engine does.

[back to slides]

CW: The kind of language that would be useful for, would be a static language with strong modularity. Do you have an example of a language like that?

AR: not sure I understand what you mean from that question.

CW: FOr example w/ Ocaml, even though you have modules it compiles down to ...

AR: this is already true for C# as I showed, by using generics you have the same problem.

CW: Doesn’t that mean that it depends when you do it? [gives example]

AR: the problem is that you can’t implement that in Wasm.

CW: can’t implement that in current MVP...

AR: if you extended the proposal with parameterized rtt fresh instruction?

CW: Imagine we go to something like… version of Ross’s proposal that has a nominal type system, extend that with RTT.fresh instruction, where you can build it in the language instead of the runtime.

AR: not sure I know exactly what you mean, my observation is , short of putting Generics into Wasm one form or another, you won’t be able to solve this problem. Because the runtime type you have to create there is essentially a generic type. You only create the class once, but you have to be able to instantiate it in a structural way with different, arbitrary parameters.

RT: We built a system where the run-time-type for arrays is not parameterized, but it can reason about arrays without it. For C# at least.

AR: that would not implement source level casts then, right?

RT: it did.

CW: you need a tagged type and bounded quantification and all that right?

RT: The RTT just tells you it is an array, not what it is an array of. The actual array has a tag to tell you what it is. A field in the array tells you which type it is, the RTT isn’t parameterized.

AR: in that case you have implemented your runtime type system yourself. This is what I said earlier, the cast mechanism and the runtime type system,... the cast mechanism in Wasm is to workaround the Wasm type system, and not to implement source level cast.

RT: This guarantees actual safety properties, you need to do it to guarantee that you could put e.g. strings into an array. It’s necessary for the safety of the system.

AR: I understand, yea right, it’s not just the source level cast.

DE: Point on observation 9: are you saying it would be anti-modular to have a central runtime, and that it’s a requirement that a different system set of modules have different runtime modules?

AR: that’s what TL asked earlier. It's fine to have a per-language central module. That’s an ambient thing in the background, because you’re running on that language. Application is a user-defined notion. Requiring a central module for that mean that modularity of individual user modules won’t translate over to Wasm. Can’t use them independently.

DE: problem is about canonicalizing across language barriers?

AR: This is a bit more high-level problem in general, not introducing additional dependencies. One way you could do this is certain ways of encoding structural types with nominal types, which would break the module topology. There might be other ways that you could break that too.

FM: another way of doing that by exposing the type definition itself, which is kind of a hybrid of nominal and structural.

CW: This is the import/export idea that was talked about recently.

FM: you’re saying that you have a type, and it must be defined in a particular structural way, exposing the constructors in Ocaml. Hybrid of structural and nominal. You’re preserving the relationship between names and their definitions.

RT: Are we trying to say one program is compiled with Java 6, and another with Java 7, they’re both shipped to the website. Does this system have to figure out how to canonicalize? What’s the problem you’re trying to solve here?

AR: I’m trying to make modularity work. Not sure what you mean by different versions of JVM.

CW: The kind of modularity you’re talking about at the source level is not often maintained...

AR: what I specifically try to make that clear by saying...

CW: restriction many structurally typed languages put on linking object code, compatible with the central module that declares in nominal/structural way.

AR: [goes back to modular compilation slide] This can’t be done with a central user module.

CW: is dotnet structurally type?

AR: with respect to generics

CW: This is the same thing to do with runtime library or canonicalizing on the side...

AR: should have made a slide about this, this suggestion also comes up a number of times. The idea that you can canonicalize on the side, two fundamental problems. 1 don’t think you can express that in Wasm, 2, don’t think you can express even the interface. 3. You’re implementing structural types in user space. Everybody would have to do that. What’s the point of doing that, you’re pushing the problem aside, everyone has to do it themselves in half-broken way… with ill-defined semantics probably. No way to express your intent in Wasm types. You bolted on the side, if you even can, I don’t know how you can do that, even if you find a way, why would you. Why not put it into the language?

RT: As Ben pointed out, C and D can be structurally identical but need different RTTs

AR: not i’m talking about. Two generic type instantiations are identified by the structure of their arguments. Not about their definitions, about their arguments.

FM: I think the response to Ben is that C and D from Wasm POV are the same, but not Java. So Java would need the additional casts.

RT: then the infrastructure needs to exist anyway.

BT: the only thing you need to distinguish c and d is to have generative rtt. Orthogonal to type system is structural or nominal.

AR: wasm type is validation and code gen. If all you care about is mapping down to Wasm, then it’s only about the RTT, and nominal and generative semantics for those. But don't’ think just generative is enough, you also need to model parameterization.

TL: out of time. Helpful if people follow up with specific questions for specific parts of this topic, for next time/future meetings.

AR: some slides left, don’t know if i should present at some other point, we can talk about other things.

TL: great for follow-up discussion.
"
wasi/2019/WASI-05-02.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the May 2 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: May 2, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Overall introduction, overview of meetings and processes
    1. Proposed [High-Level Goals] for WASI
    1. Form a plan for organizing open ideas and suggestions.
        * Currently we have issues and ideas spread across a few different places:
           - https://github.com/WebAssembly/WASI/issues
           - https://github.com/CraneStation/wasmtime/issues?q=is%3Aissue+is%3Aopen+label%3AWASI
           - https://github.com/CraneStation/wasmtime/blob/master/docs/WASI-some-possible-changes.md
           - https://github.com/CraneStation/wasmtime/blob/master/docs/WASI-possible-future-features.md
        * In future meetings we can go through the issues and decide which
          milestones to assign them to.
    1. Subgroup activities
        * The MVP
           - Discuss what needs to be done for the MVP
           - Build documentation, testsuite, tools
        * WASI libc, in https://github.com/WebAssembly/reference-sysroot/pull/11
        * Discussion of future features
    1. How often should we have video-call meetings? When should we schedule them?
    1. Should we have an official adjunct meeting at the WebAssembly CG
       in-person meeting [in June](https://github.com/WebAssembly/meetings/blob/master/2019/CG-06.md)?
1. Closure

[High-Level Goals]: https://github.com/WebAssembly/WASI/blob/high-level-goals/docs/HighLevelGoals.md

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

2019-05-02 WebAssembly CG WASI Subgroup Video Meeting Notes

Agenda: https://github.com/WebAssembly/WASI/blob/main/meetings/2019/WASI-05-02.md

Attendees:

Dan Gohman
Paul Dworzanski
Christopher Serr
Birch Jr, Johnnie L
Eric Sink
Pat Hickey
Mingqiu Sun
Sam Clegg
Till Schneidereit
Luke Wagner
Ryan Levick
Yoshua Wuyts
Mark McCaskey
Alex Beregszaszi
Tyler McMullen
Derek Schuff
Mark Miller
Paul Schoenfelder
Dan Gebhardt
Martin Becze
Nathaniel McCallum
Lin Clark
Alex Crichton
Gus Caplan

Meeting notes:

Adoption of Agenda: Tyler McMullen seconds

Action items: None, first meeting!

Dan: Process is consensus-driven. We want to avoid coming down to a
vote. When there is disagreement we want to find out the reasons why. We
have a straw poll mechanism to help find that out.

Categorizing our issues:

Dan: Issues were initially filed on wasmtime issue tracker, now
they’re on the WASI issue tracker. Need a volunteer to summarize,
organize those issues, bring them onto one tracker.

Ryan Levick volunteers.

Dan: First thing to go through is go through and label everything. MVP

Dan: Which issues belong to the MVP, which belong to other milestones.

High level goals:

Dan: with the Wasm standard the first thing we wrote was a high
level goals document. Are there any objections or questions?
https://github.com/WebAssembly/WASI/blob/high-level-goals/docs/HighLevel
Goals.md

Dan: People have asked about threads and many other features that are
not mentioned in these goals. We’ll eventually come up with a design
roadmap to cover those sort of features.

Nathaniel McCallum: can you define MVP?

Dan: Smallest thing we can do and still have some value. Specifically:
IO streams, filesystems, randomness, clocks. There’s lots of work to
do on the details of these, test suites etc, but we have people using
this so far and finding it useful.

Dan: MVP does not include creating sockets. There are a lot of open
questions about how these will work wrt security, portability.

Nathaniel: if we’re defining MVP as what we first want to ship, this
may be too large. If its the goal for the body overall it may be too
small.

Dan: We could take out randomness and clocks if you think they don’t
belong.

Nathaniel: We don’t intend to ship filesystems at all in the first
version of our product. That set of APIs is pretty large. We should trim
down this list to do something small but do it very well.

Till: There are people here that consider filesystem support a bare
minimum to be useful. This may be a false dilemma, if we modularize the
spec to make filesystems and network io as different modules, we can
move them out of the subgroup and into the main body for standardization
when they are ready. If you need to focus on network rather than
filesystems, you can push on that module separately. Neither need to
block the other.

Nathaniel: My question isn’t what we seek to do as a working group
versus what MVP means in this context. This seems to be somewhere in
the middle. I’m ok with leaving it as it is but clarification is
useful Dan: As we get into details if we find filesystem is taking a
lot of time we can move it out of the MVP.

Nathaniel: I’m OK with this.

Paul S: what is WASI Core?

Dan: WASI Core is a set of modules, it should have a module for
filesystems, io streams, arguments and environment variables.

Dan: The idea of WASI Core isn’t an exhaustive list of primitives but
just enough to be useful for a subset of us.

Luke: Filesystems are have a lot of ways they can be sliced, io streams
to stdout are enough for some applications, so we don’t have to
provide every single part of the API at once.

Till: We need to specify how modules hang together on a fundamental
level, and then we may not even need MVP beyond that, since modules can
be moved to standardization whenever they are ready.

Derek Schuff: People here have different ideas of what they consider
minimum viable, so we should come up with the way modules work and
complete two of them that interoperate, and work out the fundamental
modularity problems like dependencies, then the details of what comes in
particular modules can come later.

Till: We should do enough that the module system is proven out, we
don’t need to define exactly what that means ahead of time

Nathaniel: This is a good definition of MVP. There doesn’t appear to
be anything about versioning in the high level goals

Dan: That is an oversight, versioning is an important thing to solve.
Versioning and/or feature detection.

Luke: There may be room for a new MVP document describing this ideas
about modules, at least two of them work.

Derek: We need to iterate on what we consider MVP right now, but that
doesn't mean we have the wrong high level goal.

Dan: Maybe the goals should say: we want to have an MVP and then defer
what that means. MVP is just for a moment in time, it doesn’t stick
around forever.

Dan: I’ll take action item to take out the details about what modules
from that document, and also to add versioning and feature detection.

Nathaniel: assent

Till: Is the scope of this subgroup exhausted once MVP is reached or is
it an ongoing activity to feed modules into the CG?

Nathaniel: in IETF we specify exactly what we want to accomplish as a
group and then disband it afterwards. I don't know if that is what W3C
asks us to do.

Dan: The parent WASM CG doesn’t have a concept of when we’re done.

Luke: The WG does have a charter that they renew periodically, but that
is a formalism. We should be like the CG and have a work stream and not
worry about the higher level details.

Derek: In C++ they have standing subgroups with an area of focus, WASI
is like that. We can argue in the CG about how we spec the WASI outputs

Till: So the goal is to move things out of this subgroup into the CG and
WG in the shape of individual proposals, where the initial proposal is
the core spec of how modules work with at least two modules, and then
individual modules go through their own proposal process after that.

Luke: Reaching the WG is a long way from where we are now. We are going
to radically change some of these APIs once certain WASM features become
widespread. We will iterate a lot

Dan: There are different levels of standards here. Does that make sense?
There is kind of an unbounded surface area for APIs and the vision for
this subgroup will be to standardize those. I can imagine a structure
with champions following the CG. Right now there is the core features
and in the future we could setup new champions for new features.

Dan: Moving on to other activities. We should define what the MVP is.
The very minimal thing we could do is something with just two modules.
Anything more than what WASI core is probably too much. How do we decide
what is in there right now that we should take out?

Nathaniel: Lets pick a small task and accomplish it

Derek: Do we want to define any kind of process for phases of APIs? We
want to get proposals out there and give people time to try it out. I
get the sense that we will have even more stakeholders than in the CG.
How do we track changes over time and put our stamp of approval on them.


Dan: I suggest we start by copying the CG process. Someone should
volunteer to start by copying the CG document and make proposed changes
to it? There are 5 phases. I think this is roughly what we want to
follow It might be too web focuses.

Derek: I don’t mind taking that on.

Eric: The thing about MVP is different perspectives about what is M and
what is V. How far apart are we? Its helpful to envision the data points
of the M and V axis. Somebody said “no need to filesystems” someone
else said they are important for a lot of uses. Just one example. We
maybe want list other cases and cather before we judge and refine.

Til: Do we even need to decide on the set of functionality. If we do
our job right on the fundamental module system then a lot of the actual
development of the individual modules could happen in parallel. They
don’t need to block each other. Obviously the overarching goal is
consistency between modules but independent development might work.

Nathanial: The module are really our MVP. Module + versions / feature
detection. But I do think polling would be good to decide what to focus
on first.

Dan: Not so much who wants what, but who is willing to shut up do the
work and get things done. My main worry with filesystem is that once we
start looking at portability seriously that we might want to move it out
of the MVP. But if people really want to move it forward it would still
make sense. Different to minimal, more about the timeline.

Nathaniel: Why don’t we define MVP and modules plus versioning. And
move to a time-based process where we release say, every 6 months.

Eric: We are challenging the definition of Viable. I love the idea of
modules and feature definition but I don't think that is viable. We can
define modules with defining any of them.

Nathanial: We did mention having 2 modules and minimum. And having
reserved names as part of them module system. Even if we don’t ship
a whole bunch of modules it doesn’t mean that there aren’t modules
yet.

Derek: Users are going to want the ability to define their own APIs so
even a module system is viable even without any “approved” modules.

Til: Is viable the right terminology?

Luke: Perhaps MVP is not right.

Dan: Should we start by defining a module system and some minimal
modules, or should we try to have a few more features. Poll?

Jlbirch: What can’t we have both?

Dan: Initially I proposed a bunch of modules such as filesystems etc

Nathaniel: The idea of an MVP at least in standards language might carry
a bunch of meaning that we might not want. I quite like the idea that
the only thing you need to be standards compliant is the idea of modules
and namespaces

Eric: me too.

Luke: Related thing? Do we want the MVP terminology?

Nathaniel: Should we call it minimal implementation requirements?

Til: Is some ways is a minimum viable spec.

Dan: Should we start with the very first stage which includes modules,
namespacing.

Alex B: I’m coming from the blockchain space, looking at how to
integrate wasm into ethereum. At least the core WASI filesystem spec
doesn’t make sense for us right now. I was confused that the MVP
discussion presented no use cases. I hope to get out of wasi a process
for how to define modules (and versioning) and we will be able to define
modules relevant to the blockchain space.

Poll Results: SA: 16 A: 3 N: 2 DA: 0 SDA: 0

Dan: Should we have an official adjunct meeting at the CG meeting in
spain?

Pat: The few of us who have spoken previously discussed meeting the day
before the meeting starts.

Paul: I’m planning on being there and would like to be there.

Dan: I will take an action item to look into scheduling.

Dan: we should probably try to do it during the CG meeting.

Should we do an offline poll to schedule this?

Dan: Someone open an issue for scheduling in the wasi repo.

Final discussions:

Pat: Is this group going to be responsible for maintaining the sysroot
and the SDK that comes with it? I can still keep on doing the work if
needed.

Dan: My original idea was that it was going to be moved to this group.
It's becoming more clear it should live outside, but open to opinions
here.

Nathaniel: It might be handy for us to gather a list of people who are
involved in the standards process what they are working on and how they
are using it. The other thing that might be useful for MVP would be to
decide what does it take to standardize a module?

Dan: I don’t think this has been done before. I would appreciate
proposals.

Derek: The phase proposal is going to touch on that . If we have some
phase criteria for the advancement of modules.

Nathaniel: Tests should be part of this process.

Luke: WG specs and distinct requirement.

Dan: Thanks everybody. We are open to ideas about how to do versioning
and feature detection.
"
wasi/2023/WASI-09-21.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: September 21 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: September 21, 16:00-17:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. _Submit a PR to add your announcement here_
    1. Pat Hickey: Plan for reaching Preview 2 by 11/30/2023 meeting
    1. Vote: Advance wasi-http proposal to Phase 2

## Notes
### Attendees
Dan Gohman
Pat Hickey
Bailey Hayes
Timmy Silesmo
Toni Bofarull
Ben Green
Saúl Cabrera
Till Schneidereit
Jeff Charles
Colin Murphy
Piotr Sikora
Luke Wagner
Chris Woods
Dave Bakker
Petr Penzin
Kate Goldenring
Colin Murphy
Sam Clegg
Matthew Yacobucci
Steven Prine
Ivan Font


#### Vote: Advance wasi-http proposal to Phase 2

**Pat Hickey:** We are essentially voting on the compatibility criteria of wasi-http proposal

**Pat Hickey:** https://github.com/webassembly/wasi-http#phase-4-advancement-criteria

**Pat Hickey:** Luke now one of the champions of wasi-http. He has been very involved since day zero. He has added the set of compatibility criteria. Must have two complete independent implementations. One of the rules of the implementations is that it must execute in the browser using fetch. This means wasi-http will work both in the web and on the server. Traditionally everyone working on wasi-http has been working on the non-browser implementations first. We are making wasi-http working in the browser a requirement.

**Pat Hickey:** The Fetch API is the way you do modern http requests. The Fetch API does not implement trailers today. We will have to cover this in the spec to cover this implementation detail. Does anyone have anything to add?

**Pat Hickey:** Any questions or concerns?

**Petr Penzin**: I like that this is required to be compatible with the Web API. How does it compare to the Web version, though?

**Luke Wagner**: We looked at fetch while we were working on this. This is based on a spec worked on by Mark Knottingham that both are built on. Fetch has very restrictive headers that we may have more work on fine details.

**Petr Penzin**: I’m not an expert so when you say it doesn’t support trailers, I’m not sure what that means.

**Luke Wagner**: This is a newer feature.

**Till**: Most of the stuff specified in the WHATWG spec, I implemented at Fastly’s Compute@Edge a couple of years ago. One of the goals of the wasi-http spec is to be compatible with this. Over the last few days, I have started working on this within JavaScript side and have not seen any major users. I expect this to pass the WPT platform web test suite. I don’t see any issues there and feel very optimistic about it.

**Petr Penzin**: Nice, thank you.

**SBC**: A lot of the other WASI API’s do not try to mirror web-y things. Do you think this is going to be a requirement to mirror the web everywhere? Why bother to mention browsers?

**Luke Wagner**: People are already polyfilling components into browsers. The goal is to be able to run components in lots of places and Service Workers.

**SBC**: Will all WASI API’s mirror web API’s.

**Luke Wagner**: Not in a blank check sense. OPFS, it would be cool to implement wasi-fs on OPFS via polyfill.

**Till**: more accurate to say fetch spec is implemented in terms of the http spec as is the wasi-http spec. The fetch implementation I just mentioned is non-trivial. It has a lot of code in it to implement the fetch spec in terms of another API. It is not an identical API but serves roughly the same function.

**Petr Penzin**: OPFS, when not in the browser but running in JS engines, then you have similar API’s but not exactly the same. The goal of compiling C++, Rust, what have you, then these API’s will not exactly match the JS APIs. It makes sense that there is a balance here.

**Piotr Sikora**: Will this be phase criteria for all WASI proposals or specific to HTTP? 

**Pat Hickey:** No, specific to wasi-http. We think this is appropriate for wasi-http since fetch API exists and so it makes it desirable. Sockets for instance, there will never be a requirement for it to work on the web, there will never be a way to make it work on the web. 

**Piotr Sikora**: What about WebTransport and/or WebSockets?

**Pat Hickey:** Exposing web transport would be very interesting.

**Piotr Sikora**: It could also lead to partitioning of the WASI worlds. We want to create the HTTP proxy world and that requirement may conflict with the needs of browsers. 

**Pat Hickey**:  We expect that the http-proxy world is the thing that will work in browsers. Sockets is very intentionally not part of this world. One world we’ve tossed around conversationally is a caching http proxy store. When in a serverless environment, you could have more sharing of that cache.

**Till**: @Piotr Sikora part of the stage 2 entrance criteria is defining stage 4 criteria, so it's not purely up to the proposal champions. Instead, the WASI SG has to assess the validity of those criteria in deciding whether the proposal should advance to stage 2

**Petr Penzin**: If there was a requirement to consider Web mapping, it would be easier to see which parts of the web are mappable and which are not. Though that might not make sense for some proposals. 

**Pat Hickey:** Let’s make the things that are mappable, mappable. And for the things that are not that’s OK. This is part of the virtualization story that enables you to run somewhere where it is not natively available.

**Petr Penzin**: There is no phase 4 in the WASI process yet. Let’s clarify that.

**Pat Hickey:** Prior to the last vote we changed the name of these criteria from “phase 4 criteria” to “compatibility criteria”. That name change hasn’t bubbled through everywhere yet. We need to meet those criteria in order to ship Preview 2 or at least show that this is on a very good path to being met. We are voting on what those criteria are, today.

**Colin Murphy**: Dumb user question. We have tokio, one day we will have rustls. 

**Pat Hickey**: I want to see all of these common tools in the Rust ecosystem work on top of WASI Preview 2. 

**Colin Murphy**: Goal to reach people with tiny web app.

**Pat Hickey**: Realistically this is going to be one of those things that takes time to percolate through the ecosystem. It isn’t a gate to saying the standard is done. The standard needs to be stable before that percolation can happen.

**Sam**: Even if we don’t go to components, we can use some of the same core API’s. This is a general discussion that emscripten may be able to start targeting some of the same API’s. 

**Pat Hickey**: OK let’s do a vote. We are going to do this by unanimous consent. If you want to dissent, you can do this now by speaking up or by posting a message in the chat.

**Pat Hickey**: Thank you everyone. Now wasi-http is phase 2.

#### Plan for reaching Preview 2 by 11/30/2023 meeting

Slides: https://docs.google.com/presentation/d/1-P49kDej_5Vir8HyOcMcL9aES6nf_KUlzSTZWnTo_-U/edit?usp=sharing


**Pat Hickey:** Our goal here over the next couple of months is to ship preview 2. This is my and consensus shared with a lot of this group already for how we are going to do that.

**Pat Hickey:** Last meeting we ratified all of the shipping criteria.

**Pat Hickey:** Two proposals with worlds including their dependencies. Must have a credible plan for satisfying portability criteria. Like everything here, we vote that we all agree that it is satisfied.

**Pat Hickey:** wasi-http proxy is one of those worlds. wasi-cli command is the other. If you aren’t already familiar with wasi-cli, then it is similar to posix-y things. Isatty and ability to get your arguments and environment variables. Things that many programs need to do. 

**Pat Hickey:** wasi:filesystem is not an import of wasi-http proxy world.

**Pat Hickey:** Summarizing the portability criteria of all of these, the criteria is that there are two independent implementations that works across linux, mac, and windows. HTTP outbound uses whatwg Fetch.

**Pat Hickey:** wasi-io and wasi-poll that are two closely related things. We decided to merge these. [wasi-io#46](https://github.com/WebAssembly/wasi-io/pull/46). All of the reasonably complicated proposals depend on streams. Fundamentals are all the same but now same namespace. 

**Pat Hickey:** Wasmtime and JCO transpile are the leading implementations.

**Pat Hickey:** Green check means as done as it can be. We’re still adopting full resources so more changes may come. “Essentially done, basically working”

**Pat Hickey:** wasi:sockets and wasi:http are undergoing significant work.

**Pat Hickey:** Status for JCO is similar to wasmtime but a little behind. That’s OK. One of the tricks with JCO is that it has to integrate with the web event loop. There are things that we can do easily in wasmtime and that you cannot do very easily in the web. Specifically poll-list (previously poll-oneoff) which work is undergoing.

**Pat Hickey:** For wasi-sockets, it’s important that JCO transpile can support sockets in Node.js since there are no sockets available in the web.

**Pat Hickey:** I welcome deep conversation on any one of these items for how we will meet any of these requirements.

**Pat Hickey:** [Bytecode Alliance’s Ship WASI Preview 2 GitHub Project](https://github.com/orgs/bytecodealliance/projects/10/views/1). Broken down into all the little things that we are going to work on to get this done over the next couple of months.

**Pat Hickey:** Let’s do one big vote. We can do this all grouped as one vote as long everyone is onboard for doing it all at once. Let’s talk about it in the future as this gets closer. 

**Pat Hickey:** Stretch goal Nov 30, Dec 14 is the last regular meeting of the year. This is our goal right now.

**Pat Hickey:** Speak up at any time if you see any concerns. We prefer unanimous consent. If you think something isn’t worthy of Preview 2, bring it up.

**Pat Hickey:** Dan Gohman has been doing a phenomenal job bringing forward resources. Many others contributed to the tooling as well. Thank you everyone who has also been contributing to the resources tooling.

**Pat Hickey:** Implementations are ongoing but we are no longer seeing major changes. Mostly smaller details that are being fleshed out in several proposals. Please be involved and understanding how this will impact you and your platform. The early we can talk about that, the better it is for everyone.

**Pat Hickey:** Preview 2 is not our end goal. It is our ticket to keep working on this. We have to ship preview to be in the hands of our customers and be stable code that we can start building on it.

**Petr Penzin**: Two concerns. The vote from unanimous consent is a different from what the CG does, where lack of interest can also preclude a proposal from advancing. Moving multiple proposals at once by consent is even more so. 

**Pat Hickey:** Vote early and often advice should help cover this.

**Luke Wagner**: We have to be individually happy with each of these proposals to phase 3, then we will vote on a snapshot of the collection of these.

**Bailey Hayes**: (chat) Several recent Wasm CG groups votes have been unanimous consent.

**Piotr Sikora**: The goal stated in the slides was to vote everything at once to phase 3. 

**Pat Hickey:** That was my goal. We can phase 3 vote ahead of time if necessary. It’s a lot of procedural votes and was hoping to reduce that. The proposals are very interrelated. Many of these like streams impact http and files. Many of the lower-level proposals were influenced by learning from the implementation.

**Petr Penzin**: In CG proposal champions make the case to the group to move it forward, here we are going to get a very different dynamic, when WASI Subgroup would itself move all proposals at once, unless there are objections.

**Petr Penzin**: I actually have another question. You are using wasmtime and JCO transpile. One objection to this is that JCO is not really a runtime. JCO is a compatibility layer. Implementing something like that is different from having two different WebAssembly engines.

**Pat Hickey:** The goal of a component runtime is to be able to run a component. Being able to run in a browser engine and in wasmtime means we were able to ship without needing native support. If the goal is only to be able to run it, then if we can run it. 

**Petr Penzin**: wasm2c is not considered an engine.

**Pat Hickey:** wasm2c is not a Web engine. The core wasm cg has a requirement for two Web engines, but the WASI subgroup does not use that requirement because we are concerned with use cases beyond just the Web.

**Petr Penzin**: If you have two transpilers, then you could move it forward right?

**Pat Hickey:** Yes

**Luke Wagner**: If it is part of the portability requirements for the proposal as in those are the goals where that proposals needs to run, then yes.

**Piotr Sikora**: Concern of underspecified specification since both ""independent"" implementations (JCO and Wasmtime) are primarily developed by Fastly.

**Till Schneiderit**: Wasmtime has major contributions from 4 different companies. JCO will largely be implemented by Fastly and Fermyon. In total we have 4 different companies involved in the different implementations. If it were the same people on the same team, then I would agree it would not be enough.



"
main/2018/CG-08-21.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 21 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: August 21, 4pm-5pm UTC (August 21, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email JF Bastien or Ben Smith to sign
up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
       1. AI(titzer@): Discuss w/ domenic@ and others about WebAssembly CSP
       1. AI(dtig@): collect previous CG notes about SIMD into GH issue
    1. Update on WebAssembly threads spec work progress (Conrad Watt)
    1. Proposal to specify dependencies between features (Thomas Lively)
    1. Discuss change ([PR](https://github.com/WebAssembly/esm-integration/pull/13)) to WebAssembly ES module integration (Lin Clark)
    1. Discuss licensing for WebAssembly source code (see discussion [here](https://github.com/WebAssembly/binaryen/issues/1494#issuecomment-414481433)) (Alon Zakai)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Adam Klein
* Alex Crichton
* Alon Zakai
* Andreas Rossberg
* Benjamin Bouvier
* Ben Smith
* Ben Titzer
* Conrad Watt
* Deepti Gandluri
* Derek Schuff
* Jacob Gravelle
* Jay Phelps
* JF Bastien
* Lars Hansen
* Lin Clark
* Luke Wagner
* Sergey Rubanov
* Shiv Kushwaha
* Sven Sauleau
* Thomas Lively
* Till Schneidereit
* Tyler McMullen
* Yury Delendik

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Deepti seconds

### Proposals and discussions

#### Review of action items from prior meeting.

##### AI(titzer@): Discuss w/ domenic@ and others about WebAssembly CSP

I had an internal conversation about this, tried to take polls of where things are. Eric holk wrote a proposal, I inherited. Discussed with Domenic. We need to get buy-in from other browser vendors. JF will implement what is spec’d. Luke less enthusiastic. Haven’t heard from MS.

Potential API design issue -- subresource integrity. Adding a URL that is robust to responses. May have effects on web API surface. Like to hear from other people on the call.

LW: Can you briefly summarize what is in the proposal.

BT: Basically activates certain APIS depending on what directives are there. For example wasm-eval. Unsafe-eval activates all of them.

[BT presenting csp proposal]

We should figure out what the table should like and get everyone to have the same values.

LW: Presumably instance is also allowed?

BT: I think there’s an entry missing.

LW: instantiate is tricky since it has two different behaviors. One can get modules from lots of places. Some may be blocked others might not.

BT: Includes wasm-eval directive which enables these things but nothing else. Also includes adding origin to response, so that link is always there and trustable. Wherever that response goes it comes with URL and that would be allowed according to CSP policy.

LW: Where did the SRI fit in to it?

BT: tbh, I don’t understand that part of the proposal.

JF: SRI says you match based on hash instead of origin.

LW: I thought that was per resource, how does that work site-wide.

BT: Basic mechanism makes sense, how does that work with certain APIs. Do you have to provide hash to compilestreaming and instantiatestreaming. May need API changes.

JF: I thought the next step is to get a meeting with CSP subgroup. Two people at Apple would want to be in that. Brad had lukewarm enthusiasm on Google side. I think that’s the next step.

BT: JF can you help me connect with those people. And other people in the room on board.

LW: [csp person @ mozilla]

JF: [csp people @ apple]

I’ll send you the names on Apple’s side. I think it was supposed to be a w3c subgroup that does this.

BT: Part of the web-embedding is that the idea?

AI(BT) set up the meeting with relevant security folks.

##### AI(dtig@): collect previous CG notes about SIMD into GH issue

DT: I’ve done that. Not sure there is something to discuss right away. But if folks have things to take a look. I’ve summarized the instructions, feel free to update the issue.
https://github.com/WebAssembly/simd/issues/37

#### Update on WebAssembly threads spec work progress (Conrad Watt)

CW: Since the last update semantics hasn’t changed. The wider spec has changed. JF pointed on that we should perform bulk-memory operations byte wise and should perform a trap if oob.

We’re using abstract time stamps, instead of JS way. It fits on just a few pages. In terms of spec work, we’d like to move to stage 2. For this work it’s easier to do formal first and english afterward. Are people OK with this first? Kind of procedural question. Actual semantics is pretty fixed. Interop with bulk-memory op is up for question.

AR: To add to that: streamlining formulation makes it nicer to digest for reader. Try to put it into shape that fits with style of spec, smaller on paper. Easier to understand. There’s massaging to do still.

People seem ok with formal part of spec first for stage 2.

#### Proposal to specify dependencies between features (Thomas Lively)

TL: Coming at this from a practical perspective. Some SIMD instructions require sign-extension logic. Would be nice to reuse logic from sign-extension proposal. Trivial catalyst for this idea. Specify that certain features depend on other features. SIMD depends on sign-extension for example. To be spec-compliant would require sign-extension for SIMD.

Make testing simpler: if they are independent it is more combinations. Reduces the number of test cases. Reduces the number of executables that need to include.

Just an idea.

LH: We already decided to do this for threads proposal since we split it up.

DS: We kind of agreed to this, though threads doesn’t really require the other split proposals.

BT: This will happen again with GC proposal requiring reference types.

TL: Can’t really say that SIMD requires sign-extension directly -- we may just want to do it to limit the combinatorial explosion.

LW: There’s a difference between dependent features, and optional features. We should try to get SIMD everywhere so folks don’t have to scalarize. If you want to operate in that 2-year window where you have features that are in some browsers but not others. But it shouldn’t be the case for the future.

DS: I was thinking about this already with tools, since I don’t think browsers will have SIMD without sign-extension. Also w.r.t. Optional features. We decided we wouldn’t have versions, rather have feature testing. Now you’re saying something more like versions?

LW: I think there’s a difference between optional and non-optional features. Depends on rollout. Fundamental difference between rollout window things and optional features. Blockchains may never have threads.

DS: Do we want to formalize any of these things.

LW: During the rollout, to make people’s lives easier, lets implement things in this order.

DS: We’ve got these implementation defined limits, not part of the formal spec but it makes it easier.

LW: I see this now.

DS: For example: Please nobody do threads w/o bulk memory.

AR: Similar issues with spec writing, some things are easier in one order.

TL: right now we have a feature flag for “give me SIMD”, but you expect that some of these features will be non-optional in the future. So would you be OK with remove the flag from LLVM at that point?

LW: I don’t know about that, maybe the default flips to on. Toolchain thing: maybe you have a wasm-standard-2019 or something.

DS: I think there will be a product decision for the toolchain, spec can say what it will.

BT: Some implementations may never have SIMD, standalone or embedded. Polyfill SIMD, user-level wasm but may just want scalar.

LW: They may do that at their own peril -- may be given wasm modules that they won’t understand.

DS: This happened with NaCl, Samsung put it in a TV, will happen with wasm too.

AR: Some things we may want to be optional in the spec: threads, SIMD. I think there are good reasons for this.

LW: Just lowering to scalars?

BT: It’s a bunch of work.

AR: It’s code size too.

LW: Surprised if it was a factor of 2. Some of these tiny devices, they’re precompiling the wasm to machine code. Anyway, this feature is a fair amount of work to optimize. Not prohibited by the platform.

JP: Might not support SIMD so it’s clear that you won’t get performance benefit.

LW: Came up before -- we discussed this with intel vs arm ops that you may be able to probe whether an instruction is fast or slow.

BT: I’m not going to advocate not implementing SIMD.

...

AR: isn’t this about when we move stuff into the repo?

TL: my example was about dependency on sign-extension.

BT: Might not call sign-extension a feature.

TL: Even small things maybe should be. So we can have different meanings of spec-compliant.

AR: Separate problems: optional features vs. order of features that are added to spec.

AI(TL): Thomas will write up this point.

LW: You can imagine a graphviz doc about this, showing dependencies.

DS: For feature testing, that would be useful. It would not rise to the order of actual feature dependencies, but it might

AR: Don’t want to encourage fine-grained feature testing of non-optional features. Version of standard supported is right granularity, testing matrix too large otherwise.

BT: We may want an appendix to that describes the difference between 1.0 and 1.1 -- this delta named sign-extension. Non-functional otherwise, but puts a name on the group. Will allow fine-grained slicing.

AR: We do want a changelog appendix somehow.

BT: In some ways we’re forced to do fine-grained logging in the spec process. It’s not normative, just happens to be useful.

#### Discuss change ([PR](https://github.com/WebAssembly/esm-integration/pull/13)) to WebAssembly ES module integration (Lin Clark)

LC: That PR gives the detail, but I wanted to give more status on this. We need to restructure how modules work since last time I discussed this. How it is integrated I mean. They will link the ES module instantiation phase, but not do the instantiation work in that phase. It would run that step later. There is some concern on the terminology. Till had a suggestion to rename the phases in TC39. I’m going to try to do that. Wanted to let folks on this call know. There’s also an update on future progress: Dan E. from Igalia will work with us, doing the spec text after PTO on Sept 5th. If you have concerns about how we’re doing this, please chime in before then. They’re also going to do tests for bundlers so we can know whether they’re following the semantics we intend. Expect to complete before TPAC, ready for implementation -- some engines have said they’re interested in working on this so I’ll reach out to them.

DS: On the tools: is this something that... no concrete plan to generate anything compatible with this. Rust folks?

LC: We have been working with the rust folks, can circle back with them when we’ve made progress on the spec text.

LW: There is a bug on emscripten that says it is stuck.

AZ: We have a flag [missed this]. There’s no work on that that I’m aware of.

DS: It’d be cool, but it would be a lot of work.

JP: What about the loader spec?

LC: That’s not being worked on.

TS: For rust The plan is to emit ES6 modules, we also have wasm-bindgen tool. For must uses people will want to load a JS module that wraps the wasm module into a higher-level API. But where possible we’ll want that.

#### Discuss licensing for WebAssembly source code (see discussion [here](https://github.com/WebAssembly/binaryen/issues/1494#issuecomment-414481433)) (Alon Zakai)

AZ: This is about a specific angle. Binaryen and wabt are apache2 license. Good license, but not good for embedding in GPL2 like QEMU. The person who wants to do this, but the license worries them. LLVM is in the same situation, maybe we should change our code projects to apache2 + exceptions. Any thoughts or issues about this?

DS: No questions, but I think we need to check with lawyers. Following LLVM seems good. They’ve done good work here. I trust their process.

AZ: They’ve documented all the stages for how they’ve done this.

DS: We’ll have to track down the contributors and convince them. Another thing: do we even want this to be owned by the CG? Currently need to be a member of the CG to contribute. It is true for these 2 projects. We talked about removing them from the subgroup. If we did that, it wouldn’t be something that the CG would have to take an opinion on this.

BS: Someone needs to be on the hook for this.

DS: I would be ok taking this on AI(DS) figure out relicensing. As long as we brought it up: do we have opinions about removing wabt and binaryen as projects of the CG?

JP: I wasn’t around for that discussion -- tl;dr for benefits of it being under the CG?

DS: The reason it was under the CG in the beginning to be conservative and careful. I don’t think there’s much risk here. Most of the other projects don’t have this problem, just the 2. I’m pretty comfortable with moving them out, but haven’t made any progress on this.

Does anyone care if I push forward with this?

[silence]

### Closure
"
gc/2022/GC-02-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: February 22, 5pm-6pm UTC (February 22, 9am-11am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Pushing RTTs to post-MVP (https://github.com/WebAssembly/gc/issues/275)
1. Closure

## Meeting Notes

### Introduction of attendees

 - Thomas Lively
 - Adam Klein
 - Francis McCabe
 - Conrad Watt
 - Slava Kuzmich
 - Asumu Takikawa
 - Oran ?
 - Rick Battagline
 - Andreas Rossberg
 - Lars Hansen
 - Alon Zakai
 - Keith Miller
 - Manos Koukoutos
 - Deepti Gandluri
 - Ben Titzer
 - Jacob Kummerov
 - Ioanna Dimitriou
 - Emanuel Ziegler
 - Luke Wagner
 - Derek Schuff

### Discussion: Pushing RTTs to post-MVP (https://github.com/WebAssembly/gc/issues/275)

TL: Binaryen & V8 have been experimenting with versions of the instructions that don't take RTTs, and that works. Binaryen had been relying on lack of RTTs for optimization, but now that there's 1:1 relation between static types and RTTs that's no longer a factor.

TL: There seem to be two arguments for RTTs: JS API and generics. For the JS API, I'd suggest we think about that without RTTs being a hard requirement.

AR: I see one more reason, beyond generics & JS API (which I'd put last): having an explicit cost model for Wasm. With the MVP proposal, there was meant to be a 1:1 relationship between Wasm instructions and machine instructions; this was what was ""low level"" about Wasm. With GC we have to relax this to maintain safety, but should still stick as close to the ideal as possible. Still important that producers be able to do optimizations without depending on sophisticated VM optimizations. It's all a bit fuzzy, but where we can, we should make costs explicit where it makes sense. RTTs try to do that: they represent operations that would be separate if producers were lowering to machine code instead of Wasm. With generics this becomes even more important. This was the original motivation for RTTs to exist. The JS API use case followed once RTTs existed.

BT: Cost argument is a sliding scale. If we applied it universally, e.g. call_indirect would be split into multiple operations. My reason for wanting to keep RTTs is that if they are implicit, that might be an extra load from the instance object. But that depends on implementation details, so the explicit cost argument cuts both ways.

AR: Fair, it is a blurry line. My argument is that, if it's something we'll need anyway, we should add it now since it also fits with the cost model. call_indirect is an interesting example, I don't think anyone was really happy with how that came out; if we had to introduce it at this point I could imagine it being designed differently, e.g., in terms of casts.

BT: For this discussion, I feel that if we axe RTTs from the MVP, it might be one cut too much and we would end up shipping something unusable. As Luke and others have pointed out, we need generative RTTs for piggybacking source casts.

AR: I agree it can be useful for Java-style casts, though I don't see it as necessary: you could always do it yourself on top. But if we're going that way I think it's important to introduce nominal/abstract types, as in the type imports proposal, so that there's proper correspondence within the static type system. So the use-case of RTTs as a cast optimization for Java-style casts seems like not necessarily worth it alone.

TL: This is why I'd like us to defer RTTs: people seem to have lots of ideas of things that RTTs might be useful for, but without concrete users, different people will think they're for different things, leading to trouble

BT: We are in the game of building low-level building blocks that people are going to use in various ways. It's expected that people will build things that we don't even conceive of right now.

AR: My view is that anything we want long term for an RTT-like mechanism will be a superset of what they currently provide, and that makes me confident that including them isn't a mistake.

TL: Do people think that RTTs provide value, right now, in the WasmGC MVP, not considering the JS API or generics?

CW: I think that's not the right bar.

AT: Is the idea that RTTS would be considered a follow-on proposal after the MVP? Or that they'd be added at, say Phase 3 of this proposal?

TL: I don't think we've met the bar for including them in the MVP right now. If we do see reasons to include them, then we could add them back before shipping the MVP

CW: Removing RTTs later seems like it should be simple, if indeed we find that they're not useful. I think the bigger risk is removing them too early.

TL: So if the spec were at a late stage, would you be OK with removing RTTs at that point?

CW: Yes

JK: There seems to be an exclusive or between what Ben is describing with generative RTTs and what Andreas has been describing with the 1:1 correspondence. We would have to do one or the other.

AR: The way you would marry the two is by introducing private types.

BT: It’s easier to do it with one instruction, rtt.fresh. In a previous implementation, I misunderstood that rtt.sub was not supposed to be generative and used a generative version to piggyback casts.

CW: FWIW, if that's the main use-case for RTTs, I'd be fine adding RTTs as a follow-on (along with rtt.fresh).

AZ: Don’t we lose optimizability with generative RTTs?

AR: That’s why we need the private types in the static type system as well.

BT: Would they be part of a recursion group, or…?

AR: They'd effectively be abstract types, treated nominally

BT: I see this operationally: how do we get the VM to generate the code we want? Adding lots of machinery, e.g. a type import, in order to generate 3 instructions seems like a lot of overhead.

AR: A private type is not necessarily an import. Want to maintain the property that you statically know what static type matches which RTT.

BT: Maybe we need both. Casts that respect the generative identity of RTTs and casts that don’t.

AR: Or we could have two different sorts of RTTs, transparent and intransparent.

BT: Probably don’t want to be a subtype so that the kind of cast is clear at each cast site.

AR: You’re right, the subtyping should go the other way, transparent is subtype of opaque.

TL: We do something similar in Binaryen & V8 right now: cast instructions that use RTTs, and others that are fully static. Regarding optimizability, modules that only use the static versions can have their casts optimized, while modules that use generative RTTs & casts don't get optimized.

MK (chat): There are no generative rtts anymore in v8. there used to be with the equirecursive types.

AR: If you can tell the static type of an RTT you can do that on a per-cast basis.

TL: If we maintain a 1:1 mapping between RTTs and static types, why even have the RTTs?

AR: That assumes you always have an RTT available. With generics, this would force you to reify type parameters everywhere, and this would be expensive for languages that didn't want to use casts much (or at all). 

BT: This is the place where the cost model that AR was talking about applies: if you have the RTT available, then you can use it.

LW: Until we have function level type parameters, we’re still forced to carry around RTTs on the instance level.

AR: Could stash the RTT in a local or something to keep it closer / in a register.

LW: But register allocator will do that anyway, so it’s not a meaningful difference.

CW: All these are post-MVP features

LW: For me it's the JS API & the question of what prototype to use. If we're okay with all WasmGC objects having the same prototype (either null, or something like Object.prototype), then RTTs wouldn't be needed for it.

AR: There’s both the prototype as well as named accessors. Accessors might need something else as well.

BT: If we did include generative RTTs now, are we confident that we could design a suitable JS API?

LW: I think I could see how it would work, but idk how confident everyone else is.

AT: On the JS API side there's a direction for that to work. On the JS side, there's a Structs proposal providing fixed-size objects, and Wasm objects could be represented by these on the JS side, based on info from the RTT.

BT: To check understanding, the idea is that the Wasm module would import the RTT with attached accessors, etc.?

AR: Yes, I replied to one of the threads with an example

BT: My fear is that if we remove RTTs tomorrow, we'll get to Phase 3 and then realize we can't implement the things that people need.

TL: To re-iterate, there are two clear capabilities that RTTs are needed for: generics & JS API. Generics are clearly post-MVP. I think we should be designing the JS API well before Phase 3; and while we're doing that we should keep our minds open that there might be solutions to JS API problems that don't involve RTTs.

CW: My hope is that we could remove them easily enough if we find they're not needed for anything in the MVP. But I can see the concern that having them ""floating around"" could change the JS API discussion.

LW: For the JS API, we could also imagine doing it in two stages, starting with null or a shared prototype, and later adding the capability of describing a prototype. 

CW: I expect that designing generics will take a while as well. Checking that the Wasm feature works for producers will take time.

AR: Generally agreed. When designing generics, I think we want to design something relatively simple, not the swiss-army-knife approach. Basically parametric polymorphism which allows code to operate generically on some set of types.

CW: That’s reasonable, and even reasonable to say we don’t expect generics to eliminate more than some small number of casts.

AR: Can still remove a ton of casts in some languages, but not all.

AT: I do like the idea of tabling this until a JS API is more clear. We need more examples of what producers would want from the JS API. Other languages not using WasmGC use some sort of proxy object API and it might be useful 

TL: I do think it's a useful exercise to think about what the most spartan API we could get away with in the MVP would be, that still fulfills user needs.

AK: Happy with tabling until we figure out the JS API, as I suggested on the thread. Strongly second Asumu’s call for more examples and requirements from users. Part of that is just where we are in the project. For example sheets has not integrated WasmGC into their product yet, so we don’t have feedback on the integration. Will soon, though.

CW: What do we need to do to get more producer feedback? Is Google already engaged with the right people or do we need to do more?

AK: We have the sheets team as well as the Dart team, which already has a JS API for their Web target.

SK: At Kotlin we are using V8’s experimental API and we will use more when there’s more to use.

AR: It’s a very niche consideration that is application/user specific. Not sure how to reason about it generally. Depends on how tight the coupling should be and there is a whole range of possibilities of what people want.

TL: If we don’t get a strong signal, we can ship something minimal and iterate on it post-MVP.

BT: Extra friction like having to implement another type system on top of Wasm pushes producers away and is a chilling effect. So we do need to consider producers needs rather than just shipping something we think is viable.

AR: I’ve mentioned before that having generative casts is not useful for languages beyond Java. Anything beyond that already requires implementing a type system on top of Wasm.

AR: What is the current state of JS in V8?

JK: It’s a completely opaque handle, like a reverse externref. Goal was to do the minimal thing for partners. We have a partial implementation of a solution using auto-generated names like field0, field1, etc. But it’s been on the back burner because there’s been no demand. Our partners have been solving other problems and we expect there to be more demand for good JS integration soon.

SK: The minimal requirements for the JS API probably come from the browser and DOM APIs, where we have to pass Wasm objects to those APIs.

AR: Why would you expect that to work?

SK: So we don’t need to create extra allocations?

AR: Do you have an example?

SK: e.g. WebIDL types. Dictionary, for example, would make sense.

CW: Could you write this up in more detail?

SK: Sounds good, will write an issue. Accessing fields will also be important.

TL: It will be great to have a write up of this.
"
main/2024/CG-02-27.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 13th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: February 27th, 5pm-6pm UTC (February 13th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Update and phase 3 poll for ESM Integration (Guy Bedford, 25 minutes)
        1. Issue: https://github.com/webassembly/esm-integration
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees

- Thomas Lively
- Keith Winstein
- Sergey Rubanov
- Deepti Gandluri
- Conrad Watt
- Zalim Bashorov
- Nick Fitzgerald
- Alon Zakai
- Dan Phillips
- Daniel Hillerström
- Robin Freyler
- Ilya Rezvov
- Fedor Smirnov
- Paolo Severini
- Alex Crichton
- Paul
- Yury Delendik
- Michael Ficarra
- Guy Bedford
- Luke Wagner
- Heejin Ahn
- Emanuel Ziegler
- Richard Winterton
- Ryan Hunt
- Jeff Charles
- Dan Gohman
- Patrick Hickey
- Johnnie Birch
- Jakob Kummerow
- Ashley Nelson
- Brendan Dahl
- Sam Clegg
- Derek Schuff
- abrown
- Paul
- Slava Kuzmich 
- Nuno Perreira
- Dean Srebnik


### Proposals and Discussions

#### Update and phase 3 poll for ESM Integration (Guy Bedford, 25 minutes)

Guy Bedford presenting
[slides](https://docs.google.com/presentation/d/1qv2l17_EVU1VkXD2B2J8z-x--2ZwtPhGi0d72Fqms1Y/edit?usp=sharing)

CW: question: does this also generalization give us a path for representing compile-time imports in the ecosystem?

GB: I think the ESM integration in general has some interesting interaction with compile time imports. What the source phase does is it distinguishes between the full expressivity of the instantiation where you want to directly pass the imports and the esm integration. Esm integration is the just works pass. The source phase is more like binaries for today, where we need to provide a bunch of layering in-between. The compile-time imports defaults are potentially interesting in both cases, and maybe slightly orthogonal.


CW: If there was something on the top of your head that represents incompatibility but in the absence of that it seems like things are okay.

GB: right: as far as I've thought about compile-time imports recently,  I don’t know of any incompatibility

GB: [presenting import phase syntax]

DG: Deferred evaluation question. What stage is that proposal at in TC39 and do you have more signals about the interest levels for stage advancements?

GB: Need to double check, unless someone knows off the top of their head? I think it’s stage 2 - “Deferring Module Evaluation”

DG: Think it’s stage 2 but was interested in the second part of the question, feedback or interest from TC39 about stage advancement

GB: Bloomberg was most interested in this and were working with Igalia on it, there was considerable investment for their use case, since they use this technique in their internal systems and wanted there to be a standard way. I haven’t heard any negative sentiment about it explicitly. Not sure how close it is to progressing but it’s an active proposal.

GB: [presenting ESM phase imports]

IR: Is it going to be polyfillable without ESM modules? Could you construct a JS representation without ESM?

GB: There are different levels of toolchain support. Can imagine a build tool turning this into doing the right thing doing the syntax today. You’d write this but it would be writing JS that is supported in current browsers to do the same thing. We have the same for Source Phase imports in esm integration, where tools can rewrite it to something that works today. Can immediately get benefits. In terms of a browser polyfill, some approaches, will discuss in the implementation slide.

GB: [presenting module loading phases]

DG: a couple of questions: the documentation in the current module repository: haven’t looked recently, does it pull from the TC39 proposals that are not yet at stage 3? How should we think about the dependencies between TC39 and the CG? The 2nd note for the group: WPT are a great set of tests, but we also usually recommend at least some API tests in the wasm test repository (just in terms of process). I could go both ways on that, in Chrome we can run WPT right out of the box but I’m curious how others think of WPT as meeting the testing requirement. 

GB: On the first point, can you clarify what you mean by state of the documentation?

DG: The proposal overview of the spec, the text assume dependencies on stage 1 or stage 2 TC39 proposals.

GB: it’s kind of a chicken-and-egg thing. We’ve gone I think as far as we can without some further signal from the wasm CG. source phase is at stage 3, which in the JS process is very advanced, basically it’s done and ready for implementation in browsers. Traditionally we had problems in stage 3 in TC39 because things advance there and get implemented and it’s too hard to change. TC39 recently introduced phase 2.7 to try to fix that but source phase is at stage 3. We’d need browser implementations to get to phase 4 but that means more progress on the wasm side first. The synchronous instantiation/deferred evaluation isn’t a dependency, it’s more about compatibility. 

DG: yeah. I’d still be curious to hear from the group about testing, and interest from runtimes for implementation.

CW: For the other proposals, we had engines implementations at Phase 2/Phase 1, that’s perhaps a signal that we would be interested in anyway.

GB: Signals were the implementation was ready to go and so we had it moving forward. Deno had an implementation moving forward. They were ready to go live back in 2022 and we held back because we wanted to flesh out the source phase. Did not want to release a feature that provided part of the functionality, and result in a cliff for user support. Potentially an ecosystem effect that would kind of divide or distort the ecosystem. With source phase, we now need to send a signal that this is ready. This is the process we’re in now. We need to reverse that signal. We need to work with the CG to build trust from browsers.

CW: Do I understand correctly that just form TC39 point of view, the blocker is just that they need more web implementations?

GC: There’s no blocker at TC39, there just needs to be a positive signal from the Wasm CG. The TC39 stage 4 we can have when we have web implementations, its more about building implementation trust. 

DG: In terms of signal, GB corect me if you’re wrong. You’re just lookjing for a signal from the CG. Procedurally, most of the requirements of Phase 3 have been met, except for the testing question. If looking for a general, positive signal, maybe if interested members can speak to that, now is the time to do so.

RH: I may have missed this previously: does this run against any implementation? I guess the spec interpreter is not a web engine, is that the issue with the testing?

GB: Right, requires the full HTML integration, the full details come through the full HTML integration side. Yes. Getting end to end testing is either in JS tooling or having full support in engine like JS or another browser. In general we have that with the webkit implementation but it doesn’t have source phase yet.

RH: In terms of JS tooling, do any of them have requirements from the proposal?

GB: Right. The domain areas are, for TC39, its syntax and builtin behaviors. For wasm it’s graph execution behaviors and HTML integration behaviors. In Babel we have an implementation of parsing, loading behaviors for source phase and conversion to ES modules. The HTML integration in theory is testable though the polyfill of ES module shims. Im working on that currently. I should be able to release a version of that with support for all the specs very soon. Other than that I guess deno did also have esm integration previously without source phase, maybe node too. But they’ll need browser support for the syntax to move forward with source phase. Traditionally the signal has been “esm integration isn't moving forward, there are issues”. The key thing to say is it is moving forward, and it is ready to go - however we say that its ready to go is less important

RH: Sounds like there are some implementations of earlier versions of this, but they’re not fully complete, parts missing. Not the case that there is absolutely no testing. Historically, don’t know how complete testing is required for other features.

GB: Yes. The WPT tests that Safari did were quite comprehensive. They were close to unflagging that implementation. The only source phase implementation we have right now is through Babel. As a tooling user I can get the benefits of that syntax already through the plugin. It’s not going to patch webassembly.module but users can get most of the benefits today.

RH: On the question of browser interest, where Mozilla is coming from is that it wasn’t ready to implement, the second reason is resources, no big concerns about the proposal itself, we would just have the resources to implement it

GB: Yeah on paper it seems like we mostly have the requirements for phase 3, short of the fact that it’s not a self-contained test suite, which i guess it he main technicality. It seems like we have most of the pieces in spirit, maybe folks need time to digest it. We don’t need to get phase 3 today but I want to start working toward getting that signal of intent and getting people aware that this is ready for implementation and the concerns have been worked through. Phase 3 would be a strong way to send that.

CW: Can I ask a pointed question about Chrome, what’s their general interest in this?

DG: In a similar position to Firefox. Generally interested, don’t have any immediate plans to implement it, but no objections. Positive signal.

CW: So i would be comfortable going to phase 3 on the basis of a polyfill. It sounds like maybe the polyfill is a little incomplete? It sounds like it’s missing source phase imports?

GB: You’re making more work for me, but happy to take that requirement! That would be a nice validation point as well, looked into how much work it would be, and should be something we can cover in the ESM project, from syntax all the way to HTML integration. The difficulty again is, because of the HTML integration, treating it as a single test suite may be difficult. If it were to have a polyfill implementation, how would you want to define the tests for it. Should it run against the WPT tests? 

CW: I'm personally comfortable with a polyfill that is reasonably complete and hits all the big features. Doesn’t have to hit all the edge cases. But source phase is a pretty big feature so there probably should be non-zero tests covering that.

DG: Speaking up in favor of CW’s interepretaion, reasonable set of some coverage, doesn’t have to be complete in terms of the polyfill, seems like a good requirement.

GB: In terms of where the testsuite lives, if it is just the WPT tests - is that acceptable? 

CW: Totally fine, inviting people to disagree with me. If we are unhappy with the tests where they live, it’s on us to come up with something new, the current framework doesn’t support these types of tests. 

GB: Web platform tests are the easiest path to remain on for polyfill testing. That would be a helpful clarification if we’re going to get the polyfill passing those tests.

CW: i would consider that fine. We’re just going to be working on consensus here i think so, unless someone objects i think that would be ok

DG: Sounds reasonable, in terms of next steps, there is a lot of information to digest in this presentation. How do folks feel about deferring the poll to phase 3? I do think there is enough positive signal from the group, at least that’s my interpretation. Maybe we don’t need a strict poll to phase 3. What do you think GB?

GB: I don’t think there’s a huge rush, let’s come back to the poll in a little while, and give people to reconsider the proposals and build up the context again. I’m happy to finish the polyfill and come back when it’s ready. It’s good to make sure we get it right. The important thing today is to say we have positive intent.

DS [chat]: Not with my ""Chrome"" hat on, but I'm also happy with the level of thought that's gone into this now, and it's looking pretty good to me. I know it's hard with all the dependencies, but I'm happy that we are making progress with this again.

ZB: [chat] JFTR we in Kotlin/Wasm are interested in the proposal, and we are trying to generate glue/service js code with the proposal in mind.

CW: For the benefit of the notes, we’ll believe the Phase 3 requirement will be fulfilled by the WPT tests, with a polyfill that allows them to run somewhere, including tests for source phase imports. 

GB: that should be possible. If it turns out that there are issue with that, i’ll bring it back up but it seems sensible.


DG: thanks for the presentation



## Closure

"
main/2023/WG-09-20.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 20th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: September 20th, 2023 at 3pm-4pm UTC *( September 13th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Update on new charter
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Attendees
 - Mike Smith
 - Derek Schuff
 - Luke Wagner
 - Ms2ger
 - Thomas Lively
 - Keith Winstein
 - Andreas Rossberg
 - Anne Van Kesteren
 - Justin Michaud
 - Ilya Rezvov
 - Petr Penzin

### Charter
MS: We did get one comment on the draft: https://github.com/w3c/charter-drafts/pull/4

MS: TPAC delayed the progression intenerally, but the process is first to discuss with the W3C staff, I’ve done that. The changes were all editorial (other than adding the component model). There have been changes to the charter template. I had not initially used that but now it is, so if there are any changes from the last charter, they are from the template.
There was also the addition of a bulleted item for stack switching. 
So the substantive change was the addition of bullet items for stack switching and the component model, and for normative changes, the addition of the component model.

I have approval from the rest of the W3C team for progressing this to W3C management for final approval, once it gets that, then it goes to the advisory committee for review. I don’t recall exactly how long that review is, could be a few weeks. But likely it won’t be complete until about a month from now. We do have a charter extension through the end of october or november. If that kicks in first, we can actually publish. The charter is the thing that’s preventing us from publishing in the TR space (we can do github.io, but not on w3.org because we have to be chartered to do that).
Actually the AC review is 28 days. So we can get another month extension if we need to.

AR: we have a face to face meeting next month, after that I expect that we will want to make another doc cut soon (3.0?) since there’s a bunch of stuff that’s accumulated. I’m not sure its worth pushing 2.0 all the way through?
There’s a lot of editing work to do, resolving merge conflicts, editorial stuff, that will take a while.
So I’m wondering how much work the acutal procedure is

MS: it’s an issue if we change the shortname URL. if we want to version a different version in TR space, that’s more work. If we just want to overwrite what we have so the short name remains the same, that’s doable.
The runtimes are unversioned, right? We dont’ have different versions fo the runtime for versions of the spec?


AR: people complained that there were multiple runtimes and no spec versions, it was hard to say what was supported with no versions, so we decided to have versions even when we publish on green. But the next version will be a large change, we should probably bump to version 3 at that point, but it’s open to discussion. Seems like the right thing to do messaging-wise.

MS: that’s orthogonal to the charter discussion, the group can do what’s best for the users. If you want multiple versions in TR space you can do that.

AR: I take it that it will be significantly faster to push 2.0 first then, better to get something out there ASAP:

MS: yeah it does sound lke it.
So the only substantive comment that we go ton the charter was from Anne, and he’s here, do you want to speak aobu that?

AVK: we reviewed the proposal internally and I think a couple people got confused when they saw component model, and they didn’t really know what it was, as a normative deliverable. They want to know what it would be for webkit and the web platform, hard to know what would be in scope for this. And there’s no links, it’s not clear what it would mean. There’s a legal aspect too.

LW: yeah, most of the other things have a sort of meaning already. The component model doesn’t really. Maybe we should have a brief description?

AVK: yeah I don’t think it’s changes since we discussed initially

LW: yeah it doesn’t add capabilities to the web platform, it’s just a way of describing compute, and can be polyfilleed with wasm. Should we highlight that it’s not adding any capabilities or web interfaces?

AVK: I assume it will be implementation work, even in a browser implementation of wasm. It’s not clear yet whether it would be worthwhile, and how it fits with other features

LW: yeah part of that is that thats where the stage process kicks in, it currently needs browser support in order to progress. I don’t expect browsers to implement this soon because tehre are more important things. But the charter lets us work on a single standard instead of runtimes outside the browser do their own thing, which is happening now. When browsers implement is an orthogonal question:

AVK: typically you expect a WG charter to have deliverables that you expect to complete in some number of years, right>

MS: my advice was to put in anything in the charter that we believe that we might get done in the charter period. If somehow the component model got escalated to where a year from now we have a spec and implementations, if it were not in the charter we couldn’t publish a spesc fo rit. Teh standard charter period for WGS is 2 years, but I”m asking for rechartiering for 3. They may say only 2 but I asked for 3. So if it’s 3 there’s a real possibility that well be ready with the spec for this in the chartering period.

AVK: yea i guess it makes sense and as Luke said it still has to go through the sages in the CG, it doesn’t matter quite so much.

MS: some of the other informal feedback was a question of, how much of this applies to browser runtimes? I said everything. The core spec is agnostic to the browesr runtimes. The web API is specific to browers, but there’s nothing that’s not applicable at all. Including the component model? Although it does seem like its a bigger priority for non-browser, the anticipation is that it will eventually in browsers. That will matter to the AC reviewers. Should we say that the CM is expected to be implemented in browsers? Would be to pre-empt asking and make it clear, but also the sense of scope for the implementers.

AR: I kind of expect that eventually we will have something that’s not relevant to browsers. It seems inevitable. Should we consider that a problem? Should we set a precedent earlier rather than later? How should we prepare for that situation?

MS: it’s hypothetical at this point. We talked about WASI and the chairs thought that we didn’t want to put WASI in the charter, so we left it out. But I do think there are W3C stakeholders that have less interest in what happens outside the browser. If the focus of a group is seen as primarily working on stuff where browsers aren’t a priority, then the group might be less of a priority for some AC members. 

AR: yeah I don’t expect that we get to a point where the majority of things aren’t relevant, but there might be a few things that aren’t. The group as a whole i assume would still be interesting. WASI does seem weird since its’ a decent size effort

LW: the challenge of WASi si that its a bunch of different things. We don’t want to just make a blank check to add any kind of API. we’d need to list specific things and it’s too early for that. E.g. sockets would be a big problem for browsers, but is very useful outside. Also our stage process will need to be adjusted before we can really get it. It’s still early and we’ll need discussion. Whereas the CM is pure compute, can add value or be polyfiled today. The reason for the charter might be like ESM, where browsers didn’t implement it for a long time, but there were polyfils and the standard was useful. So we want a stable thing that people want to produce, that can be useful even if browsers don’t prioritize. So we want to break the chicken and egg where browsers won’t implement until users want to use it, but users won’t want to produce it until there’s a reason. So I wouldn’t want to try to get a firm commitment to ship it, but we’d like to at least get to where it could happen, no objections on general principle.

MS: you mentioned the blank check thing. We can’t have things in the charter that are so broad that it’s an escape hatch to do anything they want. In practice, the company lawyers that review charters will call it out, you have to be more explicit. About WASI, it’s imaginable that if some standard is published related to wasi, its not necessary to publish at W3C. some other organization or no standards org the way you need for wasm; it’s possible. It could be W3C but doesn’t have to be. If there are specs targeted for other runtimes. We could still do that, theres nothing that prevents W3C groups from publishing things that aren’t targeted at browsers, there are other groups that do that. But wasm is both for now. But eventually if we want to put some things in a new charter that aren’t planned for browsers we could still do that.

AR: some clarity on granularity: is it more on the doc level or could it be that every proposal has to go intot he charter? 

LW: roughly the latter in the current charter, there’s a bullet that has e.g. stack siwthcing, GC, etc

AR: that does seem a bit inflexible, what does that mean if we introduce new proposals.

MS: if we come up with a proposal that’s not explicitly mentioned in the charter, it wouldn’t matter until we wanted to publish a first public working draft. The AC would review and we could get feedback. If they felt that it was radically different we’d get that feedback.

AVK: it’s always possible to recharter. You need to just strike a balance between the scope that you set, and pushback that ou might get

LW: realistically for WASI we aren’t in danger of going all the way to WG in 3 years

MS: the current scope seems accurate for the reviewers that we have.
For the CM, I can minimally add some links. I can add some langauge, if LW could help with that we can just push a couple of changes

LW: happy to help. To get clarity on what we want, do we want a self-contained description in paragraph length? Or something other format?

AVK: I think a paragraph elaboritng is fine. But it’s also fine for things to be links, you could link to explainers and there would be the sense of scope

LW: so they don’t need to be totally self-contained. 

AVK: yeah thats what you see in other groups.s e.g. webappsec WG. they have text blurbs and links

MS: ok so minimally we can add a link for CM. we could also do this for other things too, e.g. you mentioned threads. We can look into adding more links.

MS: I’m available on the wasm discord, and the charter is in a github repo: https://github.com/w3c/charter-drafts/blob/gh-pages/2023/wasm-wg.html

PP: will there be some discussion in the larger W3C after this? Sorry, missed the beginning of the meeting.

MS: it will go to the advisory committee with all the company reps, they have 28 days to comment or object. If there is an objections then well respond to the comments and resolve. But hopefully it won’t happen.

AVK: since the charter deliverables are essentially gated on the CG process, it might make sense to tsay the group “may” deliver these things, since it might not happen

LW: that could be a general clarification, say that these things we will attempt to hand down via the CG process, and the WG will consider after that.

MS: at this point I think there’s no link in the charter to info about the CG stages. So maybe that could be helpful. In normative specs, we do have stuff we’ve already published and say we’ll deliver new revisions of those, and it also says we “will” deliver these other things. We could say “may”.

LW: yeah we could mention in “deliverables” and reference it later in the CM

AVK: yeah if LW will do a PR we can just review and discuss it there

(this was https://github.com/w3c/charter-drafts/pull/444)
"
main/2021/CG-02-16.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 16th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: February 16th, 5pm-6pm UTC (February 16th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. [Branch Hinting](https://github.com/WebAssembly/branch-hinting) (Yuri Iozzelli) [10 min]
       1. Poll for phase 2
    1. [Fixed-width SIMD](https://github.com/WebAssembly/simd) (Zhi An Ng) [10 min]
       1. Poll for phase 4
    1. [Web Security Content Policy](https://github.com/WebAssembly/content-security-policy) (Francis McCabe) [10 min]
       1. Potential Poll for phase 1?
    1. [Memory64](https://github.com/WebAssembly/Memory64) (Wouter van Oortmerssen) [10 min]
       1. Poll for phase 3
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees
Wouter van Oortmerssen

Ezzat Chamudi

Deepti Gandluri

Luke Imhoff

Jay Phelps

Lars Hansen

Rick Battagline

Zalim Basharov

Nick Fitzgerald

Yuri Iozzelli

Francis McCabe

Luke Wagner

Paolo Severini

Derek Schuff

Sergey Rubanov

SJG

Jbirch

Dan Weber

Jakob Kummerow

Petr Penzn

Flaki

Yuri Delendik

Mano Koukoutos

Andrew Brown

Steve Sanderson

Shravan Narayan

Arun Purushan

Mingqiu Sun

Ross Tate

Ryan Hunt

Charles Vaughn

Adam Klein

Andreas Rossberg

Asumu Takikawa

Slava Kuzmich

Emanuel Ziegler

Zhi An Ng

Daniel Wirtz

Ioanna Dimitriou

Ghislain Hude

Nabeel Al-Shamma

Ghislain HUDE

Pat

Keith Miller

Conrad Watt

David Piepgrass

Sam Lindley


### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

### Proposals and discussions

#### Branch Hinting (Yuri Iozzelli) [10 min]

YI Presenting [slides](https://drive.google.com/file/d/1oFxY2EZ9GC-xEmwlfyu7f1MjZ33InhZ4/view?usp=sharing)

AR: the main spec says that no engine is allowed to reject a module due to anything in the custom section. So if it’s malformed, just ignore it. That’s a requirement for custom sections in general.

YI: In particular, while the first few requirements listed here are easy to check because they are in the section itself, we validate everything except the branch section is correct.. I’m not sure how this interaction  should be. <Some missed details about validation>

LH: you have to validate the bytecode anyway, so the compiler can always reject something while it’s compiling. I don’t think it’s hard to validate the hints during compilation. Mostly it’s about preventing implementations from diverging. Don’t want to hold up the proposal but it would be nice to try to keep the implementations aligned.

YI: That’s why these are included in the slides, want to make everyone aware before poll to phase 2. Have a POC in V8 under an experimental flag - no tools support yet, will be needed to play with this on a real codebase - I have an initial benchmark, but would be nice to have more compiled examples that are useful

PP: Not an attempt to say it shouldn’t be done - couple of meetings ago we had a discussion about floating point modes where we had a discussion about wasm emulating the CPU, similarly we don’t find this in the CPU, a similar point here

YI: you could add more FP instructions to cover the cases; the original proposal had instructions for branch hints, more in line with modeling it as instructions. But I think there’s a need for this kind of behavior since right now the wasm code isn’t directly executable. We found real issues with very unlikely branches that made the generated assembly very suboptimal. Also since the wasm control flow is structured, there’s no good way to place blocks arbitrarily.

PP: I don’t have all the background on the issue, you could think about it as different semantics for codegen - I’m sure there’s a good reason this is being proposed - you would have to put this through tools - there is no hardware that supports this - often the compiler decides this ahead of time and it doesn’t get to the assembly code, just a point to note nothing to block

YI: When code becomes machine code it disappears, this becomes a meta section - another difference to FP is that this doesn’t change the semantics of the program in any way it shouldn’t be observable by a wasm program

WV: I have similar concerns to Petr. Last time we voted on phase 1 there was quite a bit of discussion about whether this can be something purely in the tools. We talked about looking for real-world benchmarks with significant gains. I’m not sure we have enough information there to go forward.

YI: I agree that there aren’t real world benchmarks, did this with a simple loop in V8, there’s a difference but it’s a synthetic benchmark so it’s not representative of anything - working on a codebase which will give 5-10% difference, the way we

DG: we’re about 7 minutes over for this item. Are there other folks who feel that benchmarks should be required for phase 2, or something that can be done after that. Are there opinions on that?

AR: when we discussed SIMD, there were some folks who wanted to see number first.

DG: we were stuck at phase 2 for a long time while we gathered that data. In that case we knew we wanted to do it but didn't know exactly which instructions.
I’m not sure if phase 1 vs phase 2 makes the big difference here if the issue is just tools, it will still be on the champions to try to motivate some tool support.

YI: not sure the concerns that were raised are shared with the group. If there are issues about the exact shape of the proposal, i will still go on because we can fix a few things later. Issues with the proposal itself, then we can talk more about it.

DG: we should probably talk more about it in a followup meeting. Next is fixed-width SIMD


#### Fixed-width SIMD (Zhi An Ng) - [slides](https://docs.google.com/presentation/d/1N47ZnjSlW_X9euJqlpO0ZoX1jAUmznE3J8vU3DwT8W8/edit?usp=sharing)[10 min] 

DP: I”m curious by what you meant by “poor lowering”?

ZN: i64x2 min/max lowers to 9 instructions on x64 - so the Intel lowering does not match the semantics of ARM or the scalar versions, we have to pick or one or the other - heavily feature one or the other - that’s an example of poor lowering - unsigned comparisons are not well supported until AVX512, so that’s not sufficient

PP: one small point: some instructions with somewhat questionable lowering were still added when there was still consensus that they were needed

DG: yes, when they were heavily motivated by application use cases and still had good speedups, they were added

LI: what was wrong with prefetch?

ZN: Prefetch is tricky for specification, if you prefetch out of bounds it’s an error - a no-op is also valid - that makes it hard to specify in terms of normal you don’t really want to spec a no-op - a little bit of tension

TL: beyond the spec issues, we did prototype prefetch and benchmark it, but the results weren't good


PP: They’re heavily biased on architecture

DP: why is prefetch part of this? Isn't prefetch something you could do separately from SIMD?

ZN: Native architectures have added this with SIMD instructions, so based on this feedback - in SIMD there’s usually a stride where you don’t want to prefetch linearly - I believe someone actually brought it up - will add a link to the notes, and take a look at the issue

**POLL: Push the SIMD proposal to phase 4**

|SF|F|N|A|SA|
|--|-|-|-|--|
|17|18|0|0|0|


#### Web Content Security Policy (Francis McCabe) [10 min]

<TODO FM: Add slides>

CSP is a policy that the browser enforces, allows publishers to specify what they want to do with content, usually specified as a URL. You specify whether you want to allow a particular site to be loaded from (another?) web page. There isn’t currently a policy for wasm so it’s typically tied to ‘unsafe-eval’ from JS. This is problematic because many people would like to use wasm but not allow ‘eval’ in JS.

FM: Concerns for polling can be that there will be no spec changes here, except that we will make a recommendation to a different group

CV: I’ve got a little more background/ I’m actually the one who filed issue #7 about this. Firefox just allows wasm, doesn’t gate it behind unsafe-eval. Chrome allows you to use CSP with unsafe-eval as long as you’ve loaded in a worker that has unsafe-eval supported. So you can send the module across, but safari doesn’t allow that. So basically we have the worst-case where every browser does something differently and the workarounds are incomplete. This goes back to shipping in 2017 so that’s probably why the phase 0 proposal has a repo. 
I think wasm-eval is a good approach to get something easy to agree on and implement. This is a risk for recommending wasm as a solution, since it makes it difficult or incompatible with CSP.


FM: To follow up on that -= there’s a regular stream of people that complain that they don’t want to use unsafe-eval, they do want to control this in JS, there’s a substantial set of people that want this

CV: you start to see.. E..g. libsodium, how people discover this is that they grab a Wasm lib, and install into their stack that is more locked down, and realize this is not going to work.

FM: Is Phase 1 the right thing t\

DG: I think phase one seems right, generally it’s pretty low bar, it’s fairly exploratory

DS: generally we thought of phase 1 as, do we agree that this is a problem worth solving.

LI: Isn’t this the same thing as the mime type registration?

DS: similar in the sense that we are not producing an addition to the Wasm spec per se, but something we want to get agreement in the CG about. Francis already laid out what the product will have to be produced, not a spec but something else. Which means not all of the phases will apply. Couple of options, do it ad-hoc, make it a champion responsibility to see what is proposed matching the process.

FM: the product is a letter of recommendation to the AppSec WG

BT: There will be WPT tests that come out of this, they don’t necessarily need to be hosted in this repository - some of the phases map on to what we need to move forward. Even though stuff will land in different repos it matches our phase structure 

DG: 1 more minute left, if there are no other concerns, we should poll for phase 1.

**POLL: CSP to phase 1**

|SF|F|N|A|SA|
|--|-|-|-|--|
|13|10|7|0|0|


#### Memory64 (Wouter van Oortmerssen) [10 min]

WO presenting [slides](https://docs.google.com/presentation/d/1h4OA-p6CE_6Xi4rdl2ZlxRY1Zgy00KW3mEqGD1bsFwU/edit?usp=sharing)

KM: did you test if there was a performance difference between 32 and 64 here?

WO: We’ve been talking about this, do not have tests yet - as the V8 work progresses we will get those numbers - this will be slower because we can’t do checks with guard pages, nopt sure how much slower it’s going to be - even if it is significant then doesn’t mean we stop working on it, but more to figure out how to move it forward

KM: if it’s super significant, do we think a lot of people will still want to use this?

WO: If it’s outrageously slower, then most people would want to target wasm64, which is unlikely

KM: we have both [bounds check and not] on 32-bit and we think probably 5-10%

WO: Most people, or most use cases where they want to work in a 64-bit world, it may be an okay price to pay

KM: figuring how to do better memory management, in our current world we have no way of releasing memory. Don’t know if we should gate on that, wonder if we should consider that.


WO: You mean shrink memory? I have an issue open about possibilities about memory reservation as opposed to .. does that sounds like it would be beyond the MVP or the separate proposal

CW: in recent discussion, the person was saying, this is a feature they would like even if 64 bit didn’t exist, could be a separate proposal.

KM: Totally agree that it’s likely to be a separate proposal, overhead is so much higher

WO: Huge fan of bringing memory mapped version of Wasm, happy to chat more about that independent of this proposal for now

RT: i’ll mention that there are some researchers interested in working with wasm on type system ideas for eliminating bounds checks

WO: At this point issue#3 is most important - we concluded on one type of bounds checking, do those options preclude the optimizations

RT: Will point folks to that issue

??: Is there a link I can read the whole scheme that we use for this

WO: <link to issue 3> and overview text in the repo

DG: I think we’re ready for a poll

**POLL: memory64 to phase 3**

|SF|F|N|A|SA|
|--|-|-|-|--|
|6|22|5|0|0|


DG: one followup from this meeting that will be added to next meeting is more time for branch hinting.

### Closure
"
wasi/2019/WASI-05-16.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the May 16 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: May 16, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Meeting schedule
        * We have one report of a scheduling conflict on Thursdays. How do
          Wednesdays at this same time work?
    1. Review of action items from prior meeting.
    1. Updated [High-Level Goals] proposal for WASI
    1. The MVP
        * Module system issues: https://github.com/WebAssembly/WASI/labels/module_system
        * Versioning vs. feature detection
        * [Semver]?
            - What about wildcards or other requirement specifications?
            - If we do semver, we'll be looking for a volunteer to look into
              the specifics and make a concrete proposal.
        * Weak imports?
            - See https://github.com/WebAssembly/WASI/issues/36 for some ideas.
        * Namespacing schemes
            - ""wasi:name:semver"" (https://github.com/WebAssembly/WASI/issues/2#issuecomment-482630978)
            - Other suggestions?
    1. Standardization phases
        * https://github.com/WebAssembly/WASI/issues/38

1. Closure

[High-Level Goals]: https://github.com/WebAssembly/WASI/blob/high-level-goals/docs/HighLevelGoals.md
[Semver]: https://semver.org/

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

2019-05-02 WebAssembly CG WASI Subgroup Video Meeting Notes

Agenda: https://github.com/WebAssembly/WASI/blob/main/meetings/2019/WASI-05-16.md

Attendees:

Dan Gohman
Thomas Lively
Luke Imhoff
Sergey Rubanov
Wouter van Oortmerssen
Jacob Gravelle
Mingqiu Sun
Yury Delendik
Ryan Levick
Paul Dworzanski
Alex Crichton
Derek Schuff
Mark S. Miller
Sam Clegg
Nick Fitzgerald
Arun Purushan
Mark McCaskey
Dan Gebhardt
Paul Schoenfelder
Till Schneidereit
Johnie L Birch Jr
Luke Wagner
Pat Hickey
Tyler McMullen


Meeting notes:


Meeting schedule
We have one report of a scheduling conflict on Thursdays. How do Wednesdays at this same time work?
Conflicts on Wednesday for Google WASM team
Later on Thursday would work, but it doesn’t work for Europe
FINAL: Sticking with same date/time

 Review of action items from prior meeting.
    
Dan: Module system issues are up.
Dan: Also took an action to look for an in-person meeting time, not complete yet.
Ryan: I went through and summarized issues in the WASI issue tracker. We can continue to evolve the organization scheme. I looked at moving issues over from the wasmtime tracker and we may need to dedup them first.
Dan: We will follow up offline.


Updated [High-Level Goals] proposal for WASI

Dan: Derek had a question about the meaning of namespacing. My sense is we don’t need to be terribly specific here.
Derek: I may have added some more words in there, but I think we’re all on the same page.
Dan: We can merge the High Level Goals as is, and folks can do PRs to elaborate on it. Do we have consensus to land it?
Luke Imhoff: It says “through a capability based API”, does that imply a focus on security?
Dan: I think capability-based implies that
Mark Miller: Capabilities enable a design for security, they don’t imply security
Dan: Does the current wording capture enough of the intent to build a secure interface?
Luke I: We want to emphasize that capabilities can be subdivided, are unforgable, so that we’re not no better than posix.
Mark: We could write down the important capability design principles elsewhere.
Luke I: Is there an article that summarizes your current thinking on this?
Mark: There’s related topics on object capabilities
Till: We didn’t go with object capabilities because not all languages are capable of expressing those.
Mark: Object capabilities are not specific to programming language object level capabilities. There are operating systems that use object capabilities
Luke I: Lets merge what we have and make a PR later that describes what we mean by object capability?
Mark: I will find some writing on object capability principles to link to
Till: So we can land what we have now?
Luke I, Mark M assent
Dan: I will take an action item to land that.

The MVP
Module system issues: https://github.com/WebAssembly/WASI/labels/module_system
Versioning vs. feature detection
[Semver]?
What about wildcards or other requirement specifications?
If we do semver, we'll be looking for a volunteer to look into the specifics and make a concrete proposal.

Weak imports?
See https://github.com/WebAssembly/WASI/issues/36 for some ideas.
Namespacing schemes
""wasi:name:semver"" (https://github.com/WebAssembly/WASI/issues/2#issuecomment-482630978)
Other suggestions?


Dan: Looks like things got renamed and moved around a bit, lets skip forward to semver.

Dan: Semver is the default choice, but the question is how you apply it, what sort of wildcards and specifiers you use when encoding dependencies.

Dan: What im looking for is someone to make a proposal about how the various details of semver wildcards work, and bring it to the meeting next week. I know there are many options but I don’t know which one to pick.

Mark: To clarify is this for all of WASI or for the various modules?

Dan: The goal is to specify the foundation of how modules will interact, this is an important part of that. We will probably have opportunities to revise it

Luke I: How flexible will we be with regards to revisions to the interfaces? E.g. fixing bugs means breaking binary compat

Dan: We have to assume that we can impose our own rules for how strict we are about bugfixes. We’ll just have to make judgement calls as we go

Sam K: Will the version be in the import name themselves?

Dan: That is an obvious place to put it. <someone> has a proposal but they’re out sick today

Till: This would make it hard to make minor updates, because then you’d have to change names every time a version changes.

Dan: Resolution of imports happens in the VM. So we can program how that works

Till: If resolution happens in a client they may not have a complete index of all modules available.

Dan: The current proposal (wasi:package:semver) assumes all modules are packaged & available together. If we want to have something more elaborate - a url, a hash string, those are possibilities.

Luke I: Its desirable for the resolver to have some way to find other versions, so that you can specify dependencies as “greater than this patch but not incompatible”

Till: If resolution has to happen using a map, you can put the version numbers in the map, rather than in identifiers

Dan: Resolution is necessarily not the host, some earlier packaging step can occur that takes advantage of semantic information

Luke I: is it always a precise version in the import name? (some examples given)

Dan: We should make a convention about whether the VM is going to download modules for you, or the VM is going to just resolve links as they exist

Tlively: It sounds like we have differences in opinion about who should be doing resolution of version numbers to packages, and where packages come from. Before agreeing on specifics we should figure out the user story and what goals we’re trying to achieve with the versioning scheme

Dan: Sounds good, does anyone want to propose a story or a set of scenarios to look at?

Pat: I can provide a story for our use case, but I want to get input from others as well.

Dan: Moving on to the next item, Weak Imports. In Issue 36, there is discussion about not wanting a system that forces an additional indirection e.g. through a GC Ref.

Sam Klegg: In your example of importing v2 features and then an optional v3 feature

Dan: V2 to V3 is a major semver bump, If it was a minor bump maybe that would be OK. What about e.g. most features from 2.2, and this new feature from 2.3 would be nice to use if its available, but if not I’ll fall back.

Luke I: If you’re importing from different versions are those versions separate instances

Dan: That’s up to the VM and the module API

Sam K: We don’t want to have two versions of the same module instantiated to satisfy a dep.

Sam K: Would you put a weak dependency on an entire module, or just on an import?
Dan: I think we want the ability to do both. E.g. If we have a filesystem, then we will use it to do stuff, and also if the filesystem supports this individual extra feature, i’ll use it. In both cases we want to be able to fall back.

Sam K: Seems like lots of overlap with the semver proposal

Dan: Semver just gives you the minimum requirement to be functional, weak imports are for things that may or may not be present

Luke I: Semver protects you from the ABA problem, where the function name and signature stays the same but the functionality totally changed.

Dan: You could have a weak import, and the weak import itself could have a semver tag on it, or other semver relation operators. I’m looking for a general sense from the group whether this general idea is what we want to pursue. Out of all the proposals it has the advantage of not implying indirection.

Luke I: Does this mean that wasm is going to have to support weak imports so that there is no indirection cost?

Dan: It would be a requirement of the engine to implement imports so that there is no indirection cost.

Sam K: We’re explicitly trying to not push a new concept into the core spec

Dan: Is there consensus about not trying to push new concepts into the core spec?

Jacob: are we going to expect this in web embeddings?

Luke Wagner: You could polyfill this on the web using javascript stubs

Luke Wagner: Rather than mangling the string name maybe you could use a regex to carve out what part of an import name is the name, and the rest is the wasi-specific specifiers like version, weak

(Some discussion on details of those ideas)

Dan: Is the basic idea of weak import, somehow mangled into import names, 

Jacob: We could use custom sections for this.

(Some discussion of how you might use a custom section)

Luke I: If the custom section gets stripped thats a bad sign about your toolchain in the first place. I prefer this to string mangling, it doesn’t eat names that now become reserved

Dan: There are escape characters and ways we can make name mangling work.

Tlively, Luke I, Sam C: all in support of using custom sections as opposed to name mangling

Luke I: Import maps are separate from the module itself, or you could put a default map in at build time, but the idea is that it makes polyfill possible

Sam C: There would be a lot of repetition of these annotation in the import names, custom section could solve that

Dan: Pushback that custom sections are for non-semantic information

Paul S: Would this mean we now require those custom sections?

Sam C: its extra information that says the module would like to have the following version, the following weak sym. The engine could throw it away and it would still possibly work

Jacob: This is roughly what we’re trying to solve in the webidl proposal as well, we’re specifying a custom section.

(Some discussion)

Sam C: You’re describing the environment in which you’d like to be run, and the engine may be able to provide the right implementation there

Luke I: tooling is easier with custom sections, you won’t have to change imports and byte offsets and so on.

Luke I: The import map proposal says to just specify the bare name to import, and 

Dan: Does someone want to champion writing down how using a custom section for this will work?

Sam C: I will write something down for the next meeting [action item]

Standardization phases
https://github.com/WebAssembly/WASI/issues/38

Dan: Derek wrote up a proposal of phases (linked above). In the core wasm they use the concept of web engines implementing a proposal as part of gating moving it forward. We have more non-web embeddings to consider here.

Luke I: We should document why we made certain arguments about compatibility as we go along.

Dan: Rationale is important, should that process live in the phase document?

(?): Maybe when we move to stage 3 with a proposal it should come with an agreement about what stage 4 may be.

Derek: My desire was just to come up with something that mirrors the CG without specific opinions on exactly how. What do we want the role of the subgroup vs the CG to be? Should the CG just rubber-stamp things?

Derek: We haven’t talked about the goals for the WASI api spec, should it go through the W3C WG process?

Dan: That is what I want us to do.

Till: wrt where it lives exactly, it could be a sibling to the JS API.

Dan: this is a non-web use case and W3C is a web org but I don’t think its a problem in practice.

Derek: This is something between the core spec and the JS API. WASI will build on top of core. Maybe some of the WASI loading semantics will be baked into the JS spec, or maybe not.

Dan: How the individual module specs get packaged into a spec document is something we can resolve in the future.

Till: Volunteers to champion the phases document
"
main/2021/CG-06-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 22nd video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: June 22nd, 4pm-5pm UTC (June 22nd, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Discussion: [WebAssembly, Unicode and the Web Platform](https://github.com/WebAssembly/design/issues/1419) (pre-recorded, see linked issue; [slides](presentations/2021-06-22-wirtz-webassembly-unicode-web-platform.pdf)) [20 mins]
    1. [Deprecation of cross origin module sharing](https://github.com/WebAssembly/spec/issues/1303) [20 mins]
    1. [Wasm/JS API integration for resizable buffers](https://github.com/WebAssembly/spec/issues/1292) (Shu-yu Guo) [20 mins]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

###  Introduction of attendees
Jacob Mischka

Deepti Gandluri

Dan Weber

Rick Battagline

Sean Westfall

Chris Fallin

Lars Hansen

Nick Fitzgerald

Paolo Severini

Garrett Gu

Saul Cabrera

Ioanna Dimitriou

Conrad Watt

Dan Gohman

Sam Clegg

Jay Phelps

Ezzat Chamudi

Alex Chrichton

Francis McCabe

Paul

Luke Wagner

Daniel Wirtz

Slava Kuzmich

Andrew Brown

Jacob Abraham

Piotr Sikora

Andreas Rossberg

Camille Lamy

Lutz

Thomas Lively

Kaith Miller

Emanuel Ziegler

Asumu Takikawa

Mingqui Sun

Ryan Hunt

Jakob Kummerow

Rich W

Sergey Rubanov

Aaron Turner

Daniel Hillerstrom

Flaki

Alon Zakai

Sam Lindley

Jlbirch

Heejin Ahn

Peter Heune

Ross Tate

Dan Gohman

Connor Hicks

Zalim Bashorov

David Piepgrass

### Find volunteers for note taking

Acting chair to volunteer

### Proposals and discussions

#### Discussion: [WebAssembly, Unicode and the Web Platform](https://github.com/WebAssembly/design/issues/1419) (pre-recorded, see linked issue; [slides](presentations/2021-06-22-wirtz-webassembly-unicode-web-platform.pdf)) [20 mins]

DW: Curious about the thoughts of other language implementers - would like to hear about other opinions?

FM: IT seems that you are recommending we have unicode, except not actually unicode and instead we have whatever we want?

DW: The unicode standard says that in normal processing you have isolated surrogates?

FM: It says it’s undefined what happened when you have that.

DW: Maybe when you transfer it, if you split a string and separately compile it, and pass the isolated surrogate around.. We are preventing the first part being correct. When we call a filesystem API or networking API - we want this to be well formed

FM: First of all, our focus is not on languages but on the overall ecosystem - languages are a means to an end - the real focus is on supporting a potential ecosystem - supporting modules and publishers, essentially being a marketplace of interchange. One thing that IT is not focusing on internal structuring of a library or an application - if you are structuring things internally, there is a much greater sharing of knowledge that you would expect in the ecosystem - this is reflected in the choice of type language, it is very limited, there are things you can’t express, there is no intention of supporting this. Hashmap is not something we will be supporting, for example- if you were to use IT to partition and put it back again  you would be in a lossy situation just because of the restrictive types - this is pointing to a misunderstanding of where IT fits into the scenario. The archetypal situation is at the boundary when you are going from using your code to someone else’s at the boundary. You could be using it for other purposes, but that is the picture we are aiming at and it is going to reflect our choices. Picking strings - picking a format that is compatible across all boundaries. We are not assuming a networking interface, just a boundary - having a well formed notion of a string is useful because everyone knows what to expect in that case. Ill-formed string is only one of the potential ill formed types, I would argue that if you were supposed to communicate that odd type with someone else, you may have some trouble with it - IT has some other components - resource types for examples - if you were trying to communicate an odd type to yourself.. You will have trouble with it

KM: I’m curious- you mentioned that this is an ecosystem consideration. I would expect the DOM to be a large part of that. AFAIK DOM engines primarily support UTF-16, so perhaps it would be worthwhile to have a low-cost bridge. Is that part of the disagreement?

LW: For those sorts of the DOM API, the place to solve that is in the JS API as these are uniquely specific problems. You just don’t know in the component model

KM: The task might be very large because the surface area of the DOM is very large. Millions of lines to change.

LW: I didn’t mean that Web APIs should change- The JS API would be a good place if you wanted to turn UTF16 into the DOM string

DW: AS is being used in non-web cases as well - we could annotate WASI APIs as well, we could annotate.. But it is not very convenient, we want to have a solution that works in either case, without having to worry about overhead etc. If you look at the inverse, where you use AS one side and JS on the other side you end up with a double reencoding. We can solve this in the Web API, but the problem runs deeper than that, we should be able to solve it better

CW: There are two issues here: first if you have a WTF-16 string, passing through the boundary is lossy. Second, you have a double re-encoding. The latter could be solved in a lossy way via UTF-16 support.

DW: That’s already significantly better, it still won’t be correct - if that is all we can get 

DW: Possible future steps: continue discussion at future meeting, create IT subgroup, straw polls.

DG: Let’s continue the discussion in a smaller group and come back for straw polls in one month.

#### [Deprecation of cross origin module sharing](https://github.com/WebAssembly/spec/issues/1303)
<CL Presenting - TODO - add slides>

FM: What is an agent cluster - it’s an HTML concept - in JS it is the thing that could have synchronous access to each other - if you are completely cross origin, cross site, this is what determines the execution context, if you have different agent clusters, you have different contextts

CW: IT basically defines the group of shareable objects that we can transfer between

CM: Can’t you post message them?

LH: Yes, but the shared object themselves are limited to the agent cluster.

JP: Is this about synchronous sharing, or transferable objects via postmessage

CM, KM, DG: Yes, this is just about postmessage.

DG: The other good thing to note is that among browser vendors, there appears to be consensus that this would be a good thing to do. CM, is that correct?

CM: We have broad consensus, we haven’t done an explicit call for position, but the general responses to deprecating document.domain have been positive

JP: In the future to share cross origin, you would need to download twice, compile twice, and instantiate twice

KM: correct, but there is very low usage

KM: IS that % of pages loaded, or the unique pages?

CM: Pages loaded

DG: We would be disallowing postmessaging modules across modules within the same agent cluster. Does anyone object?

JP: Could see myself doing this, but acceptable compromise for the goals mentioned

FM: What’s the action item that we would be taking?

KM: It would be a change in the HTML spec.

DG: There may be some editorial things to change in the JS API as well, but I don’t think this would be a meaningful change to the JS API.

CM: The first change could be in the wasm spec where we check for Origins instead of agent clusters. 

DG: Sounds like there are no objections - concrete action items:
Change Wasm spec to mention origins instead of agent clusters
HTML change
Engine implementations will need to change disallowing post-message of wasm modules across cross-origin bounbdaries

####  [Wasm/JS API integration for resizable buffers](https://github.com/WebAssembly/spec/issues/1292]) (Shu-yu Guo)

SG: Recap: Had presented PR #1300 on integrating resizable buffers. Feedback was to come back after stage 3 in TC39. There are some API surface changes on the JS side. Previously the resizable buffers would be separate constructors. Now we reuse ArrayBuffer and SharedArrayBuffer and pass an options bag to make them resizable. None of the semantics have changed.

SG: Currently you can get a buffer from the WebAssembly.Memory object. This proposal adds a new `resizable` getter to those buffers. If you want to make it resizeable, you call `toResizableBuffer`, which vends a new buffer and detaches previous buffers. <Runs through example code in PR>

SG: The only change from last time is that instead of vending two array buffers, there will be one ArrayBuffer

CW: If you call toresizable twice, it doesn’t detach correct? 

SG: Yes, if you call it twice with no intervening `toFixed` calls, then it shouldn’t unnecessarily detach the previous one.

AZ: When you grow, it no longer detaches if it is a resizeable buffer, and on the JS side the views continue to be usable?

SG: That is correct, got a review from littledan - some open questions should we hardcode the length? More reviews welcome
SC: Is there support for shrinking? The JS one can, but the Wasm one can’t?

SG: Yes. These buffers are designed to be implemented as in-place grows. When you resize it will commit the physical pages at the end of the reserved space. Shrinking is not guaranteed to give the pages back, but semantically it is allowed and will track the length for JS-vended buffers. Shrinking is not allowed in WebAssembly-vended buffers.

DW: HAs it been considered that if the underlying memory is resizeable on the wasm side (e.g. when the initial size is not the max size), you would get a resizeable buffer on the JS side - has this been considered? 

SG: In the previous iteration of the PR because we were proposing a new kind of AB, the back compat concern was stronger because we can’t change the default behavior - given that it’s a different mode of the same type - maybe there is less concern there? The concern is back compat, we always want to vend resizeable buffers when it is coming from the JS side, but there may be code already in place, so it’s not worth making the backward breaking change

DW: Would be nice if it were possible, but I understand the back compat concern.

SG: It depends on who wants to do the legwork

LW: It would be highly probably that something would break, so we would have to walk this back anyway

JP: Anyway we could signal during instantiation that this is what we want? 

SG: That has been brought up as well, it makes sense to make sense the Wasm JSside constructor - it’s less clear how easy this would be to do just in the Wasm side. This is very specific to JS so we could explore the custom section portion of it, but not much enthusiasm there

CW: If they stick to the discipline, it always look resizeable on the side

SG: It would probably be taken care of by a flag in emscripten for example

DW: This would not work during instantiation because the start method would need its imports to use the resizable buffer.

CW: This is an ergonomic change for a self contained JS app that always wants to make sure that an AB is always resizeable

JP: It’s a bit of an odd API because of the mode switching. It’s non-obvious that calling toResizableBuffer would also affect the memory.buffer.

SG: CW help design this in the beginning, and I like where this is now - CW’s proposed hypothetical might work, it’s just more codegen, and I expect that this is more generated code, but not written by hand

JP: Agree. That’s why I’m not too concerned.

TL: Can you explain the back compat hazard again? 

SG: I’m imagining that there might be code that depends on getting the bugger, caching the bytelength, and assuming that it never changes

JP: Wasm memory will likely eventually shrink, so there’s a reverse risk as well

CW: Something may also depend on the buffer being detached after grow

DG: Any concerns from browser vendors or anyone else?

JP: Has it been considered that we might have Memory.resizableBuffer or some other way to get directly at the resizable buffer?

SG: That was one of the earlier designs, my initial design - CW among others convinced me that this is more ergonomic - it’s too weird to have two different JS ABs aliasing the same backing store, it sounds like a user and implementer footgun. 

SG: To be clear, want to explicitly move to the implementation phase so the work can be done in parallel with the JS work.

DG: This would be at phase 3.

SG: You all normally have another discussion to ship?

DG: Yes, or to say that it’s an official part of the spec at phase 4.
    
### Closure
"
simd/2021/SIMD-06-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 11th video call of WebAssembly's SIMD Subgroup

- **Dates**: 2021-06-11
- **Times**:
    - 4pm-5pm UTC (9am-10am PDT)
- **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this [form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking
1. Adoption of the agenda
1. Proposals and discussions
    1. Performance expectations of relaxed-simd instructions (Zhi An Ng)
    1. Eliding AND before lane shift (Petr Penzin)
    1. Update on flexible-vector opcodes (Petr Penzin)
    1. Opcodes for relaxed-simd (Lars Hansen)
    1. Documentation on SIMD instructions implementation (Evan Nemerson)
1. Closure

## Meeting notes

### Attendees

- Andrew Brown
- Arun Purushan
- Evan Nemerson
- Johnnie Birch
- Lars Hansen
- Petr Penzin
- Thomas Lively
- Yury Delendik
- Zhi An Ng

### Performance expectations of relaxed-simd instructions (Zhi An Ng)

ZN: As we were working on SIMD ISA we were setting expectations for adding instructions (performance, use cases, etc). We would like to have criteria for relaxed-simd proposal as well.

LH: would think that at a minimum we should show that relaxed simd instructions perform better than similar sequence of simd instructions, every relaxed instruction should perform better than the counterpart or the multiple instructions required, would be nice to see it in real applications

JB: main motivation is performance, not sure if there is any other reason? Benefit one platform, or all platform?

LH: we have performance traps on some platforms for some instructions, will be okay if it benefited only those platforms. If a platform already has good perf, it can’t be better

AP: agree, and add to that, consistent performance can use SIMD 128

ZN: if it is a single instruction lowering we probably don’t have to debate to much for adding it

LH: for example dot product has 3-instruction lowering on x86 until we reach AVX-512, the alternative emulation is horrible

ZN: so we have to compare emulation v.s. the lowering, see how bad the difference in performance is, and look case by case

PP: if we know simd has poor lowering, we don’t have to see symmetrical performance gains on all arch, since we are fixing it

### Eliding AND before lane shift (Petr Penzin)

PP: hardware discovery on relaxed-simd, Marat points out that XNNPACK detects that using abs of neg infinity. Shuffle operations have potential platform specific behavior, you can know which platform you’re on, and you can use different shuffles, do different things with inputs, is that something we support?

LH: this comes down to what SIMD programmers think serves their case, for feature detection proposal we talk about lowering to constant so we can compile away code completely. Don’t know if dispatching on specific hardware is what we want to do. Doesn’t sound like a problem really

PP: don’t feel it is a problem too, but curious if this is what we would rely on, or would we invent a different mechanism for dealing with platform specific behaviors

TL: personal opinion is not want to expose platform differences explicitly, even a feature detection bit for x86 or arm. Also have a hard time seeing that fly in the wider CG. For similar reasons, people will be skeptical about relaxed-simd. Would expect not doing anything to make platform detection easier. Would not recommend to users to detect it.

LH: at the moment, the relaxed instruction have a lowering on every platform, they can always use the instruction and expect to work

PP: has slightly different versions for the kernel, for x86 and arm, you can expect more of this for relaxed-simd, since instructions behavior different

EN: also talk on issue tracker for fingerprinting, with TL, leave it alone, don’t make it explicit feature detection API, always ability to do it, and do timing attacks, not worth fretting too much so people can’t detect their platform, you can’t control what people are going to do

ZN: undefined behavior, can’t prevent users from exploiting that, also we can use JS to detect platform differences 

PP: a lot of other fingerprinting surfaces

ZN: we still have to consider fingerprint, so far the instructions have been Intel v.s. ARM

PP: what about other virtual instruction sets?

ZN: fma with does fused, hardware supported is fast, otherwise using algorithm, muladd which uses hardware fma if available

PP: emscripten emits AND if you have lane shift

EN: shift left count and 15, question for TL too, not a compiler person, have seen compilers do much more insane stuff then eliding an AND, this isn’t calling an intrinsic, wasm i16x8 and is actually just implemented as vector extension left shift in LLVM, when you write that code, not sure at what point it converts to Wasm intrinsics

TL: it’s totally in scope for LLVM backend to remove the mask, we do similar things for other instructions, this is just a classic instruction selector optimization we should be doing

PP: do we carry this type of info, the shift carry and AND?

TL: not in the LLVM IR layer, where you can’t have shifts that are larger, forget about semantics, probably poison, in backend, when doing instruction selector, and generating Wasm instruction, and can make assumptions about Wasm instruction, will be doing this in the backend, Wasm-specific instruction selection. Was working on SIMD for a bit, recently doing other stuff, won’t get back on SIMD for a couple more weeks, because shift from Chrome 90 to 91, emitting recently changed instructions by default on LLVM, causing issues for users who want to continue to support end users with older Chrome. Until that settles down, will continue working on non-SIMD stuff. Intend to come back and burn down bugs in LLVM bug tracker.

PP: I can look up version we target, any SIMD tags we target?

TL: not a lot of simd bugs in LLVM bug tracker, best to look at Wasm bug and scan down the list, see which ones have to do with SIMD

EN: some bugs to file from optimizations coming from wav

TL: no rush

EN: will do them within next few weeks

### Update on flexible-vector opcodes (Petr Penzin)

PP: wanted to update on flexible vectors. When the whole thing started, we had a discussion about this. The way we presented flexible vectors, it would have lane tags, i8, i16, etc. But we try to add opcodes, it takes up a lot of opcodes, if you take every operation, make a flavor that is valid, if you try to check any bit is true for example. That bloats the space, we cannot be so generous with opcodes. We have to go back with untyped lanes, or polymorphic input types, no precedence for polymorphic operations.

AB: you’re coming up with more than 255, with just the instructions we want in the first pass

LH: prefix byte + arbitrary large leb

PP: yea, we take a whole byte anyway, that’s another option, we just go with it anyways.

LH: it’s not like the instructions will dominate programs

PP: yea, good point

AB: not an option to have 2 prefix opcodes?

PP: can make them as long as you want

AB: if you have fb and fc as prefix opcode.

PP: so far everyone try to use only one, you can use 2 bytes of opcodes

TL: opcodes have single prefix byte and the rest is leb encoded, probably we won’t want to do 2 prefix bytes, we already have an extensible system that everyone has decided on

PP: the way that you write those you can see the first byte

TL: using the leb you can draw out your opcode map

ZN: leb can have redundant bytes, so need to be careful

PP: if overall this is ok, will continue

AB: doesn’t sound like a big issue, opcodes will be longer

PP: sounds like a good direction, makes me happy

### Opcodes for relaxed-simd (Lars Hansen)

LH: since we are talking about encodings, what about relaxed-opcodes

LH: whether people were opposed to using the SIMD opcode prefix

AB: don’t mind that idea? Haven’t followed the feature detection proposal, quick updates on it?

TL: there are 2, conditional sections, considered dead and feature detection proposal is very basic. It is a decoding hack that has a block of instructions that may or may not validate. Basically an i32.const that depends on what features are available. Simple proposal, when we need it for these use cases, it won’t be too long to prototype and push it in CG.

PP: there’s a feature detection repo?

TL: yea feature-detection

ZN: so share the same prefix byte, but different opcode to existing SIMD proposal

JB: once relaxed-simd goes through, would it be considered optional or spec compliant need to implement

TL: i would like to get feature-detection in before relaxed SIMD. there is a profile suggested by Andreas Rossberg, feature-detection is sliced by what instructions are supported, profiles are split out by use cases, maybe block chain profile without float ops. The story around optional features or profiles, would like to make progress on that. Possible that relaxed-simd proceeds faster

LH: with feature-detection in place, it will be easy to add instructions, but the types make it hard

TL: feature-detection makes it easy to have optional instructions, as long as you don’t add new types. Decoding of v128 type is not optional, but what they can do is to lower any function that has a v128 in its signature can be an unreachable function. Something like that. Main idea is that the type remains non-optional, but you can do something trivial.

ZN: trivial for SIMD to support relaxed-simd

LH: true currently, not true for instructions like the dot product

TL: decoding is a different level of abstraction

ZN: we can pick an opcode for prototyping first, and change depending on progress of feature-detection

### Documentation on SIMD instructions implementation (Evan Nemerson)

EN: documentation, a lot of it in issue tracker that talks about how to implement instructions, maybe a wiki or separate resource

AB: quick comment, this came up in the past, we couldn’t decide what official place to put this information, we had some data, Arseny had good data somewhere on a GitHub repo

PP: put it in the simd repo

AB: Deepti mentioned the repo will be gone

PP: if CG decides to delete it and move it around. Wasm doesn’t have a developer manual. There is no precedent of documenting that yet

EN: more focused on using that information while people are working on the relaxed simd proposal, think that could be valuable for people after it is shipped, as V8 is updated, as RISC-V support is added. Valuable for people trying to write code to target simd proposals.

PP: this should be a developer manual

EN: i will be generating this data soon, should this be markdown, some static site

AB: what’s this data again?

EN: what instruction will be generated for i32x4 add, what instructions on ARM, x86

AB: what engines?

EN: a lot of commonalities, general guide, even if we add all v8 data, we can come up with new stuff. At least give people an idea, what is the best implementation we know of, it can evolve over time.

TL: bar is pretty low to add more information to the Emscripten site, know it is not the most neutral vendor-dependent option, separate website is a lot more overhead than putting on Emscripten

EN: can put data in separate repository, emsripten can pull that data in, can be somewhere it can be shared easily. So any project can pull that data in and use that in their documentation, as long as it exists. My plan is to look through issue tracker, and Zhi will help looking through V8.

LH: what’s your plan for instructions like shuffle?

EN: haven’t thought about that too much

PP: will need a lot of documentation for this

EN: can say for shuffles what builtin_shufflevector will generate on your platform, for everything shuffle like there is swizzle, it is Tbl in ARM. Shuffles are definitely and outlier there

PP: i can help with the shuffles side, it’s definitely going to be big, but there is a system to it, different shuffles we recognize, depending on the mask we do different things.

EN: the difficulty for shuffles should not prevent us from doing for other instructions

AB: any reason we cannot have a new repo called simd-developer-manual that we stuff this data in? If simd goes away it still lives in some official place?

EN: just time? I can create a new repo and transfer it easily.

PP: if you have time to create it, make sure you have permissions to do it

AB: easily to transfer

EN: yea public domain

PP: go through CG, 

ZN: appendix?

EN: instead of just simple markdown, have some structured data

ZN: write xml/json, then generate markdown

PP: not markdown right?

ZN: yea restructured text

ZN: check out zeux/wasm-simd

EN: yea we can hook it up with compiler explorer, and can have llvm-mca to get cycle times

ZN: we have some discussion on this, but difficult to run v8, get disassembly and codegen and map it back to SIMD instructions

EN: with SIMDe we don’t have to do that, will be easier
"
main/2023/CG-02-28.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 28th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: February 28th, 5pm-6pm UTC (9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Type system properties (see https://github.com/WebAssembly/function-references/pull/91) [Andreas Rossberg, 25 min]
3. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
 - Conrad Watt
 - Deepti Gandluri
 - Derek Schuff
 - Yuri Iozzelli
 - Jeff Charles
 - Jackson Hong
 - Ben Titzer
 - Yury Delendik
 - Ben Green
 - Thomas LIvely
 - Alex Crichton
 - Paolo Severini
 - Ilya Rezvov
 - Adam Klein
 - Alon Zakai
 - Daniel Phillips
 - Saul Cabrera
 - Ryan Hunt
 - David Piepgrass
 - Francis McCabe
 - Daniel Hillerström
 - Chris Woods
 - Andreas Rossberg
 - Jakob Kummerow
 - Sean Jensen-Grey
 - Marat Dukhan
 - Shoab Kamil
 - Zalim Bashorov
 - Rich Winterton
 - Heejin Ahn
 - Emanuel Ziegler
 - Brendan Dahl
 - Andrew Brown
 - Chris Fallin
 - Rich Winterton
 - Shravan Narayan
 - Sergey Rubanov
 - Asumu Takikawa
 - Petr Penzin
 - Jlbirch
 - Nabeel Al-Shamma
 - Kevin Moore

### Discussions

#### Type system properties (see https://github.com/WebAssembly/function-references/pull/91 ) 

AR Presenting [slides](presentations/2023-02-28-rossberg-principal-types.pdf)

(Principal types for wasm examples slide):

BT: Would it make sense to quantify type level parameters?

AR: yeah this is a meta-level thing. I’ll point to where I wrote it more precisely, it’s in the appendix of the fucref spec draft, more high level here. But you enrich the type grammar with these variables and quantify on the meta level rather than in every instruction.

(forward principle types slide):
FM: The principal type property, there’s a related one which is what people were debating about, which is whether the type of an instruction (sequence) was inferrable.

AR: I think that’s the same one; that’s basically what principal types mean, for every unit of syntactic composition, you can infer a type for that unit without relying on the context. In wasm we don’t have expressions, just instructions that can be composed more liberally. This forward thing corresponds more to what you have with expressions, where the things on the left are like the children.
Is there something you’d describe as inferrable other than this?

FM: I need to take it offline, need to think more

AR: this is the property used in meta theory about type inference, that every expression has a principal type and you can infer them.

FM: I thought every type was a supertype of itself?

AR: Reflexivity is included here

FM: so every type has a supertype

AR: yes but not necessarily a common supertype between 2 types, the interesting thing is when the two types are not the same

BT: on unreachable typing: this is one of those cases where type variables could be introduced?

AR: This has nothing to do with type variables, it only says there is some type. If you care about what are all the possible types of t*.. but this is independent of that. If you want to represent the principal split type, I haven’t thought about that yet, but you may need variables to represent them all.

PP: wrt typed references: we’re not talking only about really complex types like structs?

AR: The reference types, they could be anything. In the func ref proposal they can denote funcs, in the GC proposals they could be structs, arrays, etc, in the typed continuations, they could denote continuations etc., so more general

PP: so this applies to those proposals as well

FM: are you saying that the principal type property moves from desirable to essential?

AR: We should document it, that is the outcome we had, the desirable properties are the ones we have, we could drop that, but at least we have to think carefully of why you would need that

TL: I think this is a good direction to go in, good to have formal documented properties that are consistent with the discussions we’ve had, so it will be obvious which future instructions need annotations, for example. We also decided that this is the conservative approach, and can be revisited but this makes it explicit that we have this property now, written down, and if we wanted to reduce the number of type annotations, this is what we would have to give up. And it’s also great that we have the principal forward types property written down, since that’s the essential part.

AR: for each one in the desirable category, we know what would break them. For principal types, what would break it is omitting annotations. For GLBs  it would e.g. be multiple supertypes, you would need to go full intersection types to fix that. Decomposition you would lose if you weaken the type system of the unreachable code.

TL: as far as use of GLBs in the tools, you’re right that they’re generally less important but with contravariant function parameters, you want GLBs in some form.

AR: I agree that you’re bound to run into a wall with using LUBs there if you don’t have the GLB property

TL: Is there any way to weaken the current GLB property without LUBs? Or do they imply each other?

AR: technically they currently don’t imply each other, since we have explicitly declared subtypes. When you have contravariance it is in a declared relation. The subtype relation only depends on what you’ve declared. But you might want to declare it, and certain subtypes you wouldn't be able to declare anymore in the presence of contravariance if you don’t have GLBs 

BT: I don’t understand what contravariance has to do with that, isn’t oit checking is the type variance makes sense? 

AR: no if you need to synthesize function types, and you need to synthesize the LUB of 2 function types, you need to synthesize the GLB of their parameter types 

BT: I see

TL: Back when I implemented LUBs, I thought it would be complicated because of the contravariance, but it turned out to be simple because of supertype hierarchy so that makes sense

BT: so other than computational complexity, do any of these properties break down when we have multiple declared supertypes?

AR: The GLBs, unless you introduce them to 

TL: the LUBs too, right? How would you maintain LUBs if you have multiple declared supertypes?

AR: I think you’re right, they would break as well.

TL: I’m glad we have these properties written down so we don’t break them by accident

AR: the brute force way to preserve them is union and intersection types so you can write the GLB or LUB of anything, but then you get into expensive and maybe even undecidable type system. It's unclear whether there’s a sweet spot where you get all the advantages without breaking anything

TL: For composition/decomposition you didn’t go into much detail, does the formalism in the spec include when the right hand sequence consumes values before the LH sequence?

AR: yeah that’s totally fine, it applies to any sequence with any input/output type.

TL: in that case the type in the middle doesn’t exactly match, the output of the LHS is a suffix if the input from the RHS?

AR: If the whole sequence has an input/output type and that consumes something that if the right consumes something that the left doesn’t touch, the left type just passes it through and ignores it. There are these frame-like subtyping rules where t1* -> t2* can always be weakened to (t* t1*) -> (t* t2*) for any t* on both sides. It’s basically a supertype of the more precise one, it loses the information that t* isn't used

TL: how does this interact/what is the status of the proposal to simplify dead code validation?

AR: That proposal would break decomposition, as for the status Conrad? 

CW: the status is essentially when some critical mass of people decide that they’re fed up with thinking about the current system, we can push it forward, I think i’m not going to speculatively push it

TL: I think there isn’t a critical mass of people that think about typing unreachable code

CW: a lot of implementations that allow things that are not technically spec-conformant, e.g. webkit and Binaryen.

BT: Do you have those examples? Would be goot to add tho the testsuite

AR: We already have quite a few tests that check this, so do implementations disable them?

MD:: I’m not sure this applies here but one case is in benchmarks where the sequence serves as a sink for the value and needs to accept any value

BT: I think for that you should import a function that imports that type, and then it won’t get dead code eliminated

AR: If you don’t feed the value into that function it could be dropped or optimized away, so it has to get an input?

MD: The producer of the value can be dropped

AR: since this is only relevant for types that are not bottom, it’s independent, because why would you use unreachable code in benchmarks? So it’s not really related to unreachable code. As long as we keep the property that any type of a value can be a parameter of a function it should be ok. Do you have an example where this breaks?

MD: IT triggers internal compiler errors at times

AR: Interesting, would like to see an example

BT: I think all the engines pass the test suite as it is, but I don’t have 100% confidence that it’s exactly what’s intended by the spec. So it would be good to improve that so we can align on what’s driven by the tests.

AR: The negative unreached-invalid test checks for unreachable code, not sure about the exact tests in there, but there are tests there that test them, and I would be surprised if engines pass it without implementing

TL: that would be great, if it does cause production engines to start failing the test suite then we could get more eyes on it, then we could talk more concretely

CW: If they potentially already have bandwidths

AR: We also want to make sure the proposal introduces no new problems. I doubt it atually makes implementations simpler or less error-prone

CR: I agree, the point of this proposal was not to be saving lines of code in implementation or making it faster, just to make it simpler to think about.

DG: maybe we should present about what the state of this is?

CW: would be happy to do that when we have a free slot.

TL: I could also use a refresher on what the current rules are.

CW: Happy to lump that in, you can’t understand the motivation without all the context

TL: yeah I think I understand the new proposal, but not the status quo

AR: The status quo is that there is no special rule in the types system, the implementations needs a flag but the type system doesn’t care. I would say that the new version makes it more complicated

CW: It conceptually simplifies people trying to simplify linking their type systems

BT: I would also say that we should have a status quo bias, unless there’s a clear benefit in one direction we shouldn’t make a change. All implementations have special cases, so it seem unlikely to make a large difference to implementations.

CW: Jakob has a comment in chat

JK (chat): As far as implementations are concerned, we spend as much time getting unreachable code validation right as we spend on reachable code, and we are unhappy with this distribution. So to simplify implementations, it'd be great to actually drop _all_ differences between reachable and unreachable validation rules.

CW: we do have to make sure existing code keeps validating, so it’s best effort on that

AR: My concern is that you have far more places where you have to make a case distinction, and easy to make mistakes, whereas with the current status there are places where we have to do something but probably fewer because you don’t have two modes

CW: My impression is that a lot of implementations do it now by having a conditional flag based on whether the current code is reachable. My hope was to make that unnecessary. They may still have something like that but, hopefully it would still be simpler.

AR: Basically you would still have that flag, but you would use it differently.

BT: Little bit of complexity left over, because we introduced type annotations, implementations may have a little bit of cruft around whether they represent the spec as is in addition to the proposals in flight

AR: one of the problems we had was the interaction between the lack of type annotations and unreachable code, it made some of the cases harder to determine. I’m not sure that’s easier under the new proposal

### Closure
"
wasi/2023/WASI-11-30.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: November 30 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: November 30, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Vote: advance wasi-io to Phase 3
    1. Vote: advance wasi-clocks to Phase 3
    1. Vote: advance wasi-random to Phase 3
    1. Vote: advance wasi-filesystem to Phase 3
    1. Vote: advance wasi-sockets to Phase 3
    1. Vote: advance wasi-cli to Phase 3
    1. Vote: advance wasi-http to Phase 3

## Notes
### Attendees

- Alex Crichton
- Andrew Brown
- Ayako Akasaka
- Bailey Hayes
- Chris Woods
- Colin Murphy
- Dan Gohman
- Dave
- David Justice
- Friedrich Vandenberghe
- Guy Bedford
- Hung-Ying Tai
- Ivan Font
- Jeff Charles
- Joel Dice
- Kate Goldenring
- Kyle Brown
- Luke Wagner
- Marcin Kolny
- Matthew Yacobucci
- Michael Warres
- Mo Khan
- Nuno Pereira
- Oscar Spencer
- Pat Hickey
- Piotr Sikora
- Sam Clegg
- Syrus Akbary
- Thomas Trenner
- Till Schneidereit
- Timmy Silesmo
- Utsav Oza
- Wassim Chegham
- Yong He

### Notes

Pat Hickey: We have combined all of the agenda items on one slide deck that Bailey, Guy, and I created yesterday: https://docs.google.com/presentation/d/1uVlz5JnSWm2vldLiaseSACTS0UI1bVKiWt0CxNAs7_Y/edit?usp=sharing

Pat Hickey: Review of agenda

### Phase criteria and Consensus reminders

Pat Hickey: We are voting today to advancement from phase 2 to phase 3. This is a review of the criteria for entry requirement to phase 3. The portability criteria must already be met or there is a plan to meet this criteria.

Pat Hickey: Phase 3 essentially means finish building the proposal. In order to launch preview 2, the proposals must be in phase 3. This is have a guarantee of stability. Any future versions that are tagged, we give the ability to virtualize those APIs. This means only additions to preview 2.

Pat Hickey: The core WebAssembly CG has this procedure for how consensus is reached. We are only recording the aggregate votes. The chair determines if consensus has been reached.

### Wasmtime implementation status


Pat Hickey: Last time we gave an update on the Wasmtime implementation status. One thing that is different is that we now have a tag and github release that is marked as a pre-release. `0.2.0-rc-2023-11-10`. Since this date, we have identified two bugs in the http spec and a rename in the wasi:cli spec. Hopefully those are the last changes. Everytime we make a release candidate, we are hoping that this is the final version but leaving open for changes given implementation feedback.

Pat Hickey: We have approximately 99 integration test programs that exercise this set of proposals. The CI runs these test across many different OS’s and architectures including linux, macOS, and Windows. 

Till Schneidereit: In Fermyon Spin’s implementation embedding we have this snapshot of this RC. We have a full implementation of the previous snapshot. The November 11th snapshot, there should be very few changes. This is good validation for us being close to the finish line.

Bailey Hayes (in chat): wasmCloud has also embedded this set of proposals and can confirm they are working well

### JCO implementation status

Guy Bedford: In collaboration with Microsoft, we’ve been working on this for the last couple of months. When I last presented this, I gave the current progress on the status of the tests. Since then we’ve been able to make a lot of progress. We’re now at 80/99 tests passing. 

Guy Bedford: random, io, clocks, 100% implemented and tested.

Guy Bedford: For filesystem there is some new implementations and edge cases that need to be worked out. The same for cli.

Guy Bedford: For http we are now 100% complete. The trailers and request options we could support if we move to the optimized implementation in Node.js.

Guy Bedford: In the process we’ve been asking sort of all of the stupid questions, and we’ve created a set of issues. There are a couple of things that we need to add to our implementations in terms of flushing behaviors but we have been able to successfully get the information we needed to create implementations.

Guy Bedford: The remaining work includes `jco serve` and we’re on track to have this complete before the end of the year. The follow up to that is the low-level performance optimization for Node.js.

### Vote: advance wasi-io to Phase 3

Pat Hickey: If there are no other questions, we will begin. You just heard how wasmtime has met the portability criteria and JCO has a plan to meet it.

Marcin: What is the second implementation?
Pat Hickey: JCO

Marcin: Is it done?

Pat Hickey: We reviewed that it is nearly complete but not done yet. The phase 3 criteria only requires that there is a plan for this criteria to be met.

Sbc: The tests for wasi-io are 100% complete.

Guy Bedford: The missing implementations are related to POSIX systems and not the new Preview 2 idioms.

Till Schneidereit: It’s important to note that there are multiple wasip1 implementations and so this should be a known set of work.

|        |    |
| ------ | -- |
| **SF** | 18 |
| **F**  | 8 |
| **N**  | 0 |
| **A**  | 0 |
| **SA** | 0 |

Pat Hickey: The vote passes.

### Vote: advance wasi-clocks to Phase 3

Pat Hickey: Does anyone have clocks questions before we take a vote?

|        |    |
| ------ | -- |
| **SF** | 17 |
| **F**  | 7 |
| **N**  | 0 |
| **A**  | 0 |
| **SA** | 0 |

Pat Hickey: The vote passes.

### Vote: advance wasi-random to Phase 3


|        |    |
| ------ | -- |
| **SF** | 17 |
| **F**  | 5 |
| **N**  | 0 |
| **A**  | 0 |
| **SA** | 0 |

Pat Hickey: The vote passes.

### Vote: advance wasi-filesystem to Phase 3

Oscar Spencer: Is there a clear plan for how this portability criteria will be met?

Guy Bedford: The simple answer is that I prioritized getting http working over everything else. The cases are about working through the implementations for filesystem. It’s the preview 1 style edge-cases that we need to complete on. We have precedent of doing this in node code for WASI preview 1.

Pat Hickey: As the implementer of wasi-filesystem. The edge cases take some time to go through but it’s never been hard. We’ve never run into architectural challenges. Filesystems have edge cases and are messy. It’s about getting to a reasonably cross-platform place for these. If Wasmtime can do it, then so can JCO.

Kyle Brown: What is the dependency on clocks?

Pat Hickey: There are timestamps.

Sbc: That’s just a data type dependency.

Pat Hickey: Yup. 

Sbc: To be fair you could implement wasi-filesystem without implementing clocks.

Kyle Brown: It’s not a dependency of the interface but of the type.

Pat Hickey: In wasi-io pollable input stream and output stream are resource type so those associated methods will also be imported. In wasi-clocks, there are no resources.

Till Schneidereit (in chat): and the data types are structurally typed in the case of timestamps, so an implementation wouldn't need to pull in anything from wasi-clocks, really

Pat Hickey: You could have a fully conformant implementation that never depends on wasi-clocks by name.

|        |    |
| ------ | -- |
| **SF** | 13 |
| **F**  | 9 |
| **N**  | 0 |
| **A**  | 0 |
| **SA** | 0 |

Pat Hickey: The vote passes.

### Vote: advance wasi-sockets to Phase 3

Pat Hickey: The wasmtime test suite for this is very good in my opinion. The JCO implementation is half-done.

Pat Hickey: The dependencies on this are wasi-io and wasi-clocks. I genuinely don’t know where the wasi-clocks dependency is.

Wassim Chegham: The duration type is used.

Matthew Yacobucci: How is 1/2 done measured? By number of tests passing?

Wassim Chegham: More than half of the tests passing. The other half is for TCP accept and UDP send/receive. We will be working on them the next month.

Guy Bedford: It’s not an excellent measure. Each test program tests an entire set of end to end set of tests. We’re measuring the number of test programs.

Andrew Brown: Is it safe to assume that the Node.js API makes implementing this relatively straightforward but it will be more difficult to implement in the browser?

Wassim Chegham: Right now we are focusing on the Node.js implementation.

Guy Bedford: We don’t currently have an implementation for the browser. It’s not currently on the roadmap as it were, and have been focused on the Node.js implementation for the time being.

Pat Hickey: Part of the idea there is that if you are targeting a world, then you should target a world that will be able to run in the browser. The wasi-http world is very intentionally written to not depend on sockets so that components can target wasi-http and run in the browser. If you’re targeting a world to run in the browser, then you’re either going to rely on a tool like wasi-virt to have null sockets. This is a tool that’s available to deal with some of these problems but this isn’t what we’re voting on today.

Sbc: Emscripten does have a very roundabout way of supporting web socket. You can do it but it is a real pain.

Syrus Akbary (in chat): I analyzed Sockets and was pretty solid tbh.


|        |    |
| ------ | -- |
| **SF** | 16 |
| **F**  | 9 |
| **N**  | 0 |
| **A**  | 0 |
| **SA** | 0 |

Pat Hickey: The vote passes.

### Vote: advance wasi-cli to Phase 3

Syrus Akbary: Past week I analyzed the things we are voting on. While I think wasi-sockets is solid, I don’t see any of things tagged along in wasi-cli. 

Pat Hickey: We haven’t had anyone pursue that yet. We have provided functionality for is-a-tty. We left the ability to add additional methods to this resource that would be backwards compatible. If you target this world, you will always be able to run on future virtual worlds. At this time this hasn’t been added to the wasi-cli. 

Joel Dice (in chat): WIT versions are really helpful here

Syrus Akbary: To be clear, one of the things that appear to be missing is termsize. I think this is critical of cli applications.

Kyle Brown: Is there something here that is missing and could be added versus something that is incorrect? This perhaps changes the blocking nature of this.

Kyle Brown: There are things that we have lots of consensus on and there are others that we can add later.

Till Schneidereit: for one specific thing about tty support: there are significant portability and security concerns around ANSI escape codes, which is why we deliberately forbade them in the past. Adding support for them in the CLI world would require substantial analysis and design

Guy Bedford: In this case the node.js behavior has a different stand-in. 

Syrus Akbary: I read what Till posited. I am more unsure. I would like to know if there is a plan?

Pat Hickey: That is a great technical discussion to go in depth on in the wasi-cli repo. We are pressed for time in this meeting right now. 

Till Schneidereit: The vote is not about what might not be in a future point. This vote is about if there is something that will technically preclude the addition of the feature. This is what is up for a vote today.

Dan Gohman (in chat): The stdio api in wasi-cli is specifically designed to be extended with terminal support in the future.

|        |    |
| ------ | -- |
| **SF** | 13 |
| **F**  | 11 |
| **N**  | 0 |
| **A**  | 1 |
| **SA** | 0 |

Syrus Akbary: Just to be clear, I think the proposal is half complete. And there are things that I consider critical for running CLIs. For this reason, I’ll vote against this one

Pat Hickey: The vote passes as consensus is largely held.

### Vote: advance wasi-http to Phase 3

|        |    |
| ------ | -- |
| **SF** | 15 |
| **F**  | 8 |
| **N**  | 0 |
| **A**  | 0 |
| **SA** | 0 |

Pat Hickey: The vote passes.

"
gc/2021/GC-08-24.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 24 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: August 24, 4pm-6pm UTC (August 24, 9am-11am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Presentation: Update on Binaryen optimizations (Alon Zakai, 20 minutes)
    1. Discussion: Evaluating nominal types (Ben Titzer, 20 minutes)
        1. Poll to gauge sentiment
    1. Discussion: Encapsulation and Privacy (Conrad Watt, 20 minutes)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Zalim Bashorov
- Conrad Watt
- Ben Titzer
- Francis McCabe
- Alon Zakai
- Zhi An Ng
- Rick Battagline
- Adam Klein
- Jakob Kummerow
- Ross Tate
- Igor Sheludko
- Luke Wagner
- Michael Knyszek
- Emanuel Ziegler
- Daniel Ehrenberg
- Manos Koukoutos
- Slava Kuzmich
- Asumu Takikawa
- Lars Hansen
- Yulia Startsev
- Sergey Rubanov
- Shu-yu Guo
- Dimitriy -
- Keith Miller



### Presentation: Update on Binaryen optimizations (Alon Zakai, 20 minutes)

[slides](https://github.com/WebAssembly/meetings/blob/master/gc/2021/presentations/2021-08-24-zakai-optimization-update.pdf)

ZB: Good on Dart in what sense? Is it faster than JS version for Dart?

AZ: Similar to Dart AOT output, which I believe is faster than the JS output generally. There might be some things where JS wins because of the JIT.

BT: About cast elimination: if I understand right, the rtt comes from a global so you can’t erase it, but in the nominal system there is no dynamic value. What is it about rtt that makes it different?

AZ: you can do that there, we can do it for ref.cast, larger issue is ref.test that don't trap. For things that do trap, we can, which is why we have TrapsNeverHappen

ZB (chat): So, after all this optimisations j2cl for wasm is still slower than JS?

AZ: At the moment yes, some of that is missing general optimizations in binaryen or other parts of the toolchain. No precise answer to what remains, but looking at profiling data.

BT: Another thing to evaluate is the memory size of J2CL vs Java. You can have a more optimized object layout in Wasm.

AZ: definitely true, packed fields is one thing I hope will make a big difference, more efficient memory storage

ZB (chat): Do you have information about size of binaries? for j2cl

AZ: too early to say, haven't focused on measuring that yet, focused on speed for now. It will become interesting to measure later.

DE: do these optimizations work with type imports?

AZ: have not thought about how they interact there, focused on the closed world case for now, will need to think about that. Now the assumptions is that no types come in or go out

RT: you assume you can collect all the info about the types, if the type is exported, other people can write to that type

AZ: right now we assume closed-world, if the types escape we will need to do something more careful

LW: do toolchain only thing, where the toolchains can do thing slike traps never happen, can say assume we've seen all the writes

RT: do you have examples of constant prop that aren't vtables?

AZ: In some cases, integers that happen to be propagated don't end up being significant for speed, calls are the main factor. The code doesn't care about type, any constant it can handle.

ZB: Would be useful to have code splitting or to be able to optimise bunch of wasm files together with CW assumption

AZ: interesting question, we will want code splitting after this closed-world stuff

### Discussion: Evaluating nominal types (Ben Titzer, 20 minutes)

[slides](https://docs.google.com/presentation/d/1kq7gPQ_ukj1gcZVliMKZmCiv9f1iV-3q9nJkbPzbYSk/edit?usp=sharing)

CW: given how much work Binaryen has done in prototyping, we need a alternative to prototype against it, Andreas' latest sketch seems something to compare. If just compare Binaryen equirecursive, it won't be fair, because we know the equirecursive won't work.

TL: concretely, we have been doing a bunch of work with nominal types, the next question to answer is, if we get rid of RTT, and use nominal declared subtypes, what performance wins can we realize from that. That will require engine implementation to answer. Coming up with a new prototype spec document so that Binaryen and V8 can implement. Putting together now, ready to share soon. In particular this new document is designed so you can gracefully upgrade from equirecursive program to experiment with nominal types.

CW: BT is pitching this in terms of, we have a structural design, we should do the work for nominal. In the engine, right now most of the work is in nominal. We need resources to implement the structural types in engine.

TL: was out last week, just from notes, don't have a strong understanding of it yet to implement it. need a more detailed technical write-up. Will be happen to then go implement it in Binaryen. Don't think we need it in v8 yet.

CW: will be on Andreas to write something more detailed

BT: assuming that the best version of structural types that Andreas proposed 2 weeks ago will be what we will be prototyping. What binaryen and v8 seems like a side project, i want to bring it into the main fold.

TL: finishing that document, and happy to take into account any thoughts yall have. Will be great to implement these. E.g. in Wizard.

BT: yup, thats my plan

RT: another pro, when you explore multiple paths, you often find that an idea on one path improves the other path

BT: when i implement in Wizard, I follow the ref interpreter, what's in the binary code, stick with the CG documents

RT: AR is not here to express concerns

BT: worth taking the temperature of the room

Poll, we will evaluate nominal types by adding the minimum delta necessary (types and instructions) to the current MVP and tools.

SF: 8
F: 8
N: 1
A: 0
SA: 0

### Discussion: Encapsulation and Privacy (Conrad Watt, 20 minutes)

CW: in many source languages, you have privacy or package designators, like private fields. Has come up in discussions that particular patterns of making fields private would be better supported by 1 version of the type system or another version. We have an opportunity to limit the scope, or we can decide we care about this. We should decide one way or another. When this comes up, opinions in the room are split. We never decided this at the group level. I believe it shouldn't be a concern for the MVP. Hot-take: questionable whether the kind of privacy modifiers you get in Java should ever be in Wasm level. Do you consider these modifiers a feature for security? or source-level abstraction, a way for programmers to produce an interface to shape human behaviors, as opposed to sound security. Depending on where you fall, it doesn't have to be in core Wasm, but can be a toolchain thing, because even if VM don't guarantee, using toolchain conventions, checking for private fields, you can support it. Do we want robust privacy features, or would you be happy with something more restrictive that depends on toolchain for source linking behaviors. Will point to previous soft consensus that we can't make every source language linking abstraction to core Wasm.

FM: it's a privacy issue, not a source language compatibility/semantics. Also a strong privacy/security aspect.

CW: you can have a setup that if you compile your Java program to Wasm, and only ever link it to other modules compiled through the same toolchain, then the private field is protected, but won't get that if you expose to other arbitrary modules.

FM: that is not strong enough. if i have a library, i have no control over who link it

CW: if you have a GC for linear memory, you don't have the guarantee right now

FM: argument also applies if you go to the machine code, you can figure out what to do. I would be unhappy if I was a java compiler promogator.

DE: how does this related to type imports, when you can wrap a whole value in this opaque thing.

FM: it is not enough, if i want to subclass a type.

DE: at module boundary, all or nothing might be enough, JS supports subclassing and adding public fields without adding indirection. Think a producer can emulate that.

BT: java linking allows many different kind of changes. fragile base class problem. You can have a private field which is an indirection away. A private field can become a public field, java linking is fine with that. Privacy of field changes the object model, can't do the same link time check as you would in java.

FM: that feature of Java is changing in recent version of Java, in the teens version of Java. If you have a private field you can't make it public, can't get it through introspection.

DE: seems like supporting full java semantics will be far beyond what we can do with the GC proposal, not sure if we should be treating that as a goal.

BT: supporting full Java linking requires a whole different thing, won't be able to introduce Wasm mechanisms to do that

KM: in the JS world, there are entire framework type things like SES designed to try and embed secure env, like a plugin on your webpage. Big nightmare for them. Possible that having something built into the system will make their lives easier. OTOH, I am not necessarily a champion of this.

AZ: most comments are on privacy, also optimization, if a field is private, closed-world

TL: there are use cases that benefit from this, nice to have. Will say this is post-mvp, design without thinking about it, so we can focus on performance and code size, those are the key issues that will break or make this whole enterprise

RT: ability to handle privacy and separate compilation means we have a good way of composing systems together, test of a good compositional system. In nominal type space, everything is private by default, you have to give public access explicitly, not more work to make privacy happens. We want to consider interop, DE pointed out structs proposal, can mark JS classes as fixed, another proposal for JS with private fields, and guarantee they are strongly encapsulated. Combing that with Wasm, make sure Wasm is respecting that privacy.

TL: propose that we continue to try and settle the type system question without bringing privacy concerns into the mix, simplify the conversation. Once we settle that, we can evaluate how easily we can put privacy mechanisms into MVP. If it is easy we can go ahead to do it, otherwise holding off to post-mvp is better. Key decision now is the type system question without considering privacy.

FM: two questions that are conflated. 1 is this language semantics or security issue. 2 is do we do this now or later. No opinion on 2, happy to leave to post-mvp. I don't think this is only a language-only question.

CW: if i were to grant that it is a security question, is it something that must be solved by a core extension to Wasm, or toolchain

FM: cannot trust toolchain, won't be enough

LW: different scenarios, when i'm linking c object files, when i'm linking code from totally different languages

FM: agree

CW: if we were to end up going with structural types the path to adding privacy seems harder, might be a completely orthogonal thing. We should be prepared that we end up with structural types, then find it almost impossible to extend that to add private fields. We need to be okay with that.

TL: what's in type imports proposal is basically that, layering nominal on top of structural system in GC proposal

RT: awareness of this is important

TL: sounds like we are in agreement, design core type system without considering privacy

(no disagreement)

CW: re BT's poll, given the plan of work in Binaryen and V8, the new work commitment is to prototype a structural thing to compare the nominal type system with

TL: reasonable, we can consider next steps for structural system after we have the doc

BT: we will have the union in the MVP for some time

TL: even if we don't end up shipping the union, we will have it for experimenting

RT: productive discussions today
"
threads/2024/THREADS-02-20.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the Feb 20, 2024 video call of WebAssembly's Threads Subgroup

- **Where**: zoom.us
- **When**: Feb 20, 2024, 5pm-6pm UTC (Feb 20, 2024, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/mUp4nmiVUTNQDKcD9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. 
1. Closure

## Meeting Notes

### Introduction of attendees
- Ashley Nelson
- Conrad Watt
- Paolo Severini
- Manos Koukoutos
- Nick Fitgerald
- Luke Wagner
- Alex Crichton
- Ilya Rezvov
- Dan Gohman
- Ryan Hunt
- Jakob Kummerow
- Sulekha Kulkarni
- Syrus Akbary
- Andrew Brown
- Thomas Lively
- Johnnie Birch
- Luis Pardo
- Emanuel Ziegler
- Deepti Gandluri
- Shu-yu Guo
- Zalim Bashorov

TL: (Presenting [slides](https://docs.google.com/presentation/d/1eJQjCyeeLy4MaUZPDVFfUHYQ39VF07CAJXt-UnWEiss/edit?usp=sharing))

CW: With respect to your with GC support bullet points, it is to that the generalized shared wrappers will need some GC support in ephemeral. Thread-bound wrappers will probably need GC support. 

TL: Yeah, two more slides: one sketches spectrum of solutions for TLS, the other the GC question

TL: (back to presenting slides)

CW: Wouldn’t be totally confident the dynamic scoping wouldn’t cause the ABI changes.

TL: Of these, dynamic scoping has the most amount of questions about how it would work. We have the effect handlers proposal, but having to switch stacks every time I want to switch my stack pointer is probably not going to fly. Need to think through how this would work.

RH: When it comes to TL-globals, does it actually work in a world where you’re suspending these and passing them around and sending them to new stacks. In that case, stack pointers are more of a stack global then.

TL: With the current explainer in the world with TL-globals, we have this rule that the shared functions don’t hold an unshareable intermediate state. But the stack pointer of course is not unshareable because it’s just an i32. If I suspend a shared function and send it to another thread. If it has a local or other intermediate stack value that is the shared pointer, that is potentially not going to be valid. Except when you send a task to another thread, maybe you send its in-memory stack with it.

CW: Sounds like general pointer problems, how do runtimes resolve pointers if they can be resumed in other threads.

TL: Yup

RH: I would assume that Emscripten entering … would need to allocate shadow stack space and when you send to the new thread use that shadow stack; it would be surprising if, on a new thread, the shadow stack was suddenly zero.

TL: Toolchain can accomplish that by storing the value of the stack pointer in a local before the transfer, then it would still be in the local after the transfer, even though the TL-global where the stack pointer canonically lives might have a different value after the transfer. Some sort of caller-save ABI contract around that would have to be managed. It would work differently for different pieces of data. The stack pointer might come along for the ride, but the live pthreads or TLS keys would be different on different threads. Some data would stay thread local. 

RH: extra information about context switching: with TL globals, what does it mean to look up one of these keys? Discussions about concurrent hash maps, dense arrays; the problem is the number of instances is dynamic. Heavy synchronization; must acquire locks. Does anyone have any clever solutions? Potentially large memory usage. Can we limit the cost of this to only users of this? Unshared functions can use TLS as well. An indirect call in SM has a check (JS realms) so in this case we would like to do: (1) either does the callee have TLS and look it up or (2) not make TLS part of the ABI and instead have each function perform a lookup on-demand

TL: One of the nice things about TL global design is that it's so declarative so you have the potential for different strategies. Of course you only want to ship one, but we can experiment. If we can come up with something that is fast, I’d be happy but I acknowledge there are performance questions here.

SYG: For Ryan, why need a concurrent hash map? My understanding is that in this part of the design you would know how many keys are necessary across all instances. A dense array could work.

RH: You have a wasm module with a TLS variable it declares locally. My understanding is you can create many different instances of that module as well. And then you can dynamically do 5 or 10 of them. Maybe the definition is different and it’s importing TLS as well.

CW: You can always create more TLS data at arbitrary points of execution. Always instantiate another module or free floating global. I think we should still make the layout dense per instance, but the question is shifting the perspective at import boundary execution?

SYG: That helps, thanks. The missing piece is that in the JS API you can create a new TLS thing.

CW: I could flip it around, you can create a TL-global in the JS API as instantiating a tiny Wasm module. I could imagine a naive implementation for dense allocation switching at the boundary if you access a TL-global that is created by the JS API to make it faster in that context.

TL: (presents last slide)

LW: Is finalization an option?

TL: If we had a finalization registry, need to track when there are no references on any thread; you need finalization to have global knowledge

CW: One way of saying this is if you have FR with shared keys, that's basically just as hard as supporting the strong semantics. So if can engine can do that, it can have a FR in the runtime.

LW: Is that really the case? It seems less arduously strong than WeakMaps.

SYG: I think it is. If you want to use FR, do you agree that we cannot use FR to collect cycles. FR originally created to collect references in the Wasm/JS boundary. The JS side has a wrapper object, to know when the wrapper dies to collect on the Wasm side. This cannot collect cycles across that boundary.

CW: You can express strong semantics in terms of strong finalization registry - a strong table, with entries that are nulled out when the finalization registry fires

SYG: Right, so the cycles thing–just clearing that up ahead of time. FRs can’t collect cycles.

LW: But if we’re not allowing cycles between shared and unshared, that’s a problem.

SYG: Even with no cycles, need to choose when the finalizer fires: dead in all threads or dead in one thread? In the former, you need a unified global GC; in the latter, this still has extra GC complexity.

LW: I think the strong semantics is what you would expect and easier.

SYG: You claim that there is semantics more intuitive than the strong semantics?

LW: I think it’s as intuitive as the strong semantics but if we’re containing ourselves to the FR, it’s categorically easier than strong semantics in general.

TL: Would the registry allow cycles?

LW: It’s not an edge, it doesn’t keep them alive, is that right? Or maybe it always keeps them alive? Or it’s not contingent on the liveness because it’s the FR? The roots, the postmortem notifier?

CW: Higher-level point, if we have a FR with that level of power, we can use it in userspace.

LW: This is less expressive than a weak map.

SYG: Right, but why?

LW: Well a weak map ends up being like adding an edge and a FR doesn’t.

SYG: Finalizer function can null out a map entry.

LW: But it will only fire when already dead.

SYG: so does a weak map. only clears the thing when the key is dead

LW: But if the thing is alive, it keeps the thing alive?

TL: Right, In a FR if the key is alive, it keeps the value alive as well.

CW: We’re getting off the reason these things are the same: the finalizer function can be a “drop” allowing it to be collected

SYG: LW’s point is the drop semantics, you can implement the drop semantics of weak map using a FR. But a weak map, also has no drop semantics, the liveness of the key implies the liveness of the value. LW’s point is that is not the case in the weak map, you’d have to implement that somewhere else.

CW: A table strongly roots the reference and then a FR where the finalizer nulls out the entry–so you get the same semantics

TL: You can implement a weak map in terms of FR and the semantics that we allow in FR correspond to the semantics we can possibly impl in the weak map.

SYG: Not sure if true, also think LW is overlooking complexity. You still have to choose a lifetime of when the finalizer fires if the key is shared. If the finalizer you want to fire is locally dead, that is pretty weird, what does that mean?

LW: That’s not the one I’m suggesting

CW: To lay out my point E2E: I don’t think we can have a strong FR without the strong semantics, because we can use one to implement the other. (see previous comment above)

SYG: finish the slides?

TL: (back to presenting the last slide, strong semantics)

LW: FR is weaker in a good way: it roots the unshared thing and thus roots the cycle.  A WeakMap in theory allows the cycle to be collected which may become the expected semantics and thus required of implementations..

CW: Can you expand?

LW: the difference is the edge; pure weak maps might be expected to be collected.

CW: Can the finalizers still run?

SYG: relaxed to allow them not to run; e.g, GC witnesses some refs die, finalizers queued up to run later on the event loop, it could be that the FR dies while queued, we shouldn’t have to cancel all those queued tasks.

TL: LW, under your idea, if weak maps and FRs are both garbage, there could be leak, right?

CW: shifts the question from “can we collect cycles” to “do finalisers fire after registry is collected”?

SYG: reframe LW’s semantics more simply as “put shared stuff into weak maps” and “don’t collect cross-heap cycles”--equal expressivity

CW: if FR kept alive, more things would get collected than in that scenario, right?

SYG: Why?

TL: all acyclic stuff gets collected and cycles leak?

SYG: if WM or FR goes away, the cycle could go away because the user code breaks the cycle; I’m not advocating for this, it’s very weird

TL: <back to presenting slides, weak semantics>

CW: weak semantics are actually my preferred semantics

CW: one way it is different: agree it is like “no support” when manipulating objects, but different when importing a callable function, this gives at least the option of calling unshared from shared

TL: Wouldn’t be scared of splitting this up; non-suspendable shared is basically the same as a shared function with a shared-barrier body.

CW: Can you expand please?  

RH: shared-barrier only prevents suspending your function into a shareable continuation. You can still suspend into an unshareable continuation.

CW: this is a problem for validation if we want to validate the that shared-non-suspendable functions cannot call shared-suspendable functions.

TL: you described three levels of functions: all three participate in rules; this would need to apply to function references. shared-barrier simplifies that: we can have only shared and unshared functions, and shared-barrier to enforce that unshared data doesn't get captured in a shared continuation at runtime.

CW: Very interesting idea, need to think it through more. Still can’t pass in non-shared things as arguments?

TL: Good point, shared-suspendable would be shared, have shared-barrier block, and allow unshared arguments.

CW: Have to think more about whether we would still need type system complexity to deal with the arguments.

TL: We should take an action item to explore and document this design space more.

RH: The optimized context-passing design has the benefit that it allows some context to be nulled out rather than implicitly rematerialized on suspension.
"
main/2020/CG-04-02-Subtyping.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 2nd video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: April 2nd, 4pm-5pm UTC (April 2nd, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. [Special edition of the meeting to discuss subtyping](https://github.com/WebAssembly/meetings/issues/529)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

Ross Tate

Ben Smith

Sam Clegg

Francis McCabe

Lars Hansen

Jakob Kummerow

Richard Winterton

Zalim Bashorov

Deepti Gandluri

JP Sugarbroad

Ryan Hunt

Bill Budge

Heejin Ahn

Andreas Rossberg

Luke Wagner

Derek Schuff

Adam Klein

Emanuel Ziegler

Wouter Van Oortmersson

Thomas Lively

Petr Penzin

Pat Hickey

Dan Gohman

Zhi An Ng

Ioanna Dimitriou

Jacob Mischka

### Discussion

AR: Prepared some slides for impact on proposals

[Slides](https://github.com/WebAssembly/meetings/blob/master/main/2020/presentations/2020-04-02-rossberg-ref-type-subtyping.pdf)

AR: We don't want to have bias in types that can be imported/exported...

RT: You already have this by restricting it to references

AR: Yes that's true, but future feature

<Back to slides>

RT: You say that subtyping is standard, but where is that standard?

AR: standard in type systems, like you have bounded type qualifications

RT: You mean Java, C#? In practical type systems, in order to make it possible, the implementers are moving away from this pattern.

For languages that do use it, to compile quickly they rely on nominal typing to compile quickly

AR: That's a separate thing here... source level types systems are different than low-level type systems. That is very close to what you care about if you care about which values are compatible (representation).

RT: You care about effective type checking correct? <yes> If you lower to representations the subtyping check is a large mutually recursive check. In scaling these things, it’s not clear that the standards implied.. It’s not clear that mixing the standards will be efficient for Wasm. 

AR: I'm not sure I'm doing that ... structural vs. nominal is orthogonal to this. For type imports, you need some structural constraint anyway. I don't see how any would be cheaper than any other one...

AR: Want to continue.. Let’s not make this another structural/nominal discussion

<Discussion about standard/canonical, back to slides>

RT: We've found that you don't need a top type to handle all the different languages ...

PP: Can you elaborate on what the C/C++ API issue was?

AR: Basically, you need to be able to pass values back and forth between C code and Engine, you need a union. What to do about references, you have one field of references. If you have an open-ended set you have a growing number of arguments in the union. It also shows up in how we deal with imports/exports, for example functions, tables, globals, memories. You can use the same reference values there too. I spent some time trying to up with a good alternative there, but so far have failed to come up with anything nice.

PP: This is .. <muffled> A good enough level of abstraction, makes sense for alignment etc. 

AR: We will eventually need this, no way around that - has been the roadmap for 2-3 years. 

<back to slides>

RT: Claim is that code will have a small change, not the spec

LH: That’s not the case, code will also have substantial changes, lots of knock on effects

RT: Want to know what that changes are

LH: I can share this offline.

<AR sharing spec change prototype>
    
AR: not a small change here either, various implications

TL: I have a question about the change in your discussion. My impression is that we're not talking about never having subtyping ever -- we're talking about splitting tree of types into top funcref and top anyref. All of them can have different representations between them.

AR: This gets back to the point about not introducing type bias - about import/export for example. If you import a type, and not have any restrictions why would you make this harder for some types of references? You can go and make a new choice for every new type, but it would be arbitrary, and akin to premature optimization. If there is evidence that for some of these there’s use in flat referencences we can always introduce them later, but we want to have a uniform system first

RT: I can think of reasons to be able to export integers instead of exporting funcref types.

AR: That you would have to box, or use a tagged type

RT: What are the uses for being able to export the funcref type?

AR: For example, can naturally use functions as capabilities.

RT: Usually capabilities are a table of functions, not just one, right?

AR: Can be single functions, too. We actually do that.

AR: Broader point is that we shouldn’t make premature decisions of what somebody might want to do

<Back to slides>

HA: Are we talking about removing subtyping altogether... for exnref does that get removed too? Is this just for funcref? It doesn't change much if it's just that.

AR: For anyref subtyping removal to make sense you also have to remove nullref - the intent is to partition type hierarchy, so if you don't remove it it doesn’t make sense

HA: In that case, if we make exnref a subtype of anyref, then we need to make a new value...

AR: One more generic instruction to take type immediate… 

AR: The other part of the question is whether to remove subtyping altogether. Just dropping funcref subtyping leaves the proposal in an incoherent state. It means we have subtyping in the proposal but no subtyping rules. It doesn't make sense to have subtyping you can't observe or test, so you'd want to remove it altogether. You'd also want to rename anyref to something else. These are at least three further steps to remove clean it up. This is just the effect on this proposal itself -- we also have effects on other proposals.

Bulk memory has a smaller change, exceptions proposal - rules about exnref that would have toc hange. Func ref, the work there is completely invalidated, would have to move that over and redo. Type imports, not much work yet there but it is a deeply impacted proposal. Also mentioned C++ API etc. At least 3 and a half of these are already implemented, they all would be impacted - all the implementations have to change. More churn - so we should seriously consider if we want to impose the change. Not a question of a couple of days, at least a couple of weeks for every implementation. This is the roadmap we had agreed on, by abandoning some aspect of it - what do we do with the rest of the roadmap - do we want to reconsider the entire roadmap? 

JP: Last time Ben asked about Luke's experience w/ subtyping?

LW: Which experience? 

BS: LW chimed in earlier about type imports in the github issue..

LW: Design we have now will work, we don’t have the weight of a full import, can also see the other side. It seems premature to commit to subtyping.. Ambivalent right now. I can imagine multiple successful paths. Let’s put our weight on subtyping.. And we can figure out all the implications. What should we have in the short term - makes sense to have the universal solution

AK: You're ok going conservative approach now, but you're thinking we will re-add this. But you're interested in more feedback.

LW: Can’t say I’m positive there are no problems, can’t point out is what we specifically will regret

RT: One thing I've pointed out is that we don't have a current language to work with the current plan. I've been worried about this for two years. I found other solutions...

AR: What part of that is related to the proposal at hand? 

RT: Something I've been wondering about is how this works with call_indirect.

<RT Sharing slides [(pdf)](presentations/2020-04-02-tate-call-indirect-subtyping.pdf) [(pptx)](presentations/2020-04-02-tate-call-indirect-subtyping.pptx) - how does this interact with call_indirect?>

RT: <bringing up issues w/ subtyping on ""Test 2"" slide>

JP: The current spec doesn't admit this though. The only reason for it is allowing having a heterogenous table.

RT: Do we ever want to add subtyping that people rely on? 

AR: We probably need to at some point. But we will obviously have to maintain coherence between different uses of subtyping. If we decide that extending call_indirect is not a practical choice, we can add a variant of function type that is subtypable or not. We can play around with options later.

RT: This should be known answer by now

JP: It is... 

AR: This is only relevant when you get to the GC proposal. 

RT: My question is, should this work eventually?  When that works, will this call_indirect work? 

AR: That depends on what we figure out... if we figure out that we can implement this efficiently, then we will make it work. if not introduce something else.

LW: I’ve been assuming that this wouldn’t work because it uses type equality

RT: <explains> If it doesn’t match you have to know where this type import comes from...

LW: call_indirect does a dynamic check, so...

RT: Bottom half of this program.. what should we expect?

AR: I don't disagree with you. Whatever we do has to be coherent.

RT: You are making us commit to this choice soon..

AR: Disagree, we're leaving it open. Constraining to equality is conservative.

RT: Flip side is we incorporate subtyping into call _indirect.. Callee and caller signature have to be compared by type equality

<Discussion about Test1, Test2>

JP: When you run Test1, it traps - the spec says you don’t use subtyping here <RT agress> 

AR: The program won’t link

RT: When you get to supporting subtyping correctly, this will link

AR: Once we get to the point, we have to decide on a coherent solution. 

RT: With every system.. If you make decisions one step at a time.. It’s regretted, this will come up soon

AR: Can't avoid incremental design. Question will come up in the GC proposal

JP: Where do you see this being used? 

RT: Understand now, that the behaviour is consistent, the question is has any language with subtyping have compiled to use these semantics? 

AR: Many mainstream languages don’t have contravariance

<Overlapping discussions>

AR: We are doing an incremental design process

LW: It’s hard to dismiss the possibility that we make a choice now that we regret later

BS: We only have three minutes left in this discussion

RT: Subtyping complicates everything, we haven’t gone into all the details

BS: The current use case that we have is the idea of exnref, it does feel compelling to accept some amount of churn - it seems reasonable to say that we can remove subtyping for now, and add this on later when we’ve had more investigation into figuring out exactly what we need

AR: Want to refute RT, this is the most basic subtyping, we don’t make any assumptions with what we’re introducing right now, this is how we have been doing development in wasm so far

BS: But the point is removing the any ref func ref that’s actually being introduced right now

AR: If you remove it, it’s removing all subtyping at that point

<More discussion about the cross cutting aspects of it>

LW: Makes sense to delaying the subtyping for the reference types proposal, for when we need subtyping we can make that decision later

AR: Problem is the churn, and the warts we introduce, at least leaves the C-API in limbo

**Straw poll**: Should we have subtyping in the Anyref proposal? 

Poll is not binding, only to get a sense of the room and as a way for folks to express their opinion who haven't chimed in yet.

| Agree | Neutral | Disagree |
|-------|---------|----------|
| 5 | 13 | 4 |

Conclusion: Room is pretty evenly split - what next? Another off cadence meeting to be scheduled because of Easter holidays,
and scheduling constraints, and the general interest to be able to make a decision here quickly. 

### Closure
"
main/2020/CG-05-26.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 26th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: May 26th, 4pm-5pm UTC (May 26th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Should we move proposals entirely out of the design repo? (JP Sugarbroad)
    1. Poll to include .bitmask operations in the current SIMD proposal.    
       Context with benchmarking data: [PR](https://github.com/WebAssembly/simd/pull/201), [Issue](https://github.com/WebAssembly/simd/issues/131)
    1. Poll to advance [reference types](https://github.com/WebAssembly/reference-types/) to phase 4 (Andreas Rossberg)
    1. Poll to advance [typed (function) references](https://github.com/WebAssembly/function-references/) to phase 2 or 3 (Andreas Rossberg)
    1. Update on Module Types / Module Linking proposal ([slides](https://docs.google.com/presentation/d/1Cz4yopK-V6PIq7JMJiRNUWlDlHLTnIvwhdetP5QBVL4))
       1. Poll: Rename ""Module Types"" to ""Module Linking"", broadening scope as proposed in [PR #3](https://github.com/WebAssembly/module-types/pull/3) and advance proposal to stage 1
1. Closure

## Agenda items for future meetings

1. Update on Module Types / Module Linking proposal ([slides](https://docs.google.com/presentation/d/1Cz4yopK-V6PIq7JMJiRNUWlDlHLTnIvwhdetP5QBVL4)) - moved to next meeting due to lack of time. 

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

Ben Smith

Deepti Gandluri

Lars Hansen

Nick Fitzgerald

Ms2ger

Ross Tate

Dan Gohman

Svyatoslav Kuzmich

Paul Dworzanski

Yury Delendik

Shravan Narayan

Ben Titzer

Francis McCabe

Tobias Tebbi

Richard Winterton

Heejin Ahn

Alex Crichton

Ryan Hunt

Jay Phelps

Paolo Severini

Arun Purushan

Arseny Kapoulkine

Alon Zakai

Jacob Mischka

Luke Wagner

Nabeel Al-Shamma

Jakob Kummerow

Zhi An Ng

Ioanna Dimitriou

Thomas Lively

JP Sugarbroad

Derek Schuff

Andreas Rossberg

Emanuel Ziegler

Pat Hickey

Till Schneidereit

Adam Klein

Arnaud Robin

Sam Clegg

Zalim

Mingqui Sun

David Piepgrass

Peter Jensen

Petr Penzin

Dan Gohman

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Ben Smith seconds

### Proposals and discussions

#### Should we move proposals entirely out of the design repo? (JP Sugarbroad)

JS: Tried to clean up some of the documentation around the phases, people don’t usually use the design repo, just use the proposals repository - there’s already a lot of stuff already in the design repository, having less there makes sense

SC: Is this just for future features? 

JS: It started that way, but 

AR: Makes perfect sense, we should update the pages on the design repo to make sure folks know it’s outdated info

JS: Was already in the process of doing that - can update documentation

SC: Keep the future feature proposals for historical documentation? 

<It already is, several>

AR: Should we move the proposal into the spec repo - might be harder to discover original repositories

JS: Makes more sense to merge the original proposals, a few extra directory entries in github is not a lot of work. We should backfill instead of getting rid of history

AR: To clarify - copy from design repo to the spec repo? 

JS: We can discuss this in the github repository

TL: Should we still file an issue for the design repository for new proposals? 

BS: We should use the proposals repo - people have used the design repository in the past

PP: Just had a chat with someone trying to follow Wasm discussions, they missed discussions everywhere else

AR: Why do we have a separate proposal repo at all? Why don’t we just merge? 

< More discussion about the mechanics of the proposals repo vs. design repo> 

JS: Abstract ideas for proposals, vs actual design idea - where should this live? 

JS: get rid of tracking issues in design repo, future features point to proposals repo, sounds reasonable?

DeG: Will you, JS, follow up offline on this?

JS: open 2 issues, 1 for agreed changes, i will probably make them, another one to track discussion on where we want proposals to go, where to draw the line between design and proposal?

#### Poll to include .bitmask operations in the current SIMD proposal.

AK presenting [slides](https://docs.google.com/presentation/d/1OZSlYWWnm_pPFsjSu6iGmTQb8Qs0O2Wg2TU34-Fw-jQ/edit#slide=id.p)

DaG: Can you comment on the any_true case? Shouldn’t AnyTrue be able to cover this? 

AK: not quite, anytrue is less general, you get told whether there is any match. If there isa  match you still have to find a match. For string search, you are looking at the substring, you have to do a match of the substring from the matched character. With anytrue, you then need scalar comparisons.

DaG: Is that difference worth an instruction here?

AK: we can run the tests to find out. Strongly suspect it will be well worth it for substring matches. E.g. if char you are searching for occurs every 8 chars, with a bitmask, you can do 16-wide comparison. Otw you have to do 16-byte comparisons, even though only 2 of them will match. There is code for this on the PR. Strongly suspect we will see degradation if we do anytrue + 16 comparisons, don’t know for sure, have not benchmarked it yet.

KM: This is the same instruction used in google's swiss hash. Tested w/ scalar version vs. simd instruction, right?

AR: We did not do comparisons to the swiss hash table - mostly because only thought of it yesterday when putting it together.

KM: Is there something other than string search... I suspect swiss hash is larger base of code.

AR: Structure of the swiss hash is the same as string search, exact same comparison where you do eq + bitmask + ctz loop to find matches

KM: Which architectures did you test on? Snapdragon and intel? [AK: yes] OK.

DeG: If you were looking for more arches, we can get that when we get back to the office. [KM: OK, makes sense].

KM: If we add this now, and then we test against some subset of older CPUs and find issues. What is the process for re-evaluating our decision then?

DeG: If we find out it is bad, then we can bring it back and find a different semantic. I suspect it will be wanted because it's hard to emulate. If it does show a performance cliff, then we'll bring it back as an issue on the simd repo.

AK: This is probably the best semantic -- the only difference is what bit to check, but this is probably the best since it is the top bit. It was chosen because it matches intel semantics best, but it probably matches ARM best as well. Maybe it will be added as a native ARM instruction, not sure.

Poll results:

|SF|F|N|A|SA|
|--|-|-|-|--|
|8|11|12|0|0|

#### Poll to advance reference types to phase 4 (Andreas Rossberg)

AR: we have had plenty of slides, status is, last 2 open issues were resolved, subtyping removed and relaxed restriction on predeclaring references to functions, you don’t have to do it in a segment, you can do it anywhere outside function. Both implemented, tests are updated, SpiderMonkey implements all that, not sure if V8 has caught up. Anyone from V8 can comment on that?

DeG: not sure if we are up to date on that, JK, do you happen to know if we are up to date?

JK: not personally involved, not sure, don’t think we are up to date

DeG: my impression as well, we don’t object to the changes, it will be OK to move forward? What do other V8 folks think?

BG: phase documents require 2 implementations, but we have most of the implementation, and the purpose is to prove that we can implement it.

DeG: any objections to doing this without 2 full implementation, v8 has most of it, but not the latest changes

AR: or is there another implementation somewhere

BS: Would have to be another web implementation based on current requirements

KM: my internet failed, this is about reference type? I don’t think we have made the changes

AR: fairly large change, but mostly restricting stuff, not implementing new changes

KM: It wouldn’t be hard to implement - just the one function when Ross was proposing the split. 

AR: way more than that, instructions changes

KM: All those functions flow through that in our implementation..

RH: encoding change, ref.null has immediate

AR: br table subtly changed back to what it was before, and some other changes like that

BT: don’t want to be that guy but we should enforce the letter of the law, cos these things can slide for a while

TL: was gonna say, there isn’t much downside if we wait a little bit for the implementations to catch up

DeG: How about a provisional poll to see if anyone objects to advancement, then do a more official poll once implementation catches up

BT: take a poll, when this is implemented, advance the proposal

AR: we shouldn’t poll in advance

DeG: intent is to see if there are any other objections, since this has been a proposal with many comments

LH: Bulk memory is blocked waiting on reference types? Is bulk memory included in reference types? Do we vote separately on bulk memory?

AR: I think we should vote separately, in terms of the actual work, everything is resolved in the reference types proposal for the mutual dependency - having said that we should still update the documentation - like the proposal document in the bulk memory proposal repo. One thing that changes is the ref.null const

BS: I’ve already changed that, based on what’s already there

AR: It’s all already there, just not implemented in the right way

JS: Do we wanna do that poll?

DeG: Barring the implementations, are there any other objections to moving forward w/ reference types to phase 4. It sounds like there are no objections, so let's bring this back next time.

POLL Result: No objections, unanimous consent. 

AR: make sense, more comfortable following the doc, if yall could prioritize this, it will be helpful

EZ: we will do that

#### Poll to advance [typed (function) references](https://github.com/WebAssembly/function-references/) to phase 2 or 3 (Andreas Rossberg)

<TODO: AR to add slides>
 
JS: Why do you have as_non_null when you have br_on_null? Is it because as_non_null is trapping?
 
AR: It’s basically because in some cases the compiler knows it’s not null - forcing it to branch there would include code for no good reason
 
<back to slides>
 
KM: It's useful to know the number of locals at the beginning -- so let creating locals on the fly; that means locals are dynamic by block. Might be a problem for fast code generators. Can we put a limit on the number of locals.
 
AR: Technically we could, Agree that it’s kind of gross. What would.. Would just knowing the number be enough? Don’t you need to know which types they are? 
 
KM: I assume they're all just De bruijn indices, so the bigger question is what is the maximum index so I can reserve stack space for them.
 
AR: Yeah, I agree, seems like a simplification that’s maybe not sufficient for other implementations - good to bet implementation feedback here with real implementations
 
KM: From our implementation we'd have to do it with two passes, to gather the maximum index and then rewrite afterward.
 
AR: It would be possible
 
TL: Are we aware of any toolchain experimentation?
 
AR: Nope, want to advance to phase 2, then tools can start prototyping
 
BT: Would it be possible to predclare everything, but they must be let-bound before we use them...
 
AR: Then you get into control flow dependency issues
 
JS: Discuss on issue? 1 min left, should make a poll now if we want to.
 
DeG: More needs to be discussed. Phase 2 poll seems reasonable.
 
Poll: move to phase 2

|SF|F|N|A|SA|
|--|-|-|-|--|
|3|21|8|2|0|

ms2ger: Against for lack of actual spec text
 
DeG: There's been a precedent for that happening for other proposals too. Ross, do you want to say why you're against for notes
 
RT: it came up that subtyping and typed func ref have very important interaction, and we haven’t talked much about it yet before we move ahead
 
AR: There's no function subtyping here though, right?
 
RT: since there is no subtyping yet, if we were to add it later, then performance will be very different. Adding contravariance is not something you wanna do lightly. I want a plan.
 
DeG: 2 mins over, please follow up with issue on repo

### Closure

"
main/2018/CG-10-02.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 2 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: October 2, 4pm-5pm UTC (October 2, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email JF Bastien or Ben Smith to sign
up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. The `ImportObject` is required for `WebAssembly.instantiateStreaming` and can be difficult to pass in some cases, see https://github.com/systemjs/systemjs/issues/1757.
    1. [Funclets proposal](https://github.com/WebAssembly/design/issues/1227) (Dan Gohman)
       * Poll: Accept for stage 0
    1. Consider renaming instructions containing slashes and colons. See https://github.com/WebAssembly/nontrapping-float-to-int-conversions/issues/4#issuecomment-423381162
    1. Discuss creation of a repository for a reference sysroot implementation for C and related languages. (Dan Gohman)
       * Suggested name: https://github.com/WebAssembly/reference-sysroot
       * ""Sysroot"" is a C-oriented term, and this will be a C-oriented repo (and languages that need similar support)
       * Not everyone will need this. That's ok.
       * Purposes:
          - Provide a usable minimal execution environment for C and related things
          - Define low-level interfaces to promote interoperability between different implementations
          - Prepare for future syscall standardization discussions
    1. There is some positive discussion on an [issue in the tool-conventions repo](https://github.com/WebAssembly/tool-conventions/issues/63)
       proposing a custom section that describes the producing toolchain.  Is it worth
       specifying in the core spec's Custom Sections appendix (after the Name Section)?
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Alex Crichton
* Adam Klein
* Andreas Rossberg
* Arun Purushan
* Ben Bouvier
* Ben Smith
* Ben Titzer
* Conrad Watt
* Dan Gohman
* David Piepgrass
* Deepti Gandluri
* Derek Schuff
* Francis McCabe
* Gordon Aplin
* Heejin Ahn
* Jacob Gravelle
* Jay Phelps
* Keith Miller
* Lars Hansen
* Limin Zhu
* Luke Wagner
* Michael Holman
* Mike Rourke
* Nick Fitzgerald
* Pat Hickey
* Peter Jensen
* Richard Winterton
* Sergey Rubanov
* Shiv Kushwaha
* Sven Sauleau
* Thomas Lively
* Tobin T
* Ulrik Sorber
* Yury Delendik

### Find volunteers for note taking (acting chair to volunteer)

Lars to help (thanks!)

### Adoption of the agenda

Jay seconds

### Proposals and discussions

#### Review of action items from prior meeting.

#### The `ImportObject` is required for `WebAssembly.instantiateStreaming` and can be difficult to pass in some cases, see https://github.com/systemjs/systemjs/issues/1757.

Skipped because Sven isn’t on the call.

#### [Funclets proposal](https://github.com/WebAssembly/design/issues/1227) (Dan Gohman)

DG: proposal is on a github issue on the design repo, really just asking for stage 0 at this point, ie that committee is willing to consider it

DG: questions?

* Poll: Accept for stage 0

Unanimous Consent

AI(BS) Will create a new repo for this.

#### Consider renaming instructions containing slashes and colons. See https://github.com/WebAssembly/nontrapping-float-to-int-conversions/issues/4#issuecomment-423381162 (Thomas Lively)

TL: As we’ve been implementing the assembler, running into issues with these characters. We have support in assembler thanks to Wouter for slashes. On GH issues we have consensus to remove colons from instruction names. They are only present in recently proposed instructions. Should we remove slashes from existing instructions as well. In conversion/float-to-int instructions. Shipped for quite a while. We have a workaround for slashes, but kind of ugly. Is it too late to change instruction names?

RW: There are 4 instructions, right?

JP: Is there any proposal for replacement of slash?

TL: Replacing with underscore, period. We need to bikeshed.

DG: There are about 25 instructions that use slash. That was the convention in MVP.

FM: Presumably will have a grace period.

TL/DS: We could accept both. There are a few tools, spec interpreter and wabt. What are we imposing on people outside those tools.

AR: There may be actual source code on the web. I would like to expand this for other names too. table.* and global.* If we want to, perhaps bikeshed offline.

LW: Q is: Are we open to a big text change?

BT: spec tests are text format and have to change, but wouldn't ""break"" per se

KM: Do we know of any tooling that will break on this?

JP: With the change of the memory instructions, made it difficult to update binaryen. Had to fix spec text changes before I could land my PR. We didn’t think about how it blocked other changes in a trickle down effect.

TL: The tools team could try to coordinate this.

BT:  If we're going to do one renaming we should do it in one big step

BS: We should do this before we move the spec document to CR.

HA: Can we just change LLVM?

DS: We can, but it ends up being a bigger change to the assembler.

Poll: Should we consider making changes to the text format?

Unanimous consent

AI(TL): Turn this into an issue.

#### Discuss creation of a repository for a reference sysroot implementation for C and related languages. (Dan Gohman)

* Suggested name: https://github.com/WebAssembly/reference-sysroot
* ""Sysroot"" is a C-oriented term, and this will be a C-oriented repo (and languages that need similar support)
* Not everyone will need this. That's ok.
* Purposes:
  - Provide a usable minimal execution environment for C and related things
  - Define low-level interfaces to promote interoperability between different implementations
  - Prepare for future syscall standardization discussions

DG: Coordinating low-level ABI details

DG: There are at least four ABIs out there

DG: Fix some type variability

DG: Fix Y2038 problems right now

DG: Want to expose common C interfaces we use across toolchains and libraries, for interoperation

DG: There are discussions at tc39 about builtin modules, functions that can be shared across JS implementations (node, browser), is there something here that we can share with wasm.

BT: I like this proposal, is it mostly to implement the C language standard.

DG: This is closer to what C calls a free-standing implementation. It’s the set of things that don’t need to do syscalls. I think it makes sense to include malloc, because we can use memory.grow. Will not be the be-all-end-all, because we will want different implementations of malloc for example.

BT: Do any of these require engine implementations?

DG: What we have currently, no. It’s the set of things that doesn’t require engine support. Memcpy, memset, compiler_rt for 128-bit math. Things that compilers will generate on their own. Stabilizing those things. Typedefs too, 2038 bug. Make sure that we use the same sizes for these things.

AR: This would define a kind of ABI. Why not make it a specification of some kind.

DG: It isn’t really in the core spec. I’m thinking in terms of a ref implementation. It would define the interfaces as an existence proof. If we want to right in doc that would be cool too.

BT: What about things like returning struct values?

DG: I think that would be good too. Clang has a set of conventions that are not controversial. For multi-value we may want to change.

BT: May want to coordinate with C API as well.

DG: I’m hoping to avoid the C++ ABI. Itanium shows that we can perhaps coordinate the ABI, but I’d like to skip that.

KM: How will that work with passing between host and the wasm module, for strings etc.

DG: We would have memcpy that implicitly copies in linear memory 0.

KM: Not defining interop between modules, 

DG: No, just for toolchain coordination, just trying to avoid mutually incompatible libc implementations.

LW: Poll?

NF: (chat) Will this cover bit fields in the ABI?

DS: The C ABI should cover this.

FM: (chat) How is this different from host bindings for C?

DS: This is about wasm-to-wasm, not wasm-to-host.

DG: We could imagine defining something that would be host-bindings for C. This proposal would help for this.

BS: is it appropriate to have a new repo, or should this be in tool-conventions - who has an opinion?

DG: tool-conventions is all text, this is supposed to be code

DG: tool-conventions may be about the C compiler's ABI (enums, bitfields)

RW: If we were to do a host bindings for C, … [missed this]

DG: No imports, should be able to do with pure wasm.

NF: (chat) it is nice to have a new repo so if people are only interested in this they can unfollow the other issues. 

POLL: Create a repo for this?

Unanimous consent

AI(BS): create a repo.

#### There is some positive discussion on an [issue in the tool-conventions repo](https://github.com/WebAssembly/tool-conventions/issues/63)

proposing a custom section that describes the producing toolchain.  Is it worth
specifying in the core spec's Custom Sections appendix (after the Name Section)?

LW: would be nice to have a custom section that says what the originator of the code was, to allow us to measure in the wild (telemetry) what tools are being used etc

LW: If we want to do telemetry, we can expose the bit fields and not just a UA-string (which has privacy implications).

LW: step two is to give it a little bit of structure with some defined field, eg source language, coming from a github enum, say (field names, not field values necessarily)

LW: might be something about how the code was processed (bindgen, binaryen)

LW: etc

LW: open format so that there's space for custom parts and ad-hoc extensions

LW: if this is useful, would it go in the core spec appendix, along with the custom section?

JP: There have been some discussions about representing textual representation of custom sections. Seems like you may lose that info.

LW: You could make a text conversion for this. So you could grab the info from a GH markdown link.

JP: What about version numbers?

LW: The strings would be fixed thing, but you could have a version.

AR: I think this is useful in general. Only concern, there might be tools that depend on or differentiate on this information. There was an example in the discussion.

DG: GDB was mentioned where they sniff this and change behavior.

LW: If debuggers are a problem, then perhaps it belongs in that subcomittee. If it is somewhat standardized then people may depend on it.

AR: Maybe an argument for making it harder to process. [half joking]

LW: Engines can do whatever they want, but we could censor it.

TL: This is kind of a slippery slope; tools and versions, then you may want to add options they were called with.

LW: We already have this risk. Tool could mention custom section that has hot functions. If I was doing this for diagnostic, I may actually check for valid information so people wouldn’t try to sneak info in there.

TL: Do we need guidelines for how we consider features that require new custom section data? We want to unify our approach.

DS: Part of the reason for custom sections, is to allow people to do whatever they want with it.

LW: Still could be validated.

BT: BTW, about hot functions -- we will have an intern work on this this summer.

FM: (chat) we should follow a standard like that for exif and jpeg. Adding metadata to wasm presents many long term issues. Rather than doing this in an ad hoc way, we should try to follow a standard and/or best practice. Two examples to look at include EXIF and Dublin core.
In addition, there are standard ways of representing version numbers.

BS: In general it sounds like we support, maybe just a question of how official.

AR: We may not want to put this in the core spec.

DS: Yes, perhaps put this in tools conventions.

DP: (chat) Minor thing: “I proposed a text format for WebAssembly which was rejected, though I never found out why.” It didn’t seem like there was much discussion about this.

BS: We ignored several text formats, a number of people were probably feeling that the text format was not all that crucial.

BT: We did discuss this some, but at the time it wasn’t as important to us as the binary format. We almost didn’t include it at all, but it was advocated that we really should have it.

### Closure
"
simd/2021/SIMD-10-29.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the 2021-10-29 video call of WebAssembly's SIMD Subgroup

- **Dates**: 2021-10-29
- **Times**:
    - 4pm-5pm UTC (9am-10am PDT)
- **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this [form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking
1. Adoption of the agenda
1. Proposals and discussions
    1. Spec text changes (Zhi An Ng)
    1. Prototyping status (Zhi An Ng)
    1. Deterministic FMA
1. Closure

## Meeting notes

### Attendees

- Dan Gohman
- Marat Dhukan
- Zhi An Ng
- Deepti Gandluri
- Arseny Kapoulkine
- Richard Winterron
- Mingqiu Sun
- Johnnie Birch
- Thomas Lively
- Petr Penzin

### [Spec text changes](https://github.com/WebAssembly/relaxed-simd/issues/19#issuecomment-949025272)

Presenting Spec changes: https://www.ngzhian.com/relaxed-simd/core/exec/numerics.html#relaxed-operations

ZA: Suggestion to move in a different direction. Each relaxed instruction returns a fixed-size set of results. Results can be different depending on the inputs. The spec defines the meaning of “relaxed” in relaxed SIMD instructions.

AK: The spec says here’s the superset of the hardware behavior, this is interesting - when we looked at dynamic swizzle instruction, Power PC had some weird behavior, simpler for FMA. For bit selects, when you take a minimum of a NaN and something else. Does this lead to not supporting architectures, or block lowerings for some floating point instructions - how are we thinking about - do we need to have a rigid set of rules for some operations?

ZA: There is a risk that we’re blocking some architectures, the spec text is not fixed. For the set of results for the operations should be fixed at times

AK: For a given target platform, for a given set of inputs the outputs will be same. Non-determinism within the same execution

ZA: When we get to phase

DaG: in theory we want to support all specs, in practice not that possible, how much do we other arch to target this proposal

MD: only one we need to take care of is power, other arch are much less popular, or no SIMD yet, and when SIMD added, will take into account of Wasm SIMD and relaxed SIMD

PP: We’re looking into min/max - common things would happen where the sign would be non-deterministic. If we look at what other libraries or standards do, we would expect that it runs into everything

ZA: Relaxed operators themselves, the results can be non-deterministic. Fmul, fadd results can be non-deterministic, the operators themselves can be non-deterministic

PP: If you look at libc, you would likely support more architectures

RW: Could we do a category, if an ISA switched from one type to another,

ZA: Current spec doesn't say anything about hardware, you can switch between the verticals of results, as long as it’s consistent
RW: Can you have a compatibility mode for hardware? Don’t know that that would occur

ZA: Suggestion is looking at other architectures - PowerPC, RISCV,

AK: It’s an interesting instruction set, not sure how well it maps to the baseline SIMD proposal

MD: Riscv doesn't have the SIMD extension

AK: If the baseline spec doesn't map, then that’s a separate interesting problem

MD: Arm MVE is an emerging ISA, we could be looking at it. ISA for microcontroller

PP: RISCV you could say I want a certain set of elements and get it, you could emulate SIMD instructions

MD: Can’t do swizzle operations for example

ZA: General direction of hardware picking a certain set of results, are there any further concerns?

PP: The reality is that you have to define in the broadest way possible. NaNs and 0s are implementation defined, no matter which architecture we target it’s still going to work.

ZA: Comments on text and approach welcome, will be asking for Phase 2 at the next CG meeting. Any comments/concerns?

PP: If we do relaxed min/max this way - means that some architectures could return, instead of swallowing or propagation g it returns the first one etc. How do you think developers would distinguish between those behaviors?

DaG: Are there architectures that do anything other than x86?

MD: Didn't look at Riscv vector extensions, baseline returns MinNum, MaxNum. On x86, min/max instructions on SSE a < B return a, AVX512 does something different when comparing signed zeros it returns the right one based on sign. So even on x86 there are two different behaviors

PP: For swizzles we could do something different, if you don’t rely on out of range indices.. But for min/max it’s different. Do we expect developers to ignore ambiguity, or have semantic checks?

MD: Results are only guaranteed if inputs are guaranteed, only in case where precision to that level is not important, this is the baseline assumption for relaxed-simd

### [Prototyping status](https://github.com/WebAssembly/relaxed-simd/blob/main/proposals/relaxed-simd/ImplementationStatus.md)

JB: Do we need more than one implementation?

ZA: For eventual phase advancement to phase 4, not needed for phase 2

### Deterministic FMA

DeG: We used to push for having scalar versions map to vector operations to make sure there was a way for architectures that don’t have SIMD supported have a way to match the semantics with scalar operations, but none has used it, and it’s a maintenance burden, not sure about the ROI of a separate proposal that adds scalar versions

MD: for scalar version, we have add in Wasm 128 load zero and store lane instructions, these are supposed to be use for loop remainders, don't strictly need scalar ops for load remainders. Preferable to use SIMD instructions, behavior of SIMD differ slightly from scalar, users will be surprised if result in loop remainder is different. Supporting of FMA in Wasm, don't think should be part of relaxed simd or SIMD in general, unlike most other instructions, FMA is fundamental for floating point, similar to sqrt or div, in fact some CPUs don't have anything except for FMA, implement plus times divide using FMA. Different from other instructions, many of them only make sense for DSP and only exist for SIMD version. I will be supportive of Wasm proposal to just add SIMD and scalar of FMA.

PP: relax simd will pave the way for for det fma, if we can have relaxed, then definitely can have det. For scalar version of other instructions, in regular SIMD we have pmin/pmax, can be added to scalar, they can be used in some cases for faster min/max. Not sure how much we care about scalar floating point ops, everytime someone needs perf they will write SIMD. But for symmetry we can have the same ops and vectorize.

DaG: if using LLVM, and autovectorize, how will it generate a loop without the scalar

MD: LLVM can also use a SIMD instruction in place of scalar, most modern CPU run same SIMD as same throughput as scalar

AK: It doesn’t seem like something we want to do in LLVM. There are use cases where FMA scalar would be useful. Purpose of relaxed-simd proposal has been guaranteeing some form of determinism, but guaranteeing performance. There are valid use cases where scalar FMA is useful, and using vector FMA is worse. IF you’re paying 4 times the cost with an emulated FMA

DeG: from engine perspective, see how scalar fma can be a separate proposal, for the ones we have vector instruction, then try to map the scalar back, haven't seen a lot of value. Curious to hear what use cases you have in mind

AK: precise floating point algorithms, given a sequence of floats, give the exact value for sum, paraphrasing this. Vectorization there is difficult, may be possible in some cases. Even if part of it is vectorized, there will still be scalar parts. This is where FMA has to be actual FMA. 2 different types of FMA, don't care and want quick way, another type where FMA needs to be exact. Some algorithms are not vectorizable, you can use vectors, but waste lanes, and run into more problems. Might be useful to prototype, compare performance, but slightly dangerous route.

MD: Thinking about it more, on CPUs that don’t support FMA we may want to emulate with scalar FMA instead of vector FMA.

DaG: The value of using relaxed-simd when communicating with developers. It needs to be easier to communicate what the FMA story is - falling back to QFMA or not, it’s not clear what how we would explain this

MD: simd and relaxed simd focused on performance. relaxed fma fits this. deterministic fma is fundamental. will be understandable if it is not part of relaxed

PP: The output is different? Not only timing?

MD: there are intel cpus which don't support FMA, everything that doesn't have AVX2, most intel atom. those are sse4 only

PP: you'll be stuck, what's the solution for det fma?

MD: emulated

DaG: software yea

PP: if we do fma on arm, powerpc,etc, will the result be the same?

MD: with exception of denormalized numbers, results will be the same

DaG: exception behavior, not exposed in wasm

PP: Well if it’s consistent in terms of NaNs, we should be consistent across the board

MD: arm neon on 32 bit arm doesn't support denormals but support FMA

DaG: ARM Neon doesn't support it at all

PP: Wasm supports denormals across the board, why we have the min/max semantics that we do. If you look further in JS does it too
DaG: It also comes for IEEE754, we aligned the spec with that. The discussion is pretty old, 2008 was wrong, they decided to fix that but discussions were still in  progress then. But we aligned with that and now it’s live

PP: fma is not defined in JS, we can define whatever we want. Since we are forced to handle denormals, have to think about how diff arch handles it.

DaG: MD, do you know other platforms that have different subnormal handling?

MD: powerpc altivec will also have floats without denormals, almost all support vsx on power today, so not a big concern. Probably ARM NVE doesn't support it

DaG: It doesn't support subnormals across the board right?

MD: its microcontroller, not surprised if they don't support denormals

DaG: We already don’t support those platforms, because of the determinism discussion in the earlier SIMD proposal

DaG: on those, emulated if not supported. You can use qfma with special inputs, check results. Then you know if det fma is fast.

DaG: This already aligns with how different programming languages work, or they have a way of testing which intrinsic is fast, then they use the deterministic FMA operator.

PP: will be similar if you want to determine if relaxed op is similar to det.

DaG: standard library can't do that, they need deterministic fma to implement semantics

MD: If the users want to check whether FMA would be fast, then most likely they would like not use the emulated FMA

DaG: make sense to give them a way to check if fma is fast

MD: in practice i don't expect dev to write code on slow fma case

DaG: Depends on developers

TL: if language standard libraries need det fma, can we have standard library do this check? then fall back to their own software fma? rather than baking into Wasm in the engine?

DaG: Hadn't thought about that

PP: could be easier, or not. Not sure about the cases this would work. In some cases it will be slower. Depends on what else the library does, you can slow it down even further.

DeG: we talked in the past about is-this-fast primitive. Aside from FMA, it is easy for dev to query if something is fast, seems useful as a general primitive. The way we spec relaxed simd, doesn't look like it, but curious about other cases.

PP: can check if regular simd is fast, if not then can use the relaxed one. Personally think not a bad idea, give user a choice if they want to take this path or not. Depends if we are differentiating between different flavors or not.

DeG: it's binary, just fast

PP: you can build a profile based on this. that said, not sure if it's a big deal from privacy point of view. OTOH, it is generally useful to have something like this, people will still find ways to determine if instructions are fast or slow. there is a need to do this anyway, if we standardize it, might be a good thing.

DaG: FMA is kind of an operation that gets inlined, adding a load/compare/branch around every FMA may be an observable performance difference

TL: yea fair
"
simd/2021/SIMD-05-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 14th video call of WebAssembly's SIMD Subgroup

- **Dates**: 2021-05-14
- **Times**:
    - 4pm-5pm UTC (9am-10am PDT)
- **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this [form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking
1. Adoption of the agenda
1. Proposals and discussions
    1. SimpleV (Jacob Lifshay)
    1. Masks (Florian Lemaitre)
    1. SVE implementation in SIMDe (Evan Nemerson)
1. Closure

## Meeting notes

### Attendees

- Andrew Brown
- Arun Purshan
- Deepti Gandluri
- Evan Nemerson
- Florian Lemaitre
- Jacob Abraham
- Jacob Lifshay
- Jan Wassenberg
- Marat Dukhan
- Petr Penzin
- Rich Winterton
- Zhi An Ng

### SimpleV (Jacob Lifshay)

JL: SimpleV is the instruction set designed for LibreSOC, vectors up to length 64 (number of elements). Like RISC-V ‘V’ extension, variable vector length register, CPU designed such that all implementations always support length 64 vector, can execute one at a time or execute groups of elements.

It supports fixed-length vectors on all archs, you can set the VL register to whatever value you like. 

EN: any way to use this today? A compiler or library to emulate it?

JL: software emulator, written in python, you can find it at libre-soc.org.

EN: will be interested to adding support for SIMDe to experiment a bit

JL: don’t think we have assembler/compiler for that, people working on GCC

EN: lmk when you do, i’ll be interested

PP: how do you run this now? Fpga impl?

JL: working on FPGA implementation, working on asic for it, can also find source code for that at libresoc

PP: different ways of executing it, sometimes you have vector processing, what kind of configurations do you support.

JL: currently, the instruction decoder part will take the SimpleV instruction, spit out every single element, to the instruction scheduler will group together and send it to a SIMD execution unit that executes it at once.

PP: interesting

EM: you could have 22-bit vectors, by passing that in length registers

JL: 22 bytes

EM: no real need to worry about predicates, you use that registers, no predicates?

JL: yes you have predicates, if you want first 3 lanes but not last 4

EM: mixing on and off, dedicated predicate type? Or a second vector and you AND them

JL: dedicated predicate type, ISA is based off on open power, vector of conditional registers, also support just bits in a 64-bit integers. This is why we are limited to length 64.

PP: worked with open power a bit, vector of conditions are hard to manage

JL: not based on open power SIMD support, independent thing. It is based on scalar instruction, prefix, runs in a loop

PP: cool. What kind of performance do you see / expect to see from this

JL: for initial implementation, we set it up with 128 bit wide SIMD execution units, we’re using an older process to keep costs down, we’ll probably end up limiting to 800 mhz. 50 gflops. 4-core processor.

PP: how will this compare to something else, say when you take ARM or Atom.

JL: we have been comparing to Raspberry Pi GPU. approximately equivalent

FL: q about vector length, what is the goal of the vector length register, is it for loop prologues, or just to set up preferred length of computation

JL: vector length register tells the processor that you don’t have to execute all 64 lanes, just 5 or whatever you set it to. You won’t have to do 16 clock cycles when you only have to do 2, if the processor can only do 4 lanes at a time

FL: what happens when you reduce VL to data that is out of bounds in registers

JL: we have instruction for setting VL, kind of like simpleV one, it is just an immediate to instruction, compiler will set it based on number of registers allocated for the instruction

FL: not clear

JL: instruction has an immediate that says maximum length allocated, another arg that is an int arg, will use the smaller one as the vector length, the programmer can have a loop that goes back to do the next X elements. Language level help for loop strip mining. Better than traditional SIMD instructions, we don’t have huge gigantic complicated code for cleaning up the extra ends.

FL: assuming we want to do a sum of an array, what you would do with predicate and mask is, each iteration, the full length, last iteration you mask the load of the last elements, with set length like in RISC-V V, last element of accumulator mandated to stay, thus when you reduce the elements of the register, you reduce all the elements, and not only the remaining ones. Is this the same in SimpleV?

JL: yes, if you have VL set to less than max length, it won’t modified any of the element past the vector length. Perhaps unlike RISC-V V, not sure if they require elements to be unmodified. If you run the configure vector instruction, it throws away all the stuff.

FL: RISC-V elements after vec length mandated to remain the same value

JL: good, then it is the same

JW: that is configurable, that is a mode to choose between undisturbed and don’t-care

PP: when you came to say that you are working on open source SOC, it was unclear what it means, looking forward to see progress.

JL (chat): iirc here's the SimpleV link https://libre-soc.org/openpower/sv/overview/

### Masks (Florian Lemaitre)

[Slides](presentations/2021-05-14-lemaitre-rfc-masks-challenges-for-wasm-flexible-vectors.pdf)

PP: we have different archs that we want to support that have masks, not the same general mask support, not the same interaction. It won’t be easy to reconcile. When you compare the mask representation it is different. There are also different operations, difference between AVX and SVE.

FL: most of the operations you could do the operation on another register, then do a select, this is the naive fallback, if there is a missing operation, except for stores.

PP: don’t know how easy it is to represent that in tools (LLVM), compilers don’t expect that the mask operation returns result and masks

FL: don’t have feedback on this, don’t know well enough LLVM

PP: LLVM is less of a problem, it’s more how complicated this will be. If we take some common code that we want to support using this, are we going to have explosion of the return values, maybe you need a different variant of instruction that does not return the mask.

FL: if you go this way, you will have many opcodes and this might not be something we want. That’s why I was thinking about a mask stack, where mask operations just read the mask stack, but don’t touch it. And only operations that write masks actually pop this stack.

PP: This is kind of a global state. We have in the relaxed simd proposal, an environment, we can set this similarly. If you have to constantly update something on the stack, it depends on the situation, what the engine can see and optimize out.

FL: don’t know how to handle, if the Wasm engine is able to detect that the mask is full with constant folding, and with monomorphization, basically you will probably not need to add separate instructions for with mask and without. Problem is that you will need to have a different instruction for zeroing operations and merging operations. Because those two are useful. But maybe this can be encoded in the type of mask, not sure.

PP: we should try to solve this, not necessarily going to happen right away. As we push forward this design, we should try to make sure we don’t cut of masks, need to keep the door open for them to be added.

FL: anyway, masks are basically mandatory because 128-bit SIMD we don’t need mask, there is the implicit mask being a full register. In SVE and AVX-512 and RISC-V V, when you compare, e.g. if you get a mask, you don’t get a vector. If you say comparison returns vector, then you need a smart engine that doesn’t do the double conversion from mask to register and other way.

PP: anyone else has questions? AP has an hand up.

AP: forgot to turn it off.

JL: might be helpful to see what Rust compiler is working on for the design of their portable SIMD library. They tried to have a default mask be an opaque mask, there is a separate mask type for each width of element, layout is not specified to be any format.

FL: yea, think that is the way forward

PP: basically have to have a portable mask type, the challenge is where and how and at what level to translate to hardware. Whatever we can invent in terms of portable type and how it maps to hardware instruction.

### SVE implementation in SIMDe (Evan Nemerson)

EM: FL covered a bunch of problems. I can cover some practical stuff. Just started implementation of SVE on top of AVX-512, NEON, altivec, Wasm, etc. By far, the predicates are the most painful. That is the only area where we have had trouble. What we do now is, SVE has that svbool_t that represents everything, that is in SIMDe an opaque type, which has an mmask64 variable, everything is at the c value, intel k registers on AVX-512. We store separate what type it is, that difference in how stuff is represented in memory is the major problem. SVE api section 3.5, talks about how the least significant bit in every lane controls everything, the holes don’t affect it. There is no good way to get that out for the API. Overall if you use the API as it is intended, you don’t see problems. Clang is good at eliding all the code to check, everytime we run an operation, we want to pull the mmask variable out of opaque type, and check it matches. Good way in AVX-512 to convert mmask8 to mmask16, but no way to go backwards, clang elides all that. Can share an example on compiler explorer. Fixed length loop using SVE api, compiles to exactly what you would do if you would write AVX-512 natively. GCC doesn’t look as well, haven't looked at MSVC, not had good experience with MSVC optimizations. Most complicated is predicates, everything fell into place neatly after solving that. I like the idea of exposing predicate types in flexible-vectors proposal. Came to the same conclusion as FL, the way to go to iron out differences in the arch is to have different types for different element types (8-bit lanes, 16-bit lanes, etc.) If you did that, everything kind of falls into place, and works out neatly, from my experience on SIMDe. AVX-512 on SVE, intel has a richer set of permutation operations for 512 bits and 256 bits, SVE’s permutation and selection is quite limited. There is an issue out there to add zip and unzip, don’t think SVE supports pair-wise operations, pair-wise addition. With zip and unzip it will be trivial to implement those. There is TBL, like swizzle in Wasm SIMD, that operates on the entire vector. You don’t know at compile time what vector length, you may have 512 or 256. It is any multiple of 128 bits, not just power of 2. You can have 384 bit vectors. A64 FX, only hardware with SVE support, it supports 128, 256, 512, doesn’t support 384. You can request specific lengths if the compiler supports, but not guaranteed. You cannot count of any specific length being supported. Overall, permutations are big, biggest ones are predicates.

JL: when i looked at SVE spec a while ago, they guarantee all power of 2, not the other ones.

EM: will take your word on that.

PP: it’s not that one is worse than other for permutations, but just different philosophy. We had these sort of issues on Wasm SIMD spec, some operations become so expensive, you add more and more instructions and become more complicated. Once we get number of opcodes under control I’ll go back and look at permutations. This meeting ends up being about masks for most part

EM: expect many more meetings will be about masks.

PP: exception of RISC-V, masks are most important, that’s how you turn lanes on
"
wasi/2021/WASI-07-29.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the July 29 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: July 29, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Lin Clark
    - Email: lclark@fastly.com

### Registration

None required if you've attended before. Email Lin Clark to sign up if it's your first time.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. [WASI data API](https://github.com/singlestore-labs/wasi-data) - create computational DAG's with WASM modules using map, filter, and join semantics (Bailey Hayes, 20 min, [slides](presentations/2021-07-29-hayes-wasi-data.pdf))
    1. [Interface Types Update](https://github.com/WebAssembly/interface-types) - an update on where the interface types proposal is at and how it affects WASI (Alex Crichton, 30 min, [slides](presentations/2021-07-29-alexcrichton-interface-types-and-wasi.pdf))

## Notes

### Attendees

- Lin Clark
- Till Schneidereit
- Andrew Brown
- Pat Hickey
- Luke Wagner
- Matt Fisher
- Alex Crichton
- Piotr Sikora
- Syrus Akbary
- Arun Purushan
- Bailey Hayes
- Mingqiu Sun
- Johnnie Birch
- Francis McCabe
- Radu Matei
- Ralph Squillace

### WASI data

**Bailey Hayes** Principal Engineer at SimpleStore, database. Been tossing around an idea internally. For wasi-data, idea to support embarrassingly parallel data streams. Working well beyond gigabyte scale, and IO bound. Scale means distributed. Things tend to fall over, so needs to be resilient. We’d have record types for a dataset, a row.

Map reduce is special set of split, combine, etc. This brings compute to the data. Early one is Hadoop. Flink adds a ton of different operators. … Also threw in Apache Bean here. Level of sprawl that’s happening on how to run analytics on data is kind of a problem.

When talking about a distributed map reduce problem, lots of ways to connect. For Hadoop, distributed fs, ours is distributed database. Quite a bit of data sharding happening. That means there’s a runtime that knows where the data is. Wasi-data shouldn’t fill exactly that gap. You write your mapper, etc in your preferred lang, then load into distributed runtime. Those systems would have Wasm runtime.

For a lot of data scientists, they need it to be whatever tool they know. Also talking about heterogeneous architectures. Also need isolation to run in managed service. Can’t take down the database. Because of work in IT, being able to compose wasm modules is really interesting too. We’d be able to have the same module run virtually anywhere. WHy WASI, typically need to integrate with hardware acceleration etc.

End with an example. We would want these to be structured, strongly typed, and hopefully ergonomics would be solid. Finding the through line through all of these existing runtimes.

**Francis McCabe:** What’s the relationship between what you’re working on and event analysis?

**Bailey Hayes** A lot of these platforms are event driven. You’re perhaps thinking about constant time, that’s also relevant.

**Francis McCabe:** Let me make sure I understand correctly. Don’t mean crypto.

**Bailey Hayes** A lot of times with a database you have the same concerns that crypto has. Don’t want to expose the system clock.

**Luke Wagner:** Thanks, really interesting. I like your intuition, seems right on. For dev ergonomics, is there a driver script on the outside, and then there’s an inner layer of Wasm modules.

**Bailey Hayes** I think you described it really well. I imagine initial approach will be modelled on how things work today. One wasm module exposing several functions. Nice that you have some caching involved. When you’re distributing this kind of thing, lots of problems with global state.

**Luke Wagner:** That also sounds right on. How do you imagine this being exposed to the programmer, since we won’t have distributed global vars?

**Bailey Hayes** Finely data flow does this well. …

**Luke Wagner:** Are you imagine people composing different langs?

**Bailey Hayes** I think absolutely people will take off the shelf with a variety of languages coming together.

**Ralph Squillace:** First time thinking about this space, really enjoyed, lots to chew on

**Andrew Brown:** Great presentation, thanks. Over at Intel, we’ve been thinking about similar things on a single machine. We’re thinking about a parallel API that might be able to compare and contrast. Can probably present next time. Separate from wasi-nn. We realized that there’s a separable problem.

### Interface Types updates

**Alex Crichton**: Current status of interface types plus some work I’ve been doing on tooling, and how all effects WASI.

Overview—IT isn’t yet a formal spec, so WASI is kind of using it, kind of not. Given lack of target, kind of there, kind of not. Moving away from a C like def, moving towards what it actually is. Moving towards of official IT means that there will be some breaking changes. Lots of code generators, in between.

Where’s IT currently? General idae is making the set of types that Wasm is working with much richer.

Main thing is that it isn’t going to be as ambitious as Wasm, but about defining interfaces. This isn’t specific to any language. That’s why the type grammar is pretty general. Another thing is that IT is very abstract. Finally IT are big on virtualization and seamless language support. Additionally, whenever you’re using this, no raw memory manipulation. I should just give you a string and something in the middle should figure that out.

IT explainer is a little outdated. What we’re intending to do is base on module linking, which is based on component module, which means this is a wrapper around a core wasm module. So IT doesn’t have a binary format yet, no engine impl yet, type grammar still in flux.

We have type grammar (slide)

The big thing about IT is that values are always valid. Records always have all their fields, enums have one of the constants, when you get something you don’t have to validate that it’s correct. Most interesting part comes around handles and push and pull buffers. Handles are supposed to be like extern refs but a little diff. When you import a handle, I’m guaranteed that it’s owned by someone else. Today, there’s indirection. Whenever you receive a handle, you don’t have to check that it’s valid. For push and pull buffers, these are meant for cases like read or write on things like files. WASI will primarily use for bytes, but can also use them for records.

Today, WSI is defined with s-expressions. Has downsides around readability and maintainability. Working on a curly brace version of this. New syntax is not going to 100% correspond to what IT is going to be. I mentioned that IT is a layer around the module. This is one half of the story. We’re saying you can import/export. Some of this is still in flux, but witx is one of these two halves.

**Francis McCabe:** One of the early discussions was whether IT was beginning of IDL or not.

**Luke Wagner:** This isn’t intended to be a text format for IT. Functionally equivalent to the s-expression. This might have more context once I get to the end

**Francis McCabe:** I have a comment. I think it’s fine for you to invent your IDL.

**Luke Wagner:** It is an IDL in a way, but compiles down to IT.

**Till Schneidereit:** I think a good way to think for purpose of this group is to compare with formalization used in the wasm core spec where that’s an invented mechanism that isn’t itself standardized. This is more an editors affordance. Purely talking about the syntax. Same way to think about this here. It’s the way editors write out the API for the standardized WASI APIs.

**Alex Crichton**: Next thing is a recent development—canonical ABI. So far talked about how IT isn’t talking about memory representation of types. Adapter functions can lift and lower. Problem with this is that adapter functions are going to take a while. Intention in the meantime is to have a canonical ABI. This is a temporary stop-gap. Will likely be used for a long time. Gives us something that we can work on today, and in the future with adapter functions then it can be optimized. So canonical ABI today mostly matches the C ABI. How do we productively define WASI in terms of IT today.

For Scalars/Records/Variants, do what C does. Strings are considered a specialization of list of chars. Rep of list is 2 32 bit ints. Handles and push/pull buffers (slide) Green boxes are validated by the runtime. Blue boxes are what you control. All modules have access to clone and drop. Memory management is implied here, done through realloc and free. Not required for ags to imports, which means when you’re calling module doesn’t need an allocator.

The glue around the module is what’s going to validate. This is all trusted code. This is not considered part of the trust boundary.

Talk about witx-bindgen. This is generating the glue code, plus code in the wasm module itself which gives an easy way to use. Have a demo on the web.

Brief taste (slide). Nice idiomatic Rust generated for you. Similarly, if you want to run on the web, it would generate JS and TS.

These are the high-level goals (slide). This is interface agnostic, so should be relatively easy to add new languages.

Last thing is what’s next for WASI and IT. The CG will get more agreement on canonical ABI. Soon after that, WASI would move towards IT for this. All of WASI’s APIs would be defined in terms of IT.

**Francis McCabe:** Can I ask about pull/push buffers. Is it your understanding that people will access buffer through intrinsics.

**Alex Crichton**: I should preface that these are the most likely to change of all the types. They have diff representation in imports and exports. So yes intrinsics on import, not on export.

**Syrus Akbary**: Super awesome work. I have a few questions. I found import and export naming confusing. Maybe host guest? I have a question regarding timing. When do you think things are more mature.

**Alex Crichton**: This is something that will be driven by the Wasm CG. We want to follow what the CG does with IT. IT is still in flux. A lot of work to still be done there. So that is something that CG at large would have to answer.

**Till Schneidereit:** Regarding naming, this also applies to guest/guest.

**Alex Crichton**: I also find import/export naming confusing, so trying to think of different naming. Very much work in progress in these regards.

**Syrus Akbary**: Right now effort from other companies trying to define universal IDL. Think opp to define witx as a consumer for other IDLs.

**Alex Crichton**: If it works for other IDLs, free to use it.

**Luke Wagner:** The way that resources and handles work is likely to work differently in other IDLs.

**Alex Crichton**: One other hope is that 10 years from now no one thinks of witx-bindgen. No one should have to worry about witx when they’re developing wasm modules. The more everyone can forget about it, the better. We do have to think about it in the meantime, though.

**Ralph Squillace:** Speaking as someone from a megacorp defining IDLs, they’re critical, but they eventually go away.

**Till Schneidereit:** Should also be open to changing to formats, and shouldn’t have to standardize the tool using for standardizing.

**Francis McCabe:** IT is better viewed as a compilation target from an IDL. Don’t let IT take over the world. Instead it will work with everyone.

**Alex Crichton**: This is something for WASI in the interim state. IT is the standard.

**Syrus Akbary**: One thing I forgot to add. Is there anything we can help?

**Alex Crichton**: Probably mostly via the CG, pushing that forward. This is a difficult phase to help in witx-bindgen because thing is changing too rapidly. At least from my perspective, I dont’ want to go too far ahead of the standard so that decisions are made in the standard rather than de facto standardized in the tooling.

**Till Schneidereit:** Perhaps most valuable would be a completely separate implementation to validate that we aren’t boxing in 1 impl strategy for pushing the standard forward.
"
main/2022/CG-03-01.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 1st video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: March 1st, 5pm-6pm UTC (March 1st, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Update on [Branch Hinting](https://github.com/WebAssembly/branch-hinting) (Yuri Iozzelli) [20 min] 
    1. Update on [ES Module Integration](https://github.com/WebAssembly/esm-integration) (Asumu Takikawa) [30 min]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting notes

### Opening, welcome and roll call

###  Introduction of attendees
 - Deepti Gandluri
 - Derek Schuff
 - Asumu Takikawa
 - Pat Hickey
 - Yuri Iozzelli
 - Sergey Rubanov
 - Jeff Charles
 - Saul Cabrera
 - Danielle Church
 - Yury Delendik
 - Ryan Hunt
 - Chris Fallin
 - Zalim Bashorov
 - Sabine
 - Radu Matei
 - Keith Miller
 - Paolo Severini
 - Francis McCabe
 - Conrad Watt
 - Is
 - Guy Bedford
 - Mingqiu Sun
 - Sam Clegg
 - Alon Zakai
 - Emanuel Ziegler
 - Ben Titzer
 - Thomas LIvely
 - Dan Gohman
 - Nabeel Al-Shamma
 - Peter Huene
 - Johnnie Birch
 - Richard Winterton
 - Jakob Kummerow
 - Nick Fitzgerald
 - Manos Koukoutos
 - Andrew Brown
 - Ioanna Dimitriou
 - Slava Kuzmich
 - Jacob Abraham
 - Bailey Hayes
 - fitzgen

### Find volunteers for note taking

Acting chair to volunteer

### Proposals and discussions

#### Update on [ES Module Integration](https://github.com/WebAssembly/esm-integration) (Asumu Takikawa) [30 min]

AT Presenting [slides](https://docs.google.com/presentation/d/12cZ3FQizIJ7GGhegdSzRjnGp2l-gFsTlXfvUsAdN2No/edit?usp=sharing)

- WASM modules currently require (comparatively) heavy lifting to instantiate
- ESM integration allows ES6 module import statements to perform all instantiation/compilation
- Also allows WASM module `(import)` declarations to import ES6 modules
- Spec has been stalled in phase 2 since 2019; no web engines had supported, no test suite
- JS API spec draft: https://webassembly.github.io/esm-integration/

Recent developments:
- WebKit implementation landed behind experimental flag: https://bugs.webkit.org/show_bug.cgi?id=236268
- WebAPI tests added to Web Platform Tests
- still not a high priority for other browsers, need real-world use cases (CG member input point)
- Node.js has support behind experimental flag, Deno had support but removed it
- Webpack has experimental support; any Webpack community members can provide more information about its status?

Current state of proposal/spec:
- ESM integration only exposes instantiated modules. Should it expose uninstantiated modules as well?
  - Possible syntax mechanism: JS import reflection (https://github.com/tc39/proposal-import-reflection)
  - Current plan is to keep this as a future extension (CG member input?)
- import assertions: current plan, do not require for WASM (https://github.com/WebAssembly/esm-integration/issues/42)
- import maps: probably already works, since ESM modules in same namespace as WASM
- WASM exports: should exports object be a _module namespace object_ (and not just a frozen JS object)?
  - Probably out of scope for this proposal

Next steps:
- Has met technical requirements for phase 3, how does CG feel about moving forward?

FM: about CSP: I assume the proposal is to use the script-src policies for importing wasm modules. The problem is that the allowlist in CSP isn’t a good idea. We’ve been talking about having a separate policy verb (wasm-src rather than script-src). Do you have any thoughts about that?

AT: not an expert on CSP, not a very strong opinion. With the current plan, we would go with script-src, but if there’s a specific wasm way of doing it, not opposed to that. What is the plan for wasm-src?

FM: So far it’s just an informal discussion. Outside of esm integration, there is currently a keyword for wasm, it’s a bit of a hack. There’s been discussion about having a separate policy just for specifying wasm. People would like to have different CSP policies for wasm and JS. So that's one driver, the other is that the style of the policy, we’d rather not inherit the script-src style.

AT: Is it an issue that Wasm scripts can also import JS scripts? How do the policies interact in that case?

FM: In pure wasm, it’s not an option. It would be with ESM integration. We’d have to discuss that. When the loader loads a JS module, it would use script-src policy, and use wasm-src when loading a wasm module? Probably something like that.
Another question: wasm imports and exports more than just functions. There’s tables, memories, tags, etc. How would that work with esm integration?

AT: I glossed over this in the presentation, semantics of the proposal does support the other forms of exports as well. The other direction is that while it should work, it is possible to have cyclic structures, it may not work exactly in that case due to ordering issues, i.e. when a reference is undefined before it can used. In normal cases it should work fine

FM: does ESM allow cyclic graphs?

AT: it does between JS and wasm, but not between only wasm modules

FM: There’s a lot of work on the component proposal, and the module linking proposal, how would that integrate with the proposal? 

AT: some of the module documents already mention ESM integration. One aspect is module linking might require more features from ESM integration; the module linking proposal also allows you to import and export modules (e.g. adapter modules). So that might need additional capability for ESM integration. That’s one reason for the interest in import reflection. Probably these could be added on in a future proposal

FM: so if you  had a component with internal linkages , youd be able to add that as a component in JS?

DC: I have a couple strong opinions about CSP and a separate policy verb: one is about adoption and the other is about security. Given that it’s always possible for running JS to manually load wasm and run it, in that case the script-src policy effectively controls access to running wasm. Wasm doesn’t have more capabilities than JS because it’s relying on the JS host to get outside access. My adoption concern is that if wasm security is under a different verb, and whatever admin runs a site hasn’t explicitly added it, then it hinders the ability of devs to transition from JS to wasm. The other is about security. If you have someone that has a different policy where script-src is more restrictive than wasm-src, then a malicious actor can escape the script-src policy by compiling their code to wasm instead of just using JS. that seems like a pitfall.

FM: These are good points, but off topic for ESM integration, I would suggest raising these issues on the CSP [repository](https://github.com/WebAssembly/content-security-policy)

DG: I’m excited about seeing progress on this. For stage 3, are we accepting web-platform-tests as an acceptable test suite for this proposal? For this one I think it makes sense, wondering if anyone had concerns.
…
I don’t hear anything; I would recommend making that explicitly when going to stage 3.
I’d also be interested in hearing from browser vendors about how they feel about this.

RH: (Lars isn’t here today, proxying for him.) I think we are pretty neutral on this. I think we are ok with having a phase 3 poll, it’s just not a high priority for implementation for us.

DG: I think Chrome is somewhere between neutral and positive generally; we’d really like to see use cases, that would help us establish a priority for implementation as well.

#### Update on [Branch Hinting](https://github.com/WebAssembly/branch-hinting) (Yuri Iozzelli) [20 min] 

YI Presenting [slides](https://drive.google.com/file/d/14DSYWsEU7w_EFyhnOogAW_m6gKVwuDbv/view?usp=sharing)

CW: [regarding testing]: I’m sure engines would also be interested in tests with an invalid hint section, to test that semantics are still preserved

YI: Makes sense, roundtrip test wouldn’t easily include a test like this one, I agree having invalid hints would be useful - but even an invalid hint can’t make the module fail validation,

CW: I think the simplest thing would be 2 versions of the module one with invalid hints and one with no hints, and check that the output is the same.

YI: What kind of output do you mean? Output of the module would still be the same. Take the V8 implementation for example - a hint in a function that doesn’t exist, all the previous hints, and variables would be discarded, but the module output would still be the same

CW: Yes, I agree that what I said would test far less than the full report would show

FM: Maybe this is covered by a valid custom section..

YI: yes. In the spec it says it’s not a valid hint. It’s more tricky because if you take e.g. the V8 implementation. From an engine perspective it’s costly to see in advance if there’s an instruction there or not. Right now V8 will accept it when parsing the section, and then when parsing the code, if there’s a branch instruction it will check for a hint. But if there is a hint that doesn’t point to a branch it will just be ignored. Maybe we should change the spec? It might be a waste of resources to do extra work to validate it.

CW: Is it not the case that an invalid custom section doesn’t correct module validation? Can we discard the hints lazily?

YI: I think it would be correct to discard them even lazily. If you already used some of the hints but they are wrong, do you have to go back and discard, or can you use them anyway

DG: What kind of tests do you have for this in the engine?

YI: I think that for the engine it’s easier. In V8 there’s one test; it’s a unit test, so it just chekcs in C++ some bytes that represent the modules, and it asserts that the internal map of branch hints has the expected contents, so that’s pretty easy. It’s harder to have something that can be shared, that describes the behavior in a portable/engine-neutral way.

DC: Are the roundtrip tests testing only that the binary stays the same? Or do they mandate the intermediate text format as well? In other words, can the raw format of the binary be embedded into the module, or do the tests mandate using the textual annotation format?

YI: could be either way. Right now the testsuite allows binary modules to be encoded in text, or we could talk about the actual text format with annotations. There are a few tests in the annotation proposal, it just checks whether the annotations are accepted, but not semantics.

JK: As an engine implementor, I don’t feel great about the report production type of test, firstly we want tests that work in the wild, and secondly, this report would be very specific to the tes.

YI: that was my expected reaction from engines as well. This is one end of the spectrum. The other end is no tests, hopefully we can have something in the middle

CW: I think from a core wasm, the thing we’re most interested in is testing that even really weird hint sections don’t affect the observable behavior of the module.

YI: This is similar to the current approach with the annotations proposal as well, one of the things blocking from phase 4 are custom sections, there’s no guarantee that the annotations are preserved in the custom sections, so the round trip tests would be useful for this as well

BT: as far as testing the reporting: I agree that not every engine wants a reporting mode. But even if you have just one (e.g. ref interp), then you have at least one encoding of the expected parsing behavior, then new engines that come along can at least compare to that, even if it’s not expected that other engines reproduce the reporting.

YI: This will be like in the middle, the reference interpreter does implement this in strict mode, but we don’t expect V8 to actually implement it

BT: yes it’s an aid to engine implementers, even if they aren’t required to do the reporting.

DG: Other questions, or thoughts on branch hinting? Thanks to the presenters, and thanks for the discussion

## Closure
"
main/2019/CG-11-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 12th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: November 12th, 9am-10am Pacific Standard Time (November 12th, 5pm-6pm UTC)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Discussion of atomics with unshared memories (https://github.com/WebAssembly/threads/issues/144)
    1. POLL: move JS-BigInt-integration to phase 3
    1. POLL: move [multiple memories](https://github.com/WebAssembly/multi-memory) to phase 2
    1. Move wasi-sdk et al into the WebAssembly organization?
        - Rename reference-sysroot to wasi-libc and finish the move
        - Move wasi-sdk to the WebAssembly organization too
        - wasi-libc-test? (includes GPL-2.0 and non-commercial licenses)

1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees

* Derek Schuff
* Mitch Moore
* Sam Clegg 
* Barbara Nichols
* Sven Sauleau
* Zhi An Ng
* Thomas Lively
* Heejin Ahn
* Keith Miler
* Sergey Rubanov
* Paul Dworzanski
* Minqiu Sun
* Lars Hansen
* Peter jensen
* Benjamin Bouvier
* Alex Crichton
* Dan Gohman
* Andreas Rossberg
* Alon Zakai
* Francis McCabe
* Luke Wagner
* Ben Titzer
* Petr Penzin
* Rich Winterton
* Till Schneidereit
* Adam Klein
* Jakob Kummerow
* Shravan Narayan
* Nathaniel McCallum
* Flaki
* Nick Fitzgerald
* Rick Battagline
* Bill Ticehurst
* Arun Purushan

### Atomics with unshared memories (Thomas Lively)

Issue: https://github.com/WebAssembly/threads/issues/144

Slides: https://docs.google.com/presentation/d/1TRje57rtVnX1mykYNbH8WlPvIQ6lAVK1-gFFwSNwSoQ/edit#slide=id.p


[TL presenting]

Presented different options for enabling this. Feedback?

FM: if you have a threadsafe library, won’t it be more different than just whether it invokes suspend/wait? 

TL: potentially. E.g. if fast malloc impl has thread-local free list, uses compare+swap, etc. All of that stuff will just work in a single-threaded app.

FM but you might not want it.

TL: right, but a generally malloc might still want to use it. Current implementations just use the thread ops anyway and they just work. In wasm we could lower them to non-atomic equivalents at instantiation time and get better speed.

KM: you statically know when you instantiate whether the memory is shared?

TL: yes because the binary imports/exports a shared or unshared memory

AR: if the import has to be different, how can you avoid shipping the module twice?

TL: not the final linked module, but the library (e.g. static library binary) can be compiled just once

KM: can’t you just lower them into non-atomics at link time?

TL: yes but the problem is that static linking tools are such that this transformation would have to happen in the linker, which isn’t very smart. In theory you could have a relocation or something for the linker to rewrite.

LH: but now you’re asking the runtime to do that instead? That seems like a bigger change to ask.

AR: doesn’t the same argument about importing apply to libraries?

TL: no, wasm object files don’t really have memories (the memory import in the final binary is controlled by the linker)

… back to LH: you’re asking the runtime to do the linker’s job here, but at least the linker is optional. Also this is only applicable to a fairly small number of libraries, so it seems fairly special-purpose.

KM: it seems like libraries built this way would have to be specially designed if they will work with both threaded and non threaded apps

SC: I think most libraries are like that, they support both uses

TL: currently the linker doesn’t allow this (linking thread-using and non-thread-using libraries) at link time, and lots of users have run into this error already, meaning they are linking mixed shared/unshared code. It seems common. All you need a library that’s thread-safe (e.g. uses atomics) and doesn’t spawn its own threads, and it can be used this way.

PP: on native platforms the instructions will work either way, so I’d expect to see code that takes advantage of that. … is shared memory declaration done automatically or does the user have to ask for that?

TL: with emscripten, if you use the -pthread flag then you get a shared memory output.

PP: we probably don’t want to make the linker edit the instructions, that seems bad.

SC: there is some precedent on native, e.g. for linker relaxation.

KM: [... missed the comment]

BT: the JVM is inherently multithreaded, there’s no non-threading version.

SC: the work of the runtime is optional, you don’t have to lower away the atomics.

LH: it’s more about wait/notify. They don’t have nice semantics in the non-shared context. You can just wait and not expect to be woken (e.g. to implement sleep)

TL: you can do that, just not on the main thread.

LH: those semantic choices are useful, it would be cleaner to throw rather than speculating the wait.

TL: the second proposal is definitely much more involved. I’d be happy with just the first proposal. It’s still nice to not have to have to build everything twice, even with the guard code.

LH: which guard code?

TL: you have to check the value with a load before executing the wait.

PP: what if we just don’t validate the wait if there’s shared memory?

TL: then you still have to build the libraries twice.

PP: what user-facing construct results in a wait?

TL: pthread_mutex_wait should be implemented in terms of atomic wait.

PP: so if the code isn’t guarded right currently, they’d still have to fix it.

KM: a naive lock implementation would have this problem, if it only ever waits without checking, expecting the wait to return immediately. I’d lean toward the second solution because of that. I guess in theory the engine could optimize it away or something.

AR: would conditional compilation be an alternative?

TL: if you sequestered all of your calls to wait in a separate function you could use conditional compilation for that. You’d have 2 different versions of all those functions. it would be a big workaround for the problem. 

PP: the non-wait part seems non-controversial. Not sure we want to hinge that on conditional sections.

LH: we mentioned we need the guard code. we could do that temporarily for now and then move away in the longer term with conditional compilation.


DS: we don’t seem to have a consensus here, we should clarify the options on the github discussion and continue it.


### multiple memories proposal to phase 2

AR: presenting previous slides: [TODO: link]
Current state is technically mostly ready for stage 3, but only proposing stage 2 here.

KM: do we know where we should start looking at performance characteristics?

AR: implementation is stage 3, so that would be the entry requirement for 4.

KM: I’d guess that there would be a big perf drop for using multiple memories (i.e. the secondary memories) since they don’t use the same VM tricks.

AR: you could continue to optimize memory 0 (that’s backward compatible) and the others would be slower, so at least that wouldn’t be a regression. But that’s something we should look into. Partly why i’m just proposing stage 2, so people can think about that.

KM: we want to avoid JS-style cliffs where the VM has to guess which memory you want to make fast.

BT: the drop might be less than you’d think. When we switched V8 the difference was less. So I think this won’t be too bad.

LH: we tried removing our pinned heap register, and saw a 3-5% hit, so not too bad. not great but not terrible.

FM: We looked at multiple memories in Interface Types.  we looked at the case where we combined multiple modules into a single one, static linking style. It could result in having hundreds of memories. In that case there wouldn’t be just one special memory 0.

LH: we might want some way of designating memories as primary or secondary, as mentioned in the github issue.

KM: we’d definitely want that. Some platforms have a pretty small number of possible memories to use the big VM allocation.

LW: in that case you might even want them smaller than 64k. So maybe we might want memory to declare their own smaller page size. In the extreme case you could have a size of 1, and you’d take a bigger perf difference.

AR: the question is in what form we’d want this, and whether they’d be part of the multi memory MVP. As long as we don’t regress today, this should be fine. We’ve talked about optimization hints in the past, and don’t yet have a good way to do that. Not sure we want to add that to this proposal.

LH: we’d want to be careful since we could have a ton of memories accidentally.

BT: makes sense that we should separate the hints into a different section.

LH: we still need everything to be compatible, and will matter even if not technically semantically meaningful.

BT: we’d forseen the multiple memories, but it turned out that it was useful to leave room for extensions. Could we leave further room for extension even with this proposal?

AR: we could maybe do that with the extra flag field.

LW: we also have the further future goal of first-class memories where they are a dynamic reference.

AR: the current alignment field just has the one bit. It might be possible, might not be worth it.

DS: it sounds like we have a consensus that we should move forward with this generally. The details we are talking about now are about how best to do it.

Poll: Move the multiple memories proposal to stage 2

SF: 13
F: 6
N: 3
A: 0
SA: 0

[Proposal passes.]


### BigInt to stage 3
SS: [Link to slides](https://docs.google.com/presentation/d/1DJgaN-seUGuv123Lu6JvUwIudtAvpqZHCIFUE_Z85ew/edit?usp=sharing)
AR: agreed that there’s nothing to do in the reference interpreter for this proposal since it’s only about JS integration.

TL: for the toolchain, emscripten currently does a transform that takes the i64s at the JS boundary and splits them into pairs of i32s. So for emscripten we’d just want a flag to not do that.

[No other comments.]

DS: it sounds like there are no concerns with this proposal. Let’s do a unanimous consent poll:

Poll: move BigInt to Stage 3:
[No objections, proposal passes]


### Wasi-sdk

DG: this is something we started a while ago: reference-sysroot is currently in the wasm Github organization. it morphed into wasi-libc, and we have a usable implementation.

AZ: what are your thoughts on other implementations of libc for wasi?


DG: nothing stops people from creating others. It’s useful to have an example/reference which isn’t tied to any particular runtime. It’s not unlike other toolchains/tools being part of the wasm org, such as wabt/binaryen.

DS: So the first proposal is renaming reference-sysroot, what was the 2nd?

DG: second is to move wasi-sdk to wasm organization.

DS: what’s currently in the wasi-sdk repo?

PP: a wrapper for building clang for wasi. Technically everything that goes in there is basically part of LLVM. I tried to get the build to work out of the box but its tricky because you have to build libc before the compiler. Mostly because of the way the headers work. It would be good to improve that.

DG: right. Also it’s not actually a wrapper, we want everything to be just clang.

PP: yeah it’s really just a wrapper for building clang, not for running it. Might be best to even move it into clang proper.

SC: it’s basically just a build script. It’s really for a whole sysroot which includes all the libraries, headers, and compiler. We also publish binaries as releases.

DG: we are definitely interested in putting as much upstream as possible.

DS: any other comments/concerns?

[none]

DS: let’s do a unanimous consent poll for:

Renaming reference-sysroot to wasi-libc
Creating wasi-sdk to contain build scripts and sysroot construction for wasi SDK

[no objections, proposal passes]

"
main/2021/CG-04-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 13th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: April 13th, 4pm-5pm UTC (April 13th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Announcement for 4/27 meeting: Scoping and Layering of Module Linking and Interface Types. 
    1. Announcement: Derek Schuff and Luke Wagner as co-chairs of the working group. 
    1. Proposal: Deepti Gandluri and Derek Schuff as co-chairs of the community group (10 min)
       1. Provisional vote, next steps
    1. Formalize SIMD subgroup (5 mins) 
       1. Vote to approve Petr Penzin and Zhi An Ng as subgroup chairs
    1. Vote to approve Lin Clark as a new chair of the WASI Subgroup, to replace Dan Gohman (5 min)
    1. Presentation+Discussion: Collaborative Garbage Collection, Ross Tate (20-30 min)
    1. Update on Instrument Tracing (10 min)
       1. Poll for phase 2 
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

### Opening of the meeting

###  Introduction of attendees
Deepti Gandluri

Flaki

Rich Winterton

Garrett Gu

Jacob Abraham

Zalim Bashorov

Lin Clark

Andrew Brown

Ryan Hunt

Yury Delendik

Paolo Severini

Paul Dworzanski

Yuri Iozzelli

Till Schneidereit [he/him]

Conrad Watt

Luke Wagner

Alon Zakai

Chris Fallin

Rick Battagline

Sam Lindley

Ioanna Dimitriou

Sean Westfall

Keith Miller (Apple)

Lars Hansen

Arun Purushan

sbc

Mingqiu Sun

Nabeel Al-Shamma

Jakob Kummerow

Thomas Lively

nicholas

Ross Tate

Eric Prudhommeaux

Luke Imhoff (@KronicDeth)

Asumu Takikawa

Nick ""fitzgen"" Fitzgerald (he,him)

Zhi An Ng

Dan

Adam Klein

Andreas Rossberg

Dan Gohman

Petr Penzin

Pat

TatWai Chong

jbirch

Daniel Ehrenberg

Slava Kuzmich

Heejin Ahn

Sergey Rubanov

Manos Koukoutos

### Find volunteers for note taking (acting chair to volunteer)

### Proposals and discussions

#### Announcement for 4/27 meeting: Scoping and Layering of Module Linking and Interface Types. 

**Note:** This is a 2Hr meeting starting an hour earlier than the usual meeting, as a pilot for having longer design forums virtually. Meeting led by Luke Wagner. 

#### Announcement: Derek Schuff and Luke Wagner as co-chairs of the working group. 

Excited to welcome Derek Schuff and Luke Wagner as co-chairs for the working group. Decided by [vote in the working group](https://github.com/WebAssembly/meetings/blob/master/main/2021/WG-02-10.md#proposals-and-discussions), email to public mailing list will follow, with avenues to voice concerns if any.

#### Proposal: Deepti Gandluri and Derek Schuff as co-chairs of the community group (10 min)

DG & DS have been working as defacto CG chairs in Ben Smith’s absence, and would like to formalize this with a vote. 

Chair selection process described in the charter: https://webassembly.github.io/cg-charter/
Pretty lightweight in the past - previous chair picks the next chairs. We didn’t have a full transition in place till now. 

Email to the public mailing list will go out soon, with avenues to voice concerns if any. Feel free to also reach out to webassembly-cg-chairs@chromium.org, or team-wasm-chairs@w3c.org in the mean time.

DG: provisional/consensus vote, mailing list will come after

(No objections, provisional vote passes)

#### Formalize SIMD subgroup (5 mins) 

DG: SIMD is in phase 4, SIMD proposal started before subgroup was a concept. It was productive, want to keep it going. With flexible-vectors and relaxed-simd, we want a joint place for discussions related to SIMD. Charter as open PRs on [relaxed-simd](https://github.com/WebAssembly/relaxed-simd/pull/18), and [flexible-vectors](https://github.com/WebAssembly/flexible-vectors/pull/32) repositories. Champions of both proposals will co-chair this new subgroup. Consensus vote: anyone disagree to either forming SIMD subgroup, or having Petr and Zhi as subgroup chairs?

(No objections, SIMD subgroup is formed, with Petr and Zhi as co-chairs)

#### Vote to approve Lin Clark as a new chair of the WASI Subgroup, to replace Dan Gohman (5 min)

DanG: reflect that Lin has been running meetings for a few months, formalize it. I will still be involved in WASI. Anyone objects?

(No objections, Lin is the new chair for WASI subgroup)

#### Presentation+Discussion: Collaborative Garbage Collection, Ross Tate (20-30 min)

Slides with Animations of Algorithm [(pptx)](presentations/2021-04-13-tate-collaborative-garbage-collection.pptx)

Still Slides [(pdf)](presentations/2021-04-13-tate-collaborative-garbage-collection.pdf)

CW: How much work is done at runtime to register work with the cross ref manager. At each assignment, you need to create x-ref, register with the manager. Do you have to synchronize?

RT: I tried to track that, this should be pretty race friendly - I’m glossing over the roll over the epoch - have to deal with the information that GC can happen while the epoch change and stale info may be propagated. You may have some casts, the GC would do it - the program won’t have to worry about it. It should be pretty unnoticeable from the program’s perspective

CW: registering with manager at each assignment, is that right? Any static information to make that faster?

RT: So this is designed for where these things are coarse. Registering a cross reference corresponds to putting an externref into a table. You would extend Wasm tables with coloring references. 

CW: yup, make sense. In the case where you are expecting it to work well, you have some static information given a type, which GC is handling that type.

RT: The static info can be events, a very coarse system, A, B,C ,D can be different programs - it can just be a foreign function call. <Describes Java example>

LW: there is a membrane between a b c d, and only crossing it is where you care about cross references

RT: That would work too, works as a foreign function calls

LW: firefox implements this for compartment, and cross compartment references

RT: This is a simple algorithm, but couldn’t find where it existed.

AZ: have you thought about whether this can be used on the web? Seems like it requires integration with GC on web.

RT: This should be usable on the web, problem in the GC proposal is about multi threaded programs having JS references. Mjulti threaded programs could use this as a smart table, that way JS references can only be accessed in the program they belong to, but they have some information hidden about which references they belong to

AZ: the problem is that JS vm doesn’t give you the information that i have scan the roots or i have finished. Without that, don’t see how this can work.

RT: For Wasm, if you have a situation where all of them are linear memory programs talking to each other and not the host, we could use wams to implement the cross reference, if you do need to talk to the host, then you need some system to be able to talk to it, and the host is responsible for the coloring informatiion

KM: from impl perspective, is there an efficient way for manager to know epoch is done. Maybe atomic integer is outstanding out refs, when that gets to 0, and all roots 0, then you’re done?

RT: There’s a variety of ways to implement it depending on how much synchronization you want. The answer is there is a variety of implementation strategies, my sense is that if you think of this as generational - is not super critical for the program because of early clean up. The idea is that once ina while we release cycles and clean up eventually 

KM: if the operation is an instruction to mark refs, whatever the host wants to do, polling thing

RT: all this designed to b very black box, the x ref manager has many ways to implement it.

CW: i have misunderstood what x ref is, if i have an object that is managed by GC A, and because this is coarse grained, there is some operation to transfer from A to a compartment which corresponds to another language/runtime by B. Is the act of transferring the ref that creates the xref, or once i transfer the ref to b, does every assignment to one of B field creates a ref.

RT: I think it’s just the act of transferring, when you do a transfer of a cross reference, A is going to have some sort of proxy on the outside, and B will have one inside - when you assign fields you’re assigning the proxies, and B’s GC maintains a list of all it’s proxies, and the GC is responsible for maintaining the cross references. 

CW: so long as you keep the number of transfers between heaps low, it’s okay to have lots of assignment between xrefs objects

RT: It’s transfers of heaps for host integrated stuff, we can give it an externref, you don’t have to do anything - if it’s on the stack then the program knows about it. 

PP: will it be efficient to implement GC in Wasm?

RT: I think there’s been discussion on that - one thing that’s come up is that for efficiency, we need some way to walk the stack to collect the roots. That’s the one that’s brought up as a constraining factor.

PP: if we ever get to prototyping we can find out

<BACK TO SLIDES: Guarantees of system>

DE: How are we prioritizing this linear memory GC support vs the Wasm GC proposal? I thought in GC proposal scoping, we want to prioritize host GC over this? Maybe I misunderstood.

RT: probably cannot answer in 1 min. I wanted to focus on the technology, i will write up issue for the discussion

CW: complementary, take current GC proposal, you can add this, expose this as a type that comes from another GC

#### Update on Instrument Tracing

Jacob Abraham presenting [slides](https://docs.google.com/presentation/d/1sjOqLLRJxYWim2NVGNF-zs1nAVSMKehvJiovBLKm6bo/edit?usp=sharing)

AR: abstractly speaking, what is the meaning of this instruction?

RW: IT’s a continuation of the trace instruction - lets us translate the source code to machine code

AR: if i don’t use that how would you interpret this instruction?

RW: Nothing or the Noop

AR: semantics is equivalent to a nop. Does semantics depend on the host, can inject anything we want?

RW: It would execute code, it’s a prefix - noop with a prefix and would automatically recognize the source to the trace, whether or not it’s an absolute instruction or not.. It would translate to a regular noop on an unsupported platform

AR: we don’t specify semantics in terms of any particular platform. IIUC, the abstract meaning of this is a nop really, no observable effect in any environment.

KM: Is there in the spec that says there’s no observable difference in the semantics?

RW: think that’s in the spec, have to go back to take a look at it

CW: should be an instruction rather than imported function that the host provides?

KM: It could be an imported function, or you call a different function vs. the custom section.

JA: essentially the trace instruction will be executed and only traced if a tool is attached/enabled. Regardless, the execution semantics stays the same. Only when you attach something, trace in browser or native instruction trace.

RW: They have the mark-id so it’s an arbitrary 

TL: how do you expect this to be surfaced in the browser? Do you expect some DevTools integration.

RW: JA created a prototype to do that. It could show up in browser. Can feed this into simulator and play with it, what if we increase cache, branch prediction, number of registers, etc. We can take that information. If we call it in Wasm and came back to JS and did some other things, we can trace that more accurately.

NF(chat): it can't be *just* a nop because you wouldn't want the compiler to move code across it, right?

DG: more questions, take it to repository, come back with a poll with some answers to questions.

RW: yea sounds good, will make progress

DG: feel free to answer questions on the chat

### Closure
"
wasi/2021/WASI-08-12.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the August 12 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: August 12, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Lin Clark
    - Email: lclark@fastly.com

### Registration

None required if you've attended before. Email Lin Clark to sign up if it's your first time. 

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. wasi-parallel: propose and discuss a new API for exposing a system's parallel capabilities to WebAssembly ([slides](presentations/2021-08-12-abrown-wasi-parallel.pdf)) (20m).
    1. Sketch of `async` and `stream` in Interface Types ([slides](https://docs.google.com/presentation/d/1WtnO_WlaoZu1wp4gI93yc7T_fWTuq3RZp8XUHlrQHl4)) (40m).

## Notes
### Attendees
- Pat Hickey
- Andrew Brown
- Lin Clark
- Mingqiu Sun
- Bailey Hayes
- Piotr Sikora
- Radu Matei
- Till Schneidereit
- Luke Wagner
- Alex Crichton
- Adam Foltzer
- Saúl Cabrera
- Syrus Akbary
- Enrico Galli
- Yong He
- Dan Gohman
- Matt Butcher
- Johnnie Birch

### wasi-parallel

**Andrew Brown**: Presenting something we’ve been working on for last few months, Johnnie, Peter, Mingqiu, Enrico.

**Mingqiu Sun**: Lack support for parallelism can be problem for some problem domains. Best Wasm can do is 128 bit SIMD support. So what are we doing? Last year, we proposed wasi-nn. That solves parallel computing problem for 1 domain. Approach we took is model-loader API. We assume some sort of encoding of ML model, load it, set up graph, and then execute. Works for frameworks like Tensorflow, Onyx. One problem we encountered is community members asking about what about my framework (not one of the major ones). We don’t have an answer for them now. In journals, not just limited to ML. This could be a barrier for adoption of Wasm in these areas. What’s worse for standalone is that TS.js has Wasm backend that can farm out structure into pool created by webworker, and we don’t have that in standalone env. What about providing low-level parallelism support in WASI support so that you can support all the different use cases. Initial scope is to target _____. Can be supported in variety of backend devices, CPU, GPU.

Today, want to explain what we’re doing, and also looking for partners. Not just limited to API only. Toochain related to solve this problem.

**Andrew Brown**: So given that, let’s describe goals and non-goals. This can change based on feedback

Want to access system parallelism. Trying to not modify the Wasm spec. Did have a goal to execute on heterogeneous devices, e.g. on a CPU or GPU. Another goal is to match abstraction that is provided by a bunch of different parallel programming frameworks, but don’t want to support all programming models. For example, didn’t go through p-thread route.

Draft API looks like [slide]. Based on parallel fork. A lot of frameowrks have parallel fork. Need to know what kind of device. You hint on the device that you wnat to run on, and then runtime gives you handle to device. Then you tell runtime what you’re going to do with memory. With GPUs you need to be able to move slices back and forth. This could change, but we found it sufficient. Most important call here is parallel fork. The kernel is the work you want to do in parallel. You tell it the level of parallelism you want to support. You can split up the work using the block size param. And in buffer and out buffer.

Any questions?

So here’s where we’re at currently. We’ve built a prototype using Wasmtime that can execute on a CPU. What we’re using to evaluated is PRK kernels. Repo maintained by the community taht has pretty common problems you can run implemented across different frameworks. We’re able to execute some of those kernels within wasi-parallel. Some hand coding involved. In some we could speed up linearly based on CPUs we have. Encouraging. Also working on enabling GPU execution using OpenCL, can execute simple kernels, still need to benchmark.

Finally, other thread is toolchain support for OpenMP programs to wasi-parallel. This is a proofpoint to show that it isn’t too divergent from other common frameworks.

Future directions. We do want to get feedback from the community. There have been many discussions about this topic previously, so we wanted to see what people think. Part involves refining API based on feedback. We’re also very interested in seeing if other companies and individuals would want to work on creating benchmarks that we could use to get statistics. Finally, investigating compiling from other frameworks and high-level library. Want to see if multiple frameworks can compile down. Could MediaPipe call wasi-parallel instead of p-thread or whatever it calls.

**Francis McCabe**: I have a question for you, please forgive ignorance. Why is WASI the right forum for this effort?

**Andrew Brown**: That’s up for debate. Some people might feel that parallel primitives could be added to wasm itself. From my understanding, just from reading threads proposal was that Wasm would provide the primitives, but different runtimes would have different reqs.

**Mingqiu Sun**: I would add that solving parallelism is a big problem with multiple approaches. I think the WASI approach has its advantage. We could use GPU as a backend as opposed to having Wasm core support for running in GPU.

**Francis McCabe**: You’re right that there are many approaches to parallelism. You’re coming from a community that has opinions. Why not standardize there? 

**Lin Clark**: Time check

**Adam Folzer**: I foresee possible speed bump—I did research 10 years ago but haven’t kept up. In general to get good perf out, particularly if you’re going after heterogeneity, picking right parallelism params for device is important. Baking in the params will mean it only runs well on a particular device. Also excited because such good research on _______. The exciting part is using the JIT to do that inference when you instantiate it. On a completely different note. Setting aside question of whether in wasi, calling this data-parallel might be better. 

**Andrew Brown**: Certainly API is in its infancy. Can add or change function calls. We’ve discussed that you’re basically baking in config. One goal is not to get to 100% parity. We want to narrow, maybe to 70% of native.

**Luke Wagner**: I had a comment or thought. Relating to the use fo a func ref in the API. It closes over the instance. That might be a problem for the GPU.

**Andrew Brown**: Peter went on an investigation on this. Func ref only gets us so far. He thought module linking might help with that. I don’t know if that will fix that, but we’re really interested in ideas.

**Luke Wagner**: I’d love to talk about that design problem more

**Till Schneidereit**: Wnat to follow up, I do think this is the right group. We have nominative optional for exactly this.

**Bailey Hayes**: (from chat): parallelism in wasm modules is exciting. I [sketched my thoughts for how I see this relating to wasi-data]( https://excalidraw.com/#json=6618539104403456,Tq9SZrcB2R8GIeRciROgXw)

**Andrew Brown**: I know we’re up on our time, next steps?

**Lin Clark**: Could either schedule a meeting with the interested parties, or discuss more next meeting.

**Andrew Brown**: Let’s discuss more next meeting

### Sketch of async and stream in Interface Types 

**Luke Wagner**: To pick up where we left off last time, talked about blocking being something you could put on functions so we can unify callback and greenthread. They superficially look different, but solve same problems. Want to allow composition between components using these different styles. Important use cases for both styles. Not all runtimes support greenthreading, and languages with language async will want to minimize runtime. 

On the flip side, for continuouations, this only supports sync io or newer languages [Slide]

Roughly the approach is to make these an encapsulated ABI detail. Getting feedback from that and iterating. Started thinking through additional requirements for HTTP. Request handlers need to be able to return a response but keep running. A single handler needs to be able to stream in and out from downstream and upstream. An exciting challenge appeared—can http proxy chaining just use component composition? This would just be an application for the virtualization goal we have for WASI. In this case, we’re saying “I’m importing a fetch” and it might go over the network, or it might just go to another component.

The wins from being able to do this is perf win, portability because proxies compose in same way, and module linking will be pretty powerful. Can express lots of different chaining patterns. For example, non-linear chains that can fractally fan out.

If we can solve this generally for HTTP, this is a litmus test. Lowev levels of network stack, image/video pipelines, streaming analytics

Expand the scope of blocking to return+streaming, and going to rename blocking to async. Let’s say we have a function and we have this async effect on it. I have two choices at the ABI level. ABI varies based on whether you’re importing or exporting. I can import with sync, which means I’m awaiting. Then there’s an async option. Index into local table that ABI maintains. Then to work with that future, there’s a wait that’s built in. I give it a future and the result is the B*. Also a select where I have multiple futures. With these three primitives, I can do continuation style for calling the async function foo. This could be imported by a core wasm function. 

Callback api. Classic C style callback. So those are the two imports. 

When we want to export, for continuation it’s very simple in sync. We handle early return in async. The fact that I can do it in the middle is what allows it to return early. Caveat is that I’m going to trap if I call it twice, or if I return without calling return at all.

In contrast, in callback abi, there’s one option. I get two functions: early return, and enqueue extra work. 

Any questions?

**Francis McCabe**: Does this meet all of the goals you had for fetch?

**Luke Wagner**: Yes, I think so

**Francis McCabe**: Looking forward to seeing how that works.

**Luke Wagner**: All right, I’ll move on.

If you’re familiar with typed continuation proposal, there’s a hidden slide that shows. Now walk through example.

[Slide]

Make a component called splitter. Going to import a fetch function. It’s given a string and returns list of u8. Going to nest a core module. Now I need to instantiate it, so need to create adapters. 

Any questions?

Now going to show how you can compose.

[Slide]

Wants to call the fetch, do some work in parallel, then wait and frob the results.

Going to walk through the call stack.

[Slide]
 Composition does interleaving that you would want.

So that was blocking and early return. Next piece is streaming. Just so say where we started with—”can’t we just” [Slide]

….

So let’s add a new stream type to interface types. What’s a stream? A list that is passed incrementally over the course of an async call. Thus a stream can only make sense in async. Each stream has two ends, writer and reader. The reader and writer ends are created with i32 handles by canonical ABI. So these ends are private details. 

Any questions?

**Adam Folzer**: You mentioned that a non-async function wouldn’t make sense to take or return streams. What about passing it from one import to another.

**Luke Wagner**: That passthrough case is important, will get to it at the end. 

**Piotr Sikora**: What’s the relation between stream and pull buffer, etc

**Luke Wagner**: Strictly more general, maybe prettier

**Piotr Sikora**: So do we expect it to supercede?

**Luke Wagner**: Yeah, I think so. 

**Francis McCabe**: You are taking a dep on the stack switching proposal?

**Luke Wagner**: Only with the coroutine ABI. Callback API does not require it.
"
main/2024/CG-03-26.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 26th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: March 26th, 5pm-6pm UTC (March 26th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Discuss adding table64 to memory64 proposal: https://github.com/WebAssembly/memory64/issues/46 (Sam Clegg, 10 minutes)
    2. Discuss custom Wasm page sizes: https://github.com/WebAssembly/design/issues/1512 (Nick Fitzgerald, 30 minutes)
1. Closure

## Agenda items for future meetings

*None*

## Schedule constraints

*None*

## Meeting Notes

### Attendees

 - Sam Clegg
 - Conrad Watt
 - Derek Schuff
 - Thomas Lively
 - Francis McCabe
 - Yuri Iozzeli
 - Slava Kuzmich
 - Sergey Rubanov
 - Zalim Bashorov
 - Artem Kobzar
 - Nick Fitzgerald
 - Fedor Smirnov
 - Paolo Severini
 - Petr Penzin
 - Bailey hayes
 - Daniel Hillerström
 - Andreas Rossberg
 - Matthias Liedtke
 - Ryan Hunt
 - Oscar Spencer
 - Deepti Gandluri
 - Dan Gohman
 - Johnnie Birch
 - Luke Wagner
 - Benjamin Titzer
 - Dan Phillips
 - Mike Smith
 - Mingqiu Sun
 - Alex Crichton
 - Michael Ficarra
 - Nuno Pereira
 - Julien Pages
 - Matthew Yaccobucci
 - Adam Klein
 - Brendan Dahl
 - Chris Woods
 - Mats Brorsson
 - Heejin Ahn
 - Daniel Lehmann
 - Ben Visness

### Discuss adding table64 to memory64 proposal: https://github.com/WebAssembly/memory64/issues/46 (Sam Clegg, 10 minutes)

SC: Memory64 proposal is almost 4 years old, trying to get it to Phase 4, spec text in progress, the only outstanding issue is table64, should we extend the proposal to include 64-bit indices for memories and tables?

Nobody wants to have more than 4 billion table entries, so it's just for parity with pointer size. The downside is that it's more work to add this. E.g. call_indirect and other instructions need changes.

No strong opinions on the issue, would delay the proposal a bit. Would like to discuss and come to an agreement here.

CW: I imagine the world where the table indices stay 32-bit and we just mask the upper 32-bits is the one we’re in now - is that bad?

SC: That's the status quo. LLVM will truncate pointers. Requires a little more complexity and code size. If we make the change, we could simplify the tools and reduce instruction count, but then engines would have to deal with it instead.

AR: Do you have a better understanding if the usecase that Mathias has for this? They implemented a somewhat weird Wasm producer/consumer - they didn’t want to do the masking because that reduces the confidence of what you’re calling in terms of function pointers, and they implemented manual boundchecks for the function boundaries which was expensive

SC: His use case isn’t a conformant wasm implementation, basically he’s trying to erase the wasm sandbox and use an OS sandbox, using wasm2c to generate not-quite valid wasm which doesn’t use features such as bounds checks. 

The masking can lead to more bugs going unnoticed because pointer corruption in the high bits will be masked out instead of causing problems.

RH: implementing 64 bit bounds checking on tables: on a 64 bit host system a bounds check on the table, shouldn’t be any extra overhead. On a 32-bit system it will be harder, but it’s already harder to do 64-bit memory on 32-bit systems.

If you are on 64-bit system and the engine can do the bounds check for you, then the masking would be wasted work, so there's a performance motivation for not requiring masking.

SC: The feedback we got from V8 was also that it would be a few days of work not more

NF: would this add an index type to the table, or would it just be 64-bit indexes for tables?

SC: It would mirror what we have for memories, it would add 64-bit indices for tables. LLVM would generate both a 64-bit memory and 64-bit table in wasm64 mode.

AR: the other advantage on a meta-level is that it reduce the asymmetry we have between tables and memories, which is nice.

SC: In the spec interpreter, this would reduce the special casing to account for differences between memories and tables.

I would be interested if anyone on the engine side knows if those truncations can be elided. E.g if you mask in the user code and then call_indirect?

DanG: You don't need a mask because x86 can just fold it into the addressing.

SC: We embed an i64.wrap instruction

DanG: You could do an optimization on the engine, and just generate the instruction for accessing the lower 32-bits of the register

CW: you’d have to do a fusing optimization in the engine, right?

DanG: yes you’d pattern match that.

SC: yes, there’s a small binary size increase from the userspace masking with table32 that would go away.

DanG: Doesn't seem well-motivated. Extra surface area to fuzz forever. I would want to see a stronger motivation.

CW: i do see that we don’t have an explicit poll for this on the agenda. How were you thinking we’d move forward?

CW: For a informal poll, we can use the github emojis for getting a sense for how to move forward, it is a normative change so we should eventually poll and announce this ahead of time

BT: while we’re talking about 64 bit, we might want to talk about 64 bit arrays in wasmgc. Maybev it doesn’t fit into this proposal but it’s a similar thing, it might matter for the future.

SC: WasmGC is using 32-bit indices for arrays?

BT: That's right.

CW: my suggestion for going forward would be to make an issue on Github that people can thumbs-up or thumbs-down, and we can use that to assess consensus and drive a future poll.

SC to post such an issue.

###	2. Discuss custom Wasm page sizes: https://github.com/WebAssembly/design/issues/1512 (Nick Fitzgerald, 30 minutes)
Slides: Custom Wasm Page Sizes

NP [chat]: Thank you, great proposal and summary! We had to define custom memory page sizes adhoc to get multiple modules to fit on embedded devices, with the downsides mentioned. It seems reasonable to address these needs here


CW: question: I'm surprised that they implement small memories in a way that causes divergence: couldn’t they just refuse to compile a module that asks for too much memory?

NF: There are a bunch of ways to do this that preserve semantics, but they let you observe the difference by just probing memory.

CW: oh, the problem is that their constraint is that there’s less than 1 page of memory available?

NF: yes. The problem is that this engine is shipping on millions of devices with this non-standard extension. So we need to address this in a standards-based way [back to presentation]

CW: Phase 1 vote would be fine. We explicitly do not require advance notice of phase 1 polls.

OS: one of the concerns i might have: you mentioned the Faas use case. If we dont’ allow the engine to decide the page size for FaaS, we might have portability concerns. If I’m a FaaS provider I want people to just ship their modules to me and and I can just run them, but i want modules that don't need much memory to not use much. But i have to rely on the users to do work to use less memory and they might not be incentivized to do that.
(I care more about embedded, but this seems like a concern for FaaS though)

NF: We won't introduce larger page sizes than we have today, so if you're a FaaS service that can run Wasm today, that will remain true in the future.

OS: true. But I don’t imagine toolchains by default today will say that they want to use a smaller page size. But if all the modules in a shared system use a smaller page size, then i can fit a lot more instances in, but the coordination might not happen.

CW: I like the proposal but would be concerned about allowing arbitrary non-power-of-2 sizes. I like allowing only 1 and 64k most at the moment.

NF: I think 1 and 64k would be fine. Or if we want it t6o be a multiple of ourlargest memory access size, then 16 and 64 would work well too. It might be a little weird that it’ snot 1, but 2 values could serve the use case.


AR: we have this unfortunate use of a sentinel value in memory size that we interpret as failure (-1), we could possibly run into that with page size 1. Sentinel values turn out to be bad idea.

NF?:

AR: That was my other question, what does this imply for max sizes? Would we still allow up to 4G or specify in terms of number of pages?

TL (chat): make the min size 2.

AC (chat): 16 bytes is the maximum size to load today, but that may not always be the case with proposals like flexible-vectors.

NF: I was thinking that this wouldn't have any effect on limits, but I suppose we could change the max memory size to 2^32-2 for the case of 1-byte pages to avoid the sentinel problem.

PP: I agree in principle that this is a good idea and we can figure out the sizes offline.

CW: agree that we don’t need to concretely solve that today, but we do still have time to discuss here.

BT: I think we should support powers of 2 up to 64k because the spec process takes a long time and we might as well just spec taht. I think wasm is capable of adapting to the hardware, and since we’re crossing into having more than one page size, we might as well just have all of them.
Also for gc maybe we could pin parts of GC arrays as memories, in which case it could make sense to have 1 byte pages. So maybe going all the way down to 1 makes sense.

CW: I would potentially think the opposite. Any feature that maps structures into memory seems scarier if the memory is not a multiple of the OS page size because then they can't use OS APIs.

NF: I would share that concern. Generally any kind of overlap with future virtual memory-y proposals could restrict themselves to memories that have certain page sizes. But that’s also a question for those proposals, what to do with systems that don’t have virtual memories.

CW: This is why I'm drawn to having just 1 and 64k. It's very clear that the 1-byte page is slow but you have full control and the 64k page will be fast, but you have less control.

PP: Nick mentioned that engines already do this? What kind of page sizes do they use? 

NF: Don't know exactly what multiple they're using. They're looking at __data_end and __heap_base and other globals, then assuming the Wasm won't access (much) past those.

PP: if someone already has devices that r un this, they have some idea of what they can support. The embedded world typically likes to support arbitrary numbers, maybe not want just powers of 2

NF: if we support 1, then people can just use anything they want. And I suspect if we use 16, then that could still be good enough.

CW: I would be less excited about picking 16 because it’s the largest access we have today, we could have larger in the future.
My concrete concern with totally arbitrary numbers is just that it increases the fuzzing surface.

ChrisW (chat): Nick, thank you. Great proposal!

If we don’t have more comments, we could run the poll?

Phase 1 poll: custom page sizes 

SF: 22
F: 15
N: 0
A: 0
SA: 0


Poll passes, custom page sizes to phase 1."
main/2019/WG-03-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 13 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: March 13, 2019 at 3pm-4pm UTC *( March 13, 2019 8am-9am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
1. Future meetings
    1. Confirm next meeting date + time.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

BS: I wanted to talk about TPAC in Fukuoka, Japan this September. They sent out
a survey that we need to fill out ... basically who we want to meet with and
what days we want to have a room booked for us. In the past we did a CG and WG
meeting... we did that last year. I think that was OK, although I do understand
that made it difficult for us to meet with other groups. Because we had taken
so much time there. I remember from a previous CG meeting that some people were
thinking they wouldn't go to this meeting. Partially because there is a fee,
and partially because we have another CG meeting in A coruna in June so there's
not a lot of time between those two. So a as a result I think we might want to
go back to what we did two years ago, and have our TPAC meeting be mostly about
communicating with other groups. And to that end, I got an email from the WebML
community group char saying that they would like to make sure that we don't
overlap because they were interested in coming to our meetings. So I told the
char that we would, maybe not have much of a meeting there, but we were
interested in doing some outreach, and they'd be interested in talking to us
about stuff too.

Anyway that's kind of the basics here. Any thoughts about any of what I
discussed?

LW: I think the point about making it intergroup collaboration is a good one,
and in particular interactions between webidl bindings, Domenic's import
maps... I just posted built-in modules reflecting existing web APIs, which was
part of the magic triad. And discussing that whole story, getting anyone who
cares about that, and talking through various cases. That seems like, that
would be a timely discussion topic.

BS: I agree. Especially with more of our work this year being about better
interop with the rest of the web platform, it seems like that would be good.
So, I guess we need to decide, how many days we need for our group. I'm
thinking maybe just one. When I talked to the WebML chair, they said they would
prefer if we did it on Thursday or Friday, because they are narrowed down to
Tuesday or Friday, and they have a preference for Tuesday. So, I think it's
likely that any day is as good as any other for us at this point, so perhaps we
should pick randomly and go with that. Any thoughts?

LW: Thursday seems as good as any. Is there already a list of major groups and
which days they're doing stuff. I forget the name, but the one that does Web
Apps? I wanted to go to some of their things last time.

BS: I don't see a listing. It's probably because the survey isn't due until the
12th. But if there are groups that we're interested in coordinating with, the
survey does allow us to choose which groups we don't want to overlap with or at
least try not to. There's a large list that we can choose from: Web Application
security, Web Authentication, Web Fonts, Web of things, Web Payments, Web
Performance, Web Platform...

LW: I think maybe it's that web platform... is that the one that does all the
storage, and streams...?

BS: I would assume so? It doesn't look like any of the... my guess is that
that's probably Web Platform, and I can add that to the list so we don't get
double-booked with them.

LW: Is WebGPU there also?

BS: It's interesting, I was looking for that too, I don't see that so... I
don't know what that gets looped under.

LW: It was there in the past years.

BS: They were definitely there last years.

LW: I think WebGPU, WebML, and WebPlatform are the three.

BS: I'm going to go through the survey items, to see if there's anything else
we want to bring up. We discussed number of days, one is probably fine. We
discussed day preference Thursday or Friday is fine. Flexibility, yes we're
flexible. Joint meetings, we discussed... oh this is if you want to combine
with another group, we don't want to do that. Overlap, group confidentiality,
we're not concerned about that. And that seems to be it. And the only other
question is how many people we expect to attend. And it's hard to predict, but
I imagine it will be a lighter crew. Is there anyone in this meeting know if
they or other people will go to this meeting in Japan?

LW: I might be the only mozillian.

BS: Arun says he's not planning to. I imagine that will be the same here, it's
a pretty big trip for just interfacing with other groups, depending on where
you live. OK, well that's all I wanted to discuss today. I'll fill out the
survey with best guesses for attendence, and fill out the rest of the
information. Anything else on this topic?

LW: I saw you released a working draft earlier today...?

BS: Yeah, honestly I was going through and doing some of the work for the v1
CR, and one of those things was to create a v1 branch, so I created a branch
called wg_v1 for the spec repo the idea is that it will be a good starting
point. If there's anything we want to pull in we can cherry-pick, but we might
as well have that going. And then I noticed that the releases for spec ... Brad
actually made a release for the first public working draft, so I figured we may
as well do the same thing for our previous working draft the one that released
in August of last year. So I marked that up. Eric and I have plans to... I was
expecting that he might come... we have plans to finalize the last few details
of going for CR and push that out. I know that some people in w3 are eager for
us to do that.

LW: Out of curiosity, is that because it's generally a good thing or is there
any particular reason that... [BS: that they're pushing for it?] yeah, is it
just healthy pressure to finish?

BS: I think healthy pressure is definitely a big part of it, when we met last
time PLH was saying that some groups have been very slow to go through the
process. As soon as you go through the process everything gets secured around
the patents. That's the biggest thing -- also it's just nice to put a bow on
it, and say we're done now. Another nice thing for us, now that we've branched
of to v1, we theoritically could start to move proposals that are standardized.
[LW: right, mutable globals, non-trapping] Yeah so we have to decide whether or
not we consider those to be standardized, but that means that we could stop
trying to maintain those repos and move them in. That would be really nice.

LW: Sure. Show our post-MVP incremental progress.

BS: Those are some of the various good reasons. This reminds me of something
that I was looking into yesterday. Sort of related, one of the things that's
helpful for the CR is to show multiple implementations that pass the test
suite. A nice place to do that is wpt.fyi, the web platform test website. It
has a nice display of browser along one axis, and test suite along the other
axis, with colors that represent the passing tests. It's easy to drill down to
look and see who's passing the tests. Currently we have, thanks to a lot of
good work from ms2ger, the JS-api and web-api tests duplicated in WPT. What we
do not have there are the core tests, and that was one thing that we thought
might be valuable to add to that list of tests. Currently there's not another
place where it is easy to see the current status... we assume that those are
the tests that people would pass, but it's better to have confirmation.

I started to make a patch, but I ran into some issues ... it comes down to the
Chrome 4k limit for instantiation...

LW: You know, now that you have a tiering compiler, you can maybe just bump it
to 64k. It's useful at the moment, because it's pushed everyone to instantiate
streaming -- which is what they should be doing. Until there's ESM integration,
and then they should do that. So, it's been useful, but that being said, it
might be worth increasing it.

BS: Yeah, that's a bigger discussion. It's a good point, maybe worth bringing
up to people who can make that decision. Part of what I've been trying to do,
make it so we can take the wasts that we have currently, generate JS using the
reference interpreter, but then also run the tests asynchronous... it's
probably better to do that anyway. One of the things that's been tedious is
that the we want to leave the harness mostly the same, and leave the tests
mostly the same, but then run asynchronous, which is all doable, but...

LW: Taking the wast, making each statement async... I can see how that's a
non-trivial job.

BS: It's tricky because the harness for WPT have some unspecified behavior with
regards to how promise tests are implemented, so I spent some time hacking on
that yesterday.

LW: It's great to hear that... that's been the vision for a long time, we just
haven't done it.

BS: I remember, years ago at this point, discussing many many times where the
tests live, what's the source of truth, where do they get duplicated, how are
they run, and so on. Having them up there is probably good.

LW: It's all about what's the process for these things... anything can happen.
But the process can be when a feature graduates to a certain stage, and it
starts down the standards track, that's a good time to move it to WPT, because
then you can say, yes this is reflected on wpt.fyi.

BS: That's a good idea -- it's much easier to see. But one problem with WPT --
how do you specify, this is behind a flag? Is there a way to do that?

LW: Not an expert, but it seems there has to be. It might be in the INI? At the
point that were wanting to ship, it should be in multiple implementations so
it's fine if tests fail, so as soon as it's expected to pass in at least one
implementation, it seems like a fine time to merge it. It'll fail -- and when
that happens we mark it as don't run, or expected fail, then that's your todo
list when your a participating browser.

BS: Right, so anyway that's one thing that's helpful for the CR, but also
helpful for us in general. I think I'll spend some time today getting that
working. Any other thoughts?

OK, let's close. Next meeting is in May. See you all then.
"
wasi/2021/WASI-06-03.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the June 3 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: June 3, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Lin Clark
    - Email: lclark@fastly.com

### Registration

None required if you've attended before. Email Lin Clark to sign up if it's your first time. 

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Environment Variables in a Typed Main environment (Dan Gohman)

## Notes
### Attendees
- Lin Clark
- Andrew Brown
- Pat Hickey
- Dan Gohman
- Mark McCaskey
- Radu M
- Luke Wagner
- TIll Schneidereit
- Piotr Sikora
- Johnnie Birch
- Sam Clegg
- Nicholas
- Syrus Akbary
- Ralph Squillace

**Lin Clark:** Dan is going to give a talk on environment variables

**Dan Gohman:** Environment variables are an old POSIX thing that are embedded in a bunch of places. We use them because they are better than alternatives. Debian has a policy on how to use them (linked), one thing they assert is programs should have a good default if an environment variable is not present.

**Dan Gohman:** How should environment variables work in Wasi? Two categories of use cases: well known variables set by the system or a configuration system e.g. PATH, LANG, TZ, and then application specific environment variables. E.g. gnu ls recognizes LS_COLORS. Other applications use them for secrets, like AWS_SECRET_ACCESS_KEY. Using variables for secrets is tricky, they can get leaked in the shell and other places.

**Dan Gohman:** Potential problems include: they have hidden effects. We want programs that are portable and statically analyzable. Programs don’t declare what environment variables they need, can lead to “Works for me” but doesnt work elsewhere.
**Dan Gohman:** The default environment variables contain a lot of interesting information, could be personally identifiable (home directory contains your name), path and time zone and operating system and hostname identify your machine as well.

**Dan Gohman:** Because environment variables are strings they may contain absolute paths or network addresses that require ambient authority to open. 

**Dan Gohman:** Portability is an issue, windows environment variables are pretty similar to unix but not exactly the same. String encoding is also an issue we wont get into here.

**Dan Gohman:** WASI’s conceptual tools for this sort of problem: we have my presentation from a few weeks ago about Typed Main, where argv strings are replaced with typed parameters. Another technique is programs could write a witx description of what it needs from the outside world. You can also use something like a preopen system, libc grabs handles behind the scene. Languages and toolchains need to opt into all of those.

**Dan Gohman:** I presented Handles in a march or april meeting, they are references to external resources. Handles are defined by a spec layer below WASI, WASI can just focus on defining its APIs in terms of Handles. These are a mechanism to avoid ambient authorities - rather than pass in absolute paths we can preopen and pass in a handle to a file.

**Dan Gohman:** The follow on to Handles was I/O Types. This gives us streams and arrays, which abstract over many of the useful things the underlying system can give us (e.g. networks, files, devices storage partitions, pipes). 

**Dan Gohman:** Finally we talked about Canonical ABI previously, it gives us a way to use Interface Types without the full power of adapter functions being ready to use yet. 

**Dan Gohman:** So now with all of those technologies I will present Typed Environment Variables. This mirrors the way Typed Main works. We want to cast environment variables as imports available to the program. At program build time, it declares it will import the values, so we can statically see what it needs.

**Dan Gohman:** When should we use imports vs when should we use arguments? These are two different domains to provide input to a program with no clear dividing line between the two. My intuition is: use arguments for things which would be arguments in a CLI, and imports for things which would be enviroment variables or ambient authority. Not a hard and fast rule but a good starting place.

**Dan Gohman:** Lets look at more use cases. Locale variables: LANG, LC_*, TZ. Many headless applications and libraries wont need to know these. We can define interface type enums for Language, Locale, Timezone so these can be imported with structure rather than by string. Maybe a single locale, timezone won’t even apply to an entire application, we don't need to tie that to the entire process scope, we have smaller modularity in WASI and we can get away from that. We can use an abstract timestamp type which doesn’t have an associated timezone, and only present it in terms of a time zone when the user needs it. For compatibility, libc can recreate the strings.

**Dan Gohman:** Another set of variables is the terminal config- TERM and NO_COLOR. There is this common environment that lots of programs expect to run in, for WASI to be portable we need to keep that environment consistent. Many programs already recognize “256color” in the term string so we can e.g. set `TERM=”wasi-256color”`. But that is a process wide symbol, what if we have a program talking to multiple terminals? We should scope the terminal setting to a terminal connection.

**Dan Gohman:** Temporary directories, TMPDIR. This hasn’t aged well in Unix, programs have to use random names and special protocols to stop from stomping on each other. It has been the source of many CVEs. TMPDIR doesnt preserve a lot of intent for what a program uses it for. Does the program need to create a file to pass it to another application? That requires your program and the next share the same view of the same filesystem. Ownership and lifetimes are not well defined, so systems need daemons to clean up old temporary files. THese are a symptom of what I call “filesystem oriented thinking”, if we need to solve “temporary storage outside programs address space” we can use io arrays for that. We can use and manage their lifetime in a very particular way. If you need to pass large objects between programs, you can use handles for this as well. We want to push programs away from assuming they have TMPDIR and towards using handles. Compatibility will be harder to emulate in libc. We can provide a TMPDIR to libc but that wont help us with sharing with other programs. We’ll likely need to have programs be modified to work for WASI when they need to pass a temporary file to another program.

**Dan Gohman:** HOME has so many things in it. Your ssh keys, your email, your browser history is all sitting there. In many virtualized container environments home may be empty. We need to drill down and have a program say what its doing with its home directory - is it a cache, is it a config. Special case thats harder to fit in the model is a user shell where the user is navigating their own files. We can put shells in their own box, that is not the general application platform use case, potentially shells can have their own separate APIs.

**Dan Gohman:** Path configuration- ways to run external programs. PATH, EDITOR, BROWSER, SHELL etc. so that the program can exec things. Very difficult to make portable or sandbox. For typical applications and libraries we should make them describe exactly what external resources they need - if they really need to launch an editor there should be an api for them to do that.

**Dan Gohman:** Arbitrary execing another program on the host system is maybe out of scope for WASI for today, its very difficult to do this in a sandboxed or portable way. but having a WASI program launch another WASI program is very much in scope. We want programs to express their intent to do one or the other of those things.

**Dan Gohman:** User config like LOGNAME, UID. sshing to a hostname makes use of this, it picks a username on the other end of the connection according to the local username. Wasi can define a DefaultUsername type that is imported for that ssh use case.

**Dan Gohman:** Application config like GIT_AUTHOR_NAME, LS_COLORS. The Twelve-Factor App recommends this approach for configuring applications. We want to allow applications to request arbitrary names, however, they should use imports with specific types, and we should deny well-known environment variables for security/privacy reasons e.g. LOGNAME. In this case, we can be compatible by having tooling translate its imports back into string environment variables.

**Dan Gohman:** Secrets are a special case of application config. We can add a Secret type for arbitrary bytes outside the instance, keep it behind a handle so that programs dont need to observe the secret itself and have special APIs to serialize them into HTTP request URLs or other things, as late as possible - potentially some sort of templating system. Different protocols may have different requirements for how and where secrets get interpolated. 

**Dan Gohman:** How does this look for developers? In the typed main story we pass in environment variables as a list of key-value string pairs. Next step up is the application developers write their own witx file to describe their imports. And finally we have language/toolchain integration. In my Nameless rust crate I have a demo of how typed main and environment variables will work with full language/toolchain integration. I have declared what environment variables this program uses with this special macro. When you compile this program for native, it uses regular environment variables to get these imports. When you compile it for WASI, it uses imports for the environment variables.

**Dan Gohman:** Any questions?

**Andrew Brown:** You mentioned environment variables as imports - how do we do optional imports in WASI/WebAssembly?

**Dan Gohman:** We defined a system for optional imports in WASI a long time ago and nobody implemented it or used it. We want Module Linking to provide a concept of an optional import. So whether we describe it in the WASI spec or Module Linking we will have some mechanism for this.

**Piotr Sikora:** Do we expect to use existing WASI apis to consume environment variables? One current problem is what if you need a configuration that is e.g. a table containing many megabytes of IP addresses, then it stays in memory for the lifetime of the process. What about a way to extract a single value from that table?

**Dan Gohman:** The current interface will be called “classic WASI”, when we move to typed main you can say, rather than import the value as a string you can import it as a typed object and then have additional getters defined which take the handle to that object.

**Sam Clegg:** Would these environmental imports be distinguished in some way or look like any other import?

**Dan Gohman:** I think they should look like any other import. When you need to run a program like this in a command line setting, if the wasi runtime cant satisfy the imports form what is available ambiently, they can be an optional value where it indicates it doesnt have them. The user’s agent gets a lot of flexibility on how it provides these variables, it can report an error to the user or prompt for the input - that is up to the user agent, not the program developer. Imports are sort of like environment variables - your language doesnt change, your git username doesnt change, whereas you pass in different arguments each time you invoke a command line program. 

**Lin Clark:** Thank you Dan, we will see you all again in 2 weeks
"
stack/2021/sg-8-9.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 9th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  August 9th, 16:00-17:00 UTC ( August 9th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
- Francis McCabe
- Daniel Hillerström
- Luke Wagner
- Thibaud Michaud
- Zhi An Ng
- Paul Schoenfelder
- Sam Lindley
- Rick Battagline
- Ryan Hunt
- Paul?
- Andreas Rossberg
- Ross Tate
- Alon Zakai
- Deepti Gandluri
- Adam Klein



## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. Next steps for stack switching
   2. Should we add 'work stealing' (aka moving tasks between threads) as a requirement?
   3. Next meeting [2 mins].
1. Closure

## Meeting Notes



### Adoption of the agenda

### Discussion:

#### Multi-Stack Requirements by Francis McCabe

FM: thing that strikes me the most is 3rd use case, yield-style generator. Would like to see a more convincing critical use case. Not sure what it is.

PS: specifically for generators or green threads in general?

FM: this was a stand-in for other forms of non-local control flow, we have green threads already as a critical use case

PS: you mean continuations or things of that nature? call/cc or variants. Call/cc is a technology, not a use case

PS: a use case can be supporting languages with control flow structures natively like that. How are you going to compile to Wasm without support for control flow that is based on continuations.

SL: we felt that those kind of things are not critical use cases, there are such languages…

PS: what is the definition of critical use case? In my mind, we don’t want to restrict such languages from being able to target Wasm

SL: yea maybe that’s reasonable and we are too conservative. Supporting Scheme might not be a critical use case

PS: perhaps that isn’t, saying if we can’t support the way Scheme does continuations, which is critical to people who want to bring Scheme to browser, but not critical to others. If critical is about top 10 programming languages, and not anything else, that’s one definition of critical.

FM: lead to adoption

RT: critical to the proposal being successful, being adopted in Wasm

SL: use case and critical success factors seem to be different things

FM: critical success factors is something we must satisfy, a use case it what we are targeting

SL: difficulty in identifying the exact scope of green threads, does that encompass coroutines? Actors? Promises? Depends on what taxonomy you want to use. All of those things are important, how you group them is arbitrary.

FM: one reason I left yield-style generators in the list was, there is a risk of going down a particular technology rabbit hole that was too focused on async-await and green threads, whereas the other use cases don’t seem to come up to the same level, but don’t necessarily want to leave them out. Async/await wait up in the front, everybody needs it, green threads needed by a lot of people, the other things form a long tail.

RT: the top 2 are really critical use cases for the MVP, but you want a viable path towards the tail use cases (yield-style generator) so at least we have thought about them

FM: this list doesn’t talk about MVP at all, but yes that is a way of thinking about it. Want to make sure we don’t cut off the long tail.

SL: in the long run, the long tail does support for general continuations like in Scheme

PS: support for async/await green threads, can’t imagine you can’t implement generators on top of them

FM: that was the thinking, maybe rather than talking about yield-style generators, we should talk about long-tail uses of continuations, much harder to enumerate that long tail

SL: there are many many examples, a big one is reactive programming, which is kind of tied in with green threads

FM: will take an AI to edit this slightly







#### Should we add 'work stealing' (aka moving tasks between threads) as a requirement?

RT: from discussions, i got a sense we want to reconsider work stealing in scope. Teams are coming in with plans for goroutines, there is an implicit assumption that goroutine can be moved to a different thread, number of languages are assuming that. Conversations with people from TC39, discussing how JS moves to support more thread centric parallelism. Web workers are very isolated, ongoing proposals that web workers can share mutable state and make effort to ensure that mutable state is well behaved, so engines can still perform optimizations. E.g. looking at explicit distinct heaps, can move an entire heap from one thread to another, or share heap but read only view. Also looking at sharing certain JS objects with fixed prototypes, shape cannot change, all shape analysis can still work in parallel settings. Looks like JS will have a richer support for parallelism, in this proposal we are thinking of moving from one process level thread to another. Constraints that come up are the JS setting constraints, if your stack has JS references on it, you can’t move it to another thread, would break many engine optimizations. What are the implications of supporting work stealing?

FM: work stealing approach to parallelism underlies the Java story and Swift story. A number of languages moving to this model of many tasks distributed over smaller number of threads

RT: and Go too. Erlang probably hoping for this too? (stacks move across threads)

PS: absolutely, key part of how Erlang scheduler works. If we can’t do that, it is an acceptable loss, but is a key optimization lost. Browser remains to be seen, that will largely depend on what kind of workloads are happening in the browser. We might be be able to do dom-less rendering then pass to main thread. In non-browser land, work stealin gis critical

AR: is it realistic to talk about this before we have pure Wasm threads?

PS: much less interested until there is notion of real threads. We have been treating Wasm as single threaded in our compiler

SL: our current spec (inspired by multicore ocaml), any reason why it can’t be extended to support work stealing once we have threads. One of their example is a work stealing scheduler

RT: you need to guarantee your stack doesn’t have JS refs on them

SL: the subtle thing here is interaction with JS

AR: OCaml has similar problems, they multiplex syscalls to one given thread, the env can’t just do anything on any random thread. There is one kind of thread that is special, is more capable than the random threads you spawn. Don’t think this problem is specific to JS

SL: more about interactin with external system

LW: in the future when Wasm has threads, we talked about shared fn and shared types, shared fn can called from any thread, so transitively the types can be accessed anywhere. For continuation, you have a shared continuation, suspended from shared fn, will prevent unshared reference in stack

AR: exactly what i would expect, have to work through the details of transistive, only make sense after we have shared attributed

LW: Wasm will need a fork instruction, if we add a shared attritube it can be postmessage-able. What does it mean to add shared, with transitive property, does it guarantee …

RT: implications of interop constraints with JS or external system. One issue is when shared fn call non-shared fn, with guarantee that non-shared fn won’t suspend. In a disjoint heap model, with message passing from one heap to another, some fn that is called by send operator, takes care of copying, move data from its heap to a format that is allowed to be on another heap. This special fn can talk about two heaps at once, do the copy then the suspension happens

SL (chat): If anyone's interested, there's a Multicore OCaml implementation of workstealing using effect handlers here: http://www.lpw25.net/talks/meetup2015/multicore.tar.gz

SL: an overview of current status of threads proposal?

AR: current proposal is limited, implemented in most engines. Really only adds atomic instructions, and a memory model. No notion of ways of creating a threads from within Wasm. You can only share memory between threads (Web workers from outside).

SL: would it make sense to share a continuation

AR: the paper for memory model, an extension that is a bit richer, includes refs and functions, type system has shared attribute with transitive guarantee, shared cannot point to unshared. RT says might be too weak in some cases. It’s quite far in the future, discussing quite hypothetical thing. Continuations are another ref type, they also have this shared attribute, will be how they fit in. Question is the typing rule, can try to work through that.

SL: what stage is threads proposal at?

AR: technically stage 2, thing that keeps it at stage 2 is that test infra cannot yet handle that. It’s there now, so we need to port that. We need to edit the spec, include what we did in paper. Process side is lagging behind, implementation is there. Spectre thing stalled shipping implementations. This is a very limited form of threading where you can only share memory, all these things are not expressible there. No concrete work on follow-up.

SL: wonder if we should try implementing concrete example in ref interp that combines thread with typed continuations proposal. Would that necessitate adding extensions to these sharing properties

AR: can try playing, question is how far you have to diverge implementing this sharedness type system, maybe not that much work

SL: RT, do you have concrete examples of something going wrong?

RT: the example of message passing, you need a way to temporarily to talk about 2 disjoint heaps in a setting where I’m guaranteed not to suspend. In a shared function, but need to call out to a non-shared function, with some guarantees that you won’t suspend while doing so. High-level constraint for the proposal is, if we want to support work-stealing eventually, what path do we have to making sure that the stack frame has only sharable things, without walking and examining everything. Maybe the straightforward thing of shared is enough, or not.

FM: the idea of calling a non-shared fn from shared fn strikes me as problematic, have to be a different way. In Interface Type, we resolve that by adopting multi-memory as a requirement. Still hasn’t been fully adopted. If we have the equivalent of that for gc memory, you can implement message passing.

RT: a lot of stuff we take for granted that needs to be supported within Wasm, how to support them without building in everybody’s mechanism (e.g. message passing)

LW: default assumption is to use shared memory to implementing unshared memory for message passing. Think this is an orthogonal discussion of how do we do shared.

FM: not a regular data structures

LW: this continuation and all stack frames do not contain refs. That can be orthogonalized from how we do fancy sharing, where we temporarily rendezvous

SL: once wasm supports threads and stack switching, it should support sharing of stacks. Wll be disappoint if Erlang cannot leverage this

RT: currently that will be the case with either proposals we have written

LW: the fork primitive, which starts a new stack, the root being Wasm, so it doesn’t involve JS

RT: with fork, the new fork thread can call out to JS or call import

LW: it won’t be able to take any JS, it is off of the JS thread, won’t make sense to be able to call JS

PS: this is a restriction we can live with

LW: certain WebIDL defined as shared, can be taken off the main thread, not JS unless JS can share functions

RT: shareable suspension can only be handled in shared functions… we should spend some effort thinking through that

### Adjourn

"
main/2017/CG-08-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 8th video call of WebAssembly's Community Group

- **Host**: Google Hangouts
- **Dates**: Tuesday August 8, 2017
- **Times**: 9:00am–10:00am Pacific Time
- **Location**: *link sent to registered participants*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

[Sign-up](https://goo.gl/forms/2Te4NrrQYdmVGVkD2)

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Follow-up from [Kirkland meeting](https://github.com/WebAssembly/meetings/blob/master/main/2017/CG-07.md)
        1. Mailing list reshuffling:
            - public-webassembly is now for discussions, requires signup.
            - public-webassembly-announce is moderated and low-traffic, auto-signs up all CG members.
    1. Discuss timing of next in person CG meeting.
    1. Hold these video calls regularly? What schedule? (JF Bastien)
    1. WebAssembly Working Group (Brad Nelson)
        1. Planning and Logistics
        1. Discuss scheduling of future WG meetings
    1. Content Security Policy and WASM (Brad Nelson)
        1. Discuss clarifying current tight WASM CSP restrictions
            1. Strawman (for near term):
                * Similar to JF's proposal https://github.com/WebAssembly/design/issues/1092
                    * But avoids throwing from promise-returning methods
                      Fails earlier (at compile)
                    * Allows Tables + Memories
                      Has baked in the understanding that we revisit loosening this at some point,
                      likely as modules + WebAssembly becomes clearer.
                    * When under an unsafe-eval policy, all methods are allowed.
                    * When not under an unsafe-eval policy:
                        * Throws a CompileError:
                            * WebAssembly.Instance
                            * WebAssembly.Module
                        * Returns a promise rejected with a CompileError
                            * WebAssembly.instantiate / WebAssembly.instantiateStreaming
                            * WebAssembly.compile / WebAssembly.compileStreaming
                        * Always allowed:
                            * WebAssembly on the global object
                            * WebAssembly.Memory
                            * WebAssembly.Table
                            * WebAssembly.validate
                            * WebAssembly.CompileError
                            * WebAssembly.LinkError
        1. Discuss allowing WASM in more places (in the future)
            1. Strawman (longer term):
                * WebAssembly modules or instances compiled from a Response with
                  a URL set are treated similarly to JS code loaded via a script tag from a URL.
                  Wasm compilation from a Response falls under script-src
                  strict-inline has no effect on wasm compiles as they have no equivalent of inline.
                * The 'integrity' field in fetch()'s 'init' parameter can be used to specify sub-resource hashes at the 
                  request site, equivalent to <script integrity=.
                  Combined with script-src <source-hash>,
                  this allows execution of safelisted resources by content hash, not just URL..
                * There is no equivalent to <script nonce= (or need for it as there is no wasm equivalent to inline).
                * A Response is fine under policy if any of the following hold:
                    * unsafe-eval is allowed
                    * wasm-eval is allowed
                    * It has a URL that is allowed by script-src
                    * It has integrity metadata (piped through from its originating request,
                      e.g. via fetch(..., { integrity })) that is allowed by script-src
                * When a Response is fine under policy all methods behave as currently specced.
                * When a Response is not fine under policy:
                    * Returns a promise rejected with a CompileError:
                        * WebAssembly.instantiateStreaming
                        * WebAssembly.compileStreaming
                * When neither wasm-eval nor unsafe-eval are allowed:
                    * Throws a CompileError:
                        * new WebAssembly.Instance
                        * new WebAssembly.Module
                    * Returns a promise rejected with a CompileError:
                        * WebAssembly.instantiate
                        * WebAssembly.compile
                * Always allowed:
                    * WebAssembly on the global object
                    * WebAssembly.Memory
                    * WebAssembly.Table
                    * WebAssembly.validate
                    * WebAssembly.CompileError
                    * WebAssembly.LinkError
    1. Coordinating spec tests with WebPlatformTests (Ben Titzer)
        1. Discuss advantages / disadvantages of changing source of truth for some or all of Wasm tests to WPT.
        1. POLL: Should we strive to have some version of all Wasm tests as part of WPT?
        1. POLL: Should the source of truth for Wasm Web embedding tests live in WPT?
        1. POLL: Should the source of truth for Wasm JS embedding tests live in WPT?
        1. POLL: Should the source of truth for Wasm binary format tests live in WPT?
        1. POLL: Should we automate the process of commiting Wasm tests to WPT?
        1. POLL: Should we automate the process of commiting WPT test changes to Wasm repos? 
    1. [Presentation on JS/wasm modules integration](https://docs.google.com/presentation/d/11tHsNh2U9oEJD4lvV7XX2M22JnyeyyCHj1ncmspXjBU/edit?usp=sharing), mostly stage-setting (Domenic Denicola)
    1. Bulk Memory Instructions (Ben Smith)
        1. [WIP proposal](https://gist.github.com/binji/acc43b94c0a747e51dfafa1b5b099c9a)
        1. Some initial performance numbers
1. Closure

### Schedule constraints

None.

## Dates and locations of future meetings

| Dates                    | Location          | Host       |
|--------------------------|-------------------|------------|
| 2017-11-06 to 2017-11-07 | Burlingame, CA    | TPAC       |

## Meeting notes

### Roll call

* JF Bastien
* Arun Purushan
* Dan Gohman
* Tyler McMullen
* Deepti Gandluri
* Richard Winterton
* Pat Hickey
* Brad Nelson
* Ben L. Titzer
* Vincent Belliard
* Ben Smith
* Thomas Lively
* Domenic Denicola
* Jason Yu
* Arjun Sreedharan
* Martin Becze
* William Maddox
* Peter Jensen
* Sergey Rubanov
* Luke Wagner
* Eric Holk
* Unbug Lee
* Lars T Hansen
* Mike West
* Jacob Gravelle
* Michael Holman
* Limin Zhu
* Benjamin Bouvier
* Rick Byers
* Michael Hablich
* Andrew Koroluk
* Ulrik Sorber

### Agenda adoption

Brad seconds.

### Mailing list reshuffle

JF explains reshuffle.

### Timing of next in person CG meeting

Mozilla and Intel can host the next meeting. Intel in Santa Clara, Mozilla in Mountain View. Let’s just go with Intel for now.

Ben Titzer: is VC equipment good?
Richard: yes.
JF: [Hosting process](https://github.com/WebAssembly/meetings/blob/master/process/hosting.md)
JF: try something between 1st and 3rd of November, just 2 days.

### Video call regularity

JF: meetings have had enough content each time. Maybe hold bi-weekly, same time and Hangout link. Will continue sending official invites to list, but we can assume meeting is always happening.
Brad: should I send a calendar invite?
(yes)

### WebAssembly Working Group

* Brad: we now have an official Working Group. Finalize spec test, publish recommendations. Need to start holding meetings, imagining primarily video calls. Some timers in the W3C start when you have the first working draft, want to do that soon. Imaging monthly video calls. Will have brief face-to-face at TPAC, my not have any items of business. Will need to discuss JS and Web embeddings, should we block on those or tackle separately? Tentatively will hold first video call next week, Monday.

* [Join here](http://www.w3.org/2004/01/pp-impl/101196/join)
* [Home page](https://www.w3.org/wasm/)

### Content Security Policy and WebAssembly

Brad Nelson presenting.

* [CSP issue](https://github.com/WebAssembly/design/issues/1092)
* CSP allows pages to set restrictions.
* Would like to get everyone on the same page.
* Browsers currently do different conservative things.
* Promises should probably reject, not throw.
* Throw EvalError, like other JavaScript things.
* JF implemented compilation allowed because a Module can be postMessage’d.
* Mike: threat model for CSP isn’t protecting bugs in implementation. It’s preventing user-generated content from being executed. Compilation without execution isn’t something CSP cares about.
* Luke: agreed. It’s about strings finding themselves in eval strings.
* Domenic: it’s also binary blobs.
* Brad: CSP folks don’t care because it’s about code execution?
* Mike: I don’t care about protecting V8. As long as we prevent code execution I’m fine.
* Brad: given this, I don’t have a preference.
* Brad: in original WebAssembly API resources aren’t URL-bound, this allows JIT-code generation. A better approach would tie in with streaming API, script-src locations would “enhance” Response, and URL wouldn’t be forgeable.
* Mike: I think CSP already assumes URL can’t be forged. Step 5 already checks outgoing response, and 17 checks the incoming Response.
* Brad: there’s option on fetch to specify a hash. Integrity field. You can carry it through and reference it elsewhere.
* Mike: would be useful to distinguish SRI and CSP.
* Domenic: I thought so too, but CSP has script hash.
* Mike: I think it’ll work different from script tags. We call fetch internally when dealing with a script tag. Whereas with WebAssembly you fetch, pull data, and do work on the blob.
* Mike: currently we don’t persist SRI information in response.
* Domenic: that’s the proposal, allow integrity field to carry through.
* Mike: it might not be a big deal to do this.
* Brad: allows more flexibility about where the hash goes.
* Mike: allows you to allow scripts from arbitrary sources, as long as the hash matches.
* Brad: in addition to unsafe-eval, also have wasm-eval allowing just WebAssembly and not JavaScript.
* Luke: let’s also have discussion of whether unsafe-eval covers WebAssembly, has consequences. Let’s do it as a separate issue.
* Action item JF: will file tracking issue, Brad to champion.

**POLL**: encourage work in the general direction of the strawman presented by Brad

Yes

### Coordinating spec tests with WebPlatformTests

Ben Titzer: There’s a repository for web platform wide tests. There’s tests in the spec repository which tests implementations, then JS and Web platform tests. Question is where all that should live. With the spec right now, there’s the reference interpreter which has the wasts for the engine tests, and place-holders for what would be web platform tests. They need more work. Question is where they should live. Where would the source of truth be? Rossberg thinks wast tests and JS API tests should stay in spec repository. For developing WebAssembly adding new things is easier if it’s all together.
* Rick Byers: over the last year we’ve shifted how the web evolves. Disciplined about testing, it used to be a disaster. Web platform interoperability as of 1.5 years ago. We created a dashboard at [wpt.fyi](http://wpt.fyi). We (Google) have about 10 people working on this. CSS folks a while ago moved all their tests into the web platform test repo instead of duplicating tooling. We also have tooling for pull requests, will run tests on all platforms, won’t allow flaky results. WHATWG has a policy: all normative changes must come with a web platform test PR. It’s a bit of a pain to track in separate repos, but people love it eventually.
* Luke: we’ve done some work, but looking at contracting Igalia to sync tests bi-directionally. Having web tests in web platform tests seems fine. Keeping wasts in spec tests sound good. The JS ones are kind of in the middle. We could do whatever.
* Domenic: agree. We do lose some of the benefits of the tooling if you keep them with the spec. It sounds like wast tests require more infrastructure.
* Ben Titzer: the granularity is coarse. Maybe we can move them in coarse grain to the web platform tests.
* Luke: non web platforms will want to run the wasts.
* Domenic: there’s good support for this on the web platform test infrastructure. Maybe having a generation step.
* Rick: we invest heavily, 10 person team, includes a contract with Bocoup who do test262. Anything that leverages web platform tests we can help.
* Brad: would you be able to set up a two-sided commit for a slide of the test that lands in V8?
* Rick: we can explore. How do we generalize import / export. I don’t know enough.
* Mike Holman: yeah it’s complicated for us because all our JavaScript stuff is on GitHub and we have to integrate back to get web platform tests. Anything that would make it better would be great.
* Tyler from fastly: there are applications for WebAssembly outside of browsers. It would be fine in WPT, but having source of truth in spec would be good. Our applications are outside of browsers. Having the web platform tests is weird, but it could be fine.
* JF: good point, would it be OK for WPT to run non-web gating tests?
* Rick: there’s a public test infra mailing list. Could be OK.

Links from Rick on WPT:
[W3C web-platform-test blog](https://www.w3.org/blog/2017/05/the-web-platform-tests-project/)
Centered around investments specifically in web-platform-test
Chrome has a ~10 person team
[Ecosystem Infrastructure team charter](https://docs.google.com/document/d/1MgcisuMnvh3z6QNIjDSvRbt4uoNtmI_cljcQkGXzNQ8/edit#heading=h.79m825gvckml)
[Web-platform-test chromium infrastructure status update](https://docs.google.com/presentation/d/1s2Dick89wvJsuNJb4ia3pPt84NtMv8rZr0E_GFXJLrk/edit)
[Web-platform-test dashboard](http://wpt.fyi/)
[PR](https://github.com/w3c/web-platform-tests/pull/6770) build bot - being replaced with a more powerful results server
Chromium and Firefox have tooling for import/export, Apple and Microsoft looking at something similar
[Using web-platform-tests in chromium](https://chromium.googlesource.com/chromium/src/+/master/docs/testing/web_platform_tests.md)

### JavaScript / WebAssembly module integration

Punt to next meeting.

### Bulk memory instructions

Punt to next meeting.
"
main/2018/CG-08-07.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 7 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: August 7, 4pm-5pm UTC (August 7, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email JF Bastien or Ben Smith to sign
up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. New champions needed for proposals:
       1. [Fixed-width SIMD](https://github.com/WebAssembly/design/issues/1075)
       1. [Type Reflection for WebAssembly JavaScript API](https://github.com/WebAssembly/design/issues/1181)
       1. [Exception handling](https://github.com/WebAssembly/design/issues/1078)
       1. [Web Content Security Policy](https://github.com/WebAssembly/design/issues/1122)
    1. [Moving SIMD proposal to stage 2](https://github.com/webassembly/simd) (arunp)
       1. What remains to be done here?
    1. Follow up on [last meeting's `volatile` discussion](https://github.com/WebAssembly/meetings/blob/master/main/2018/CG-07-24.md#discussion-c-volatile-in-webassembly-httpsreviewsllvmorgd49194)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Adam Klein
* Alon Zakai
* Andreas Rossberg
* Ben Smith
* Ben Titzer
* Conrad Watt
* Dan Ehrenberg
* Deepti Gandluri
* Derek Schuff
* Heejin Ahn
* Jay Phelps
* JF Bastien
* Lars Hansen
* Luke Wagner
* Pat Hickey
* Peter Jensen
* Richard Winterton
* Sam Clegg
* Sergey Rubanov
* Sven Sauleau
* Thomas Lively
* Thomas Yeun

### Find volunteers for note taking (acting chair to volunteer)

Pat Hickey

### Adoption of the agenda

Luke Seconds

### Proposals and discussions

#### Review of action items from prior meeting.

#### New champions needed for proposals:

1. Fixed-width SIMD

Arun: I was talking to Peter Jensen from Intel about this proposal, pending approval from management we may be able to co-champion this together

2. Type Reflection for WebAssembly JavaScript API

Andreas: I have too much on my plate to champion this, I’m happy to help with this but need someone to do the work of writing the spec and tests

BS: As champion its not necessarily your responsibility to write the spec or do the technical work, but just to take the role of pushing it forward and finding people to delegate the technical work to. Is that everyone else’s perspective? (Many nods)

Luke: Till volunteered to champion the reflection API.

3. Exception handling

Heejin volunteers

4. Web Content Security Policy

JF: Brad setup a meeting with another group in the W3C to talk about how to structure this. There’s low interest from people on the web for getting this right?

BS: I got the same impression. Maybe we can let this drop until people are interested.

BT: I don't know if we will be able to let it drop. Google had some people interested. Maybe Domenic will take it. We’ll have discussions and come back.

#### Moving SIMD proposal to stage 2 (arunp)

1. What remains to be done here?

(Copied from Phase document)

* Full proposed English spec text available in a forked repo around which a reasonably high level of consensus exists.
* Updates to the formal notation, test suite, and reference interpreter are NOT yet required.

Arun: Is there anything besides these to take it to stage 2?

BS: I copied the requirements in (above). How far off are we on the items in point #2 above?

Deepti: I think there are a lot of rough edges and we are working to resolve issues in the spec. We didn’t have everyone on board with the spec as-is. We didn’t want to call something spec text if it didn't have numbers for the instructions,

JF: When we started the SIMD work we voted to not add instructions that didn’t have a measurable advantage

JF: We can go back to what we had voted on, maybe a year ago. We should figure that part out.  Move forward only the stuff that met the bar we proposed.

Deepti: We have some early use cases for the floating point instructions, do we just need a use case or do we need fleshed out performance analysis?

JF: I think it would be useful to go back to what the notes said, add to the issue list -- what we were looking for. It was pretty well thought out, so...

Deepti: Ok

Dan: We went through that process with simd.js and ended up settling on including FP instructions based on some JS benchmarks. Would it make sense to pick up that evidence?

JF: If I remember it ended up being pretty underwhelming. We voted on standardizing an API that works well on every architecture - it has to map well to both arm and x86. If you start adding shuffles and 16-bit instructions I really want to make sure we get it right or else we’ll paint ourselves into a corner. We had a long discussion about this and I want to make sure we stick to it. It was a google meeting at the quad

Keith: I think it was at the microsoft meeting

JF: Yes we discussed it there too. James came back with numbers there

BT: It’s great that we have notes on that, can we get something that’s less hidden away.

JF: Yes this criteria we came up with should be made part of the SIMD proposal.

BS: Action item: put this into the proposal?

Deepti volunteers

Andreas: What is the current status of SIMD with respect to introducing more nondeterminism? Some of the instructions might be underspecified?

BT: Vector floating point on (...) might do something on arm

JF: Some floating point instructions flush to zero - It only does that on arm v7, not on newer v8, so that's up to the implementor. We can also say that ARMv7 can’t use those vector instructions.

BS: There’s another question about reciprocal square root

Deepti: Not in spec, but there’s a pull request

Andreas: So the goal is to avoid more nondeterminism?

JF: We said we would explore it but we need a principled way to deal with it. Will ARMv7 have to devectorize (scalarize) to follow the spec? It’s more difficult for reciprocal square root, useful for games, and we get different results for different hardware. We have some hand-wavy criteria about what we want

RW: The result (for reciprocal square root) is not more or less accurate, it's just different

JF: Similar to threads proposal, there’s a well-defined way to get seq cst, you can step outside those bounds, but you can always constrain the behavior to being deterministic. Maybe FTZ will be fine, we don’t know. That’s the pushback from people like Andreas, trying to reduce non-determinism. We wanted a principled approach so we can provide support for different users of web assembly.

Keith: It would be reasonable to come up with a limiting factor (bound on what nondeterminism may be)

JF: We talked about adding sin and cos, having emulated through libc requires look up tables and so on, but then the question was whether you care about sin and cos way far away from zero. Transcendentals are really hard to get right. The question is: where do you offer the precision, which inputs matter.

Andreas: If we add stuff like that, somehow insulate it (clear criteria) from the rest of webassembly with a high bar for doing that.

Keith: One idea, is to have in your module an imprecision … if you don’t want imprecise floating point ops then you can block it in a module.

JF a few issues / prior discussions:

* https://github.com/WebAssembly/meetings/issues/106
* https://github.com/WebAssembly/meetings/blob/master/main/2017/CG-11.md#updates-on-simd-proposal
* https://github.com/WebAssembly/meetings/blob/master/main/2017/CG-05.md#simd

Andreas: Per-module annotations keep coming up but it doesn’t actually work. Module boundaries don’t mean anything, you can call funcs and in the future take refs across module boundaries.

BT: There should be a deterministic cos and a fast cos, with different byte codes.

Andreas: This reminds me - we already have nondeterminism with NaNs, could we add an instruction to normalize NaNs so that you can work around the nondeterminism you have there, pay the cost to normalize when you need it.

Luke: I’ve been thinking about this case about wasm-on-blockchains… when a host wants absolute determinism, there is a bit set for the host. They get a limit for all the resources, NaNs canonicalized, all that other stuff. I assume that’s what people want...

Andreas: Fully deterministic can work w/r/t/ resources, requirements for how to specify things in that dimension can vary a lot.

Luke: Maybe there are multiple possibilities on resource side -- but otherwise the spec may tell you what it means to be “deterministic”. Maybe a tool injects it for you?

Andreas: We could have an appendix for deterministic wasm. These embedders could use that. But outside that space, we may want to selectively enforce determinism, so for that case it may be useful to inject nan canonicalization.

BT: The NaN canonicalization instruction sounds good to me and is easy to add.

JF: see https://llvm.org/docs/LangRef.html#llvm-canonicalize-intrinsic

LW: Is there a lower-level expressiveness problem? It would add a little bit of code bloat but its not like we haven’t exposed a certain CPU instruction.

BS: If we want to move this forward it needs a stage 0 proposal. We should discuss this more in another meeting.

BT: sounds like the question is: If we are going to have nondeterminism, is there always going to be some escape hatch that comes with it?

Andreas: We also talked about compartmentalization of the spec, so things like threads won’t be allowed on these embeddings. But for other things, tiny things… because there is not a clear boundary that we’re defining for a new feature. There’s a risk that this might spread if we don’t have a clear policy.

BT: One way to phrase that is, try to have fully deterministic from the start but where we can’t achieve it, we add a mechanism that may be a special bytecode or may be a mode to make it deterministic at slightly higher cost that is opt-in.

Andreas: That sounds good

RW: So this means that we may allow FTZ then?

BT: That was part of the original SIMD discussion, FTZ may be something we allow

JF: But just to be clear, this is allowing things that current hardware doesn’t do anymore. Since 2010 this has not been a thing. Modern HW is fast when it comes to denormals, so this would be a backwards-looking feature.

BT: We’re only talking about SIMD with FTZ, not scalar instructions

Andreas: Lets not add it if we don’t have to, but please make sure there’s an escape hatch if it has to be added.

#### Follow up on handing C++ volatile in WebAssembly

JF: Last meeting we said we’d come back to this - Dan was supposed to look at things, Heejin was going to add some things to the issue.

Heejin: I posted the address of the GH issue for that
https://github.com/WebAssembly/tool-conventions/issues/60

The discussion was informative. It’s not really relevant to the spec itself, maybe continue the discussion there.

BS: Since Dan isn’t here there isn’t much more we can discuss.

JF: I’d like to make sure we can let Heejin move forward. Can we bring this up next meeting again? Heejin, are you blocked?

Heejin: For this issue I want to have consensus before we proceed. I want to check in with Dan to make sure he’s comfortable with what we came up with.

JF: Can you and Dan follow up offline and if there is anything still unclear we can discuss it next meeting, otherwise proceed as we discussed last time.

### Closure
"
wasi/2021/WASI-02-11.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the February 11 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: February 11, 17:00-18:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Lin Clark
    - Email: lclark@fastly.com

### Registration

None required if you've attended before. Email Lin Clark to sign up if it's your first time. 

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Discussion: What are the next steps in adapting WASI to use Interface Types handles and resources?
    1. _Sumbit a PR to add your agenda item here_

## Notes
### Attendees
Pat Hickey
Andrew Brown
Sergey Rubanov
Lin Clark
Mark McCaskey
Till Schneidereit
Dan Gohman
Josh Dolitsky
Mingqiu Sun
Ralph Squillace
Nicholas
Radu Matei
Matt Fisher
Johnnie Birch
Luke Wagner

**Lin Clark:** Are there any announcements?
(none)

**Lin Clark:** Lets talk about how we’re going to move from this version of WASI to a new version that uses handles

**Dan Gohman:** Witx has been designed to anticipate interface types. It has String and Handle types. These are pretty close to the ones in interface types - PR 391 takes things to the next level and evolves the rest of the witx types towards the interface types. Going forward we need to get rid of the witx pointer and get buffers to work the way they will in interface types, but we’re still waiting to hear from interface types the final word on how those will work. See Interface Types issue 68. Our job on the witx side is to evolve into the Interface Types buffer types. Without waiting we can add support for strings and return types and lower them into the existing C ABI that WASI programs use.

**Dan Gohman:** Another piece is WASI modularization. It has been in progress for a while but several pieces are coming together. Issue 378. Describes a more granular include mechanism than witx uses right now - import a symbol from a module, rather than import a file.

**Dan Gohman:** The next two big pieces, which we can address in detail in the future: How do you pass handles into programs? Currently there is a table with preopens in it, but interface types is going to give us new mechanisms that are better than the preopen concept.

**Dan Gohman:** The last piece is defining new abstractions. wasi PR 240 describes how to merge the send and recv on sockets with read and write on files. We can generalize part of files and sockets into a concept of I/O streams. In interface types you’ll have the vocabulary to ask for e.g. a stream you can write to, without knowing or caring that its backed by a socket or file or pipe etc. What is the noun that you use in function signatures to describe an I/O Stream? Beyond I/O Streams there’s non-streaming operations on files which don’t work on sockets or pipes - pread/pwrite - there’s a place for an I/O object with non-stream personality as well, an array of bytes or a we can call it a dynamic array because it can be resized. There will be other concepts as well - key-value stores, windowed IO with buffers... At the moment the nascent WASI I/O proposal will evolve to develop these ideas. There will still be files, and then a function that gives you a stream from a file. Files are going to be required to interop with existing systems, but we can push people towards interfaces that don’t tie them to the complications of those existing systems, particularly file semantics are very difficult to compose but streams are. This will help us enable shared-nothing linking of modules - we don’t want modules to have to share a filesystem to talk to each other. Questions?

**Ralph Squillace:** What kinds of objections to this direction do you anticipate?

**Dan Gohman:** This is going off the path of POSIX. Existing applications and programming languages will be more work to port to I/O streams than having us port libc and standard libraries to WASI. We have ideas for making the standard io operations work on top of I/O streams - you can treat an i/o stream as a libc FILE if you only ever read and write from it, other operations give an error.

**Ralph Squillace:** The philosophical discussion is about how you weigh the objectives of different applications moving to WASI - some will have to adapt specific POSIX-isms to WASI, where does the work of porting existing code break down - does the code stay in WASM and not use WASI, have its own custom runtime - or does it move to WASI in the coherent way that resolves the semantic differences. I don’t personally see myself trying to port an existing huge monolithic application to WASI, whereas I do see myself working on libraries to make them work in WASI.

**Lin Clark:** How much is WASI filesystem still going to allow porting POSIX applications?

**Dan Gohman:** It will allow it. Its a question of priorities rather than absolutes. WASI today runs plenty of interesting POSIX code that doesnt do things like fork(2), WASI filesystem is going to still be there for these applications to use. But we don’t want that to be part of the default for WASI, we want to encourage applications to use simpler concepts that don’t imply a whole filesystem. I want to build tooling that bridges the gap between the shared-nothing-linking space and making big applications work.

**Till Schneidereit:** We can look at this in terms of layering - there is a core of WASI that may not apply to every use case but you can virtualize many of the other needs on top of it. You can add a filesystem ion top of the core, in many cases, and let applications that need it use it.

**Dan Gohman:** In terms of migration from where WASI is today to this ideal system - the WASI I/O abstractions can be worked on now, we have witx where we need it. We can flesh out exactly how streams and dynamic arrays work today.

**Dan Gohman:** Another aspect is portability. I’ve been working on support for WASI on Windows vs Unix the last few months - there are so many differences between those platforms, the semantics of filesystems is radically different and there’s no portability in many cases (its too expensive to bridge them). The WASI I/O abstractions can be designed to hide all of the non-portable parts of filesystems. We can get away from having to specify “what does windows do here” and instead specify the things an application actually needs.

**Ralph Squillace:** Layering will require thought.

**Pat Hickey:** The customers we have writing applications right now aren’t concerned with the differences between the filesystem guarantees on linux vs windows, they care about http requests and responses. If we have I/O abstractions that unify the way http bodies work with the way certain aspects of the filesystem work, that is better for the applications we care about.

**Till Schneidereit:** There are lots of use cases that work with streaming, which has traditionally been a file or a socket, but with abstractions that are hard to generalize. My interpretation of what you were just saying is that if we had a way to have a cleaner system that didn’t have that incidental platform dependence, it would be much easier to build code that works across these very different environments. We have all these applications that are popping up that are very different. Ideally we have a layer that doesn’t care about host differences, and then the layer that cares about that. What we do is just one specific example of that. Don’t want to optimize for old use cases, but all of the new novel ones that are coming about.

**Radu Matei:** Is the assumption that wasi-filesystem will be developed in parallel?

**Dan Gohman:** Yes, WASI-filesystem will continue, and wasi-io will be a peer.

**Ralph Squillace:** Drawing older threads in, what about BSD sockets PR.

**Dan Gohman:** The contributor who created that hasn’t been active, but I expect that will fit into the system in the same way as wasi-fs. You could get a stream. Networking is a complex topic and I dont’ want to simplify, but the first step will be to take sockets and say the socket gives you a stream that you can read, a stream you can write, and bi-directional r/w. 

Async is a subtlety that we’re leaving out. We can say that async is an orthogonal concern. We expect the Wasm platform will give us better answers over time. But the fundamental concepts of I/O are independent of whether you block that I/O.

**Lin Clark:** Any other thoughts/comments

**Luke Wagner:** I have a hypothesis I want to test. Why are people going to want to use wasm outside of a browser? Some people think it’s great because of ISA. We don’t think that’s a great motivator. We think running guest code in latency sensitive and low trust scenarios is the motivator. Things like routers ____ would be host APIs. The libraries would be wasm. These problematic cases don’t have a high value reason to be ported to Wasm.

**Ralph Squillace:** I understand where you’re coming from. I don’t see WASI as a monolithic process sandbox. I do think that the idea about the sweet spot is right. I’m not a big believer in the thought that the world’s code is going to all be running on WASI. But I think it’s worth consideration how much of the world’s knowledge can be run as WASI. Shouldn’t wall off for all time, but I think the way that Dan laid out the direction, it lets us start with the sweet spot and either layer the others, or add support to WASI later on. I would hate to frame the boundary ruling out knowledge transfer.

**Luke Wagner:** I agree with your points, so the layering and virtualization are also motivated by that.

**Dan Gohman:** I can add one thing. Thinking of lib-c, and lots of languages have lib-c like std lib: under the covers, something that people are using as a file could be represented by streams. We can make that work under the covers. We could talk about how that will exactly work. But this is the framework. We can make porting easier by allowing you to use streams by allowing you to use files, but discourage from using file stat and depending on i node. 

**Andrew Brown:** It feels to me that filesystem should be in phase 3 or 4. How do these changes affect moving those to later stages

**Dan Gohman:** That’s a great question. Wasi-fs is waiting to figure out it’s place. This conversation moves that forward. Understanding that wasi-fs won’t attempt to be abstracting over all hosts, wasi-io does that, and accepting that’s ok means that wasi-fs can probably move to phase 3 at this point.

**Till Schneidereit:** I think the better way to put it is that it’s not an either/or, we don’t need to make it completely host specific, but let’s find a balance that’s actually viable.

**Radu Matei:** do we have a document?

**Dan Gohman:** Will be writing that up. Wanted to introduce here first. Will write up wasi-io ideas soon

**Pat Hickey:** One blocker to wasi-fs advancing. The filesystem has cloud ABI system of rights. Need to work out what to do with that.
"
gc/2022/GC-05-03.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 3 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: May 3, 5pm-6pm UTC (May 3, 9am-11am Pacific Standard Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Bringing back `nullref` [#288](https://github.com/WebAssembly/gc/issues/288) [10 minutes]
    2. Discussion: RTTs [#275](https://github.com/WebAssembly/gc/issues/275) [25 minutes]
    2. Discussion: Cast opcode refactoring [#274](https://github.com/WebAssembly/gc/issues/274) [25 minutes]
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Aske Simon Christensen
- Justin Michaud
- Lars Hansen
- Rick Battagline
- MT
- Conrad Watt
- George Kulakowski
- Slava Kuzmich
- Asumu Takikawa
- Ben Titzer
- Luke Wagner
- Alon Zakai
- Adam Klein
- Francis McCabe
- Manos Koukoutos
- Ryan Hunt
- Igor Iakovlev
- Emanuel Ziegler
- Ilya Rezvov
- Deepti Gandluri
- Sabine Schmaltz
- Jakob Kummerow
- Dmitriy
- Andreas Rossberg
- Zalim Bashorov

### Discussion: Bringing back `nullref` [#288](https://github.com/WebAssembly/gc/issues/288) [10 minutes]

CW: If we bring back nullref, is there value in keeping typed nulls around.

TL: Can't get rid of them, they're part of the shipped reference types proposal.

TL: On the issue, there was discussion of whether we should add a new instruction…

BT: Depends on the bottom heap type question

AR: Not sure this is the best forum to discuss, as it's super-technical.
Having bottom heap type is the only reasonable design. Have to keep the general shape of types uniform. The non-null (ref bot) is necessary because if you don’t have it, you lose principle typing and other things.

CW: We could have an ad hoc forbidding of…

AR: No, then you lose subtype substitutability… (explanation)

BT: Could substitute something that produces unreachable

CW: An unreachable type is exactly an uninhabited type.

AR: ref bottom is uninhabited but importantly also a ref type. A non-ref bottom type wouldn’t work.

BT: Two subtype relationships going on, value types and heap types. We already need a bottom value type. When working on Jawa, I ended up adding a bottom type…

CW: I'm compelled by the argument that we want the shape to be uniform to simplify the casting rules. 

AR: We definitely don’t want a discontinuity in the type system, even if we could pull it off. The effects are unpredictable.

BT: Inline structs wouldn’t work as well.

AR: Inline structs would be a different class (""defined type"") of type alongside value type and heap type, so we wouldn’t have a bottom type for those. Reference types introduce some special cases in validator for unreachable code, but I think that’s independent of whether we have a bottom heap type. Where else would there be a special case?

BT: Anywhere in the format you could write a heap type, you could type bottom. For example in br_on or br_on_not.

AR: The proposed refactor of those instructions syntactically restricts to subset of heap types, would disallow bottom as well. Definitely don’t want to allow arbitrary heap types to be used with the cast instructions.

TL: What's wrong with a bottom heap type on a cast?

AR: It'll always fail

TL: Seems fine

AR: Well that's totally useless, I don't think we should allow such

TL: Would be nice to allow arbitrary heap types, even if some are useless

AR: But you already can't allow casting to eq

JK: Why would it be bad to cast to eq?

AR: Because eq might include host-defined types and it could be arbitrarily expensive to check for that.

CW: What’s the state of externref/anyref?

TL: They are the same type now.

CW: So we already have the case where external types and Wasm types have to be differentiated. If systems are set up to support that, then it could make the system even more regular.

AR: Worried that if we make the type hierarchy richer later, unneeded generality could cause issues, e.g. extra work for engines.

CW: Could be a tooling hazard where modules disagree about producing anyref or eqref and can’t compare them. Can’t compose those modules if you can’t cast to eqref.

AR: Why would you have that mismatch?

CW: Because you don't control the module

AR: But then how do you know it'll work?

CW: You don't, but would like an operation that will succeed or trap

JK: Checking for data is no worse than checking for eq from an engine perspective. 

AR: Could imaging adding more types to eq, and each time the check gets more expensive. Same thing could happen with data, but that is a more closed set, so it’s less risky. Overall it would be good to have more specific casting instructions to avoid preventing ourselves from adding more types in the future because casts would become too expensive.

CW: Don't want to create a situation where modules try to cast to a variety of types until it gets the right one, then expose it as eqref.

BT: If you’re using type erasure to implement polymorphism, then you always end up with the supertype statically and have to insert downcasts. In the limit that means we need casts to reverse every subsumption in the system.

AR: When I implemented a compiler that did that, I just used eqref instead of anyref and that was sufficient.

BT: Then your code wasn’t truly polymorphic. It was only polymorphic up to eq. If there’s a library that produces anyref, then that would be insufficient.

AR: We're basically talking about host types, and there's no way to know whether they even support equality

BT: When you implement type erasure (example from Java)

CW: Can we leave the ability to generalize until later?

AR: Sure, that's what I would prefer to do

ASC: Something close to this is happening with Wasm/JS interop

JK: I don’t think we have specified that JS references are all eqref.

AR: JS docs are super stale, but I remember discussing this, maybe with Luke? This was going to be a problem with numbers, but we concluded that it was doable and not a big issue.

JK: The question is whether pointer equality is meaningful, and that’s not always the case for JS.

AR: But JS objects specifically can be eqref, right?

JK: Sure, if we specify it that way.

LW: If you import a host object as anyref and want it to interop with your type erased system, then that’s a good reason to erase to anyref rather than trying to wrap it.

AR: Still seems like you either know things are equatable or that they’re not.

CW: No one has objected to having casts of the form `ref.cast <HeapType>`, we’re just quibbling over which heaptypes to allow there. Any objections to going with that?

BT: I’m not convinced back compat is that easy. Adding types and subtyping is fraught. You would be able to determine what version of the spec you’re on. For example subtyping between function types in the future.

### Discussion: RTTs [#275](https://github.com/WebAssembly/gc/issues/275) [25 minutes]

TL: Concern is hidden costs in the future having to do implicit passing around of type info, outside control of the toolchain. Comes up especially with generics.

AR: Cost of generics are main motivation, there are other use cases, customising object creation as discussed before, or e.g. extensions similar to constant fields like with the hidden classes JS engines have.

TL: If we keep RTTs explicit, in the future I'd be hesitant to make changes to them that would inhibit the optimizability of casts. E.g., making RTTs generative would have this problem, as you could no longer make use of the static types to do optimizations.

AR: Agreed, I think we should make that a design goal for RTTs. For generative types, rtt.fresh isn't the way we should go.

JK: My general opinion is that we should add features when we can use them. I can see future uses for RTTs, but not in the MVP. We currently have implemented both RTT-consuming and non-RTT versions of every instruction, so this is not a maintenance burden. Also there are bad interactions with the host when values are passed back from JS to Wasm, where we have to “guess” the RTT to use to cast the value back to a Wasm type. Debugging and other interactive use cases depend on being able to pass values across the boundary without toolchain preparation.

AR: First, I'd argue that dynamic interaction with Wasm is far-fetched, given how static Wasm is.

JK: It’s not far-fetched. DevTools needs this right now.

AR: Still don't want to restrict Wasm's design based on such dynamic requirements. More generally, these sorts of worries are exactly why I think we should include RTTs now, so that we don't go off in a direction that won't support them even though they'll be needed for things we know we want to add, like generics. Just because we've slimmed down the MVP to a small set of features doesn't mean that we won't want to add more stuff later; this is why I called removing RTTs creating ""a hole"" in the proposal.

BT: One concrete thing we’ve talked about is the ability to piggyback source level casts, and I don’t see how to do that even in the MVP.

TL: You can’t piggyback. You need pure user-level RTTs followed by the lower-level cast.

AR: The reasonable thing we can do is have generative types, which would help with the first level of cast functionality. Would still need user-level cast implementation for anything beyond Java classes, but that’s ok.

BT: I would posit that it’s reasonable to require that a Java cast can be piggybacked.

AR: All Java casts? They include array casts, which generative types don't help with.

AR: Think there's too much focus on Java; yes, it's important, but its casts are also weird in some ways.

BT: Given that Wasm requirements are based on the languages we need to support, and that Java-like classes are used by many languages, it seems a fair requirement.

LW: Backing up a bit, can’t we view the static types as if they implicitly had an rtt.canon built in, and in the future we could add RTTs and the current instructions would be reinterpreted as using canonical RTTs.

AR: Sure, but then you end up a lot of redundancy later on.

TL: We already have this redundancy in V8 and Binaryen and it's not that bad.

CW: Would want to hear more about JK’s DevTools requirements.

JK: In order to debug a module, you want to be able to interactively call a function to produce an object and then pass it to a different function. Since this is interactive, it’s not statically typed, so we have to automatically perform the correct casts.

AR: The host can track objects' types in that environment. It can annotate every object with the type it is returned at and check against that when passing it. That would be most general and completely independent of Wasm internals like RTTs.

LW: Aren’t the devtools written in JS, so the thing that has to do this is the JS API?

JK: If the JS API handles this, then great. It’s possible that the JS API is more restrictive than what DevTools needs.

LW: Seems like the same kind of check.

### Discussion: Cast opcode refactoring 

(This was partially discussed as part of the nullref discussion)
"
main/2018/CG-09-04.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 4 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: September 4, 4pm-5pm UTC (September 4, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email JF Bastien or Ben Smith to sign
up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    2. Proposal for a [C/C++ API](https://github.com/rossberg/wasm-c-api) (Andreas Rossberg)
       * Poll: Accept for stage 0
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Adam Klein
* Alex Crichton
* Alon Zakai
* Andreas Rossberg
* Arun Purushan
* Ben Smith
* Ben Titzer
* Conrad Watt
* Deepti Gandluri
* Derek Schuff
* Heejin Ahn
* Jacob Gravelle
* Jay Phelps
* JF Bastien
* Keith Miller
* Limin Zhu
* Luke Wagner
* Peter Jensen
* Richard Winterton
* Sergey Rubanov
* Shiv Kushwaha
* Thomas Lively
* Wouter Van Oortmerssen
* Yury Delendik

### Find volunteers for note taking (acting chair to volunteer)

Ben Smith taking notes

### Adoption of the agenda

Derek Seconds

### Proposals and discussions

#### Review of action items from prior meeting.

AI(Thomas Lively): Write up discussion about optional vs required features.

TL: 80% written up, will post today. [[Link]](https://github.com/WebAssembly/spec/issues/870)

AI(Derek Schuff): Figure out relicensing of Binaryen and Wabt.

DS: I have not looked into the relicensing yet. No progress yet.

#### Proposal for a C/C++ API (Andreas Rossberg)

AR: Some clients want to embed wasm in a non-browser environment. We don’t really have a story for  that. No defined interface. AFAIK production systems like v8 don’t provide a real interface for that. V8 has embedding API, but not to wasm functionality. Idea of proposal is to define a c/c++ API agnostic of underlying VM, allows you to embed in black box fashion. One non-goal, it is supposed to be black box. No way to interact with GC, or other complicated ways.

AR: [presents repo]

AR: Has C/C++, has prototype implementation based on v8. Not integrated into v8, but built on top of v8 API. Not the most efficient way to implement it, but it works. For dfinity we have started using this.

AR: Design goals: black box API. C++ version is a bit safer to use, from memory management. C++ uses unique pointers to make that automatic. C version has none of that. Reason is that you can create a binding for C libraries. We use that to create a haskell binding. That is completely manual memory management. Implications are that I try to restrict to language features that are easy to bind to. Some FFI can’t bind struct returns, etc.

AR: Luke suggested that we design everything abstract classes with factory methods. Makes it link-time independent.

BT: Does that mean you could link in two implementations of this API?

AR: All classes are abstract classes, everything is just pointers to methods. Header doesn’t include implementation details.

JF: Why do you have both? Is one implemented on top of the other?

AR: Yes, started with C, but built C++ on top to catch memory errors. Much safer to use.

JF: It’s much easier to create a stable ABI in C, wrapper in C++. When I did this last year I just did C. You really don’t want C++ if you want a stable ABI.

AR: I think it should work, since you’re just programming against a C interface works, though brittle. At some point I found that I had a complete layering in C++. That’s one of the things that we can iterate on, whether the C API is sufficient.

JF: If the user uses is pure C++ and it’s all inline, and the only things we link to are C calls that’s better. Agree that it’s easier to use C++ API. I doubt that webkit would ever expose a C++ API, but already has C APIs.

AR: In principle we can do this, I found it easier to get it working this way.

WVO: Sometimes people who consume pure C libraries don’t want to have to link to C++.

AR: But the engines are all C++

WVO: True

BT: Current engines are implemented in C++

AR: Yes, there’s no reason you have to implement one in terms of the other. You could do both. Maybe just expose C API, maybe wrap the other way. Maybe good idea to have wrapping in both directions so not everyone has to redo them.

TL: It seems like that having two official APIs, one in C and one in C++. Why not have an official rust, haskell one. Just have the C API. Not C++ API that is not as official as the C API, but similar to rust.

AR: Could argue that C++ is on the same level as Rust. Not sure about how that works with the standard.

AR: One advantage of C++ one is that the interface is easier to read. C++ one looks like this. Boilerplate to define vectors. Class that defines Egnine. Class that define Store. Store is an isolated Store, every object is tied to a store. Each store is tied to a thread. Similar to isolate in v8. You can use threads but you have to create separate stores for each thread. There are types (globals, functions, tables, memories). There are Values. Tried to anticipate reference types, makes it a bit trickier to handle API. You can only move reference type, not copy or assign. Tricky to get right in C API.

AR: [Module] So these look more or less like what you expect from the JS API. I recently added a share() function to give a way to share a module between threads without having to serialize them. V8 serializes in this case.

BT: You can now share the modules in v8.

AR: Also has functions, instances, and other types you expect. C API follows the same structure but has super verbose names. For modules, there’s wasm_module_t, all the modules have functions instead of methods.

AR: That’s roughly it. Prototype implementation on top of v8. Some things you can’t do, to call a function you have to go through JS. Prevents being able to use int64. But other than that, things are mostly functional.

AR: A few TODOs. One main thing that came out of discussion w/ Luke. When you call a function you have to allocate some stuff; this already supports multi-return. Might want to change the API so you don’t have to allocate. You always know the types, so you could stack allocate the return values and pass them in.

AR: Any questions? Should this be a stage 0 proposal?

LW: Do you imagine this as an appendix to the standard?

AR: I would assume this is on the same level as the JS API. We would want a separate document for the C and C++ APIs.

JP: What about iterating as a community API before it becomes a standard?

AR: It’s part of the proposal process anyway.

JP: I mean iterating for several years, what works what doesn’t work.

JF: I think this could be ready in a month if we really wanted to.

AR: One reason I don’t want to iterate for years is that clients want to use it now. They want it to be something more solid.

KM: At least historically there is a strong binary API constraint. It would have to be binary compatible.

JF: I think it’s critical to have opaque objects, if you want to have any hope that Apple would ship.

BT: I think the main risk here is future compatibility with future features. And also making sure there isn’t much overhead. I think the functionality is there.

AR: I can imagine that the C API is a bit easier to standardize. It is relying on fewer features. Tried to stick to C++11 to make it easier. It might be nice to use C++17 variants, but then there are the question of exceptions. Some C++ libraries immediately locks you in to certain features. Makes it harder to agree. For C API it is relatively canonical.

LW: Main question to have experimentation is one where the ownership is clear. Make sure that it is a fast API with opaque types.

AR: Started working on this today. Use plain arrays everywhere the type is understood.

BT: One thing I want to ask: sharing memory between C++ and wasm. The embedded wasm memory is hidden state. Being able to map things into wasm memory, that may be something we want to consider. Similar to host bindings, we want to do one layer of unwrapping. We may want something similar for passing across the wasm boundary.

AR: You mean direct access to the wasm heap.

BT: The embedding host has access to the entire address space which has access to the wasm memory inside, so you could share a pointer out from the wasm memory, but wasm can’t access pointers inside the wasm module.

JF: That’s the same as the JS API right?

BT: More like host bindings, convert the types.

AR: The memory buffer class allows you to have direct access to the underlying buffer. So you don’t have memory safety. Defining a shared memory model will be tricky. Probably should not be to formalize this.

JF: I just think it should be possible to do.

AR: I guess what Ben suggested is something like host bindings on top of this. I agree, but I think it would be a separate proposal. This is kind of like the MVP, you can add fancy stuff like that later. Raw functionality is already there. Or should this be there from the beginning?

BT: It may mean that you can simplify things later; pointers into wasm memory etc.

AR: There are a couple of interesting questions for integration: one thing you would like for functions is to call them with their C types directly. Right now you pass in a array of val structs. You can do template magic to do wrapping around that to convert direct C types into val, but it would still go through val struct interface. You cannot type it…

BT: You need to cast it to C++ signature, then you would have API-specific types.

AR: The number of types is infinite, so I don’t know how you would do that with low-level C  API.

[AR, BT - discussing how this may work]

LW: If you think of the C API, then you have a C function and a datum. Then the engine creates a stub that can be handed back and cast to the correct type and called directly.

AR: What about return types?

LW: That might be tricky.

AR: Can’t be implemented in C.

LW: JIT can do it by creating machine code.

JG: You could do a vararg function with a format string perhaps.

[discussion about forwarding C types to wasm]

JF: You can see how this works with [the implementation I made](https://bugs.webkit.org/show_bug.cgi?id=181262).

Poll: Accept for stage 0

[unanimous consent]

BS: Move into WebAssembly GH? [yes]

AR: Any issues having v8 implementation in there?

JF: Now, it’s just an example so that should be OK.

### Closure
"
wasi/2019/WASI-10-24.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the October 24 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: October 24, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. WASI and OCap
         1. https://github.com/WebAssembly/WASI/issues/109#issuecomment-541191297
         1. https://github.com/WebAssembly/WASI/pull/69
    1. ""Handle"" terminology
         1. https://github.com/WebAssembly/WASI/issues/62
         1. https://github.com/WebAssembly/WASI/pull/117
    1. Quick ping on reordering `clockid_t` values
         1. https://github.com/WebAssembly/WASI/pull/112/files
    1. Modularization update
         1. https://github.com/WebAssembly/WASI/pull/98
         1. https://github.com/WebAssembly/WASI/issues/2
    1. Some good first issues
         1. Make __wasi_linkcount_t 64-bit
             1. https://github.com/WebAssembly/WASI/issues/70
         1. Incorrect size returned by __wasi_environ_sizes_get
             1. https://github.com/WebAssembly/WASI/issues/27
         1. Make clocks/random into capabilities
             1. https://github.com/WebAssembly/WASI/issues/118
             1. Should random continue to be `random_get`, or should it become
                `fd_read` from a special stream?

1. Closure

## Meeting Notes

Attendees:

Dan Gohman
Mark Miller
Mark McCaskey
Pat Hickey
Barbara Nichols
Andrew Brown
Peter Huene
Artur Jamro
Till Schneidereit
Luke Wagner
Yury Delendik
Alon Zakai
Alex Crichton
Aaron Turner
Jacob Gravelle
Wvo
Sam Clegg

Meeting notes:

Dan: First discussion is WASI and OCAP. We have Mark Miller here. First off, what does OCAP mean and why is it interesting, and second what do we want to do. Mark can you please talk about what fine grained OCAP means.

Mark: We have to distinguish two forms of fine grain. What is the unit of computation being protected, and what is the nature of a permission that can be separately reified (turned into something that can be passed around). Wasm has a coarse-grained unit of protected computation - a wasm module instance. It has a flat address space (two: memory for data, and functions, are separate). All toolchains are currently built around the assumption that all Wasm modules that are linked together share a memory and function table. I’ll introduce the term “compartment” for all Wasm instances that share those address spaces. Inside that compartment, all computations inside are vulnerable to all other computations inside. We’ll eventually address that better with the GC proposal but thats a way out and we wont address it further in this conversation.
The other issue is what is the unit of passable permission. Thats permission to access outside resources and also for units of computation to effect each other. We’ll assume that there are a set of separate compartments that are units of protection - their only initial relationship is through imported and exported functions. As far as the Wasm mechanism is concerned, import functions between compartments are a perfect OCAP protection mechanism. (details this by example)
Currently the only things that Wasm can pass over function interfaces are numbers (ints and floats). As a result the permissions communicated between compartments are only communicated statically - you can't pass them dynamically once compartments are linked. So you can convey permission at whatever fine-grain you want by having many different exported functions. You can use procedural abstraction to attenuate permissions, e.g. you can use a function to provide an abstraction of a read-write file as an append-only file.

Dan: I want to temporarily ignore address spaces and tables: in a world where we have references, does it make sense to talk about compartments still?

Mark: Current Wasm architecture plus references still has flat address spaces - our current toolchains push us into it, there will still be multiple module instances linked together sharing address spaces.

Dan: I’m trying to hypothetically see if we take address spaces out of the situation and have wasm gc everywhere, are compartments still relevant?

Mark: In that hypothetical the Wasm module can use the memory and table space as empty, and Wasm becomes a fine-grained object capability machine.

Dan: The question that came up on github is that we currently are trying to do much finer grained permissions than the function level.

Mark: Yes in the hypothetical GC situation you have capabilities that are fine grained at the level of the objects in your programming language

Dan: How do we bridge the gap between the situation we have now, with these compartments and the failures of granularity associated with that, and where we want to be with GC with finer grained permissions.

Till: What about the host?  (I didn’t follow this close enough for good note taking)

Mark: There are OCAP languages and operating systems, and research on running OCAP languages on a OCAP operating system with a bridge between the language’s idea of capabilities and the operating system - when you’re writing in the language its as if the operating system’s view of capabilities are just ordinary programming language capabilities.

Mark: If you design that all interfaces between compartments are designed around reference types, the inter-compartment protocols that are natural to future GC based compartments.

Mark: Even with reference types, the notion of a virtualizable capability is the natural way to express capabilities in the 

In the Wasm GC machine there’s support for both virtualizable and abstract datatype capabilities, theres no penalty for virtualizable capabilities and its quite natural. In the current world the only way cross-compartment is abstract datatype capabilities. That’s going to be an impedance mismatch.

Dan: I’d like to steer this back towards what do we do with WASI right now for languages that don't have GC or reference types. Its going to be a long term problem because we’re going to have C/C++ forever. How can we deal with an integer based approach that can approximate reference types in a useful way, at the penalty of being coarser grained?

Mark: Let’s take very basic C++ as the representative (worst) case. There’s two approaches: one is the approach the Cheri team (University of Cambridge) has taken, they’ve added reference types to existing RISC machine architectures as additional instructions and registers and used that to put protection boundaries inside existing C/C++ code. They built a compiler and LLVM fork that can run in two modes: one mode every C++ pointer is turned into a Cheri capability, at which point you’re treating the Cheri hardware like we’d eventaully do Wasm GC.

Dan: In Cheri pointers are still bit patterns right?

Mark: Sort of, in the other compilation mode: in that mode the pointers are still bit patterns that are readable, but the capability gives you a range of addressable memory (which is potentially very fine grained) that is valid to dereference. This is expensive and not really what we’re doing with Wasm GC.

(at this point i lost the ability to follow and take good notes)

Dan: Any solution that involves users annotating their source code is going to get a lot of resistance from our users. Any solution where capabilities are held on by a side table and theres bit patterns in the wasm, is better for C compatibility but not the best for actually doing OCAP. Cheri is cool but it doesn't magically solve our problems here yet.

Mark: A completely different way to approach this issue: Let’s say all your inter-compartment capability interfaces are defined in an IDL, and then we can generate (like capnp) bindings to particular non-capability-based ABIs, so only the code generated from the IDL directly handles the reference types and does the context switch between compartments. All of the C code just uses the C ABI bindings generated by the IDL. Those ABI  bindings use integers that require the capabilities be looked up from tables

Till: A lot of this is actively in the works as the interface types proposal. A lot of these concerns are actively being addressed by how WASI and interface types are developing. The biggest thing is that moving capabilities from being expressed as integers to references, and all compartment interfaces are in terms of reference. Inside a compartment you can do whatever you like.

Dan: We have an IDL now where we’re moving to talk about APIs in terms of references. At the WASI level we should design in references using OCAP.

Jacob: In the interface types polyfill we have a way to automate the side-table translation so you don’t have to even generate glue code, its just done in javascript (the host) for you. You can add an interface instruction to convert an index into a ref. This lets us use C without annotations beyond the toolchain knowing about interface types.

Dan: Next topic: there's a virtualization doc that is coming along, and a paper
http://www.cs.cmu.edu/~aldrich/papers/ecoop17modules.pdf
(summarizes part of paper in way I couldnt follow for notes)

Dan: Mark’s idea of virtualizatbility is an object with vtables inside them.
(more discussion of the paper)

Mark: I’ll have to read the paper to understand this fully.

http://www.cs.cmu.edu/~aldrich/papers/ecoop17modules.pdf

Mark: Just followed the link, I know this paper. The language in the paper is fine-grained OCAP, individual objects are vtable-like. In that language, there’s still an issue of how you start the world off - a static configuration with good safety properties so you can move forward with dynamic properties. This paper is about the initial permissions with least-authority linkage between the modules. It is in the context of a dynamic system with full fine-grained virtualizability. I don’t see exactly how that addresses our Wasm representation problem, we still cant use references as fine-grained virtualizable capabilities.

Dan: I think we should table and continue this discussion at a different time. I’d like to go to the rest of the agenda for the remaining 15 mins.

Dan: What do we call handles, or descriptors? PR 117, or the last comments on issue 62 on file descriptors vs handles. POSIX has called things file descriptors when they're not really files. I want to talk about OCAP capabilities as handles.

Mark: Historically, descriptors and capabilities are aligned, and the numbers you are familiar with as file descriptors are often just called indices, so clists are the list of capabilities and clist indices are the file descriptor ints you know.

Dan: We settled more or less on Handle as an identifier that refers to a capability. When we say handles we’re just saying the OCAP sense. Does that make sense?

Mark: Yes!

Dan: Let’s call that a decision then.

Dan: Witx files are up in the repos, you can make a PR into the ephemeral phase and we can then promote that to unstable when a decent number are landed and move on to implementing it.


Dan: Moving on to the modularization update: look at PR 98 for the basic change. This wont be the end of the story for modularization, but its a logical first step.

Sam: Does this change the import field name strings?

Dan: Yes, right now “wasi\_unstable” is the module name everything imports from. 

Sam: Yes I see that there are N different modules. 

Dan: Does it make sense to limit witx to one module per file? Wat only allows one module per file.

Pat: We have to figure out how to deal with type names being global, we’ll need some sort of namespacing and import mechanism.

Dan: Ok, we’ll figure that out and move forward.

Dan: I put some basic issues in the agenda that are hopefully straightforward to implement. I’d like to encourage more people to step in and make PRs on the witx files and get involved.

Dan: for example on the issue about using capabilities for randomness, we can propose solutions with PRs that change the witx.
"
wasi/2021/WASI-03-25.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the March 25 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: March 25, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Lin Clark
    - Email: lclark@fastly.com

### Registration

None required if you've attended before. Email Lin Clark to sign up if it's your first time. 

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Better OS-agnosticism with I/O Types (Dan Gohman) ([slides] [html files])

[slides]: presentations/2021-03-25-gohman-io-types.pdf
[html files]: presentations/2021-03-25-gohman-io-types/index.html

## Notes
### Attendees
- Lin Clark
- Till Schneidereit
- Andrew Brown
- Matt Butcher
- Radu Matei
- Luke Wagner
- Dan Gohman
- Peter Huene
- Ralph Squillace
- Piotr Sikora
- Mark McCaskey
- Mingqiu Sun
- Yong He
- Pat Hickey
- Sam Clegg
- David Piepgrass
- Jonnie Birch
- Brian Hardock

**Dan Gohman:** Quick introduction to concepts. 

Wasm itself: how is it different than assembly. In Wasm, foundational concept is the module. This is in contrast to modern OSs, which build on processes. All the IO in Wasm goes through imports and exports, rather than scanning through binary to find syscalls. No sneaky ways to get a syscall in. And Wasm is typed.

One of the big things is that makes Wasm good for virtualization. If you’re a wasm app and talking to a host, don’t know whether a module is a host api or a virtualization of it. These virtualization layers have all info.

One of the things this leads to is shared nothing linking, having linked instances together without linking address spaces together, so they dont’ share data directly but can still call each other. You can use calls as a lightweight IPC mechanism. Great for virtualization because we can virtualize calls in a way that’s hard otherwise.

How does an app pass file or any kind of data from one platform to another. Where should I put the file? What conventions does the host have? Same for networking. In order to transfer data, need to know a lot about the env you’re in. So this exposes a lot of info about hosts to applications.

Next big picture concept: data vs metadata. Data is the contents. Metadata is things like inode, filename, etc. This distinction leads to a broader dichotomy between compute and metacompute. Compute is what computers are for, in the literal sense. Metacompute is what you do to enable that—managing access, organizing files. Compute juse does math, data structures, algos, etc. So they are the most independent from host.

Last big idea. POSIX is dynamically typed. If input to a file happens to be a file, then you can do lseek. If it’s a pipe, then lseek will fail. It exposes what kind of thing the data comes from. This brings along some metadata concerns into the compute on the data. Let’s use our static type system to make the most of what Wasm gives us.

All these bg concepts lead us to a place called I/O Types. Part of a larger idea called Wasm-native I/O. POSIX bakes in a lot of assumptions about how the system is set up.

What is an I/O type. A type in the type system. Abstraction for a common I/O pattern. Abstracts away actual data from how the data gets there, how is it stored, etc.

Want to lay out a few simple examples.

i/o streams: They have reliable in order delivery of bytes. TCP streams are the archetype. IT may give us a stream of T. I’ve prototyped this in a library. Major ops are read and write. We also add skip, like read but discards data. Write_zeros, flush. Media_type: sometimes useful info from file name. We can provide string for this without exposing the whole filename. Pseudonym: You give it a stream and it gives you an opaque handle that contains the name.  Forward: combine read from one input and write to another. This allows to copy from input to output without copying into the instance. Will be able to construct from an I/O Array.

I/O Arrays: dynamic arrays of bytes, like a Vec in Rust or C++. Not living in linera memory. Examples, device memory, files. Files are tricky because seem to be both streams and arrays. Prototype of this as well. Read_at and write_at is like pread. Advise: inform system of use case, like sequential access. Similar to I/O streams with media_type, pseudonym, etc. Copy is similar to forward in I/O streams.

One of the ways that you’ll get these types is using typed main. System can convert passed in files to streams or arrays. Programs that do this don’t care about the network stack, local address of the machine. Lots of things that we don’t have to care about. Typed main and I/O types avoids all of these complicated issues. The name of the program isn’t the relevant part. Just focus on compute, which we can make quite portable.

We do have some differences to POSIX. Can depend on multiple return values. Instead of int return, can report succeeding partially along with error. 

For error types, POSIX has a lot of errno codes. Applications themselves usually don’t care about exactly how it failed. Bubble up to the user. Often the reason why something fails reveals info about the host. FOr us, in many cases, errors will be simple success or failure. We can use opaque handle to pass back up to Wasm env which can be logged to a file, but hide from application itself. This helps with virtualization. Doesn’t need to simulate what kind of error would have occurred. 

Wasm doesn’t have signals, and seems like we won’t add them. So we don’t need to have a concept of being interrupted.

Big picture: not going to think of it as file or socket api, so not going to expose some of the weirder details.

POSIX also has concepts of read and write being atomic, but that’s poorly understood. Hard to decide from low level of read call whether it should be atomic. Instead, we want to introduce things like atomic files for things like config files. 

Of course WASI already has wasi-filesystem, and wasi-sockets is underway. Relationship we expect is peers to wasi-io. One of the really interesting things is io types takes pressure off of filesystem to provide quite as much portability. For systems that want to have this level of non-determinism and port, use IO types. For other, less portable things, use wasi-filesystem. Wasi-filesystem can then be less aggressive about portability.

Some use cases will always want to know they’re talking to a file or socket. Some use cases will always want to specialize on that level. Some hosts won’t support all that functionality. Libraries can decide which they need and where they can run.

Any questions?

Let’s go more in depth.

Are files streams or arrays? Both, done with a single handle in POSIX. In IO Types, we want to have separate handles. Is lseek a stream or array operation? Both, kind of a bridge in a very subtle way. In IO Types, we can emulate lseek. The fd would have the handles for both the stream and the array. This way, can do lseek in userspace?

What about directories? Some apps want to iterate through directories. Want to avoid exposing names and that’s how dirs usual work. Instead, in IO Types, planning stream of lazy streams. Can check things like media_type to figure out if it wants to open, and then lazily open and it will give either a stream or array.

How does this relate to write once, run anywhere?

We’re starting with focusing on compute and abstracting the metacompute. Not focusing on the whole application. We can think about simpler applications for now and expand out from there. Instead of making whole app portable, growing the portable core and push metacompute to the boundaries. Won’t have business logic mixed in with thinking about how the filesystem works.

What about compat?

Going to have capability to program to IO Types directly, but also important to apply to existing APIs. We can build libc types on top of IO Types. Going to be a way for code that’s already somewhat portable to easily port. This work hasn’t started yet. Idea is that we’d have two different libcs. Do I want to use libc backed by filesystem or by IO Types?

Zero copy is something I get asked about a lot. Want to talk about how we think about that. Forward, skip, write_zeros, etc are examples. Worth mentioning that read is not zero copy. Zero copy for read means shared memory. That means you need to have a protocol on top of that memory. When we add that on, then it’s not very virtualizable. Possible that we’ll introduce zero-copy read in the future with changes to Wasm core, but for now don’t really need it for many use cases, but can instead use things like forward.

**Sam Clegg:** What about avoiding linear memory all together and allowing read to return slices to others memory? Then you could have an object that points to kernel memory.

**Dan Gohman:** Yeah, that’s a cool idea. I think we’d need to add things to core Wasm for that. 

**Sam Clegg:** And GC would probably come in.

**Dan Gohman:** Some considerations there, but certainly something that we can think about. If wasm wants to go in direction of views, then WASI will go there too.

Async will be handled by Wasm CG. IO Types are about semantics of the IO and how its abstracted. Independent of how we wait for things to happen. Wasm stack switching subgroup will lead that work.

Data parallelism, don’t have time for that.

Hints of things to come:
- Vectored IO. Optimistic that IT can help with this
- Multiplexed connections, like QUIC. Maybe makes sense to have an abstraction on that
- IO Windows. Network engineers think in this way
- Interactive streams. IO Streams are unidirectional. Interactive is likely a different set of APIs
- Text streams is something I care a lot about. Rule out things like control codes.
- Terminal IO
- A way to do fsync and fdatasync. 

**Matt Butcher:** What can we do to help?

**Dan Gohman:** wasi-io, trying to define witx files for these. Once we have this is to take a look at these interfaces and the backing prototypes. Try to use them in an application. File issues in wasi-io repo. That will be a place for open ended discussions. If you want to talk about these things in Discord, or BA Zulip. Reach out and lets talk about things we can do

Are there other patterns we can identify? What are the categories we can make

**Sam Clegg:** You mentioned dont’ want to deal with complexity of platform differences. Where does that complexity end up?

**Dan Gohman:** Some of it is in the host system. And some of it is pushing it out to outer parts of the program. Inner modules might be pure compute, with outer modules using wasi-filesystem. General theme is pushing that all the way out, to either those outer modules or the host.

**Matt Butcher:** Wanted to give unambiguous feedback that we’re really excited and that you’ve hit on an abstraction that we think is really workable.
"
wasi/2023/WASI-06-15.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: June 15 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: June 15, 16:00-17:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Presentation on [wasi-sockets](https://github.com/WebAssembly/wasi-sockets) by @badeend, XX mins
    1. Vote: Advance [wasi-sockets](https://github.com/WebAssembly/wasi-sockets) to phase 2
    2. Discussion: Where should wasi-cloud-core implementations live? by @danbugs

## Notes
### Attendees
- Lin Clark
- Dave Bakker
- Chris Woods
- Kyle Brown
- Danilo (Dan) Chiarlone / @danbugs
- Jiaxiao (Joe) Zhou
- Jamey Sharp
- Joel Dice
- Antoni Bofarull
- Ivan Font
- Zalim Bashorov
- Eduardo Rodrigues

#### wasi-sockets

##### Presentation on wasi-sockets by Dave Bakker

**Dave Bakker:** README On github out of date, please don’t look there. Will update it soon. Client and server. No ambient authority on all platforms. POSIX compatible layer should be built on top. Component model is not POSIX compatible so, need that layering.

Non-goals, to clarify. Low level TCP and UDP sockets. Have had some issues openned over time for higher level support of stuff. That’s not really in scope. Really should enable network access. HTTPS not in scope, retrieving other network info like installed network interfaces, etc. 

I thought I’d start with how a TCP client would look from the consumer side. Client, from client perspective, you get network handle which is mostly just an opaque resource that reps some kind of network access. In raw POSIX impl, there is no general file descriptor from which you can derive more specific resources. No root handle in POSIX (e.g. like filesystem dir), so I invented it. The idea is that there’s one default network specified. In future, a component may get passed down multiple network handles. Ex: one that can only access database, or one that can only access a specific domain… any kind of firewalling.

This function, called instance network, is IIRC a temporary function. It’s there just as a placeholder for value imports at component model level. At moment, just one method which … the network. In future, might be multiple networks with own slice. Network is mostly virtual. Does not need to map to physical network interfaces. 

**Chris Woods:** Is it meant to rep a network interface?

**Dave Bakker:** it may

**Chris Woods:** Physical or virtual, it’s a network interface? 

**Dave Bakker:** At this moment there’s just one, but maybe in the future maybe component can declare multiple requirements

**Chris Woods:** So in future thinking there might be a negotiation?

**Dave Bakker:** Might be, they don't’ have to be declared statically.

**Chris Woods:** For now, I have my network handle, what happens next?

**Dave Bakker:** Now we move on. Next on the client. Resolve the domain name of party connecting to. This iss provided by the IP lookup interface. This interface provides domain name lookup, not just specific to DNS. Rather than returning a list sync, the resolve addresses func returns an async stream which can be iterated on. Goal is for it to be a proper CM stream so these methods (resolve-next-address, drop-resolve-address-stream) wouldn’t be necessary anymore. But for now, I’ve stubbed it out to a manual impl of what CM will provide. So we request domain lookup, iterates over each result, then drop these resolve stream. At this moment, the addresses will contain all the results of resolve stream. For brevity, assumed this will all be magically ready without await, but could subscribe to async events using wasi-poll. 

Next step: set up actual socket. Creating socket without capability handle… this means that when creating a socket initially, this socket is just an in-mem config object. This was done to increase POSIX compat. At moment of creating a socket, no need for POSIX compat layer to know which network to bind to. So you create a socket, in this case IPv6, and options inc set-keep-alive. Create a socket, you can configure any way you want. Up til this moment, the network handle hasn’t been necessary yet… up to the moment where we actually want to use the network. Then need to bind to a specific network. In initial version, only 1 network handle which the libc can use as the default, but in a world where there are multiple, libc might iterate and figure out which is most appropriate network handle. Might be from address it’s going to connect to, IP address range, etc.

Connect method is async, so we can await in the future. Connect method returns send and receive stream from wasi-io-streams proposal. Another diff from BSD, where socket desc is both input and output stream. Assuming the connection succeeds, we send some data using streams proposal. A TCP socket can be shut down, preferably shut down is implicit when ending send and receive stream. Since they aren’t really available yet, for now manually call the methods. So we write some data for the server we shut down for sending, then we read, then we shut down read. Then drop all of our resources. 

Any questions?

**Jamey Sharp:** Do you have a UDP example as well?

**Dave Bakker:** If you want I can go over the specs.

**Jamey Sharp:** Curious, but don’t want to interrupt.

**Dave Bakker:** Don’t have an example from usage perspective, but will be similar. Main difference that UDP connect doesn’t return streams that can be written to.

**Chris Woods:** I have a more approach question. When we look at WASI in general, we can define interfaces for things like HTTPS, etc. Defining a socket level WASI interface. For me, the main reason is to support legacy software. Then having POSIX support becomes pretty important. I know there’s plan for compat layer. Is this a case of here’s a list of POSIX functions we need to support, because I’m looking at what’s the value in the proposal. What’s your vision on that approach… just looking at the delta?

**Dave Bakker:** Expect that applications running in WASI will mostly interact with streams. Everything else is for providing POSIX compat. 

**Chris Woods:** …

**Dave Bakker:** The way I view, proposal is a blend between POSIX compat using component model primitives. So the fact that the socket doesn’t have a send method itself, that is to use the component model primitive to best advantage. 

**Chris Woods:** So as part of the proposal output, you’re going to do a GAP analysis? Is that part of the proposal?

**Dave Bakker:** Not at this moment. It hasn’t been written down, but 80% of the POSIX spec is implementable with this proposal. Weeds of socket options becomes a portability problem. So we can’t guarantee that every option will be provided. But the main stuff: sendto, send message, peer name, all the basic stuff should be implmentable. 

**Chris Woods:** And on the change between get ops and set ops bit. What’s advantage of calling them out in individual functions?

**Dave Bakker:** They aren’t actually ints in each case, and that’s not really implmentable in wit.

**Dan Gohman:** I would also characterize it as a virtualization limitation. If you have intermediaries, it’s good to have type for forwarding. 

**Chris Woods:** Yeah, I get it. We need to think about API design, why would you do that in POSIX, you don’t know what values you have in advance. Able to make a change without an interface change, so don’t need to update WASI standard.

**Dan Gohman:** Useful to point out that that would be a new WASI standard. There’s no shortcut around that.

**Kyle Brown:** We do have a flags type in wit, for things that have something on or off. Instead of passing int, could be flag type. Subtype related upgrading. 

**Chris Woods:** That makes sense. I’m thinking about practicality of supporting legacy code. Thinking out loud, so I could be wrong. 

**Dan Gohman:** You’d call to libc which would have POSIX interface, so you’d get ENOSYS etc. 

**Chris Woods:** Or you’d get an error.

**Dan Gohman:** You as the programmer wouldn’t get that because libc would handle for you 

**Dave Bakker:** Also not all options are bools. Then you’d have to defer to having massive variant.

**Chris Woods:** So libc is going to be repackaging the message. Ok, thanks for doing the dive on that.

**Dave Bakker:** Any other questions?

**Jamey Sharp:** UDP, I assume you don't’ want sendto where you can have message and recipient in one call. 

**Dave Bakker:** OK to park that question?

**Jamey Sharp:** Sure

**Dave Bakker:** Let me go through server. Network handle that can instantiate TCP listeners. Set some network options. Set the backlog of the listen queue or accept queue. Has been split into socket option, so split what is effectively a duality of the native listen call. On some platforms, transitions to listen state and sets backlog state. So that has been split out in WASI side into backlog size option and the listen method. The socket option is updatable over time. 

**Dan Gohman:** Should point out that listen once is a portability thing.

**Dave Bakker:** Right, updating listen backlog not supported on all platforms. 

**Dan Gohman:** Want to make sure that distinguish between CM constraints and portability constraints.

**Dave Bakker:** So socket is set up, time to bind to local address on specific network. Deferred until last possible moment, bind method. Then we transition to a listener state. Then accept new client sockets, which is async. Accept returns output and input stream. 

Questions?

**Dan Gohman:** Requirement around significant runtimes? Maybe should add some of those as acceptance criteria. That would largely cover POSIX compat. Would that make sense?

**Chris Woods:** That would make perfect sense. 

**Lin Clark:** May want to have a limit to significant runtimes.

**Dan Gohman:** Subtlety that we say POSIX, but we dont’ really mean that because POSIX means so many different things. Rust probably makes sense.

**Lin Clark:** Python seems like another good option. 

**Joel Dice:** uses wasi-libc

**Dan Gohman:** That’s fine, as long as we support the portable set of functionality in Python, that’s enough o show that it’s doing what it’s supposed to do.

**Dave Bakker:** I’ve done an inventory. Very quick to see what are generally supported.

**Dan Gohman:** That’s awesome, thanks for doing this. 

#### Vote: Advance wasi-sockets to phase 2

Decision to postpone until acceptance criteria is modified to reflect the requirement around significant runtimes.

#### Discussion: Where should wasi-cloud-core implementations live? by @danbugs

**Dan Chiarlone:** Shared a document in the chat. Big point is to discuss where wasi-cloud-core impls should live. Different from impls that make sense to be in runtime. For cloud-core, might be cloud specific. Want to avoid duplicating code. 

**Lin Clark:** Does charter allow for this?

**Dan Gohman:** If it’s a virtualization, then the CG should own it. But for other impls, probably not a WASI concern

**Luke Wagner:** That makes sense to me too.

**Dan Gohman:** Yeah, wasi’s not a great place for maintaining software, so I think these would live outside. We may impl these on top of wasi-sockets, 

**Kyle Brown:** At that point, less of a question of wasi.

**Dan Chiarlone:** Ok, will bring up in another venue.
"
main/2020/CG-01-21.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 21st video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: January 21st, 5pm-6pm UTC (January 21st, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. [Poll for approval of the proposed semantics for atomic operations on unshared memory ](https://github.com/WebAssembly/threads/pull/147)
    1. [Discussion (and, ideally, poll for approval) of higher memory limit ](https://github.com/WebAssembly/spec/issues/1116)
    1. [Discussion: require design rationale for proposals](https://github.com/WebAssembly/meetings/issues/481)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees
Thomas Lively

Rick

Paul Dworzanski

Ben Smith

Deepti Gandluri

Sam Clegg

Adam Klein

Alex Chrichton

Peter Jensen

Ingvar Stepanyan

Conrad Watt

Azakai

Zho An Ng

Francis McCabe

Ryan Hunt

Yury Delendik

Ross Tate

JP Sugarbroad

Derek Schuff

Lars Hansen

Nabeel Al-Shamma

Jakob Kummerow

Richard Winterton

Emanuel Zeigler

Heejin Ahn

Keith Miller

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Thomas Lively seconds.

### Proposals and discussions

#### Review of action items from prior meeting.

None.

#### [Poll for approval of the proposed semantics for atomic operations on unshared memory](https://github.com/WebAssembly/threads/pull/147)

TL: Summary of what happened there at the last meeting. Posted into [chat](https://github.com/WebAssembly/threads/issues/144#issuecomment-553024481). I posted that after we talked about it last in the meeting. There was a loose consensus that we should adopt a particular semantics for wait on unshared memories. That is not a radical change, just matches what JS Atomics.wait does. Trap whenever it is executed on shared memory. I have a [PR that is linked to from the agenda](https://github.com/WebAssembly/threads/pull/147) this PR is updating the spec text in the threads repo for the new semantics. Since we have never taken a vote, we should do that now. I'm looking for a go/no-go consensus vote for the semantics in that PR.

Specifically, wait will trap unconditionally when executed with unshared memories. And notify will return 0 for unshared memories. If that sounds good to everyone, great. If people have concerns, let's discuss.

DG: Do you think we need a poll for having atomic operations for unshared memory?

TL: It was clear consensus that we should do that. I'd like to frame this poll on the PR in general. It also includes RMW, read/write atomic operations too.

DG: The poll here is to allow all atomic operations on unshared memory. wait will trap, notify will return 0. Any objections are more discussion?


| SF | F | N | A | SA |
|--|-|-|-|--|
| 1 | 10 | 7 | 0 | 0 |

poll passes.

#### [Discussion (and, ideally, poll for approval) of higher memory limit ](https://github.com/WebAssembly/spec/issues/1116)

JK: I don't have slides. proposal seems straightforward. Currently says that memory must be initially or growable to 2gig. We have requests from partners to push that to 4gig.

Our implementation supports a higher memory limit, but we would like to do this in conjunction with the spec. 

I've filed an issue for that, put it in the chat. Any reasons not to do that.

KM: I thought the limits were standardized and recommended, but not mandatory. Is that true?

JK: My reading is that they are mandatory, specifically for the JS API.

LH: My interpretation as well that they are mandatory.

SC: There are some limits that are not mandatory, like maximum function limit.

BS: My interpretation was limits in JS API are mandatory, and standardized across browsers

JK: Allocating 2G is not guaranteed to happen anyway, so in that sense bumping the limit doesn't fundamentally change anything.

LH: You have customers that will request 4G on 64bit applications, and that is likely to succeed.

JK: If that application requires that much, then it will happen, perhaps if it grows to that size.

DG: Is there an interim limit to make progress.

KM: Would it be reasonable if we had a lower minimum size that may not exceed, but the maximum could exceed.

LH: We have an internal limit that is 2G, and will be hard to change. So we don't want to be incompatible.

KM: You're concerned they will have a minimum size that's too large, and then it won't load at all. But it's possible that it will start with a small size, then grow to 4G immediately.

NA: Hello, I'm from adobe. Our applications have files w/ caches. Sometimes stored on disk or other files. The ability to access more memory is performance enhancements, we run better with more memory.

DS: Another thing we've heard is that people that have apps already working, so they want more memory to support larger files.


LH: There could be code out there currently that doesn't work with 3G.

LH: Not currently against this, but concerned that there will be fundamentally incompatible applications on the web.

JS: It's clear that this was intended that an embedder could have less than 32767 pages, so an embedder that couldn't support that would be incompatible right? 

KM: On the web in particular, there are difficulties, if it works in one place then they ship it as is, and we get complaints with browser A supporting & B not supporting 

JP: Would it satisfy to allow the maximum number to increase? [JK: yes] Then you don't have to deal with instantiation problems. 

LH: I don’t know what the minimum limit has to do with anything

JP: Not minimum, but just the initial

LH: I could live with that.

#### [Discussion: require design rationale for proposals](https://github.com/WebAssembly/meetings/issues/481)

BS: this a a suggestion ffrom a new person to wasm, who noted that there’s a lot of info spread out across repos and in the heads of the participants, so it can be hard for new people to understand why choices were made. They suggested that (similar to some tof the MVP rationale docs, which were really helpful for udnerstanding howthe choices were made) that we should have something similar for proposals. We have something similar with explainers, but it doesn’t have the same level of detail.

BS: Wiuth some of the explainers, it’s clear we want to say X, Y, Z, I”S this something we want to put on the Proposal owners? Nothing concrete, but would like to start a discussion

FM: I’d like to strongly endorse this. I”ve been making a similar doc with the interface types proposal, where we structure the doc between the technical spec, a set of examples, and what I call “choices” that just describes how we made the major decisions. It’s very important for people coming from outside.

TL: I also think it’s a good idea to express rationale in a clear rationale document. I don’t know the direction is where we require this in phases.md as a hard requirement for all proposals, it could get stale where we add a rationale but it’s not updated. Setting a mandate might not always work - should this be more of a cultural change? How much detail is too much detail?

BS: it might be like where we suggest that people write an overview with some rationale is a good place to start.

FM: It's not just one document. Some bigger proposals will need more than one of these. For example in IT I”ve been drafting one on webIDL. To explain to someone knew why we chose one thing over another, focusing on one particular topic. GC will have this too, where there are several different issues that need explaining. I wouldn’t mandate it with legislation that requires it, but it should be included.

FM: Examples are also important, more people usually learn from examples

JP: It would be beneficial about people working on this proposal, in general it would be good for people to flesh out what the general goals and design rationales of a particular proposal are

TL: this is sort of like having an FAQ. one of the good outcomes would be that we’d have fewer people coming in and reading the spec, and wondering how we came to a decision and then opening an issue to ask about it. I feel like we’ve seen this for several topics.

JP: The design rationale has a very different quality than an explainer document, it would also be good to write down what the rationale is talking

KM: How many of these proposals were just consensus? I.e. like atomics, but for more contentious issues, it may be good to document them

BS: A lot of the time, we already have that information and searching through all of the meeting notes

KM: at the same time I don’t want to put even more burden on the champions, to not only come to the CG but also copy everything out into this, it’s already a lot fo work.

TL: One thing we can do to lessen the load on proposal champions is to have standardized documents, with Rationale, overview, notable polls etc. Proposals need not follow the exact sructure, but proposals can decide what sections make sense as we decide what components make most sense

RW: How about just linking meeting notes/discussions

RT: For GC, we have the overview, design, requested we have a rationale, I have examples of how this makes a difference - there are a lot more examples that we can go into - another proposal we are trying to figure out why something was done, and the reasons are no longer relevant, but not documented anywhere it helps on both ends of this conversation

BS: so it sounds like in general people are happy with the idea of doing something like this, so the question is how do we make this more concrete? Suggesting that we retroactively go back and do this for previous proposals seems like too much, but adopting it going forward seems feasible and people are already doing it. So we just need to find some common ground on what.

FM: As a concrete suggestion, if the proposal is small, then an FAQ is enough, if it’s a proposal like GC, then it will be too long to have in one document. We can even have a whole directory of files - there’s a role for answering questions, there is an audience there, and for any given proposal we have to figure out where to address it

BS: so perhaps a suggestion here would be to take the proposal howto document, and depending on whether its a big proposal or a small proposal, update the howto with a sample template

FM Agrees

TL: I propose that we make a proposal template directory in the form of standard best practices that we can all agree on

BS: I like it, this could live in the proposals rep

DG: so we have the standard proposal template but it’s not clear that we have a formula for the details (e.g. whether it’s a big or small proposal). Should we take this offline for more discussion?

BS: yeah that sounds good.

### Closure
"
wasi/2024/WASI-02-08.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: February 08 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: February 08 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. _Submit a PR to add your announcement here_
    1. New proposal: wasi-observe
        1. Issue: https://github.com/WebAssembly/WASI/issues/573
        1. Proposal repo: https://github.com/dylibso/wasi-observe
        1. Call for participants: https://github.com/dylibso/wasi-observe/issues/1
        1. Any initial feedback?
        1. Vote: Approve for Phase 1
    1. WASI64
        1. Issue: https://github.com/WebAssembly/WASI/issues/566
        1. Discussion points:
            1. New WASI APIs (`_64` suffix) vs name overloading
            1. New WASI SDK targets
            1. Concerns / Feedback
            1. Next steps
    1. New proposal: wasi-webgpu
        1. Issue: https://github.com/WebAssembly/WASI/issues/578
        1. Proposal repo: https://github.com/MendyBerger/wasi-webgpu
        1. This also includes wasi-graphics-context, wasi-canvas, and wasi-frame-buffer. Discuss if makes sense to seperate them out.
        1. Any initial feedback?
        1. Vote: Approve for Phase 1

## Notes
### Attendees

- Bailey Hayes
- Chris Dickinson
- Colin Murphy
- Dave Bakker
- Quentin Michaud
- Hung-Ying Tai

- Shengdun Wang
- Mike Warres
- Marcin Kolny
- Fedor Smirnov
- Matthew Yacobucci
- Sean Isom
- Sehyo Chang
- Yong He
- Mendy Berger
- Andrew Brown
- Johnnie Birch
- Jiaxiao (Joe) Zhou
- Syrus Akbary
- Zalim Bashorov
- Dan Gohman

### Notes

#### wasi-observe

**Chris Dickinson**: wasi-observe’s goal is to expose an interface to logging and metrics to wasi components. Stories listed in the wasi-observe repo. Whether DataDog or Honeycomb, should be able to integrate. Agnostic if this is implemented by the host or another component. Not opinionated about aggregation. Not opinionated about auto-instrumentation.

**Chris Dickinson**: Initial CFP. Had representatives from Fermyon and Cosmonic including Danielle and Brooks, as well as Walther who is unaffiliated. Other interested parties include Ralph from Microsoft and Ben from Dylibso. Meetings are fortnightly. Current state is that we have a WIT interface from a core module implementation of observability from the observe-SDK from dylibso. We are bringing in the wasi-logging effort. We are working with them to pull that interface in. We are going to build a context resource to anticipate multi-threading.

**Pat Hickey**: Phase 1 vote. Already happening in a private repo and this vote is to move to the WebAssembly org and list in the existing proposals there.

**Pat Hickey**: It doesn’t sound like there are any questions or contention around this one.

 **Pat Hickey**: Universal consensus vote. Any objections?

 **Pat Hickey**: Everybody is in favor. wasi-observe is now Phase 1.

#### WASI64

**Shengdun Wang**: When the API ends, they all assume the pointers and size of 32 bit. So you end up in a situation where you are not able to use WASI API’s in 64 bit. I tried some solutions. I maintain an existing virtual machine, abvm. I think the better solution is to duplicate all of the API’s to 64bit. A duplicate with suffix will not break anything. All of the plugins is trying to assume 32.
Demo implementation: https://github.com/trcrsired/wasi-libc/blob/main/libc-bottom-half/sources/__wasilibc_real.c

This demo uses a 64 bit suffix. 

 **Pat Hickey**: W3C meeting. W3C has a governance rule to protect IP. Sign the CLA. 

 **Pat Hickey**: Second piece of this puzzle in terms of ABI’s and interfaces is WITX. The changes is about WASI Preview 1. This is specified in WITX. This is a 4 year old way of doing things. This group has voted to move on from specifying things in WITX from WASI Preview 1 to WASI Preview 2. We voted to launch WASI Preview 2 in the last meeting. I am not in favor of extending WITX.

**Shengdun Wang**: The problem is that libc is required for this. Libc is a posix like ABI.

 **Pat Hickey**: Today we support libc with the component model adapter. There is work ongoing right now to add component-model support in libc. 

**Marcin**: WASI Preview 1 is 4 years old. Complete migration might not be possible with existing systems. It is not possible right now but not necessarily moving to preview 2 for various reasons. Is there a model here where we can have community level support for some of the features. Is there an option where a particular group can support this feature. Maintaining for the future. We have a business case to use 64.

**Bailey Hayes**: 

 **Pat Hickey**: It’s not about maintaining or contributing. It’s about the maintenance of all new features. It will make it very difficult for new things to develop of the new things that need to be developed on the component model. Increased work for folks are going to add it in this way that the spec is moving towards. I think we disagree on substantial point here. Should we add features to preview 1 or should we maintain focus on preview 2.

**Luke Wagner**: How many different folks are interested in adding to preview 1 in terms of fork and things. 

**Shengdun Wang**: I want to change code just in wasi-libc. Changes are just isolated to wasi-libc.

 **Pat Hickey**: The hosts would have to support it. Splinters support for WASI Hosts.

**Luke Wagner**: What is the quantity of people interested in toolchain and support for WASI Preview 1. 

**Marcin**: My team is dedicated and run a relatively large product on Preview 1. We have to maintain it. Once we migrate to preview 2, we will have no business case to keep maintaining.

**Shengdun Wang**: Preview 2 does not have a plan to support x64.

**Luke Wagner**: Actually that part is really is easy. If the memory index specifying by lifting and lowering.

**Shengdun Wang**: Plugins wouldn’t work. Still must be a suffix.

**Luke Wagner**: Yeah bigger challenge to get the target emitters to target 64. That doesn’t get to the WASI challenges. As far as how the component model can support 64, this is simple. If targets 64 bit then put in the right pointer. This is easy but changing the producer toolchain this fundamental challenge here.

**Marcin**: What is the preview 2 status compared to preview 1. It might take a preview 1 program. Is there a gap between preview 1 and preview 2?

**Marcin**: There is a component adapter that takes in core module and adapts it to preview 2.

 **Pat Hickey**: Joel Dice has work ongoing to do this in wasi-sdk. Less than a quarter away from all of that. This was awaiting the standard. [CD edit: link to the draft PR https://github.com/WebAssembly/wasi-libc/pull/449]

**Luke Wagner**: There is an adapter from preview 1 to preview 2.

**Marcin**: Is there an adapter to go from preview 2 to preview 1?

**Luke Wagner**: Not currently.

**Marcin**: Are there other people like me that are stuck on preview 1 for features like wasm-exception, threads, 64 memories.

**Sean Isom**: For what its worth, I use the preview2 adapter against code from wasi-sdk daily in C++ as part of my toolchain. No issues [CD edit: link to the preview 2 adapter, https://github.com/bytecodealliance/wasmtime/tree/main/crates/wasi-preview1-component-adapter, sean’s docs PR in progress: https://github.com/bytecodealliance/component-docs/pull/66]

**Pat Hickey**: The component model has a path forward for all of those things. Threads is under active development with several engineers. I don’t know the status on exceptions. I know that there are sketches and plans.


**Shengdun Wang**: LLVM is still using the old one. 

**Dan**: Exceptions are orthogonal to this conversation. Preview 1 did not have support for exceptions. The thing we need for exceptions is the standard to stabilize and for someone to write code.

**Pat Hickey**: As far as supporting the 64 bit proposal in the component model. It is imminently implementable. No longer a WASI concern, this is a component model concern.

**Dan**: To be clear about this, WASI has never supported exceptions.

**Marcin**: Moving back to memory in wasm 64 in the component model. Would it be enough to just implement the ABI’s in the host. I presume WASI libc operates on the ABI’s. Would that be an option and reasonable to you?

**Luke Wagner**: Yes, folks starting with a single module targeting the component model API. 

**Marcin**: Component model support in wasi-libc status?

**Pat Hickey**: PR for libc support https://github.com/WebAssembly/wasi-libc/pull/449 
 
**Pat Hickey**: You get type safety at the component model level. 

**Dave Bakker**: Supports everything in preview 1 plus sockets. Initial PR was too big and so next steps are to split them up. Another PR is opened up to use preview 2 to component model resources. The next step would be to use the sockets functionality, etc. Then slowly migrate over from preview 1 adapter straight to targeting preview 2 functions.

**Marcin**: It is under active development?

**Pat Hickey**: I don’t think there’s a way to make this work go faster where it is at now. 

**Shengdun Wang**: Does preview 2 use the component model?

**Pat Hickey**: Yes.

**Pat Hickey**: We need to end this discussion now and move to wasi-webgpu. 


#### wasi-webgpu

**Mendy Berger**: This is wasi-webgpu+ because this includes more than just wasi-webgpu. But that doesn’t give you the ability to render it anywhere. You need something to get it onto the screen. The point that you connect the canvas to the webgpu is a new context.

There is a question on if some of these should be broken out.
wasi-canvas: Canvas/surface
Wasi-graphics-context: Point of connection

This can mostly be based on the webgpu spec. I created a WebIDL converter. 

https://github.com/MendyBerger/webidl-wit

Not like canvas on the web. This is a very simple API. I expect this to take longer to standardize because we’re coming up with new API’s there. 

wasi-graphics-context is the connection between the webgpu and the canvas so that they don’t have to rely on the other. 

**Sean Isom**: Example of attaching a web canvas to webgpu via the context: https://github.com/MendyBerger/wasi-webgpu/blob/main/example-apps/triangle/src/lib.rs#L49

**Mendy Berger**: Should be usable with other graphics API’s in the future.

**Mendy Berger**: This is WIT for the wasi-graphics-context. Every GPU API would give you it’s type for what the next frame is going to be.

**Bailey Hayes**: Since the work is tightly coupled today, it makes sense to me to keep it in one repo for now

**Pat Hickey**: Later we can figure out if/how we should separate this out into a separate proposal. 

**Mendy Berger**: Sounds good.

**Sean Isom**: Should be useful for vector graphics since most of this is not gpu accelerated.

**Mendy Berger**: Cool so it will be useful.

**Syrus**: I don’t understand the need for a custom API. What is the delta that you are trying to cover?

**Mendy Berger**: Are you asking what the web api’s are?

**Syrus**: Why separate?
**Mendy Berger**: A new windowing/full windowing API would be useful for example. 

**Sean**: https://stackoverflow.com/questions/50819974/how-to-use-canvas-in-emscripten
Two different use cases. Raw image pixels for output from a raw rasterization process, vs Canvas which is a higher level context. Like this: https://web.dev/articles/drawing-to-canvas-in-emscripten

**Pat Hickey**: Universal consent vote. We’ll keep it all in one repo for now and may have future discussions later to split as appropriate. 

**Pat Hickey**: Ok this passes. 

**Pat Hickey**: We are now out of time and will see everyone next time.

"
main/2020/CG-04-28.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the Aptil 28th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: April 28th, 4pm-5pm UTC (April 28th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Safety in the WebAssembly C API. [Slides](c-api slides)
       See https://github.com/WebAssembly/wasm-c-api/issues/132 for background.  
       Poll: Should wasm-c-api pursue safety, as discussed in this issue?  
       Poll: If not, approve a new WebAssembly C API proposal at phase 0?
    1. Flexible vectors - [slides](https://github.com/penzn/wasm-long-vectors), [design/1332](https://github.com/WebAssembly/design/issues/1332). Poll: Approve phase 0 for flexible vectors.
    1. Poll: Propose WebAssembly BigInt<->i64 conversion in JS API for phase 4.
    1. Poll: Remove subtyping from the Anyref proposal.  
       Context: https://github.com/WebAssembly/reference-types/issues/69.  
       Meeting notes from off cadence meetings: [04/02/2020](https://github.com/WebAssembly/meetings/blob/master/main/2020/CG-04-02-Subtyping.md), [04/21/2020](https://github.com/WebAssembly/meetings/blob/master/main/2020/CG-04-21-Subtyping.md)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

Manos Koukoutos

Ms2ger

Deepti Gandluri

Thomas Lively

Francis McCabe

Nick Fitzgerald

Ben Smith

Jay Phelps

Rick

Ryan Hunt

Derek Schuff

Sabine 

Petr Penzn

Lars Hansen

Sven Sauleau

Dan Gohman

Jacob Mischka

Luke Wagner

Keith Miller

Yury Delendik

Zalim

Jakob Kummerow

Alon Zakai

Alex Chischton

Zhi An Ng

Nabeel Alshamma

Ross Tate

Conrad Watt

Rich Winterton

Heejin Ahn

Emanuel Krivoy

Tobias Tebbi

Andreas Rossberg

Adam Klein

Emanuel Ziegler

TatWai Chong

Ingvar Stepanyan

Luke Imhoff

Arun Purushan

Ioanna Dimitriou

Wouter Van Oortmerssen

JP Sugarbroad

Ioanna Dimitriou

Jensen-Grey

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Ben Smith Seconds

### Proposals and discussions

## Safety in the WebAssembly C API. 

DG presenting [c-api slides] (https://github.com/WebAssembly/meetings/blob/master/main/2020/presentations/2020-04-28-gohman-c-api-safety.pdf)
 
RT: What's the trust model here?
 
DG: IF you look at the JS-API - that’s a good model for it - you can’t modify any key aspects of the module - the things that are impossible to modify at runtime are the same invariants that we are enforcing here. 
 
RT: My question is: you're trusting the C API program implicitly? Not a separation of trust. Just curious if you're trying to solve a harder problem here.
 
DG: When you’re talking about C code, it’s unsafe, the untrusted parts are the module, the C code itself is assumed to be safe, the wasm module is supposed to be unsafe - if you’re expecting an immutable global in the C API, but the module defines it as immutable then you want that error to be defined, similarly with exports..
 
RT: Second question. What's the substitutability model here. If you have a well-implemented engine and another, how reasonable is it to get exactly the same behavior between the two?
 
DG: If you use the unchecked APIs, no guarantees they have undefined behavior, if you dont… we haven’t finished the work of verifying the entire API yet, but the goal is to ensure compatibility between well implemented engines
 
AR: Primary goal of C API is that people don't program in it directly, it's a binding API. So it should be low overhead. C is fundamentally an unsafe language, some of the cost of performance is that it is unsafe. We can find middle ground there. The best you can do normally is adding assertions. Best you can do is sanity checks, I think there are things that you think that can be checkable that cannot be checked. These are checks that are asserting preconditions to the API...
 
DG: Can you clarify what you mean by things you can’t check? The JS API can check most things, what are things that the JS API can check and we can’t check? 
 
AR: I think that we can still do this in the JS API because it's still a simple language, I think in the future we may have to make the JS API more complex or not check things. The other issue is that it requires self-reflection to implement.
 
AR: The status of these checks is like assertions, and people usually want to tuern them off. In some environments it’s common practice to turn assertions - we require checks.. And they have completely undefined behavior that’s not ideal - it’s the nature of the low level API. Having a checked/unchecked API is not the solution to this - you want to be able to have just one switch when going to production, it’s not the right level that you want to do this at. The specification/semantics should not enforce  hecks. It’s good if implementations provide checking, it shouldn’t be a required part that when you turn off implies undefined behavior, it’s not what you want to specify. Not necessarily about having different goals - but where you put having different requirements. If you put it in the API spec, then you throw out some usability - that would not be good - because you want to have the correct semantics. The checked/unchecked versions you want to specify what that means because some undefined behavior becomes defined behavior. 
 
AR: The last thing I want to say. The things you're adding are protecting against bugs in the host. The kind of error reporting you want to do, you should distinguish that. There's a difference between the wasm program itself that has an error and the host having an error.
 
LW: There’s a bunch of checks if they are not optionally done in the C-API then they have to be done by every host - if it’s well defined and donbe, then the host can rely on the C API to perform these checks. Maybe I want all the checks except the one on the really hot path. Incidentally the C API isn’t good for hot paths, there’s more work to be done apart from tearing out the checks.. But there’s a commonality between the host
 
AR: I can agree with that. I'm less sure about the factoring. Another problem w/ check vs. unchecked cases, the cost is not in the call. The cost is based on having additional data stored...
 
LW: If it’s all defined in the JS API, it’s a precondition that’s already defined..
 
AR: I think this will only get you so far, though. Some of these are possible because the language is simple. Currently there is no complex objects...
 
LW: Let’s cross that bridge when we get there, because the JS API will also need that..
 
AR: Does this mean we're painting ourselves into a corner?
 
LW: It’ll be symmetric with what we’ll do with the JS API..
 
DG: JS API, Python, Ruby, they'll all have the same problem here. We'll have unchecked for hot paths when needed. 
 
AR: My point is, this is something you need to configure statically, you’re paying for the overhead, you have to compile the engine with a different configuration.. 
 
DG: One thing I want to address. We don't look at these like assertions. If you're a high-level language you need to have it. If you need to have it in your bindings, then each of them have to do it. This is required to make your high-level language work.
 
LW: If we get to this point, when we get to the expensive situation, we can have both.. We can cross the bridge when we get to it
 
DG: If you're using it from high-level bindings,..
 
RT: Historical example, is the simcity example, when windows 98 wanted to upgrade something.. Some part of the API was undefined, and not enforced by checks, when they wanted to upgrade, turned out to be incompatible with simcity, Conditional on if(simcity) do this unchecked behavior, otherwise do this behavior, which was not what was intended, but happens in practice
 
AR: There's one other assertion you made. All bindings will have to implement these checks. Some other languages will enforce these properties with type systems. You'll make them pay for this.
 
DG: Unchecked APIs can be proved to be safe..
 
LW: IS that the only thing though? How do we express uncheckedness? The only thing left to figure out how to opt out of the checks?
 
AR: One is how to opt out, the other is how to import them.. <example with trap> It’s not really a trap, we should report it as a different thing that can be defined, the other is how do we opt in/out. We specify the preconditions, and then say that there are some ways to check some preconditions but not all
 
DG: If you can't check all of them, then you can't have a JS API.
 
AR: The JS API may be more restricted, why would you hold everyone hostage to what the JS API does? 
 
DG: Poll is: should the wasm C API, accept the PR as laid out...
 
AR: Poll is too binary
 
DG: Happy to work through details there, trying to get a clarity of direction..
 
AR: You haven’t motivated why these changes are required? 
 
Poll: Should wasm-c-api pursue safety, as discussed in this issue?
 
|SF|F|N|A|SA|
|--|-|-|-|--|
|6|10|18|2|0|
 
BS: Seems pretty clear that the group agrees that there is consensus on having safety..
 
AR: The way that it’s currently done in the PR is.. I want to ensure that we have a toggle that still has the defined semantics - 
 
DG: I think we fundamentally disagree here..
 
BS: We can get to the point where we have to figure out what the semantics are, that sounds like a reasonable compromise.
 
<More discussion DG, LW, AR - taking it offline>
 
## Flexible vectors [slides](https://github.com/penzn/wasm-long-vectors), [design/1332](https://github.com/WebAssembly/design/issues/1332). Poll: Approve phase 0 for flexible vectors.
 
PP: presenting <TODO slides>
 
AR: One basic question: you're proposing introducing implementation-dependent behavior to wasm?
 
PP: Depends on what you mean by implementation dependent? 
 
RT: Doesn’t length change on each implementation? 
 
PP: Yes, the vector can change on cell phone, desktop, etc.
 
TL: Vector length itself is implementation defined..
 
PP: Machine code you’re generating changes though
 
TL: The code you're intended to generate would not have observable differences, but using this proposal you could construct an example that has different behavior on each platform, for example returning the size of the vector.
 
AR: The number of
 
DG: There are definitely implementation-defined aspects. Other implementations don't have to have the maximum length. The poll that Petr is putting in is for phase 0/1. Not set in stone, mostly investigative.
 
KM: Is the reason why this is better... it makes code generation easier, since your loop can be dependent on what the machine supports?
 
PP: Yeah, generally because you would have to.. We don’t actually combine them 
 
KM: You could do a loop invariant strength reduction, there are loops you can write that you don’t have to flatten it out.. 
 
AR: Similar concern as KM
 
JS: Consensus requirements are low: do members believe that the feature is in-scope will be workable.

Conclusion: Unanimous consent for Phase 1, with caveats that there are design concerns that need to be discussed. 
 
## Poll: Remove subtyping from the Anyref proposal.
 
Poll: Remove subtyping from the anyref proposal

|SF|F|N|A|SA|
|--|-|-|-|--|
|7|9|8|2|5|

### Closure
"
gc/2021/GC-10-05.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 5 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: October 5, 4pm-6pm UTC (October 5, 9am-11am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Announcement: Proposal update in wider CG
    1. Discussion: Prototyping and investigation plans (10 - 15 minutes)
    1. Presentation: dart2wasm (Aske Simon Christenson, 20-30 minutes)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Aske Simon Christensen
- Ben Titzer
- Zhi An Ng
- Roberto Lublinerman
- Rick Battagline
- Ross Tate
- Zalim Bashorov
- Lars Hansen
- Keith Miller
- Tim Steenvoorden
- Alon Zakai
- Jakob Kummerow
- Andreas Rossberg
- Conrad Watt
- Goktug Gokdogan
- Luke Wagner
- Francis McCabe
- Mark (??)
- Asumu Takikawa
- Slaval Kuzmich

###  Announcement: Proposal update in wider CG

TL: Let me know if you want to join me, Alon, and Jakob in presenting recent progress on the GC proposal.

### Presentation: dart2wasm (Aske Simon Christenson, 20-30 minutes)

[slides](presentations/2021-10-05-christensen-compiling-dart.pdf)

ASC: Dart is very dynamic. Fields can be overridden by getters and setters or vice versa. Even adding two integers is a call in theory. We depend on type flow analysis heavily for devirtualization in the front end. Every object has a class ID. Every method has a selector offset into the table. Call dispatch uses Wasm tables and call_indirect. Any class can be used as an interface, so all calls are interface calls?

BT: you have reference types in func types, how closely do they need to match for call_indirect?

ASC: I will get back to that, but parameters can change types in overrides. So the wasm signature needs to be the least upper bound. More details later.

ZB (chat): Why do you have tree shaking 2 times?

SK (chat): Does it mean that table size is (num_interface_methods * num_ClassIds)?

ASC: no, these are interleaved. If you have the complete square table it will be very sparse. They are packed together. Each row corresponding to a particular selector will have entries for all the class ids that have that particular method, rows will be sparsed, and interleaved into a 1 dimensional table, so it's usually not very big

FM: on this slide, do you mean each dart object is translated to a Wasm struct rather than each class?

ASC: each class translates to a struct definition

RT: What is the `context` field in _Function?

ASC: It’s a pointer to the context.

RT: Could you have the context be fields after the `functionRef` in e.g. _Function0?

ASC: If you have two different functions with different contexts and different variables, they need to have the same type so the functions are interchangeable.

RT: The two different functions being subclasses of _Function0 would accomplish that.

ASC: There needs to be a cast anyway since the contexts can all be different, so I didn’t do that.

AR: like flattened closures, save 1 indirection and allocation per closure

ASC: you would put function ref in the same object as the context

ASC (Post-meeting addendum): Multiple functions inside the same function can share a context. Mutations from one function are seen by the others. Therefore, there needs to be an indirection from the closure to the context (i.e. deep closures).

AR: if functions are divided by arity, does it mean any parameter and result has to be boxed

ASC: yes at the moment. It is somewhat trivial to do that and still have this be assignable through the dart subtyping rules, worth looking into to avoid boxing. Currently prototype does not support optional parameters at all for function objects, working on this at the moment.

AR: can avoid boxing by using anyref instead of top type, can use i31ref or bools or small ints

ASC: for small ints, there are a few unsolved challenges (see slide)

RT: In the system I briefly presented last time, we did something similar with call tags to solve some of these problems.

BT: About complex type tests: In Jawa I implemented interfaces with a search, but because you used call_indirect you don’t need to do that. But then search comes back for type tests, and I think that it’s unavoidable that it shows up somewhere.

ASC: yea, the way it is implemented in Dart VM, the class ids are numbered such that for most classes, all of its subclasses constitutes an interval of class ids. When testing against a class, you can test class id is inside an interval. An interface with a number of classes implementing it, you check against multiple intervals.

ASC: It would be useful if we could use the JS weakmap on Wasm GC objects.

FM: question about async/await. Is this the only place you needed the arbitrary goto?

ASC: One other situation that creates non-reducible control flow is a switch statement that continues to a previous switch label, which is possible in Dart. That can also be implemented by jumping to the beginning of the switch with an appropriate value on the stack, but is slightly less efficient.

FM: That sounds like CW's multi-loop thing. On async/await, is this transformation part of the semantics, exposed to the programmer? Or can you implement async/await using the stack-switching primitives?

ASC: Stack switching feature could be used, the async/await is not specified in terms of the transformation, it specifies that it suspends at a particular point, then resumes at the same point. If that can be achieved with stack switching, it will be a feasible implementation strategy. In the case of Dart, it's always just 1 stack frame.

ASC: tree-shaking in type flow analysis is based on the result of the type flow, will figure out certain parts are never called, classes never instantiated. Second tree-shaking is there because intrinsicifaction can make methods calls unnecessary because they have be intrinsified.


(chat)

From Luke Wagner to Everyone:
Also, if the captured variables are mutable and there are multiple live closures, you in general need to share the activation state
From Ben Titzer to Everyone:
Yeah, you might need to share contexts if functions can be nested multiple levels deep
i.e. linked closures
From Mark to Everyone:
Very cool and interesting presentation! Thanks so much for sharing. From all of the issues that you mentioned have you come across anything so far that you feel like would prevent Dart from becoming a showcase language of how GC languages can work with Wasm or do you feel like the trade offs are too much at the moment? What do you think the main challenges are from here from your point of view?

ASC: not really, with the way Wasm GC is progressing so far, I have a good impression of the group being open to implementor feedback, if something shows up, will have confidence that we can solve it. Have not encountered that looks like a complete blocker.

TL: already beating JS on most benchmarks?

ASC: yes, on big benchmarks, it's something like factor of 2 for time to first frame. After it gets up to speed, a factor of 3. Not done thorough analysis, this particular benchmarks does a lot of megamorphic calls in JS, but efficient when using global dispatch table in Wasm.

AR: does the JS version of Dart support separate compilation in any way? This is about whole program right?

ASC: JS is a whole program optimizing compiler as well.

RL: how does it compare to the performance when running in the Dart VM?

ASC: varies between a little slower to 2-3x slower. It is not as fast as the Dart VM, in some cases it comes close, especially for peak performance on large benchmarks. Native AOT clearly beats it on startup time, doesn't do anything except load code into memory. On the execution speed, not as fast, but not much slower.

AR: any feel for specific language constructs in Dart that are significantly slower in the Wasm version? Or equally distributed? Hard to tell?

ASC: definitely some overhead in call_indirect that is not there in the VM. call_indirect has to do a bounds check and a type check, which are not needed in VM runtime because it trusts the table. Also VM trusts the Dart type system, all the places Wasm needs to insert casts, VM doesn't need to.

AR: are there specific constructs where casting is particularly bad? or across the board?

ASC: one thing I can definitely see in performance is null check, so many of them. This will likely change when V8 implements null check elimination (not implemented yet), at least in current implementation, seen quite some overhead by modifying V8 and looking at the difference there.

AR: V8 does implement nullable and non-nullable?

ASC: no checks for non-nullable. Locals have to be nullable.

AR: goes back to issue with let or uninitialized locals

JK: we implement non-nullable locals, even the completely unsafe version where V8 trusts you to do the right thing

ASC: haven't tried that yet, will try that

AR: you mentioned call_indirect, why can't you use call_ref, which saves some checks?

RT: have to load from vtable anyways, a lot of the same overhead

ASC: will need to load from an array, then do the call, you could have a huge struct with the specific types there, it wouldn't work since you have to index into it. Not really a good fit for call_ref. call_indirect does exactly what it needs to do, but it cannot trust the table.

GG: in our experience, wonder why different in two langauges, is it possible you have less efficient structure? Memamorphic JS beats Wasm quite highly. In J2CL, megamorphic code happening in Wasm is much slower than JS. Have benchmark sthat show that Wasm is significantly slower than V8 dynamic dispatch.

RT: megamorphic class method calls or to interface methods?

GG: class methods? In cases we cannot devirtualize, class with multiple implementation. If you look at delta benchmark from octane, ported to Java, can see Wasm is much slower, JS is close to JVM, Wasm is 50x slower.

JK: hard to say for sure without taking a closer look. 10 years spending making the JS fast, Wasm can't compete with that yet. Could be inlining helps, maybe JS can do that. We can take a closer look offline.

GG: surprising that Dart didn't see that in their benchmarks, but might be just the way they generate JS, don't get full benefit of V8

RT: we have measurements to suggest call_indrect can be done faster than call_ref

BT: also implementation details about call_ref in V8, some devil in the details, without seeing the actual machine instruction hard to tell

JK: call_indirect and call_ref should be roughly the same. CPU internal optimizations or lack of play a big role. In some cases the branch predictor can help. Hard to make general statements there.

### Discussion: Prototyping and investigation plans (10 - 15 minutes)

(Deferred to GitHub / next meeting)
"
simd/2021/SIMD-07-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 9th video call of WebAssembly's SIMD Subgroup

- **Dates**: 2021-07-09
- **Times**:
    - 4pm-5pm UTC (9am-10am PDT)
- **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this [form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking
1. Adoption of the agenda
1. Proposals and discussions
    1. Working on cost model (Petr Penzin)
    1. Relaxed simd update (Zhi An Ng)
1. Closure

## Meeting notes

### Attendees

- Evan Nemerson
- Yury Delendik
- Deepti Gandluri
- Petr Penzin
- Zhi An Ng
- Andrew Brown
- Rich Winterton
- Marat Dukhan
- Thomas Lively
- Johnnie Birch
- Jan Wassenberg

### Working on cost model (Petr Penzin)

PP: volunteer to work on cost model, wanted to make sure no conflict

TL: sg, haven’t worked on that, working on other isel stuff

Lowering data (Evan)

### Relaxed simd update (possible phase 2)

ZN: Before we go to phase 2 discussion, we need to decide if there are going to be any other classes of instructions we want to add to relaxed simd

MD: flushing of denormals, disable nan propagations, few ways to implement this. maybe function attributes? Function to get fpu state and function to restore fpu state, function to set.

ZN: For relaxed SIMD we decided to create a new instruction for each mode. Will this scale?

MD: Complicated to do this on the instruction level. In AVX 512 these are specified by setting state rather than as instructions. We could implement this with a function attribute, but there might be high overhead.

PP: Similar to the rounding mode discussions we had previously.

MD: this is not the same as rounding mode, Arm (?) does not support everything proposed there

PP: manipulating status word aspect is similar

JW: Clang reorders setting rounding mode

...

MD: the result is still valid, since it is non rounding mode, it will just be less performant

EN: sounds like a clang bug, seems like that should work, or at least file issue about it

JW: gcc knows about it since 10 years

EN: don’t think a lot of people use the functionality

PP: yea bug for sure, we’ve talked to different people, try to define new intrinsics… overall, fundamental with porting such things to wasm, global setting, you can inject code, everything will change, we don’t like such global settings

JW: can you flush normally? Is there one point they are created

MD: NaNs cann pop up anywhere

JW: subnormals flushing?

MD: can also be created, subtract 2 numbers of similar number and same sign. Subnormals guarantees if a != b, a - b != 0.

PP: you only want this on relaxed simd, not normal wasm level?

MD: will affect all of it

PP: maybe there is bringing this up separately

DG: some time around mvp where the fast mode was discussed in general, we decided to revisit this question when we add fma, kind of goes hand in hand. When I first imagined what relaxed simd is, it is a mode you can switch between, maps to fast mode flag. Imagine would hard to force just on SIMD and not on scalar operation.

RW: why is instruction set a hard blocker for phase 2? We were changing late in the game for SIMD.

DG: we need to solidify overall design of proposal

RW: was just thinking a fixed number of instructions

TL: even if just adding instructions, the whole proposal is adding instructions, consensus on design == consensus on instruction set. Good that we got implementer feedback, but the best process is to have consensus before moving ahead.

DG: we can agree which set of instructions we are adding, we can then add one or two to the set

PP: we were not adding non-det to SIMD, even though we were adding lots of new isntr

JB: relaxed-simd is attractive to me because as use cases become more known, particularly in standalone, the need for relaxing certain instructions before more prominent. As long as there is a path to add relaxed instructions.

PP: where do you stop?

MD: one aspect is, how restrictive should we be for values that can differ between implementations. Shouldn’t we be more restrictive, it’s an implementation defined function of input? Or enumerate which values are possible?

DG: won’t be opposed to be less restrictive to start with, then with implementor feedback to be more restrictive. A lot of the non-det is a function of the environment that we are building the proposals for. If browsers or engines don’t have a problem with it. Curious to know more about benefits of restriction?

MD: whether we want to support users testing for specific behavior or not. If instructions out of bounds is unspecified, it can be random, e.g. cann leave previous values. Users cannot really rely on testing with specific input, can be good or bad. It complicates implementation, there may be situations where users will care only about certain out of bounds results, and add special out of bounds results.

EN: if we make guarantees, we force implementations to use less optimal instruction since we already committed to a set of outputs

MD: realistic, we can see what arm/x86/powerpc output for particular inputs, make sure our specifications will be consistent. In the future, risc-v, unlikely to be influenced by Wasm SIMD.

DG: engines and implementations can specify limitations, e.g. memory limitations. Community agrees, but don’t need to spec it.

MD: in the end, users can look into source code, and how to lower. Better to provide guarantees that output is a deterministic function of input. E.g. float to int conversions, when input is NaN, below or above bounds. Can say the output in this case is some implementation defined constant.

TL: reminds me of fpenv, guarantee the output is a function of input, looks like the same fpenv thing this is trying to solve.

EN: implementations could also provide additional guarantees, if the spec says implementationn defined, implementation can define it, it’s whatever we want it to be, might change it. Mozilla can promise that on x86 we will always do that.

MD: will be hard to get all engines document what exactly they do. If you want to know, go read the source code.

TL: we can put it in the web embedding doc

DG: we can be more restrictive, concerned about having too many restrictions in the spec. Probably need more eyes on the issue

ZN: Marat, can you file an issue

MD: there are multiple different aspects here

ZN: at least one example can illustrate the problem

MD: I want instruction to flush denormals, not fast math flag. Global flag is the closest to how hardware does it. Function level is the closest, but my concern is that it won’t be easy to port existing code, also the overhead of function-level solution would be high and not acceptable to some users

ZN: function level flag can also interfere with optimizations

DG: flag mode is interesting in a way that it can help avoid opcode bloat

TL: Wasm is formalized, adding global flag complicates formalization. need to say what the benenfit of global state will be over adding instructions. Performancne cann be a compelling argument.

DG: can also make a code size argument. Can generate more opcodes up front, easier for engine, maybe code size v.s. Performance tradeoff

JB: is the implication that the global state each engine has to implement everything in relaxed simd.

JB: easier to reason about individual instructions giving non det, compared to global state

TL: yea definition, but also how much it matters

PP: discussion on other global state related things, setting this per-instruction (as opposed to global), it would make engines more complicated, as you can’t reset hardware mode per instruction, you would have to combine instructions with same mode somehow

RW: MD, do you see a use for CDT instructions?

MD: Yes, I use something similar in XNNPACK and it would be useful there.

RW: These seem to be in the same category as the relaxed instructions so far.

MD: I think there is already a proposal for these instructions. I32x4.trunc_sat… issue #21.

RW: That covers four formats, right?

MD: Yes. 64 or 32 bit, signed or unsigned.

EN: We already have two pairs of min/max instructions, but we don’t have a min/max where it may or may not be pmin/pmax.

MD: we shouldn’t result to just min/pmin

EN: seem to remember that i ran into situations where a platform didn’t support min or pmin, had something else

MD: risc-v doesn’t have min or pmin, in scalar instruction set, only minnum and maxnum

EN: will check, might be platforms where nans are handled differently.

MD: only need to check what powerpc does

DG: for previous SIMD proposal we were mostly keeping it focused on intel and arm, big portion of devices we were trying o address. What set of archs we want to target this proposal for?

EN: flexible-vectors proposal adds interesting element, a lot of 8-bit instructions missing in SSE, at least in SVE and AVX512. Even if they are only operating on 128-bit vectors, can use flexible vectors proposal, and keep relaxed limited to ARM and Intel.

MD: practically what we have today is intel arm and in theory powerpc. Everything that comes after that comes after that has to take into account Wasm SIMD itself.

EN: are we thinking we could add 8-bit shifts to relaxed SIMD, even though x86 doesn’t implement till AVX512.

MD: we have 8-bit shifts, cover intel arm powerpc well, don’t need cover something that is experimental.

EN: if x86 doesn’t cover it, leave it out of relaxed simd. Think there is less need for it in relaxed-simd if we have it in relaxed-simd specifications. If you want to use those instructions, you can use flexible-vectors.

MD: have to keep in mind the timeline, relaxed-simd is a small specification. We can get it out sooner. Flexible-simd is a huge specification, with large number of instructions, will take longer.

EN: makes sense. Right now people are on x86, and ARM. By the time that shifts, hopefully flexible will be closer.

MD: webgpu is supposed to get to be a real thing sometime in between, also will be less interest in using variable width simple once you have general purpose gpu.

PP: you can only use from JS.

MD: to sum up, i think relaxed-simd should target the case when we have Wasm SIMD and we don’t yet have flexible vectors. Since it’s bigger and will take longer to materialize.

PP: I don’t think webgpu is related at all.

MD: everything is driven by demand, need fast computation in browser, think webgpu will take away good portion of demand

PP: cant interface from within Wasm

DG: PP mentioned CPU workloads, some libraries use CPU workloads to not incur overhead of bringing up GPU, only useful for smaller workloads, interesting in flexible-vectors, think of useful workloads. A lot of proposals still early stage, interesting to see when flexible-vectors is more widely supported. Don’t have answer yet.

PP: do you know if anyone trying to interface with WebGPU from Wasm.

DG: no concrete proposal, some people thinking about how to solve this problem.
"
stack/2021/sg-5-17.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 17th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  May 17th, 16:00-17:00 UTC ( May 17th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Matthew Flatt
Daniel Hillerström
Luke Imhoff
Luke Wagner
Amirouche Boubekki
Paulo Matos
Paul Dworzanski
Luke Wagner
Alon Zakai
Thibaud Michaud
Daniel Hillerström
Deepti Gandluri
Sam Lindley
Derek Schuff
Ioanna Dimitriou
Ben Titzer
Andreas Rossberg
Adam Klein
Alon Zakai
Emanuel Ziegler
Thomas Lively
Zhi An Ng
Zalim Bashorov
Daan Leijen
KC
Rick
Ross Tate
Arjun Guha
Paul Schoenfelder

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. Support for Coroutining in Racket/Chez Scheme (Matthew Flatt) [55mins]
   1. Next meeting [2 mins].
1. Closure

## Meeting Notes

### Adoption of the agenda

### Discussion:

#### Support for Coroutining in Racket/Chez Scheme (Matthew Flatt)

MF presenting

[Slides](https://github.com/WebAssembly/meetings/blob/master/stack/2021/presentations/2021-5-17-flatt-racket-intermediate-language-control.pdf)

SL: looks like a lot of things, could you cut it down to a few call primitives if needed?

MF: that’s what we will be doing, as Wasm designer you won’t want to add 30 things

AR: since you have all these boxes, some needs to hide from lower levels, does that mean some of those layers are not really safe?

MF: A good example is continuations, at the racket level all continuations are delimited, we can’t provide the raw scheme at the chez level, exposing them in the higher level would not be safe, each wrapper is building up stoff that need to hide/refine at the higher level

AR: they are too powerful.

RT: what does unsafe at the upper level mean?

MF: if you had chez scheme call/cc at racket layer, you can capture too much, can ignore delimited prompts, unsafe in the sense that you step outside where the semantics say happens, when delimiting doesn’t work

RT: unsafe from how racket language is supposed to interact, but not in the view of memory safety etc.

MF: unsafety as unspecified behavior, capturing undelimited continuation is unspecified behavior

FM: what happens when you finish evaluating e1

MF: So when we have a value v1, it will get delivered to the next bubble, and the badge goes away along with the square box

RT: seems like you want that for other reasons

MF: calling continuation is more convenient in a lot of contexts

Amirouche: does racket have parameters?

MF: Yes, they are implemented with a mark

Amirouche: Marks are like thread locals?

MF: It is a continuation local and not a thread local - if you try to use the same continuation in two threads bad things can happen 

DL: all the v values cannot be updated in place, you cannot set v to a new value

MF: Yes, racket is not purely functional so the box could be a value that you mutate

DL: if you do the continuation multiple times...

MF: Will come to that in a minute

FM: are these tags first class values?

MF: In racket they are first class values

FM: how important are marks?

MF: We use marks for parameters, something like current directory, used in the contract system, don’t have a list of uses right now, but there are 6-8 of them  - enough that we built them into the chez scheme for performance

LI: if something similar like this was used to implement erlang processes, equivalent thing would be process dictionary. Can see similar use in Erlang for it

FM: If you go back one slide, you may not know who to go back to, you may not know where your delimiter is, can you put the delimiter in a mark?

MF: you can do that, delimiter tags are values, marks can be arbitrary values, that is one way to implement certain things, you can have a private key that corresponds to prompt, and find prompt that way. We don’t actually do it that way, delimiting is more fundamental. The machinery in some layers is similar.

FM: at the moment we are not looking at building the equivalent of marks, although some of us would like to, right now we’re not

DL: Coming from algebraic effect language, you could implement the marks in a non-primitive way, using prompts - that inserts and gets in a key-value way?

MF: or you don’t need prompts, you can do marks with raw chez scheme with state on the side. That’s one unsatisfying thing in the zoo in racket, more than one way

DL: I wanted to verify, it is possible? Partly the way chez scheme works,important for wasm to figure out which primitives are truly enough, you may have enough without marks as well

MF: question of which combination performs right. Food for thought, one way of stacking them up

LW: Is the main thing you’re optimizing for performance? Are there other factors?

MF: believe that’s right, want to make sure it has a certain level of expressiveness, and make it go faster

RT: These are largely a concern for multi shot continuations?

MF: Yes

RT: Still useful, wanted to clarify

BT: you end up making copies of every frame, you copy at least once...

MF: That’s right

BT: Stack segments are garbage collected? Are they in a special region?

MF: the stack is in a region special to GC in that it makes it able to do the splitting. Two pointers so you can get the total size of the segments

BT: They also need to be in the right order so you can use them in a native execution stack?

MF: when i hit underflow, it can be a completely different part of the memory

BT: do they need to be next to each other for any reason?

MF: the things i drew, the GC might move them in between, interesting subtlety there about one-shot continuation, can come back another time.

LI: A concern for FM is that V8 is CFI, can this do CFI on intel stacks?

MF: think not, not using the C-stack or the usual registers to refer to stack, just doing its own thing, things in heap.

LI: You used register, wasn’t sure it meant a cpu register or a virtual register

MF: virtual register, may or may not be CPU register. Depends on the CPU, not on x86, yes on ARM.


FM: If you’re not using call/return instructions, does that affect performance?

MF: no, there was an era in 2000s or so, it was a big deal for branch predictor, found that to be tru ein Racket JIT, these days it doesn’t seem to matter. Jon and students had paper on PLDI noted small effect, just because processors have evolved, not sure if CFI changes things.

LI: Would be really cool if we can get a hardware perspective

MF: haven’t measured on arm

BT: specific hardware mechanism for call return on hardware cpu, probably indirect branch prediction has gotten very good, may depend on how many indirect branch. It will normally prefer to use return stack buffer, if stacks aren’t too big.

MF: When stacks get big, it gets harder to come up with benchmarks

FM: I get the impression that on x64, there is more optimziation going on in call/return for call stack, for e.g. push push pop pop faster than exchange register, which it shouldn’t be, but it is.

LI: IS that maybe a fusion, when it’s translated to microcode?

FM: having a hardware expert on this panel will be great, to answer questions like this

LI: worried if they will tell us, is that too secret

FM: We  can give them the opportunity to say that

BT: usually specific guidance about fusian in Intel manuals, changes often, you have to read the manual in detail, it’s not secret

AR: what does racket typically use multi-shot for?

MF: Threads, the cooperative at the runtime level, preemptive at the racket level

SL: those examples are all one-shot, i would imagine

MF: correct, interestently wasn’t able to get any performance improvements for threads.. For many reasons. Opportunistic oneshots are a slightly different flavor

DL: it might be that you already paid upfront, if you look at it again, you can make call1/cc faster.

MF: One of the things happening - callcc was keeping larger stack segments around - the live portion of the thread was so small, maybe you’re right?

DL: might be in practice it doesn’t
MF: This opportunistic one did pay off, but it was tied with continuation marks

RT: if you knew the continuation was one-shot for with-mark, would you have to write the frame at all?

MF: Lots of things you can do to avoid creating frame, similar things happen with marks - if they are low enough you can do different things with the compiler .. explains with ‘+’ example. We change the way tailcalls compile in certain ways.. The compiler can know how with-marks work

DL: a cool thing if you wanted deterministic reproducibility of proofs, get away from timers, use number of instructions executed, even with threading you get the same results, even if computer was faster or slower

MF: Yes, when I say timer, it’s not a cpu timer - it is counting how many times you pull effectively. Interesting tradeoff - when you have foreign function interactions etc. always thought we may have to switch back to wall clock, but the decrementing counter has been effective so far

DL: also for things like fuel, for continuations you can cut something short, it’s a powerful concept

RT: With Racket’s amcro system, can you take continuation marks and compile them to use primitives (?)



MF: I left out the slides where we did that at first, it worked alright, ran for a couple of years, when moving continuation marks more primitively, 20% boost on continuation heavy programs, contract-heavy programs. It was worth the extra 20%. I hesitated a bit when you talk about macros, the layers and boxes aren’t quite macro expressible. One of the first things we tried to build things on top of Chez, worked well enough to get going.


RT: How do you do debugging? Do you use continuation marks?

MF: if you use Racket, provides a predictable debugging experience, doesn’t optimize away things, constrained that way, preprocessed to add with-marks all over the place for debugger to look at. If you don’t use that, you get a raw virtual machine stack.


RT: Especially if you want certain semantics

MF: that’s where continuation marks, the stepper for DrRacket, to reconstruct programs to effectively debug them

AR: Always impressed how scheme decomposes all of the things, added complexity in wasm is that we don’t want to depend on Gc, but also don’t have closures - hard problem, but any ideas on what we could do?

MF: great question, don’t know the answer to, happy to let people work on it, thought about how to compile Racket to Wasm. Hard to imagine Wasm garbage collection that will let Racket do the stack splitting thing, as we talk about knowing the stack layouts, splitting by just moving a pointer. Generally, don’t know how to abstract over garbage collection. Control things are very much connected to garbage collector.

Related documentation:

- https://docs.racket-lang.org/reference/contmarks.html
- https://srfi.schemers.org/srfi-157/
- https://docs.racket-lang.org/reference/contracts.html


### Adjourn
"
main/2017/TPAC.md,"![WebAssembly logo](/images/WebAssembly.png)

# WebAssembly meeting at W3C TPAC 2017
## (W3C Technical Plenary / Advisory Committee Meetings Week 2017)

- **Dates**: Monday-Tuesday November 6-7, 2017
- **Times**:
    - Monday - 8:00am to 6:00pm
    - Tuesday - 8:00am to 6:00pm
- **Location**:
  * Hyatt Regency San Francisco Airport; 1333 Bayshore Highway Burlingame, CA 94010
  * Sandpebble B, Lobby Level
- **Wifi**: TBD
- **Contact**:
    - Name: Brad Nelson
    - Phone: +1 650-214-2933
    - Email: bradnelson@google.com

## Logistics

Hosted by [W3C TPAC](https://www.w3.org/2017/11/TPAC/). See the site for details.

### Registration

Opens June 2017, see [TPAC page](https://www.w3.org/2017/11/TPAC/) for details.

### Hotels

See [TPAC page](https://www.w3.org/2017/11/TPAC/).

## Agenda items

### Day 1 : Monday, November 6th

#### 8:00am - 10:00am : Open Discussion

Swing by and talk about WebAssembly!
WebAssembly folks and others can discuss topics of interest.

#### 10:00am - 11:30am : WebAssembly Working Group Meeting

Official meeting of the WebAssembly Working Group.

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
    1. Host facilities, local logistics
1. Find volunteers for note taking
1. Adoption of the agenda
1. Approval of the minutes from last meeting
1. TPAC Welcome
   1. Welcome to TPAC (Brad Nelson).
       * [Code of Conduct](https://www.w3.org/Consortium/cepc/)
       * [Best Practices for Effective Meetings](https://www.w3.org/wiki/Meetings_Best_Practices_document)
       * [Speaker Guidelines](https://www.w3.org/wiki/Speaker_Resources#Speakers_Guidelines)
   1. Introduction of our W3C Team member [Eric Prud'hommeaux](https://www.w3.org/People/Eric/).
1. Proposals and discussions
   1. Discussion on increased coordination with other W3C Groups.
      * We'll talk about where we should be collaborating more with other groups,
        how we conduct outreach, and plan.
   1. Discussion on the status of the specification.
      1. [WebAssembly Core Specification](https://github.com/WebAssembly/spec)
      1. [WebAssembly JavaScript API](https://littledan.github.io/spec/document/js-api/)
      1. [WebAssembly Web API](https://littledan.github.io/spec/document/web/)
1. Closure

#### 11:00am - 11:30am : Proposals in Progress
Presenter: *Brad Nelson*

Brad will give a quick rundown of all current in-progress WebAssembly proposals.
We'll talk about where each is at in terms of our
[phases](http://github.com/WebAssembly/meetings/blob/master/process/phases.md)
and the obstacles each proposal faces.
[Slides](https://docs.google.com/presentation/d/1uRpS79-kAoL3EoC7IxrJFU5G7V-Sxno9pm9rVjC20yE/).

#### 11:30am - 12:30pm : WebAssembly Visits WebPerf

The Web Performance WG is discussing the
[Lifecycle API](https://github.com/spanicker/web-lifecycle/blob/master/README.md).

As modulating things like xCoin mining has bearing on WebAssembly,
our group should go to the WebPerf Room (Sandpebble C, Lobby Level).

#### 12:30am - 2:00pm : Lunch

Free-form mingling in the WebAssembly Room

#### 2:00pm - 3:00pm : WebAssembly from Above
Presenter: *Ben Titzer*

Ben will give a high level overview of WebAssembly.

#### 3:00pm - 3:30pm : Toolchains
Presenter: *Derek Schuff*

Emscripten is WebAssembly's toolchain.
Derek will give an introduction on how to use it, tips and tricks, and where it's going.

#### 3:30pm - 4:00pm : WPT

Discussion on Web Platform Tests.

#### 4:00pm - 5:00pm : Demos

Come see Demos of WebAssembly:
* Google Earth (preview) - Live demo only
* [WebDSP](https://d2jta7o2zej4pf.cloudfront.net/)
* [Construct3](https://editor.construct.net/)
* [Epic Zen Garden](https://s3.amazonaws.com/mozilla-games/ZenGarden/EpicZenGarden.html)
* [WebSight](https://websightjs.com/)
* [NASA Access Mars](https://accessmars.withgoogle.com/)

#### 5:00pm - 6:00pm : Open Discussion

WebAssembly folks and others can discuss topics of interest.


### Day 2 : Tuesday, November 7th

#### 9:00am - 10:00am : WebAudio + WebAssembly

WebAssembly and WebAudio WG folks to discuss future APIs, performance interactions, and avoiding garbage introduced by the API.

#### 11:00am - 12:00 : Exceptions and Control-flow in WebAssembly
Presenter + Moderator: *Heejin Ahn*
* Presentation on Control-flow in WebAssembly + current state of exceptions proposal. [Slides](https://docs.google.com/presentation/d/1bny3a9OFxDoJQpQXz_ZVN_bCqrTPNGEnotLaubyXrxY/edit?usp=sharing).
* Discussion

#### 12:00am - 2:00pm : Lunch

Free-form mingling in the WebAssembly Room

#### 2:00pm - 3:30pm : GPU for the Web Community Group
Presenter + Moderator: *Corentin Wallez*
* Presentation on WebGPU
* Discussion of WebGPU Topics, especially Wasm related ones:
    * Fast bindings for Web platform APIs (call overhead and GC-less render loop)
    * How to make the API interoperable between JS and WASM
    * Is the WASM host mapping buffers in the WASM module memory space a thing? (glMapBuffer equivalent)
    * Multithreading story for APIs
    * API extensibility in WASM (can't just add a dictionary entry like JS)
    *Any questions you might have!

#### 3:30pm - 4:00pm : Abusing WebAssembly
Moderator: *Brad Nelson*

Discussion on what bearing coin mining and other CPU abuse has on WebAssembly.
Follow up discussion of [Lifecycle API](https://github.com/spanicker/web-lifecycle/blob/master/README.md).

#### 4:00pm - 5:00pm : Host Bindings (JS + DOM) for WebAssembly
Presenter: *Brad Nelson*

WebAssembly currently in practice relies on a substantial amount of support from
JavaScript + Web APIs to be useful on the Web. Interoperability with JavaScript
and Web APIs will help make WebAssembly in practice more ""of the Web""
while improving performance and ergonomics. Bindings for non-Web hosts embeddings are also relevant.

[Slides](https://docs.google.com/presentation/d/10vz6pldVOA8N3guv2jf4DCUujqz6jFmDnp37ax4SCc0/edit?usp=sharing).
[Proposal](https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md).

#### 5:00pm - 6:00pm : Open Discussion

WebAssembly folks and others can discuss topics of interest.

NOTE: Brad Nelson will be away presenting to the AC.


### Schedule constraints

## Dates and locations of future meetings

TBD

## Meeting Notes

###  Roll call

* Heejin Ahn
* Jacob Gravelle
* Mircea Trofin
* Eric Holk
* Thomas Nattestad
* Deepti Ganduluri
* Ben Titzer
* Derek Schuff
* Kenneth Cristiansen
* Mark Miller
* Alex Danillo
* Eric Prud'hommeaux
* Conrad Watt
* Limin Zhu

### Opening, welcome and roll call


### Find volunteers for note taking
Derek Schuff agrees to take notes.

### Adoption of the agenda
Eric Prud'hommeaux seconds.

### Approval of the minutes from last meeting
[https://github.com/WebAssembly/meetings/blob/master/main/2017/WG-10-23.md] 
Ben Titzer seconds

### TPAC Welcome


Welcome to TPAC (Brad Nelson).
* [Code of Conduct](https://www.w3.org/Consortium/cepc/)
If you are speaking, check out these best practices and speaker guidelines:
* [Best Practices for Effective Meetings](https://www.w3.org/wiki/Meetings_Best_Practices_document)
* [Speaker Guidelines](https://www.w3.org/wiki/Speaker_Resources#Speakers_Guidelines)

Great year for wasm, gone from being sort of a thing to shipping in all browsers. Lots of interest, and lots of proposals upcoming.

### Introduction of our W3C Team member [Eric Prud'hommeaux](https://www.w3.org/People/Eric/).

W3C has a process document which describes the roles. Mine is boring bookkeeping! We want a spec process that involves the community enough that people will actually follow it. It’s a blanket process that isn’t necessarily customized for wasm, but it works pretty well. The overall goal is to make the spec resilient, i.e. make it so everyone can implement it. My background/current skills involve JS frontend (and Node), clinical data, C++ libraries. 

### Proposals and discussions


#### Discussion on increased coordination with other W3C Groups.
 
* We'll talk about where we should be collaborating more with other groups, how we conduct outreach, and plan.

We are here! So let’s take advantage by visiting other groups and talking to folks in our room too. Best to check with the chair before sitting in on an official meeting (fit with their schedule, avoid disruption, etc).
Next door is Web Perf team, we will go visit them later.
Talking to a broad variety of folks can get us good ideas now rather than later.

#### Discussion on the status of the specification.


1. [WebAssembly Core Specification](https://github.com/WebAssembly/spec)
1. [WebAssembly JavaScript API](https://littledan.github.io/spec/document/JS.html)
1. [WebAssembly Web API](https://littledan.github.io/spec/document/web/)


Probably no real decision here in the absence of Dan and Andreas. Dan is interested in capturing the state of CSP. We talked about that last week at the CG meeting, but it’s still in flight. It might also be left for a future WG iteration.

EH: which specs?

BN: all 3: core spec, JS and web embeddings.

AD: what’s the plan to turn this from the CG format into a real W3-formatted spec? Those have lots of boilerplate. This still isn’t like those.

EP: We can paste that on the front. Good integration for bikeshed, etc

BN: the embedding specs are BS, but the core is ReST and we kind of like it that way being self-contained. 

EP: Can we fit it into a framework that can work?

AD: for a WG recommendation track doc, it has some requirements. So we need to figure out how to fit what we have into those.

BN: We are trying as much as possible to keep the CG in charge of the content. But WG can do reformatting, status section, etc

EP: Some are requirements for publication, some are for convenience. Question is whether the form can be dropped into BS, respec, etc where we can append the extra stuff.

LW: the hope was that the embedding docs could have the webIDL, links, etc.

P?: tradeoffs between the editors and publication process. Do what’s best for the editors, and tooling for publication

EP: also depends on how often we want to publish.

LW: can we put the boilerplate in our BS-based embedding spec and drop in the core spec as a component inside?

Discussion ... maybe? Is the JS-rendered math markup a problem?

P: we’ve done this on other specs, it is possible to include the JS in the published HTML.

KC: Media Capture Depth Stream Extension spec has JS rendering

P: How often do we want to publish?

BN: twice a year?

... We can publish what we have as a working draft. Best to start the patent clocks ASAP
How much iteration do we want after?
We should have a pipeline to automatically publish as much as possible.

EP: what about the opposite? Doc which just points to editor’s draft.

P: could do that too. Mostly a matter of taste.

BN to follow up with EP on tooling to satisfy the publication rules.

BN: process to kick off public working draft?

EP: add document status, ask for the right short name for spec, warn the lawyers

Plan is to start in 2 weeks at next WG meeting.

EP: also possible to let the editors push the button to publish new working drafts.

### Closure

End of agenda!
Motion to close: let’s get coffee
DS enthusiastically seconds

## WebAssembly Meeting with WebAudio

WebAudio folks came by.
They demoed a synthesizer built with WebAssembly.
It inlines the wasm bytes as javascript text, converts it to an ArrayBuffer and instantiates the module.
This is because WebAudio worklets cannot use fetch.

We discussed the current WebAudio worklet proposal.
The desire to load wasm more directly was discussed.
Eventually when wasm gets ES6 modules support, an import of wasm code would be allowed.

The current api provides buffers to the user application.
We discussed a bring-your-own buffer API that would avoid the need to copy audio data in and out of the WebAssembly heap.
A protocol to allow WebAudio to request new buffers would be required. Ideally this would allow the main callback for samples to have no arguments, avoiding any chance of a GC.

We talked about if worklets are part of the same Agent Cluster as the rest of the page.
Link from Domenic to issue discussing this:
https://github.com/w3c/css-houdini-drafts/issues/224

We discussed using the Worklet MessageChannel to pass a SharedArrayBuffer (probably WebAssembly.Memory) / WebAssembly.Module to the worklet.
This would allow fetching to happen outside the worklet.

We discussed whether 32-bit floats are still a problem. Consensus was that with this new API, most of the historical issue with larger sample sizes can be worked around.

The general sense was:
* The current API will work fairly well for now, with the use of a MessageChannel.
* It can be later improved with bring-your-own buffer.
* Hosting Bindings might help, but if care is applied won't be blocking.

## Efficient XML Interchange

Representative from Efficient XML Interface EXI WG visited.
Recommended we learn more about their compression format.

AI: Add a github issue linking to their spec.

## WebGPU CG & WebAssembly

Presentation & Discussion
[NOTES](https://lists.w3.org/Archives/Public/public-gpu/2017Nov/0001.html)
"
gc/2022/GC-02-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: February 8, 5pm-6pm UTC (February 8, 9am-11am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
      1. Discussion: Changing to using PRs for agendas
      1. Discussion: Timeline for advancing to phase 2. 
      1. Discussion: i31 as a type dimension
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Francis McCabe
- Paulo Matos
- Ben Titzer
- Aske Simon Christensen
- Conrad Watt
- Ryan Hunt
- Lars Hansen
- Luke
- Rick Battagline
- Adam Klein
- Manos Koukoutos
- Keith Miller
- Sabine Schmaltz
- Zalim Bashorov
- Deepti Gandluri
- Alon Zakai
- Andreas Rossberg
- Jakob Kummerow
- Asumu Takikawa
- Michale Knyszek
- Sergey Rubanov
- Oran
- Emanuel Ziegler

### Discussion: Changing to using PRs for agendas

AB: Thumbs up in chat.

No objections.

TL: Ok, going forward we will organize our agendas via PRs to the meetings repo.

### Discussion: Schedule for going to phase 2

CW: Numbers?

TL: Posted on issue. Small overhead over nominal types, but definitely linear. Only measured with single rec group, no worries from our side about overhead.

CW: Experimenting with linking?

ASC: Dart still wants to do this, but it’s going to be further out.

TL: Any reason to discuss this again at next meeting or should we take it to the CG next week?

AR: No reason to wait

ZB: No reason to wait

FM: no reason to wait.

TL: Will put together a presentation for next week with overview of our status and a vote for phase 2.

AR: Will aim to land the PR ahead of the meeting.


### Discussion: i31 as a type dimension

BT: [presenting slides](https://docs.google.com/presentation/d/1fwDLjfaqpLZuuics1m8I--K-Zhpz1BLQnsrR8T-vIwA/edit#slide=id.p)

AR: Extra checks needed only if you're using `eq` or `any`; if you're not using `i31`, you could use `data` everywhere and avoid the overhead.

BT: Yes, that's the cost of `i31` being part of the heap type hierarchy [continues presenting slides]

CW: I see this as necessary because we don't have a general union facility, so you have to use `eq` or `any` as a union.

BT: Right, which is why the issue proposes adding union types for i31.

AR: There's only one win: if you need a union between `i31` and some `(def)` type.

BT: The win is as big as however low you can go on the hierarchy for defining the union. However low your common supertype is.

AR: [responding to ""Forward-compatible* encoding"" slide] Current thinking is that type exports & generics would both be over heap types. That's a bigger discussion we probably don't want to get into today.

CW: I was thinking that in a world where we don’t make this change and wait for general union types, could we add a restricted version of union types later where the only allowed union is i31 + some heap type definition? The goals is to be forward compatible.

AR: Yes, the union is over heap types and I would expect general unions to be defined types, so defining a restricted union makes sense to me as an intermediate step.

BT: We've already put a bit in the reftype constructor for null; i31 would just be another bit.

AR: You can think about it as a bit, but it's a new constructor, and the number of constructors is exponential in the number of bits.

BT: i31 is about machine representation, it's not a user-facing type


CW: We already have an example where you want richer representation for multiple types.

BT: i31 is representable on nearly all machines and other representations would not be portable, so i31 is special.

CW: ???

AR: I don’t think anyone is suggesting unions over value types, but rather unions over heap types.

CW: Only distinction between eq and data right now is that eq can be an i31.

BT: Right now the problem is that there's no way to have an any that can't be an i31

ASC: ???

CW: In a world with the union constructor, you wouldn’t use a cast(?) you would construct a union.

BT: Union or type or heap type?

CW: Heap type.

BT: Why isn’t null a heap type?

AR: You could make null a heap type. But it has this very special role.

ASC: Having null as a separate type could be useful, that would keep us from having to specify a heap type for the null.

AR: That would be separate, adding a bottom heap type, which couldn’t be anything but null.

BT: Could it be a non-null bottom type?

AR: It would be separate because bottom is a subtype of everything else, but null is disjoint from everything else.

CW: My assumption is that enough languages will want to be using null and nullable types in such a way that it makes sense for null to be a dimension. i31 is much less generally-applicable.

AR: Agree with CW that keeping null as a separate dimension makes sense given its special role. Even within Wasm null has a special role: e.g. default value of locals.

TL: Makes sense that null is special. But this conversation is about whether i31 is special. Clearly it's somewhat special, given we don't have i63 or whatever. Why is it not special enough to be a type dimension?

CW: I think it's special enough to merit a union constructor, but not a type dimension.

AR: You could require usage of i31 to have a defined type; we don't do that because it's kind of stupid, but it would make sense.

BT: Could declare structs to also be able to be i31. 

CW: That’s what I was talking about with the special case union constructor.

ASC: I don't think it will work well for a struct type to declare itself as being also-an-i31. Since the thing you want to deal with, when it's a struct, would be only-i31.

AR: Right, you want a struct type and a union of defined-struct-type and i31.

BT: But then how do we talk about only ref types that are pointers (not i31)?

CW: That would be a union of data and func.

AR: If we had unions we wouldn't need `any` or `eq`, they could be unions with i31.

BT: I want to define any point in the space of pointer-only types and also any point in the space of tagged pointers. Want a type as specific as possible.

AR: And a union would give you that.

CW: I think the point BT was making earlier was that adding i31 as a dimension would imply the use of tagging.

AR: Special union can’t use tagging either to make a representation change.

BT: Regardless of whether it's a dimension or a possible feature of unions, you'd have to pull it out of the hierarchy.

ASC: That would be necessary to avoid checking for i31 when downcasting from eq or any.

AR: If you want to avoid those checks you can just avoid using `any` and `eq` (those are just unions).

TL: AR, you said that you couldn't use pointer tagging with these unions? Doesn't that make i31 useless?

CW: Pointer tagging should still work? Downcasting from union won't change representation, values of precise types will keep their tags.

BT: The trouble with using a union of {data, func} is that you'd have to add anything else that gets added between `any` and `eq`.

CW: If we added unions with i31, should we get rid of eq?

AR: We could, but there are typing rules that want to refer to it

CW: I'm more saying that you wouldn't end up using `eq` for the purpose of unioning with i31

BT: If we have an i31 type, then `any` will be on top of it.

AR: Sounds like you want an any-but-i31 type? We could add such a thing if it was useful!

CW: From BT's presentation the use-case seems to be to avoid a tag check

BT: Correct

AR: Have a hard time imagining a use case with such a large union of arbitrary func and data.

BT: The not-i31 type sounds good to me, I think I could get by with that

CW: Would be the type of pointers, of untagged things.

AR: The type hierarchy would become a DAG: there'd be a new type below any, above func and data…

ASC: Depends on what you union i31 with, you might want a union with any?

TL: Sounds like two ideas to explore: 1) adding a new any-but-i31 type to the hierarchy 2) union of i31-and-something-else.

BT: We should try (1) first

AR: Agreed, (2) might not be worth it for the MVP

CW: I'd say we could add (2) whenever we want if the numbers were worthwhile.

BT: What are the criteria to evaluate whether it's worth it? I don't think V8's going to be able to avoid a tag check because of JS null & all that.

AR: Fortunately V8 is not the only Wasm engine, and there are non-JS engines that have more freedom.

AR: Have other Wasm engines now.

BT: Wasmtime has no GC implementation.

CW: Want to point out that option (1) above should be looked at closely, making the type hierarchy into a DAG seems potentially problematic

BT: I think it's a DAG under `func` already

AR: In the presence of structural subtyping DAGs are unavoidable. Do think it's worth scrutiny whether these abstract types need to be a DAG too

TL: Agreed on caution, it could make calculating least-upper-bounds harder

ASC: Going back to the defaultable discussion above, if we had union-with-i31 you could make such a type defaultable with in i31 value, rather than null.

AR: True, but I’m not sure we would want to exploit that.

ASC: It would be useful to have that union and have it be defaultable.

AR: We will have non-defaultable types, e.g. for locals, and that'd make this partially moot.

CW: Non-nullable in Wasm is different that non-nullable for the producer. Producers could define their own default value to use wherever necessary.

AR: Want a sufficiently general solution because this seems like a general problem. Raises question of which default to use if you have a nullable i31.

BT: Summary is that we can probably get away with dropping the dimension idea and adding a pointer type.

LW: Some of the complexity of the DAG came from func <: any. Are any producers using that? Originally it was for func.bind, but that has become more complicated.

CW: Agree we might able to get away without adding anything in the MVP

AR: We could remove the func <: any link…

TL: Time!
"
gc/2021/GC-06-15.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 15 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: June 15, 4pm-5pm UTC (April 6, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: J2CL
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Sabine
- Aske Simon Christensen
- Roberto Lublinerman
- Lars Hansen
- Goktug Gokdogan
- Francis McCabe
- Jakob Kummerow
- Luke Wagner
- Ryan Hunt
- Keith Miller
- Manos Koukoutos
- Rick Battagline
- Ross Tate
- Daniel Wirtz
- Julien Dramaix
- Slava Kuzmich
- Asumu Takikwawa
- Emanuel Ziegler
- Deepti Gandluri
- Alon Zakai
- Igor Sheludko
- Adam Klein
- Petr Penzin
- Zhi An Ng
- Andreas Rossberg
- Zalim Bashorov

### Discussion: J2CL

[slides](https://docs.google.com/presentation/d/19iD1GKxuE04Mm4Q3x5P7K8BTa-B_yA7wbhHjSKHWh-Y/edit?usp=sharing)

AR: understand that you need a downcast, in my compiler, only need it for overriding method, why do you need Object instead of base class, first class that introduces the method.

RL: You’re right that you only need to use the first class that observed the method.

AR: then only need a downcast when you override the method, most won’t need

GG: general case has extra cast, kind of the limitation of represent in Wasm type system, not something we can prove using the current type system

RL: Interface methods will need some sort of general top type because it’s a tree rather than a graph.

RT: seems like you’re using whole program compilation, you don’t even need the vtable unless you have overriding methods

RL: yes, we have a basic model that we are presenting, we have a pipeline of optimizations. Eventually we only have methods that are not overridden. But in the general case being presented, we potentially have an extra casting in the method prolog

RT: surprised that i-table is not stored in v-table, you’re making your objects larger

RL: this is a trade-off, simple change to design and compiler for us, have not tried these experiments. Can trade off extra indirection for some memory in the object. For now we went for the extra memory.

AR: how do you implement cast on array type?

RL: In Java arrays have object semantics. So we have a struct that represents the Array object and internally it contains an array. The cast would be on the struct.

AR: wondering about casts specifically, the cast semantics is different from all other classes, it is the only true generic

RL: at the moment, we have nto implemented the full semantic of casts for arrays. We distinguish between objects and each of the primitive types. Plan is to keep a metadata in the array, that you can check to do the cast. We use a similar technique in JS, keep a metadata to do the cast, and array store exception.

RT: Is your wasm representation of a string array…?

RL: the wasm type is the same for all arrays of references, will be the same wasm struct. We have different for primitive arrays

GG: all array accesses need to have casts

FM: anything you can share about performance

RL: preliminary benchmarks, current performance is not great, is slower than JS performance, 20% slower to 5x slower. But we haven’t done any optimization on our part yet. Normally in JS we have a lot of optimizations to eliminate virtual dispatch and code size. We don’t have any yet in our prototype. Some of it is expected.

GG: we rely on what binaryen provides. We don’t leverage our global knowledge yet. In jS we have a lot of custom optimizations for our code patterns.

RT: for interoperability, if a java class has method foo and you can call foo from JS with the same name...

RL: For interop in J2CL we use annotations that let you mark methods as being from JS. You can use the normal names in JS.

RT: reason for annotation is to avoid overloading conflicts?

RL: we have to mangle names for lowering, we have a pattern for mangling to make the names user friendly. If you have a JS class, you want to be able to call it in J2CL, you can declare it and mark methods, rename methods, can present to Java.

GG: in the J2CL case, it is rich, you can mix and match js and java types, within a single hierarchy, can have hamburgers of types. Which is kind of crazy but useful for migration purposes. Migrated lots of JS code to Java preserving semantics. Very rich, probably won’t need as much, or can’t. For migration you’ll have the same problem, moving boundary between the 2 systems. Annotations change how we emit constructor to fit into ES6. That part is completely hand-wavy in current prototype to make basic pieces work. For something in practice we need something much richer.

RT: I could see JS classes extending Java classes [note: other way?] but not the other way.

AR: scala is more restrictive. Scala.js you have 2 mechanisms for defining scala class, one completely opaque to JS, one that is usable from JS, they are separate mechanisms, don’t think you can mix and match them. A “native” scala class, exported to JS, it is an object with a null prototype, no methods, IIRC. they don’t bother doing any of that.

GG: we had one global optimization that understands both languages. J2Cl was originally GWT, GWT was originally doing opaque objects. J2CL moved to one global optimizer, we didn’t need to have 2 different class structure. We need to handle overloads etc to make semantics work, we didn’t need that 2 class structure.

RT: There are known implementation techniques allowing untyped code to extend typed code, but I don’t know about the other direction.

FM: can you talk about developer experience, someone using J2CL, what’s it like using devtools

GG: there are 2 parts, the debugging side, we have source maps support, that’s more recent and kind of works, but some limitations. We cannot inspect memory, see underlying representation, can’t customize formatters for types. Inspecting strings harder, need to see internal representation of string. Need to understand lots of internal pieces and layout. Wrt development, quite limited, we have limited JS interop, didn’t need something richer.

FM: will be interesting to compare dev ex of someone targeting JS v.s. Wasm. The other is how is devtools for debugging J2CL code.

GG: J2CL case, we develop source maps. Due to limitation of source maps, people end up using original JS code for debugging. In J2CL we have a goal of making our classes to be understandable, part of the design goals. Unlike GWT, was trying to target JS like a binary, cannot debug much. In J2CL case you see ES6 class, method names, mangled but readable, even without source maps, they can go through JS code, they really know what is going on. For people who don’t have much experience on the JS, they use source maps. Generally J2CL is close to hand-written JS code. On Wasm it is totally different. We will see how it will turn out. Right now we are just targeting this, we don’t have a huge developer base yet.

RT: what is some thing that are problematic about compiling to JS that you are hoping will be better with Wasm.

GG: one biggest issue is lack of primitives, e.g. all numbers are effectively emulated with double. Types commonly used like int, we need to instrument them. Luckily it helps V8 figure it is int, but in terms of code size. It affects our interop. Numerics I expect big improvement. Essentially the lack of type information, not well communicated to the engine. We wanted JS with richer type systems, can communicate with the engine. Wasm is a way to reach that potential. Maybe in the future we can look at async/late loading of code. That was built on existing JS concept, maybe Wasm will have first class support for this. See it as a clean start, of what we were abusing in JS.

GG: one other thing that might be worthwhile, the lack of system libraries. In J2CL case, we were heavily using the existing libraries in the browser. They are usually native implemented, performant, already shipped in the browser, doesn’t require downloading. In Wasm case, you need to replicate a lot of things, in most cases they are slower, and add to the download size.

FM: following-on from RT, is there something you’ld like Wasm to have but not on the roadmap? What’s the biggest ask?

GG: multi-threading going to be one of the biggest ask. Right now our customers are looking into Wasm from performance perspective. Whatever we do on JS, single-threaded. Making things multi-threaded will give a lot of ground to innovate. That’s probably somewhere in the roadmap. That’s one of the things that our customers will think of.

CW: this is specifically multi-threading with GC references, right? Are they looking at closed-world compilation, or something more compositional?

GG: don’t know the answer to that. Generally the potential they are expecting. Are they willing to move completely into Wasm. For performance reason yea. If you think about general customer base, different.

FM: you mentioned about dynamic/deferred loading. There’s good and bad news here. Good news that it should be doable. Bad news is that we still haven’t solved the mutual recursion problem of modules. Java is heavily mutual recursive at the class level.

TL: what connection between deferred loading and mutual recursion? What’s the particular interaction that is special to GC perhaps?

FM: not special to GC. you want to partition your java code into pieces that can be loaded dynamically. So long as you can do it in a layered fashion, that’s an additional constraint on the partitioning, can’t have mutual recursion across module boundaries

GG: we haven’t investigate modules in general. Looks like you’ll need to recreate the type system in every module. Sounded like trying to bring a couple of binaries compiled together, want to refer to modules in the loading. Our apps are global optimized, we are looking for efficient way to deliver that app. We don’t have the problem of making types compatible, in our case there is one single type. The problem trying to be solved is different in our case. E.g. GMail, thousands of different individual JS code, incrementally loaded based on different strategies, tooling is automated to split it in a way into small pieces and incrementally loaded. Eventually one of the things we will need, but is different from problem of compatible types. We want lightweight (size-wise) loading, that we know globally before-hand.
"
main/2022/CG-04-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 12 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: April 12, 4pm-5pm UTC (April 12, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Update on [Relaxed SIMD](https://github.com/WebAssembly/relaxed-simd/) (Zhi An Ng) [15 min]
        1. Poll for phase 3
    1. Update on [JS Promise Integration](https://github.com/WebAssembly/js-promise-integration) (Francis McCabe) [15 min]
        1. Poll for phase 2
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

###  Introduction of attendees
Derek Schuff

Deepti Gandluri

Sean Westfall

Yuri Iozzelli

Radu Matei

Sabine Schmaltz

Francis McCabe

George Kulakowski

Yury Delendik

Nick Fitzgerald

Sébastien Deleuze

Sean Jensen Grey

Jeff Charles

Conrad Watt

Ryan Hunt

Rick Battagline

Sebastien Deleuze

Paolo Severini

Jacob Abraham

Keith

Saúl Cabrera

Luke Wagner

Zhi An Ng

Manos Koukoutos

Thomas Lively

Andrew Brown

Mingqiu Sun

Zalim Bashorov

Slava Kuzmich

Andreas R

Peter Huene

Jakob Kummerow

Gordon A

Emanuel Ziegler

Alex Crichton

jlbirch

### Find volunteers for note taking

Acting chair to volunteer

### Proposals and discussions

#### Update on [Relaxed SIMD](https://github.com/WebAssembly/relaxed-simd/) (Zhi An Ng) [15 min]

ZA presenting [slides](https://docs.google.com/presentation/d/1ofBkgbW2AjYM4oayjTPTH3PCbyEn6W-q3GN67qSEigQ/edit?usp=sharing)

CW: when the top bit is 1, is it completely nondeterministic what the result is, or constrained?

ZA: It is constrained to the two possibilities to treating it as a uint8 or an int8

CW: do we expect producers to rely on the fact that the same columns of behaviors are selected for each instruction?

ZA: Min/Max, do you expect producers to rely on picking results from the same column? My intention is showing Min/Max together is that the same column is selected for both, they’re separate instructions. For FMA we want the results from the same column, we specify FMZ in terms of FMS

AR: a similar question: on the other slide (comments) you said that really people are expected to only rely on the last case (rather than the corner cases). Do we need to specify that correlation at all? Compared to what we do with NaNs, we don’t specify any correlations but we thought that’s not very useful. So I wonder why we do that here, what’s the use case? It seems it could have even more relaxation.

ZA: The reason why we chose to constrain is to make it easier to test, and so we don’t have weird values showing up. If we relax it too much, for the first case of relaxed min, we can have a completely unrelated result to show up. We don’t want nonsensical results

AR: you can still constrain it, like we do with nans. But why do you need to specify correlation between the different cases when nobody should be relying on that. I think that actually makes it harder to test, you have semi-defined behavior but you have to test the whole matrix, which seems worse than making it completely unspecified. So maybe less specification is better?

CW: It  still seems that you want the different edges to be one off

AR: right but do you need to specify the correlation? We don’t want to loosen it beyond the set that’s mentioned here.

CW: Does the fact that we specify NaN bits interfere with optimizations?

ZA: I don't think so

TL: on the tools side, we just ignore that and use whatever platform the optimizer is running on.

AR: Maintaining this correlation might be harder,

TL: are you talking about the correlation between FMA and FMS?

AR: The fact that we say for each case we can pick the same column

CW: I think Andreas means the first, 2nd 3rd line you have to pick the same column within one instruction

AR: Why don’t we treat them as sets, and it’s not specified you get the same ones, we don’t care, we shouldn’t rely on these cases. Keep it more loose and limit it to the set of values

TL: it happens in the tools too. I was just implementing these in Binaryen, and what do we do in the precompute optimization. But what if it’s precomputed with different semantics that it eventually runs in. but if we make no guarantees from one execution to another, it would be safe to do.


CW: Semantics that AR was proposing would also reassure me, mixed execution across GPU/CPU or different steppings of the same processor - keeping the strict semantics would be complicated

ZA: These are good points. I think I’ll bring it back to the SIMD subgroup meeting. I’m concerned about other instructions. For min and max it's more obvious that it would work because of the nondeterminism in NaN. FOr swizzle and others it’s not about NaNs and we don’t have existing nondeterminism. So I’d like to see how the subgroup thinks.

AR: In the 0 case, you don’;t have 

CW: If someone somewhere really is relying on this extra specificity, i uges that would be a concern

AR: yeah if someone is, that could be a problem actually.

DG: from the user perspective, I don’t know that anyone is really relying on this, these instructions are used more for performance, and not necessarily relied on for accuracy
We had hoped to constrain the nondeterminism in some way so that the results aren’t completely unspecified. But I do understand the concerns, and don’t really expect too many objections about this in the SIMD group

AR: Would remove implementation defined behavior, and just be non-deterministic which is allowed

TL: for full transparency I actually do expect users to depend on this kind of thing, those who are already looking at engine implementations and looking at what instructions come out. They are already operating below the level of the spec, and we shouldn’t worry about them.

AR: What are the users? Are they tied to a single instruction or engines? How are they working?

TL: The folks working on some of the SIMD kernels for things like video processing are looking at the actual output from V8 and choosing their instrucitons based on that

AR: then they won’t really have portable code…

TL: yes they do this for multiple platforms and choose their instructions accordingly. Which we aren’t thrilled about, but we can’t really stop them either.

AR: Do they probe the user version? Or the CPU version?

TL: yes they are checking the platform and are deliberately going underneath the abstraction that we have. We can’t stop them, but we shouldn’t go out of our way to support them either.

DG: it's not so much that they rely on certain probing hardware, more that SIMD applications usually have existing code for the underlying platforms and when abstracting up a layer they run into unexpected behavior on different platforms

KM: I can’t wait to get a web compatibility bug because of this…

CW: in theory there could be more of an issue if the behavior is more tightly specified than if it's more completely nondeterministic [?]

ZA: One of the reasons we chose fixed projections - when given this input, a particular implementation always returns Z2, when we relax it again - it’s a non-deterministic set of inputs relaxes that further

AR: Why do we want this?

ZA: First I’m assuming that all the instructions would be defined the same way, not all the instructions are specified the same way. Mixing fused/unfused results gives results that could be wrong for the algorithm. You could feature detect ahead of time, i.e. with a module to check if you get fused/unfused results, then you can use that information in the future for a computation

AR: When you say it’s out there, what do you mean? 

ZA: I guess the point of the specification is that we want to be specific about what the results can be. Since we are talking about the spec text we want to be more strict

AR: Do we want implementation dependent behavior? It’s quite a cross roads for the language as a whole, the use case you mentioned if we need to support it, then it would need to be implementation defined

TL: People will do it in practise anyway

CW: Are we assuming that code already exists? Or is this a more abstract concern?

AR: the risk that people will probe is always there, but if we specify it there’s a higher probability that people will rely on it

TL: Tradeoff between trying to guide users to do what we expect and trying to describe and support what users are actually doing. In the case of SIMD, there’s significant divergence there.


AR: For the interpreter I wonder if we should produce all possible behaviors randomize? If you have code you can run it against the interpreter and run it against it to see if it works for some subset of possible input values - we do this for the threads proposal that also has some non-determinism. It increases the coverage especially if we go towards implementation defined behavior.

ZA: Yes, it would make sense to have the interpreter emit a random correct output. It could lead to flaky tests if people run against the reference interpreter.

AR: As soon as the tests are flaky, they have a bug

ZA: How often to people test their code against the interpreter? Might be useful in the engines too

CW: wasmtime fuzzes against it for SIMD instructions

TL: Fuzzers would be very sensitive to the non-deterministic nature of the instructions.

ZA: Most fuzzers check for crashes rather than exact results

TL: Binaryen fuzzer runs on the interpreter, and the Wasm Engine and compares the output

CW: wasmtime also compares outputs.

DG: At least testing the non-relaxed versions of the instructions should be possible. We can add options to allow that.

**Poll:** Move relaxed-simd to Phase 3

|SF|F|N|A|SA|
|--|-|-|-|--|
|4|11|10|0|0|

CW: We should definitely get the story for how to precisely specify the non-determinism straight before phase 4.

#### Update on [JS Promise Integration](https://github.com/WebAssembly/js-promise-integration) (Francis McCabe) [15 min]

DS: I didn’t get this on the agenda 24 hours before the meeting as we usually do for polls (sorry about that). The purpose of that rule is to allow people to know whether they really need to be at the meeting. We seem to have just about everyone present in this meeting that usually attends, and this is only for stage 2, so I think it’s OK to go ahead and allow the poll. If people have objections or concerns that they want to raise, they are definitely encouraged to do that in followup meetings, github, etc.

FM presenting [slides](https://docs.google.com/presentation/d/128Vv-HnqkKDVjSEAP1R3LTnBIVe_4DM93MdIh71R8Ww)

**POLL:** Move JS Promise integration to phase 2

|SF|F|N|A|SA|
|--|-|-|-|--|
|6|14|6|0|0|

### Closure
"
wasi/2023/WASI-08-10.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: August 10 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: August 10, 16:00-17:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Discussion: Preview 2 definition, as presented on 07-27
    1. Pat Hickey: Implementation status update
    1. _Submit a PR to add your announcement here_


## Notes
### Attendees
Bailey Hayes
Pat Hickey
Luke Wagner
Dan Gohman
Colin Murphy
Dave Bakker
Joel Dice
Piotr Sikora
Jeff Charles
Kyle Brown
Toni Bofarull
Matthew Yacobucci
Mikkel Mørk Hegnhøj
Eduardo Rodrigues
Ivan Font



##### Implementation status update

**Pat Hickey**: We’ve been implementing WASI Preview 2 within wasmtime. Wasmtime’s implementation hasn’t reflected the upstream standards very closely. Finally time to rectify this. 

Three PR’s to upstream changes needed found while implementing. 

PR for descriptor-flags: eliminate non-blocking flag, and therefore set-flags, https://github.com/webassembly/wasi-filesystem/pull/125

This is for the same file, we need to expose a stream that can be used in a blocking or non-blocking manner. It does not make sense to have a file opened as blocking or non-blocking. This removes the non-blocking flag. The blocking stream write/read is called, it is up to the implementation to make that operation blocking. 

Set-flags sets descriptor flags. Some operating systems do not support changing the descriptor flags. Since we can’t portably support this, then this is now excluded from being allowed to set-flags. Then due to the above change, there are now no contents in set-flags and this is it’s reason for removal.

We have not seen issues with this removal in practice within Wasmtime.

**Pat Hickey**: Delete preopens interface from package, replace with `wasi:filesystem/preopens`, https://github.com/webassembly/wasi-cli/pull/19. Preopens are more specific to a filesystem than a CLI app. This is now moved to the filesystem package. The initial cwd is moved into the environment package. Now the CLI world imports preopens from filesytem. This is largely a reorganization of content that already existed. Not expected to be an issue.

**Pat Hickey**: Add stream-status to stream write return values, and expand documentation PR, https://github.com/webassembly/wasi-io/pull/38

Any implementation of a pollable needs to fallback on the implementation in the host. Wasm does not have a concept of waiting so needs a host implementation. Adds back-pressure with blocking read. `stream-status` says whether the stream is open or ended. When writing (new in this PR), then if you get streams ended, this indicates that the stream is no longer being read.

If you write to a stream that is open, that is not necessarily guaranteed. We know for a fact that the other end of the stream is not going to read. This optimization seems to be the complement to read-end, and read had stream-status, now write has stream-status.

If the stream has ended, you can write successfully but the stream-status will say closed. If the stream-status is still open, then you will get zero-bytes in the write result indicating that you cannot write more bytes without blocking.

Besides resource-ification, this is the last significant change we have to streams.

**Pat Hickey**: Questions?

**Joel Dice**: Are socket preopens a thing (or going to be a thing)?
**Dave Bakker**: Preopens are not specific to a filesystem. This could refer to any component that needs to be preopened.

**Pat Hickey**: Prepopens exist as they are matching what we had in Preview 1. We desired to change that concept as little as possible as a migration path from Preview 1. The way I see preopens for files, it’s not just that this is a “here’s a file”, it’s a mapping to a path. This is similar to what other pieces of software call a mount, but these are not the same thing. This is why it is not called mounts. Opening new networks or new sockets is a fundamentally different type than what preopens are.

**Kyle Brown**: I've imagined that preopens will eventually evolve into value imports of resources or arguments of an exported function.

**Pat Hickey**: Right, this is the idea that we will be able to talk about values in WIT. WASI-CLI in stdio is get std-in is a function that always gets the same value. We cannot give you a value directly in the component import. This seems to be good enough to write programs with Preview 2, but this is something we want to do eventually. 

**Dave Bakker**: I had not given them much thought around preopens much significant consideration.

**Pat Hickey**: Preview 2 adapter does not support preview 1 sockets functionality to preview 2. This is not really our priority and instead focus on the preview 2 interface. We have yet to find anyone that depends on preview 1 sockets, and preopens functionality going away is an issue. Do let us know if this will impact your use-case.

**Dan Gohman**: This seems straightforward and something we may likely want to do.

**Dave Bakker**: I will create an issue and we can discuss more there. 

##### Preview 2 definition, as presented on 07-27

**Bailey Hayes** We’re still seeing active discussion on the presentations dan made last meeting. So, we delayed the vote to let that discussion continue. A lot of folks are still learning what these presentations mean so we are giving time for that.

**Petr Penzin** What is the actual change in the process?

**Dan Gohman** The core CG process had some ambiguity in their definition of phases (at phase 3 vs in phase 3) so they clarified the entry requirements vs what happens when in a phase for a given proposal. We are just porting that process change from the core CG to our process, to eliminate ambiguity.

**Petr Penzin** The later phases in WASI are not actually defined, whereas they are in the core CG. Not a request to change things

**Dan** This is about communication and clarity - is it confusing to have phase 4 and 5 there without any definition? Well, it shows a parallel structure, and our structure is not finished yet. We’ll discuss what the exact structure we need to finish this standard when we are ready, but its premature right now. The corresponding step to CG phase 4 is standardization. One possible outcome is we do a W3C Req for WASI. We aren’t about to start those discussions but that is an eventual possible path we could take if the CG and W3C are aligned.

**Petr** If we’re using the component model as our vehicle for defining interfaces, it becomes interesting to consider that the component model is not complete yet either. If its just a function definition and not an ABI it can be a convention not a standard.

**Dan** What matters is what a standard means, we want it to mean that many different implementations and languages can interoperate, so we don’t want ambiguity in what the 

**Petr** if we dont use the component model we dont use any new features from it, just existing ones

**Dan** from a process point of view the component model itself will become a standard at some point, it will be separate from the core wasm spec but the idea is it will be published in the same venue as the core spec. The CG publishes multiple specs today: the core spec and the JS embedding spec are separate but published in the same venue

**Petr** What about separate documents that dont require the same process

**Dan**, **Petr** (some discussion lost, notetaker couldnt keep up)

**Luke** in theory the CG and WG is not supposed to standardize anything thats not in their charter, sets the scope for the wasm CG and WG, for example the wasm cg couldnt start standardizing video codecs. The component model is going to be included in the next charter for the wasm CG/WG. WASI, since its IO, its not in the charter because it would be a blank check for any IO. Its not officially in the charter because we need to narrow it down to particular interfaces to be included in the wasm charter. So, the component model is further down the path of being in the wasm charter because it defines pure computation, not any IO.

**Petr** so in the current state of the wasm cg, WASI cannot become a standard because it is to broadly defined.

**Luke** the charters have a time limit, they get refreshed every 2 years, so when that period becomes due we can look at the WASI standards which are ready to be standardized and consider adding them to the charter.

**Petr** escape hatch is you can define the standard to be non-browser implementations

**Luke** that is possible but we also want to see the browsers natively implement some of the WASI standards which make sense for their context.

**Kyle**: I have one kinda detailed question about streams in Preview 2, but I'll save that unless we think it'd be a good use of time. I see a pathological case.

**Pat:** The host is able to optimize this in some situations. When making calls between components, not possible to optimize calls between components. When we first started talking about streams, we knew this would be a problem. Need to make the copy exactly the right amount into the linear memory to make this optimal. The fix for this is to have streams be a lower-level primitive to make this optimal. We have sketched this and think we can do it, but it is complex. We have pushed this out of Preview 2. The idea in Preview 3 is that all of wasi-io goes away where streams live. 

**Kyle**: Do we have a way to mitigate this in the preview 2 timeframe?

**Pat**: No we don’t have one of those right now.

**Dan**: Component to component streams will not be ideal for a variety of reasons. That fundamental lack of async, is more likely a blocking issue. Streams and pollables work as essentially callbacks by the hosts. The expectation is that this will not be a major use-case given preview 2’s limitations.

**Kyle Brown**: Streams are designed primarily for component to host. 

**Pat Hickey**: You can’t implement a poll-oneoff in pure WebAssembly. Any compositions that you do have to be nested such that these are consumed and orchestrated internally or orchestrated by the host. When delegating from the host, then dispatching from the host streams. Guy ran into this with wasi-virt. Wasi-virt has to import all of the pollables from the host and exports those to consuming components.

**Dan Gohman**: Discussion around stream-utils to aid in the wasi-virt type situation. If we have something like that, then we wouldn’t need to virtualize all of the 


"
main/2020/CG-05-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 12th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: May 12th, 4pm-5pm UTC (May 12th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Poll: Propose WebAssembly BigInt<->i64 conversion in JS API for phase 4 ([spec PR](https://github.com/WebAssembly/spec/pull/707)).
    1. Discuss global ref.func initializers complicating validation ([reference-types issue#76](https://github.com/WebAssembly/reference-types/issues/76))
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Adam Klein
* Alex Crichton
* Alon Zakai
* Alshamma
* Andreas Rossberg
* Arun Purushan
* Arun Purushan
* Ben Smith
* Conrad Watt
* Deepti Gandluri
* Derek Schuff
* Emanuel Ziegler
* Francis McCabe
* Gergely Buday
* Heejin Ahn
* Ingvar Stepanyan
* Jakob Kummerow
* JP Sugarbroad
* Keith Miller
* Lars Hansen
* Luke Wagner
* Manos Koukoutos
* Mingqui Sun
* ms2ger
* Nick Fitzgerald
* Paolo Severini
* Pat Hickey
* Paul Dworzanski
* Petr Penzin
* Rick
* Ross Tate
* Ryan Hunt
* Sabine
* Sven Sauleau
* Thomas Lively
* Tobias Tebbi
* Wouter van Oortmersson
* Zalim
* Zhi An Ng


### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Thomas Seconds

### Proposals and discussions

#### Review of action items from prior meeting.

#### Poll: Propose WebAssembly BigInt<->i64 conversion in JS API for phase 4 ([spec PR](https://github.com/WebAssembly/spec/pull/707)).

https://docs.google.com/presentation/d/17hzIr9uGWv4krJC9W9fWhWzx-6jA4rzLkTLKT8leeo8

SS: Only thing missing for phase 4 is consensus from CG

SS: Only thing to mention is no implementation in reference interpreter as this is a JS API feature

POLL: WebAssembly BigInt<->i64 conversion in JS API for phase 4

| SF | F | N | A | SA |
| - | - | - | - | - |
| 17 | 10 | 2 | 0 | 0 |


#### Discuss global ref.func initializers complicating validation ([reference-types issue#76](https://github.com/WebAssembly/reference-types/issues/76))

https://docs.google.com/presentation/d/1EOwIRSpW3kJlSdiR529rIaXXfvzIP221LK5qv8oeGbE/edit?usp=sharing

From the slides:

1. Defer validation of global initializers until element section is read
2. Split off global initializers into their own section after element section
3. Refine allowed targets to include anything specified before code section

AR: 4th option would be to use element section - plug in another kind of section that plugs in ref declarations, not sure that’s worth doing either

BS: drawback is that we already allow those in the elements section

AR: There has to be a special case for the element section anyway - we could limit that section to the compressed section.. This is all kind of making it arbitrary, but any solution here seems to be arbitrary

BS: global init in their own section - global initializers can get more complicated, depend on more info in other sections, might be valuable to do this, think of module as set of declarations, then definitions below

AR: That was my thinking too, right now global initializers are trivial - ref.func are the only ones that allow you to reference other things. This would be a more forward looking solution in a way, it’s also obviously a bigger change.

LW: one argument towards (3), it’s not ref.func that is the problem, we need to know which func global tables can be aliased before compiling code. Everything before code section doesn’t really matter for compiling. E.g. if you have a func in the exports, but another module can stick that in the elements section.
The weird detail is that you have ref.blahs that show up in the code section - we have all the data before this section ..  that justifies how we’re setting up the code section. Three is the least work possible, and it achieves the goal of what we actually want to do here.

AR: agree that 3 is the least work, it makes a number of assumptions about what is relevant for streaming and what is not, what is code and what is not. An argument for (2) is that we don’t know global initializers get more complicated. It’s not clear that’s going to happen, but it would be nice if we did not have to bake in narrow assumptions about what you want to stream (or not). The distinction between declarations and definitions is useful. Globals are the only thing that are mixing these.

LW: If we got to a point where we have loops oin that section, where we want to JIT them, we can figure out what we get to it, I don’t see it be very likely.

RT: Is one option to have func section to have a bit that says if it’s allowed to escape or not.

JS: That’s what the element section is doing, the element section doesn’t happen till the function section… the argument about compilation is strange to me, You could be half way through a compilation, see a large expression.. And it’s back to the same thing

BS: the primary issue is about ordering of the section, so you can do validation in order

RT: If you put the bit in the functions section..

AS: basically the option 4 mentioned, it would have to be a separate thing we have to put somewhere else

LW: To be regular we need it for all kinds of functions that could be refed in the future.

BS: if we had to choose between 2 and 3, 3 seems easier, we consider this to be the env, my concern mostly is, if we extend what global init can do, to include ref func, if we ever get to a point where we have complicated enough initializers, then we add the global init section, and that section can only be constant or ref func.

LW: It really is hard to imagine putting loops in global constant expressions

BS: imagine we add a section that occurs after the globals section, maybe structure definitions, then you need this to validate the global initializers.

LW: If it’s type stuff it should go before the globals section...

AR: more abstractly, the assumption that code gen is the only thing that needs this information may be too implementation driven, though i can’t come up with a scenario that is different

LW: Validation is happy with what we have, we’re talking about an implementation perspective here, we need to know if it escapes to some strange thing

AR: this is now part of the declaration that might come after certain uses, and making the assumption that these uses don’t care. For existing engine and language, reasonable assumption. Is this true in a more general sense? What’s the rationale behind this on a more abstract level. This is just ad hoc, might be the wrong thing in the future.

LW: Worst cse is if you don’t have this implementation detail, you delay the compilation, so it seems like it would only be a problem if we made it be that way...

AR: not just code generation, i can imagine some ways where you want to figure out the layout of stuff in a streaming fashion, and how certain data structures related to each other, you might want to know if stuff can escape, and this can influence choices you make downstream - this might not be limited to code gen by itself

LW: The exports section which is at the end of all the section, also makes a thing aliased, so it seems like you have to see the module environment before you can make any nuanced data structure decisions, and that’s already the case, it’s less than 1% of the bytes, so it’s not like we’re leaving performance on the table

AR: is it still when you have nested modules?

LW: all the module codes go after the code section

JS: we have this streaming validation, and with this, we can’t have streaming validation, need something to refer to information that comes after. Until we actually start to see prologue sections that become large enough to do two-pass / delay, it’s a difficult argument to say we have a problem.

LW: With 3 validation is streaming, it’s only option 1 that makes us wait

JS: disagree, even if you allow it… if we scan a ref.func within global section, we say it’s okay?

LW: Yes, exactly - and any other place that ref.func might show up before the code section

RT: essentially, section 1 through 9, should be viewed as all done together...

LW: They all serve to declare ref.func, anything before the code section will be on the declaring side. All ref.funcs before the code section serve to declare the ref.func.

BS: okay with this, (3) makes it simpler to move this forward, in the future we may want (2), we can still defer it to the point when it is necessary. So it’s only somewhat ad-hoc.

AR: IT will be more ad hoc at that point, in the interest of moving forward, I agree this is okay

TL: have to be arbitrary order as well

FM: The property you want to keep is declaration before use - it seems to me there are tow constraints that will collide - fixed order and declaration before use. If you allow multiple occurrences of the section, you keep the properties that you want to keep

JS: we lose a lot of canonicity in encoding, what happens if two sections say different things

AR: They would just be concatenated. The semantics of multiple sections would not be difficult, but it makes decoding unfortunate, because you can’t allocate data structures ahead of time

LW: validation will be tricky, you have to think about binary section order to see if it’s a valid index.

BS: sounds prone to a lot of bugs, discrepancies between engines.

JS: Sounds like 3 was getting some pretty good consensus there

BS: agree (3) sounds like we’re aligning on it. Worth taking a poll? How do we want to move forward. Can’t really poll cos we did not suggest it as a poll on the agenda. Other opinions in the group?

RH: If anyone disagrees, maybe that’s good enough to move forward, that’s good enough to move forward.

<Silence>

BS: Silence of agreement.

RH: Github issue is on the slide, if anyone still has issues follow up there.

BS: no other items. One last comment i'd like to make. I have a form for the Garbage Collection Subgroup. If you are interested, please go to the issue.

https://github.com/WebAssembly/gc/issues/80

### Closure
"
main/2021/CG-10-26.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 26th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: October 26th, 4pm-5pm UTC (October 26th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Update on [Typed (Function) References](https://github.com/WebAssembly/function-references) (Andreas Rossberg) [25 min]
    1. Update on [Custom Annotations](https://github.com/WebAssembly/annotations/) (Andreas Rossberg) [15 min]
    1. Update on CSP integration (Francis McCabe) [15 min]
       1. Poll to move to stage 2
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
* Sergey Rubanov
* Flaki
* Steven Prine
* Sean Westfall
* Is
* Lars Hansen
* Wouter Van Oortmerssen
* Saul Cabrera
* Yuri Iozzelli
* Rick Battagline
* Zalim Bashorov
* Francis McCabe
* Paolo Severini
* Jacob Abraham
* Keith Miller
* Zhi An Ng
* Alex Crichton
* Minqui Sun
* Asumu Takikawa
* Chris Fallin
* Sam Clegg
* Bailey Hayes
* Emanuel Ziegler
* Andreas Rossberg
* Dan Gohman
* Alon Zakai
* Jakob Kummerow
* Ioanna Dimitriou
* Conrad Watt
* Heejin Ahn
* Nick Fitzgerald
* Arun Purushan
* Ross Tate
* Ethan Lee
* Richard Winterton
* Sean Jensen-Grey
* Deepti Gandluri
* Johnnie Birch
* Thomas Lively
* Pat Hickey
* Luke Wagner
* Dmitriy
* Adam Klein

### Update on [Typed (Function) References](https://github.com/WebAssembly/function-references) (Andreas Rossberg) [25 min]

[Presentation](https://github.com/WebAssembly/meetings/blob/main/main/2021/presentations/2021-10-26-rossberg-func-ref-type.pdf)


KM [on non-defaultable locals]: One possible option is to sidestep the problem - make all mlocals non nullable, and initialize with set. We would need to do a null check after initialization was this considered?

AR: we did discuss that; basically just being the most conservative and not allow non-defaultable locals. It seems like a cop-out, you want to be explicit. References also might not be the only non-defaultable type and maybe you won’t have the option of doing null. RTT for example, reference types weren’t nullable.

KM: You could go back and add this later

CW: There were also some concerns with the  number of as_non_null instructions, some examples had a lot

AR: Also seen my compiler, try to avoid using let instead of nullable locals. When you want to read it or pass it onto a function that uses something non-nullable then you need an additional check

KM: I guess one way to solve would be to leave it on the stack and propagate into your blocks, and pick it out (do we have a pick instruction?)

AR: Doesn’t solve the problem in general, the producer knows it’s not null but has to convince..

KM: I guess you could have a local.get_as_non_null?

AR: You can’t store the information that it’s not null. You want to be able to store something in the additional information that this is not null..

CW: this was just the code size issue could be solved by getting and recording the information at the same time.

KM: Not sure if that’s actually better, let’s carry on

FM: There’s a parallel between non-null and initializing local variables with having data structures that you initialize and want to seal after. The same mechanism should be able to deal with both

AR: I don’t think that’s the case because with data structures, it’s like you forget some type info on a reference (e.g. that it was mutable) but with locals and tables you can’t because their type is global. You can’t really refine the type info.

FM: Yeah, haven’t much put thinking into this

CW: as things are now, I guess we could do something careful with the start function, but if we had first-class tables that wouldn’t work.

AR: Right, the start function right now is orthogonal to typing, and may create some weird entanglement

AT<chat>Igalia has been working on an impl in JSC as well, with most instructions implemented now

LH: on tooling. Do we have tools that use this yet? Are they using it independent of the GC proposal?

TL: Binaryen supports it, but don’t know of anything using it independently.

AR: I don’t know of any either.

LH: Just thinking about what the general priority is

AR: Good question, GC proposal is the obvious proposal, and where it originated. There was a thing that it was motivated by WASI using function references for some things. But not sure if that’s the case anymore, can’t recall other other major motivations

LW: do you mean func.bind or references generally?

LH: Non-nullable references in general

LW: I don't remember any WASI connection on func refs. Maybe the thing was getting typed tables and typed dispatch in those

AR: Typed tables would be good to do to get rid of the type check. Do we think Emscripten/LLVM would make use of that?

LH: do we think emscripten/llvm will make use of that?

DS: might, have talked about using it for vtables, cfi, not strong plans for that

LW: Am.js had typed tables, the FCI cases is great can do analysis on class hierarchy and could do meaningful things

RT: was just wondering also if we should pull it back into the GC. Do we have evidence that typed tables would improve performance?

LW: We saw regressions from moving asm.js typed tables to wasm

AZ: it would also allow better dead code elimination.

JK: re non-defaultable locals, I thought there was interest in exploring control-flow aware tracking first, e.g. if/else initialize locals in both branches, and propagate to the join afterwards

AR: Don’t remember any intent of experimentation with that, if we wanted to do that it should be through block types, we concluded that this would be a conservative and an extension we can add later

JK: IIRC, Aske reported that it would save some instructions

CW: He suggested that there wasn’t much flow based initialized, so wasn’t clear that we would get anything at all

AZ: Tools perspective flow based would be easiest to implement, don’t know how hard block based would be to implement

AR: you have to match flow-based rules from Wasm exactly, that’s kind of the slippery slope there, not convinced that it is actually simpler to do with

RT: You have to do that with blocks anyway, aske also said there were some issues on the generation side if it doesn’t fall into the convenient path

JK: have had it on my to-do list but haven’t got to it

AZ: I hope we do try out trapping at runtime semantically if a non-nullable value is used with a nullable value, should be simpler to implement in the tools

AR: from my POV this solution is equivalent to not allowing non-defaultable, force everyone to use nullable one, combined with the idea that a special local.get that does null check. Not a big fan of this. Local.get should be a register read, no runtime check.

AT: Quick question about JS API, Igalia working on implementing this in JSC. What is the plan in the JS API to create .global and specify a funcref? That is the plan there? 

AR: good question. If we want to allow that then we do need to extend the API. I’m not sure what the value of that would be exactly. In JS you can’t enforce these types, so you’d have to check at the boundary anyway.

CW: What would it look like on the JS side? 

AR: have to cast it, first you have to import it with some concrete Wasm type. From Wasm perspective there are no JS functions, only host functions that wrap JS, which always have some concrete types

CW: If you export the wasm table to JS, what would it looks like? 

AR: API doesn’t allow you to put a function in the table, fixing with the js-types proposal - in MVP you can’t actually do that

CW: Should this be a dependency on that proposal?

AR: Open question whether that dependency should be introduces, not sure how it would be used. Haven’t heard anyone express a need for this

HA: If the validation from local.get is a problem, would it be a solution to introduce another non-local get, and only use the one that needs validation for the ones that need to be non-nullable?

AR: won’t save much, since you have to make the case distinction if the local is defaultable or not, still have an extra branch i think. Also don’t save overhead with block ends where you have to undo the information (or figure out if if you have to undo)

JK: Good idea, if we want to get rif of the validation cost, not sure if it’s worth it, but it does give us the option

AR: the one that requires a defaultable one will have to check too

JK: That’s a status quo, not a regression

AR: currently you don’t need that in the MVP

JK: have to look at the code, remember seeing the code, you’re right in theory you don’t need it, we have it for local def, but not for local get

CW: Might also be an argument in favor of local.init talked about earlier

JK: local.get is the problem, not local.init

AR: End is also in the same ball park. 

AR: we should try to resolve this, have been stuck on this issue for a while

AT [chat]: Thanks for the answer re: JS API. I agree it makes sense to connect it to type reflection. There’s also this issue that with type reflection implemented you need some representation either way when you query an exported typed funcref global, even if perhaps you can’t construct these from JS.

AR [chat]: Yes, good point.

### Update on [Custom Annotations](https://github.com/WebAssembly/annotations/) (Andreas Rossberg) [15 min]

(Postponed to next meeting)

### Update on CSP integration (Francis McCabe) [15 min]

[TODO: slides]

AR: how does this affect the JS API? Rather than just Web API?

FM: we had to add a constraint. Webassembly.compile with  bytes is in the JS api and compile response is in the web API, and they both need adjusting.

DS: Poll for phase 2, not sure if people have opinion if we should go for phase 3?

DG: we also have a full web platform test suite, which covers that requirement, which is the big one for phase 3. So I don’t think that would be unreasonable.

DS: a lot of the changes that usually happen in phase 2 has already happened on the WebAppSec side, comfortable with phase 3 in this case.

Poll for phase 3
SF: 8
F: 12
N: 4
A: 0
SA: 0

CSP advances to phase 3, congratulations!

"
stack/2022/4-4-2022.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 4th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  April 4th, 17:00-18:00 UTC ( April 4th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Elle Imhoff
Derek Schuff
Andreas Rossberg
Ioanna Dimitriou
Lars Hansen
Rick Battagline
Luke Wagner
Deepti
Sam Lindley
Thibaud Michaud
Ross Tate
Petr Penzin


## Agenda items

1. [Opting-in to Stack Switching](https://docs.google.com/presentation/d/1fjnB5zOSCAURZI-mQ44Wpbbsr3yToVICL94oIg4zmSU) (Francis McCabe) 
   A discussion on stack switching & opt-in enforcement.

## Meeting Notes

### Adoption of the agenda

### Discussion

This meeting was [recorded](https://us02web.zoom.us/rec/share/Xi7Abe_UI7rKsJfp2aWArN07sPn8hOeLbv6lfHvlfYbNK5z4t3E2XpvnTZYv6HG2.zLHouWq_BKpwG845?startTime=1649088205000 (Passcode: 6lCscqE%)).

SL: question: is this under the assumption that most code isn’t SS aware? If it were the other way around, would you want to opt-out instead of opt-in?

FM: today you can’t write code that will opt out. I couldn’t enforce any way to have my caller opt out

SL: I guess there are 2 categories [ ? ]. Having to opt-in is more conservative.

[effect type]
AR: I’m not sure I understand the difference to the first approach. If you can just call arbitrary functions… I’m not sure how you can avoid marking every function. It seems like you'd have to track it through the function types

FM: might need to take it offline

End presentation
FM: IMO we need to take care of this problem because it affects the future viability of code written today. ALso it affects the future ecosystem because the people who will have to grapple with this in the future world of lots of interoperable components are least able to.

So 1st question, do we want to do something about this, and if so, what. Do we solve it at the core wasm level or something like a component level.

AR: you started with “what’s good for JS is good for C++”. there’s a dual do that. What’s not bad for JS is not bad for other languages. I.e. it’s an easy trap to just assume that whatever JS has in terms of control is the “natural” thing. Excpetionsa re an example. If you want to interoperate with an EH using language you might assume e.g. whatever you’re calling will return to you. But with EH you might assume some cleanup code will run. But if you donnt have EH it might not. EH is a degenerate form of effect handlers, so it’s a similar problem. We discussed this with EH but you could also discuss with other forms of control flow. E.g. concurrency. If state is mutating concurrently, you get messed up. So it reappears with any form of control flow (code that doesn’t operate how you were expecting gets messed up)

FM: If you are exception awre the sandwich issue won’t effect you, but not aware

AR: yes e.g. if I’m C and I’m sandwiched between a language that throws across me, and bypasses my cleanup code.
So either way your invariants are violated. I think we discussed wrt exceptions and concluded you can’t really guard against in core wasm,you’d need a finegrain effect system that makes everynew form of effect opt-in. On the core wasm level I think we’re accepting there that we have all sorts of effects that could step on you e.g. when you use linear memory to share data. So on this low level tight integration IMO this isn’t a problem we need to or can solve. But on the component boundaries we have interaction between different universes with different assumptions. So it makes sense to try there. It won’t be easy, i’m not sure how.
If the way is static with an effect system, how can you limit it to component boundaries.

FM: currently the idea would be not to have an effect type but strongly limit the possible interactions, dynamically.

AR: that does make sense to me. An exception at the component boundary is basically an uncaught exception  and this would be like an unhanled resume.[
SL: would hti smean adding some functionality to the module/component system. You’d have to specify “this is a component that knows about exceptions”?

AR: no, you don’t allow exceptions to go across boundaries at all

FM: for exceptions. An exception in the callee is mapped to a variant type in the interface, and then remapped to an exception (if applicable) in the caller. So e.g. i fyou’re C calling into C if youre a component, the exception is mapped back to an error type.

RT: does this assume that all languages have an error type like this?

LW: there’s a type in the signature that you can map to an exception or a return value

RT: what is code that wasn’t supposed to throw…

Luke: if you don’t handle if you have an uncaught exception it will trap.

RT: so we have trappging its a commonly agreed upon exception..

LW: more like it ends the world.

[ missed some from SL ] 

LW: future and stream types in IT are like a limited set of effects that limit what you can pass across the boundary

FM: we might need a form of catch_all, 

SL: in typed continuations proposal we have this barrier instruction that catches everything and traps. But in this extension you want to let certain things through because you know how to interpret them on the other side.

LW: right

FM: you’d have patterns that are blessed, eg the streaming pattern. If you want to be able to propagate it out, it would be via such a pattern.

LW: in a month or so Ill present on streams and futures here and in WASI
PP: it looks like there was a presentation [ where? ] on this?

LW: [Aaron? ] gave a high level presentation at the last WASI meeting. It was pretty high level and didn’t have all of the details.

PP: there was an overview of the API. I”ll look in the meetin gnotes.

RT: what about GC languages, which might want tighter integration that components can provide? Will they just have to hope nobody uses stack switching?

FM: GC languages fit into component architecture. Similar situation to non-GC languages, when you convert form one to another it’s a coercion. I don’t think it’s that different.

FT: coercion on all GC boundaries involves lots of wrapping, which doesn’t perform very well. Are we expecting a perf hit for interop?

FM: there is a performance penalty when using components. I don’t think GC makes much difference. It’s the primary arguments for not using IT in components it that it costs too much. For this discussion, this committee would be telling those folks you either want to be able to be safe in which case pay the performanc, or you have to know what you’re doing.

AR: components is based on copying by design, so it doesn’t matter whether its memory or GC.

RT: it sounds like we are saying composability is good and we can support it at components but in cases where we want to pass mutable references with tight integration, we have to give up?

AR: its not different from linear memory when you can’t just pass pointers. If you need that, you have to build tighter integration

LW: also similar to ABIs. if you have a C ABI then everyone intends to follow a single ABI. it’s faster but with shared everything, if you break the rules everything breaks. So you have shared-nothing cross languyage or shared everything and you have to follow the same ABI

RT: … want to import a methods that do the appropriate thing [...[

LW: what ABI are they following? JVM? There’s more to an ABI than just importing the objects and methods

RT: there are conventions e.g. in JS. where you import references and import a JS function that calls a method on the objects. Likewise when you export you decorate it.

LW: so that’s a JS specific ABI that tools can choose to support but it’s not as general

SL: so it’s lowest common denominator, so it seems its inherently poor performance.

LW: yeah when it’s shared nothing you have some cost. Sometimes for immutable cases you can optimize or reduce cost.

RT: so e.g. J2CL, Kotlin, ScalaJS all already use the same JS ABI. so they will be in this situation where you have different GC languages interoping through a JS ABI.

LW: and that’s fine, you can have a JS ABI.

RT: I’m pointing out that you’re saying we should have composability properties for IT but for this ABI

LW:

RT: They use the JS ABI but they aren’t calling into JS directly.

LW: if they go through the speced JS binding, it will enforce this even if it’s wasm->wasm 
RT: It sounds like the answer is that those languages will jstu have to just hope for the best.

FM: to rephrase: we’re telling the developer community that there’s 2 worlds. You know what you’re doing, or you go through the sanitized safe but potentially slow approach with components.
There’s a risk associated which depends on what people do. If theres an ecosystem that’s all based on components, they’ll all just integrate at the component level. If people dont like that penalty (and we’ve heard about that in some cases), then we won’t have a good story for stack switching, since in addition to the copying they also have to be aware of code that will switch underneath them.

FT: you’ll have to wrap every call out with a catch_all and trap and its a question of how expensive are catch_alls and traps going to be.

FM: theres a risk, it’s not really technical, the risk is that we’ll get a perception of being difficult and dangerous to use, like exceptions in C++.  

SL: we have to be careful here. Some calls outside are totally safe, e.g. if you call some mathematical function. You’ll only really have a problem if you passin a callback or something.

FM: that’s true, this is a corner case.

RT: not for OO GC languages, they pass around objects which are effectively callbacks all the time. This will effect viability of the component model for them

SL: yeah if your’e just calling functions e.g. in  math library you’re fine.

FM: if you have 100 foreign modules in your app, you don’t know what the interactions are, it's unreasonable to expect people to know

RT: even the OCaML people are sying they arent just going to allow effects everywhere. Only want it in e.g. system code because they don’t trust users to use them effectively.

SL: that’s a bit misleading. They use their effect handlers such that e.g. an expert implements a library e.g. concurrency, and users of those libraries don’t need to think about them. It will be similar here where you’ll make a library for greenthreads or whatever but most programmers won’t use them. This means they can reasonably get away *without* an effect type system now - though in the future they would definitely like to have one.




### Adjourn

"
wasi/2022/WASI-01-13.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: January 13 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: January 13, 17:00-18:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Plan for the transition from current witx-based APIs to wit and canonical ABI (@linclark)
      - Update on async and streams work (@tschneidereit)
      - Plan for updating wasi-libc (@sunfishcode)
    1. Release snapshot2 w/ `accept()` (@npmccallum; https://github.com/WebAssembly/WASI/pull/458) 

### Attendees
- Lin Clark
- Dan Gohman
- Chris Suszynski
- Saúl Cabrera
- Sam Clegg
- Shiqi Wang
- Luke Wagner
- Piotr Sikora
- Arne Vogel
- Oscar Spencer
- Amanieu d’Antras
- Till Schneidereit
- Pat Hickey
- Harald Hoyer
- Ralph Squillace

### Plan for the transition from current witx-based APIs to wit and canonical ABI

**Lin Clark:** Plan for transition to WIT
1. WIT is ready for proposals that:
    - don’t require async/streams
    - don’t have a dependency on libc 
1. Proposals that require async/streams (such as HTTP) will be unblocked with Alex’s work — expected late Q1
1. Proposals that depend on libc will be unblocked by Dan’s work

**Till Schneidereit:** Luke presented the details for how async works, different ABIs and how streams are integrated. Since then, based on impl work from Alex… area with lots of devils in the details. We’ve come to understand finer details, have simplified the model quite a bit. In particular, Luke and Alex and Aaron Turon have been collaborating on defining the semantics in much more detail. That resulted in some changes to the ABI. Have something that we feel pretty good about. Alex is now updating the proof of implementability implementation. For async, I think we’ll have something to share at the end of the mont**Harald Hoyer:** combination of updates to the proposal and an implementation that demonstrates viability of approach. Will start streams impl after that, since it depends on async. The’eres a little bit more uncertainty in that timing. I think in late Feb, early March time frame. With that, we’ll unblock proposals that don’t depend on libc. At that point, we’ll want to make progress on moving these proposals and rapidly getting them towards stability and production quality. As soon as the documentation is updated, we would encourage other implementations to dig in. One open question is how do we experiment with proposals. We don’t need to change toolchains because we don’t need to change the std libs, so we can start experimenting with these new proposals in a really robust way.

Building on that ,we’ll get back to the libc work. We’re working on unblocking those.

**Dan Gohman:** On the libc front… wasi-fs has been updated to WIT format. Also includes other changes, like dropping the rights system and chmod feature people have been asking for. Next step forward is to port wasi-libc to this API. One of the interesting questions is that we don’t have support for streams. Right now, using a temporary measure called push/pull buffers. One thing to observe is that we haven’t had a snapshot in a long time. Could make people think it’s stable, but that’s why we used the preview terms. When this new fs  comes out, it will be incompatible. We’ll have release docs that explain the compatibility.

**Till Schneidereit:** Will also need proof of implementability, and working on that in parallel. As soon as that, in particular streams, is solid enough, we’ll shift over to implementing that in lower level of wasi-libc. Dependency chains so precise timing is hard, but hope is that it won’t be lagging too far behind. 

**Sam Clegg:** Do we know how many of these proposals are libc-dependent?

**Dan Gohman:** Probably 7 or 8

**Till Schneidereit:** In some ways, those are the much more stable proposals. In many ways, the unblocked ones are the more interesting proposals. Wasi-crypto, wasi-nn, wasi-http etc should all be viable without libc

**Chris Suszynski:** One question about HTTP. I’m wondering about sockets in general. I imagine it’s blocked by …

**Dan Gohman:** wasi-http is not blocked by sockets

**Piotr Sikora:** Do we have a plan for promises?

**Luke Wagner:** Askin gabout trailers? Future type constructor

**Till Schneidereit:** That’s the part that will be ready sooner, right?

**Luke Wagner:** Yeah, part of that same batch of work.

### Release snapshot2 w/ accept() 

**Nathaniel McCallum:** Let me give a little background. While we’re very excited about work on HTTP, streams, etc, our level of pain dealing with snapshot 1 is high so trying to bridge the gap, without getting in way of current work.

Proposing snapshot2 that includes an accept call that allows to accept new incoming connections. … polling for incoming socket events. Runtime preopens socket, Wasm module can poll lon it and can call the accept function to init new file descriptor. Does not violate cap sec because you’re operating on an existing open resource. This would significantly alleviate our pain.  

Invited Harold who’s done implementability prototype.

**Harald Hoyer:** Made a small poc that implements the accept proposal. Also implemented listener fd interface implementation, which puts an already open fd. It all works well. Also added the missing functions in Rust so that we can use Rust natively.

I think the changes to Wasmtime and Rust itself are pretty small, so tell me what you think.

https://github.com/haraldh/WASI-1/commit/21d18effac2d9e8607e23ab99c45c38b43d92ef8
https://github.com/haraldh/wasmtime/commits/sock_dirty_accept-0.32
https://github.com/haraldh/wasmtime/commit/565339672de5c4bb25a976b8fe438937e57d2c1c
https://github.com/haraldh/wasmtime/commit/6d42ef247056913bf0ca58b4b381a111c585fe81
https://github.com/haraldh/rust-1/commit/49516998cd488dc3029f95d2bb903e746a3fa528


I put the fd in the file table, so handled like a normal file. Should be sufficient for a small server. 

**Nathaniel McCallum:** Intent was to just prove it out. We would follow up with an actual implementation

**Dan Gohman:** Test integration with systemd?

**Nathaniel McCallum:** systemd will preopen fd 3 and above, would be up to the runtime to take that and expose it to wasm. Only difference in the systemd case is that the fd is preopened.

This could be a fairly simple patch to Wasmtime to learn about the preopened fd. Could be a really nice user experience to bridge until we get streams.

**Harald Hoyer:** Even a crate for it to pass the whole thing. Not much code. Just have to accept the accept

**Dan Gohman:** So this all seems aligned with what we described before. Seems like it hits a sweet spot, small enough but gets us a big win

**Luke Wagner:** Yeah, nice job finding this fix.

**Sam Clegg:** So if we made a new version of wasi-libc, would all imports be from preview 2? Haven’t made a transition like this in a long time.

**Dan Gohman:** Original plan was do snapshots regularly. Got off track with that. We’re going to abandon snapshot. Should we just modify snapshot in place?

**Till Schneidereit:** THat would actually be in keeping with what we’re planning for WIT. In that world, this would be a minor bump. That might be an argument for saying we’ll do this as an additive thing and still call this snapshot one. I’d be much more uncomfortable with that if we planned to keep snapshots alive. But since we just talked about the timeline for the transition strating in this quarter, I feel like we can get a whole lot of bang for little buck by just adding this to snapshot1.

**Sam Clegg:** Agreed, probably easier not to invent new tooling now

**Nathaniel McCallum:** So I have a question for Dan in terms of timing this update. You just talked about a new release of libc. I imagine we need to get this in before the major changes happen. 

**Dan Gohman:** Yes, I expect it’s not too much work and then we can do a release before we start transitioning to WIT.

**Nathaniel McCallum:** Should we support trad libc address of returning the IP address of the incoming connection. Inclined not to to minimize surface. Tradeoff in that it was based on practice of immediately asking for IP for logging. You were doing two syscalls back to back which had perf issues. That does mean that in layers above like Rust, we’ll have to fill in all zeros.

**Dan Gohman:** Agreed, we can bikeshed on what the IP address is, maybe loopback address. Should fill in dummy now though. 

**Nathaniel McCallum:** Biggest question isn’t address but port

**Dan Gohman:** Address would be what you’d want to log, right?

**Nathaniel McCallum:** Correct

**Piotr Sikora:** Could we use byte addresses so that it’s invalid values?

**Nathaniel McCallum:** Yep

**Chris Suszynski:** I have another idea. We could for example calculate IP and port with algo that is reproducible so that every time you open you would get same IP on module. Hashing would make it reproducible.

**Nathaniel McCallum:** Yeah, I expect the behavor of falsifying this won’t affect most people. Address and port as a key could overwrite. Point is well taken, let’s diff between what committee would need to accept as a standard and what guidance we provide to implementations. 

**Piotr Sikora:** In terms of app env, you can always have option to not disclose or provide. 

**Dan Gohman:** I think we have a pretty lcose approx shape. I think we can take this off line.

**Till Schneidereit:** Any objections to adding this to snapshot 1

**Nathaniel McCallum:** No concerns with that approach.

**Till Schneidereit:** Sam, really glad you brought this up. It would create a lot more churn if we cut a new snapshot. Seems like a really good idea to just add it.

**Lin Clark:** So it sounds like we have agreement here

**Nathaniel McCallum:** Action items, will update pull request with results of this convo and doc a recommended impl, and will then mark as a non-draft so that it can be merged. 

**Till Schneidereit:** Is pull req right venue for the ongoing discussion around IP address?

**Dan Gohman:** Maybe new issue?

**Nathaniel McCallum:** What remains to be discussed? Are we discussing what the appropriate rec to impls?

**Dan Gohman:** Maybe best way to go is for you to put draft text in the PR and then people can discuss

**Till Schneidereit:** Does the plan of record now mean that once no one objects, that PR lands and then we do a PR to wasi-libc, and then a new release is done? Is everything else from here on details and impl?

**Nathaniel McCallum:** For our part we’ll also impl in Rust std lib and wasmtime as well. 

**Till Schneidereit:** That means in terms of recs for implementers, that means working in parallel. Once it’s merged, we can encourage impls to start updating.

**Nathaniel McCallum:** Can have separate wordsmithing for things that depend on libc. Shouldn’t block merge of function
"
main/2017/WG-12-06.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 6th video call of WebAssembly's Working Group

- **Host**: Google Hangouts
- **Dates**: Wednesday December 6th, 2017
- **Times**: 8:00-9:00am Pacific Time
- **Location**: *Brad will email Google Hangouts link to WG members + registered CG guests prior to the meeting*
- **Contact**:
    - Name: Brad Nelson
    - Email: bradnelson@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion of W3C Process.
       * NOTE: All of this is based on Brad's understanding of W3C docs.
         Brad is not a lawyer.
       * [Presention Details](WG-12-06-process.md)
    1. Adoption of CG specification
       1. Discussion of state of the core specification + JS & Web embedding.
       1. Adopting a first public working draft.
          * Ramifications:
             * Starts a 150 day clock on WG members (present and future)
               to notify the group of ""essential claims"".
             * After that 150 days, only new claims based on changes to the
               spec can be excluded (everything else members must license).
             * We have to publish a revised draft at least every 6 months
               after this. It need not have changes, but needs to explain why.
             * When we revise the spec after this point, we have to carefully
               capture a list of what
               [""substantive changes""](https://www.w3.org/2017/Process-20170301/#substantive-change)
               have occurred,
               publishing that in a revised draft. That draft has a shorter
               clock (60-90 days depending on when someone resigns).
             * If we advance from Working Draft to Candidate Recommendation
               and then need to change something, the process resets back to 0.
          * POLL: We should adopt the current WebAssembly core + JS & Web
           spec as a ""First Public Working Draft"" for
           the WebAssembly Specification v.1.
    1. Future meetings
       1. Meeting times + collaborators in Asia-Pacific
           * Discussion of meeting time logistics
           * POLL: We should hold every third video call at an APAC friendly time.
       1. Confirm next meeting date + time.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Opening, welcome and roll call

* Ben Titzer
* Kenneth Rohde Christiansen
* Brad Nelson
* JF Bastien
* Peter Jensen
* Luke Wagner
* Jacob Gravelle
* Eric Holk
* Deepti Gandluri
* Arun Purushan
* Andreas Rossberg
* Conrad Watt
* Michael Holman
* Limin Zhu
* Daniel Ehrenberg
* Derek Schuff

### Find volunteers for note taking (chair to volunteer).

### Adoption of the agenda

BN: Move to adopt

JF: second

Adopted.

### Discussion of W3C Process.

       * NOTE: All of this is based on Brad's understanding of W3C docs. 
         Brad is not a lawyer.

[Presentation Details](WG-12-06-process.md)

A W3C document passes through several stages. We have not yet entered the first stage. Normally there is a first public working draft, culminating in a candidate, and then the document is handed to the WG and they have their own process. There are changes that can rollback the process. [diagram](https://www.w3.org/2017/Process-20170301/#rec-modify) Even though we can move back to the beginning, one enters a small cycle (danger of getting kicked back to beginning). Main idea is that in the working draft phase, the main requirement is to document what has changed. Need to document substantive changes. 4 categories of changes. Editorial changes that aren’t substantive changes; substantive changes do potentially change conformance. The general requirements to advance through stages is that decisions must be recorded, get approval from a W3C director, and have a set a public documents that describe the delta since the previous public recommendation. Must formally address issues about the maturity of the document. Keep documentation on any formal objection. Also try to capture the reasons for the change. 

Q: is the github documentation enough?

BN: This information is really for lawyers. They are concerned with whether they need to revisit any patent considerations

KC: This is why there is a distinction in the types of changes to separate them from the patent change.

KC: [for the WebF manifest spec] There is a tool that checks whether something gets broken and flags. Creates an issue and allows one to mark it as non-substantial.

BN: It looked nontrivial to set [the tool nazgul] up one repository for both CG and WG at the time.

BN: In our charter we listed our dependencies with other groups.

BN: One should also track where implementations are.

BN: There is no notion of previous maturity level required for first public working draft. Once we are in the working draft stage, every 6 months, if there are no significant changes, we are obliged to publish another draft that includes an explanation why no progress has happened. We don’t even need to have consensus to reach this step. Just have to keep capturing what changed and report what has happened since the previous step. All of it is motivated by the patent considerations. The first publication working draft triggers a “call for exclusions”, which require participants to declare the patents required to implement the draft. They have 150 days to disclose this. After this, they must grant a royalty free license for anyone implementing the standard. Someone joining also has the shorter of the original 150 days or 90 days. They have an opportunity to rewind to a previous draft. 

BN: If we were to adopt a working draft now, all participants have to start the clock for their patent investigations. We are also then required to at least update every 6 months.

LW: What is new information here is that only the deltas are able to be considered. What is put out early essentially “times out”

BN: Yes, we have signed a death pact.

LW: Having a chance to read through the entire spec, it reads all pretty good.

DE: I feel comfortable with the JS and Web specs for first public working draft.

BN: There was a mismatch in our expectations about the process. We’re weird that we showed up with an almost done document. They are used to the document first, long before browsers have an implementation.


### Adoption of CG specification

#### Discussion of state of the core specification + JS & Web embedding.

AR: For the core spec, there have been some small typo and note PRs. Non Substantive. Don’t see how we could have substantive changes, considering it is already shipped.

DE: In the JS spec, we may have some substantive changes, in terms of correctness of features that affect conformance. There are a few edge cases, but nothing major, and probably don’t carry much IP content.

BN: We have been operating on the assumption that [no restricted IP is likely needed for wasm in practice].

       1. Adopting a first public working draft.
          * Ramifications:
             * Starts a 150 day clock on WG members (present and future)
               to notify the group of ""essential claims"".
             * After that 150 days, only new claims based on changes to the
               spec can be excluded (everything else members must license).
             * We have to publish a revised draft at least every 6 months
               after this. It need not have changes, but needs to explain why.
             * When we revise the spec after this point, we have to carefully
               capture a list of what
               [""substantive changes""](https://www.w3.org/2017/Process-20170301/#substantive-change)
               have occurred,
               publishing that in a revised draft. That draft has a shorter
               clock (60-90 days depending on when someone resigns).
             * If we advance from Working Draft to Candidate Recommendation
               and then need to change something, the process resets back to 0.
          
AR: The JS spec has not landed yet.

DE: If we wanted to land it after all changes, it would take a week or two.

BN: We could make it contingent upon some set of changes.

AR: I think we should land it sooner and iterate.

DE: I agree.

BN: Revise poll?

<a name=""publicFPWD"">POLL<a>: We should adopt the current WebAssembly core + JS & Web
      spec as a ""First Public Working Draft"" for
      the WebAssembly Specification v.1.

SA | A | N | F | SF
-- | -- | -- | -- | --
0 | 0 | 0 | 4 | 8

BN: We have a working draft!

BN: I will notify the W3C proper and they will send out the call for exclusions.

### Future meetings

#### Meeting times + collaborators in Asia-Pacific
#### Discussion of meeting time logistics


BN: Someone in the APAC timezone would prefer that we have some meeting times more friendly to asia. Last CG meeting concluded that the next CG meeting in Jan would target an asia-friendly time. Things are slightly different for WG. With the CG there was a regular cadence. Clashing with TC39 was problematic. But now we have times for the next TC39 meetings.

DE: Thanks for taking this into account.

JF: Do we have any asia-pacific participants that are WG members?

BN: We do.

BN: We have LG electronics and China Mobile.

JF: How do other WG groups handle this? For the CG we can do what we like, but for the WG we should try to lean on what other groups done.

BN: Generally there seem to be rotations of the time. Not sure how equitable those times are. We could do a rotation. Open to suggestions. With the CG, the primary difference is that we don’t have the strong signal of people in different zones. With the WG, we don’t yet have a regular cadence.

BN: What is the next useful checkpoint? What do Andreas and Dan think?

AR: I will not work much the rest of the year due to holidays.

DE: Might be one editorial change. If we had a checkpoint early next year, that would be helpful. (issue in question is initializing a module calls the start function).

LW: The megafunction needs to be split into pieces.

AR: Came up with another idea where that is not needed. Might get the chance but can’t guarantee.

BN: We are grabbing a lot of IP turf today, the incremental changes are trivial in comparison. 

JF: After this meeting, Brad is sending an HTML document to W3C?

BN: Yes. Correct. There is a draft after with the additional changes.

DE: Suggest a month from now.

BT: Suggest second week of January.

BN: January 11?

(no main objections)

BT: Maybe do the APAC time after that.

BN: There will be a call for exclusions, so that is when people will start to chime in.

BN: Any objections to Jan 11 at 9am Pacific?
(no objections)

BN: At that point we will think about trying an APAC friendly time.

           * POLL: We should hold every third video call at an APAC friendly time.

POLL was tabled.

Happy new year!

*Adjourn*
"
threads/2024/THREADS-07-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 9, 2024 video call of WebAssembly's Threads Subgroup

- **Where**: zoom.us
- **When**: July 9, 2024, 4pm-5pm UTC (July 9, 2024, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/mUp4nmiVUTNQDKcD9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. TLS with context passing ([#42](https://github.com/WebAssembly/shared-everything-threads/issues/42) and [#66](https://github.com/WebAssembly/shared-everything-threads/issues/66))
    1. Thread-bound data [#53](https://github.com/WebAssembly/shared-everything-threads/pull/53)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Ryan Hunt
- Manos Koukoutos
- Ilya Rezvov
- Emanuel Ziegler
- Shu-yu Guo
- Sulekha Kulkarni
- Conrad Watt
- Nick Fitzgerald
- Andreas Rossberg
- Jakob Kummerow
- Deepti Gandluri
- Luke Wagner
- Adam Klein

### Discussions

## TLS with context passing

RH: There was debate around context passing. I got lost in some of the discussion, but the last post from Luke described a design based on linear struct passing. There was discussion of whether the typing rules for context passing are a rabbit hole.

CW: Think back to the way we were discussing non-nullable locals with cross-block initialization. You need a type annotation on every block and control flow join tracking the status. If you have to describe the context shape at every join, then they're basically everywhere. The context persists across functions, so the combination with EH is worse. Doing this correctly gets complicated. Discussed recently with AR and we just kept getting more upset about how to do it correctly. Luke's latest comment doesn't fully work through that and I can write a comment in reply when I have time.

RH: Would the annotations be better if contexts couldn't change within a function?

CW: When an exception is thrown, the context would have to be in a good shape. Exception handlers would need annotations.

RH: Maybe we could put contexts on tags so the thrower and handler agree on context.

CW: Then you can only throw if you know you're going to be caught in a function with the same context.

RH: I was assuming this was very coarse-grained, so a language family would share an ABI, so this would be ok.

CW: You either end up with restrictions such that you can never use contexts unless you know all the contexts, or you put annotations everywhere. There's no in between.

RH: My intuition is that having the consistent ABI assumption would be ok. The context would be very general–a pointer into linear memory or a single GC struct reference.

CW: Do you make it a language-level feature that can't be used without such a restrictive ABI, or do you punt deciding on the ABI to the toolchain? There is a tie-in to the discussion about not having shared functions. We could have shared non-suspendable functions. The question of whether they could be used depends on…

TL: ABI changes. Importing JS tag. Concerned about non-compositionality.

LW: Wouldn't the JS tag have an empty context?

CW: But to allow it to be caught, you need to annotate the block with the context.

LW: Not every block, though.

CW: But arbitrary blocks.

LW: This gets back to how the context can change instruction to instruction.

AR: You need a sound version of higher-order type state.

LW: Doesn't seem different from the operand stack.

AR: But it's cross-block, cross-function, totally global. Needs in and out context type.

LW: If you have an ABI, it will be the same indices everywhere.

CW: Unless you throw a JS exception.

LW: Need trampolines.

CW: But breaking to a block with a different context would be a type error. Requires lots of annotations.

AR: Taking a step back, typing is just one issue. Way too much type overhead and toolchain complexity. I question whether this is the right abstraction in the first place. We understand how to implement linear thread state, but that might not be right for TLS, which is essentially dynamic scoping.

LW: But native code does this fine because registers are context-local state.

CW: But not safely.

LW: Add types to make it safe.

AR: Register analogy doesn't fly because native code can store state on the stack. TLS is bound to a stack.

LW: But you can implement that in terms of something like registers.

AR: Only works when every stack switch goes through a scheduler that saves and restores stack state.

LW: Same with thread-local globals.

CW: Native code doesn't need a type system to make this sound.

LW: If the type system is impossible, then fine, but I don't see it.

AR: It's effect typing. An update to the state is an effect.

LW: Isn't everything an effect in that case?

CW: The reason it's considered an effect is because of the cross-functional nature.

LW: But we're not talking about mutable state, we're talking about passing values around. It's value semantics.

AR: You're talking about threading state updates everywhere. If you model state in a functional manner, you get rid of the effects.

TL: Time out. Conrad has offered to write up a fuller response when he has time.

CW: Exceptions are complicated and we would need to figure out how to paper over the JS tag thing.

AR: We need something more modular.

CW: The other option would be to go whole hog for the effects, and you can alternatively view that as value passing. All control flow needs to handle it.

LW: Compiler will not have issues because it already generates safe code.

AR: But typing it is far too complicated.

TL: Thread-local globals so far have had this peanut butter cost where they make all indirect calls slow because the TLS pointer might need to be updated on every potential instance boundary.

RH: They would similarly make stack switches slow.

TL: My latest thinking is that if we can have a dense vector of TLS blocks hanging off the instance, then maybe we can just do the lookup on each thread-local global access. It will only be a sequence of loads, not a concurrent hash table lookup.

RH: Thought about this implementation. How do you allocate thread IDs? Do you reuse slots? With weak memory, reusing slots might require a barrier.

TL: Good questions. I don't have answers yet. But I agree that paying the cost on every indirect call is bad.

RH: For shadow stack pointer, I imagine it would still be faster to pass it around as an argument.

TL: That would be good to experiment with.

AR: How bad would it be if you just didn't do anything for TLS? Use ordinary parameter passing or effect handlers. There are several options.

CW: That means we're deferring work stealing. We could do the version with shared non-suspendable and use non-shared parameters, but not more.

RH: It could be useful to split the problem between shadow stack pointers and other use cases. Then we could still have shared-suspendable and pass the shadow stack pointer as a param.

SYG: On performance and whether it's good enough to do something naive. It seems analogous to the security thing V8 is doing to sandbox pointers via a trusted external pointer table. It's not all pointers. I assume the TLS stuff won't be for all accesses. The sandbox is a concurrent, thread-safe pointer table that can grow and shrink based on GC pressure. The kind of pointers they want to sandbox on real-world workloads, the overall regression was 1-2%. We're willing to eat the cost for security. Is 1% an acceptable cost?

CW: Even for shared-suspendable functions, we can have something that works. If you have thread-bound functions, the ABI could have you pass in all the thread-bound functions as shared parameters instead of unshared parameters.

CW: We want to do shared functions. It's the new capability for the platform.

TL: Shared structs and arrays are also a new capability for the platform, or at least get WasmGC languages to parity with linear memory languages.

CW: There are three levels of complexity in supporting shared functions. (1) shared-nonsuspendable with only parameter passing, (2) shared-suspendable by adding thread-bound JS functions, (3) shared-suspendable by adding true Wasm-level TLS features. The point being that it would be good to at least do (1) rather than totally giving up on shared functions!

CW: What is the motivation for reduced scope of V8 prototyping? If we had a perfect TLS design, would V8 implement the full thing now?

TL: No, the goal is to reduce complexity, so even with a perfect design, we would still start out doing the minimal useful thing.

AR: But you can't compile vtables without shared functions.

TL: You have to use indices into tables, the same as linear memory languages.

AR: Not parity if you have to fall back to tables. If you had a full GC story, you wouldn't need the tables.

TL: It's functional parity, at least, even if it requires unfortunate workarounds.

CW: Is there a wasmtime appetite to experiment with shared functions? I imagine it would be easier than in a Web engine.

LW: I imagine so, but it's unclear how much effort it would be.

CW: My concern about V8 taking their foot off the gas on shared functions is that it makes the TLS discussion less urgent. Will we be able to experiment with shared functions and TLS in addition to shared structs and arrays?

TL: Unfortunately experimentation will have to wait in V8 since we can only do one thing at once.

NF: Wasmtime won't have cycles to work on shared functions soon, except perhaps for Andrew Brown.

CW: WASI people definitely want shared functions, so are there free cycles there?

LW: Some people want threads, but except for Andrew, they're not contributing engineers. We don't want to bake in instance-per-thread because it is clearly the wrong model in the long term.

TL: We can still make progress at this early stage by discussion, so I'm not too concerned that we won't have implementers for shared functions in the short term.

CW: Two leading candidates are in tension. It can be easy in the type system or in the engine, but we need real implementations to inform the decision.

CW: How important are shared functions for the code splitting use case?

TL: For both wasm-split and dlopen, the benefit is that you can load the code once instead of once per thread. But unfortunately the immediate problem in that space is how to make splitting usable at all, not how to make it fast. Maybe eventually this will be a reason to work on shared functions, but not now.
"
gc/2021/GC-11-02.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: November 2, 4pm-5pm UTC (November 2, 9am-11am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Removing redundant type indexes (Ben Titzer, 15-30 minutes)
    1. Presentation: Waml (Andreas Rossberg, 30+ minutes)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Francis McCabe
- Aske Simon Christensen
- Ben Titzer
- Rick Battagline
- Alon Zakai
- Tim Steenvoorden
- Asumu Takikawa
- Andreas Rossberg
- Zhi An Ng
- Sergey Rubanov
- Ross Tate
- Jakob Kummerow
- Keith Miller
- Conrad Watt
- Michael Knyszek
- Fil Pizlo
- Adam Klein
- Slava Kuzmich
- Zalim Bashorov

### Removing redundant type indexes (Ben Titzer, 15-30 minutes)

[Slides](https://docs.google.com/presentation/d/1THORVnyq3dPH08H_MU0jaFcHYBJ-uNgAH5S9uTZhnZA/edit?usp=sharing&urp=gmail_link)

AR: is this specific to GC proposal, or more general?

BT: it is more general

AR: surfaces mainly in GC proposal, if we want a broader discussion, should take it to CG

BT: yes, planning to present about interpreters in a month or so

AR: wouldn't call it IR, it's just an AST

BT: AST is a form of an IR

FM: V8 doesn't have an interpreter anymore

BT: yea I know, it is moved into test only, think it is a mistake

FM: How do you get O(1) access to the side table?

BT: xip starts at beginning, first instruction we come to will be pointing to the right thing, if the ""if"" falls through, advance xip, if we go to ""else"" will add by value of xip.

KM: if you fall through the if, you just add 4? what about br_table

BT: yea, br_table have table of entries, compute offset into table

CW: what is eip?

BT: end instruction pointer, when you fall off the end you return

CW: this is done per function?

BT: yup. You can go to the function, go to the code, look at the length. But there are a lot of end opcodes, I think this is faster.

RT: for control you have extended code, you can do it for other instructions too right?

BT: you can, but not needed. For example, there are a lot of LEBs in the bytecode that are slow to decode. You could imagine having a decoded i32.const value in a side table, but it turns out LEBs are small in practice.

AR: when you say per bytecode, you mean per struct instruction? Do we have any idea how frequent they are?

BT: Aske has done some space studies,

ASC: struct.get was one of the most common instruction, local.get was the most common, 100k, struct.get with 26k.

KM: in the whole module? or just function or code section?

ASC: whole module. 25% of the most common one, for a 1.5 MB module, 26k struct.get, 10k struct.set.

AR: you wouldn't need to inline these 3 or 4 values each time. You can have the module global field index in the side table.

BT: yea, wouldn't put it inline, it basically undoes the space optimization of making that struct relative

AR: validation gets somewhat cheaper, you have fewer checks

BT: not sure about that until we measure it

AR: not sure how much difference, but certainly fewer check

AR: whether select is a specific case depends on impl strategy, you might consider drop a similar case. Depending on how you organize your stack, you don't know the size either.

BT: The way I did things, it really is madness to consider anything except a uniform value representation.

AR: why does select have a problem?

BT: for an interpreter, what select is pop and i32, look at it, then choose one of the two, copy the tag down, it will drop 1 thing or copy 1 thing, it doesn't look at tag. a baseline/optimizing JIT, whether it is an i32 or i64, it might be in different registers, generate different code, whereas interpreter is tag agnostic. I implemented a version that doesn't keep the tags, right now the tag only used for a precise GC.

AR: maybe I misunderstand that you're saying select is a problem for interp

BT: yea turns out it isn't

AR: agree that memory savings undone by side tables. This is only for interpreters, optimizing compilers will not construct these side tables. Also, it won't be much worse in terms of space usage, it ends up being equivalent for side tables v.s. code. Engine complexity is a fair point, however you need to implement this infrastructure already, you need that one way or another. If you use a side-table, you can at least organize it in a manner that is more adequate to your interpreter, you might gain something there, maybe with lookup time.

BT: The main advantage of having an interpreter is to save space, so making any trade off that uses more space is bad for interpreters.

AR: we're not wasting it right, we are moving it elsewhere. It's not getting worse for interpreter.

KM: it will be dirty memory, in theory your code can be disk-backed.

BT: if field_index was struct relative, it wouldn't be useful to interp, I would store a module relative index, it is wasted information, wasted space

KM: I also think increasing wire size is bad for a lot of things, especially for web apps shipping 50 MB modules, if you make that 10% larger, now it is 55 MB, pretty brutal on slow connection. Not super concerned with side-table, need to keep in mind how hard it is to create side table.

BT: side table only needed for control flow, adding new kind of entry adds complexity. Worst code in V8's Wasm engine is probably in validator, reason is because it is templated, used by 3 different tiers, didn't want to write it 3 times. All the tiers need to piggy-back on the type reconstruction. If you add more things to it to record the breadcrumbs for side-table, it gets worse.

KM: don't find it as true in JSC, curious what it is like for Firefox

AR: one trap we could run in is, considering too specific an implementation and drawing conclusion from it. V8 makes certain choices, some good, some terrible. What should we conclude from that? Do we optimize design around certain implementation techniques?

BT: in practice we also do consider the implementation complexity, part of the impl feedback process. I'm not advocating we do everything exactly for Wizard's interpreter, that'll be a mistake, i've changed my mind too. OTOH, the bigger point is that we need enough immediates in the code so that we can look at bytecode and know how to execute it. That's a property which is useful for multiple different things.

AR: the exact interpretation of that depends on your implementation. An example is the cast instruction should just have the n there, maybe that's the information you need for one impl, but not for another. Same with indices. If we put information there, it is sufficiently abstract to not assume what information engines need to execute something. Have to generalize there a bit, not too specific.

TL: running low on time here, a lot to discuss, take it offline for now, move on to next agenda item.

AR: we have discussed this a number of times, at a f2f meeting we had a decision, fine to revisit, wondering how to make progress. Too bad we can't have f2f, maybe we can start thinking about that soon. This will be easier to resolve f2f.

TL: this comes down to fundamental goals for what Wasm should be and its goals, comes up in GC, also need to get wider consensus from CG. BT presenting on interpreters to CG, might be good to continue discussion there.

### Presentation: Waml (Andreas Rossberg, 30+ minutes)

[slides](presentations/2021-10-19+-rossberg-wob.pdf)

FM: i guess it started as an experiment for you to figure out what it takes to implement an OO language in Wasm. I propose a slight modification. There are times when we have issues with language implementation, vtables, java style classes, dart style classes, which we don't want to experiment with by modifying a java compiler. One possible future for wob could be a platform for making implementation experiments.

AR: first line of experiment is whether the current proposal supports what i want it to support, and how easy it is. Equally, I tried to keep it simple so it can be used as a platform for experimenting with alternative designs

FM: e.g. casting. Know that wob has its own source-level casting, it is of interest only to wob, not other languages. How to deal with wasm-level casting will be of interest.

AR: a slide summarizing wasm-level cast, have a similar one for waml compiler, 3 main places it uses cast, that's a relevant insight you want from experiments like this. What we expected, how bad it is, which casts we can avoid.

RT: for uniform representation, eqref for wob, for waml it's not eqref?

AR: waml also uses eqref

RT: not anyref anymore? 

AR: nope, don't need anyref here. anyref might show up if you have some kind of ffi, if you imported some externref you want to use, you probably want to abstract from externref v.s. language value, then you need anyref

RT: with externref you can't downcast, hard to mix them together.

AR: for the ffi setup you do downcast, but only externally. Internally it's an abstract type, no reason to downcast within Wasm.

RT: for wob, generics, you can't generically quantify over primitives, what happens if you try that?

AR: you need more boxing. In waml you can quantify over every type, you have to use uniform representation in more places.

RT: talking about without changing how you represent values. In some languages, tuple<int, int> stored as tuple int int, if you use in generic code, tuple<x,y>, x and y accesses box/unbox it.

AR: two ways to implement this, run time code specialization, C#, we can't properly do in Wasm.

RT: Tuple<X,Y>. Getting the first field is via a vtable call that returns the first field in the uniform representation.

AR: that isn't about uniform representation, that's about implementing tuples as objects, and abstracting over accessors, uniform representation to me is representing everything as eqref. doesn't imply using vtables, you can, but that's a choice.

TL: will be cool to experiment with these different strategies

AR: agree, limitations to what we can do with current proposal
"
main/2018/CG-10-16.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 16 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: October 16, 4pm-5pm UTC (October 16, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email JF Bastien or Ben Smith to sign
up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. An update on JF.
    1. Presentation: Rust and wasm-bindgen (Nick Fitzgerald)
    1. The `ImportObject` is required for `WebAssembly.instantiateStreaming` and can be difficult to pass in some cases, see https://github.com/systemjs/systemjs/issues/1757. (Sven Sauleau)
    1. [Move proposals tracking to a new proposals repo](https://github.com/WebAssembly/design/issues/1235)
       * We already have this information in tracking issues, and FutureFeatures.md
       * Some people have told us that tracking a repo is less noisy than tracking the design repo/issues
       * POLL: Should we create a proposals repo, and move the tracking issues there?
    1. Function references (Andreas Rossberg)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Alex Crichton
* Andreas Rossberg
* Benjamin Bouvier
* Ben Smith
* Dan Gohman
* Daniel Ehrenberg
* David Piepgrass
* Deepti Gandluri
* Derek Schuff
* Heejin Ahn
* Jacob Gravelle
* Jay Phelps
* JF Bastien
* Keith Miller
* Lars Hansen
* Luke Wagner
* Nick Fitzgerald
* Peter Jensen
* Richard Winterton
* Sergey Rubanov
* Sven Sauleau
* Thomas Lively
* TobinT

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

JF seconds

### Proposals and discussions

#### Review of action items from prior meeting.

#### An update on JF.

JF: Recently Ben has been doing most of the chairing. I think I should step down from being a chair.

BS: We all appreciate the work you’ve been doing so far, so thanks.

JF: It’s important to rotate, and it’s useful to advance things in different ways - it’s useful to step down and let other people lead.

BS: Thanks again.

#### Presentation: Rust and wasm-bindgen (Nick Fitzgerald)

[Nick Presenting] [ slides: fitzgen.github.io/wasm-cg-wasm-bindgen ]

TL: Can we use this for other languages as well?

NF: We could. It’s mostly a question of motivation. None of the people hacking on it now are super motivated to get other languages working. Questions about what the UI would look like in C++. A lot is pretty straightforward. Another front end constructing AST from diagram. We would need another codegen method for C++. It seems clear to me where we would extend it, wasm-bindgen is always going to be written in Rust but could be extended to support C++.

JG: I experimented with this a while ago, opened a GH issue [link]. It’s just a question of the porcelain. We may need a clang plugin or something; or maybe some other tool.

NF: The only parts that need a clang plugin, is the generated stuff that goes from a C++ type to the raw -- the functions that are actually exported. The trait methods themselves could be trait functions in C++.

JG: I think we don’t have enough to do it in a static way -- haven’t looked at it in a while.

NF: It’s progressed a bunch in 6 months.

#### The `ImportObject` is required for `WebAssembly.instantiateStreaming` and can be difficult to pass in some cases, see https://github.com/systemjs/systemjs/issues/1757. (Sven Sauleau)

Links:
- Caching for compileStreaming + instantiateStreaming https://github.com/webpack/webpack/issues/8157#issuecomment-428080190 (+ thread proposal API comment in Webpack)
- Initial issue https://github.com/systemjs/systemjs/issues/1757
- Promise in import object https://github.com/WebAssembly/esm-integration/issues/2

SS: I want to bring this up for systemjs. It is a javascript module system, so it has no compilation step. We want to use instantiateStreaming, but we need to pass import object and you don’t have it until you pass the module and you get the exports section. You have a cyclical thing here. Once solution is to use instantiateStreaming and then use new WebAssembly.Instance, but that is not possible because of Chrome’s 4k limit. We have some other solutions but they are super hacky. We don’t really have a good solution here.

DS: Is it possible to use compileStreaming then instantiate?

SS: If you use instantiateStreaming then it will compile twice right?

DS: But you can use compileStreaming instead.

SS: it still has the limits right?

DS: Only synchronous ones have this limitation.

SS: perhaps this will work. But instantiateStreaming is recommended way to use this --

LW: Have you seen the proposal to allow the instantiate functions to take a promise as import object?

SS: Yes, we’ve seen this.

LW: Would that fix it? Each individual value of the import object is allowed to be a promise -- that’s the proposal.

SS: If you have a cyclic dependency, the promise won’t ever resolve. I don’t think this will work in other cases.

DE: To get around the multiple download issue, can you use WebAssembly.compile, then use instantiate on that? The 4k limit won’t be applied.

SS: If you use compile then you have to download by hand --

DE: I thought you wanted to be able to download yourself so you can parse the wasm binary.

SS: Yes, we could do this with just one stream. It’s a lot of work though… another idea, Alex asked about thread proposal. If you use webpack and spawn a module into main and module into worker. One solution we mention is if we use instantiateStreaming with the same url in multiple cases it will provide the same module. It would be nice to use to ensure this in the spec. Maybe we could do this.

LW: It would be nice to follow up in the GH issue.

SS: [links to issues]

LW: What is issue with compileStreaming w/ instantiate? Other than cyclic.

SS: No issues probably. Thought it may have limit.

KM: WebKit won’t, any browser that does is probably a bug.

LW: Your constraints: you want to be able to inspect the imports? You want to be able to do it purely dynamic?

SS: Yes, this is one of the main issues. I’m expecting other systems will have this issue.

LW: I can imagine new APIs for this… helps in the future but not right now.

SS: We mention adding a new API, but it doesn’t seem right to do so.

#### [Move proposals tracking to a new proposals repo](https://github.com/WebAssembly/design/issues/1235)

* We already have this information in tracking issues, and FutureFeatures.md
* Some people have told us that tracking a repo is less noisy than tracking the design repo/issues
* POLL: Should we create a proposals repo, and move the tracking issues there?

BS: [describes above]

DS: If we do make this the source of truth then we would remove others?

BS: Maybe not remove, but link to.

DS: Currently design repo has two responsibilities: various design discussions as well as tracking new features. Do we need a bigger change here?

BS: I think we could do that; currently design repo exists as a catchall for anyone who wants to comment on WebAssembly too -- we could have a separate repo for that, but it’s a different question.

TL: The point of having a new repository is to allow people to follow the information on GH? If we just wanted info we could just add the chart to the design repo.

BS: Yes, it is kind of a workaround for how GH works -- it’s easier to follow a repository than to follow a set of issues.

DE: I like this idea, it’s easy to follow and I like the information. Having a contributor work on this (Sergey) makes it seem likely that it will be kept up to date too.

[Unanimous consent to move this to a new repo]

Link: https://github.com/chicoxyzzy/WebAssembly-proposals


#### Function references (Andreas Rossberg)

AR: We have the reference types proposal. We have the GC proposal. Another feature is typed function references. It is a relevant feature. This is a question to the group -- whether we should amend one of the two other proposals, or whether to make a separate proposal. I want to push this forward in some form.

This feature is: with GC proposal we add a reference type. A simpler thing is a reference of a particular function type. We could get a function ref that is a subtype of anyfunc. It allows you to introduce a call_ref instruction that doesn’t need to be typechecked.

Should this be a separate proposal or merged into another.

LH: I think we should make it a separate proposal?

KM: Doesn’t a function type per proposal make a lot of pointer chasing?

LW: Tables are static like asm.js

KM: You aren’t going to compile that in, you may compile across multiple workers. So you still have to find the table. If you’re going to IC that, you could IC the type check too.

AR: The use case is different -- the current one is almost exclusively to support C function pointers. The typed functions would be for other languages. If you have a function reference as a first-class then you can call directly without using tables at all. Then tables are just for storing them as opaque types. In the same way that you can store numbers in memory. The use case is a bit different than how you currently use tables. You don’t need to do casts if you know their types.

KM: If you have a bunch of small tables -- if you knew statically the length then it might be ok, but that’s not how they currently work --

AR: This extension to tables is already part of reference types proposal, though.

KM: It seems like we may end up with a number of dependent loads.

AR: The more relevant use case is that you can call a function reference directly, without type checks.

DS: In terms of factoring proposals -- anyref gets its own proposal so it can feed into host bindings. Is this not related to host bindings?

AR: It isn’t probably for JS. It is separate from anyref, but it is also separate from GC proposal, since it doesn't require GC in the same way. It’s useful and independent from GC.  Interesting interferences with GC proposal. Perhaps make a separate repo.

DS: We have sign extension as its own proposal. :-) We did a similar thing on threads, splitting things into their own proposals which logically chain together.

### Closure
"
wasi/2021/WASI-03-11.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the March 11 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: March 11, 17:00-18:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Lin Clark
    - Email: lclark@fastly.com

### Registration

None required if you've attended before. Email Lin Clark to sign up if it's your first time. 

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Presentation: Passing capabilities into programs with Typed Main (Dan Gohman) ([slides] [html files])

[slides]: presentations/2021-03-11-gohman-typed-main.pdf
[html files]: presentations/2021-03-11-gohman-typed-main/index.html

### Attendees

- Dan Gohman
- Lin Clark
- Sam Clegg
- Mingqiu Sun
- Ralph Squillace
- Radu Matei
- Piotr Sikora
- Till Schneidereit
- Johnnie Birch
- Andrew Brown
- Pat Hickey
- Peter Huene
- Sasha Syrotenko
- Yong He

**Dan Gohman:** What is main in this context? The main function. Takes argc argv. You pass in ints, bools, strings, files, network connections. However, on all systems today they are passed in as strings. That’s how they are communicated.

You pass in filename. Program gets string and passes it to the OS. The OS then gives the file. 

This has worked well for past 50 years, but does cause problems. Everyone does command line parsing in their own way. Single letter options sometimes works. Order sometimes matters. Get all kinds of differences.

More important for WASI, child process needs same filesystem view and permissions of the parent. Parent will pass strings to things they can access. It also means that they hardcode how you ask for a stream. This is hardcoding in a particular kind of access. This means we have a dependency on filesystem permissions and filesystem views. We have a coarse grained way to handle this.

What can Wasm change here? We sometimes call Wasm an ISA, kind of true. CPUs have also started converging which is part of why Wasm is possible. But there are some properties that Wasm ____. Memory is a big virtual address space of bytes. Another counterprperty across all systems is that calls are just jumps based on conventions. Syscalls are also based on that property. Arguments go in particular registers. We don’t get this with Wasm. Call arguments are part of the signature. Has implications in terms of emulating Unix. 

Wasm has a static type system in contrast to other ISAs. CPUs will allow you to run any code you want. If they don’t recognize an opcode, CPU won’t determine until that opcode is being run. Wasm in contrast has up-front validation. With a type system, you have relationships that span instructions, so its a very different way of organizing instructions. So we can try to either minimize the effect of the type system to maximize compat, or we could take advantage of the type system and make the most use of it to do new things other platforms can’t do. I think ultimately we want both, but this framework helps us understand how we can combine both.

Quick look at Wasm type system. Like CPU types. Interface Types gives us signed and unsigned ints, bool, lists, variants, records, strings and handles. IT is very abstract so no concrete representation. Handles represent external objects. It roughly corresponds to file descriptors. Over time, we expect that as the Wasm platform expands, we’re going to have more options here, e.g. representing unforgeable handles. At the witx level, we can use the handle type and assume the underlying platform will give us a representation of a handle, and we don’t have to care about the underlying mechanics.

When we have types, we also get signatures. Functions have signatures, and programs are functions. If you look at native programs, what is the signature? Native binaries don’t tell you the signature. Unix deals with this by saying all programs have the same signature: pass in an array of strings and return an int. What if we allowed Wasm programs to have real signatures?

What would this look like in terms of CLI usage? Command line parsing happens in the engine. The program says I want an f32 and the program doesn’t have to parse it. Wasm engines could be local aware and use commas instead of dots. To the extent that we can move this into the engine, we can make it consistent across programs.

What happens if the program has a handle argument? A program wants to have an input file. But in most cases, they don’t need an actual file. They just need something they can read from. So if the program declares it’s going to take a handle and the Wasm engine says that the user on the CLI is going to pass in a string, the engine can convert it. This solves the problem of the child/parent process permissioning. We can launch applications without permissions to the file system. There might not even be a filesystem on this host.

If we can build up an ecosystem of programs that can do this, we can start thinking about composing programs together in a richer way.

This is a cool functionality, but currently there are zero programs in the world that take advantage of this. So how are we going to make this work? There are three levels.

Option A: out of the box. If the developer doesn’t make any changes, we can give the user that experience and make some improvements. We could provide a main function in the toolchain that takes strings from the program.

Option B: provide a witx description. For developers who are willing to do a little work, they could create a witx file that describes the interface, and then a tool could wrap their program with a typed main. That would prepopulate the preopen table. <talk through grep example>

Option C: Typed Main in the source language. What if programming languages would allow you to write a mian function where you specify they types you want. I’m putting together a crate for Rust that prototypes this. Nameless does this. <talks through grep example using Nameless> This works in native programs. Once WASI is ready to do this, we can port this to WASI. If you’re interested in Nameless, it’s up on crates.io. Get in touch if you want to learn more about what it does and how it works. Optimistic we can do this in other languages as well.

Current status: typed main is still fairely experimental. Witx result type is currently in witx tree. Haven’t built tool on top of that yet. New style commands is something that I added to LLVM earlier. Wasi-libc and rust support that now. Interface types are the foundation for many of the types, currently in phase 1 and there’s prototyping underway.

How are we going to use it in WASI. This is something we’ve been waiting for for a while. Currently wasi-clock etc depends on ambient access. But we want this to be a handle that some things don’t have access to, but complication is how do you get that handle into the program. This is a way we can get capabilities into programs. Wasi-random is kind of the same story. Typed main and similar techniques are closely related to having program imports. More generally, this applies more generally to other suggested apis such as serial ports, audio devices, database connectison. With typed main, we can get those capabilities into programs.

**Sam Clegg:** Awesome vision! In the limit, this would remove need for preopen.

**Dan Gohman:** Yes, preopen will still be needed for Option A and B, but Option C will not use preopen. 

**Sam Clegg:** Why is it called nameless?

**Dan Gohman:** because with this, you don’t need to know the name of the file. For example, sometimes you need a filename to get to media type. We could do things with that not using names. In general, we want to avoid filesystem dependencies. They bring in strings, unicode, a lot of details of the filesystem. Goal is to abstract that out so programs don’t need to worry about that. Not thinking about how you turn a string into a file. All of that is factored out.

**Sam Clegg:** So file names is what you’re thinking of, but also handles other types like floats, and probably will get an enum or struct of options.

**Dan Gohman:** Yes. May be more work on ergonomics, but basically all flags would be booleans. One of the fun things that namelses adds on top of that. If a string looks like a URL, nameless has support for automatically handling that URL and giving you a handle for it. You can launch a child process and pipe in the input. Your program doesn’t know were the data is coming from. A bunch of different schemes we can wire up. 

**Radu Matei:** How does this look for reactor modules that don’t use a main function. 

**Dan Gohman:** Related to imports in Wasm. Reactors would probably just use imports for everything. Imports would be provided, initalizer would run, and then reactor would be ready.

**Andrew Brown:** How do you see the relative priority? What is stopped by not having typed main?

**Dan Gohman:** Shared nothing linking. The idea of breaking up a program into components that don’t share underlying state and implied dependencies including implied dependency on shared filesystem state. Shared nothing linking isolates without the giant firewall.

**Andrew Brown:** Blurs the line between library and executables. In terms of other proposals in WASI, like sockets. Are there any dependencies here?

**Dan Gohman:** Sockets proposal in flight has an address pool that is related to the thinking here. It would be provided the pool and then becomes a UI question. High-level for me is factoring it out. Typed main isn’t tied to command line options, so we can package this up in a lot of different ways.     

**Lin Clark:** Switch to Ralph

**Ralph Squillace:** Great presentation! BSD sockets PR stalled, we said we would reach out, had a nice chat. He’s enthusiastic that we reached out and he would like to complete it. My take was that he had a question about what modifications might need to be made yet. Also some awareness that changes would need to be made in the future.

**Radu Matei:** The conversation about the missing APIs were fairly clear. Probably good to go back to original PR and talk through what will change, eg with IO Streams. He’s happy to get back to working on that and so are we. 

**Ralph Squillace:** Over-documentation at this point might be good at this point so that’s the principle that we’d like to stab out in this case. 
"
gc/2022/GC-01-25.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: January 25, 5pm-6pm UTC (January 25, 9am-11am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
      1. Discussion: prerequisite proposals (Thomas Lively, 20 minutes)
      1. Discussion: preparing for phase 2 (Thomas Lively, 30 minutes)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Sergey Rubanov
- Aske Simon Christensen
- Francis McCabe
- Sabine Schmaltz
- Conrad Watt
- Manos Koukoutos
- Ben Titzer
- Lars Hansen
- Rick Battagline
- Derek Schuff
- Adam Klein
- Jakob Kummerow
- Alon Zakai
- Andreas Rossberg
- Deepti Gandluri
- Luke Wagner
- Ryan Hunt
- Emanuel Ziegler
- Zalim Bashorov
- Asumu Takikawa
- Michael Knyszek
- Igor Iakovlev


### Discussion: prerequisite proposals (Thomas Lively, 20 minutes)

TL: Filed an issue against typed function references about merging it back into GC since it doesn't seem likely to ship independently, thinking that it would simplify maintaining the spec formalism.

AR: I’m for keeping it as is, hygiene reasons as well as other dependencies. Better to keep it clean, and unrelated proposals depending on the GC proposals. Even from the organizational purpose, may cost more to try to merge it in than keeping it separate. 

TL: Happy to keep with the status quo if you think that'd be simpler, especially since it'd mostly be AR's work that would be potentially made simpler.

TL: The Type Imports/Exports proposal may be a prerequisite for GC, anything to do with that?

AR: Don’t think it has to be, practically it depends. If we go with structural types with no dependencies, but if we go with nominal types then we definitely need it.

TL: This came up on the eq type discussion, and generally it seems like type imports can leak into other discussions that don't really need to address them. So if they're not needed by the GC MVP proposal, I'd prefer to defer work on type imports and not block any GC work on them.

AR: Agree, if that is possible then it’s a plus.

TL: Anyone else have any concerns about deferring type imports to a post MVP feature?

AR: Technically no dependency either way. In reality, there’s quite a few open questions. Makes sense in terms of timelines. 

TL: Has anyone prototyped or used type imports anywhere?

BT: Have prototyped something, but it’s significantly different from whats there.

ASC: Type dimensions discussion ties in with type imports, so it's relevant there.

AR: That’s an example of forward compatibility. Type imports are just one example. Generics or type parameters have a lot of similarities, the factorization would be similar. Some things are affected, what we want to do are type imports but they are more clarifying structures. 

TL: I'd like to err on the side of not trying to predict the future and be forward-compatible. That is, I'd like the decision to defer work on type imports to imply that we don't have to consider type imports in GC MVP design decisions.

AR: Except that when you p[aint yourself in the corner it will be hard to make it work. I think it depends, don’t want to plan for everything in the future, but it should depend on a case by case basis. Some things may be more clear than the others.

BT: Taking those two in account, I think we need criteria to help decide when we need to design for the future. And I think those should be: are there use-cases? Don't want to build features without use-cases.

AR: I guess everyone agrees with that

CW: There are broad strokes things we still need to decide - type dimensions could be a discussion for after phase 2. 

AR: Agreed

BT: Is it a prerequisite for phase 2 to decide nominal vs structural?

TL: This is the topic for the second half of the meeting. That is the key question I would like to settle for phase 2: however subtyping & identity works, and everything else is smaller details.

AR: Agree, this is by far the most cross cutting decision we have to make that affects the big picture of the proposal. Everyone seems to agree that this is something we should do.

BT: Agree with that assessment, good motivator to settle these questions.

TL: Are there other things people would want to settle before phase 2?

### Discussion: preparing for phase 2 (Thomas Lively, 30 minutes)

AR: Tried to come up with some, not anything that is equally fundamental to this.

CW: Potentially would be nice to have something on separate compilation. So far we've mostly focused on closed-world scenarios, but it's unclear to me if that's because we don't have use-cases for separate compilation or if there were other reasons we wanted to continue to focus on closed-world.

AR: The other thing I brought up was the type annotations story but that could be resolved after Phase 2, how heavily annotated do we want the instructions to be? It affects function references so makes sense to decide sooner rather than later.

BT: Not clear to me whether that needs to be before phase 2.

TL: That's one where we've seen a lot of evidence but we don't seem to be any closer to closing it out.

BT: We have the annotations, or we don't. I'm ok with the status quo.

AR: The status quo is that we have a mix of things: made a decision at the CG to remove annotations, but haven't carried that through the entire instruction set.

BT: MAkes sense to resolve after phase 2. There seem to be bigger issues to resolve.

TL: Can triage issues before phase 2, to close out issues that have been superceded.

CW: Don't necessarily think that separate compilation is a small issue, but I do think we could defer it till after phase 2 if we don't have new data to look at.

AR: More like a meta consideration, it influences some decisions we might make, but doesn’t influence anything directly right now, not sure.

TL: CW, do you see separate compilation as being separate from the type system discussion, where different type system features imply certain separate compilation capabilities?

CW: It’s a question of performance. In a structural world, we’re talking about canonicalization, in the nominal word, name mangling and central coordination work would need engineering work, in the absence of that we could block on Phase 2.

TL: Posted an [issue](https://github.com/WebAssembly/binaryen/issues/4473) on Binaryen around benchmarking the isorecursive hybrid system. My feeling is that if the canonicalization in that proposal performs well (which it should, it seems like it's linear) I don't see a problem with moving forward with that system.

ASC: We want to try out deferred loading scenarios with multiple modules. Partly to see how the iso-recursive system would work. So we have some concrete thing to look at - it’s on our plans,

AR: Is this about expressiveness or performance?

ASC: Mostly expressiveness: how would it work if you had whole-program compilation but creating separate modules and loading them at different times. What works, what falls down?

AR: Makes sense

CW: That sounds like a good thing to have.

TL: ASC we should follow up offline, you might be able to use the wasm-split tool to make that easy.

TL: [reading chat]

AK: [pasted phase 2 entry requirements]: Full proposed English spec text available in a forked repo around which a reasonably high level of consensus exists.

AT (from chat): I don’t think it needs to block phase 2 (other phase 2 proposals like typed funcrefs don’t have a fully hashed out JS API either), but I think figuring out more design details about the JS API would be important once we have consensus on the type system direction.

AR: Originally this was supposed to be spec text, at some meeting we decided to read that as strictly a generally complete english design. We should update the process.

AK: There’s some text below about formal notation..

AR: We should clarify that English text is sufficient.

CW: Certainly true that english text is still formal, and possibly more work to write in the spec itself.

AR: All I'm saying is it would be good to update the process document to match practice. Someone else could do that or I could. Just making a note that we ought to.

AR: The MVP document should be fairly concrete and precise description of the semantics. We have a number of open discussions about what we can add.

TL: Level of detail in the current explainer seems fine when looking at what we've done for other proposals.

AR: Who is owning the JS API right now? Someone was owning that not sure now..
LW: It was a long time ago, don’t mind if anyone takes it over and does whatever they like.

AT: That's a topic I'd be interested in working on. I'm also in TC39 paying attention to the JS structs proposal which is closely related to this.

TL: Agree that, since it would be nice to get to phase 2, I'd rather not block on the JS API for phase 2. And I think that moving the prototyping work forward will give us more opportunity to understand the requirements for the JS API.

TL: Premature for formal polls on any of this stuff. Benchmarking work to do, will come back and give an update on that soon.

AK: Wanted to ask about type imports, is that we want to bring back to the full group to make a decision about the status of that?

AR: Don’t know

AK: IT assumes type imports, not sure if the existing component model depends on it, or anyone in a different proposal depends on it, and would be surprised if it wasn’t moving along.

LW: It’s not a hard dependency.

AR: Why does IT not depend on it anymore? 

LW: Because out spec is layered on top of core Wasm, we can have ""type imports"" at the IT level, but then in core Wasm with the canonical ABI they end up as i32s into a table.

CW: Does this mean that atv the IT level something looks like the Wasm core spec types? 

LW: Yes, we’re working with AR. They’re resource types.

AR: What if you wanted to lower these to reference types?

LW: Could be a future extension
"
main/2021/CG-11-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 9th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: November 9th, 5pm-6pm UTC (November 9th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Update on [Branch Hinting](https://github.com/WebAssembly/branch-hinting) (Yuri Iozzelli) [20 min]
       1. Poll for Phase 3 
    1. Update on Relaxed SIMD (fpenv discussions) and poll for phase 2 (Zhi An Ng) [15 min]
    1. Update on [Custom Annotations](https://github.com/WebAssembly/annotations/) (Andreas Rossberg) [15 min]
       1. Poll to move to stage 4
1. Closure

# Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

### Introduction of attendees

Deepti Gandluri

Steven Prime

Andreas Rossberg

Francis McCabe

Chris Fallin

Bailey Hayes

Lars Hansen

Zhi An Ng

Alex Chichton

Keith

Yuri Iozzelli

Sam Clegg

Rick Battagline

Paolo Severini

Ryan Hunt

Sergey Rubanov

Zalim Bashorov

Alon Zakai

Jaco b G

Andrew Brown

Yuri Iozelli

Dan Gohman

Conrad Watt

Thomas Lively

David Piepgrass

Sean Jensen-Grey

Ben Titzer

Dmitriy Bezhetskov

Mingqui Sun

Radu Matei

Slava Kuzmich

Jakob Kummerow

Asumu Takikawa

Intel Seven

Paul Shoenfelder

Petr Penzin

Peter Huene

Nick “fitzgen” Fitzgerald

Heejin Ahn

Ross Tate

Arun Purushan

Emanuel Ziegler

### Find volunteers for note taking

Acting chair to volunteer

### Proposals and discussions

#### Update on [Custom Annotations](https://github.com/WebAssembly/annotations/) (Andreas Rossberg) [15 min]

[Presentation](main/2021/presentations/2021-11-09-rossberg-annotations.pdf) on Custom Section Annotations by Andreas Rossberg

AR: Motivation is that binary format has support for custom section, but want to be able to represent something similar in the text format

BT: Free form, but should braces be balanced?

AR: Yes, almost free form. Needs to be parseable by tools that do not understand that specific section. The syntax is a sequence of tokens, which can include parentheses inside string literals

Keith (in chat): Do we specify an encoding for the strings?

Francis(in chat): what about connecting the text annotations to custom sections

DP (in chat): It sounds to me like the syntax with the byte-sequence should be part of the Wasm standard rather than merely an ""example"" as the slide says

BT (in chat): The text format allows strings with escaped byte sequences At least in .wast So binary tests (.bin.wast) have modules that are specified in binary as strings with escapes

JG (in chat): I think there's a symmetry between the custom annotations and custom sections, so any ways you can go wrong with one you can go wrong with the other
which is to say, we already have the problems of annotations in the binary format, so it's already something we're living with

YI: Interested in the discussion about testing, similar to branch hinting. Same problem, no way to add tests for Branch hinting in the current ecosystem. Should I be addressing this? Interesting problem, glad we’re talking about it

AR: We should decouple from specific problems, who would be willing for the volunteer? 

FM: What happens if an engine has implemented an annotation scheme, someone is using the annotation scheme but in an incorrect way. 

AR: Same as custom sections, the spec is clear that engine should not reject a malformed custom section. If there’s a malformed custom section it should ignore it, but not reject the module. Similar pattern expected for malformed annotations. You shouldn’t refuse to consume the module. 

PP: Can you easily reject a malformed section, in a binary it doesn’t apply, in this case you would read it and may need to compile the module differently. Other languages could support these type of annotations. This would be ok to do with the text format

AR: Yes, and no. Text format is the textual representation so it should be equivalent. Annotation shouldn’t modify the semantics of the semantics of execution, so should be ok to ignore

FM: that's unrealistic

AR: depends on what the tool wants to do, less clear cut with text format

FM: suppose i'm compiling java, suppose i'm using annotations to fill in the gaps that Wasm can't support, like names. A tool expecting java like Wasm is expecting to see those annotations, expect them to follow rules

AR: if you are a tool dependent on certain annotations, then you can't do much if you don't understand them. If there are other custom annotations you don't understand, you should sitll ignore them.

AR: Ultimately tools are free to whatever they want to do with it, it’s

DG: Does anyone block phase 4? 

LH: Mild objection as it looks like we need more discussion, with respect to the tests as well as what happens when we encounter a malformed annotation. We pushed YI pretty hard on tests, and the same standard should be applied here as well. Could use more discussion.

<AR Agrees to move poll to next meeting>

#### Update on [Branch Hinting](https://github.com/WebAssembly/branch-hinting) (Yuri Iozzelli) [20 min]

YI presenting [Slides](https://drive.google.com/file/d/1f5DYBKcSMkqSaCX9lhzlyTD5dVOkak-7/view?usp=sharing)

KM (in chat): Should be trivial for JSC excluding the interpreter (in response to how tricky is this to implement in engines other than V8?)

BT: (in chat) Won’t really help in an interpreter IMO, So can just ignore the custom section In contrast to the constant time proposal, which also needs to be supported in the interpreter, where we decided to have new instructions

LH (in chat): I don’t think Firefox has a good notion of hot/cold code at this time, would need to be added to support hints

RW: Have you done any workload testing, where you have some data from workloads. 

YI: Test using CheerpX (extra benchmarks slide), compared benchmarks with/without branch hinting. Testing is not easy because in general branch hinting is not needed. Native programs don’t also always have them. But for some applications it doesn give 10-20% speedups

RW: Is this from CPU speculation?

YI: Definitely not, if V8 knows something unlikely to be used it doesn’t need to put it on the stack

RW: Is the workload publicly available? 

YI: Had it uploaded, can add it again. <LINK: https://repl.leaningtech.com/benches/index.html>

PP: Tool is proprietary

YI: Tool is not open source, but the compiled version can be analyzed as needed. Can test with/without flage

PP: Is it correct that it’s an x86 binary transpiled to Wasm

YI: There’s a jit compiler inside that generates the Wasm

PP: IT’s not the most common usecase

YI: Agree, not commonly, it’s not useful in some cases

PP: Tools eliminate this behavior, will this mean that this was already addressed? 

YI: < PHASE 3 slide> The idea is that other proposals use custom sections in the same way with similar instrumentation, tools may not be able to keep up with different formats. If all the proposals stick to the same format, the cost of having a common framework will be shared

RW: We’ve changed the implementation to match this format
    
PP: Code annotations can indicate which custom sections are malformed and throw them away, how does it do that

YI: if tools start adding support for code annotations, then i expect the ecosystem to understand these annotations in general, e.g. wabt can understand any annotation after i added support. For wabt it is easier than binaryen, since binaryen is changing the module. You can add support for parsing them, and add support to its IR.

YI: POC of adding a code annotation in llvm (very partial but to have an idea on how it could look like): https://github.com/yuri91/llvm-project/tree/annotations

**Poll** Branch hinting to phase 3
    
|SF|F|N|A|SA|
|--|-|-|-|--|
|7|18|6|0|0|

Congrats to branch-hinting proposal for Phase 3

#### Update on Relaxed SIMD (fpenv discussions) and poll for phase 2 (Zhi An Ng) [15 min]

[Slides](https://docs.google.com/presentation/d/1zyRqfgGU7HdoVw9QiKaVYifozbytPhNLHUW9jQjPzLk/edit?usp=sharing)

CW: How robust do you expect this to be if there’s a new architecture comes up? 

ZA: That’s not realistic at the time, because ti might be hard for Wasm itself to support

AR: I thought the text was saying each result is specified as lists of sets, should it say list and not a set as it is unordered? And each element in the list can be 

ZA: That’s correct

CW: Do you think in practise people will rely on having results picked from the same column?

ZA: Yes, example is the fuse operations

BT: IS it correlated across different instructions, i.e. are there families of results? Across different instructions? 

PP: That’s more per architecture, not family of instructions

BT: Does that need to be in the spec that you would get this column or that column across multiple architectures

ZA: Don’t think so - that’s not necessary, for example we only want fused or non-fused. Right now the way we specify it doesn’t cross instruction bopundaries
DaG: Some instructions have that correspondence right, we should label it

ZA: We would have to label it in some way yes

AR: We could get away with funneling similar operations across in some way

ZA: Besides FMA AND FMS there won’t be other combinations so we won’t want 

DaG: Min/Max also come to mind

LH (in chat): Preventing the migration is sort of the point though, that was the point of fpenv and this is the child of that

ZA: It’ll be weird that architectures do that, we can have a meta instruction that does that. The broader idea is that the results don’t jump between the two columns

PP: Pseudocode in the overview has what is supposed to happen, and what is implementation defined, there’s much more detail there.

ZA: We don’t really want implementation defined results, that’s what we’re trying to fix here. We want it to be defined

PP: The text will be only different in some cases, -0, +0, NaN etc. Very narrow cases

RT: You can say implementation defined up to a certain point

ZA: That’s what this column is doing

PP: This is still fine in that direction

RT: Where things get weird is, out of these two columns there are two independent choices, but now you’re saying they’re correlated choices. One is consistency across discussions, constrained implementation defined ness

NF (in chat): idle thought: this would preclude live migrating a wasm instance from x64 to aarch64, since the wasm could observe the difference in results of these nondeterministic instructions
or even using something like Wizer (https://github.com/bytecodealliance/wizer/) to initialize a Wasm instance on x64 and then run it later on aarch64

POLL: Relaxed-simd to Phase 2

|SF|F|N|A|SA|
|-|-|-|-|-|
|10|6|7|1|0|

Congratulations to relaxed-simd for advancing to Phase 2! 

ZA: Reasons for against votes? 

DaG: Just in terms of priorities, adding non-determinism

### Closure
"
main/2020/CG-06-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 9th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: June 9th, 4pm-5pm UTC (June 9th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Update on Module Types / Module Linking proposal ([slides](https://docs.google.com/presentation/d/1Cz4yopK-V6PIq7JMJiRNUWlDlHLTnIvwhdetP5QBVL4))
       1. Poll: Rename ""Module Types"" to ""Module Linking"", broadening scope as proposed in [PR #3](https://github.com/WebAssembly/module-types/pull/3) and advance proposal to stage 1
    1. Discuss numerical values in data segments proposal. ([discussion link](https://github.com/WebAssembly/design/issues/1348) and [semi-formal description repo](https://github.com/echamudi/numeric-values-in-data-segments-wasm-proposal))
    1. Discuss removing type annotation on ref.is_null ([issue](https://github.com/WebAssembly/reference-types/issues/99))
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

Wouter van Oortmersson

Jacob Mischka

Ezzat Chamudi

Zhi An Ng

Francis McCabe

Luke Imhoff

Lars Hansen

Rick

Deepti Gandluri

Ben Smith

Thomas Lively

Paolo Severini

Jay Phelps

Zalim

Arun Purushan

Nabeel Alshamma

Conrad Watt

Alon Zakai

Pat Hickey

Ryan Hunt

Pat Hickey

Alon Zakai

Ross Tate

Heejin Ahn

Flaki

Jakob Kummerow

Michał Kawalec

Clemens Backes

Luke Wagner

Derek Schuff

Alex Crichton

Sven Sauleau

Till Schneidereit

Adam Klein

Emanuel Ziegler

Richard Winterton

Manos Koukoutos

Andreas Rossberg

Sam Clegg

Gergely Buday

Dan Gohman

Petr Penzin

JensenGrey

Mingqiu Sun

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Luke Imhoff seconds

### Proposals and discussions

#### Update on Module Types / Module Linking proposal ([slides](https://docs.google.com/presentation/d/1Cz4yopK-V6PIq7JMJiRNUWlDlHLTnIvwhdetP5QBVL4))

[Luke Wagner presenting]

<Binary format slide> 

AR: That might not work for type imports

LW: You're right about that, but for existing things like Functions it could work. That's why I put a ""perhaps""...

<Back to slides>

RW: You said that a child module could inherit permissions from parent module. How is that protected? Can I write a rogue module and inherit it?

LW: Inherit might not be the right word, it’s explicitly passing capabilities - the child can ask for anything, but the parent has to choose to give it to the child module - more like function arguments

RW: I would ask for it as a child, and then the parent would ...

LW: <Explaining with Link-time virtualization slide>

RW: Makes sense.

FM: In JS land, it’s important to be able to know whether you have the original of something...

LW: That was a contentious statement in the get-originals proposal... but then there were security implications there. But then it was decided that you could ask for the originals, but wouldn't necessarily get them. Then the proposal was set aside for the time being.

FM: So this is important in cases where the application is not in complete control of itself - if you go upto a browser extension, that has loaded some code that ahs virtualization capabilities, and injects some nasty stuff - that’s probably the business use case for it

LW: I think in the web discussion; they said that if you run first, then you get control of whatever runs after you. In JS, it's because you can monkey-patch the global. So if you need to be in control, you need to be the root. But if you're a random wasm module that means you can't necessarily be the root. It's at odds with virtualization.

FM: Maybe.. A compromise is to have some signal saying you have been virtualized or something like that

LW: It's worth discussing ...

FM: The thing about running first is problematic because you don’t always know..

LW: It's the web developer who writes the document that can make the choice.

FM: The CDN gets...

LW: It's a good question.

FM: In Java class loaders it's arranged so that you cannot override the definition of your parent class loader... e.g. a definition of String, any class loader that's loaded by defining one for String cannot override String. The reason for this was security -- it makes it awkward to use though.

LW: One thing we have to sidestep is that we don’t have a global mutable state that’s shared by different modules, that’s probably a partial solution at best..

PP: Out of scope perhaps, but potentially you could make a standard library functionality that the library could depend on. You can imagine a situation where a module comes from a library with a different toolchain, you may see mismatches like we see in the native world.

LW: When you can make your own instance, it’s okay to have two modules that import different C-libs.. It gives us new levers, if everyone imports the same libc, then they have to agree on the major version, but otherwise..

PP: Is there a way to check the version?

LW: You can say in the string, you could put the version in the string, and the type captures semantically what you depend on, and those two things are the signal to the outside world.

LI: This was listed as feature work,(Explains with Erland example) but can this exist outside the browser - will this allow for replacing yourself? Kind of doing it yourself..

LW: Not as some intrinsic feature. But if you had a dynamic instantiate API you could implement that transfer of state at a higher level. But not as an intrinsic.

LI: We’re fine without become, we just have to write so much JS glue code, but it would be nice to do it just in Wasm

LW: That may be a more advanced future use case. For now, all the instantiates are declarative. A compiler could look at this and generate everything. It's a later feature to have runtime instantiation. Current proposal doesn't allow this as at all. First class instantiation requires GC, since you can make cycles, and we don't want to require GC for something like dynamic linking.

LI: Going back to prev conversation - an objection to virtualization check is that checking if you’re in virtualization or debugging  is how viruses hide from anti-virus software

LW: It would break various abstractions that you would otherwise have.

RW: Yeah, if you can replace yourself, then you could be replaced with a rogue module... I'd be nervous about that.

LW: Not sure what replace would look like…

RT: When you have commands like instantiate - they’re stateless correct? If you run instantiate for example,

LW: The start function gets invoked as part of instantiate...

RT: You may want to think about delayed start so you can run a bunch of these in parallel

LW: The resource allocation... the runtime machinery can be parallelized before start functions fire, but once you do one, you need a specific order. For AOT compilation, where you can parallelize these...

RT: Something to think about.. You could divide it into phases.. Given this can I get exported types, or a pointer to that without instantiate to speed this up

LW: Definitely compilation can happen eagerly... and instantiation is supposed to be cheap in wasm, so in theory we're OK. But yes, we should be mindful of this. That's why it's currently declarative.

POLL: Poll: Rename ""Module Types"" to ""Module Linking"", broadening scope as proposed in PR #3 and advance proposal to stage 1

SF|F|N|A|SA
--|-|-|-|--
17|14|2|0|0

#### Discuss numerical values in data segments proposal. ([discussion link](https://github.com/WebAssembly/design/issues/1348) and [semi-formal description repo](https://github.com/echamudi/numeric-values-in-data-segments-wasm-proposal)) 

[Ezzat presenting [slides](https://docs.google.com/presentation/d/1C_2ZdVep_kt2BZmpLiRJ7VgqFXUG8gUgGUORLghdAGE/edit?usp=sharing)]

PP: I think it's a good idea, good for developers. Right now, if you want to understand the text format with floating point numbers, it's pretty hard.


CW: Is there any change to the binary format? If you convert back to the text format from binary, will you lose the changes?

EC: There will be no changes in the binary specification - maybe we can still convert back to the normal thing - in the binary ithe type isn’t mentioned they’re flat numbers

JP: It could be in a custom section if you wanted it to.

WVO: Is there any alignment applied?

EC: For now no, it’s another way to specify string

LI: Should it error out if the literal is outside of the range?

EC: In my demo it’s an error for now

LI: Sounds good.

RT (in chat): Consider signed vs. unsigned

BS: wanted to get more people aware. We did not explicitly state there this is a poll, but perhaps implicitly.

DG: we should have the poll on agenda before we poll

TL: adjust rules for phase 1 poll, since the bar is lower

BS: yea, probably discuss next time. Follow our rules right now.

#### Discuss removing type annotation on ref.is_null ([issue](https://github.com/WebAssembly/reference-types/issues/99))

[Slides](https://github.com/WebAssembly/meetings/blob/master/main/2020/presentations/2020-06-09-rossberg-ref-type-annotation.pdf)

<AR Presenting slides> 

<on proposal slide>

CW (in chat): I think the type should be [<reftype>] -> [i32]?

LW (in chat): Also select is only polymorphic over numerics, iirc

LI: Is this considered a breaking change?

AR: Not a breaking change, the proposal isn’t a standard - it’s new in this proposal that changes the binary format

LI: If you are using the feature in browsers that have implemented this already, then it will be breaking.

AR: Yes, you have to assume there can be breaking changes before phase 4. 

TL: Can we do a straw poll to gauge interest?

AR: Implicitly this is saying that we are betting on the future that we won't need type annotations for this sort of instruction.

FM: How certain are you that we don’t need type annotations for those instructions? 

AR: As a general rule we will not require it on every instruction. There still are instructions where this will be required. For example, select has a principle type, so it needs a type annotation.

LW: We made the existing select change, this is just following through with that. 

AR: Yes, in a way this isn't something new.

[no objections to straw poll]

AR: Let's move forward assuming that the poll will go through; so implementers can make progress over the next two weeks, then ask for formal poll and phase 4 poll at the same time.

[no objections]

FM: Process question - what is the criteria for needing a formal poll? Does a change to a proposal need a Poll? Or is it just for proposals?

At time, moving the discussion to github/next meeting. 

### Closure
"
wasi/2021/WASI-05-20.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the May 20 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: May 20, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Lin Clark
    - Email: lclark@fastly.com

### Registration

None required if you've attended before. Email Lin Clark to sign up if it's your first time. 

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Impact of the canonical ABI proposal on WASI ([slides] [html files])
       - https://github.com/WebAssembly/interface-types/pull/132
    1. Collecting documentation and standards for ""classic commands""
       - https://github.com/WebAssembly/wasi-classic-command

[slides]: presentations/2021-05-20-gohman-canonical-abi.pdf
[html files]: presentations/2021-05-20-gohman-canonical-abi/index.html

## Notes
### Attendees
- Lin Clark
- Sam Clegg
- Daniel Wirtz
- Piotr Sikora
- Dan Gohman
- Andrew Brown
- Mingqiu Sun
- Petr Penzin
- Johnnie Birch
- Daniel Wirtz
- Saul Cabrera
- Pat Hickey
- Luke Wagner
- Ralph Squillace
- Yong He
- Till Schneidereit

### Canonical ABI impact on WASI
**Dan Gohman:** Luke gave a presentation about lightweight component model. How do these relate to the core spec model. Luke has great slide on linking dynamism. Question of do we put in core spec. LW component model is saying we’ll put it in a new layer.

Comp model gives us all the great things in Wasm. Just imports and exports, really great property. Sandboxing and port comes with that. But Wasm Doesn’t have perfect story for black box reuse. Linear memory is often exported, but that’s often dependent on toolchain you’re using. Hard to know how organized if you don’t know what language. Idea for a long time of abstracting this (e.g. sharing slice). Would be somewhat more organized, but the slices has problems of lifetimes. Without any knowledge of how long the slice lives, hard to deal with this. CM solves this using IT and shared nothing linking. Shared state is shared in very tight boundaries. This gives us much more flexibility in defining interfaces between modules.

Another recent PR is canonical ABI proposal (in IT repo). IT has this type system, types like list, variant, string, signed/unsigned ints. Canonical ABI lowers into core wasm types. This has a number of ramifications. Allows us to move forward with IT before adapter functions are ready. Adapter functions can create optimized bridged between internal types and IT. We’re looking for a way to move forward getting a lot of benefits without waiting.

Canonical ABI also gives WASI a way to support engines that don’t support IT.

Two big concepts in IT are handles and resources. Handles are abstract handles, unforgable. These come across as i32 handles that are indices into a table. In the future, we’ll switch to C-ABI, but now we’ll have a more rigorous foundation.

[Example of wasi-io read function]

Can say that handles are at a layer below us. This will turn into a param of i32 handle. WASI won’t have to think about how things work, e.g. strings.

Another major concept is buffers. This is a new take on memory slice problem. Gives us a clear lifetime. Temporary views on memory buffers. Lifetime of the call. Pull buffer is read interface. Write is a push because. This solves ambiguity. Only valid to use within this call. Essentially like a borrow.

One unfortunate side effect: doesn’t support vectored IO. Question to answer: How important is it to have vectored IO?

So handles and buffers are the two main interesting concepts. With this, we can just focus on being an API instead of how to lower.

WITX is evolving into an IDL. Can describe core Wasm types, components, and components with full adapters. This allows us to just focus on semantics.

So that’s whirlwind tour, any questions?

**Piotr Sikora:** Observation. C-ABI way of borrowing is very similar to what we originally used in proxy-wasm. In very last iteration had started moving away to align with WASI, seems it won’t be necessary.

We skipped free part and moved ownership to Wasm module itself so if it wants to keep the data, it can. 

**Luke Wagner:** If I remember correctly, C-ABI in current version only frees if it’s returned to the caller.

**Piotr Sikora:** [pondering] do callbacks make a difference? Who’s on the stack, you mean…

**Luke Wagner:** When Wasm is calling an import, it’s on the stack, and then returning to the host. For same reason you said, I think it’s a good use case.

**Sam Clegg:** I’m curious where in the process you see removal of full shared memory. Where does that fit in timeline?

**Dan Gohman:** A few diff options. Way proposal is shaping up, we have components and core wasm stuff. Components won’t export their linear memory. Components are for shared nothing use cases. That’s what gets us this black boxing.

**Sam Clegg:** That’s the line we draw. Core Wasm is shared everything. Components mean it’s shared nothing.

**Luke Wagner:** What’s kind of nice is that compiling core Wasm, you don’t need to care because you’re either wrapped in a component that will hide internal details for you, or you don’t need to hide internal details.

**Piotr Sikora:** So should we assume that C-ABI is a requirement.

**Dan Gohman:** At this moment, still a PR on IT. I can’t speak for what the IT or Wasm CG will decide. Should be careful to say that I think these are really attractive for WASI.

**Piotr Sikora:** Let’s assume that CG approves C-ABI, should we assume that we’re dependent on C-ABI?

**Dan Gohman:** I would suggest that. A lot of the APIs wouldn’t change that much. Read and write would lose vectorability. But would all be very similar to today. It would basically work in terms of core wams.

**Luke Wagner:** We could publish both the IT and C-ABI versions from witx. 

**Dan Gohman:** Should talk about how to present core wasm version.

**Piotr Sikora:** Would C-ABI version have mallac and free?

**Dan Gohman:** We’d need to have in the toolchain. Wasi-libc would offer that.

**Luke Wagner:** From a core abi perspective, here all the things you can import, these are the things you must export. Both could be in this core wit file.

**Andrew Brown:** Just want to add a 1+ for that. Having some official way to translate witx down to core wasm is useful for those of us implementing.
**Dan Gohman:** Agreed

**Piotr Sikora:** One more question. Do we expect to use malloc/free for all data, or just for buffer.

**Dan Gohman:** Only buffer and only where you need dynamic.

**Luke Wagner:** Definitely the case only when it’s needed, but I think that’s not necessary for buffers because just a pointer to linear memory. Only cases are where a dynamically sized bit of data is coming into the instance.

**Dan Gohman:** In particular, won’t be calling malloc on every read call. No extra allocation or copy

**Piotr Sikora:** I worry that there might be inconsistencies. Some will get dynamically allocated data.

**Dan Gohman:** It will be on the application to get it right. This is how C works, on your own to manage your memory. Other languages can manage it for you. Between programmer and toolchain. 

**Luke Wagner:** Will have a baseline of safety with sandboxing of linear memory

### Classic commands
**Dan Gohman:** WASI has commands and reactors. This is where we say FD 0, 1 and 2 are in/out/error, that _start is command start function. I’m now calling these classic commands. Preserving core wasm API for things that don’t use components. These all fall in the same bucket, this is where definition of command/reactor can go. Components subsume this.

Do people have thoughts about collection this whole realm of how we run things today into this one repo and then clearing way for components to be new clean ABI. Some ambiguity today where you export functions that aren’t part of _start, many engines will just ignore them. We don’t really want programs to depend on having their other exports being called.

**Sam Clegg:** Are you thinking that because reactors haven’t really been adopted we don’t need parallel repo?

**Dan Gohman:** If people are still using reactors, then we can keep that around, but components solve the use case they were designed for.

**Piotr Sikora:** In proxy-wasm reactors we use std-out. Would be good if that isn’t specific to commands. 

**Dan Gohman:** Both commands and reactors have that, so I’d keep that together.

**Dan Gohman:** Do these two things seem like generally good ideas or would people like to see more discussion.

**Andrew Brown:** I’d be in favor of C-ABI side, don’t really understand the classic ABI stuff.

**Dan Gohman:** Classic ABI stuff works but isn’t pretty. If implementing toolchain, need to know, but others don’t.

**Andrew Brown:** And you don’t think it fits in tool conventions?

**Dan Gohman:** Good question. I think this does more because it defines contract between toolchain and engine. Feels like it’s a lower level thing.

**Andrew Brown:** Makes sense. So easily convinced to be in favor.

**Johnnie Birch:** I think I missed this. Is classic ABI meant to be long term.

**Dan Gohman:** I think I’m not really ready to call that. Components are really cool. If classic ABI needs to evolve, then putting them in a box makes it easier to do that because they interact in subtle ways. If we wanted to evolve to incorporate typed main, we could do that, so collecting them together allows us to do that.

**Andrew Brown:** Sorry to bikeshed where to put these things. Hard to keep track of the repos.

**Lin Clark:** For context, we're working on streamlining the wasi repo since it's the base for all proposals.

**Dan Gohman:** Could solve with links

**Lin Clark:** Hoping to tackle navigability over the next few months.

**Dan Gohman:** Nothing really needs to be decided at the moment, but I'm going to call this as consensus to move forward for now.

**Lin Clark:** So that's it for the agenda. Any other thoughts before we wrap up?

**Luke Wagner:** If I have a list of buffers, that could be vectored right?

**Dan Gohman:** Thought about that this morning. With adapter functions, vectored could be part of that. Probably some details to figure out.

**Luke Wagner:** Good point, multiple good options here

**Sam Clegg:** C-ABI has list?

**Dan Gohman:** Yes, has all the IT types.

"
stack/2021/sg-11-1.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 1st video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  November 1st, 16:00-17:00 UTC ( November 1st, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)

**Note that the European time is one hour earlier than normal due to the end of daylight savings time in Europe**


## Participants
- Francis McCabe
- Sam Lindley
- Elle Imhoff
- Ross Tate
- Derek Schuff
- KC Sivaramakrishnan
- Lars Hansen
- Zhi An Ng
- Alon Zakai
- Ben Titzer
- Daniel Hillerström
- Luke Wagner
- Michael Knyszek
- Deepti Gandluri
- Andreas Rossberg


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. [Wasm with typed continuations continued](https://github.com/WebAssembly/meetings/blob/78cfd1b3f3c1e7419319a309433b446fbe3fca8d/stack/2021/presentations/wasmfx.pdf) (Sam Lindley)
   2. Next meeting [2 mins].
1. Closure

## Meeting Notes

###  Wasm with typed continuations continued (Sam Lindley)


SL: Cover some of the same ground as before.
Show the basic idea scales

FM: can you explain why the design looks like this and not another design one could have had

SL: can't imagine every other thing

FM: imagining a shift/reset style

SL: the canonical other way of doing it in research community doesn't involve any of the tags around. You have a way to create new continuations, suspend and resume, control and prompt are the constructs you typically have. Instead of suspend, you have control, rather than a tag, you pass a function that appears in the block. Key difference in design here is that the code you want to run is specified in the handler, in those blocks, rather than specified at the point where you do the suspension.

FM: why is the difference there?

SL: from programming POV, separating out interface from implementation, the other way of doing it is conflating the two, here we have it teased apart.

FM: differs on that point, am interested to know why the design looks like this

SL: we can encode the other style in this by defining a tag called control, have done that. Allows us to simulate the other style without these tags. The types get more complicated, rather than here where you define just the ways you do control you're using, you need a generic way. Wasm requires us to keep track of types in stack, that ends up being more complicated and messy.

FM: to summarize, if you have a non-generic way of doing things, then it simplifies the types you need to write down

SL: generic stuff okay, end up with complicated types. Doesn't reduce expressive power, when doing simple things, the types you write down is simpler

FM: this code is impossible for a regular compiler to generate from regular programming language

BT: a list of tags and how they map to labels, looks like a try catch, but there's not a value pushed onto the stack when you land on that labe.

SL: there is, when you do suspend, suspend is just like throw, you get a payload. The diff is suspend you get the return value back, for throw you don't.

BT: in exception proposal there is a rethrow, hidden value you can't see, there's not one here right?

SL: you can suspend again, same value you have before

FM: no equivalent for rethrow

SL: you don't need that

AR: you have the continuation which is first class, you don't need rethrow.

SL: FM what do you mean a compiler can't generate this?

FM: resume is the biggest issue. No language construct that maps to resume. No possibility for a compiler to construct one of these from their source language. Has to be done by hand.

SL: most pressing need is to implement specific features like async/await. You don't have to write much code at all for these features, e.g. lightweight threads.

FM: it is a sketch of it and it works, not what you actually need

SL: in a real implementation you have other considerations about performance and other ergonomics. If you want to implement the feature, this is all you need. Something with the semantics of lightweight threads.

FM: some languages like Java have a join operator

SL: wasn't saying to implement lightweight threads for a certain language, but for a lightweight thread feature, this is all you need. A higher level point, this is designed as a target for existing feature. If you have a more flexible language with effect handlers or delimited control, you can compile into this.

FM: Java has Loom project, allows Java programmer to construct their own scheduler, that's not feasible here because this code which is the output of such a scheduler, you can't write it in Java. Most conventional languages don't have the notion of effect handlers.

SL: If you are compiling Java or Loom, you can define a control tag, then compile directly into this. If you don't need the full features of first class control, you can do just the things you need, say yield and fork.

FM: In Java, there is an interface which defines the set of operations the virtual threads can perform. That is the analog of the different labels you have for the resume. But a Java compiler just implements an interface via vtables. No way a Java compiler can take that interface and generates this code from it.

SL: depends, if an implementation of continuation in Java as in Loom, then you can change the backend to target this. If you write code that is completely unaware of this, then it can't.

FM: same is not true of shift/reset control/prompt style.

SL: they are the same, interdefinable

FM: with control/prompt, there are builtin functions, the rest is built on that

SL: no difference, you can implement shift/reset, control/prompt on top of this. If that's the abstraction on top, you can use this.

FM: My original question about why the design looks like this still stands.

SL: I tried to explain, we can come back to this.




FM: was this inspired by the mandate to not suspend in JS

AR: inspired by discussions that you have code you don't want to suspend because you want it to run to completion, or resources have to be handled in some way, JS is one instance. Other reasons like crossing runtime boundaries, something you want to enforce no suspensions.

FM: interface types is another example

AR: brute-force catch all handler that just traps. Can be more fine-grained you can write a handler, but only if you know the effects.

FM: In the case of JS, when dealing with JS promise integration, you have to build that in. Part of the reason is that we can't allow JS to suspend. If we rely on barrier instruction, we can achieve the effect of not suspending JS, it wouldn't capture the other part of the contract: it must not possible for Wasm to suspend JS.

AR: let's assume an example if you implement JS on top of Wasm. Whenever you enter Wasm from JS, wrap with a barrier.

AR: if you bake it into the semantics, how would you implement that semantics on top of Wasm, you need some sort of construct.

SL: it behaves like a catch-all handler doesn't mean it's implemented like that. It can be implemented by a system that doesn't do any stack switching at all.

AR: yea you probably implement it differently, a bit of every stack when you try to suspend, if it is set you trap. The barrier will set that bit on that current stack.

BT: threads scheduling loop is cooperative, to make it preemptive you have to compile code with checkpoints

SL: ideally you have interrupts, Wasm doesn't have that

PS: on Erlang side, under the cover is coop, from the user perspective is preemptive, because we compile code with checkpoint like function call barriers.

FM: you only need 1 way of interrupting with a clock or something

SL: orthogonal to underlying design

AR: usually green threads have check points that the compiler inserts, below the abstraction of source language, if you want to emulate actual threading on source level

FM: motivation is not just for efficiency, also for semantics, dynamic/static scoping

SL: there are other motivations yes, on next slide



FM: entire feature is an optimization, can do everything with asyncify

AR: not in pure wasm

FM: ayncify will do everything

AR: but not modular

SL: if we end up with recursive types, interesting to experiment to see if we can get performance improvements

RT: in that design you still linear scan to make it sound?

SL: that's an orthogonal issue

RT: you're still doing a linear stack search

SL: this has got the named handler, the problem with named handler is you have to do a linear scan if you're doing anything interesting. Also a design with direct switching without named handlers

FM: if you had a language with effect handlers, effect handlers are first class values

SL: not necessarily, for most implementations they are not, you can turn it into first class by wrapping in a function. Like a switch, or handle, or try-catch

RT: multi-core ocaml the root of stacks has table, with handler you can't do that anymore, you need to know the actual list

SL: abstract over it with a function. In multi-core ocaml is an extension of match.

RT: it has first class effects

SL: define a function that takes a thunk, then do a match on it. Pass that function around, isomorphic to the first class handler.

RT: have you implemented multicore ocaml on top of this. tried walked through that and ran into problems with this, particularly with optimizations. supposed foo event, with multiple handlers. Raise foo, search through meta info in stack, find stack that handles foo, switch to it, reduces cost when nested handlers. With first class effects, you switch to all stacks in the interim just to find handler for foo.

SL: initially this is more important as a design for existing weaker languages, we want to consider that, didn't understand the details of what you are describing, post offline? first class tags is one of the things listed on this slide, not sure if that addresses your concern.

RT: nope

SL: DL implemented a Wasm backend for Koka, he compiled it all the way, compiled to standard Wasm. He is also working on targeting this design, will stretch the expressiveness.






### Adoption of the agenda

### Discussion:

### Adjourn

"
main/2022/CG-01-18.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 18th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: January 18th, 5pm-6pm UTC (January 18th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. [Fine grained control of WebAssembly memory](https://github.com/WebAssembly/design/issues/1439) (Deepti Gandluri) [20 minutes]
       1. Poll for phase 1
3. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

###  Attendees

- Thomas LIvely
- Pat Hickey
- Johnnie Birch
- Michael Knyszek
- Lars Hansen
- Francis McCabe
- Ben Titzer
- Yuri Iozzelli
- Yury Delendik
- Deepti Gandluri
- Richard Winterton
- Chris Fallin
- Andrew Brown
- Slava Kuzmich
- Conrad Watt
- Radu Matei
- Paolo Severini
- Manos Koukoutos
- Dan Gohman
- Adam Klein
- Sabine Schmaltz
- Arun Purushan
- Petr Penzin
- Alon Zakai
- Alex Crichton
- Sergey Rubanov
- Jacob Abraham
- Jakob Kummerow
- Sean Jensen-Grey
- Emanuel Zeigler
- Sam Clegg
- Luke Wagner
- Mingqiu Sun
- Charles Vaughn
- Derek Schuff
- Zalim (Bashorov?)
- Shravan Narayan
- Peter Huene
- Heejin Ahn
- Jay (Phelps?)
- Nick Fitzgerald
- Shravan Narayan
- bhayes
- Is
- Oran

### Proposals and discussions

#### [Fine grained control of WebAssembly memory](https://github.com/WebAssembly/design/issues/1439) (Deepti Gandluri)

DG presenting [slides](https://docs.google.com/presentation/d/1ybMGOj_sy6WaKjp3f3BKhxeHXHetrhg6_E58je9pBRE/edit?usp=sharing&resourcekey=0-gkWaUf3aWNLDDU4lQw0VJg)

CW: With reference to the idea of extending the memory type to include the protection status, could a memory start out protected then become unprotected at runtime? Similar to the “min” part of the memory type.

DG: With the mem type, the main option I wanted was to ensure if you have just a static read only memory, you’d have that. If the protections can change, you still ensure that you’d still be able to grow the memory.

CW: Sounds like there are lots of options, so don’t want to pin you down now.

DG: it’s not clear exactly what all the use cases are yet, so we there are still some open design questonis

CW: Could it be useful to have different kinds of memory bounds and protections be different types?

DG: I’m imagining that If you have memory other than the default, they should all enable external mappings. But if there are cases where you want to get it on permissions up front, it would be pretty easy to implement, if it’s useful. Not sure what the use cases are. But it wouldn't be hard I think

CW: Makes sense. I would be interested to hear opinions on how we would want this to work concurrently, i.e. with multiple threads racing. I’m not sure what’s safe or not in allowing races. In native programs, races are undefined. Presumably we would want something safer. I looked at what guest OSes do and I saw one example where it had to take a global lock before forwarding the operation to the host OS. That seems rather brutal. Do we have a roadmap for consulting experts, etc. to figure this out?

LW: I’m also worried about performance implications about protection changes anywhere at any time. But the idea of “below X bytes have no access” statically is something I like and seems reasonable. Also wholly-read-only memories are another good use case and easy. It might be a good idea to take some of these known easy cases and go incrementally before trying something fully-general. 

YI (chat): A different type of memory like Conrad proposed would solve the issue of breaking the performance of existing applications. they would not opt in to use mappable memory and would not have extra bounds check. Maybe that is also combinable with multiple memories: a program could have a default non-mappable memory and an extra mappable one (potentially slower to access due to mapping checks)

SJG (chat): An interesting paper on creative uses of the kinds of things normally handled by an MMU http://dune.scs.stanford.edu/belay:dune.pdf
Dune is a system that provides applications with direct but safe access to hardware features such as ring protection, page tables, and tagged TLBs, while preserving the existing OS interfaces for processes. Dune uses the virtualization hardware in modern processors to provide a process, rather than a machine abstraction. It consists of a small kernel module that initializes virtualization hardware and mediates interactions with the kernel, and a user-level library that helps applications manage privileged hardware features. We present the implementation of Dune for 64- bit x86 Linux. We use Dune to implement three userlevel applications that can benefit from access to privileged hardware: a sandbox for untrusted code, a privilege separation facility, and a garbage collector. The use of Dune greatly simplifies the implementation of these applications and provides significant performance advantages.


DG: Also Aside from that (what Luke said), having separate memories with more sciatic properties would probably be easier for integration into the web environment, JS APIs etc. Also agree that there are things we don’t know wrt concurrency, so we don’t have good answers on that, and agreed that we should try to find more folks with experience on that.

CW: My point is that concurrency is scary for normal applications, even more scary for us.

BT: Actually immutable memories could allow more optimizations, so that would be another useful distinction.

DG: that’s an interesting point. From the application perspective, that seems like a useful thing to be able to have too. Eg. for a codec use case, having a static view/data view

LH: Would like to see the tools story fleshed out early. Since we don’t currently have a good story for multiple memories and how mainstream languages would use it.

DG: Yes that is something I was hoping to look at very soon after we get started

TL: For LLVM, Igalia is currently working on exposing ref types, e.g. exposing user-defined tables. I would think that secondary memories would use similar mechanisms internally.

PP: why would this be similar? The problem with most languages is that there’s not really a concept for different memory spaces. So we’d need to figure out how this would map and be expressed in those languages. Using fully dynamic memory references might even be easier for those.

TL: for the table support in C, we’re looking at an attribute on a user-defined array of a builtin type. (e.g. array of funcref) that yo ucan say is a table, and you can do loads and store from it, those lower to table.get/table.set. A table is basically a memory full of funcref/anyref instead of bytes. Conversely a second memory is a just a tlable full of bytes instead of references. So it could be similar at the source language level. 

PP: But memory accesses are more freeform, can overlap and be different sizes, etc.

TL: true. The way you access the secondary memories might be less ergonomic than how you access the primary memory.

PP: there was a discussion of address spaces e.g. that LLVM has, that could be the closed analogy.

SC: as an escape hatch you could compile the whole program to use the secondary memory instead of the primary one

DS: Could have a hybrid where you compile some of your code normally and compile other code to use a different memory, then arrange for them to call into each other somehow.

PP: …

LW: In this area there are 2 orthogonal approaches. One to use multiple memories which has hard problems in source langauges. E.g. code needs to opt in with special syntax etc. the other approach is, within a single memory, map stuff in. mutably mapping and changing protection is where all of the difficult portability problems. Maybe  we can have immutable mappings (or e.g. with copy semantics) maybe we could optimize those. E.g. on the web there’s  a concept of an immutable blob. If we could e.g. map one of those into the memory it might work well for some use cases. E.g. you can write into it but it doesn’t get reflected in the underlying blob.

DG: One more note on copy-on-write. I checked whether that made sense and some users thought that wouldn’t be problematic, so that does seem like a reasonable thing to investigate.

LH: Petr also mentioned my same point, that there’s a big space in the tools/langauges where we don’t know how it will work.


DG: [?]

CW: one other question: is it expected that if we have C that makes mmap calls, that we can compile that to these instructions?

DG: I would expect not. I’m not sure what happens now when C encounters a mmap.

DS: It’s basically completely outside the model of the language. But the pointers are uniform, for example zlib doesn’t care whether you pass it a pointer to mmapped data or not. We would give up that property if mmap only works on secondary memories. Would have to find alternative solutions for developers that have different use cases traditionally satisfied by mmap.

SC: yeah the summary is “probably not” currently we fake mmap, I expect we’ll keep doing that.

CV: Packing the memory id into the pointer is something that people have tried, it does have a lot of overhead though.

TL: yeah, fat pointers essentially turn every access into a switch over the index, which would probably be too slow for most use cases

PP: from that point of view a first class memory references might be easier.

DS: Not sure it’s easier in C since C doesn’t have opaque references of any kind. It probably makes some problems easier and others harder

PP: The likelier solution is that the memory reference would take the place of a pointer.

DG: No easy answers. I still have a lot of work to start and make progress on these discussions.

Poll: we can do a consensus poll, since the bar is low. Are there any objections to phase 1?

Unanimous consent achieved.

DG: Will take this discussions and split it into issues.

LW: It’s great to have someone actively working on this. Thanks.
"
wasi/2023/WASI-01-12.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: January 12 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: January 12, 17:00-18:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. wasi-threads: request for comments on https://github.com/WebAssembly/WASI/issues/502
1. Proposals and discussions
scussions
    1. wasi-io and wasi-poll refresh: I/O streams, I/O arrays, and I/O polling for preview2!
    1. Preview2 update: prototyping, polyfills, and progress!
    2. wasi-messaging pull interface; scoping and reducing forward risks on wasi-cloud proposals.

## Notes
### Attendees
- Ayako Akasaka
- Chris Woods
- Dan Chiarlone (danbugs)
- Dave Bakker
- Frank Denis
- Frank. Schaffa
- Hung-Ying Tai (hydai)
- Ivan Font
- Jeff Charles
- Joe Zhou (Mossaka)
- Kevin Hoffman
- Kevin Moore (kevmoo)
- Pete Vetere
- Piotr Sikora
- Yong He
- Marcin Kolny
- Lin Clark
- Wilson Wang
- Dan Gohman
- Colin Murphy
- Andrew Brown
- Mingqui Sun
- Kyle Brown
- Chinmay Garde
- Luke Wagner
- Bailey Hayes
- Johnnie Birch
- Johannes Becker
- David
- Krisztian Gacsal
- Colin Murphy

### wasi-threads: request for comments

**Andrew Brown**: We can use wasi-threads if you cobble together PRs. I have a demo, if you’re interested contact me. This has brought up several issues in how we’re doing things with wasi-libc. Especially want to bring up https://github.com/WebAssembly/WASI/issues/502. This is about switching wasi convention. Currently wasi module is expected to export memory. Think we should import instead. Think it would be best to consider sooner rather than later. If you have an opinion, please take a look.

**Wilson Wang**: what is the relationship between wasi thread and the future in component model?

**Andrew Brown**: Luke, Alex and I wrote up a plan: https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1282975456

**Kyle Brown**: Not even a memory being imported/exported at all? Looking forward to preview 2, at that point maybe there isn’t a memory. I think we’re losing that as part of the idea.

**Andrew Brown**: That might make this change easier

**Kyle Brown**: Part of the reason is that component models’ shared nothing means that in general you’re not sharing memory across components

**Sam Clegg**: Don’t they lower to wasm core modules?

**Kyle Brown**: They do lower to core wasm, but the runtime or embedding of CM is connecting the memories. The question, Luke, was originally about importing vs exporting memories in wasi. In the preview 2 future, does the shared nothing boundary means this doesn’t make sense.

**Luke Wagner**: One important distinction is between components and intracomponent. Between components, not shared. Most of the WASI interfaces are at the component level, but for parallelism we’ve talked about having these as core modules inside components. 

**Kyle Brown**: wasi threads needs to be expressed in that lower, core module way then.

**Luke Wagner**: Shared memory parallelism is pretty advanced and needs to be deeply integrated with the host, so this is an advanced use case. We have talked about expanding wit to cover core wasm modules, which would be useful for importing core in other contexts as well. It will be expressable I think, but it’s more of a when. Hard to do now since we’re just bootstraping.

**Sam Clegg**: I think we should support both. 

**Dan Gohman**: Interesting ? for the component model. Do we want to have it use import instead of export. Not that much more work for the engines to create the memory themselves.

**Sam Clegg**: In an ideal world, we wouldn’t be exporting at all. In the future world, that may be the case.

**Dan Gohman**: In core wasm, we don’t have much option.

**Andrew Brown**: I felt it made more sense at a conceptual level because the model is that the engine hands me the memory before me the wasm module start running it. The engine is the one creating the memory regardless.

**Sam Clegg**: It’s also just less code in the JS world if you dont’ need to do new wasm memory whenever you start a module.

**Luke Wagner**: Emscripten evolution

**Sam Clegg**: By default in ems we have moved to module creating and exporting. 

**Luke Wagner**: That’s sort of why active data segments were created.

**Andrew Brown**: If we want to continue the discussion, issue 502 would be a good place. Would like to come to conclusion.

### Wasi-poll and wasi-io refresh

**Dan Gohman**: Quick bit of background: started these at the beginning. Clear that streams would be really important. Seemed like a good design, then realized that they are so fundamental that they should be fully integrated. Moved to component model. 

Then, we started recognizing that streams will take a bit because async is taking a bit more time. So we’re bringing these back for preview 2 timeframe.

### Preview 2 update

**Dan Gohman**: Plan to build preview 1 to preview 2 prototype. Can run preview 1 binaries and run on preview 2 hosts. This will allow us to move onto preview 2 sooner rather than later. Working to build a prototype.

Also in this repo is preview 2 host impl. Programs from hello world to spidermonkey are now running on this. Still some more work to do, but some of the big pieces are done. 

We have our own wit files for prototyping, but submitting upstream to WASI, so keeping things in sync as they evolve.

Another part of this is pseudostreams that are based on resources and a built-in type.

**Sam Clegg**: Does polyfill use binary re-writing

**Dan Gohman**: We have a linker that can fuse together

**Sam Clegg**: So both!

**Ayako Akasaka**: Are you going to use wit-bindgen for generating preview2 headers ? sorry for poor question

**Dan Gohman**: If you look at the releases tab, we have releases include generated bindings.

**Lin Clark**: No additional questions

**Dan Gohman**: Overview of pseudostreams and how they work. A little different from how POSIX does things but polyfill handles that

**Bailey Hayes**: quick clarification: will the complete set of wasi-sockets eventually be added to preview2 or to a later preview?

**Dan Gohman**: Hoping to get it in. TCP sockets are there. UDP sockets are hard, trying to figure out. Also have resolution ABI for name lookups

**Dave Bakker**: Need any help with sockets, just lmk

**Dan Gohman**: Will be reaching out once ready to push back up.

**Marcin Kolny**: What date are you targeting

**Dan Gohman**: No specific date. Think it will be usable in the next month. Not sure how to handle in the spec, do we want to officially bless. If so, could be in the next few moths.

**Hung-Ying Tai**: Will the wasi-sockets become a standalone proposal or be a part of the preview2?

**Dan Gohman**: Preview 2 isn’t an official thing. Wasi-sockets is already a proposal, so we’ll just upstream

**Frank Schaffa**: wondering about support for http3 (if this makes sense!)

**Piotr Sikora**: re http3 - there is really no difference from WASI API point of view between HTTP/1 vs HTTP/2 vs HTTP/3, since they share the same HTTP semantics

**Ivan Font**: Where is the prototype work happening?

**Dan Gohman**: https://github.com/bytecodealliance/preview2-prototyping. We’ll be bringing to the group for stamp

**Luke Wagner**: Could we consider “preview2” as just proposing the world that you showed (that pulled everything together) and thus depending on all the other individual interface proposals?

**Dan Gohman**: Yes, that makes sense. That would be what we publish.

**Sam Clegg**: Is the plan to eventually have wasi-sdk produce them without polyfill eventually.

**Dan Gohman**: We’re making some compromises to get things out sooner rather than later. We’re making some compromises here, so might not make sense to push upstream until we get to preview 3. Not really determined yet. Plan is eventually to update wasi-sdk.

**Sam Clegg**: Yeah, we could leapfrog preview 2

**Dan Gohman**: Yeah, because WASI has been held up for too long on CM, so this is just getting us unblocked. We can do engines sooner, but toolchains are the main question. We can figure that out.

**Sam Clegg**: Would there be any reason for producers to switch to preview 2?

**Dan Gohman**: If you want to use more of the features, like streams API, so you could be more efficient. Might be some reasons producers would want to do that. Once we get into wasi-http, there will be more reasons for people to upgrade. It will be in toolchains interest to start thing. Also logging features not accessible through the polyfill. Some toolcahins might want to opt-in, but won’t be a requirement

### wasi-messaging pull interface; scoping and reducing forward risks on wasi-cloud proposals

**Joe Zhou**: A few months ago, introduced SpiderLightnight. Now called wasi cloud. I presented wasi-keyvalue, Dan presented wasi-messaging and wasi-sql. Steve S wrote draft for wasi-blob-store. Haven’t started runtime config, distributed lock service, grpc and http. We’re going to be focusing on grpc and http in short term. 

Take a look at the PR on the wasi-messaging repo for major change.

We want to move forward in a more effective and efficient way. We’ll be reducing scope. Consensus that future and stream types aren’t going to be in near term, so planning to move. Alternatively, we’ll use pseudofuture and pseudostream.

Assume that the resource type will be landed by end of year. For now, we’ll use pseudo-resource.

We want to ensure that wit files are versioned, validated and documented. Also want to establish with community that breaking changes will occur.

### Any other questions

**Wilson Wang**: Working with ___ community. Trying to run WebAssembly on top of ___. In Python, we can serialize functions.

**Kyle Brown**: In a way, modules are also serializable representations.

**Bailey Hayes**: I think CM will enable this. We would have a component that could represent the runtime. When you want to do remote execution, you could link in a tiny component that is your execution.

**Kyle Brown**: Intending to bring back sql-embedding proposal. Don’t think we ever made it an official proposal. Want to bring that back.

**Joe Zhou**: Do you think of putting that in a wasi-sql proposal. 

**Kyle Brown**: They are actually kind of a distinct problems. It doesn’t overlap significantly IIUC. Doc https://hackmd.io/Q93MXGLYTRSeGw7FVelURg?view 
"
gc/2022/GC-10-18.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 18 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: October 18, 6pm-7pm UTC (October 18, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: No-frills JS interop (https://github.com/WebAssembly/gc/issues/279#issuecomment-1277950124)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Francis McCabe
- Alon Zakai
- Zalim Bashorov
- Asumu Takikawa
- Ilya Rezvov
- Justin Michaud
- Adam Klein
- Manos Koukoutos
- Ryan Hunt
- Conrad Watt
- Ioanna Dimitriou
- Jakob Kummerow
- Andreas Rossberg
- Slava Kuzmich
- Emanuel Ziegler
- Ben Titzer
- Igor Iakovlev
- Sergey Rubanov

### Discussion: No-frills JS interop (https://github.com/WebAssembly/gc/issues/279#issuecomment-1277950124)

[Design document](https://docs.google.com/document/d/17hCQXOyeSgogpJ0I0wir4LRmdvu4l7Oca6e1NkbVN8M)

JK presenting [slides](https://docs.google.com/presentation/d/1OxU3lrgtyo1b5HaF55Vk0lzk3BlJshaRADKX87hH7bE)

CW: Looks wonderful. Can you walk me through why option 2 for i31ref would require boxing?

JK: Would normally represent a 42 in JS the same as we would represent an i31ref 42, so if we need to distinguish them, one needs to be boxed.

AR: Wanted to ask about that. Do you know in V8 which operations might produce non-canonical numbers?

JK: Definitely divisions, which assumes the result has a fraction. Also pulling numbers out of arrays.

AR: Another question: What about minus 0?

JK: Right, and we couldn’t convert it here because extern.{extern,internalize} are supposed to be value preserving.

CW: Do we need to think about what the semantics of calls if we allow more types on the boundary are?

JK: We would have to do the same work as part of the function call sequence.

AR: Would have to build the internalize logic and downcast into the call.

BT: I think what we have here is fine for shipping, but what about once we get ecosystem penetration and get more modules that use GC types on the boundary? Can we relax that?

JK: Yes, which restriction were you thinking about?

AR: I think it’s critical that we allow anyref at the boundary. Externref specifically means host reference, and there are uses for that, but the more dominant use case is that if you import something, you don’t want to commit to whether it comes from Wasm or the host. If you don’t have anyref, then you can’t do that in a way that would be efficient for linking to other Wasm code. The cost of converting to externref just at the boundary would be unacceptable.

JK: I can see futures where we may need that and it may be a common case. But no one does that now. The MVP use case is a single module app that talks to the browser. I do believe this intentional.

AR: That’s too minimal. If we don’t allow it now, people will use the wrong abstraction and there will be confusion later.

RH: But you can still use this to link Wasm modules together with no conversion by opaquely passing through JS.

AR: Still, it’s important to be able to implement the other side in JS. That’s a general goal of WebAssembly.

CW: I agree, but also conscious that JK said it would be a lot of engineering work. Can you share more? Could it be implemented before shipping?

JK: I would prefer not to block shipping on this. It seems really low priority. No one is using this. Can still stitch Wasm modules together, just not call them from JS.

BT: Can dynamically generate modules to do the translation. You would need to be able to reflect on signatures to determine when that was necessary.

AR: That would be tedious and have a lot of overhead to do all that wrapping.

BT: I 90% agree with Andreas and 10% agree with Jakob. I share the concern about self-fulfilling prophecy.

JK: Would be a quick follow-on proposal to relax this.

BT: No such thing as a quick follow-on so far.

AR: If it’s quick, we can just do it now. Won’t be shipping MVP this year, so not much difference between 3 weeks and 3 months to implement this.

TL: Would this be similarly complicated in other engines?

RH: Would have to think about it more. Are there spec concerns about this or just engineering timing? It seems like we’re just speculating about what’s going to take longer.

CW: On the spec side this would be trivial. It think it would be fine for V8 to defer implementing it for months and months. Would be fine with aiming to have it and making a crunch time decision when it comes to shipping.

RH: Won’t be trivial in SpiderMonkey. Don’t know if it’s a week or a month, but not having this would make things strictly easier.

AT (chat): I think we don’t have a good idea of how much work it would be (anyref on boundary) in JSC work either at the moment

JM: If it’s going to be slow to pass other types, people will want to use externref anyway. Better to spend engineering time on other things.

BT: The performance concern is specific to JS and in the long run of Wasm, passing anyref on boundaries will not be a problem. Need to optimize for API ergonomics.

AR: Also don’t want to bifurcate the ecosystem between externref passers and anyref passers.

AK: Part of the reason we want to take the minimal approach to JS interop is that we don’t have people trying to do rich things between JS and Wasm. The idea of transparently swapping between JS and Wasm is future looking. What would be a use case for that?

BT: Once you have a data structure like a high-performance hash map. Could be implemented in either language.

AR: There’s the general polyfill class of usecases where you want to implement in one or other to provide functionality before it becomes available.

BT: In my VMs class right now we have an extension that wouldn’t be implementable with anyref for the reasons here.

AR: Just to step back a little, we are in broad agreement about the minimal functionality here and this one detail seems like a relatively minor point in comparison.

RH: If you have an exported global with a concrete type and you do a global.set from JS, is there an implicit cast there?

JK: Yes, and the difference from function calls is that it’s less performance sensitive and easier to implement than in the function call case.

RH: And there’d be a similar mechanism for tables?

JK: Right. If someone wanted to, we could make that more restrictive.

RH: For the implicit cast, was there concern about what RTTs to use?

JK: That concern still holds and in a future with arbitrary RTTs we would have to add something else or tell people to work around it on their own.

AR: Ryan makes a good point there. I think there’s a strong case for making them consistent there. It’s strange if you can pass a type in one way but not the other.

JK: If you need a principled argument, it’s because functions give you a place to add the instructions yourself. Globals and tables need to be implicit because there is nowhere explicit to put the instructions.

CW: In the fullness of time when all signature are allowed, implicit casts will be the only reasonable semantics.

BT: Would need a special case of the `toWebAssemblyValue` algorithm that throws for function calls.

RH: Is there any thought on what type reflection should look like? Inspecting or constructing tables for specific types, for instance.

JK: Our working assumption is that this is just not possible, since the interaction with isorecursive type canonicalization is complicated.

AR: You’re asking what .type would do?

CW: IIUC it would just throw right now?

RH: No, since this is functionality added in the separate type reflection proposal.

JK: That’s a good question.

AK (chat): https://github.com/WebAssembly/js-types/blob/main/proposals/js-types/Overview.md#type-representation

AR: Maybe throwing would make sense if the type cannot be reflected into JS yet. Or maybe generalizing to `func` from specific function types? But no, that would be bad.

AT: There are other cases where things similar to type reflection come up, like in creating globals. Can you create a null ref of any for instance?

AR: I think that would be disallowed for now.

JK: JS has one null value that you could pass in.

BT: The JS null would have to be internalized. For type reflection, would probably want something to expose and construct rec groups.

RH: That makes sense, but I’m concerned about how we would handle JS object identity with the canonicalization. Happy to have a shortcut for the MVP.

AR: In the current reflection API, function types are syntactic and not canonicalized if I remember correctly. Does it return the same object for the same type?

RH: Don’t think so. It may be underspecified.

AR: We could choose to have the object identity reflect canonicalization or not.

BT: …

JK: I think the types are weakrefs so if you keep creating and destroying modules, we won’t run out of memory.

MK: That’s right, they’re weak.

AT: So are we planning not to extend the existing type grammar in JS for now?

JK: But tables and globals can hold arbitrary ref types. We should make that explicit in the spec.

BT/AR: That already follows from globals holding value types and tables holding ref types.

AT: What about that same functionality in JS?

RH: To clarify, you’re thinking about that WebAssembly.Global constructor from JS and passing in some interesting type there.

AT: Yeah, and the typed function references proposal extends that with a ref type constructor.

JK: Would need an API for rec groups.

AT: What about for `eq` and `array` and other GC types that don’t need rec groups?

RH: I would support supporting those.

AR: Would prefer to consistently allow or disallow the same types/values everywhere.

CW/RH/TL/AT: Thank you to Jakob for the doc and presentation.
"
gc/2022/GC-05-31.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 31 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: May 31, 5pm-6pm UTC (May 31, 9am-11am Pacific Standard Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: RTTs ([#275](https://github.com/WebAssembly/gc/issues/275)) [30 minutes]
        1. Consensus poll: Should we defer RTTs from the MVP and reintroduce them alongside generics, type imports, or another post-MVP proposal?
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Francis McCabe
- Igor Iakovlev
- Justin Michaud
- Ben Titzer
- Adam Klein
- Aske Simon Christensen
- Alon Zakai
- Emanuel Ziegler
- Manos Koukoutos
- Ilya Rezvov
- Luke Wagner
- Sabine Schmaltz
- Ryan Hunt
- Jakob Kummerow
- Andreas R
- Asumu Takikawa
- Deepti Gandluri
- Zalim Bashorov

### Discussion: RTTs ([#275](https://github.com/WebAssembly/gc/issues/275)) [30 minutes]

BT presenting [slides](https://docs.google.com/presentation/d/1fL4-NwjpiiQ4PPQt3adGNH5rDiZFJFs-gH2apC-Wdxc/edit#slide=id.g130629fc726_0_60) about programmable meta-objects / RTTs.

AR: Metaobject idea is not new: static fields have been [listed](https://github.com/WebAssembly/gc/blob/main/proposals/gc/Post-MVP.md#static-fields) in the post-MVP for a while. The new thing is the second kind of cast. Seems like there’s no conflict between the different kinds of casts, but we have details to explore. Regardless, plain Wasm casts cannot be rtt-free with generics. 

LW: Totally agree on the meta-object thing. I also buy the software engineering argument that we should design it together with RTTs and therefore delay them from the MVP.

BT: Currently, when declaring an RTT type you can declare an index. In the future we’d want to declare fields there too. Might want a zero field too.

AR: Spent some time thinking about how we would do this. Both ways involve extending the struct definition. So we would need a new mechanism on the type level, otherwise you don’t know at runtime what static fields you can access. Could either ad hoc let any struct also have static fields, or you could let metaobjects be declared separately and even have their own metaobjects.

BT: This is why I think we should have a functioning version of that before we ship anything related to RTTs.

AR: In the model I had in mind, you have two ways of creating an RTT: rtt.canon if you don’t care about the metobject, or by getting an rtt from a declared metaobject via a new instruction.

BT: That sounds reasonable, but the devil’s in the details. Depends how you refer to RTTs, load from them etc.

AR: That’s why you want metaobjects of metaobjects, i.e. metaobjects can have rtts.

BT: Until we have it prototyped and used, I’d worry that we’d miss a detail. So doing this all in post-MVP makes sense to me. The primary cost is that we’d duplicate the rtt-free instructions in the future.

AR: The primary cost I see is on the risk side. RTTs right now aren’t a feature but a design choice, and a fundamental one at that. The risk I see is that if we leave them out, people might make assumptions about the design (e.g., how casts work under the hood), and we could find ourselves in the position that they couldn’t be added. I see the point that they are not “useful” right now, but if you see them as a design choice rather than a feature, then that makes more sense.

TL: There must be RTTs internally, even in MVP. In MVP, these are simple static lookups because allocation and cast targets are always known statically and there is a bounded number of types. Once we add generics, the number of types will be unbound and cast targets will not be statically known, so the engine will have to pass RTTs around. any implicit MVP-passing scheme would have overhead even where unnecessary, e.g. in generic containers. To avoid that overhead, we will want explicit RTT values to pass around and elide if possible. I like all the metaobject stuff, and agree that software engineering wise it’d be best to design it all together, but even aside from that I think we will have RTTs. All things considered, delaying from the MVP seems like the right choice.

AR: Since we agreed we need them for generics and type imports, part of the risk I see is that those features are delayed until we resolve RTTs. With Ben’s argument that we should codesign with metaobjects, that risk increases.

JK: I’m quite firmly in the postpone camp, by the principle that we should only add features that are used by producers and provide value at the time they’re used. We already have RTTs in the engine. That’s why I’m not concerned about risk. We have people here who are care about efficiently implementable casts, so I don’t expect the group to make mistakes here in the future. I like Ben’s ideas about metaobjects. I can see that maybe even in the future we may be able to do some static configuration instead of RTTs, but that remains to be seen. I’m not worried about the risk of not being able to add them in the future. Especially because V8’s Map objects, which are the implementation equivalent to RTTs, aren’t going anywhere.

BT: One last thing I didn’t mention in my slides is that headers can be pointers into tables or etc. so they don’t actually have to be full objects in the MVP. So a hyper-specialized engine could optimize them to be simpler if it doesn’t want post-MVP features.

AR: That seems like exactly the sort of risk I’m talking about.

BT: But there are engines that won’t even support GC. There’s always the possibility that there’s some point in the space where some engine will stop implementing additional Wasm features.
JK: Engine will need some sort of RTTs to implement casts.

AR: I don’t see a way to optimize this without something like pointer compression.

JK: You need some identity for every struct on the heap. Semantically equivalent to a pointer to some type information.

AR: One thing I wondered in this discussion is if the name “RTT” is confusing things. It’s really just a “descriptor”. Type information is just one type of information you might want to store. Static information and GC information is also there.

BT: I don’t disagree with that classification. Still leaves the question of whether we need to make them first-class now, and I don’t think we do. I see it as a system of upgrades to the functionality we support. I think we can thread the needle here.

JK: I think that’s a great point. If in the future it turned out that explicit RTTs were more expensive than implicit ones, then this could be a tradeoff that languages could make…[interrupted]

AR: No, no. Explicit / run-time type objects came up in the early 2000s, coming out of experiences with the JVM and CIL that had not been designed with generics up front. The methods of adding them post-hoc ended up with undesirable semantics. As Thomas said, if these are values, then optimizers like Binaryen can immediately apply to the same things.

JK: I’m not making this up out of thin air. Previously, Andreas, you suggested that more than one RTT can refer to the same static type. As long as there is a single RTT for a static type, then you can do a single pointer comparison for a type check. Once there are multiple, it’s no longer a single comparison, some indirection is necessary.

AR: One thing that is a bit subtle here is that if you generalize RTTs to descriptors, then you can have multiple descriptors that describe the same type, but they all describe the same type. So if you do a Wasm-level cast then they are all identical. If you do different operations like the identity check Ben described, then they can behave differently. This also came up with the idea of the JS API using different RTTs that describe the same type.

BT: I’ve been repeatedly confused by RTTs over the years, but I was under the impression that RTTs would be an identity check. Going back to my slide, with the two types of casts, for the static case the RTT isn’t exactly a witness. The RTT is a holder of static type information.

JK: If there is more than one holder for each static type, then we actually have to read it rather than just do an identity check on it. But we have lots of exciting ideas and different preferences for what we should design. So we should leave all those conversations to have in the future.


AR: Agreed, but all of that depends on the RTT design we have today.

BT: polymorphic recursion mints new types.

AR: No, just instantiates type expressions that you need to compare. This is why piggybacking won’t work.

BT: I know we’ve argued about this and have different opinions, but piggybacking is the first thing language implementers try.

LW: I don’t think there’s a risk-free path forward. Incrementalism and non-incrementalism both have risks.

AK: I was curious if Luke or other folks have use cases for type imports in the near future, since AR brought up a concern that it would be delayed.

LW: For browser imports and for … (missed this).

AR: Can you say how they relate to the component stuff?

LW: We’re pretty happy with i32 indices into tables for now, but if the core Wasm uses GC, then type imports would be how you would type references flowing into that module. That’s not in the near future, though.

**Poll: Should we defer RTTs from the MVP and reintroduce them alongside generics, type imports, or another post-MVP proposal?**

|        |    |
| ------ | -- |
| **SF** | 2  |
| **F**  | 13 |
| **N**  | 2  |
| **A**  | 1  |
| **SA** | 0  |

Consensus achieved. No further comment from dissenting member.
"
main/2023/CG-04-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 11 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: April 11th, 4pm-5pm UTC (April 11th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
   1. Add a `_initialize` convention in tool-conventions
     - This would add a new tool-conventions document named
       BasicModuleABI.md which would define the `_initialize` convention.
     - See https://github.com/WebAssembly/tool-conventions/pull/203
       for details.

1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes
### Attendees

* Sergey Rubanov
* Zalim Bashorov
* Dan Gohman
* Paolo Severini 
* Jeff Charles
* Yury Delendik
* Alex Crichton
* Ryan Hunt
* Andrew Brown
* Ben Titzer
* Chris Woods
* Yuri Iozzelli
* Brendan Dahl
* Alon Zakai
* Ashley Nelson
* Emanuel Ziegler
* Manos Koukoutos
* Thomas Lively
* Dan Phillips
* Nick Fitzgerald
* Petr Penzin
* Deepti Gandluri



### Discussions

#### Add a _initialize convention in tool-conventions

DG (Dan): we want to implement C++ constructors and similar. If we have a main function, we can just put the call before the user code starts. But if there’s no single entry point, there's a question of how to run them at the right time.
So we are proposing a tool convention, but this is somewhat unconventional because it spans more than just one toolchain.

We’d have the _initialize function which would be exported, and the users of the module would have to recognize. 

With the component model we are also discussing adding a second init phase, after the imports are initialized. This would be a good match, the component model exports a more limited interface.

For core Wasm this is more complicated to do due to interactions with JS, we sort of need to have an in between phase so that the component model doesn’t have to deal with the things that have to run before the start function
We’ve looked at a few alternatives… could we use the wasm start section, but that doesn’t work because the imports aren’t available yet. And we need to be able to do arbitrary things like read()/write() in constructors.

Also tempting to define a second initialization phase in core-wasm. core -wasm members expect to have mopre control of exports, so that would be hard to do. 

Another option could be to have wasm-ld automatically wrap the exports. The wrapper would have a check that runs the initializer if it’s not been done yet.
There are concerts about overhead, people don’t want to deal with the overhead of an extra branch at every initialize.

And lastly, the name. Call it _initialize, or _wasm_call_ctors, or what. We use_initialize in WASI, it seems fine, but open to input there too.

Do people have thoughts about this? Questions? Suggestions? 

PP: is there currently work to use this in something non-component-model based?

DG: This is entirely not about the component mode, this more about how do we implement C++ constructors for core wasm? 

PP: is there an effort to implement this in the toolchain?

DG: Variety of efforts, wasm-ld grabs every export, there’s code in wasi-libc, one of the issues there right now is that we want  C++ constructors 

There is also code in wasi-libc to do _initialize as described. But we want C++ constructors to work even without WASI since C++ should work across all wasm environments, not just WASI.

DG: We have implementations, biut looking for a standard convention, we should have a unified answer to this

DS: Bit of context to add, today we have the tool conventions repository which has been primarily for documenting how the LLVM based tools do things so that other things can use LLVM in the same way or interoperate with them and it’s sort of describing how one ecosystem works. But the reason this is interesting is the hope it would be a little broader than one toolchain or one set of toolchains on one set of infrastructure. So the scope is a little bit broader.

DG2 (Deepti): Have y’all talked about separate place for something that’s broader? I know sometimes tool conventions has been a catch all for a bunch of different things, so I don’t want to open a discussion about what the toolchain repository should be or if there should be a new repository. But I wanted to know if these discussions have already taken place.

DG: If we don’t put it in tool conventions, the other place that makes sense is core-wasm spec but that opens up a can of worms, is this the initialization phase and how do we define that? It makes things more more complex. Push the problem onto the host environments that doesn’t allow us to say much about those environments but ensures that initialize is called before anything else. A whole new document just for this feels awkward. What else would we put in this document? It would be this one thing, and would we make a standard for the other initialize functions? Seems silly but we could do that. Part of the guidance I’m looking for is what should we do here? A whole new standard for this seems unjustified but maybe we should. I don’t know.

BT: about exports: one of the important ones is memory, used by lots of APIs. are there other exports that are relevant here?

DG: The function table, if you want function pointers across boundaries, you would need the function table.
Other than that, exporting malloc is also pretty common, to call back in and allocate memory inside the module.

AZ <chat>: It might be helpful to clarify which VMs and toolchains would be expected to call _initialize. (web VMs, server VMs, others, etc.?)

DG: Don’t know the answer to this, if you’re using wasm32-unknown-unknown, they shouldn’t expect to know about this, and the user code would have to deal with it, but VMs could automatically do this

NF <chat>: on the web would it be automatically called, or would it be the JS?

DG: on the web, I don't think we’re proposing changing how browsers work. That seems like a pretty significant step. We could?

TL: Difficult to figure out how.

DG: That’s also a basically a second initialization, so it’s basically the same problem.
The places we can call automatically mostly are the places that don’t have JS. in a non-JS engine, the host doesn’t really have any purpose for the exports, so it can just call _initialize automatically. But on the web where there are users of the exports, it’s important.

DG: We’re not going to define the function, but its up to the user to define it, it can have undefined module if not defined right;
 So I’d expect that we wouldn’t put it in the browsers, we’d tell toolchain developers or users that they’d need to call _initialize if it exists.

PP: if the problem is that there are things that are not initialized, so you need a second function. Can you have a convention that this is still part of init but called after everything is set up? Maybe this is a naive question…

DG: The challenge with the second initialization function is defining when it runs. We want the function to get called after the exports are available, JS code expects autograbbing of exports, in JS we have async await, but we don’t have that in Wasm, if we build a second initialize then we have to call into JS before the exports are available, and call back into Wasm and then back out into Wasm again to be able to suspend the way JSPI expects

One option we discussed was a callback. In a way _initialize is like that but only host code knows when it has to run.

PP: Makes sense. Some kind of callbacks for system functionality could be useful. E.g. in wasi-threads, libc provides the support vs libc in emscripten which does a lot more, but there is missing a place to put that

DG: Primarily looks like a direction, if there should be a callback scheme, then we could go that way

BT: I don’t have an answer but It looks like there’s almost a recursive dependency between imports and things that you export. You kind of paper over this but if there was a more explicit way to express dependencies between imports and exports, eg. repeated section. Component model does this with multiple modules. But we don’t have a way to express in core wasm.

DG: A phased instantiation type of scheme? 

BT: A little like that, you can import things that don’t depend on something, that can be used directly, if you have an export that depends on an import, then you want to be able to export before the imports are defined. Luke, any thoughts? I fundamentally see it as an ordering dependency issue.

LW: I think it raises some of the cyclic dependency questions that get difficult quickly. DAGs are straightforward but it gets complicated quickly if you have cycles.

DG2: Any objection to this going into the tool conventions repository to start with? What is the best next step forward?

LW: were you suggesting this in tool conventions?

DG: yes, this link is a PR there. Would be a new file called BasicModuleABI.md

DS: You’ll probably spend more time describing what this document is, and what it should do than the technical part :)., if we don’t have a clear path forward for now, then it makes sense to put it in tool-conventions now and we’ll have something to refer to in the future if we want to do multi phase instantiation, or better dependency management, this could be relevant to that and at which point we’ll have a better idea what to do with that.

DG: 

DG2; Any objections to starting in the tool conventions repository as DG proposed?

No objections raised.
"
main/2021/CG-10-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 12th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: October 12th, 4pm-5pm UTC (October 12th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Update on [Garbage Collection](https://github.com/WebAssembly/tool-conventions/issues/167) (Thomas Lively et al.) [30 mins]
    1. Update on [Typed (Function) References](https://github.com/WebAssembly/function-references) (Andreas Rossberg) [20 min]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

###  Introduction of attendees

Jacob Mischka

Steven Prine

Flaki

Slava Kuzmich

Lars Hansen

Chris Fallin

Richard Winterton

Michael Knszek

Saul Cabrera

Yuri Iozzelli

Jacob Abraham

Francis McCabe

Paolo Severini

Zhi An Ng

Sean Westfall

Thomas Lively

Alex Chrichton

Petr Penzin

Conrad Watt

Rick Battagline

Dan Gohman

Luke Wagner

Jakob Kummerow

Alon Zakai

Pat Hickey

Vibhav Pant

Jlbirch

Ben Titzer

Zalim Bashorov

Mingqiu Sun

Arun Purushan

Heejin Afn 

Nick “fitzgen” Fitzgerald

Peter Heune

Ross Tate

Andreas Rossberg

### Find volunteers for note taking

Acting chair to volunteer

### Proposals and discussions

#### Update on [Garbage Collection](https://github.com/WebAssembly/gc) (Thomas Lively, Alon Zakai, Jakob Kummerow) [30 mins]

TL presenting [Slides](https://docs.google.com/presentation/d/1cIZ-w5FcaTndrsrFFaMJ6EkVYulxF1DZgB6WiIzNNQU/edit?usp=sharing)

CW: Is that optimization done as a Wasm to Wasm pass?

AZ: yes, Wasm to Wasm

CW: Does that mean producers are missing the opportunity? Or are all the optimizations are in the wasm to wasm pass?

AZ: dart here is based on AOT compiler path, it can be a missed opportunity in some sense, the escape analysis here is productive only because of more optimizations Binaryen does later

RT: We made a system that compiles through LLVm, we found that devirtualization wasn’t useful unless it unlocked other use cases. This sort of chaining after the user space is important

AZ: good point, devirtualize a call does little, but it allows us to inline, does escape analysis, and more optimization. Unsure why this example doesn't happen in the Dart AOT.

CW: when measuring the cast overhead, is this running a version of V8 that nops the cast?

AZ: Yes, that’s how it’s done. It’s an unsafe measurement

CW: The overhead is lower than expected, remaining overhead is mysterious

BT: for null checks, is that because V8 has a null object that needs an explicit branch?

JK: Yes

CW: It takes several minutes to compile - without type canonicalization?

JK: yes, if IR graph happens to have a pattern that runs into quadratic algorithm in e.g. register alloc

CW: Are these problems solvable by reengineering passes in V8, this is not inherent to Wasm?

JK: not inherent to Wasm at all, not much Wasm can do about that. The toolchains that produce modules have to be careful. E.g. if binaryen inlines everything it cans, the resulting function can be too much for a JIT compiler. The inlining budget is a knob we can turn. Some optimization passes are just expensive, takes time.

<chat>

BT: The era of wasm engines doing dynamic inlining is about to begin :)

CW: :'(

BT: CPUs do SSA. You can’t stop the hardware getting smarter :)

LW: Hopefully in a way that can attempt to preserve as much of the predictability of the cost model as possible…

BT: I think we can address that with a compilation hints section

CW: worried about having deopts in Wasm

AR: Still confused about the call ref thing, create an auxiliary table of size one, put, and do a call ref on that, why are inlined calls needed? 

JK: because a call that you don't do because you inlined, is an order of magnitude faster than non-inlined

AR: Fair, if you want to inline it?

CW: Is this an optimization that you would have done for call indirect anyway, and needed more for the number of indirections in GC?

JK: yes, accurate. We can consider doing it for call_indirect afterwards

BT: everything in call_indirect table has Wasm calling convention, if they are JS they have been wrapped by wrapper, you don't have to check if it is a JS function. call_ref has to do several checks to see if it is a JS function.

AR: Why? 

BT: That’s V8, everything in the heap is a JS object..

AR: idea with other JS values passing the boundaries is that conversion is done at the boundary, then you have the exact same situation, you save the type check and reading from table. What do you do if you store the ref in the table, how do you wrap that then?

BT: Stuff might be generated when you write into the table, table writes are expensive in JS

AR: now that we have table.set.

BT: also expensive, how signatures are canonicalized, can be a broadcast write to multiple different instances that import a table, due to how signatures are canonicalized to a unique number

AR: Would that also be true for typed tables? Or any func refs? 

BT: even if they were typed func refs, anything that can be call_indirect-ed. Not for table with non-funcref type.

AR: If you have a typed function ref, then you also don’t need to canonicalize the types? 

BT: goes back t o how type check for call_indirect works. you have to check the right sig, if you can't do that statically, the dynamic check uses this unique identifier.

AR: that's the case if you have a concrete function type

CW: Independent of this, the large part of the speculative optimization is based on inlining, which is orthogonal to this discussion.

JK: if we want to be competitive JS or Java on JVM, we have to do inlining on non-direct calls.

RT: agree, also know that our AOT compiler doesn't do any speculation and inlining and competitive with JS or Java. Not sure if it is as necessary. It varies by benchmark.

JK: Depends on the benchmark

AZ: does varies a lot, in Java every call happens with virtual. This is much more serious now.

RT: we have the AOT compiler, they run relatively the same as Java, C#...

BT: Speculative optimization by gathering indirect call targets is valuable, we should measure this going forward with Wasm engines so we can measure where our overheads are. 

AR: with Wasm, assumption is that most heavy-lifting is done beforehand, that can't cover dynamic optimizations. Worried that we get too deep into that kind of thing, depending on too much magic in Wasm engine, that was the antithesis to the intents of the original design.

JK: We want to do as much as we can ahead of time, two limitations - we are concerned about module size. Uncompressed modules are still 2digit MBs, 10-15Mbs with stripped out names section., The other limitation is that some calls can be devirtualized, but some calls if you use JAva the way it is permitted is not possible to predict ahead of time, 

CW: what does the JVM do in that case? does it do the unsound inlining?

BT: not unsound, but JVM has an inline cache to collect receiver methods, will inline one or more targets if the distribution is skewed

CW: Unsound is the wrong word given the fallback

BT: another thing JVM does is dynamic class hierarchy analysis, for a given class method, has it been overridden, if not it will devirtualize and inline. If you instantiate an object of a class that overrides it, it will deopt code.

CW: Horrifying

BT: beautiful at the same time

AR: hope we haven't created another Java here. In the ideal world we can do all this in the user space, can JIT from within Wasm, express that in Wasm itself. That's a long shot, if ever possible.

BT: This is the kind of stuff to figure out over the next few years, Gral VM is a potential target for these types of optimization. The JIT may inline a constant, if you change the global it will change the code.. This method lets you do dynamic call hierarchies etc..

AR: question is how many shortcut we want to take before we have the full-blown machinery. Might have pressure to take shortcuts that are very adhoc.

CW: Off the wall, not realistic…. Never mind

DG: a lot of work in V8, have other engines prototyped this and can share experiences?

LH: We have a partial prototype, not spending a lot of time on that right now.

LW: experimentation is valuable, to see what the optimizations are to be competitive with JS. Once we have parity, we can ask where the optimizations should be. Getting to parity is a prerequisite, biggest risk to address.

JK: IS the dart compiler missing out on optimizations? Any time we have a system providing an unoptimized result, is there a missed opportunity of missing optimization in the other system? This is an intentional choice, any optimizations implemented in Binaryen will benefit the entire ecosystem

CW: agree that what binaryen is doing is incredibly valuable, what do Dart expect their burden to be, do they expect to delegate to Binaryen?

JK: Lot of optimizations on their end, it makes sense to have both language specific optimizations on their end, and language independent optimizations in Binaryen

BT: advantage of doing optimizations in VM is debugging, tracing through your programs. If you use an offline/AOT, you can inline things and you don't see their frames. If you generate unoptimized code, and VM supports debugging, you can step through. E.g. javac doesn't inline. If you think about ecosystem view, generating unoptimized code is a good thing if you want to debug it, not everything is production deployment where you run optimization passes which make it harder to debug.

RT: Context: the DART optimization does whole program optimizations, dynamic classes relying on dynamic optimizations, so we’re relying on different things

### Closure
"
wasi/2022/WASI-09-08.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: September 8 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: September 8, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Poll to advance Spiderlightning to Phase 1
        1. [slides](https://docs.google.com/presentation/d/e/2PACX-1vQAt5BbFRqpS5tLFx0gegpGZ4TFLuSGRIP3kc5BIV6IPtwd6PwjjTsrmND6xqZFlRTXk-lyCwYazSW6/pub)
    1. _Sumbit a PR to add your discussion item here_

### Attendees:
- Lin Clark
- George Kulakowski
- Arne Vogel
- Andrew Brown
- Brian Hardock
- Syrus Akbary
- Mossaka (Joe)
- Dan Gohman
- Joel Dice
- Kevin Hoffman
- Krisztian Gacsal
- danbugs
- Kyle B
- Luke Wagner
- Mingqiu Sun
- Nick Vidal
- Nicolas Devillard
- Chris Woods
- Onescu Alexandru-Vlad
- Piotr Sikora
- Adam Mohammed
- Yong He
- Steve Schoettler
- Victor Barros
- Valery Antopol
- Frank Schaffa
- Patrick Hickey
- Chris Suszynski
- Ayako Akasaka


## SpiderLightning poll

- mossaka
  - quick overview again
  - abstract out higher-level capabilities like “key-value store”
  - high level, and agnostic to backend providers
  - intended for distributed applications
  - allow configuration at deployment time
- Piotr Sikora
  - what does it mean to advance to phase 1?
  - previous proposals have had the feedback to split into smaller pieces
  - so is this the interfaces or sdk
- mossaka
  - in my find, it’s the interfaces for phase 1
- Lin Clark
  - would there be a challenge in advancing these as separate proposals
- Mossaka
  - one overlap is common (de)deserializing formats
  - will be a good example of a world file when wasi preview2 comes out
- Lin Clark
  - so SpiderLightning may want to advance as a profile proposal
  - we haven’t thought through how that works
- Andrew Brown
  - my understanding is that there would be some attempt to reconcile SpiderLightning with some of Piotr’s mentioned previous proposals
- Kevin Hoffman
  - if SpiderLightning as a whole constitutes a profile, does that mean using it mean you are locked into the entire suite of wit files?
  - have often seen factorings where some modules use different parts of the system
- Luke Wagner
  - I think that is a great concern
  - defining world files right now
  - which interfaces are imported and exported
  - but a component living in that world can still run in other places that provide and need those interfaces
- Kevin Hoffman
  - that does seem to line up with the need to depend on only part
- Luke Wagner
  - we should consider bringing up these decisions in a WASI meeting soon
- Syrus Akbary
  - the name of the proposal was opaque to me, it is not very self descriptive
  - you describe the proposal as being about cloud events
  - maybe a name mentioning that would help
- mossaka
  - that’s good feedback, thanks
- Kevin Hoffman
  - this may be too in the weeds, but what if there are two conflicting key-value contracts
  - how do we make sure that we have at least a lot of use of one kv store interface (say).
- Luke Wagner
  - currently everyone has to type their own anyway
  - so we can only get better by sharing
  - there’ll still be specialization
- Kevin Hoffman
  - my other question is around discoverability
  - suppose there’s related interfaces like kv, kv-simple, kv-extended
  - how do they discover the right wheel and not reinvent it
- Luke Wagner
  - distinguishing between programmatically and human interpreted strings
  - the former sure seem like they want to be urls
  - could possibly claim the a url scheme, so we can have wasi:// urls
- mossaka
  - another perspective and issue is that even if we have those related interfaces, there’s still the challenge of different kv implementations. for example, some kv stores allow scanning and others do not.
  - classic portability problem. being more implementation agnostic means missing out on less portable features
  - our design challenge is finding good places in this space. for example, do we provide scanning as an api, and teach developers that using that may reduce the portability of their applications?
- Piotr Sikora
  - if we have too many different key-value stores, then we are trading off portability, and I would wonder what is the port of standardization
- Luke Wagner
  - we can do one small set of things
  - there’s always the escape hatch of doing your own thing, which is no worse than the status quo
- Lin Clark
  - I would propose the following, and do want feedback on it
  - we put SpiderLighting in phase 0, with a note saying that individual interfaces will move through it independently
  - this lets us link all the proposals together, while allowing us to advance individual interfaces as separate repos 
  - do we want to poll on individual interfaces, or is that premature? specifically, I think anything mentioned last week is plausible to poll about this meeting
- Kevin Hoffman
  - more of a procedural question
  - this was presented as a single bundle
  - if we are going to proceed, it would be nice to have a discussion on each interface separately
- Lin Clark
  - too soon to talk about design specifically
  - this is just to decide whether this is in scope for us to discuss at all
- Steve Schoettler
  - I am also interested in evaluating each domain API separately
- Lin Clark
  - I’m suggesting separate polls for each of those domains
- Dan Gohman
  - there’s a lot of commonality between interfaces
  - events, serialization types, etc
  - there seems to be space for design iteration
- Kevin Hoffman
  - some of those seem like design-time concerns
  - I wanted to avoid this bundling to begin with
  - but these are very conceptually different things, and I think their scope should be considered separately
- Lin Clark
  - maybe we can move forward about whether there is disagreement about any of the proposed interfaces
- Kyle Brown
  - I was wondering if it was possible for Joe/Mossaka to put together an overview of these, the backing implementations, competing proposals, and so on
- Mossaka
  - https://github.com/deislabs/spiderlightning/blob/main/docs/primer.md lists the interfaces
- Dan Gohman
  - http seems new and an expansion of scope
- Lin Clark
  - ok, we can move forward with the poll following the presentation on those capabilities
- David Justice
  - I see small worlds building up into larger worlds
  - this world is closer to cloud applications world
  - i would hope we can move towards a more agnostic point of view
- Kyle Brown
  - i’m curious to seeing this proposed after these interfaces are independently standardized
- Luke Wagner
  - think there’ll be an incremental path forward here
  - like to think of those other proposals as opportunities rather than competitors
- Mossaka
  - custom pluggable functions can be ignored
- Kevin Hoffman	
  - is figuring out the names separate from deciding whether or not things are in scope
- Piotr Sikora
  - there are a fair amount of overlaps
- Andrew Brown
  - my underlying concern is that I would like to see differences between those previously existing proposals to be figured out
- Lin Clark
  - consensus poll for each of these individually
- Lin Clark
  - Poll: distributed lock service (advances)
- Kevin Hoffman
  - if things are so ubiquitous that we can agree on a common abstraction, distributed locks are not very high on that list
  - maybe this is a design concern
  - but seems like it is a much less agreed-upon contract
- David Justice
  - going to be many different contracts and implementors
  - there may be a lifetime where an app goes from a shared interface for the behavior to a more specific one
- Lin Clark
  - Poll: key value store (advances)
- Piotr Sikora
  - the considerable overlap with previous proposals, but it’s still in scope
- Lin Clark
  - Poll: sql database (advances)
- Lin Clark
  - Poll: message queue (advances)
- Lin Clark
  - Poll: pub sub (advances)
- Lin Clark
  - Poll: blobstore (advance)
- Piotr Sikora
  - what’s the different between blobstore and kvstore and do we need both? on the interface level
- David Justice
  - maybe not at the interface level. semantics get closer to fs semantics
- Piotr Sikora
  - so why not use the posix fs api
- Luke Wagner
  - a smaller, tighter API. also more immutable
- Piotr Sikora
  - readonly files also have to be supported
  - not strongly opposing but it seems premature
- Lin Clark
  - can we resolve after we iterate on the design, and have this concern block advancement to phase 2
- mossaka
  - I really want to hear feedback on these storage layers
  - there are two ways you can go, more granular and then more higher-level storage management
- Lin Clark
  - Poll: runtime config (advanced)
- Piotr Sikora
  - we already have environment variables in WASI preview 1
- Luke Wagner
  - as part of preview 2 that’s being factored, and so hopefully that facet can be shared
- Steve Schoettler
  - competing goals of standardization
  - reduce fractured and duplicate efforts across the industry
  - on the other hand, sometimes want competition to see how things evolve
  - in the place where wasm and wasi is today, having a major evolution between preview1 and preview2, how do we decide if it is too soon to stabilize certain ABIs
- Lin Clark
  - Poll: http server
- Piotr Sikora
  - overlap with proxy
  - grpc just a layer on top of http, do we need it?
- Lin Clark
  - out of time
  - moving ones besides grpc and http forward
"
main/2023/CG-02-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 14th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: February 14th, 5pm-6pm UTC (January 3rd, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Relaxed SIMD phase 4 poll: https://github.com/WebAssembly/relaxed-simd [5 min]
    2. Implementation-defined limits discussion [10 min]
    3. Initial information regarding the next hybrid CG meeting [15 min]
3. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
- Conrad Watt
- Derek Schuff
- Zalim Bashorov
- Chris Woods
- Kevin Moore
- WIllem
- Daniel Hillerström
- Krisztian Gacsal
- Robin Freyler
- Jeff Charles
- Paolo Severini
- Saul Cabrera
- Sergey Rubanov
- Thomas Lively
- Ilya Rezvov
- Alex Crichton
- Nick Fitzgerald
- Alon Zakai
- Yury Delendik
- Andreas Rossberg
- Zhi An Ng
- Heejin Ahn
- Sam Clegg
- Manos Koukoutos
- Nabeel Al-Shamma
- Petr Penzin
- Mingqiu Sun
- Brendan Dahl
- Asumu Takikawa
- Sean Jensen-Grey
- Deepti Gandluri
- Chris Fallin
- Jakob Kummerow
- Keith Winstein
- Slava Kuzmich
- Marat Dukhan
- Francis McCabe
- Shoaib Kamil
- Adam Klein
- Johnnie Birch
- Andrew Brown
- Rick Battagline
- Ashley Nelson
- Luke Wagner
- Emanuel Ziegler
- Peter Huene
- Yuri Iozzelli

### Proposals and discussions
 
#### Relaxed SIMD phase 4 poll: https://github.com/WebAssembly/relaxed-simd [5 min]

ZA Presenting slides. [TODO: Add slides]

Relaxed SIMD to Phase 4

PP: Does SpiderMonkey implement the relaxed semantics? 

YD: we did the relaxed semantics

DG: More context: there was an option that if we ever run into issues with the relaxed semantics/implementation-defined behavior, we have the option to implement them in terms of “strict” SIMD, but it’s not recommended

AR: you say the spec interpreter implements the deterministic semantics. Does that include the change using FMA that we decided on 2 weeks ago?

ZA: Does not include it yet, but will do soon after.

AR: yeah, so this is largely my fault, I didn’t get to review until a couple of days ago. But really technically our entry requirement for phase 4 is that the spec is done. I don’ tknow how far we want to stretch it if it’s still under review and there’s work to be done. I don’t think it will take long. I don’t know theres a reason to rush the vote until the work is done. I worry we’re setting a precedent to play fast-and-loose with the rules.

CW: What is the rule that we’re violating right now? 

AR: that the spec is done. It’s still under review and there are things to fix. And that the interpreter has work still. None of this is a big deal, but I did want to raise the question. It’s really more about setting precedent than about the actual proposal. This proposal overall has moved forward quite quickly, so I don’t know that there’s a reason to rush it.

ZA: Happy to punt this until after we get the right things in place and we’re happy with both the stacks and ???

DS: Can we get a commitment for timely review of the proposal?

AR: I’ll try my best, sometimes there is too much on my plate

CW: just to be completely specific, are we saying that the interpreter implementing the deterministic semantics is going to be a blocker for phase 4? It doesn’t seem like a strict requirement?

AR: That’s a fair point, it seems more ideal if it does so it’s clear that we know what it does. Not a strict requirement. Before we move to Phase 5 we should do it 

TL: I’m unclear on that. You’re saying you’d prefer that the spec interpreter implements the relaxed semantics?

AR: No so that it implements the deterministic mode. There are two ways of doing this here. One is it implements the deterministic mode because it has a deterministic implementation and it would be good if it matched the deterministic mode we specify. We could randomize it to some degree and allow it to exercise the larger semantics. I don’t know if we want to do that, if it’s worth doing that but that would be the other option. But if we have a deterministic implementation, it would be good if it matched the deterministic mode.

TL: I agree, it’s what I would expect for FMA. Are there any other behavior differences that we need to update?

ZA: As far as I can remember no, but I will check and see if they are consistent with the deterministic semantics.

AR: Final remark, Spec is based on the profiles spec draft, but which we haven’t progressed to any phase yet. 

DG: maybe we should schedule for the next meeting and figure out what makes sense for profiles. The repo has some discussion about what do profiles look like, which ones do we care about and which ones we don’t etc. 
Also wanted to add to your previous remark, why is this necessary to move forward. Implementations have been ready for a long time and we need to get this into the hands of users who have been waiting for a year.

AR: Which I understand but there are multiple other proposals which it has been years.

DG: Which is fine, but I just want to respond to that

AR: I think this one has gone exceptionally fast by our standards

CW: Different expectations going forward maybe.

PP: Kind of interesting aspect but the fact that we are going to base it on profiles and profiles is the proposal itself and it’s not in any sort of phase, that sounds somewhat interesting.

CW: I guess I never considered it strictly necessary that we base this on profiles. You can think of relaxed SIMD as the full profile, and then you could base profiles on that.

PP: That was sort of if you are going to standardize the profiles in a different way, I guess you could change the profiles. We haven’t gone through all the normal phases of profiles and figuring out if they actually work the way we want. Could be tricky to undo something that was put in this spec. But that’s the risk if you want to take it.

AR: just to clarify, I think we could of course specify it without profiles, but currently it includes the entire profiles spec. It really is based on it as far as the spec goes. We could undo that but we’d have to update the spec. And since this is really the minimum for profiles, which I don't’ think there’s big disagreement over.

PP: I don’t know how broadly this is defined at the moment, the only concern is that something in the profile part of the spec would have to be removed later and that’s a backwards compatibility problem.

AR: Only thing about profiles that is in there is a framework for determining profiles, it contains the deterministic profile which is what the relaxed SIMD uses right now. There is nothing we don’t need right now but it is defined in a general way that encourages other profiles to be added. I guess the question, I think it makes sense but Im biased obviously.

TL: I agree it seems clear to me that we have consensus that folks want a deterministic profile, and as you said we have spec machinery that doesn’t do anything but define that. So I would be fine merging that spec machinery and the deterministic profile as part of this phase 4 vote. Other future profiles should have separate discussions. 

AR: In terms of what’s an open question on the profiles repo, whether it should include a SIMD profile or not.

TL: right, I think we should discuss that separately.

MD: Don’t all engines include SIMD? 

TL: only web engines. But I think we can separate that from the phase 4 vote.

CW: Anything else to say on this agenda item?

TL: I think we should vote and I’m sympathetic to not setting a precedent of moving too quickly and not ignoring our rules.. Having it on the full CG agenda in the future is not that useful, the only change is that we updated the interpreter. I say we do the vote now and make it provisional on the interpreter work.

AR: Hold on, the main thing is the spec work not the interpreter work. main the PR has to merge. I did the review and there are some minor things. Main thing I think is the spec for FMA. nothing big, it’s just technically not done yet.

TL: so I’d be in favor of a provisional vote saying that once the spec is done, it should move to phase 4 once the spec is ready.

CW: In that case, I’ll run a contingent poll, so contingently, *typing, running a poll in Zoom*

DS: We have 1 against vote, let’s give that person an opportunity to have a statement. If someone wants to do that, now is your chance. Usually we know who it is, but we don’t this time (because of Zoom vote)

**Poll** Relaxed-SIMD to Phase 4:

|SF|F|N|A|SA|
|-|-|-|-|-|
|8|23|6|1|0|


CW: If the against vote would like to speak up, please post on GH or send us an email. Even with the vote, we have a successful vote for Relaxed SIMD moving to phase 4, contingent on the spec getting done.

####  Implementation-defined limits discussion [10 min]

[BT not present, will push to a future meeting]


#### Initial information regarding the next hybrid CG meeting [15 min]

CW: Not all details are finalized, hopefully will follow up with a formal announcement in the next couple of weeks.

https://docs.google.com/presentation/d/1u6h86YKpNiQjIgll6zZiqVk9BkREj3Pr5DB3pYA3p04/edit?usp=sharing

### Closure
"
wasi/2021/WASI-05-06.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the May 6 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: May 6, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Lin Clark
    - Email: lclark@fastly.com

### Registration

None required if you've attended before. Email Lin Clark to sign up if it's your first time. 

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. Meeting agendas and notes moving to the [WebAssembly/meetings repo](https://github.com/WebAssembly/meetings)
    2. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Presentation: Supporting alternative ABIs for blocking function calls (Luke Wagner) ([slides](https://docs.google.com/presentation/d/19Xknjvlmy7WaGoJH496KikOHvdAO66zex_oW_TtLudg))
    2. Demo (if time allows): Update on wasi-io (Dan Gohman)
   
## Notes
### Attendees

- Lin Clark
- Luke Wagner
- Sam Clegg
- Piotr Sikora
- Francis McCabe
- Mark McCaskey
- Dan Gohman
- Andrew Brown
- Mingqiu Sun
- Matt Butcher
- Radu Matei
- Yong He
- Johnnie Birch

**Luke Wagner:** Fleshing out idea from conversation last week. Want to see if this looks reasonable to Piotr

What to do about blocking is an open question for WASI. There are callback style APIs. Challenges when supporting non-async languages. Some languages have some kind of structured concurrency, e.g. greenthread. For such langs, you have to do something. One option is asyncify, but that has significant overhead. Even langs with async have subtle differences, would be hard to capture those difference. 

There’s also blocking style APIs. With blocking APIs, you can support both sync and async pretty efficiently, doing blocking on root of callstack. Big downside is that it requires native engine support.

Question for WASI: Do we just pick one? Seems problematic because interest in all styles. Pick arb based on champion? Do we do both? Or have a single interface that can be programmatically converted to use in both styles?

**Johnnie Birch:** How do you consider wasm and the way that wasm will handle threading?

**Luke Wagner:** Yeah, wasm doesn’t have native wasm threading. Some sketches of what it would look like. Subtle distinction between threads and stacks. When we talk about native wasm threads, that’s something more like pthread or greenthread?

**Johnnie Birch:** Is it possible to compartmentalize?

**Luke Wagner:** Definitely hard question. Hopefully what I present here will go some way to answering.

**Francis McCabe:** If wasm stack switching was already done, how would that… you can answer at end, but how would that affect?

**Luke Wagner:** If the answer is we wouldn’t do two things, then hard questions, but I think there are some scenarios where we do want callback style. Will return at the end.

Recap bits from last CG meeting. Component model, question was to use WASI do you need to use component model? Answer is that you can use WASI without CM. WASI specs could be defined in terms of IT but via canonical ABI can create interfaces that only use core types. WASI can support CM, but doesn’t need everyone to buy into it. One thing that I didn’t explain before, from perspective of compiler, we can think of these as different bin format. LD could either emit component or core module. Since that meeting, Alex has posted PR that has concrete PR for canonical ABI.

Question relevant: what about wasm GC? I also mentioned that we don’t need to have literally one ABI, but it could be parameterized. Linear memory version vs GC version. With memory=linear, signature uses i32s, with GC memory uses GC types. One interface signature but can derive two canonical ABI representations of it.

Idea is to add a blocking attribute to function interface types. Intro ABI variant, blocking=suspend|callback. When callback, exports and imports return callback+closures. When blocking=suspend, exports are sync and generate two sigs, either sync or return future/

To show in more concrete detail [walk through Cannonical ABI blocking variants slide].

**Francis McCabe:** I think there’s a bunch of questions here. The future that you’re returning—who’s going to specify what that future looks like.

**Luke Wagner:** Combination of interface you use and canonical ABI. That’s a thing I left out.

**Francis McCabe:** Reason I ask is diff stack switching proposals will have… not obvious who’s responsible for designing async/await on top of stack switching. So WASI’s taking it on?

**Luke Wagner:** Yes, for these particular kinds of interfaces, yes. So design of canonical ABI would say what you could do on a future. I’ll put a little more detail

**Piotr Sikora:** On the suspend side, you are missing continuation, right? 

**Luke Wagner:** You’d say I’m going to block in the future, can either wait for all to finish select. Either blocking now or in the future. 

**Piotr Sikora:** On the callback side, are interface types enough?

**Luke Wagner:** Doesn’t even block on interface types. Can both work today immediately and in the future.

[Continues with walk through]

From the perspective of the spec, when I’m doing suspend, I call the canonical export func, plain old sync. When I call import adapted functions, I just wait on them

In contrast, when callback, conceptually one adapted function call, but I’m calling deep and then return. When I want to do IO, I call import function, it’s my job as the calling code to do the extra work to get off the call stack. That’s what it looks like from spec perspective.

From impl perspective, probably want a greenthread for suspend. In contrast, when callback can have a host event loop. So this is basically classic event loop. Third possibility, if you have a greenthread no problem doing callback style. Greenthread allows strictly more options, but if you don’t have them can still do the callback ABI.

**Francis McCabe:** Going back to prev slide, would you expect someone exporting a blocking function today to support both implementations. 

**Luke Wagner:** This gets to impl thing here, on hosts that have green threads, I can do both. Until we get stack switching, in which case it can emulate greenthreads

**Sam Clegg:** Or with Asyncify

**Luke Wagner:** If proxy-wasm were to go this direction, what would that look like? [Talk through To adopt in proxy-wasm]

Does this potentially satisfy proxy-wasm’s requirements?

**Piotr Sikora:** I would need to sketch it out. Would on_fetch be enough to satisfy all callbacks without wasm code?

**Luke Wagner:** I’m oversimplifying here, some other calls. For each of them, I think it makes sense to have different exports.

**Francis McCabe:** I have a syntax question. In IT land, one question that comes up is who writes the IT signature.

**Luke Wagner:** In this case it’s WASI.

**Francis McCabe:** So if you’re handwriting, you can put blocking and reentrant on signature. But one scenario is that someone wants to be able to autogenerate IT sigs from C sigs, and blocking and reentrant don’t show up in C.

**Luke Wagner:** You’re right, different scenario, I expect to be handled with macros. If this all worked out, as a component author, I would just say implement that please. It will spit out all the signatures. That’s what we’re going for witx tooling.

**Francis McCabe:** I think both scenarios will show up

**Sam Clegg:** Would given module have to choose between callback and suspend

**Luke Wagner:** You’re right. Component authors would have to specify, and hosts would reject if couldn’t support

**Sam Clegg:** And then fully flexible API would present either option

**Luke Wagner:** I also think blocking composes, satisfying virtualization requirements

**Till Schneidereit:** On web, define in terms of workers

**Sam Clegg:** Can’t multiplex within a worker. Could have an HTTP impl that was using blocking and then a consumer that uses callbacks, and engine could stitch together

**Luke Wagner:** Yeah, and if you’ve been following, JS API is just an example of this

**Piotr Sikora:** Question regarding callback, we’d use function indirection table. Do you know the overhead? 

**Luke Wagner:** I think it should be optimizable. I think crossing cost is the high order bit.

**Piotr Sikora:** Is there any reason not to use some convention

**Luke Wagner:** If you do it right, thing that is expensive is dynamic function signature. You have to go through slow trampoline. That thing doesn’t care because always a pointer. If you have a type specialized code path, but the callee is still an actual pointer. My guess is that in the host you’re going through indirection anyway and we’re not adding that much if any.

**Piotr Sikora:** Thank you, I think this will work. Will need to consider. Should we try this with a small component?

**Luke Wagner:** Yeah, great starting point. Maybe we can help by writing a sketch of the witx toolchain, and you can evaluate that

**Piotr Sikora:** That would be perfect

----

**Dan Gohman:** This is updated version of witx, works with some of the canonical ABI stuff. You can see now that we’re using this new syntax for resources. Can define resources. In IO stream, input and output are like TCP but it’s not just for TCP.

Pseudomonas give you an opaque handle to the resource so don’t need to expose name string. 

Here’s an example of the new syntax. Getting ready for witx to be more of a first class tool. Uses pull buffer from canonical ABI. Gives us a way to abstract over linear memory vs GC buffer. 

Return value is expected. Basically a specialized version of variant. Read isn’t going to tell you what failed. We’re abstracting over the input source because application logic doesn’t need to know, but can talk about how to surface for logging, debugging, etc.

Push buffer and pull buffer really make clear what you’re doing as opposed to in/out. Forward is how we do zero copy IO. 

So that’s a brief overview of what we can do with new IT and witx tooling. Some cool new buffer things. 

**Sam Clegg:** error is built in core type?

**Dan Gohman:** Error is more like a keyword. Literally saying there’s no type there
"
main/2023/CG-12-19.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 19th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: December 19th, 5pm-6pm UTC (December 19th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
    2. Benchmarking subgroup - 10 mins (Ben L. Titzer, Petr Penzin, Saul Cabrera)
    3. Updates on JS Types Reflection - 20 mins (Ilya Rezvov)
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 19th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: December 19th, 5pm-6pm UTC (December 19th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
    2. Benchmarking subgroup - 10 mins (Ben L. Titzer, Petr Penzin, Saul Cabrera)
    3. Updates on JS Types Reflection - 20 mins (Ilya Rezvov)
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
 - Francis McCabe
 - Deepti Gandluri
 - Robin Freyler
 - Doehyun Baek
 - Paolo Severini
 - Michael Ficarra
 - Derek Schuff
 - Zalim Bashorov
 - Mingqiu Sun
 - Sam Clegg
 - Ben Titzer
 - Yury Delendik
 - Daniel Lehmann
 - Saul Cabrera
 - Andrew Brown
 - Oscar Spencer
 - Bailey Hayes
 - Aura Munoz
 - Adam Klein
 - Ryan Hunt
 - Ilya Rezvov
 - Yuri Iozelli
 - Manos Koukoutos
 - Dan Phillips
 - Sean Jensen-Grey
 - Kevin Moore
 - Emanuel Ziegler
 - Chris Woods
 - Heejin Ahn
 - Alon Zakai
 - Ashley Nelson

### Proposals and discussions

#### Benchmarking subgroup - 10 mins (Ben L. Titzer, Petr Penzin, Saul Cabrera)

BT: we’d talked about putting together a benchmarking subgroup, to work on that. It seems to require chairs, a charter/mission statement, and a vote.
There is a repo which is mostly empty, and different efforts, some ongoing, but we want to get everyone together and collaborate and share results.
People have been shy about creating an official benchmark suite, because of the history in JS where we had benchmarks that aren’t representative of real world and competition over those wasn’t good.

BT: We have discussed this in a large email thread offline, a few things came up that can be in the mission statement, providing a benchmarking space for collaboration - we should also share best practices for benchmarking Wasm, in particular what not to do and how to measure and how not to measure

BT: also tools. So developing and sharing tools for benchmarking wasm. There is (sightglass) for measuring lots of things e.g. wasm execution time. Also sharing knowledge about existing projects, I’ve got a few and heard of some others, so we want to be able to make that public facing.

BT: We can’t control how people are going to benchmark, we will give them recommendations, and tools - we want to provide people recommendations. We didn’t write an actual proposed mission statement, probably needed to do a vote. But we’d like to talk about it today, and if we get it down, maybe do the vote.

SC: Don’t have anything to add, I have a draft of the charter. We can post it after the meeting, a TL;DR of what you just said

RH: is there a plan for meetings: frequency, format, etc?

BT: plan was to alternate with SIMD meetings, so every other week in the same time slot.

DG: the recommendations you’re making: different ecosystems have different requirements. How broad would the set of  recommendations be?

BT: i’m thinking it has to be vague and high level, for example we’ve talked about microbenchmarking which has its place but the recommendation would be not to rely too much on that. Also about how you measure startup time, instantiation time. There are ways that don’t quite capture what you're trying to measure, so we’d have recommendations about that. Also a recommendation to have a diverse set of benchmarks. We’ve also had experience with different suites, and we know some characteristics and some limitations so we can help with that too.

DG: Will there be any plans to collaborate/integrate with existing benchmarking frameworks? Jetstream etc. will  

BT: we’ll probably go through a phase where we rotate amongst people to present work that they’ve done, will make sense to invite folks who have designed JS suites e.g. jetstream, to get their opinions and experience, before we get into specific recommendations about what wasm benchmarks to use and how to use them. So we’ll have that discovery phase.

AK: was there a charter that’s visible to read? 

RH: Good practice to have it written down, so we know what we’re voting on

DS: All the stuff we’ve talked about makes high level sense, we don’t have text we agree on, you can post a PR on github so we can iterate on the language, and we can come back to a consensus vote

BT: which repo?

DG: We've’ done this previously on the meetings repo because we create a separate directory for each subgroup for meeting notes and such. Also the meetings and the charter creation can be orthogonal, we can start organizing meetings and such in parallel with nailing down the charter.

#### Updates on JS Types Reflection - 20 mins (Ilya Rezvov)

IR: Presenting [slides](https://docs.google.com/presentation/d/1wtF83QvOKrUIWQ0WiQuf3IzTjd9xQmwmoKKdvsky-Zc/edit#slide=id.p)

Previously: a couple of issues blocked stage 4, I hope I’ve eliminated them now, and also found one new issue. Each of these has an issue filed on github, and a PR that implements the solution. I’m planning to merge those if I don’t get any more feedback here or on the issues.

RH: you’re saying you’ll throw this exception when you call type containing ref type. Is that for any ref type or, just for new types in the GC proposal? Or what exactly are we supporting and not supporting?

IR: Right now as implemented, it has any function references if it doesn’t contain GC types in it, just subtype to funcref, anything that contains a GC type throws an unsupported type exception. 
It’s reasonable because you can always get a type from wasm, and then create a function that has that in its signature and it will work.

RH: If I had a webassembly.function that has an anyref param with a type in it, would that throw an exception? 

IR: yes it will throw. Any heap type other than function will throw “unsupported type”

RH: there’s also externref, we don’t throw for that

IR: We don’t throw that exception

RH: I think we can allow anyref, which is the top type

IR: we don’t convert struct type to anyref automatically. You mean we allow anyref in type signature and return it as is?

RH: Only when the value type is exactly anyref, you would not throw an exception, if it’s any other value type we don’t upcast.

IR: that makes sense too, I don’t know how useful it would be. But we can change it to support that. I’ll do that

RH: There’s also, with typed function references, you could have a non-nullable funcref, which is ref that is non-nullable-  would you throw an exception for that? 

IR: initially how I intended to solve that was right now we have simple string text representation for all supported types, but for ref types I wanted to introduce a more complex structure, with Object with the kind and a nullability flag. so map the nullable argument explicitly.

RH: It’ll be nice to try and represent we can. But throw on tricky cases - anything we can faithfully represent we should so that we don’t have big gaps to fill later. 

IR: I can modify the PR to reflect that too. 

<IR presenting Bonus track slide>

RH: was just reading more on the value typ handling, from reading the GC proposal’s JS API. if you're constructing a global and trying to pass a value type, it looks like it only supports externref and funcref, not anyref. Is this a gap in the GC proposal that wasn’t updated?

IR: Good point, I forgot to update the spec for globals

RH: i’m thinking of the GC proposal. There’s a 2 value type operation that takes a string and takes ths value type, I only see externref and funcref, you can’t create a global with anyref type. Curious if anyone from the GC group remembers that.

IR: As far as I remember, the JS representation for the GC types was limited, and we’re limited on what we can pass

RH for spider monkey we implemented it is that if you wanted to create a global of anyref or structref, we accepted those, but it looks like the JS API specifies that. Is there anyone from V8 here who knows what they do for that?

AK: I don’t see anything obvious in the repo or know off the top of my head.

RH: will follow up offline.

IR: Will follow up with a Phase 4 vote next time.

DS: Next scheduled meeting is Jan 2, but there will probably stlll be people out, and we don’t have any agenda items yet.  Please get them in by Thursday Dec 28 (9AM PST, 18:00 CET) or we’ll cancel it.

### Closure
"
gc/2022/GC-05-17.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 17 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: May 17, 5pm-6pm UTC (May 17, 9am-11am Pacific Standard Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: func <:? any [#293](https://github.com/WebAssembly/gc/issues/293) (30 minutes)
    2. Discussion: type system modes from changing subtyping [#296](https://github.com/WebAssembly/gc/issues/296) (Ben Titzer, 30 minutes)

1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Zalim Bashorov
- Ben Titzer
- Conrad Watt
- Asumu Takikawa
- Slava Kuzmich
- Ilya Rezvov
- Rick Battagline
- Ryan Hunt
- Sam Clegg
- Manos Koukoutos
- Adam Klein
- Francis McCabe
- Aske Simon Christensen
- Justin Michaud
- Alon Zakai
- Andreas Rossberg
- Jakob Kummerow
- George Kulakowski


###  Discussion: func <:? any [#293](https://github.com/WebAssembly/gc/issues/293) (30 minutes)


JK: We use different representations for functions in JS and Wasm to make function calls more efficient in each domain. That means we need to convert the representation on the boundary. Passing an anyref on the boundary, we have to inspect it to see if it’s a function. It would be nice to avoid this performance wart. We decided to drop the subtyping when we standardized funcrefs because there was no use case for it and we still haven’t seen any use cases, so I don’t think we should change it.

AR: To clarify, the decision was to defer it rather than drop it entirely. (Ed note: this note taker disagrees). There is some small extra complication with multiple nulls, in validation, etc.

TL: Since our subtyping is supposed to be subsumptive, it seems like a better representation of the engine to keep them separate.

BT, AR: But it’s only on the boundary.

JK: There is implementation freedom. Can move check to call site rather than boundary.

BT: Could also split externref back out from anyref and use that for passing opaque host references.

JK, AR: That’s already settled.

AR: Isn’t there already something similar happening?

JK: Proving that hostrefs cannot be casted to i31 requires doing extra work as well.

AR: Would want to make that deterministic so that all numbers in range can be downcast to i31.

JK: Do we? Since anyref is open, it can always be an opaque value.

CW: Doesn’t seem like a good idea to have different behavior depending on how engine represents a number.

JK: Doesn’t seem reasonable to be able to expect to be able to inspect an anyref you don’t control.

CW: But you might control it because you generate both the JS and Wasm.

BT: We’re talking about all values in JS. Suppose we chose not to check the i31 range…

RH: I would like to understand the cost of _not_ having the subtype relationship. Would we never be able to add a new type that is a subtype of any? Like closureref for func.bind?

AR: I’m pretty confident that we could add this subtype relationship later, and of course we always need to be able to add new types that are subtypes of any. So closureref would not be a problem.

CW: Would the dead code typing relaxation proposal help?

AR: There’s still something you have to do… Also without top anyref, you have to formulate rules to work on multiple hierarchies.

BT: Would like to know what the cost is on wasmtime, since internally in Wasm there is no cost in V8.

GK: Don’t know, but letting fastly people know that you are wondering.

BT: Would like to know a specific performance number.

AR: Agree. Think we could go either way, keeping types separate now and adding the subtyping later or having the subtyping now and adding a rawfunc type later.

BT: The other consideration is whether we have a use case for the subtyping now. I commented a few weeks ago that it could be useful for universal representations.

TL: What languages would it be useful in?

BT: Virgil, but I don’t expect anyone else to be able to comment. Doesn’t use them yet.

AR: Speculating that we could use them for method pointers.

BT: Would prefer to keep the simpler path now and justify the complexity with performance data in the future. (simpler path is to keep subtyping).

ASC: Anything that adds costs to round tripping will be bad for Dart.

TL: Can we experiment?

ASC: Yes, can make a Dart benchmark and experiment in V8.

AR: Sympathetic, but concerned that we have to pay these costs anyway for i31. What does V8 do with i31 right now.

JK: Not sure, might just disallow it for now. Our goal is to pass anyref as just a pointer with no checks. Could have an uninspectable anyref above inspectable anyref in the type hierarchy.

BT: Isn’t that just an externref type?

AR: If the point of anyref is to be generic over Wasm and host types, then you need to be able to downcast it to the Wasm types.

JK: Externref is currently opaque but can be passed around. This is what we would preserve with an uninspectable top type.

AR: Wouldn’t be virtualizable. You wouldn’t be able to implement an opaque DOM node in Wasm.

JK: I see. Will have to think about that.

TL: Let’s get those performance numbers and revisit this discussion. Sounds like both paths are viable.

CW: Let’s consider i31 as well, since it seems to have similar issues.

BT: … Cast gets more expensive in Wasm.

ASC: Casts from anyref being more expensive is fine as long as casts from eqref do not get more expensive.

AR: I think I also suggested moving cost to cast. The JS call might need to deal with raw Wasm values. Could also only normalize one direction and not the other. But sounds like ASC doesn’t want cost in either direction, which would mean more work in JS.

### Discussion: type system modes from changing subtyping [#296](https://github.com/WebAssembly/gc/issues/296) (Ben Titzer, 30 minutes)

BT: We changed externref to be an alias for anyref. When I updated Wizard, I needed to add a flag for this so it would pass both new and old tests.

CW: To be clear, this is about old tests that tested validation failure?

BT: Yes.

CW: We are going to get ourselves in trouble if we want to do anything here. Any engine has to pay the engineering cost if it wants to support old tests like that.

BT: Agree that the general case needs flags. But subtyping is special. Might assume that new subtypes won’t be added.

TL: Do you think it’s a viable solution to just document in the spec that such assumptions won’t hold?

BT: no.

CW: It requires a contrived change to break things this way.

BT: I agree that if we’re careful, we can make sure that any subtype relation we add in the future is safe now that we know it’s a problem. Worried about which module gets blamed when things go weird between multiple modules produced at different Wasm versions.

AR: The type system would have had to have had some negative information, such as types being documented as closed. I agree we could accidentally add cases that break this, but I think it will be easy to avoid. Especially with anyref, which is open.

CW: Not too concerned about open and closed because we can’t prevent toolchains from treating any as closed and creating a web compat hazard, even if we document it as open.

JK: Can introduce a new type whenever we would otherwise want to add a new subtyping.

CW: That would be safe, but I think it’s stronger than necessary.

BT: Also always safe to add new types on top.

CW: Dangerous part is adding intermediate types.

AR: Don’t think you can break anything by introducing subtyping where you couldn’t observe it before.

CW: Example: supertype of both anyref and funcref, then try to make funcref <: anyref. This is silly, but would definitely break things.

BT: The module that can’t observe subtypes doesn’t go wrong, but an intermediary module, for example a security layer filtering out funrefs wouldn’t be able to filter funcrefs on the version of the language without the subtyping, but then if we add the subtyping and the filter doesn’t get updated, funcrefs could get through.

CW: But this is similar to accidental ABI breaks. Can’t guard against this kind of mistake in general.

BT: But it’s about who gets blamed when things go wrong, and in this case it’s WebAssembly that changes, so WebAssembly will get blamed.

AR: Still don’t think this kind of contract is expressible in Wasm. You can test for the things you know and reject everything else, and that will continue to work.

TL: What is the action item? Is it sufficient to document that this is a hazard and handle it on a case by case basis?

BT: Documentation is good, would also want to bias toward adding subtyping early to avoid hazards. Would also want to bring back externref and place it under anyref.

AR: Might also want to add new subtypes of data in the future. Might have same problem because older modules might get something they don’t expect. So it’s not just anyref that is special here.

JK: The argument I find compelling against bringing back externref is the same virualizability of DOM nodes from before.

AR: Would be happy to have both, but don’t see that they’re practically useful.

BT: Let’s look at all the possible trees we can create from our current types and crank through the implications. Will take an action item to start this.
"
stack/2022/11-7-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 7th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  November 7th, 17:00-18:00 UTC ( November 7th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants

Francis McCabe
Sam Lindley
Daniel Hillerström
Deepti Gandluri
Thomas Lively
Matija Pretnar
Ryan Hunt
Ioanna Dimitriou
Ross Tate
Thibaud Michaud
Justin Michaud
Ilya Rezvov
Adam Klein
Ben Titzer
Michael Knyszek
Brendan Dahl

## Agenda items

1. Review of 'issues' raised during core stack switching discussion in F2F.

This list is transcribed from the meeting notes. 

   * Should we disallow unorthodox entry points to functions?
   * When should we dispatch - suspend/resume/switch event? 
   * Are type checks & dispatches equivalent? (Semantic+Performance implications)
   * What is the role & scope of type checking in stack switching? (Single type of whole computation, multiple types over a computation, effect types)
   * Suspend/resume regime vs switch-only regime for switching computation.
   * Should switching be entangled with communication?
   * What are the implications of dynamic scoping for semantics + performance?
   * What are the tolerable costs of validation for switching?
   * Should the machine enforce structured concurrency?
   * What safety guarantees do we want the machine to enforce? (Intra and inter-module/component)
   * What are the appropriate implementation techniques for dynamic scoping
   * Should the machine support general dynamic scoping?
   * Should stack switching depend on dynamic scoping?
   * funneling references vs accidental capture
   * Do fibers allow heap cycles
   * Are cycles/mutable references required?
   * How much of a concern is memory management to engines? (Do we depend on WasmGC? Do we allow languages to not depend on WasmGC?)
   * Should an unreachable computation be allowed to be garbage collected?
   * What representative use cases are addressed by each proposal which are not addressed by the other?
   * Who are the important stakeholders in the design of wasm stack switching?
   * How can we determine the performance overheads of any given proposal?
   * What kind of experiments are required to compare designs?

We will triage this list, possibly adding new issues and concerns.

## Meeting Notes

### Adoption of the agenda

FM: Would like to triage issue list, figure out what we can remove, what we would like to add.

SL: I have questions about what some of the points mean.

### Discussion: Issues from F2F meeting

FM: Any burning points to raise?

TL: I liked Andreas’s presentation of the design space. It confirmed my belief that the existing fibers and typed continuation proposals are very similar. They are different points in the design space of delimited continuations.

FM: Agree.

#### Unorthodox entry points

FM: Refers to the part of the fibers proposal where a fiber starts in a suspended state and is available to receive events.

RH: As an implementer, these might be tricky to implement.

TL: This seems like a niche issue, since it’s only a problem for specific designs. Not sure it’s worth discussing before we have a big picture.

SL: Could rephrase as “should we disallow the design from having unorthodox entry points.”

FM: Agree. Moving on.

#### dispatches everywhere?

RH: Not clear what context this is for. As a comparison between proposals or divorced from any proposal at all?

SL: Was this arising from the distinction between the typed continuations proposal, where there is only dispatch on suspend, and the fibers proposals where there is a dispatch on resumes as well.

FM: Yes, that’s where “everywhere” comes from.

TL: To use Sam’s previous framing, we can answer “should we disallow designs that dispatch in both directions?” and I think the answer is no. We should at least be open to considering both options here.

#### Are type checks & dispatches equivalent?

FM: I think we can leave this question. There is clearly confusion here.

SL: Was this arising from the idea of dynamic typing via dispatch?

TL: Right, came up again due to dispatch on resume direction. Would be happy to leave this question because we can easily measure the performance impact once we have implementations.

SL: Could consider performance and semantic differences separately.

RH: There were lots of options for how to type transmitted values. Does the type change over the lifetime of the stack resource?

SL: This is also equivalent to whether event tags for suspensions have return types.

TL: Again, I think we should not close the door on either option here. Can guide the decision by producer ergonomics and performance. Tied into previous discussion.

FM: There are also questions about what Wasm types are for.

#### mechanisms for suspension (computation vs message passing/checks for special cases)

FM: Not sure what this is about.

DG: Sorry for hastily scribbled items. We should prioritize them and choose the most important.

RT: I think this is about how control is resumed.

SL: What was the part about checks for special cases?

RT: I don’t know.

FM: We can replace this with something that makes more sense. I would rephrase this as “Suspend/resume regime vs switch-only regime for switching computation.”

SL: You can have combinations of those.

FM: Another missing dimension… “Should switching be entangled with communication?”

TL: Can you give examples?

FM: Goroutines switch control but do not handle communications.

SL: Wasmtime fibers is another example that don’t involve communication. Both current designs do entangle them. Java 19 as well.

FM: When talking to John McCall, he said they would like to separate them out.

#### Is handler lookup dynamic scoping?

RH: What’s unclear to me, is what positive or negative answers to this question would mean for the design and implementation.

SL: When Andreas gave his talk, he gave a version of the design space where you search by the name of a tag, and that’s a dynamic search. He also argued that if you search by the name of a handler, it’s also dynamic.

RT: Don’t think so. He was asserting that validation through a search was the same was dynamic scoping.

TL: Andreas isn’t here to clarify what he meant. Without a precise statement to discuss, not sure we can have a useful conversation here.

RT: Does a transfer uniquely specify a target or not? Are there multiple candidates with some policy to determine which to use? Is there meta-state you need to rely on to determine whether you’re allowed to transfer.

SL: There’s one question of whether the target is uniquely determined. That’s separate from whether determining it requires a dynamic search.

RT: Right, it’s about whether validation requires search.

TL: Validation in the Wasm sense?

RT: No, validation that a transfer is valid and allowed at runtime.

FM: There’s how to do the validation and there’s the performance of validation.

SL: And also the uniqueness of the target.

FM: Dynamic scoping to me means there is a search for the target. The target changes depending on the dynamic context you’re in.

RT: How much context is necessary to determine where you jump to and to determine whether it’s a valid jump.

SL: Lots of different options from Andreas’s slides.

TL: Ross, you said in the meeting that you had a solution that didn’t involve any linear time components. It would be great to get a writeup of that offline.

RT: There is a discussion of switching already with no follow-up. Direct switching is how you get constant time performance.

TL: Sounds right at a high level, but devil is in the details. It would be good to see a complete writeup of how the whole system avoids linear cost.

RT: Can do that, but don’t want folks to immediately say we don’t want to that for unrelated reasons.

... Note taker lost internet ...

#### funneling references vs accidental capture

SL: Claim that you run into the same issue by other means.

FM: Let’s leave it, don’t want to discuss right now.

#### GC questions

FM: Let’s leave this for now.

TL: I think we can definitely say that depending on GC for the full design is fine, because we can always support consumers that don’t want to implement GC via an analogue to MVP Wasm’s indirect function table.

FM: Let’s leave this for now.

#### What representative use cases are addressed by each proposal which are not addressed by the other?

FM: Good questions. Will add “Who are the important stakeholders in the design of wasm stack switching?” Language and engine implementers.

SL: Also application developers

FM: Also end users.

FM: Will also add “How can we determine the performance overheads of any given proposal?”

RT: We know the context switch, however it is represented, is the most expensive operation. So we want to make it so that our proposal doesn’t require any more context switches than a native implementation would.

RT: A lot of these languages already have implementations, so we can count the context switches.

SL: Surely what matters is time, not number of context switches. In a lot of applications, it’s not clear that minimizing context switches has a huge impact. Multicore OCaml is competitive with Rust or Go, but is based on a design where it suspends and resumes to switch, so it does twice as many switches. So there is a real-world counterexample to what you’re saying is obvious.

RT: We’ve also heard from teams for which reducing the number of switches was an important and noticeable optimization.

FM: Want to lift up from the details of this question. This can be folded into whatever experiments we end up doing. Some experiments will show a difference and others won’t.

SL: My concern is premature optimization.

FM: We’re at time, but is there anything obviously missing from the list?

SL: It’s quite sprawling. Maybe we should try triaging it.

RH: If we posted discussion topics on each of these, most of them would not get discussed.

FM: Will post discussions in GitHub and see how things go. Will bring these back for discussion in future meetings as well. Will have to take holidays, etc. into account in the near future.

### Multicore OCaml in practice 

### Adjourn

"
wasi/2021/WASI-04-22.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the April 22 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: April 22, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Lin Clark
    - Email: lclark@fastly.com

### Registration

None required if you've attended before. Email Lin Clark to sign up if it's your first time. 

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. [Proxy-Wasm](https://github.com/proxy-wasm) update (Piotr Sikora, [slides](presentations/2021-04-22-PiotrSikora-Proxy-Wasm.pdf))
    1. _Sumbit a PR to add your agenda item here_

## Notes
### Attendees
- Dan Gohman
- Sam Clegg
- Johnnie Birch
- Mingqiu Sun
- Yong He
- Andrew Brown
- Lin Clark
- Piotr Sikora
- Luke Wagner
- M Butcher
- Mark
- Ralph Squillace


**Piotr Sikora:** Update on proxy-wasm. People have changed, so going to recap.

Primary reason is to extend capabilities of proxies with business logic. Ideally running on different proxies and providers. Run in Nginx, istio, fastly, and works exactly the same on the platforms. Started as part of istio to allow code at runtime with security, but that’s not the only reason. Primary reason is abstraction across different providers.

Have support for logging, metrics, network filters, HTTP and gPRC callouts, can do auth check, have key-value store (non-durable, only used to coordinate e.g. telemetry, not meant as DB), background services and timers, FFI.

Current adoption pretty good, supported in Envoy and Istio Proxy. Alibaba added support to MOSN. Created embeddable Go host library. Have SDKs for AS, C++, Go, Rust. ABI spec is kind of lagging behind, so they are all using last year’s version which isn’t reflected in today’s presentation.

Compared to serverless, we are executing in-process as part of request/response flow, trying to minimize memory overhead, running multiple requests in same VM. Handle as much as possible in the optimized host e.g. TLS processing

Led to a design that’s using reactor, each entry point is an event. Minimize number of calls, e.g. include number and size of headers so you don’t need to do extra call. Transforming pre-opened connections. 

[walk through Example slide]

Changes since last update: trying to align with WASI. Prev memory allocations were happening on host side, e.g. get host headers would call plugin and would then copy to own memory. Context_id is passed as arg, prev this was implied and not part of ABI. Added support to have multiple instances of timers, queues, etc.

Wasi-context. We run multiple plugins as part of the same wasm instance if there are multiple plugins compiled as part of the same wasm  module. Don’t expect this to land in WASI in this form.

Wasi-common. Retrieve data, get/set property. I put them in common because they are shared across http proxy and bytestream, etc. Perhaps should move towards something more generic.

Wasi-bytestream. TCP, UDP stream, QUIC. 

Wasi-http or wasi-http-proxy. 

wasi-http-client . 

**Sam Clegg:** So if WASI developed async, you could use that.

**Dan Gohman:** The Wasm stack switching proposal is the place where that async work is happening.

**Sam Clegg:** I wonder if this changes—instead of having callout ID, you would use the stack.

Wasi-grpc. Similar set of APIs. bidirectional open http2 request. Wondering whether this should be separate component, or whether should be layered on top of http. Left as dedicated abi because of small details.

**Dan Gohman:** are the on functions calling _____

Now for straightforward components: wasi-log. Print_f or std_out. Level so we don’t waste time for hosts that dont’ care about certain levels.

**Dan Gohman:** Minimizing calls because APIs are expensive? 

**Piotr Sikora:** Again, this is running in process. Because of that, we’re looking at 300-400 nanosecond. Maybe premature optimization.

Wasi-kvstore. Not sure whether this is something that should be standardized in WASI. Can create new or open existing KV store. Make sure it’s atomic. 

wasi-queue . similar to prev. We just use it to shift stats from each of the workers to aggregated.

Wasi-timer. Used to periodically call into the plugins so it can perform some background task.

Wasi-metrics. Maintained by the host.

Wasi-ffi. Support for foreign functions.

Next steps: alignment with WASI. Write witx, need to migrate to handles, need to see whether can leverage wasi-io. 

New features: load balancing, tighter integration with cache control, ability to follow redirects because right now ABI makes it ugly, support for starttls because some start with plain text and then start tls in middle of connection, possibly UDP datagrams.

Any questions, comments?

**Sam Clegg:** What VM options do you provide?

**Piotr Sikora:** We’re running on V8, but envoy supports both Wasmtime and WAVM, and PR in progress for WAMR.

**Sam Clegg:** When you have the on callbacks, those are exports from the module, and the others are imports. Is this the first time we’re talking about exports of a wasm module.

**Dan Gohman:** Yes, currently tooling gaps

**Sam Clegg:** Once we have funcrefs, would it be better to use those than IDs.

**Luke Wagner:** One idea in other contexts, is distinction between interface and profile. It sounds like we’re talking about profiles to describe proxy filter. 

**Piotr Sikora:** Definitely

**Luke Wagner:** There might be perf improvement if they aren’t callbacks

**Sam Clegg:** Funcrefs would require some sort of bind

**Luke Wagner:** IT wants to statically know the functions, so that works better when they are static exports.

**Dan Gohman:** At some level core wasm doesn’t like mutually recursive instances. This seems to have APIs that would want that, eg log interface. Have any ideas to resolve? 

**Piotr Sikora:** One is host and one is module.

**Dan Gohman:** Thinking in terms of virtualization.

**Sam Clegg:** You would need mutual instantiation in order to satisfy.

**Piotr Sikora:** Those would be statically linked at compile time. Right now we solve this through SDK, so delivered as part of the same WASI module.

**Dan Gohman:** Goal is to make all of these virtualizable. How would we do that in the case of wasm module implementation. To be sure, this is a loaded question.

**Piotr Sikora:** Log doesn’t depend on anything.

**Dan Gohman:** You do have the program depending on the log module, the log module

**Luke Wagner:** You may need to split this into two modules. Containment relationship

**Sam Clegg:** Presumably only one log module, so there’s a multiplexing here, is that right? Could have 1000 plugins and there’s only 1 log instance.

**Luke Wagner:** So you’d have 1 of the inner things, and N of the outer things. Might be an interesting question of whether this could just be a function call.

**Dan Gohman:** Maybe the log function could return current log level. 

**Sam Clegg:** Highlights some sort of design space we need to think about

**Andrew Brown:** essence of the problem here. IIn order to work, every module needs to register somewhere and there’s no good place.

**Dan Gohman:** Good question. Does everyone get their own log instance. Can you run multiple plugins in same store. 

**Piotr Sikora:** Yes. share an instance

**Andrew Brown:** The instance we’re talking about is a host instance for loggin.

**Dan Gohman:** Sort of both. Should de-emphasize the instance

**Sam Clegg:** Something that changed over the last year or so. We now think more about virtualizability. Never made a formal announcement, but that’s the way that’s it’s going.

**Piotr Sikora:** Now I understand the issue. So I guess the question is do we see these components as something that we want to include.

**Dan Gohman:** Certainly a lot of functionality that’s common to a lot of things. I think question is with the callback interface, will that be generalized enough, or is this more of a specialized use case? People doing HTTP that are using no callbacks. Do we need separate APIs for that?

**Piotr Sikora:** Good question, prefer same APIs. 

**Dan Gohman:** The callback model requires fundamentally different model. E.g. C++ doesn’t have a way of getting called ___

**Piotr Sikora:** No main function

**Dan Gohman:** That’s a pretty fundamental difference between models. That’s why we’re working on difference between command and reactor. This is an open question.

**Sam Clegg:** I guess you’re saying that anything that has these callback patterns is by definition a reactor.

**Andrew Brown:** Kind of changes requirements of WASI APIs, because if you’re one of these reactors that can look at HTTP headers, you have to export that function, which is a WASI requirement that we didn’t have before.

**Piotr Sikora:** But that’s the whole point of WASI reactors

**Dan Gohman:** What I would like to see then, could someone mock up end-to-end command style program that has callbacks 

**Piotr Sikora:** Those are by definition mutually exclusive

**Dan Gohman:** That gets to my question. Do we need to have separate APIs. If we’re going to have one, then I’d like to see how it works.

**Andrew Brown:** It would be nice to just have one.

**Piotr Sikora:** Blocking

**Dan Gohman:** In regard to blocking, WASI is deferring to Wasm’s async model. Not practical in short term, so I think there’s space for doing something now with a custom async model, but that’s the current space that we’re in. But feels like it has bearing on whether it bifurcates the API.

**Andrew Brown:** Bringing this up brings up a great question. On other note, does this support client? 

**Piotr Sikora:** Any idea when async may be widely available. 

**Luke Wagner:** Like idea someone else brought up, maybe doesn’t have to wait.

**Lin Clark**: Next steps?

**Andrew Brown**: Seems like a convo about callbacks

**Luke Wagner:** Should have more to say about async after next Tuesday’s CG meeting

**Lin Clark:** Ok, I’ll follow up with those involved in the discussion to see whether this is offline chat or should be covered in next meeting.



"
wasi/2022/WASI-06-02.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: June 2 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: June 2, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Component Model async proposal (updated) (slides: [pdf](presentations/2022-06-02-luke-async.pdf), [live](https://docs.google.com/presentation/d/1MNVOZ8hdofO3tI0szg_i-Yoy0N2QPU2C--LzVuoGSlE))

## Notes

### Attendees
- Lin Clark
- George Kulakowski
- Andrew Brown
- Jeff Charles
- Bailey Hayes
- Saúl Cabrera
- Luke Wagner
- Adam Mohammed
- Dan Gohman
- Yong He
- Dave Bakker
- Till Schneidereit
- Alex Crichton
- Mingqiu Sun
- Sebastien Deleuze
- Josh Triplett
- Aaron Schlesinger
- danbugs
- Jeff Charles
- Johnnie Birch
- Mossaka
- Petr Penzin
- Piotr Sikora
- Ralph Squillace
- Syrus Akbary
- Thomas Lively
- Granville Schmidt
- Kevin Moore

### Component Model async proposal (updated)

[live slides on the component model](https://docs.google.com/presentation/d/1MNVOZ8hdofO3tI0szg_i-Yoy0N2QPU2C--LzVuoGSlE/)

**Lin Clark**: Part 1 of 2 on this proposal, which Luke expects will take more than 1 meeting

**Luke Wagner**: update from last time
- motivation
- background: synchronous Canonical ABI
- Async support
  - future
  - callback abi (optimization)
  - eager return (optimization)
  - stream (optimization)
  - splicing and skipping stream (optimization)
- more for next time :)

- motivation
  - How do we specify async/non-blocking operations in WASI and wit?
  - Can’t we just add first-class functions / callbacks to wit?
    - Cycle leak problems especially in non-GC settings
      - note that browsers are able to de this in js settings by controlling code on both sides
    - Callbacks can be very low-level, especially compared to language concurrency models
  - reqs
    - virtualizability
    - efficient i/o when interfacing with the host (epoll, io_uring)
    - ergonomic automatic wit-bindgen bindings
    - support different styles of lang-level concurrency
      - sync
      - nonblocking
      - async
      - coroutine
    - built-in backpressure story
    - integrated select/timeout/cancellation
    - keep executing after returning a final value
    - not force threads, but allow them
- background: synchronous canonical ABI
  - associating core wasm types to component types named in imports/exports
  - canon lift / lower operations
  - produce a core wasm file
  - new, we can wrap this up into a component
    - .wasm + .wit + ABI options
    - now via wit-component
    - maybe later via ldd or equivalent
  - canon abi options
    - example, string encoding to describe and match what you have internally
  - canon lift and lower bracket all component entry/exit operations
  - example of different string encoding options in rust (utf8) vs js (latin1+utf16) being linked together
    - compiler can see all of these together and optimize
      - eg the cross-linear-memory string copy can be fused with and optimized the string transcoding
  - in separate processes, so not like classic async ipc writing into a pipe
- new stuff for async now in wit
  - future type constructor
  - future<T>, eg future<String>
  - still canon lift/lowered
  - also canon return
    - non blocking
    - offering a T for the given future
    - the ptr to the offered T must stay valid until the return-complete event
  - canon wait
    - block until an event; events include
      - return-complete
      - return
  - canon listen
    - offer a buffer to receive the future’s value
    - buffer must stay valid until the return event
    - traps if futures come from canon lower
  - futures can have very different roles
  - in particular coming from imports or exports
  - eg trapping on wrong canon listens
  - can write idiomatic code that says e.g. async/await and have the toolchain lower to the canonical abi
- question time

**Andrew Brown**
- <audio quality was a bit rough, question around futures given vs returned>
**Luke Wagner**
- some are more like out params

**Josh Triplett**
- why allow running code after offering a value?
**Luke Wagner**
- well, streams will generalize this.
- but also something like http handlers. maybe you send out the request response per se, but you still want to do some logging that’s associated with the request but not in the hot path

**Petr Penzin**
- you talk about lowering+lifting, and so those choices mean more for what it means to instantiate the module
**Luke Wagner**
- yes, and in particular with linking we want to have fusing of those adapters of both sides.
- we might want to put this into the spec and describe the “link” step, which is a good time for AOT compilation.
- note also that in the case with one core module, the host could just implement all the imports!
**Petr Penzin**
- what if we use components and a link step, doesn’t that imply having all dependencies statically?
**Luke Wagner**
- loading code is a subtle thing. i expect implementations to be able to load lazily or not. so we want to be able to AOT compile, but implementations may make different choices.

**Josh Triplett**
- listen and return are both nonblocking. so it seems like there’s not enough information to fuse writes by seeing that the buffer is already there
**Luke Wagner**
- “eager return” is the very first optimization we’re going to talk about
**Josh Triplett**
- what about with streams and multiple values?
**Luke Wagner**
- scatter/gather, nope not yet. worth considering. we can do N at once now though, but lets cover streams.

**Luke Wagner**
- back to presentation
- linked components, working through the control flow
  - something like fetch is asynchronous, so control is yielded back with a returned future
  - the calling code could eg start more async work
  - nthen the calling code waits, control yielded back to its caller, which in this case is across the component boundary
  - eventually the IO completes and the host task gets to copy that data to its caller-provided buffer and so on
  - very chatty without optimization, hence things like eager-return

**George Kulakowski**
- What’s backpressure going to look like?
Luke Wagner
- going to talk more later, but looks like tasks you have but not listening

**Luke Wagner**
- unsure if the futures should be i32 or i64 in wasm64, as they are indices into tables

**Luke Wagner**
- back to presentation
- optimization: callback ABI
  - consider future/promise/task async+await languages
    - rust .NET JS ...
    - wait is always performed at the base of the callstack
    - want to allow producer toolchains to leverage that constraint and elide the stack switch
  - some hosts, native stack switching doesn’t exist or is expensive
  - so generally want to allow callback ABI to directly call
    - and a bool of whether you are finished
  - encapsulated implementation detail
  - composes with non-callback
  - directly call rather than suspend stacks
  - composable, can use both

**Bailey Hayes**
- do you think you can eliminate some of these copies?
**Luke Wagner**
- some of these copies are ones that are semantically copies out of the host. that could be eg via io_uring to go directly into the userspace buffer.
- some are what we conceded with the shared-nothing component model.

**Petr Penzin**
- using the callback ABI means compiling the code very differently?
**Luke Wagner**
- yes! I suspect toolchains will do all one or the other, generally. can imagine wanting to expose this more fine-grainedly in some contexts
**Petr Penzin**
- yeah, openmp say
**Luke Wagner**
- one thing we should be able to do is implement existing libc in terms of this. kick of, listen, wait
- stack switching proposal would allow blocking ABI to run on the web context. specifically, the promise integration. asyncify would also work but expensive

**Josh Triplett**
- what is the story for cancellation?
**Luke Wagner**
- part 2 structured concurrency will address that

**Kevin Moore**
- hi from the dart team. do we think we can maintain our individual quirks in terms of runtime semantics?
**Luke Wagner**
- we do. one way we think of this is that languages already bridge this by running on different OS semantics. and so we think this is general and flexible enough
**Kevin Moore**
- what about debugging? eg stack traces
**Luke Wagner**
- also part of structured concurrency. tasks forming a tree helps.
- to be fair, cross language call stacks challenging. the language will need to help the debugger traverse each language’s part of the call stack

**Petr Penzin**
- following on with Kevin and wondering about what the different semantics are, and what dart has
**Kevin Moore**
- i’d have to talk to our js engineers. know there are some subtle differences, like when tasks start.
- want to see if all the different models
**Luke Wagner**
- being able to compile to JS is a good sign that you are adaptable
**Petr Penzin**
- depends how sophisticated your state machine is perhaps

**Luke Wagner**
- back to presentation
- optimization: eager return
  - if the result is already available, future adds overhead
  - add nuance to the async cabi operations to know if they are done etc
  - brings us very close to a synchronous looking callstack

**Bailey Hayes**
- are implementations already in flight?
**Luke Wagner**
- maybe Alex can speak more to what he’s worked on
**Alex Crichton**
- we’re working on component model work but not yet to the async work
**Bailey Hayes**
- a lot feels similar to prototypes of async work that Alex showed
**Alex Crichton**
- ah yes. a lot of this exists in a prototype state, in particular the compiling-down parts. but not a lot yet of async support in wasmtime yet.
"
main/2017/WG-09-15.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 15th video call of WebAssembly's Working Group

- **Host**: Google Hangouts
- **Dates**: Friday September 15th, 2017
- **Times**: 9:00-10:00am Pacific Time
- **Location**: *Brad will email Google Hangouts link to WG members prior to the meeting*
- **Contact**:
    - Name: Brad Nelson
    - Email: bradnelson@google.com

### Registration

None required if you've attended before. Email Brad Nelson to sign up if it's
your first time. The meeting is open to WG members only (we'll likely broaden
this in future meetings).

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Openness (Brad Nelson)
       1. Discussion on how open the WG process should be.
          * We're obviously bound by general W3C:
          * [W3C Openness](https://www.w3.org/wiki/OpenAndTransparentW3C/Group_Openness)
          * [Membership](https://www.w3.org/Consortium/membership-faq.html)
       1. POLL: We will open up WG meetings to all CG members (for observation).
    1. Mailing list
       1. POLL: We should share the Community Group mailing lists:
          * public-webassembly@w3.org  ( not auto-signup )
          * public-webassembly-announce@w3.org
    1. Scope of v.1 specification
       1. Discussion on which things should be included in the initial
          specific, possibilities include:
          1. [WebAssembly core spec](https://github.com/WebAssembly/spec)
             1. Core format
             1. Reference interpreter
          1. Test suite
          1. [JavaScript embedding](https://github.com/WebAssembly/design/blob/master/JS.md)
             * [Draft spec](https://littledan.github.io/spec/document/JS.html)
          1. [Web embedding](https://github.com/WebAssembly/design/blob/master/Web.md)
       1. POLL: We should limit v.1 to core specification only.
          This excludes: the JavaScript embedding,
          Web embedding, reference interpreter, and test suite.
    1. Spec repo logistics
       1. Should we branch or fork the repo to capture Working Group state?
    1. Adoption of CG specification
       1. Discussion of state of the core specification.
       1. POLL: We should officially tag and adopt a revision of the spec as
          the WG input.
       1. Discussion on the process of adopting a ""First Public Working Draft"" for WebAssembly v.1.
    1. Discussion of coordination with the Community Group.
       1. Discussion of [draft phases proposal](https://github.com/WebAssembly/meetings/blob/master/process/phases.md).
       1. POLL: We should revise the phases proposal to include recommendations on when browsers ship features.
       1. POLL: We should adopt the phases proposal in coordination with the Community Group.
    1. Future meetings
       1. Discussion of timing for future meetings.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Dates and locations of future meetings

| Dates                    | Location          | Host       |
|--------------------------|-------------------|------------|
| 2017-11-01 to 2017-11-02 | Santa Clara, CA   | Intel      |
| 2017-11-06 to 2017-11-07 | Burlingame, CA    | TPAC       |

## Meeting notes

##  Roll call

* Ahn, Heejin
* Bastien, JF
* Christiansen, Kenneth
* Ehrenberg, Daniel
* Ferris, Michael
* Gandluri, Deepti
* Gravelle, Jacob
* Holk, Eric
* Holman, Michael
* Jensen, Peter
* Miller, Mark
* Nattestad, Thomas
* Nelson, Bradley 
* Prud'hommeaux, Eric
* Purushan, Arun
* Rossberg, Andreas
* Schuff, Derek
* Smith, Michael[tm]
* Tillmann, Nikolai
* van Oortmerssen, Wouter
* Wagner, Luke

### Find volunteers for note taking (chair to volunteer).

JF volunteers to take notes.

### Adoption of the agenda

JF seconds motion to adopt.

### Proposals and discussions

#### Openness (Brad Nelson)

Discussion on how open the WG process should be.
  * We're obviously bound by general W3C:
    * [W3C Openness](https://www.w3.org/wiki/OpenAndTransparentW3C/Group_Openness)
    * [Membership](https://www.w3.org/Consortium/membership-faq.html)

Brad: Trying to be as open as possible. Bound by W3C rules. Folks should feel free to speak freely. Proposal is to allow non-WG members to observe without material participation.

MikeH: How often will we be meeting?

Brad: We'll discuss in a later item, but I was imagining every month, more frequent until we have logistics sorted out.

Brad: The WG is how we produce a formal recommendation, there are legal implications. Mostly a rubber-stamp for the CG work.

MikeH: If we don’t have the meetings that often may be useful to keep closed in case something comes up.

JF: How do other W3C groups handle this?

EricP / MikeS: Not much precedence for this, WebAssembly is fairly exceptional. Started fully-formed. Have tests, implementations, specification. We don’t normally start out this way. This is good. Breaking new ground, we might not have infra / process down for this. One motivation to have a delineation of who’s in the WG is that companies make a patent commitment. Implication of having an open group is that non-WG members could bring IP to the discussion without contributing it. Seems like a small risk, many players have signed on. This is something you should talk to your lawyers about. The CG has a CLA, it’s quite different from the WG. <details omitted from notes, see documents and talk to layer for details>

**POLL: We will open up WG meetings to all CG members (for observation).**

| SF | F | N | A | SA |
| 4 | 13 | 2 | 1 | 0 |

MikeH: If we open for observation, it’s just another CG meeting. We might want WG meetings to be something else.

Brad: There’s no reason we can’t call a closed meeting if need be. If we find ourselves calling closed meetings often then it’s new information which warrants revisiting this poll.

#### Mailing list

**POLL: We should share the Community Group mailing lists:**
   * public-webassembly@w3.org  ( not auto-signup )
   * public-webassembly-announce@w3.org

JF: If goal is to have CG create work, and WG adopt it, then seeing the work progress seems nice.

Brad: Any objections to sharing lists?

*Unanimous consent.*

#### Scope of v.1 specification

       1. Discussion on which things should be included in the initial
          specific, possibilities include:
          1. [WebAssembly core spec](https://github.com/WebAssembly/spec)
             1. Core format
             1. Reference interpreter
          1. Test suite
          1. [JavaScript embedding](https://github.com/WebAssembly/design/blob/master/JS.md)
             * [Draft spec](https://littledan.github.io/spec/document/JS.html)
          1. [Web embedding](https://github.com/WebAssembly/design/blob/master/Web.md)

Brad: Have core spec, tests, interpreter, etc. Recently DanE started working on JS / Web embedding. Do we want to split what we publish?

DanE: The JS integration spec isn’t done yet. In a month or two it’ll be in a more complete state.

Brad: Do you think the union of these things forms our spec, or is it more useful to have a V1 of each?

DanE: There are different parts of the web embedding doc. Maybe some would make sense as a separate section.

Andreas: Working assumption in CG was separate specs. Definitely separate documents. They’re written in different styles and tools. About versioning, I don’t know if that matters to keep them common.

Luke: There will be dependencies. JS binding will depend on certain core spec things.

Andreas: True, but we’ll have dependencies on other specs.

DanE: There’s not a solid API surface between them. I wouldn’t want to maintain against multiple WebAssembly versions. I’d like them sort of connected.

JF: Important to understand that JS and Web parts aren’t required for WebAssembly. They’re optional to embeddings e.g. node.js embedding wouldn’t have Web part, and full native embedding wouldn’t have JS either.

Brad: Publishing first draft starts some clocks ticking too.

Andreas: There’s interest in using non-JS embeddings.

Luke: Any restrictions to publishing multiple specs?

EricP: No, only want to make sure what you publish is in the charter.

Luke: Some embeddings might want to make AOT step on install.

JF: I think core question is whether we move forward with a pre-publication for the core spec, which is ready to start now, or whether we wait for JS / Web to be ready. If we move forward we can figure out how to bundle (one doc or multiple) later.

DanE: the JS spec may require some additions to the core spec to expose things, and on the other hand, the JS binding may make changes to what’s shipped by browsers on that end, such as enumerability of methods.

Brad: a useful motivation to move forward is the patent exclusion, and 150 day period. If we start the clock ticking now, then cosmetic changes to the spec don’t reset the clock. If Dan doesn’t uncover anything major then we can talk about first publish.
Andreas: I don’t think technical additions will be needed. I think we’ll want to expose hooks and such.

Dan: I agree.

Brad: In the interest of time, let’s table this poll.

Andreas: Question on separating the tests.

Brad: No serious discussion of them being part of the spec.

*No objection to moving forward*

**POLL: We should proceed on a v.1 of the core specification only (not waiting for the JS + Web embedding, which will be separate docs).**

          This excludes: the JavaScript embedding,
          Web embedding, reference interpreter, and test suite.

*Not polled*

#### Spec repo logistics

       1. Should we branch or fork the repo to capture Working Group state?
    1. Adoption of CG specification
       1. Discussion of state of the core specification.
       1. POLL: We should officially tag and adopt a revision of the spec as
          the WG input.
       1. Discussion on the process of adopting a ""First Public Working Draft"" for WebAssembly v.1.

*Not discussed*

#### Future meetings

Discussion of timing for future meetings.

Brad: I was thinking of meeting every 2 weeks for now, and then reducing cadence. Any objections?

*None*

Brad: Timing isn’t great for Andreas / people in Europe. Anyone from APAC? I was thinking about meeting the opposite week from CG meetings.

Mike: I call in from Tokyo. Time is fine, but we get short end of the stick for all meetings.

Brad: Proposed time would be 2 weeks from now, Tuesday. The 26th of September. We’ve been doing this at 9AM pacific time. Let’s schedule this tentatively.

DanE: This conflicts with TC39.

Brad: Monday September 25th at 9AM pacific time instead?

*No objections*

#### Discussion of coordination with the Community Group.

       1. Discussion of [draft phases proposal](https://github.com/WebAssembly/meetings/blob/master/process/phases.md).
       1. POLL: We should revise the phases proposal to include recommendations on when browsers ship features.
       1. POLL: We should adopt the phases proposal in coordination with the Community Group.

Brad: Please consider these. No time to discuss today.

#### Closure

*Adjourn*
"
main/2022/WG-04-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 13th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: April 13th, 2022 at 3pm-4pm UTC *( April 13th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Proposal to publish the current main branch of the Core, JS API, and Web API specs as `WD-wasm-{core,js-api,web-api}-1.1`
    2. Proposal to enable auto-publish for future spec updates (Eric Prud'hommeaux) [20 min]
1. Closure


## Meeting Notes

### Attendees

* Andreas Rossberg 
* Luke Wagner
* Eric Prud’hommeaux
* Deepti Gandluri
* Derek Schuff
* Philippe Le Hegaret

### Discussion

### Proposal to publish the current main branch of the Core, JS API, and Web API specs as `WD-wasm-{core,js-api,web-api}-1.1`

EP: I dusted off sphinx2HTML. Got a worfklow using respec which takes that output and puts it into W3C format.

Our charter ran out a month ago. W3 approved a short continuation of the old charter, and I am ready to publish a snapshot of the spec from yesterday. I checked a few diffs in the git log and ensured that they show up in the doc. I’m working from gh-pages branch for core and main for js-api and web-api

AR: gh-pages is automated, so it’s updated anytime theres a commit to main

EP: yeah the reason is that I’m using the bikeshed source for js-api and web-api so i can locally change status from editors draft to working draft. I’m using gh-pages for core just because I’m using the HTML output from there.

AR: it get generated from main if you build it there. It just gets committed to gh-pages. 

EP: I can try running the publication process against that

AR: yeah I don’t think there’s anything built in gh-pages, it’s just copied over.

EP: I was just going to use the list of finished proposals as the list of what’s changed since the last document.

AR: the spec has an appendix section which has a list of changes with a little more granularity

EP: so I can point to a subset of that

AR: we didn’t even have it before so everything there is new this time.

EP: so the proposal is to publish this snapshot. It’s not published yet but can be seen at https://www.w3.org/TR/2022/WD-wasm-js-api-1.1-20220414/ (or https://www.w3.org/TR/2022/WD-wasm-core-1.1-20220414/)

LW: so we’re calling this officially version 1.1? We independently landed on that inside the other doc

EP: yeah it just seemed right.

LW: it’s basically semver.

EP: I will have to make one manual patch this time around, but in the future we can publish automatically anytime we commit to main.

AR: in the core API, am I missing the TOC? I just see the first page

EP: you should see a big table of contents

AR: in Chrome it works, on Safari maybe not.

It works for DS in Safari and for EP in Firefox, maybe not for LW in Firefox. There may be a content blocker blocking an analytics script, but it’s not clear why that would affect the TOC. Disabling the content blocker seems to make everything load. After some looking at developer tools trying to diagnose exactly what’s happening, EP will follow up with other W3C folks.

EP: I propose we publish the working draft anyway, but we’ll try to get it fixed.

AR: makes sense. Probably we also want to tag the main repo with the version we publish. Previously we had tags like wg-1.0

EP: I pulled this yesterday so if someone wants to create a tag 

DS: ok I can create wg-1.1.draft1

Proposal: Publish the working draft from today.

LW: does this go through the stages and become a REC?

EP: no, this would be going to evergreen

LW: what exactly does that mean?

EP: basically we get to what was previously called candidate recommendation. But we can stay there and keep updating it, rather than going all the way to REC. New changes come in, they go to working draft, and they go to CR whenever we want. And we can keep doing that without freezing and going to REC.

AR: does that mean the versions are never actually released?

EP: we can go to a REC anytime we want but if we choose not to, we just keep republishing the CR

AR: so do we bump the version number?

EP: oh I see, I don’t know

LW: do we have a history of versions?

AR: It would still be good to have version numbers, it makes it easier to reason about feature sets that are implemented in a particular engine or whatever. Easier to communicate. I think we should make more regular releases from now on with updated version numbers.

LW: so maybe our ideal is something with minimal process for making docs (evergreen) but which lets us have a history of version snapshots. 

AR: yeah if we can cycle on version numbers while staying on CR that would be ideal. What does the W3C page say officially about the version right now? Will it just say 1.1 forever or how does someone find out that they aren’t looking at the current version?

EP: the REC says “this is what 1.0 was” and will point to the latest. There’s always a “latest” link. 

LW: RECs point to the newest corresponding CR?

EP: yes they should.

LW: will the newest CR point to the previous CR so we can trace backward?

EP: I think so

LW: webassembly.github.io would be a great place to collect those links so we can have a full list.

AR: so when we vote on this, is there another step?

EP: that’s our 1.1, and then the second question is whether we set up autopublishing. So we need to figure out if this will let us do what we want, and when to push the button.

AR: yeah I assume version number bumps will have to be at least partially manual. And document how to do it.

EP: it sounds like we aren’t quite ready to say exactly what we want to do about auto publishing then. I can check with W3C about how it works. And then we have to decide when to do it

AR: annually would be nice

LW: or we could bump each time we merge a proposal

AR: we could even rewrite history if we wanted with the existing proposals. 

EP: implementations may be spotty in their implementation of the first feature set.

LW: hopefully not too much.

EP: I’m not sure I know how to publish 5 versions at once tomorrow

AR: do we actually need to publish them all?

LW: could we call this 1.6 and not publish the earlier ones? We could put them in the appendix but not make documents.

AR: nontrapping ops and signext could be together, and reference types and bulk memory can’t be separated

So that would be
1.0 (mutable globals)
1.1 (nontrapping ops, signext)
1.2 (multi-value)
1.3 (bigint)
1.4 (reftypes and and bulk memory)
1.5 (SIMD)


[Philippe Le Hegaret joins]

PLH: it’s weird because you generally only have version numbers when you go to REC. it doesn’t really make sense to have version numbers if you never go to REC. if you don’t want to go all the way to the end of the project.

DS: we could just ignore the official “version number” and just make numbered milestones with the feature sets

LW: what if we have an evergreen CR, and what we call it inside the doc changes over time.

PLH: you can have your own names in the doc. But if you are in evergreen, you don’t have a “version”

AR: which terms are reserved i.e. used by the W3C process?

PLH: version, series, family (level is the same as version in our system)

LW: minor version? If each REC is a major version, we just iterate on the minor version?

AR: not really needed, there are so many synonyms

PLH: we encode the version number in the URL. and the version is in the systems internally. So if you try to change pieces of it, there could be issues. The “latest” link could not have a version. You can still call the next one 1.1 but it won’t be exposed everywhere

LW: what we want to avoid if there’s confusion about how they interact. If we start a new system it could be 2.0 and then we have the internal milestones

PLH: some other groups are hiding the version in the doc and it’s only in the URL

AR: could we call it 1.01?

LW: it’s like the first version was 1, and if we go to 2, we could potentially cut a REC and this would be 2.x

PLH: yeah we could just keep 2 in the URL and do whatever you want to inside the doc (call it 2.4 or anything else)

Post meeting:
In some followup email discussion, it was decided that it makes the most sense to update the official W3C version to 2, which becomes evergreen. We will use release numbers within the doc to designate “minor” or “milestone” revisions, which will be documented (e.g. in the change history in the appendix). Usually this would be when a new proposal is merged.
"
main/2023/CG-08-15.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 15th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: August 15th, 4pm-5pm UTC (August 15th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
   1. Update on Branch Hinting [Yuri Iozzelli, 20 min]
   2. Poll: Advance Extended Name Section to Phase 2 [Ashley Nelson, 10 min]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees

* Chris Woods
* Yuri Iozzelli
* Derek Schuff
* Thomas Lively
* Justin Michaud
* Francis McCabe
* Nick Fitzgerald
* Paolo Severini
* Ryan Hunt
* Saul Cabrera
* Conrad Watt
* Jeff Charles
* Dan Gohman
* Alon Zakai
* Matthew Yacobucci
* Ben Titzer
* Pat Hickey
* Shoaib
* Bailey Hayes
* Johnnie Birch
* Nick Ruff
* Petr Penzin
* Ashley Nelson
* Saúl Cabrera

### Update on Branch Hinting [Yuri Iozzelli, 20 min]

YI presenting [slides](https://drive.google.com/file/d/1b_q4mL6Fa0f7gQmOhX-wENEKksBhOQDU/view?usp=sharing)


FM: In the the branch hinging custom sections, is there a spec version associated with the section? (i.e. so you can tell what version of the spec the hint is for)?

YI: no, although this can be easily worked around by the nature of the sections. E.g. if there needs to be a change in the format, we can just change the name of the section. Then we don’t break anything. If browsers stop supporting the old version, then it just gets a little slower because the hints aren’t recognized. I don’t really see that as likely with branch hinting though. 

FM: One alternative to having a new kind of custom section would be to version the custom section. Have a new version of the spec, maybe not for branch hinting, with additional functionality. 

YI: For future things, definitely possible, there is a general structure of custom instructions attached. There are only two proposals that are using it for now. Branch hinting and Instrument tracing technology. They can both use it. Future things may need it that’s not taken into account. I think v2 at that point. The names are quite freely chosen. So we could have v1 in the name right now.

FM: Thanks

CW: I saw when you mentioned toolchain support, you didn’t mention Binaryen. Do you have any perspective on that, whether Binaryen might support that?

YI: I cannot speak for Binaryen. I think it would similar to preserving DWARF information. Binaryen takes wasm in and produces wasm out with stuff in the middle. The most difficult thing of preserving custom section is changing the custom section, then I need to change the hints. If I flip the branch to the opposite meaning, then I need to flip the meaning of the ints. I think this is similar to preserving the DWARF but easier because it’s optimized information and not for debugging. But every optimization pass would need to think about this. Some information needs to be attached to the instruction and proper care. I cannot speak of a plan for doing anything in Binaryen right now.

TL: that’s correct. We don’t have concrete plans to implement it, although it would be useful. The part where we update instruction offsets would be no problem, we have things that do that already. And I agree that the tricky part would be where we have optimizations that change branches. We’d probably just drop them if we did the minimum. Hard to say how many would make it through. Doing it properly would be more effort but could be done.

RH: Have you done any data collection on the binary size overhead. Say you have a module and you want to annotate. Do you annotate most branches, some, little?

YI: It’s a bit complex of a question. If e.g. we have an average C++ codebasse we wouldn’t expect a lot. If you’re not very sure the branch is very likely or very unlikely you would’nt add a hint, because you risk making it worse. So I’d expect just a small fraction of branches. If you look in a codebase you can search for e.g. __builtin_expect and there aren’t many in most codebases. So I wou’dn’t expect a lot. There’s also my actual usecase, which isn’t this but JIT-generated code for a runtime. In our x86 VM or a Jav JIT, etc. In that case I would imagine more e.g. for checks/bailouts for slow paths. So there will be a lot more and they are almost never taken. So they are generated at runtime, so my guess would be for AOT codebases there would be few, but more for JITs.

RH: Thanks

YI: if you want to try to reproduce this, there is a basic benchmark (link in the “benchmarks” slide).

DS: Sounds close to being ready for stage 4, what are the mechanics? Sounds like we need to push annotations to stage 4 first, this is a one-way dependency, right?

YI: Yes. My idea would be as soon as custom annotations goes to Phase 4, try for Branch Hinting as well. 

DS: In principle, they could even be voted together


### Poll: Advance Extended Name Section to Phase 2 [Ashley Nelson, 10 min]

AN: presenting [overview.md](https://github.com/WebAssembly/extended-name-section/blob/main/proposals/extended-name-section/Overview.md)

AN: there is quite a bit of support for this already, in V8, Binaryen and emscripten for various name types. We are trending toward phase 4 level of readiness, so I wanted to see what support was like for adding the missing entities, and we should definitely go to phase 2.

FM: does tag name refer to exception tag?

AN: yes

YI: is there an equivalence for the entities in the custom annotations? E.g. it’s about being able to put custom sections in the text format. In the namse section there’s a name annotation, you can name more things that you’d otherwise be able to name in the name section. And it would be more true after this. Maybe it’s already taken into account int he custom annotation proposal.

TL: everything here already has names in the text format, e.g. data segment. The text format already has syntax where you can name a data segment or any of these other entities. So the annotations proposal isn’t necessary to use these names and round trip them. So I’m not familiar with the name annotation you mentioned. It doesn’t seem necessary, but I also wouldn’t anticipate any bad interactions.

YI: Curious because I recently touched this and now we have the tests for the name section,. So I wonder if this new addition should also go to those tests. The ordering of the proposals. 

TL: yeah, adding support for these to existing name section tests sounds great.

PP: on the LLVM side, I think typical native toolchains produce symbol tables a little differently but that shouldn’t stop us. Also this is phase 2, not phase 4, so that shouldn’t block this.

YI: Nothing against advancing this.

TL: Doesn’t interact with linking at all. The LLVM symbols used in linking and debugging. This is useful for debugging in so far as it can give names to things when you disassemble the module. Independent from DWARF. Shouldn’t interact with anything else. 

PP: yeah LLVM typically does what you do for linking symbols, this is parallel. 

BT: is this enough to express all the names that are in the text format and round trip them?

AN: it does include all the names in the text format. Can you say more about round trip?

DS: as far as I know, yes - if not, it should

TL: actually one thing missing here is type names, which can be named (even in MVP linear text format). Those don’t appear here because they’ve been added to the GC proposal, since we assumed that GC would go to phase 4 before this. The GC proposal extends the name section with type names and field names. Field names are of course specific to GC, but type names are important for GC too.
Actually one thing that’s missing for round tripping IIRC, if you define a function type, you’re allowed to give names to the params in the function type, there’s no way to round trip that yet. Nobody has proposed it.

BT: Fair enough, thanks

DS: Something we can possibly rectify if GC goes to Phase 4 and this proposal is still in 2 or 3

YI: With the name annotations proposal you can name parameters. 

TL: That would be solved in the text format or the binary format as well? Right now IIRC you can name parameters in the text format but not in the binary. Double checking that now.

TL (chat): A note from the spec: ""The optional identifier names for parameters in a function type only have documentation purpose. They cannot be referenced from anywhere.""

DS: Any other comments on this proposal for phase 2. Definitely sounding like people are supportive. I think we can just do a unanimous consensus poll. If anyone has any objections for moving this proposal to phase 2, please speak up now. 

*no objections*

DS: Sounds good to me. With that, that is everything on the agenda. Thanks everyone. Remember Deepti has sent out a 
[form](https://docs.google.com/forms/d/e/1FAIpQLSdFUvB3MC9GNMuOMlN8Iab499xW30NaoxRgMWVjRwo9wLrbNQ/viewform?usp=header_link) 
for the hybrid in-person meeting in October. So if you’re interested in coming to that, please fill that out so we can plan. Thanks, see you all in a couple of weeks.





"
gc/2023/GC-05-02.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 2 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: May 2, 4pm-5pm UTC (May 2, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Status checks
        1. Spec documents
        1. Landing bulk array PR ([#363](https://github.com/WebAssembly/gc/pull/363))
    1. Discussion: Finalizing branching cast instructions ([#359](https://github.com/WebAssembly/gc/pull/359))
    1. Discussion: Finalizing instruction opcodes ([#370](https://github.com/WebAssembly/gc/issues/370))
    1. Discussion: Additional bulk array instructions ([#367](https://github.com/WebAssembly/gc/issues/367))
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Craig Latta (first time, I’m writing a WASMGC version of squeak.js.org)
- Andreas Rossberg
- Alon Zakai
- Conrad Watt
- Ashley Nelson
- Ryan Hunt
- Jakob Kummerow
- Deepti Gandluri
- Emanuel Ziegler
- Francis McCabe
- Nick Fitzgerald
- Ben Titzer
- Zalim Bashorov

### Status checks

TL: I saw movement on the PR Conrad was reviewing for Andreas, how is that going and how is everything else looking?

AR: That is merged and I spent last week merging that downstream with the GC proposal, which took a while because there were lots of merge conflicts. Started trying to in the reference interpreter two different approaches to the type representation which would then end up as the spec as well. Still playing with that. Next week I’m going to start with the actual spec.

TL: Next, we have a standing PR from Conrad for the initial bulk array instructions. What. if anything, needs to happen before this lands? 

CW: That PR doesn’t include an overview or spec changes, AR I don’t know if that was your reasoning for deprioritizing it.

AR: Deprioritize it?

CW: I now realize I never formally requested you as an interviewer in GitHub’s interface.

AR: I think I did a round of review but I didn’t realize it was ready.

CW: You might be thinking about threads, this is a different PR on the repository. 

AR: I’m looking at the one Thomas just sent in chat: https://github.com/WebAssembly/gc/pull/363 I see new changes that I haven’t reviewed. Send out a PTAL if you’re done with your addressing comments so reviewers know they should look again.

TL: No spec or overview changes there. AR, I’d be happy to do the overview changes if helpful.

AR: Sure.

TL: I’ll do it then.

AR: Be aware I’m out the rest of the week, will review Monday

### Discussion: Finalizing branching cast instructions ([#359](https://github.com/WebAssembly/gc/pull/359))

TL: Some comments on PR about using a single instruction name if we’re going to have a single base opcode for br_uncast and br_uncast_fail?. Beyond that, we haven’t discussed in detail the scheme ohere we have the base encoding and the additional byte about nullability and if it’s fail or not. Any comments on proposed encoding in this PR or should we just move forward?

BT: I don’t think the discussion reaches the conclusion about whether there should be two opcodes, one for fail, one for pass.

AR: Discussion died down.

TL: I’d like to revive it now. Personally I’m ambivalent. I’d prefer two different bytes if the encodings are shorter.

AR: To make it shorter, we’d need 6 more opcodes, which could be easily doubled in the future, which is why I went with this tentatively, it seems more scalable. We had discussed leaving extension space for more opcodes. For this one, it seems important, because I feel this will have more extensions in the future.

TL: Wish we’d done this for call instructions, seems worth learning from that.

BT: Fail versions, TL you had made the point about v8 debugging so that opcodes matched the opcode bytes. I’d prefer that because the engine generates two different versions, one is taken and one is not taken.

TL: Any strong opinions about naming?

AR: I’m trying to understand what BT is suggesting. Should we have two opcodes or one opcode and basically what Ryan? Suggested, having the immediate fail on the op code to reflect the binary op coding 

BT: Envisioning two opcodes.

AR: So changing the binary encoding. I’m fine with that, we can go either way, no strong opinions.

BT: Not high importance.

TL: If we have to choose a bikeshed color, I’d rather have two different opcodes, two different names because they do two different things. Reduce ad hoc flag immediates we have to add to things.

AR: I can make that change, SGTM.

TL: Just a matter of making changes and landing PR. Any other branch instruction changes? Alright.

### Discussion: Finalizing instruction opcodes ([#370](https://github.com/WebAssembly/gc/issues/370))

TL: Haven’t thought concretely about the optimal organization, I don’t think v8 has strong opinions here, haven’t heard any internally. Anyone want to take point on developing the final opcode numbering? Any strong opinions on what it should look like?

AR: No strong opiniuons, but happy to suggest one. Are there any particular things? If anyone has anything in mind specifically we should care about, speak up now.

TL: In SIMD, we had a chart laid out nicely and we left holes for missing instructions. I don’t think that applies here, so I’m happy with whatever.

AR: Grouping with some holes for obvious anticipations, this will be straightforward.

TL: Implementations, even with final encoding, we plan to wait a bit for implementing to avoid breaking users of the origin trial. Once we’re ready to ship, end the origin trial, push the final op code reordering which will be a breaking change for everyone - phase 4.

### Discussion: Additional bulk array instructions ([#367](https://github.com/WebAssembly/gc/issues/367))

TL: Last discussion is about the infinite space of potentially new bulk array instructions. Matthias was looking at bulk array instructions we can add to support growing a vector. And basically if you come up with the most general possible array allocation or copying it has an absurd number of arguments. Maybe 6 or so. So the question is what should be our design philosophy here. Should we depend on engines to depend on array copies or allocations they can optimize themselves? Or post-MVP should we add in these really complex array implementations. So that the native implementation can be maximally performant.

AR: Why is it more complicated than what we have for table bulk instructions?

TL: For tables and memories, the only instructions we have are copy, fill, init. With arrays, it gets more interesting because we have the dimension of allocating a new one at the same time or copying into a new one. Also there are more things you could be copying from, from another array, from another table, from another element segment. There are more dimensions here.

AR: That seems separate from the number of arguments thing you brought up. I don’t see why that should be worse here than.

TL: In Matthias’s suggested uber-instruction, there is a source_array, source_start_index, copy_length, target_start_index, target_length, and a default_value because you are allocating it, so anything you don’t copy needs a default value.

AR: Source and destination length I wouldn’t have. Copy or build, I think you want to separate that. I don’t think you should do that differently here.

JK: Growing backing array stores is the case where you want to copy what is there but you want to allocate more than what you are copying.

AR: I don’t think you should grow backing stores

JK: If you have a source level array, it can grow. It means when you grow in Java, you have to copy the wasm array and also grow it. And of course you can also grow it in two instructions and then copy the elements that you want. But to make it efficient you have to rely on engines removing the needless copies. Do we want to rely on engines to detect this pattern and optimize it or do we want an instruction to make this explicit?

AR: Not sure we want to address that in the MVP.

BT: This definitely sounds post-MVP to me.

TL: I agree.

CW: Looking at this issue, as a post-MVP thing, the optimized instruction with the 6 parameters doesn’t look very unreasonable to me. I think that is a very legitimate post-MVP proposal as is. Certainly if we’re considering if it’s a slippery slope, there is that matrix that Aske posted in the previous issue which shows it’s 1 of 2 gaps in our capabilities in a pretty regular way. 

NF via Chat: You also don't want to initialize new array with a default value that you then immediately overwrite

TL: Definitely was thinking of this as a post-MVP. Some concerns about slippery slope but the instruction seems reasonable, so there is probably some room to figure out the regular expressions we’ll need in this vein. We can look post-MVP.

AR: Can you clarify what you have in mind for MVP?

TL: Bulk array instructions exactly mirror table and memory bulk instructions. Init, two kinds, init_elem and init_data for the two different kinds of segments. Then we have copy and fill. And that’s it. 

AR: Copy is array to array?

TL: Yes, all non-allocating. Separately, we had new_data and new_elem as well as new_fixed for taking values off of the stack. We have not filled out a regular chart of instructions but we have some nice subcharts if you will. 

TL: Any other things to discuss while we’re all here? Next meeting is a presentation from Intel about compiling a subset of TS to WasmGC.

"
stack/2021/sg-10-18.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 18th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  October 18th, 16:00-17:00 UTC ( October 18th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
- Francis McCabe
- Lars Hansen
- Ben Titzer
- Ayke van Laethem
- Ioanna Dimitriou
- Derek Schuff
- Arjun Guha
- Ross Tate
- Thibaud Michaud
- Sam Lindley
- Deepti Gandluri
- Heejin Ahn
- Andreas Rossberg
- Michael Knyszek
- Luke Wagner
- Paul Schoenfelder




## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. [TinyGo](https://docs.google.com/presentation/d/11n3xICqxy1oqgEl3wv4k7E2DgHf_vVsMKyDffPycU-A/edit?usp=sharing)(Ayke van Laethem)

   2. Next meeting [2 mins].
1. Closure

## Meeting Notes

Presentation of tinygo by Ayke van Laethem (AL)



### Adoption of the agenda

### Discussion:

Ayke presenting the slides.
TinyGo, a go compiler for small embedded devices.
Garbage collection and green threads, relevant here.
In Go every function can be potentially blocking, a problem with Wasm.

- Francis: Is this true for tiny go or go generally?
- Ayke: These two features are for Go in general, but the way tinyGo implements things are a little bit different than the standard compiler. E.g. tinyGo doesn't do parallelism yet, but it does concurrency, as it is a language feature.
- Francis: sounds good.

Continuing with presentation: Slide ""Option 1: LLVM coroutines""
Not very maintainable.

Slide ""Option 2: Asyncify""
Less convenient.

Slide ""Option 3: native stack switching in Wasm?""
Ayke's ideal API solution.

- Francis: About Asyncify, did you use asyncify to implement Go routines?
- Ayke: Someone else did this, and I believe it's working but I haven't looked at it yet.
- Francis: Wondering about the cost of using asyncify there.
- Ayke: It's still WIP, haven't compared the cost, it's interesting. I hope it's less than LLVM.
- Francis: Was option 1 costly in effort?
- Ayke: In maintainability. When trying to switch to LLVM12 the compiler got smarter, and it was hard to do this change, in practice it seems hard to keep up with the changes to LLVM and get them right.
- Francis: Any examples?
- Ayke: For example in Go there is the ""go"" keyword. For example in some occasions (?) the Go code goes to sleep and not returns. LLVM corrects this, so assumes the code after that is unreachable. Trying to go around this, could not find fixes.
- Francis: I can see how this is a problem.

Continuing with slide ""Option 3"", the API that would be exposed to the programmer: `new_stack`, `switch_stack`, `destroy_stack`.

- Sam: More detail on the API functions?
- Ayke: `new_stack` will create a new stack with an opaque id, a number or whatever. Has a function and initial parameter, one should be enough, any more could go to the heap. `switch_stack` would switch to the other stack and start running it.
- Sam: Switching stack to the same id twice would be an error?
- Ayke: When you switch to your own stack?
- Sam: Yes, would that be an error?
- Ayke: Haven't thought about that, an error seems appropriate. Also not destroying the current stack.

- Ben: Switching stack from A to B, then another stack switching to A would wait until A has returned from B?
- Ayke: Do you mean from a parallelism point of view?
- Ben: When I am suspended to B and another call switches back to me, does it wait until B is finished?
- Francis: How would a call know when to switch to which stack?
- Ayke: Runtime should take care of it.
- Ross: How do you change to the originating stack?
- Ayke: An idea would be to give it a fixed id, like 0 and not allow destroying that stack. Destroying stacks is the responsibility of a garbage collector.
- Francis: What happens to the return value from a called thunk?
- Ayke: I guess a void.
- Francis: So return value is ignored?
- Ayke: Yes, because when it returns it exits the coroutine, so returned values would be ignored.
- Sam: Giving the originating stack 0 id, how does it work with multiple such stacks?
- Ayke: 0 is the originating one.
- Ross: You could have a way to return the current stack id.
- Ayke: Yes, that could be useful.
- Ben: ... <notes missing>
- Ayke: ... <notes missing>
- ??: How often do you switch stacks?
- Ayke: Depends on how often you do IO.
- Ross: Presumably also when a channel read happens. How often is that?
- Ayke: Depends, happens often, but less often than you'd call a function.
- Ross: So having noticeable overhead in stack switching would have an effect.
- Ayke: Yes, you wouldn't want this to be expensive.

- Francis: TinyGo for embedded systems?
- Ayke: yes.
- Francis: So you're relying on an external event loop for IO, is this how it's done or are you doing it yourself?
- Ayke: The thing with coroutines, this is unrelated to Wasm, I'm mainly talking about wasi and the web.
- Francis: ... <notes missing>
- Ayke: Microcontrollers can interrupt at any time, stack switching that happens there are operational threads, no IO loop.
- Sam: Are there interrupts that can happen in WebAssembly?
- Ayke: not aware of any. Maybe if JS can call into Wasm, but JS is single threaded.
- Sam: But a computation in Wasm should block.
- Ayke: TinyGo is only single threaded at the moment.
- Sam: So you'd have to return to allow other threads to run?
- Ayke: Spec is silent, haven't implemented it.

... <notes missing> ...

- Ayke: Interrupts are preemptive, there you store the program counter, start executing somewhere else.
- Sam: Not the case for Wasm
- Ayke: right, so Wasm wouldn't be interrupted.

- Ben: Do you check whether you have space to switch on other systems?
- Ayke: There is a check when switching stacks, checking for overflow.
- Ross: So buggy code leads to system crash.
- Ayke: Yes, it's not perfect. Some microcontrollers would try to compute maximum stack space, but not possible when you have recursion.
- Francis: What is more important for TinyGo? Wasm or microcontrollers?
- Ayke: I'm more interested in microcontrollers but running Wasm is important to others.
- Francis: Wasm on microcontrollers is also interesting.
- Ayke: Wasm page size is small for a laptop but huge for microcontrollers.

- Ross: Any more slides?
- Ayke: This is all I have to show from what we'd like to have from Wasm. Reason for this talk is to share how TinyGo does this, and make sure it's considered.
- Ross: How to determine who to switch to next?
- Ayke: Runtime to determine this. Currently using a scheduler.
- Ross: For example Erlang does the computation before switching.
- Ayke: Could be either way.

- Francis: Another way to express Ross's question: Sleep does a yield to the scheduler, so you'd have to know the id of the scheduler.
- Ayke: That's an implementation detail, but there has to be a main stack, otherwise you can't run Wasm. Currently I'm using the main stack as the scheduler, and the interrupt stack, but that's another issue.
- Francis: If you're running a runtime, what is the runtime written in? If it's done in Wasm, then you'd have to do the switching in Wasm.
- Ayke: How I imagine it: entry function runs the scheduler which creates a new stack for the main coroutine (all written in Wasm). When you want to switch stacks you switch back to the scheduler. The entire code is run in go which is compiled to WebAssembly. So the Go runtime is generic Go code, compiled to WebAssembly, so in general is Wasm.

- Francis: Back to microcontrollers, how many threads do you expect to see?
- Ayke: Usually one or just a few due to memory limitations. Don't think people are running hundreds of them, but people might do that. For example a web server could be quite a few.
- Francis: And these microcontrollers don't have real threads.
- Ayke: So you mean parallelism?
- Francis: Yes.
- Ayke: There are microcontrollers with multiple cores, I am only aware of two, but the vast majority have only one core, very uncommon to have more.

- Ross: If your scheduler is written in go, what happens if it does a send or receive?
- Ayke: You shouldn't, there are limitations, like arbitrarily allocating memory. You shouldn't allocate memory while garbage collecting either.
- Ross: So whoever is writing that code should be careful about what subset of the language you use.
- Ayke: Yes.
- Paul: Same happens in Erlang, when we're writing the scheduler. The scheduler thread is essentially privileged, we write it in Rust and compile that to Wasm.
- Ayke: For us it's not privileged, but it's like in C, you should be more careful with memory.
- Ross: We would need to know how the scheduler is compiled, whether it's privileged, to know of any constraints.
- Ayke: In what way would it constrain the stack switching API if it's not privileged code?
- Francis: Having the runtime in Go, even having the runtime in Rust, is putting constraints to Stacks spec.
- Ayke: I could write some assembly directly then.
- Paul: That's what we do in Erlang, some stack switching logic is written by hand.
- Francis: When we say assembly we mean WebAssembly.
- Ayke: That would be fine as well. Maybe it would inhibit a few optimisations but not a big deal.



### Adjourn

"
wasi/2022/WASI-03-24.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: March 24 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: March 24, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. An update on asynchrony in the component model, @aturon and @lukewagner 
    1. _Sumbit a PR to add your agenda item here_

## Notes

### Attendees

- Lin Clark
- Dave Bakker
- Saúl Cabrera
- Jeff Charles
- Sébastien Deleuze
- Dan Gohman
- George Kulakowski
- Piotr Sikora
- Mingqiu Sun
- Aaron Turon
- Radu Matei
- Yong He
- Nick Fitzgerald
- Bailey Hayes
- Till Schneidereit
- Andrew Brown
- David Justice
- Luke Wagner
- Jonnie Birch
- Peter Huene
- Brian Hardock
- Pat Hickey
- David Piepgrass
- Arne Vogel

### Async Update

**Aaron Turon:** Background, Alex and I worked together to develop Rust futures and async blocks in Rust, and as you’ll see many of the ideas apply nicely to the component model. Presentation is one that I gave internally, so high level. Hope is to give you an overall picture of where we’ve come in thinking about async in the component model.

Everything intended to fit into component model built on top of wasm standard. Each component should be written in idiomatic source language but collaborate with other components in diff langs.

Everything I’ll be presenting today will be in terms of canonical ABI, but ideas about how this will interact with adapters. There’s canonical ABI for stitching together, but translates between idiomatic structures and canonical ABI.

As part of this, building on top of Wasm execution model. In that model right now, you can set up a component graph with independent memory for each component and execution is driven by asking engine to execute top level export—the entry point. And exec is sync. At any time, one function in whole component graph. One interesting nuance here is that there’s a distinction between imports from host which can have extra capabilities. Goal is to keep gap between host and component capabilities as small as possible.

Kick off whole thing by execing top level export, which can call into another component or host. That all happens single threaded.

Explain the goals for async. Why async? Couple of distinct motivations. Expressiveness, ability to do things like launch concurrent ops and race them. Need it for idiomacy as well.

Have been keeping in mind different languages that represent the different models of async we want to support (futures, promises, goroutines). Avoiding gotchas for all these. Also make things efficient, and try to make as minimal a proposal as possible. Introducing concurrency risks losing properties, so we keep a single threaded underlying model of execution.

We are setting aside fully multi-threaded because of above, so we’re introducing tasks. It’s concurrent but not necessarily parallel.

We are going to have a notion of an async function import or export in IT. When you import an async function, you’re actually spawning a new task. To begin with, don’t expect to have a persistent stack. Not a greenthreaded kind of model. But we want to anticipate that greenthreads or coroutines could be added later. Way to think of a task is the inner body of an event loop where the el is being managed by the runtime. This is a fairly common impl approach even if langs don’t surface it directly. Internally, you can have lots of async tasks, …..

Final note, there are langs like Go that bake in greenthreaded. In meantime, use things like LLVM or asyncify to handle.

**Andrew Brown:** What about when you have async calls inside a component.

**Aaron Turon:** Depends on how you’ve set up language glue. We don’t expect that to be visible at the component model level. That’s internal to the component. I was mentioned having fine grained task when you cross boundary, but inside much coarser grained.

Every component in this world… the glue code involves a top level event loop. You can create internal concurrency within that component however you like. How you multiplex between tasks in your own event loop is up to you.

Alright.

So let’s get into meaty detail. [Async imports (simplified) slide walk through]

Any function that returns future result is async and will have semantics we’re describing.

**Andrew Brown:** example?

**Aaron Turon:** Example of request processing. Race different origins. You have an async export, and you might fork out to do requests to different origin servers. The way that’s going to look is to import send_request. You’ll call it twice, spawning two tasks. Let’s say send_request is host. What the host import is going to do is use its own async primitives. When it completes, it will notify you. While those backend requests are being processed, nothing in Wasm is running at all. That component calls wait to show that it’s blocked on child tasks. When one response comes back, we can go back into Wasm execution. We’re going to call onevent and say child return. I do how much compution I can do with just that event, and call wait again until the other comes back.

**Andrew Brown:** Helpful. Who calls listen function. 

**Aaron Turon:** Importer. It’s a blocking call but it ….

**Andrew Brown:** So that’s saying I do want to hear about events in these async tasks

**Aaron Turon:** And where to put the results of them

This lets us have single set of intrinsics that can work with arbitrary types. 

**Dave Bakker:** I’m familiar with future type of Rust. Holder of future value does the polling and progresses the task. If I understand, this model is opposite.

**Aaron Turon:** That’s exactly right. Rust has notion of tasks as well. Here task execution drives itself. We’re going to talk about cancelation later.

Next piece is talking about structured concurrency, so cancelation and post return. I introduced task model by saying everytime we invoke import, tantamount to spawning a task. Spawning has tricky edge cases like lifetime management. In lots of langs, not much structure. Top level API that you call to spawn fresh task and the relationship between spawner and spawnee is up in the air. Hard to guarantee that you’ve shut down a qhole task subgraph, hard to do and have to do in app code.

In recent years, has been push to structured model that give you more control and predictability around lifetimes of tasks.

Core idea is that we keep track of a task tree. A lot of ways to design structured concurrency. Some go to far in making it so every function needs to think of tasks. Our goal is to have clear lifetimes and reliably push out cancellation. Also allow for post-processing after return. Internally, it looks like new tasks that were spawned, but for you you don’t really care. We’re trying to balance between simple programming model, where you don’t have to think about lifetimes, but give you the option to manage those with things like cancelation if you want to.

**Dan Gohman:** So you might say that each lang is it’s own async runtime. 

**Aaron Turon:** thats actually great thing to bring up. Go does epoll to multiplex out to greenthreads. Each component invocation, you have a small runtime going on in the component managing the external events and then doing whatever makes sense internally. 

So I’ve been describing all of this in terms of component model and canonical abi. But we need to hook this into the programming language experience.

Goal is for developers to not have to think about this at all. Work idiomatically in their own language.

Every lang has a way to manage async requests to the system. We’re just another system. For Rust, we’ve worked through the glue level. We have something that roughly gives you async imports and exports that map to language-native async. Bottom line, you can just treat it as a normal future, not caring at all that there might be some spawned subtasks. 

Last piece which was really important and thorny is streams. Everything we’ve been talking about so far is single value interaction. Another really important use case is streaming async. Another type constructor like future. You don’t just get a pipe that you can pass around freely. The pipe is created at the same time as the task that’s job is to fill that pipe. Having this property was super helpful for things like preventing deadlocks.

Barely scratched the surface. A lot of fine detail that we’ve bottomed out in. Have an early prototype in Wasmtime and toolchain glue to check end programmer experience.

**Jonnie Birch:** What’s best place to follow progress here.

**Luke Wagner:** I think the next step is turning this writeup into PR to the component model. I’ll be working on that PR. THat will be pretty low level. Before that, I’ll be working on presentations to this group and the stack switching group. So that will come in the future weeks.

**Jonnie Birch:** Sounds good, lots to digest here.

**Sébastien Deleuze:** I may try to contact the Kotlin team because they also have structured concurrency.

**Luke Wagner:** One other thing, if someone is raring to go. This isn’t a good intro, so not useful as a starting point, but here’s the hack.md file:  https://hackmd.io/NM8WrCMWRPOwq--K1jRQrg?view

"
main/2019/CG-08-06.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 6th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: August 6th, 4pm-5pm UTC (August 6th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Discuss NSF Expedition on WebAssembly
    1. Discuss new proposal that introduces types for modules and instances (and text format thereof), as initially discussed in [design/#1289](https://github.com/WebAssembly/design/issues/1289) ([slides](https://docs.google.com/presentation/d/11IIqttVbCsWtvhrmBcKMPdWqvEVdTE2nlvIzZMoOpyk/))
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
Derek Schuff
Luke Wagner
Sam Clegg
Ross Tate
Francis McCabe
Bill Ticehurst
Deepti Gandluri
Alon Zakai
Rrwinterton
Till Schneidereit
Dan Gohman
Peter Jensen
Pat Hickey
TatWai Chong
Andreas Rossberg
Luke Imhoff
Conrad Watt
Zhi An Ng
Alex Crichton
Jacob Gravelle
Arun Purushan
Thomas Lively
Ryan Hunt
Lin Clark
Adam Klein
Shiv Kushwaha
Sven Sauleau
Jay Phelps

## Adoption of Agenda
Luke Imhoff seconds.

### Proposals and discussions

#### Discuss NSF Expedition on WebAssembly
    
Ross Tate[RT]:

Thinking of preparing NSF Expeditions grant proposal for wasm. Large grant, requires a lot of collaboration. 
Letters of collaboration from wasm team expressing interest in collaboration. 
NSF Expeditions have to be big expeditions, letters of collaboration needed from each browser probably. 
Application due in April.

FM: What’s the aim of the project?

RT: First thing is helping with the GC proposal - shared garbage collector with the rest of the proposal, so that DOM

DG: what would you be looking for from the community beyond letters of collaboration?

RT: the idea is that we commit to spend some time helping them make it happen. I.e. someone who works on the GC on at least one of the browsers, who can give insight on the challenges, etc. feedback on feasibility.

FM: Is there a history of NSF supporting this? 

RT: both of our previous NSF grants were like this. One was collaboration with Kotlin and [??]. Another was with the Julia team. Response was that they wanted to accept but couldn’t do it withgout the letter. So there’s a history of NSF support of this, and of this formal commitment actually mattering.

LW: In the scope of the work, is there implementation work required? Either for the spec, or for prototyping?

RT: NSF has historically not been very interested in funding development to that degree. So a second thing we’re looking that is….

Timeline is that we don’t get the money for 2 years. It should be spent on research (e.g. students, postdocs, event attendance) and educational aspects. E.g. courses, training, e.g. about how to implement compilers for wasm etc.
But in this setting the development involves a big research component. E.g. how to make a managed language communicate with a browser’s GC etc. So NSF covers that kind of thing.

 For the development side, looking into an initiative - make a webpage, with interested folks, companies interested in encouraging research sign up for membership - we have discretionary use of funds. They basically act as the bank for this, there is overhead, but not more than if it was a gift. Goal is to get that in place, to get funding at a faster pace, if the expedition  doesn’t go through - plan is to split it up and apply through smaller mediums
 
LW: for development there’s a spectrum. There’s early prototyping which is essential for any spec, vs polish. Could that kind of prototyping fall under the research and be funded?

RT: could be. The proposal needs to say how we will evaluate the research, and that could be part of it.

DG: I can facilitate some offline conversations on our side. For this meeting, are there any objections from the community to doing this kind of research?

… [no objections raised]

RT: there are 2 things that would be helpful. On is breadth. So interest from the browsers. But also from folks who would be producing compilers targeting wasm. The other thing is breadth of expertise. E.g. in other aspects of the web and [?]

For some of these, a letter from the CG itself could be useful.

RT(in chat): Other researchers (and specialities) currently involved:  Arjun Guha (webassembly implementation and evaluation, in-browser effect implementations, continuation), Steve Blackburn (virtual machine design, garbage collection), Amal Ahmed (language interop, assembly-level guarantees), Zach Tatlock (browser semantics, mechanical formalization and verification, certified compilers, floating point), and Steve Chong (security, information flow) 


#### Discuss new proposal that introduces types for modules and instances (and text format thereof), as initially discussed in [design/#1289](https://github.com/WebAssembly/design/issues/1289)

LW: [slides on module/instance types](https://docs.google.com/presentation/d/11IIqttVbCsWtvhrmBcKMPdWqvEVdTE2nlvIzZMoOpyk)
Motivation is how do you specify the interface of a wasm module. Either a binary or the host. 
[presenting slides]

POLL: Move to stage 0?

PH: Most tools deal with just binary and not text format. Would be good to define a binary format for this.

PH: Biggest debate is whether there’s a signifier about whether this should be a module type or an instance type. 

FM: Can this be extended to ML Functors?

AR: a wasm module is essentially a functor in the ML sense

FM: Compositionality seems to be missing, having modules that return modules as the value. 

AR: what wasm calls a module is what ML would call a  functor and what ML calls a structure is what wasm calls an instance

FM: Can you have a module that implements the effect of importing/exporting and does something in between? Right now this is what the instantiator does, but can the module drive that?

AR: it’s a separate thing form this proposal. We’ve talked about it, but doesn’t need to be part of this proposal.

LI: there’s nothing stopping you from calling the JS API to instantiate a module from wasm. Everything is an i32 though.

AR: Yeah, it’s a bit.. You really have to got through JS for everything - there’s no way to express what’s an import/outside outside of that, and we express tham as integer indices - I think what FM is asking if there’s something more direct? Interesting, but one step at a time

PP: What’s going to use this functionality?

LW: Usecase may be that - defining a standard interface for WASI - That’s in one language independent form like the s-expression format in the slide, and can be compiled to a header. 

PP: right now clang would not generate anything for this. Until you get to a body you don’t generate anything. Maybe would change for C++ modules.

??: Precursor for dynamically linked libraries

AR: can’t really say how it would work with C++ specifically but it could describe the interface between a provider and a client in general. You could define subtyping on module types so you could tell when a change to a module is backwards compatible with existing clients (e.g. when it’s a subtype). There are a couple open issues in wasm and wasi where we want some IDL for wasm, which pretty much is just the module types.

One was phrased as an IDL, another as a way for a module to to have imports/exports? 

PP: what language would use this now?

JG: In C++ or clang, you are able to specify import functions, you can already build that type of interface. 

DG1: we could generate this file form C++ code

FM: It’s the linker level that’s going to make the most use of this, is that correct?

DG1: not necessarily. It could be used statically as well. 
The C++ Frontend would see it too..

PP: Right now, everything that the clang backend - Linker is the one that makes everything visible - the header files are transparent - we don’t really have a way to convert a header - no way to convert it to an interface file. The linker right now does not consume any such files.

DS: In some other systems you can make stub libraries, which are very similar to this idea; just an interface. the linker could use this, these are non-standard things, but there is a precedence to this. 	

PP: interested in knowing if anyone knows how to use this from other langauges? In C you could do a form of dynamic linking wit this

JG: There’s essentially two cases - building an interface, or using an interface - the interface is defined by the imports/exports - you can strip out all the bits that are not your import/export and that will be the interface - like a post-processing tool

PP: makes sense

POLL: Stage 0 to create a repository

TL: shouldn’t this be a stage 1 poll?

DG not that much difference. 

AR: stage 0 is just to create the repo basically.

TL: we just skipped to stage 1 with feature detection

DG: we have this as a proposal for 0: we can just leave it as that


| SF | F | N | A | SA |
| - | - | - | - | - |
| 17 | 6 | 1 | 0 | 0 |


#### Wasm beyond the browser

CW: I was asked to plug a workshop going on called “wasm beyond the browser” at UC Berkely on Aug 9. There’s remote participation too. [http://cseweb.ucsd.edu/~dstefan/wasm-beyond-the-browser/]

### Closure
"
main/2021/WG-07-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 14th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: July 14, 2021 at 3pm-4pm UTC *( July 14th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. [Fixed-width SIMD](https://github.com/WebAssembly/simd/tree/main/proposals/simd)
       1. POLL: Advance proposal to Phase 5
    1. POLL: Publish First Public Working Draft for next version (possibly also auto-publish on merge to main)
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Attendees
Luke Wagner

Derek Schuff

Deepti Gandluri

Eric Prud’Hommeaux

Conrad Watt

Ryan Hunt

Sergey Rubanov

### Proposals and discussions

#### SIMD to Phase 5

DG: we’ve been testing implementations and tools, no issues have come up with implementations or users, so we thought it would be a good time to poll for phase 5. Should we do a consensus, or more detailed poll?

LW: I expect we can get consensus. Ryan, do yo have any comments from the Firefox side?

RH: I’m not actually a WG member but i’m here to answer questions about FF if anyone has them. We don’t have issues with our implementation, and we’re supportive of moving to phase 5.

DG: any objections then?

<no objections noted>

Consensus. Feature moves to phase 5

#### Publish First Public Working Draft, and auto-publishing
EP: For our purposes here, “TR” means https://www.w3.org/TR/; it means a doc that conforms to publication rules.
The previous doc (the rec) is big and unwieldy. I decided to try to write a sphinx to TR tool to convert it automatically.

It takes a “fake” spec and runs it through ReSpec, which creates a valid TR doc. ReSpec has some material that shows editors, etc. It has a config that has to be edited from time to time. It generates the front matter and table of contents (richer that what sphinx generates)

LW: this looks very nice. The TOC looks actually useful.

EP: the TOC is more detailed, let you refer to numbered sections, etc. It’s scriptable, we can run it as a GH action, and can be integrated into W3C’s auto-publish. So if we get our action set up to output the sphinx, we can hook it up.
To get this running we have to decide to move to first public working draft (starting over after our REC, basically), and then to decide to do automatic publication.

LW: how does that relate to using an evergreen standard?

EP: technically they are orthogonal. Auto-publication just lets you keep it up to date when you iterate on a working draft. Evergreen is that you can stay in CR, and only have to go to REC every couple years, etc. 

LW: we don’t merge stuff too much, it’s mostly like we just did, with a “really done” chunk of work.

EP: yeah when you go to CR you stabilize for 3 months, to to give accessibility, internationalization etc. a chance to review, keep a summary of what’s changed, etc. With evergreen, the patent commitment and review process you did to get to CR, you want to make sure you don’t invalidate the previous patent/accessibility/i18n reviews etc by starting everything over or whatever.
Once you have auto-publish you can just update the doc with git pushes.

LW: now that we have the tool, that seems quite easy.

EP: yeah if it needed a lot of manual manipulation, it would be slowed down, so this is more realistic. The value of evergreen is less if you need lots of doc work.
Mathjax has a way to pickle its output, but there are some issues, that might need patching. Are there currently any scripts that change the content when you load the sphinx HTML output? If so, I haven’t caught them. (i did just include all the scripts that were in the old doc). If there are things we want to freeze that were from scripts that run from sphinx, they'd have to be made to work in JSDOM.
In Firefox you can switch it to MathML and mathjax just does its thing. Do you know what it does when you do that? Is that output something you’d want to pickle to HTML, e.g. for other browsers? Do you know anything about mathML in the other browsers?

DS: the state of mathML in webkit browsers is... complicated.

EP: the mathml WG seems to be reanimated. It seems like maybe the browsers are back on board. It would be nice to be able to just do that once the support is there.

LW: is it possible to just dynamically generate HTML from the mathML if the browser doesn’t support it?

EP: sort of. It’s what the current version does with mathjax. In the future it might be possible to do it AOT. or we could have both mathML and mathjax markup.

LW: yeah dynamic fallback would be great. But what we have now seems like it works pretty well?

EP: we’ll see if there is anything cooler we can do for the first version. Otherwise we can start with what we have.

So the options are: Should we publish now with what we have? And do we want to auto-publish? And if we have auto-publish, do we switch to evergreen once we hit CR? (there’s no observable difference in evergreen until you get to CR).

LW: I think the answer to the first 2 is yes, right?

DS: yeah I agree.

EP:  Is there  a section in the doc that tracks changes since the last version?

LW: depends on the granularity. Mostly we have them in terms of features, which you can point to big sections. There is also sphinx diff, which might be more useful than an HTML diff.

EP: that might be useful actually e.g. for i18n. Then a reviewer would have to look for bits that would need review. If they can see the sphinx diff that would be the info they need. We could maybe even add an appendix with that.

LW: that would be convenient to do. It could align with a human-readable description.

EP: another question: the main spec that people use, with the sphinx HTML output. Does that get autogenerated?

LW: i think whenever people merge to the spec repo.

EP: that’s probably what we’d want for auto-publishing drafts. So the community expectation is for that doc to be the latest, there’s no other step for extra vetting?

LW: not really. The WG itself isn’t really supposed to do anything interesting.

EP: so that seems ready for auto-publishing again.

Are we ready to start that with SIMD?

LW: Yes, once someone gets the PR to merge.

EP: OK. So I formally propose that we publish FPWD with core, JS and web after merging SIMD.

DS: sounds good. Do we have consensus?

<no objections, proposal is accepted>

EP: Second proposal: set up autopublish of core spec, JS API, Web API, to be activated at chair's discretion.

DS: Do we have consensus on this, any objections?

<no objections, proposal is accepted>

DG: After merging SIMD, what do I need to do exactly?

EP: The decision means you just let me know when it’s merged and I’ll try to fix up the rest of the script, and get the webmaster to accept the publication request.
There will be a 2 week wait for the director to approve the transition
Oh, we also need to put down a name for it; i.e. a version number.
Philippe had a proposal to just call the next version 1.1, we left room for that.

LW: do they show up in the doc or just in the URL?

EP: they’d show in a listing as “this version” and “latest public version”. We decide when to change it.

DS: implementations work in terms of features, not versions. But we do merge things in order, we could just bump the minor version with each proposal that gets merged.

LW: I like that idea. It can mean that we don’t have to decide what gets bundled together

EP I like that too. 

LW: We could just start with 1.1 now (since we have several proposals merged since the first) but in the future each stage 5 merge gets a version bump.

DS: our current process uses proposals even for small things like bug fixes, so it should work with that.

EP: so each time we merge a stage 5 proposal, someone will edit the ReSpec config.

#### WG observers
<from chat> SR: Zalim Bashorov from JetBrains Kotlin team is asking to add him to WG meeting calendar as CG observer. He’s using form which is mentioned in WG meetings template here https://github.com/WebAssembly/meetings/blob/main/main/2021/WG-06-09.md#registration. I had the same issue earlier https://github.com/WebAssembly/meetings/issues/339

DS: thanks for bringing that up. I can see those entries in the form data, but I think right now the problem is that it’s not set up so anyone gets notified when someone submits it. I’ll add those people to the calendar and see if I can fix the notification problem.
"
main/2017/CG-11-28.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 28th video call of WebAssembly's Community Group

- **Host**: Google Hangouts
- **Dates**: Tuesday November 28th, 2017
- **Times**: 9:00am–10:00am Pacific Time
- **Location**: *same Google Hangouts link as before*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

None required if you've attended before. Email JF Bastien to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Meeting times + collaborators in Asia-Pacific
       * Discussion of meeting time logistics
       * POLL: We should hold every third video call at an APAC friendly time.
       * POLL: We should time the meeting to avoid conflict with TC39.
    1. The name of WebAssembly.Global
       * See [WebAssembly/threads/issues/49](https://github.com/WebAssembly/threads/issues/49),
         discussion stalled
       * Poll-worthy?
    1. The type of immutable globals exported from instances
       * See [WebAssembly/threads/issues/73](https://github.com/WebAssembly/threads/issues/73),
         discussion stalled
       * Basically, either change existing API incompatibly or live with complex API
       * Poll-worthy?
    1. The type of the wake count argument and return value for atomic.wake
       * Spec text changed this to i64 but poll at CG mildly in favor of older i32:
       
         SA | A | N | F | SF
         |----|---|---|---|----|
         2 | 2 | 11 | 4 | 0
       
       * Would be good to nail this down now, code is landing in implementations
       * Discussions bogged down on what TC39 may or may not want to do
       * POLL: Revert to i32 with trapping in (the implausible) case of overflow
    1. Conditional Segment Initalization instructions `init_memory`/`init_table`
       * See [WebAssembly/threads/pull/79](https://github.com/WebAssembly/threads/pull/79)
       * POLL: Should we limit these instructions to only being valid during instantiation?
1. Closure

## Agenda items for future meetings

1. Require custom sections after all known sections
   * See [WebAssembly/design/issues/1153](https://github.com/WebAssembly/design/issues/1153)
   * POLL: Should we specify that custom sections must come after all known sections?

### Schedule constraints

*None*

## Meeting notes

### Roll Call

* Ben Smith
* Brad Nelson
* Heejin Ahn
* Ben Titzer
* Jacob Gravelle
* Sergey Rubanov
* Tyler McMullen
* Yury Delendik
* Luke Wagner
* Eric Holk
* Thomas Nattestad
* Limin Zhu
* Pat Hickey
* Michael Ferris
* Michael Holman
* Marakat Durkan
* Deepti Gandluri

### Opening

JF away, BradN deputized to run meeting.

### Adoption of the agenda

Seconded by Thomas Nattestad

### Find volunteers for note taking (acting chair to volunteer)

### Review of action items from prior meeting.

Glanced at open issues.
Nagged folks.

### Meeting times + collaborators in Asia-Pacific

       * Discussion of meeting time logistics
POLL: We should try a APAC + EMEA friendly time for the first meeting in January.
Unanimous consent.

POLL: We should time the meeting to avoid conflict with TC39.
**Tabled so we can talk with TC39 attendees.**

### The name of WebAssembly.Global
       * See [WebAssembly/threads/issues/49](https://github.com/WebAssembly/threads/issues/49),
         discussion stalled

Discussion

LW: Global kind of make sense, it's similar to JavaScript's notion of a global.

BT: It's kind of a lie, it's not global in the sense of global to all threads.

LW: The text format would change. It would be a breaking change. All our things are with respect to a module. Seems the right name from a core webassembly perspective.

BS: We don't have a better contender, there's not really a better name.

BN: Thread local?

LW: When we do pure wasm thread, it would be instance specific.

BT: You really want to make it a property and not make it something separate.

LW: I think thread locals in a pure wasm world would get a new definition.

BN: Sad it would be a breaking change.

LW: I think rossberg was in favor of keeping it.

BS: I don't think we're gonna make anymore progress.

POLL: We should stick with WebAssembly.Global.

SA | A | N | F | SF
|----|---|---|---|----|
0 | 0 | 3 | 7 | 5

EH: N because have no opinion. 

    1. The type of immutable globals exported from instances
       * See [WebAssembly/threads/issues/73](https://github.com/WebAssembly/threads/issues/73),
         discussion stalled

POLL: We should specify that immutable globals return `WebAssembly.Global`?

Discussion

BT: Is there an advantage besides uniformity?

BS: Not sure there is. We could instead have it vary based on if mutable.

LW: Imagine importing a mutable as immutable in another module.

BT: You wouldn't expect the value to change or to export as a subtype.

BS: That's an argument for keeping a separation. It makes it obvious that the numbers are not mutable.

LW: Here's an argument maybe. A Global could have a nice accessor, that would tell you what type it is. A raw number would lose something.

BT: There might be global we would allow to be exported that don't have a JavaScript type.

LW: Like passing i64 type functions between modules.

BN: I like that argument.

BS: We'd have to have some kind of error if you mutate / types don't match.

SR: If they TC39 proposal for global passes, it will be global.WebAssembly.Global which seems weird.

BS: Maybe rather than a poll. We could have an action item to have a browser try it and see what breaks.

AI(lukewagner): Try it and see if it breaks.


       * Basically, either change existing API incompatibly or live with complex API
       * Poll-worthy?


### The type of the wake count argument and return value for atomic.wake
       * Spec text changed this to i64 but poll at CG mildly in favor of older i32:
       
         SA | A | N | F | SF
         |----|---|---|---|----|
         2 | 2 | 11 | 4 | 0
       
       * Would be good to nail this down now, code is landing in implementations
       * Discussions bogged down on what TC39 may or may not want to do
       * POLL: Revert to i32 with trapping in (the implausible) case of overflow

BS: It seemed like most people just didn't care, so I took the liberty to go with i64.

BN: Is there a poll we could suggest that could clarify this?

LW: Lars just wants it settled.

BS: Type doesn't make a big difference to me. This is largely theoretical.

AI(Ben Smith): Change back to i32 (as per poll result).

### Conditional Segment Initialization instructions `init_memory`/`init_table`
       * See [WebAssembly/threads/pull/79](https://github.com/WebAssembly/threads/pull/79)
       * POLL: Should we limit these instructions to only being valid during instantiation?

BS: There was a recent proposal for conditional segment initialization. The new proposal adds instructions to do initialization. You provide the index of the segment as an immediate. We thought maybe this should only be available during instantiation. JF wanted to know why not all the time?

LW: The argument for restricting it, is there's no way to know when you can throw away the data segment.

LW: Seems like a pretty silent cliff.

BS: Because JF isn't here to advocate for himself, I'll read his comments. """"

BT: I don't think it makes sense to require a global analysis to know if you can throw away the data segment. Could we add another bit to indicate if the block should live outside the start function.

BN: I kinda like that. Maybe more complex.

LW: Could we start without and see if anyone wants it?

BS: We currently don't have this functionality. We're adding this functionality for threads, do we have a use case for this?

BT: Games might want to bundle assets this way.

BN: But most games usually want assets in separate resources.

BT: This could be useful if they have a chunk of data they want to mutate.

LW: Unlike native, this isn't just mmaping, you have to do a copy. Seems like then you might want to use a file.

BT: It gets you most of this functionality, with a small change.

BS: Do we want to add the additional complexity to allow it? Or push to the VMs.

BN: It seems unfortunate to require a global analysis to calculate this.

TM: Being able to lazily init memory might be a big savings for us.

BS: You're saying rather than copy data in, you could decide at a later point to do that copy?

TM: Specific path through the webassembly code could do that.

BT: The way you'd do this without this mechanism is either use something in the platform, or do it yourself and end up with the memory duplication.

LW: We might be able to get a useful copy of write type mapping.

MH: What is your use case? We have a limited set of fast memory.

TM: We plan to always create a fast memory. We're running Wasm on the server. We're using cretonne, but not any of the spidermonkey machinery for it.

BS: To try and move forward, it sounds like we're interested in having this functionality. It sounds like we're mostly not wanting to do global analysis. So it sounds like we're going to want this bit proposed by Andreas.

LW: It's observable if you call the op but didn't have the the flag set.

LW: The other idea was that if you were transitively called from the init function.

BS: I think we can follow up on github for this.


### Require custom sections after all known sections
       * See [WebAssembly/design/issues/1153](https://github.com/WebAssembly/design/issues/1153)
       * We currently allow custom sections anywhere, but since most (all?) producers currently put
         them at the end, we may have incompatibilities in implementations.
       * POLL: Should we specify that custom sections must come after all known sections?

*Tabled*

*Adjourned*
"
wasi/2024/WASI-02-22.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: February 22 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: February 22 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Pat Hickey: WASI P2 0.2.x 
    2. _Submit a PR to add your announcement here_

## Notes
### Attendees

- Bailey Hayes
- Luke Wagner
- Pat Hickey
- Friedrich Vandenberghe
- Sean Isom
- Stephen Berard
- Raees Iqbal
- Colin Murphy
- Trevor Elliott
- Marcin Kolny
- Sehyo Chang
- Fedor Smirnov
- Hung-Ying Tai
- Johnnie Birch
- Merlijn Sebrechts
- Dan Gohman
- Jeff Charles
- Dave Bakker
- Kate Goldenring
- Yong He
- Mendy Berger
- David Bryant
- Piotr Sikora
- Dan Phillips
- Till Schneidereit

### Notes

#### WASIp2, WASI 0.2.x

[Slides](./presentations/wasi_02x_update_phickey_02_22.pdf)

**Pat Hickey**: WASI 0.2.0 is launched. Now we can focus on landing in standard language library SDKs. Now we want to expand 0.2. We want to add new functions and new worlds. Open process driven by all of us. 

**Pat Hickey**: We will ship WASI 0.3.0 no sooner than the end of 0.3.0. If it takes longer, then we will let it take longer. This is what we’re working towards. We will not make breaking changes on 0.2.0. We are working ultimately towards 1.0. The Wasm WG and CG have not blessed these specs, we are still in the early phase process.

**Pat Hickey**: We have version numbers that show up in import name when at a component level. How are we allocating those version numbers? For proposals that are not yet part of preview 2? For example wasi-observe, logging, nn, etc, not yet at phase 3 or included in preview 2. The process for preview 2 is that we can add things but we need to vote on this as a group. 

**Pat Hickey**: To suggest something is not done yet, use 0.2.0-draft. We don’t guarantee two different wit’s at a draft phase is not guaranteed since churn is expected in this early stage. 

**Lann Martin**: 0.2.0 sorts higher than 0.2.0-anything; maybe it should be 0.2.1-something?

**Pat Hickey**: May use 0.2.1-draft etc, no requirement there.

**Pat Hickey**: Once approaching subgroup phase proposals, please use the release candidate: 0.2.0-rc-<iso 8601 date>

**Pat Hickey**: For proposals that are already part of preview 2: When making your first PR to make a change to an existing proposal in p2, please use 0.2.x-draft. For example wasi-http has such a PR today. We have a tool that is not yet integrated with CI to prove that we have not yet broken 0.2.0 functionality, but we will have that to prevent breaking changes. 

**Pat Hickey**: For breaking changes, you need to wait for 0.3.0 for that. 

**Joel Dice**: Would a draft of what we think a 0.3.0 interface might look like be 0.3.0-draft or something else?  (e.g. https://github.com/WebAssembly/wasi-http/pull/101)

**Bailey Hayes**: That makes sense to me

**Pat Hickey**: Point release roadmap for the next two patch releases we think will look like this. 0.2.1’s goal is to be the smallest possible change which is only adding timezone to wasi-clocks. We didn’t have two compatible implementations done in time, so we opted to leave it out and add it in afterwards. We chose not to hold up WASI p2 over this. So we will now aim to add this to the current reference implementations.

**Pat Hickey**: Timezones are important to users. We will establish a cadence that is consistent and the tooling to facilitate this. For example, if a new function 0.2.1, then runtime should reject. But should be able to be backwards compatible with 0.2.0 functionality. That’s what we’re going to do for 0.2.1

**Pat Hickey**: It’s been proposed once a quarter for the cadence. I know that I can say that 100% certain yet. 

**Merlijn Sebrechts**: So it will look at the actual imported stuff instead of the semver itself?

**Pat Hickey**: Namespace:package:version for each interface. If there is an interface at 0.2.0 at foo and foo at 0.2.1 then it matches. Effectively ignoring the patch number if the additive interface is not used.

**Merlijn Sebrechts**: Makes sense, thanks!

**Pat Hickey**: The idea is that this apply to 0.2.1 and later patch releases. In wasi:io there is work being done by Dave Bakker to handle stream forwarding for example. Dave has others for buffering and flushing. Another example candidate for 0.2.2 is wasi-http to have a different way to expose requests and responses. Then whatever else. You can make PR’s to proposals to add new functionality and work with the champions of the proposals to create an 0.2.x release according to the cadence.

**Bharat**: Does WebAssembly support asynchronous HTTP calls?

**Pat Hickey**: Yes, wasi-http supports making async http calls.

**Pat Hickey**: We’ve received feedback from our community that the word Preview throws them off because they don’t know what it means. We are already using semver. We use it in the WIT. Most developers already know semver. When we say WASI is at 0.2 right now that can get across better than Preview 2 is that we’re not at 1.0. And 0.2.2, 0.2.3, etc means that we’re not breaking anything. Let’s communicate better by using terms most folks are already familiar with. WASI 0.2 is recommended for most audiences. This is what you’ll see in wit docs and import names. 

**Pat Hickey**: For the target triples we don’t want to use the period character. Folks in the go community took the lead here and used wasip2 in their target. 

**Pat Hickey**: This is still called WASI Preview 2 which is relevant in the standards context. WASI is not yet a formal Standard (requires Wasm CG and WG), so in their context this is a Preview.

**Pat Hickey**: I’d like to salute the go community for seeing this problem coming. Go decided to use wasm32-wasip1 and wasm32-wasip2. Folks in the rust community saw that and also has chosen to adopt this triple. 

**Pat Hickey**: I linked the rust PR that has a good discussion and explanation of the plan. Rust will continue to support wasm32-wasi to mean WASI Preview for some time with a warning to update. One day wasm32-wasi may be removed or changed to mean WASI 1.0. We don’t force or control these other communities but encourage you to give them feedback.

**Pat Hickey**: We suggest languages reserve wasm32-wasi if possible to one day mean WASI 1.0.

**Joel Dice**: Can you expand more on why the draft releases should not have a date? 

**Pat Hickey**: I don’t have a hard reason for that. If it’s useful, use draft. Updating the dates was busy work for me while churning. As reaching stability for your end users nears, using a date should be used. It matters less when it’s only a couple developers working in the design phase. 

**Pat Hickey**: I don’t want to mandate anything here, but want to suggest it and try it out.

**Pat Hickey**: This group is a small subset of people who need to know about WASI. We can hide some of that detail of the churn but at some point we have to ship the software.

**Pat Hickey**: I get bug reports in wasmtime about version and errors is confusing. I agree that it’s not great right now and as an implementer and there’s consensus to make this better for end-users in the implementations. Docs is also critically important for users. Please everyone continue reporting bugs and helping us improve the experience. Thank you to everyone who has already been doing that.

**Merlijn Sebrechts**: I have a question about a different topic if that’s ok. I contacted you about i2c devices. I got in contact with someone at Siemens who is working on similar prototypes. They want to work together with us on i2c interfaces. Is it ok if we become co-champions of the proposal. 

**Pat Hickey**: Sorry about that email falling off the bottom of my inbox. Yes, we wanted to see champions that are in the industry in addition to students so that the proposal will continue after students graduate. 

**Lann Martin**:  if you haven't already, please see https://bytecodealliance.zulipchat.com/#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG

**Pat Hickey**: Outside the standards group and in the space where folks are working on implementations, Lann posted a link to a new SIG in the Bytecode Alliance including Siemens. 

**Merlijn Sebrechts**: We also have a prototype for the USB interface. We are not thinking about standardizing that. At the moment this is an internal prototype and not planning to go through the standards proposal process unless someone is motivated to do that.

**Pat Hickey**: You can also post announcements here in this agenda to raise awareness.

**Chris Woods**: Please come on to the embryonic SIG that is starting to form. I think there is enough interest to go through the necessary process to get the SIG to form. Please come along!



"
simd/2023/SIMD-06-02.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 2 video call of WebAssembly's SIMD Subgroup

- **Dates**: 2023-06-02
- **Times**:
    - 4pm-5pm UTC (9am-10am PDT)
- **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this [form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking
1. Adoption of the agenda
1. Proposals and discussions
    1. i16x8 laneselect
    1. flexible vectors
1. Closure

## Meeting notes

### Attendees

- Andrew Brown
- Anton Kirilov
- Deepti Gandluri
- Marat Dukhan
- Petr Penzin
- Yury Delendik
- Zhi An Ng

### i16x8 laneselect

https://github.com/WebAssembly/relaxed-simd/issues/125

ZN: 8-bit blend instruction doesn’t match semantics to 16-bit laneselect, there are a few solutions: change spec, change lowering, etc

MD: keep as performant as possible, keep it to pblendvb lowering, it requires spec text changes, change it to also be able to look at top bit of each byte

PP: the 16 bit won't look at top bit of the lane, all instructions will look at top bit

MD: initially we specify to look at any subset of bits, we narrow it down to look at each bit or top bit of lane, so allowing to also look at top bit of the byte is minor relaxation

ZN: Alex brought up that if we add this, all four laneselects can use pblendvb and technically all instructions become the same operation

PP: then you can drop the ‘sign bit of a lane’ part and just keep the ‘byte’

MD: in XNNPack we detect case of sign bit of 32 bit lane and specialize for that, an implementation that uses pblendvb won't use this opt, but will still be better than bitselect

ZN: since it is a minor change and we are not technically in phase 4 is it OK to do that?

DG: totally fine, minor spec text fix can still happen, removing instructions, adding new ones, need more oversight, still at phase 3. We discussed previously about phase 4, require more profiles discussion. Especially if we know spec has a mistake

ZN: to summarize we will make a spec change for 

DG: we will want to post on the issue about our discussion before doing work

PP: if anyone wants to take advantage of all 3 options, it will require detecting whether implementation use pblendvb for everything, or have different instructions, you have to detect

ZN: yes, will have to check i32x4 implementation if you want to use i32x4 laneselect to check f32x4 sign

PP: if you define operation to be byte wise then you can prepend different comparison with different lane sizes, that will result in the semantics. You can define it to be byte wise.

ZN: this would add an instruction to the lowering

PP: the effect would be negligible, one extra instruction for SSE and two more for AVX

AB: the point of the proposal is to try to get performance back, think going for the most performant option is the way to go

ZN: what about removing i16x8 laneselect

MD: will be weird to ask user to use i8x16 laneselect, if result is mask, you can use the the right lane type for the laneselect

DG: we can remove operation at this phase, any of the options here are fine from spec / phase perspective

AK: on ARM, all options can implement this, which is single instruction compare against 0, my preference is efficiency on all

MD: question for firefox, when will relaxed simd become stable?

YD: no plans, at the moment waiting for official phase 4


### flexible vectors

Slides: [(pdf)](presentations/2023-06-02-flexible-vectors.pdf)

AK: we have element wise shifts, same concerns applies, maybe some clarification there to do

PP: proposal has elementwise shifts, they are variables, not immediates

AK: what happens when indices are out of bounds? if you look at pseudocode, it's probably better to have explicit spec text, maybe pseudocode needs tweaking

PP: if more than number of lanes, you get all 0, should have a note that explicitly says that

AK: in pseudocode, index the vectors, doesn't make sense if index is > vector

PP: pseudocode does a check but needs tweaking

DG: for most bounds checking, at least in v8, it's ~15-20% performance regression across the board for scalar code. Any ideal performance you have in mind?

PP: need to look at mechanisms for OOB, how exp it is, hope you can eliminate a lot of the bounds check because they will be produced by constants, indices are constants, easily detectable. if not, the modular scenario will be better. Less about performance i can estimate, more of whether if a compiler can detect this easily

AK: on x86 no special handling needed for int divisions right? i'm thinking on aarch64, int divs never trap there, we have to check what input values are, if 0 in order to do trapping behavior that is mandated by Wasm. Div is always done unconditionally, branch is not on critical path, expect that bounds check for laning is done in a similar way. Vector op will be done unconditionally, and a check and conditional branch that is not on critical path, will have some performance impact on larger code size, but likely not that bad.

PP: check version will be more friendly, will need optimizations to ensure it doesn't kill performance. Also need to explore 128 bit chunks, if it is easier to use, then skew it towards 128 bit chunks, then get lanes using immediates.

AK: have a comment about 3rd option, taking modulo the lane count. In AArch64 we deprecated non power of 2 vector sizes

PP: it would make this option a bit better, no need to do division or do it efficiently, always a power of 2

PP: x86 also the same, multiples of 128, power of 2 * 128. only odd arch is RISC-V. but that isn't considered the main target at this point.

<missed some discussions here>

AK: on ARM you need to target a particular microarch, might be a bit too constraining, less optimal lowering, idea about having shuffle that operate on 128 bit chunks, have to look at the specific ops, but might be challenging, very generic shuffle in SVE is not designed that way.

PP: not possible to do the same on both platforms

AK: if op is not available on the spec, and user is forced to workaround, if it is as costly to workaround as having in the spec, then still make sense to have the spec

PP: highway and halide as a source of inspiration, libraries like this define all of it, some op clearly work better on x86, some work better on arm. that is similar to SIMD. we survived that

PP: need to get to the prototyping phase, a lot of things we need to test and try. Broad consensus this is the right op, is this ready for phase 2?

ZN: set of ops look complete, book a slot to present to CG?

DG: would like to understand the goals, who will be using this? what are you trying to achieve? what sort of hardware? Ideal performance scenarios? Need to scope this out to motivate implementations. For phase 2, need to build what this will look like. Digging deeper into what applications you expect to care about wide vectors in the world of GPUs. How does this look like on older devices?

PP: classes of instructions not work exploring in 128 SIMD, someone brought up crypto, we talked about compatibility between two platforms, talked to people about crypto, if only has 128 SIMD, performance will be similar.

DG: wouldn't you include AES instruction and not SIMD

PP: you will need AES to be longer than 128, it is quite close to scalar

PP: some int operations used in graphics will be affected, do we care about crypto or similar use cases

DG: from chromium, we have seen crypto requests, for AES 128, web crypto has its own problems. For people outside web crypto but want a fallback, there is Wasm fallback, but complicated for them to use. Trying to see if we want to prototype AES 128. Try to not fragment ecosystem with multiple implementation of crypto

PP: in the future we open up avenue for adding them

DG: being able to do fast crypto on web using Wasm is not ....

DG: for a lot of this, we need tooling to catch up more, we can provide tooling solutions for people that care about crypto. e.g. a request is to share the same AES header, if decrypting, might not be the critical path. They are trying to have a single implementation across all platform, an emscripten header they can share across all platforms that can target native and Wasm. Solution space is large.

AK: crypto might be tricky, some people care whether crypto ops are timing independent, another proposal for constant time, might need to coordinate with other proposal

PP: could also apply to people hand rolling theire own crypto

DG: another thing for profiles, constant time and deterministic profiles. we haven't seen activity on constant time proposal for several years, don't know if it is active.

AK: AArch64 already has constant time equivalent extension, looked at the spec before, lists instructions that take constant time, AES are in that list. would assume that if we do flexible vectors, it will look the same, need to coordinate.
"
main/2023/CG-08-29.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 29th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: August 29th, 4pm-5pm UTC (August 29th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
   1. Vote to approve acting-chairs Bailey Hayes and Pat Hickey as new chairs of the WASI Subgroup (5 min)
   1. Reminder: upcoming function references and GC phase 4 vote [Thomas Lively, 10 minutes]
   1. Presentation: Prototyping stack switching for Wasm [Daniel Hillerström, 45minutes]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes
### Attendees
* Thomas Lively
* Conrad Watt
* Derek Schuff
* Pat Hickey
* Yuri Iozzelli
* Daniel Hillerström
* Yury Delendik
* F. Smirnov
* Zalim Bashrov
* Francis McCabe
* Paolo Severini
* Lin Clark
* Nick Fitzgerald
* Ryan Hunt
* Sam Lindley
* Dan Gohman
* Heejin Ahn
* Ioanna Dimitriou
* Nuno Pereira
* Dan Philips
* Andrew Brown
* Justin Michaud
* Bailey Hayes
* Thomas Steiner
* Mingqiu Sun
* Alex Crichton
* Jonnie Birch
* Matthew Yacobucci
* Jakob Kummerow
* Luke Wagner
* Shravan Narayan
* Adam Klein
* Petr Penzin
* Ender
* Manos Koukoutos
* Jake Hemmerle
* Shoaib
* Richard Winterton
* Ioanna Dimitriou
* Matthias Liedtke
* Alon Zakai
* Ilya Rezvov
* Asumu Takikawa
* Ashley Nelson
* Chris Fallin
* Kevin Moore

### Vote to approve acting-chairs Bailey Hayes and Pat Hickey as new chairs of the WASI Subgroup

LC: I have chaired the WASI subgroup for 2+ years. Less time recently for chairing - BH and PH have done amazing job, want to make their chairing official


CW: Unanimous consent poll: would anyone like to object or raise any discussion?

<no objections>

CW: unanimous consent passes, thanks and congratulations to both, we look forward to working with you


### Reminder: upcoming typed function references and GC phase 4 vote (Thomas Lively)

TL: Just wanted to let everyone know that 2 weeks from now we have a scheduled vote to move the garbage collection proposal to phase 4. The requirements have been met, there are few outstanding spec PRs but we have tests, implementations, implementer feedback has been very positive. It’s the result of a lot of work by a lot of people, we are excited. Just wanted to make sure it was on everyone’s radar since it’s a big deal for a lot of folks here.
There will be a presentation by Andreas reviewing the proposal, changes, etc. but I would urge anyone interested to look at the MVP.md doc in the repo. But I can also take questions now.

LW: Has anything interesting happened or changed in the proposal in the last 2 months or so?

TL: we did finalize the opcodes and reshuffle them. Maybe not that interesting. The last big design question we talked about was a detail about the type annotations on br_on_cast and br_on_cast_fail. We had an input  and output type annotation, the question was whether we should constrain it so that the input type was a supertype, making it a proper downcast. The answer was yes, it will be validated to be a proper downcast. We initially thought that would be very hard to ensure in Binaryen during optimizations, to ensure that the refined input type is still a supertype. But we found a simple solution, so it became a non-issue. Other than that it’s been stable.

FM: If you’re not participating in the GC group, it’s a bit hard to find out exactly what is being proposed.

TL: yeah, like most proposals we have an overview document, but it’s a bit out of date. The correct doc to look at is the MVP.md doc: https://github.com/WebAssembly/gc/blob/main/proposals/gc/MVP.md

FM: can you update that?

TL: yes

Chat (JM): Note: tpac is scheduled that week (Sep 11-15), so browser implementers may not be able to attend

CW: are there any browser implementors here that want to say anything, or object?

RH (chat): I will be able to attend.

JK (chat): I will also attend.

JM: I won’t be here (PTO). I don’t have any objections, just wanted to raise it.

JK (chat): for the record, ""Typed Function References"" will also have its Phase 4 vote in two weeks. (It was split out from the GC proposal years ago, but the two ended up progressing in sync with each other regardless.)

TL: I’d be happy to roll them into one vote, if that’s acceptable according to procedures.

CW: We can roll them together, and if it fails we can figure out what to do.

TL: The tools have a single flag to turn them on and treat them as a single feature.

TL: thanks, and check out the proposal if you’re interested.


### Presentation: Prototyping stack switching for Wasm (Daniel Hillerström)

Slides: https://dhil.net/research/talks/wasmfx-cg2023-08.pdf


TL (chat): If wasm-opt did support WasmFX, would you expect it to be able to noticeably optimize the hand-assembled benchmarks?


PP (chat): An I understanding correctly that you are wrapping all types into u128? If that is true, can you speak of any overhead associated with that?

FM: I was under the impression that you’d improved the performance, Surprising that you’re still slower than asyncify?

DH: yeah we haven’t optimized yet, we did some refactoring and it slowed down. I think we can recover that though, will talk in a couple slides. In the tree case it’s faster

FM: you said you didn’t want any memory leaks, but my understanding of the proposal is that theres a builtin memory leak because you still have a pointer to the continuation after?

DH: you refcount the continuation, you keep a reference alive in a stack and if you don’t invoke it, you leak the memory

DH: (to TL):  yes I think so, the assembly isn’t too optimized, especially inlining might help. And maybe loops? So I’d expect to see something, but I don’t think its the main source. There’s low hanging fruit we can get in wasmtime. Like to build something correct first, and then optimize it. 

DH: (to PP): yes there’s a massive overhead to that. Its unfortunate that it’s typed but we can’t take advantage of that in wasmtime. We want to put an i32 into a regular register and can’t right now, so it impacts performance quite a bit because we pad everything

PP: if you just disabled SIMD somehow, could youi try it without that would it help?

DH: yeah we could use 64 instead of128, it might help. Was cheaper to get a functionally correct version first, didn’t want to prematurely optimize. Just to avoie getting trapped too early on in a local minimum. There’s definitely low hanging fruit that we can get, and maybe better integration with the tools. I don’t have a good feeling yet for how much.
We also need better benchmarks, more of them and better representative of real code. More realistic workloads to get a good evaluation.


TL (chat): Do you have an idea of how deep the call stack needs to be for WasmFX and Asyncify to have roughly the same performance?



CW: have you looked at current use cases for JSPI: is it getting generated by a compilation process that could be used for case studies?

FM: dart did have an experimental implementation of async on top of JSPI but they aren’t using it because it’s slow. 

CW: do you know of any other similar uses of JSPI that might also be useful to look at?

FM: there are languages that have coroutines, so those are obvious candidates for all of these proposal. Languages  like Dart/Kotlin, mainstream languages that use coroutines aren’t currently targweting this. They are interested but have other things to do. They have CPS transforms. Emscripten does support JSPI today as well, can use instead of asyncify, and pretty convenient to use. Currently good candidate use cases in emscripten aren’t good candidates for core stack switching (instead they are what JSPI is designed for).

TL: emscripten does have some APIs that use JSPI, e.g. the fiber API. current built on asyncify, would be interesting to implement on top of wasmFX. There’s also a native promise API, a C API that wraps JS promises to write async C code. Might be interesting to see if that could be written in terms of wasmFX.

DH: yeah that would be helpful for getting better performance data.


More questions will go offline.

Questions we didn’t get to from chat:

TL (chat): 
Do you have an idea of how deep the call stack needs to be for WasmFX and Asyncify to have roughly the same performance?


NF (chat): do you have a sense of how much the benchmarks were exercising stack allocation vs stack switching and suspend/resume?

ZB (chat): We are experimenting with JS PI in Kotlin/Wasm, not specific results so far.
And we (Kotlin) would be happy to experiment with stack-switching proposal implementations, as well.



"
main/2024/WG-02-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the 2024-02-14 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: 2024-02-14 at 16:00-17:00 UTC *( February 14th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Next steps for releasing Wasm 2.0
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Attendees

 - Mike Smith
 - Luke Wagner
 - Andreas Rossberg
 - Derek Schuff
 - Zalim Bashorov
 - Ms2ger
 - Thomas Lively

### Agenda items

#### Next steps for releasing Wasm 2.0

AR: It’s been quite a while since we met, and we should push on this and try to create some AIs to get it moving

We have a RC in the right format, don’t we? I think It’s about the process. We could update the document with some fixes, it should be possible to rebuild it. I think the pipeline is functional, but I think the blocker is the process. I think we went through part of this process but don’t recall the details.
Someone will need to figure out where we are in the process and what needs to be done next.

AR: Notes from last time: one blocker was lack of a charter, but we have that resolved. Last time we talked about publication was March.

DS: was there tooling missing to get the right W3C format?

AR: Eric put something together that I’ve seen, but I thought that we had put together the first RC for 2.0 without it. Working draft is https://www.w3.org/TR/wasm-core-2/

MS: I can look at what’s needed. I looked at it once in the past, I don’t recall what was done before. 

AR: There is a bikeshed version in CI, I think it should be working?

MS: Does that work?

AR: Not sure about all the front matter but it’s what we used to build everything before, and it’s functional.

TL: It’s https://webassembly.github.io/spec/core/bikeshed/

AR: that’s essentially an up-to-date version of what’s in the main repo. The working draft had a couple things in the front of the HTML.

MS: that should be a matter of just tweaking some bikeshed stuff. With the right flags, it’s capable of producing something that works for the W3C. I can look at what would be needed for that. Process-wise, the other thing is… that there’s nothing that really needs to be done. The process would be that the chairs ask the WG for a decision and they would agree and have a vote, request for consensus. We don’t really need that because it’s been published as a FPWD, so you don’t need to ask the WG for a decision about that, you can publish what’s there. We should publish a dated version. Everytime we publish in TR space, it gets a URL with the date, e.g. https://www.w3.org/TR/2022/WD-wasm-core-2-20220419/ the others are basically just symlinks to a dated version. So I can work on that.

AR: so we don’t need a vote?

MS: the next time we’d need a vote would be to go to CR.

AR: whatever makes progress, we should do.

MS: We could also set up some auto-publishing so that everytime a change is made to the spec, the CI runs, we could push a change to the TR version, so we’d never need to do this part again, until we want to move to CR. So I can look at that too

AR: so that would be a GH action on the spec repo?

MS: yes, we have tooling for that, it’s just a matter of pushing some buttons.

AR: that would be good, we basically assume that the live doc that gets pushed is like a live standard already, so pushing that to the W3C side would be even better.

MS: Yeah, I generally tell people not to use the TR versions because they aren’t up to date. But regardless of what we do here, we should still say that, really the only purpose is to make it look more official for the W3C. 

AR: is that what the evergreen process is for?

MS: yeah that was part of the idea. But unless every group does it consistently, it can still be unreliable. So we still generally tell implementers  not to use versions in TR space unless the date is recent. But even then, the version in github, or what you work on that is the source. But it won’t be a problem once we get auto-publishing.

AR: what we have on github.io now is pretty much the same because we are merging new stuff into a 3.0 branch. Butdoes this mean the evergreen model isn’t good?

MS: one problem was that search engines index and the TR versions always show up higher than the github versions despite being less up to date. So people always find it, so the best thing about the evergreen is getting the TR versions up to date. That was the hope, but it’s inconsistent, there’s no way a random person can know that the TR version for any given spec is the up to date one. So the biggest problem is still that we have implementers that show up and say I’m trying to figure out this thing in the spec but they’re looking at a really old version and they’ve wasted time. So we wanted to avoid that, and it still happens.

AR: all the more reason to push a new version ASAP then and move the process along.

MS: the other part that’s nice is that it used to be that WGs, once you published a CR, you had to do more process steps to publish a rec. But you don’t have to do that now, you can just stay in CR and not need to move further. So that’s what we should do once we have the CR.
So I’ll look at this, I agreed to do it a while back, but haven’t yet. I thought that it maybe wasn’t working but if it’s working in CI, then we should be good.

AR: let us know what you need from us

MS: i shouldn't need much from the group. I’ll need to talk to some folks on the W3C side.

AR: and the next step is a vote to move to CR?

MS: yeah for W3C process that’s next

AR: are there constraints or prerequisites?

MS: none that I can recall for entering CR, other than the normal procedure for getting a WG decision. The process doesn’t mandate details, normally you send a message to the WG list, tell people that we’re asking for statements of agreement to move to CR, and that silence is agreement. People can make statements, but after a week we publish. After that, for moving out of CR, we need to demonstrate that the spec has had wide review and multiple implementations. We have that but it means specifically all features in the version that we want to move forward. But that’s moving out of CR if we want to do that.

LW: so our evergreen plan would just stay as CR and update in place. Would the thing we publish still say 2.0? Or 2? And at some point we just switch to 3?

MS: that’s up to the group to decide what we want to title. We have these “short names” currently wasm-core-2 but the title doesn’t have to be versioned. THer are a range of opinions about versioning. If you find value in distinguishing between versions and saying this is 2 or 3, then you can, or just dont’ version the title and say this is the “current” spec.

AR: I think versions are helpful. Initially we didn’t have a version and people complained about that.

MS: yeah there are opinions, some people will complain if there is a version, just depends on how you want to balance.

LW: would it be the case in practice that 2 will have everything right up to but not including 3, i.e. including the last thing we merge until we change to 3?

AR: depends on how we merge. My plan is, we have a bunch of new features, I thought maybe we should do a 3.0 with that, where we do a big bang to 3.0 once we switch to that branch. And we maybe can iterate on that afterward. At least thats what i had in mind.

LW: and 2 is a big atomic thing. And then we can switch to 3, decide if we want minor versions, etc

AR: so our current goal is to do CR, Mike will look at the publication, what else?

DS: I will look at next steps and notifying people for the CR, etc.

AR: let me know if you need help with the doc.

MS: yeah we’ll want to make the formatting tweaks automatic if they aren’t already.

"
main/2020/CG-03-03.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 3rd video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: March 3rd, 5pm-6pm UTC (March 3rd, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Follow-Up on Module Sharing and Encapsulation
       * Slides: [(pdf)](presentations/2020-03-03-tate-roadmaps.pdf) [(pptx)](presentations/2020-03-03-tate-roadmaps.pptx)
    1. [Memory w/ 64-bit indexes](https://github.com/WebAssembly/design/issues/1325) (Ben Smith)
       1. Poll for phase 0
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

Lars Hansen

Paolo

Zalim

Rick

Alex Crichton

Jakob Kummerow

Olaf Tomalka

Adam Klein

Ben Smith

Yury Delendik

Dan Gohman

Luke Wagner

Thomas Lively

Heejin Ahn

JP Sugarbroad

Keith Miller

Mingqiu Sun

Petr Penzin

Ryan Hunt

Rreverser

Sven Sauleau

TatWai Chong

Yury Delendik

Francis McCabe

Nabeel Alshamma

Arun Purusan

Derek Schuff

Alon Zakai

Emmanuel Ziegler

Heejin Ahn

Deepti Gandluri

Conrad Watt

Vivek Shekhar

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Keith Miller Seconds

### Proposals and discussions

#### [Memory w/ 64-bit indexes](https://github.com/WebAssembly/design/issues/1325)

Ben smith polling for Phase 0 for 64-bit Memory

There’s a github issue, linked in the meeting notes - any questions? 

TL:Any reason not to go to Phase 1? 

Phase 1 sounds simple. 

JP: Do you have proposal text? 

BS: It’s a github issue, so maybe Phase 0.

TL: Github repo is populated during Phase 1

BS: Anyone opposed to Phase 1? Phase 0 is free. <Deafening silence>

BS: Unanimous consent to Phase 1. 

#### Follow-Up on Module Sharing and Encapsulation

Roadmaps Slides: [(pdf)](presentations/2020-03-03-tate-roadmaps.pdf) [(pptx)](presentations/2020-03-03-tate-roadmaps.pptx)

RT Acknowledges having two proposals is not ideal, giving background.

RT: Any questions about the roadmapping process? 

<No questions>


JP: Systems written by humans are often nominal. Systems for machines are often structural -- think of LLVM IR. Is that a consideration here?

RT: It certainly is, interesting thing is there are these double stages - talking about memory layout - the way you describe it is structural, but the way the correctness of the compiler reasons about them is nominal. The low level types assembly level languages, took the structure and defined a process of naming the different elements… examples ... then you can express the invariance at a higher level. It’s a halfway point between nominal and structural

JP: Like a pseudo structure

FM: Where does SML/Ocaml fit in?

RT: Languages may use mostly structural types, or algebraic structures, still the case that when you compile it down, it still compiles to a very structural memory layout, tuple layouts - sort of the same pattern with OCaml specifically because it has structural equality, even layouts between arrays and tuples map to a structure so you can walk through them consistently. We used out structure to walk through the OCaml system as well, with our nominal types and it works.. It’s a better model for how you reason about the compiler

FM: So it's more structural in your analysis?

RT: What do you mean? The reasoning at the low level is almost the same as a nominal system, it's about how memory layouts align for each other. You have names,you say they're related by subtypes. You have an a priori check to see that their layouts match up, then at assembly code you just look at the names. Don't have to look at the structure, which is slow. Then field access you look up name to get field access offsets.

RT: High level, don’t want to sidetrack to explaining the whole system

<back to slides>

<slide on efficient casting>

CW: In the proposal, my understanding is that the structural subtyping relationship would be pre-computed ahead of time, so you don't get quadratic behavior.

RT: There’s a few things that come up, if you have large classes that table gets really bit, the precompiler phase gets really big - you could try to move stuff from the compiler phase.. Could try amortizing these costs. When you have polymorphism, you will have types/casts whose types are determined at runtime, that approach is made effective by canonicalization. At runtime you have to got through the canonicalization process, there’s a lot of heavy machinery to make that work.. We need implementation, a whole thorough test like a big Java implementation to make sure it works, hard to predict

<back to slides - nominally tagged casts>

JP: Are these slides available? [RT: I'll put them up], 

JP: The proposal I know of is the GC proposal, the alternative is? 

RT: The secondary one is an alternative... here's the link:

https://github.com/soil-initiative/gc/pull/1/

RT: We tried having a discussion about what can we do to improve this? There was a discussion about existential types, we haven’t had a chance to discuss it yet

AK: Andreas was on vacation this time -- there's a plan to put a GC subgroup together. That's a good place to have a focused discussion on structural subtyping working. In a smaller setting, with focus in that area.

RT: Mostly wanted to present, agree that we should not be hashing out what to do right now - having someone new come in and give a big proposal is not ideal, but realized that the reasons why we did this was not documented out. Looking for feedback on the structural approach and how it would work out with all the situations that were outlines 

BS: Read through PR, it’s very comprehensive - a lot of it is potentially not something ina  first version - wasn’t clear to me which parts are useful to be in a first version and which ones not

RT: We roadmapped much further down the road than what we have planned for now, we tried to find a middle ground of showing a roadmap without going all the way, part of the roadmap is staging the releases - if this is the direction to go then we should have a discussion about figuring out what to target, as well as plan for the next releases. We talked about how dynamic languages have the switch thing, but that’s something we can add later on - it’s useful to know that’s there for..

AZ: In the talk here we mentioned 2 GC proposals. But there's another proposal (Wouter's) that exists too.

RT: I was also talking with Arjin (sp?) that may help have GC better support interop between modules, which Wouter's path is specifically not wanting to do. Arjin's idea is -- if we just wanted to support GC languages better, then what could we do to compile GC objects to linear memory, then have language stack walk and create their own GC themselves. So that's potentially another path.

TL: Thinking about the module interop story, that’s a big discussion we should have - should the GC proposal define interlanguage GC issues? My question is how that would work at the course level? I don’t know of any languages that have the ability to import any arbitrary arrays at the source level

PP: I also have the same question

PP: I agree, outside of C you can't really do that at the source level.

RT: Even for the GC languages w/ a runtime. They may want them to be implemented in c/c++ languages, and still want to be able to reason about GC objects. If we come up with something like that -- like the crypto example. Suppose it was written in C++. But we come up with some way to use C++ code through imports/tooling/etc. So it could take an array -- not a C++ array, but some GC array -- all I care is that it has an indexing operator. Then I can write my code, and it could compile down to that example.

TL: Sounds like the tooling story would be pretty similar to interface types, the source language unmodified isn’t able to do anything, but the tooling will have to figure out how to make these things work together.

RT: There might be other strategies for figuring this out -- this is probably the most obvious way. May be orthogonal to the GC discussion. No matter what proposal you pick, this problem is going to come up.

PP: We don’t even have.. We don’t even know if they’ll support it yet - we can’t really support or talk about interop between C ?& Java because that’s not supported yet.. So unsure how to discuss it. ..

RT: The clarification is -- we were not discussing language interop, we were discussing GC/non-GC interop. C++ code that needs to be able to reason about GC references. It's possible that you could do that in ways that C++ code interop with other languages -- but GC/non-GC interop is the bigger question.

PP: It's the same thing as if you want to call a C function from Java...

### Closure
"
gc/2021/GC-05-18.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 18 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: May 18, 4pm-5pm UTC (April 6, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Iso-recurisve types [Andreas Rossberg]
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Zalim Bashorov
- Ben Titzer
- Sabine
- Luke Wagner
- Slava Kuzmich
- Sergey Rubanov
- Tim Steenvoorden
- Zhi An Ng
- Lars Hansen
- Igor Sheludko
- Daniel Ehrenberg
- Andreas Rossberg
- Manos Koukoutos
- Ryan Hunt
- Jakob Kummerow
- Daniel Wirtz
- Ross Tate
- Francis McCabe
- Adam Klein
- Emanuel Ziegler
- Asumu Takikawa
- Ioanna Dimitriou


### Discussion: Iso-recursive types

[slides](presentations/2021-05-18-rossberg-iso-recursion.pdf)

TL: will there be any problems if each type inside recursion group got its own type index?

AR: alternate design, have some slides later on to suggest this

LW: just to see how this is observable, if A exported u, and B extracted the export u from its instance, and then try to use export u and internal u, and they weren't the same?

AR: The simplest way would be if A exports a function that also uses A’s $u in its signature and B tries to use B’s $u with it.

RT: how many more slides are there?

AR: not that many, 2 slides about alternative, and summary slides

TL: motivation is to get to discussion?

RT: want to make sure there is time for discussion

FM: example of a language that uses equi-recursive structural types

AR: ocaml, typescript, Scala but it uses JVM reflection

BT: order dependence, doesn't it mean if you export a type, you need to define in minimal recursion groups

AR: You don’t have to, but you probably want to. You could define all the types in your module in one big recursion group, but that’s less useful. 

JK: on order depdennce, in first design it is clear we need it, with flatten index is it still order dependence? why?

AR: Yes because that dependence is ingrained in this structure that is a tuple over types. Comparing equality if the tuple is not ordered would be complicated.

RT: any case studies done with this?

AR: no

RT: looked this up in OO languages?

AR: nominally type OO languages, no problem. It is as expressive as nominal plus more, any nominal can be mapped. You need this at module boundaries for linking for nominal types, essentially iso recursive at link type, that's what you check against.

RT: What about subtyping? How do you deal with a non-recursively defined class being extended by a class that is mutually recursive with other classes.

	class A
	rec-class B <: A
	B and C are mutually recursive

AR: what would be the problem? it wouldn't get recursive just by extending it. B and C would be recursive but not with A.

RT: Mutually recursive group, a member of that, a non thing, and they are not lining up. How is B a subtype of A?

BT: subtyping is totally orthogonal, recursive relation over types, only time it comes up is immutable field, anything else is a check. The recursion we have now for width and depth subtyping for structs, just works out.

TL: no problem having a type in a recursion group, be a subtype of another type not in a recursion group?

AR: this might be actually a reason to allow nesting of recursion groups. Because you basically have recursion over recursive things. The subtyping rule for iso-rec is one rec group is subtype of another rec-group if you have both depth and width subtyping on components. Means that you can only extend one group in one dimension at a time. But if you have two mutually recursive classes, then the recursion group, for each clas the recursion between methods, then recursion between the two classe, which is one level up. The inner one want to be a subtype, but not on the combined thing.

RT: I understand it's complicated, asking if you have worked through to see if it works

AR: no, not in that detail. I'm pretty confident that it works sufficiently well, iso-recursive is often used as the type theorteic model of nominal types

RT: some red flags in representation. E.g. non-uniform recursion and how it is decidable. But it is known that non-uniform recursion that can handle OO subtyping, then it is undecidable

CW: Undecidable in the presence of bounded quantification?

RT: No, generics are undecidable with iso-recursive types without bounded quantification. Follows from the [paper](https://kar.kent.ac.uk/58183/7/javats.pdf) by Radu Grigore as I presented to the group back in [December](https://github.com/WebAssembly/meetings/blob/main/gc/2020/GC-12-15.md).

AR: if there is something that is decidable, and decidable for nominal types, pretty sure it is undecidable fo rmodule linking, we have a problem anyway. At the module level you have to get structural.

RT: depends on how deep you go, first import nominal types, then link, how C# and Java works

AR: you have no global namespace, all you have structures

RT: C# has decidable and nominal linking.

LW: it has global namespace, we can't have that in Wasm

RT: no, you import the module that defines the names

AR: java doesn't have safe linking, class loader is kind of the global namespace. In C#, not sure how linking happens that, understanding is that it is conceptually similar even when modelled in different way

TL: probably good to have presentation on C# linking

RT: we don't know if this can handle OO languages, we don't concretely understand…

AR: for anything we design, there are aspects of languages we can't handle.

RT: you put on your slide, equirecursive types, we don't know languages, but for OO we know. We can't handle all languages, but if we cannot handle Java and C#, two popular languages.

CW: does java have the right kind of generics, impression was reified generics

RT: java has arrays, one way that java implements vtable canon for array is to have a field in the class, that says vtable for arrays, non-uniform recursion, those arrays are variant, if you extend iso-rec to support variance it becomes undecidable. Even for user-defined generics arrays.
So the problem comes up due to Java arrays, even though user-defined generics are erased.

AR: we need to explore this to figure out what works and doesn't, no easy answer. I'm convinced that there are things that won't work, but that's true in any direction. I mentioned some things I know won't work, not sure how relevant they are. Might have ways to work around that. We always have things to work around. If there is a work-around then it's a question of how expensive and how common it is.

TL: thinking about prototyping this in Binaryen with least churn possible, would it be sufficient to take the type section that is currently emmited and find the strongly connected components to define the recursion group and just pretend it was defined as those groups all along, and do canonicalization. This will break down in theory for some use case, but for common basic use case in producers, will that work? or any immediate issues you see.

AR: for performance? That should work for canonicalization.

RT: probably won't validate anymore

TL: why?

RT: if people make their own subtype hierarchies, and i have in there a rec-group, and subtype of something in that rec-group.

TL: this is the problem of A B and C you discussed earlier. I will think of how to hackily prototype it.

AR: just to measure canonicalization performance its fine

TL: true, validation doesn't matter, but it would be nice to have something working end-to-end.

AR: all you care about is bottom-up canonicalization and see how fast it is

TL: okay, thanks both

AR: when i tried the test case, binaryen or whoever emits this seems to use a dependent index space for field index spaces, i had to hack ref interp to handle that. for symbolic field indices in text format, they would be per-struct, and that won't fly because it only works if we have both the type index and field index on struct.get, we want to get rid of former, so you can't resolve it syntactically

TL: you mean with iso-rec

AR: nope, completely independent, we were discussing removing more type annotations, struct.get won't have type of struct anymore in syntax, you won't know where to lookup the field in which type if you just desugar it, you would need full type-checking, which breaks the idea of symbolic identifiers, we can't support that in the future.

AR: the labels are local, like in C, don't think it works here.

TL: might have issue on this, can file an issue

AR: works right now, won't work when we change it.
"
gc/2020/GC-06-16.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 16th video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: June 16th, 4pm-5pm UTC (June 16th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Update: v8 GC prototype (@jakobkummerow)
    1. Update: Kotlin GC implementation (@skuzmich)
    1. Discussion: Linear memory GCs (@kmiller68)
    1. Discussion: criteria/objectives/requirements for GC proposal (@fgmccabe)
1. Closure

## Meeting Notes

### Introduction of attendees

* Adam Klein
* Andreas Rossberg
* Ben Smith
* Cheng Shao
* Daniel Wirtz
* Emanuel Ziegler
* Francis McCabe
* George Karachalias
* Hans Hoeglund
* Jakob Kummerow
* JP Sugarbroad
* Keith Miller
* Lachlan Sneff
* Lars Hansen
* Luke Wagner
* Ross Tate
* Ryan Hunt
* Sabine
* Syvatoslav Kuzmich
* Wouter van Oortmersson
* Zalim

### Update: v8 GC prototype (@jakobkummerow)

[Jakob presenting]
[slides](https://docs.google.com/presentation/d/1FhDU3lkjQIuXA7K9MK3MXggQvxT5Glj4e2bifr4_Jlg/edit?usp=sharing)

RT: How are you doing v-tables?

JK: You can put function references into an array?

[some audio issues]

RT: Function calls have to be done by putting a funcref into a table, just wondering if that's the plan

JK: Yes, I think so. Not strictly required to have function references right now. If so, we'll add it.

Zalim: Any information about when it will be finished?

JK: I'm hoping in a week or so, but hesitant to make any promises.

KM: Any further work?

JK: Not quite done with milestone 2, not sure what to do after that. Don't want to waste work. Not too willing to do experimental work. We're interested in hearing feedback. Planning to take time to respond to feedback.

HH: How best to try this out?

JK: Compiling from source is not too hard. You can use [JSVU](https://github.com/GoogleChromeLabs/jsvu), you can get fairly up-to-date binary snapshots. Also can use Chrome canary (24-hour latency)

RT: Minimal features, surprised that let-locals are required. Interesting to hear why.

JK: We added those so we had a way to test non-nullable references. You could have as an intermediate on stack values.

### Update: Kotlin GC implementation (@skuzmich)

[Syvatoslav Presenting]
[slides](https://docs.google.com/presentation/d/1shBSyexgdwegaGQH3PXtFiLcyWDsi4BvYmi6n0hVIj8/edit?usp=sharing)

KM: Nullable references. Rough estimate, how many are trivially provable that the value is not null? On the wasm-side?

SK: I don't have that data.

KM: Just curious.

FM: You don't need VM support for coroutines?

SK: They are stackless coroutines, implemented in user-space.

FM: Ah, so you do program transformation for that. Would it help if there were VM support for it?

SK: Not sure.

RT: Yes, they are syntactically restricted like C#.

FM: There may be less code if there was a common pattern for coroutines.

RT: For non-nullable references: kotlin can guarantee that strings are non-null. When you defining strings, are you defining it as non-null?

SK: We have enough information about non-null references, but FF doesn't have this yet.

HH: For generics, I assume you add costs. Do you know what kind of performance improvements you could gain?

SK: Haven't measured performance yet, just functionality. Casting and v-tables are suboptimal. We're waiting for more VM functionality.

RT: Your generics are erased, right. So you have to cast them anyway to guarantee soundness.

HH: If you have enough information in the source language, you could prove it.

SK: I believe you can infer a lot of information from the language about generics. But yes currently they are unsound, and you have to add casts. We don't have immediate plans to investigate in this area.

### Discussion: Linear memory GCs (@kmiller68)

KM: We want to make sure that linear memory GCs have good integration with the host GC. We've spent a lot of time and bugs on integrating GCs. I think every engine has multiple GCs at this point. I hope we can come up with some way to avoid this. I was hoping to come up with some sort of criteria.

KM: So in linear memory GC, so the wasm module is providing its own collection strategy. So you are building a connection graph, which is also connected to host GC. This is similar to browser GCs where DOM and JS have connections between them. For us we have DOM reference counted and JS garbage collected. So we have issues here. I assume that a naive linear memory GCs will have similar issues. So we can expect that differences between browsers may cause issues here, causing memory leaks.

KM: I'd like to have a problem statement that can prove we can solve it.

RT: It's a pretty hard problem. I've discussed this with Steve Blackburn.

[general agreement from browser VMs that this is very hard]

JK: Our teams have determined that the only permanent solution is to combine them.

RT: You need a way to have a finalizer in and out. The problematic cases is when you have spirals coming in and out between GCs.

KM: There's also issues with reference counted implementations, since they have cycle detection algorithms. A lot of GCs are concurrent too, and you need to interact with their safepoints.

HH: Can you use message passing to do this… like Erlang? Would that work?

KM: I suppose that could work.

FM: One of the memes coming out of interface types is that you make this available at the edge. You have a map at the outside that allows the two worlds to talk to each other. One possible idea is that you don't try to have a close integration with the host. You delegate everything to the API at the edges.

KM: That's still kind of how it works on the web. You're more likely to have leaks then, you have to call a function to retain. The bridge will have a hard root because they need to be in a table somewhere.

WVO: I guess you would not try to use references across the boundary. So both spaces would not have references.

KM: It sounds like a lot of copying --

FM: It might not be, though. At least with DOM walking, it turns out that it has not very measurable overhead. In practice, this may be a better strategy than you think it would.

RH: At least for the DOM, there are cases where you can't just copy. For example, addEventListener with a callback needs a reference. If you want to do this in Interface Types, you need references across the boundary.

FM: The event loop cycle is the obvious and serious one. The approach we've been considering here is that you model that DOM reference as a resource. And someone has to take responsibility for managing the lifetime of that resource. You don't rely on GC for that, instead they have to be explicit.

KM: So you reference count.

FM: We're not, the application does.

KM: That's the case we're worrying about, we rely on the DOM to be careful. And that has problems, people make mistakes.

FM: The difference is that the module has their own language, and their own GC story. The application takes responsibility for managing its resources. If there is a mistake there…

KM: That would be fine if I didn't get bug reports if a website didn't work in my implementation.

LW: Two application scenarios: blackbox model (like Francis is talking about). The other one is taking languages like scala.js kotlin.js, with tight integration with JS. Trying to make it feel like you're using typed JS. For those languages, you need a host-integrated GC.

KM: I think it would be a shame if it would be better if compiling to JS was better than our GC story. It would be an unfortunate conclusion if it ended up that way.

LW: OK, for the scope of the wasm GC proposal it seems like host-integrated is what we're talking about. And separate discussion for the other model.

HH: Talking about implementation -- I don't see how that matters. As for semantics, I don't see how the implementation matters.

LW: There's a fear that the different browser GC implementations will cause differences in behavior.

KM: And the browser rewrite the GCs too.

RT: One strategy we came up with -- you can use a coloring GC scheme. You reserve additional space for flags. If you design for only having one flag, that rules out other strategies.

FM: There's a difference between works-as-intended, and works on my page.

RT: Running low on time, should we switch topics?

### Discussion: criteria/objectives/requirements for GC proposal (@fgmccabe)

[Francis presenting slides]
TODO: slides and discussion about critical factors analysis

KM: So idea here is that we have a list of criteria, in readme.

FM: You could use a diagram, yes. It makes the relationships more readable.

JS: Good idea. Best way to do this is for someone to make a strawperson, to have a concrete starting point.

AI(binji): add agenda item to discuss criteria at next meeting
"
stack/2023/stack-2023-02-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 13th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  February 13th, 17:00-18:00 UTC ( February 13th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants

Daniel Hillerström
Sam Lindley
Francis McCabe
Ilya Rezvov
Thibaud Michaud
Andreas Rossberg
Luke Wagner
Ashley Nelson
Deepti Gandluri
Benjamin Titzer
Brendan Dahl
Adam Klein
Thomas Lively
Ross Tate
Ryan Hunt
Zalim Bashorov

## Agenda items

1. How to add stacks to V8 (Ilya Rezvov)

IR presenting [slides](https://docs.google.com/presentation/d/1Jx8mNKVucK242e0z3iScQK9r4UD0U4VFKQxQpTWdnKg/)

This meeting was recorded, the recoding is [here](https://us02web.zoom.us/rec/share/7OOX_3iz680WLmC2h695faJ8-ldmmH_kwjLi-r6WJESFcFrSs0zuLn7M09NOd9sq.yMlSXAL-I4lGlKJv).

## Meeting Notes

AR: Is V8 investigating conservative GC for all frames or just C++ frames?

IR: (missed answer)

SL: Growable stacks, are these segmented stacks or are you expecting to move the stacks?

IR: That's the next slide!

BT: How would that work on Intel with the shadow stack?

IR: When we call, we push the return address on shadow stack and never replace return addresses, so we don’t have to adjust it. There could be one case with top frame on stack grow, but we don’t have to do anything involved because if we copy frames, we keep return addresses the same so we don’t have to change in the shadow stack. Segment stacks as well.

TM: Don't think there's anything to do for stack growing, just stack switching.

AR: When you copy over, you keep the addresses so that would require VM techniques and would need to be required if you want to handle native stack frames as well or they would be completely gobbled when you copy to different addresses. Presumably that means you can’t use copy on grow on i32 platforms or something like that

FM: To be clear, we’re not going to have native frames on these stacks. 

IR: Because of switching to shadow stack,makes our life a bit easier. We chose segmented stacks so we don’t have to worry about this. When we create a new stack, async.wait but never suspend, segmented stacks allows easier optimization because we can continue to execute, use the same stack for freshly created greenthread. And if we return to parent, in this case we can have immediate stack overflow and build a new stack segment for parent. An optimization we call stack stealing, because you steal stack from parent to use for execution. A bit easier to do with segmented stacks.
SL:
BT: Sampling profiling, is that simple to support? Are there plans to support?

IR: Falls in debugging and profiling bucket. I haven’t thought about it yet, I’m not sure.

FM: Currently if you use the pthread??? API for something, it won't crash, but it won't sample your WebAssembly code. You'll need a new WebAssembly-aware profiler.

SL: You mentioned these two approaches, copy on grow and segmented stacks. Another approach that hasn’t been mentioned because maybe it’s been discounted is the variation of growable stacks where you use VM to avoid having to change the address of the stacks at all. So the libm library that Ben Lyon created for instance. Have you considered this approach and decided it’s not worth doing?

FM: We have and it doesn’t scale.

SL: What would the various entries be in the table for that case? Is it ruled out from the start because you don’t think it will scale to smaller platforms?

SL: Do you have a feeling for the relative costs between ""heavy"" and ""light"" stack switching?

IR: Right now, still limited by mutex acquisition, so we cannot properly measure and get numbers. My feeling is it shouldn’t be too expensive, several additional instructions for updating execution state. Could tax us a bit because it’s not cache friendly. We hope it won’t be prohibitive.

SL: The priority is to optimize the mutex?

IR: Yes, optimize mutex and it shouldn’t be expensive for existing calls. If we have to introduce green threads and we have to use it, then it’ll be a little bit less efficient but it will be usable.

FM: How much work has this been?

IR: It's a huge project. We already spent half a year developing it and will continue this year. More than a year for rounding up to two people.

SL: How much more work would it be to do the things you listed? That you said should be done?

IR: Hard to say because right now we're working on getting just one platform done. Next platforms should be slightly cheaper.

SL: You don’t have all of the segmented stack infrastructure done or the allocators, those kinds of things. Would that be something that is relatively easy to plug in?

IR: Yes, a new allocator would be easy to plug in because it's not integrated in V8.

RT: What’s the biggest cost of switching?

IR: You mean switching between stacks?

RT: What takes the most time to switch between stacks?

IR: It's the mutex we want to eliminate.

TM: I don’t think we’ve done presized yet.

IR: For each switch we have to update several roots in V8. It's not too expensive, maybe several dozens of assembly instructions, mostly accessing and modifying memory. Without mutex it shouldn't be too expensive.

RT: It should look like a function call with a little extra stuff + the mutex call.

IR: We're targeting 5 to 10 function call overhead.

BT: Do you have a list of design alternatives you rejected and a record of why you rejected them?

IR: I mentioned movable stacks, I’ve rejected it because of CFI and potentially less room for optimizations in the future. Also, initially we tried not to switch to central stack, our grow routine wrappers of native code but it requires. We don't have a special requirement for native code so we have to annotate all runtime calls with how much space we need. And it sounds like a pretty hard to maintain and estimate tasks. So switching to central stack was a better solution here. 

FM: The main one would be the VM for stacks. The issue is we have the traditional problem with real threads, you have to guess how big the thread would be. If you’re going to run on small platforms, even 64-bit platforms like Android, you run out of address space pretty quickly. And there are some embedders that don’t have VM but that’s less of our concern.

SL: One downside of segmented memory is they allow you to have pointers into the stack, whereas if you're moving the stack around, you have to reload the pointers. Is it not relevant for v8?

IR: Not relevant, we still have to update some small pieces of state.

SL: Like what?

IR: Frame pointers. And we store sometimes references to arguments, arrays. So there are several places.

TM: If we had native frames, this would be less of a problem but we have JS.

SL: That must be another design decision you discarded immediately? Having native frames in the segmented stacks?

FM: Originally we were going to do that.

IR: THe first was conservative GC scanning, it crashed in our POC impl. So now we have some code that gathers all secondary stacks in special leased process. It’s more work to do. Conservative GC you have to be aware of what you’re doing and traverse the segmented stacks, so it is more coupling to subsystems.

FM: To answer Sam’s question more directly, there is documentation here. We have design documents that cover this.

SL: Where are they?

IR: We can revisit and publish more broadly.

RT: Another issue I remember was overflow potential.

FM: We looked at one possible strategy which was annotating the code. As Ilya says, we could do it for our own code, but apart from everything else, v8 is embedded in other systems and it would be an impossible burden for those embedders.

AR: In what way is it relevant? You don’t have stack overflow checks

RT: Virtual memory handles it if it overflows in a typical way, the VM says hey, stack overflow.

BT: It is significantly more difficult to make those checks work with VM than advertised. It doesn’t work to use the pthread library with virtual memory stack overflow checks.

RT: Can you clarify what you mean? Because C++ code doesn’t check the stack overflow.

BT: In C++, it is undefined to overflow the stack. In linux, you can’t use the pthread library. You have to use your own stack segment with Linux to do overflow checking with stacks.

FM: Why because the stack you get is not protected?

BT: Linux has this idea of automatically growing stack segments for you, handling traps. So if you try to create red zones it doesn’t work because you’ll be confused by the heuristics in the kernel for the stack. So if you want to use VM in your own stack, you have to roll your own, it’s the only way to make it completely stable.

RT: Are you saying virtual doesn’t require any VM to do stack overflow stacks.

BT: It does, but it uses its own stack segments, and doesn't use the pthread library.

RT: What does virtual do when it calls out to its own C++ code?

BT: It does not call 
















### Adoption of the agenda

### Adjourn



"
simd/2022/SIMD-02-18.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the Feb 18th video call of WebAssembly's SIMD Subgroup

-   **Dates**: 2022-02-18
-   **Times**:
    -   4pm-5pm UTC (9am-10am PDT)
-   **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this
[form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1.  Opening, welcome and roll call
    1.  Opening of the meeting
    1.  Introduction of attendees
1.  Find volunteers for note taking
1.  Adoption of the agenda
1.  Proposals and discussions
    1.  Preparation for phase 3
    1.  Open issues not yet merged in the spec
    1.  AOB
1.  Closure

## Meeting notes

### Attendees

-   Andrew Brown
-   Deepti Gandluri
-   Evan Nemerson
-   Johnnie Birch
-   Lars Hansen
-   Marat Dukhan
-   Petr Penzin
-   Richard Winterton
-   Thomas Lively
-   Yury Delendik
-   Zhi An Ng

### Preparation for phase 3 (Zhi An Ng)

ZA: Resolution of fpenv discussion: there are open questions in the current
spec, some inconsistency is allowed, ex.: fused multiply and non-fused add, etc.
Before phase 3 we need to finalize instructions, add tests, and agree on
instruction prefixes. Additionally we might need to work on feature detection,
since we are adding more possible features.

DG: bring up feature detection to CG again, try to phase 2, see what open
issues, can prototype, need to find the right people to do it.

AB: is fpenv a blocking issue?

MD: fp sub defined via fma with negated operand. not sure if min/max need to be
consistent, cpu may prefer to lower min and max to vectors using a single
compare, which would be asymmetric.

AB: what was the state of fpenv discussion?

ZA: there is no explicit fpenv parameter in the spec anymore, instead we assume
that there will be consistency in operations

AB: fpenv on x86 can be changed by MSR

LH: no, no runtime presence of this at all

MD: you can disable FMA instructions, will be different fpenv

LH: that comes into play when we cache machine code, capture the fp status
register and make sure it doesn't change we we reload

AB: seems fine, likely no one is messing around with it, if they did, with
different MSR

LH: only migrate code between processes

PP: majority of stuff that happens there is rounding mode, etc, can't turn off
FMA

DG: from v8's perspective, don't expect to provide user visible flags for
different semantics. Problem with caching, one way to get around it is to
compile the compiler everytime. Seems like the folks using relaxed simd will be
aware of this.

LH: i care less about users, then bug triage people who get very obscure crashes
from this

PP: relaxed simd generally feels like this, general philosophy, can't depend on
this to do the same thing

MD: would be helpful for developers for them to test different fpenv from the
native one, could be interpreter, no need to be performant interpretation.

LH: can imagine a config flag in the browser, that compiles relaxed this way or
that way

MD: doesn't have to be in browser, like a standalone engine

AB: spec interp maybe

MD: yea

ZA: seems like a quality of life improvement, not super blocking

AB: agree with DG, occupational hazard, relaxed is a big warning sign that we
can have differences on different arch

PP: in general, people dev on different platform than it runs on, people will
have difficulty using it, don't see any better way to do it

DG: we had this entire deterministic push, the objective of this is to relax
this, we can do some things here, don't know if we can get rid of all the
weirdness. E.g. for testing, relaxed simd fuzzers can flag some
non-deterministic, so don't crash. If users will migrate this, it will be
different. Relaxed simd is a different thing that developers have to work
around.

EN: will be willing to add different flags to SIMDe to help people test
different fpenvs

### Open issues not yet merged in the spec

Relaxed rounding Q format. There are discrepancies between Arm and x86.

MD: guarantee results only if highest bit of second input is 0, 8 bit by 7 bit
dot product, enough to be the same, neural networks, neurons can be 7-bit
unsigned (activations always positive), weights as 8 bit signed, get 2x speed up
with special instructions. unlocks native dot product, multiples quad in one
element with another, produces 32-bit output.

YD: judging by instruction name, what instructions are you proposing

MD: proposed 4 instructions, unsigned and signed variants, accumulate to 16 bits
(2 elements)

YD: is it really relaxed? or can it be guaranteed.

MD: if want to be portable, have to be relaxed

YD: we are limiting 7 bits

AB: users can put whatever they want

MD: doesn't mask the high bits, result only guaranteed for 7 bits

LH: we need to ask kenneth if this can be used in their kernels, not sure if
they depend on it

YD: looks at it, really depends on 8 bits, want to use all precision. he detects
8 bits

PP: will we be able to enforce 7 bits?

MD: not enforced,only guaranteed if you use 7 bits

PP: you can enforce it in the engine

MD: relaxed swizzle instruction, guarantees only inputs are in range. same here,
only when input is in range

PP: trying to follow up on what Yury said, there is no way to make this strict
(non-relaxed)

AB: can zero top bits

PP: it ignores extra information

LH: shift left shift right

AB: this is relaxed simd, user can do that too

MD: on arm, thats one instruction to zero high bit, on x86 depends if mask is in
memory, user guarantee that it is in range

AB: XNNPACK can use this instruction?

MD: doesn’t have 7 bit elements, but can adapt to it

ZA: can we get Kenneth to look at this too?

YD: he is targeting Intel architecture

DG: seems like we have a small number of outstanding instructions, any big
instructions others want that have not added issues for?

### AOB

JB: what's the intent with relaxed simd if there is some instruction that was
missed, multiple versions

DG: can spin up proposal and move it along. I imagine this as some subset of
instructions solving a particular use case, some logical subset of instructions.
There is a burden of doing the work to make it a standard. If we think of
something, consider it for this proposal.

JB: wondering if there was some additional instructions, will there be a more
stringent process

DB: not particularly stringent, there is overhead in spinning up a proposal, a
new branch

MD: a class of instructions we talked about, approximate reciprocal, and other
approximate instructions. We can even have all libm functions as approximate
instructions. They are non deterministic differently from relaxed-simd,
relaxed-simd we can enumerate the differences. These instructions, on way to
enumerate, it will be in the millions of different variations. Leave it out,
potentially next proposal. Don't see that much speed up from reciprocal
instructions on recent CPUs. Native division is sufficiently fast, as long as
algorithm is not doing division all the time. E.g. in division in sigmoid, not
very conclusive wins.

ZA: probably a good idea to leave this to a different proposal

MD: maybe define instructions not in antive, approximate exponential, on native
will be multiple hardware

PP: how to define output?

MD: define accuracy of output, will have millions

DG: no objections for approximate instructions to different instructions, was an
old issue on simd proposal

MD: one more in mind, bfloat 16 dot product instruction. it can be polyfilled by
extending bfloat to fp32, then using qfma, need to check if results are really
different across different cpus, some newer CPUs have native instructions for
bfloat16, not sure if they differ on x86/arm and what we can polyfill.

DG: process note, any objections to doing agendas the way we do regular CG
agendas, in meetings repo

ZA: can still have the issues, will copy paste agenda items to meetings repo
agenda

PP: other subgroups doing that

DG: GC moving to the main cg process now

TL: yes, have moved

DG: stack switching, more adhoc

LH: echo Andreas comments, name should reflect it

DG: relaxed might be too long, maybe nd (non-det)

LH: instruction names are already very long

MD: not as big deal, care more about intrinsics

ZA: intrinsics match closely instruction name, for discoverability

AB: in favor of relaxed prefix, links intrinsics, proposal, and instruction
names

MD: summarize up the plan forward, on board with stage 3, rename instructions, q
format mul, dot product

DG: for open issues, engine will prototype come back with feedback, phase 3
needs test suite, text format names and opcode not as important, can bike shed,
implementations agree, design consensus

ZA: feature-detection, will we be blocked on that

DG: move along together

ZA: action item for everyone to look at outstanding issues not in overview (will
tag those issues) and comment or thumbs up

AB: for spec tests, are we adding to wast to detect range of results?

MD: oneof result

DG: file issue on this, see what needs to change in test infra
"
main/2020/CG-08-18.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 18th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: August 18th, 4pm-5pm UTC (August 18th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. A Meta-meta-meta Request for Proposals (7.5 minutes)
    1. Discussion on Typed continuations for stacks ([issue](https://github.com/WebAssembly/design/issues/1359
)) (Daniel Hillerström, Daan Leijen, Sam Lindley, Matija Pretnar, Andreas Rossberg, KC Sivaramakrishnan) [20 min]
       - Poll: Phase 1?
    1. [Proposal for changes in EH proposal for two-phase unwinding support](https://github.com/WebAssembly/exception-handling/issues/123) +
       discussions (Heejin Ahn) [25 min]
       - Potential poll: Should we make the change?
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Adam Klein
* Alexander Syrotenko
* Alex Crichton
* Alon Zakai
* Andreas Rossberg
* Asumu Takikawa
* Ben Smith
* Conrad Watt
* Dan Gohman
* Daniel Hillerström
* Daniel Wirtz
* Derek Schuff
* Emanuel Ziegler
* Francis McCabe
* Heejin Ahn
* Ioanna Dimitriou
* Jakob Kummerow
* Jay Phelps
* Jlbirch
* KC Sivaramakrishnan
* Keith Miller
* Lars Hansen
* Luke Wagner
* Nick Fitzgerald
* Paolo Severini
* Pat Hickey
* Paul Dworzanski
* Rick
* Ross Tate
* Ryan Hunt
* Sam Lindley
* Sergey Rubanov
* Syvatoslav Kuzmich
* TatWai Chong
* Thomas Lively
* Till Schneidereit
* Vivek Sekhar
* Wouter Van Oortmersson
* Yury Delendik
* Zalim Bashorov
* Zhi An Ng

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Lars seconded

### Proposals and discussions

#### Review of action items from prior meeting.

#### A Meta-meta-meta Request for Proposals (7.5 minutes)

Francis McCabe presenting
[Slides for RFP Proposal](https://docs.google.com/presentation/d/15lHl2dKRRkcGk38tHJDp7ireljxqtuvTJsqiOD_Mawc/edit?usp=sharing)

AR: What are the differences between our current process. It seems like phase 0 is similar, one or two pages. At that point CG votes if they have interest, which is phase 1. What's the difference with RFP?

FM: new artefact, the RFP itself, it will morph into a requirements doc. Having a separate reqs doc where you state what you want. Not that different from what we do informally, I'm proposing we formalize it to some extent.

CW: The biggest difference is if someone ""misses the boat"" then that would be ground to reject their proposal out of hand.

FM: we have seen some of these already, it has caused a lot of trouble, e.g. with exception handling, garbage collection. We’ve seen late proposals, even though they should be given more space, they haven’t been given more space (informally). This has caused a lot of friction

AR: The particular examples you gave are things we voted on in the CG years ago. How would these particular examples change with what you propose. Exceptions have been at phase 2 for a while, before most recent discussions were started.

FM: it does have a forcing function, that’s part of the point. Part of the reason behind this is to do that: it is to make the bar higher for people coming later

BS: have to cut off discussion here, can come back to this at the end of the meeting or follow up on an issue.


### Discussion on Typed continuations for stacks ([issue](https://github.com/WebAssembly/design/issues/1359)) (Daniel Hillerström, Daan Leijen, Sam Lindley, Matija Pretnar, Andreas Rossberg, KC Sivaramakrishnan) [20 min]

[TODO(AR): add link to slides]

HA: What does undelimited continuation look like? Are synchronous continuations…

AR: Undelimited means you don't have a parent. You can't do that, you can invoke another continuation. So call/cc, in scheme, that implements undelimited continuations, they're symmetric.

HA: Thanks

[Back to slides]

RT: You say in practice you want delimited continuations, but Python's stackless continuations are undelimited. A lot of people use this. I understand you can emulate this, but this is a pretty popular system that uses this.

AR: Right, but it's true that if you talk to scheme folks they say you don't really want this.

RT: for applications, custom control structures, delimited control is preferable, for other applications, such as green threads, undelimited is more common, depending on setting.

AR: control abstractions is what we are targeting here, that’s the whole point of the proposal, that’s why you want stack switching. You want stack switching to compile control abstractions. Almost all are of this nature

RT: Python want's stack switching for green threads.

AR: one of the few control abstractions you can actually implement with undelimited continuations but not in a compositional way.

[back to slides]

<On note about “avoids GC”>

RT: should bring this up offline in the discussion of the other proposal, not spring a surprise like this

AR: yes, point is by construction, avoid GC

RT: the other proposal also does not have cycles by construction

[back to slides]

FM: I want to pick apart the typed part of this… if you have two coroutines communicating through a channel, then there is flow information not known to the scheduler. When you talk about types, you're only talking about communication between a thread and its scheduler.

AR: between stack and its parent

FM: talking about green thread scenario, it’s between thread and scheduler. The types you’re talking about here are only the types.. Only the “control types” of the thread itself, not any data being communicated. OTOH, I will assert that the programmer is most interested in the type going through the channel.

AR: The types here are only concerned with what the construct does. If you have other channels, with which threads can communicate, this is agnostic to that. But it is still the case, as with await or generators, these are the values you want to communicate with. You are communicating specific values between the thread and the generator, etc.

FM: when the stack is deciding to signal back to its parent, there are different scenarios that might happen, normal, exceptional, yield, some data. These are variants of a control flow, there isn’t one type involved here, since each of these different events have different type information associated with it.

AR: That's crucial right. Different suspend points and have different types. With await that's exactly what you need.

FM: but you call out one of them, which is the final return values. If you have a coroutine (using this to be general), if it never suspends, then you’re probably not using the control mechanism, it will suspend at least once. A non-normal return will happen more often than normal return, but you called out normal return in the type. I will argue that is meaningless…

AR: you’re right, but i’m not talking about normal returns, the resume and return is typed.

BS: unfortunately, have to cut off to move on to next topic. Can come back to this at the end. There’s a lot more to talk about this, especially with the other proposal.

##### Poll: Phase 1?

#### [Proposal for changes in EH proposal for two-phase unwinding support](https://github.com/WebAssembly/exception-handling/issues/123) + discussions (Heejin Ahn) [25 min]

[Slides: Two-phase Unwinding and its Implications](presentations/2020-08-18-ahn-eh-two-phase-unwinding-pt1.pdf)

AR: Why is it not a simpler transformation to move callB out of the inner try? It's probably worth noting that this example is over-simplified, but in the general case it's not so simple.

HA: Yes, in whatever way we sort the CFG we can solve this problem.

AR: iiuc, that comes in when you have multiple unwinds going to the same handler, if you didn’t have that, this problem wouldn’t exist, the CFG might construct such a thing

HA: Not sure, in the original program callA and callB should unwind to different catches. It's a byproduct of CFG linearization that we end up in the inner try. But that's not the program's semantics. So we're fixing it to use the original program's semantics by using transformations.

ID (on chat): sorry, no microphone, couldn't one also use br_on_exn there? I mean, instead of setting a local with the exnref

HA: br_on_exn is for checking tags, this is for how we can find the right catch. Br_on_exn is used after we determine which catch we should go to. After we decided if this is the right catch, we use br_on_exn for tag checking. Btw, we don’t need to use locals here. We can make block return value, setting local is a simple way to do it. The gist of this is that exnref can escape catch blocks, we can do this transformation behind the scenes.

BS: We're out of time. Let's continue discussion on the issue.

##### Potential poll: Should we make the change? (skipped due to lack of time)

### Closure
"
wasi/2024/WASI-01-25.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: January 25 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: January 25 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Guy Bedford: JCO progress update
    1. Vote: launching WASI Preview 2

## Notes
### Attendees

- Bailey Hayes
- Pat Hickey
- Colin Murphy
- Robin Brown
- Jeff Charles
- Friedrich Vandenberghe
- Timmy Silesmo
- Syrus Akbary
- Luke Wagner
- Matthew Yacobucci
- Radu Matei
- Kate Goldenring
- Dave Bakker
- Joel Dice
- Daniel Phillips
- Dan Gohman
- Till Schneidereit
- Guy Bedford
- Andrew Brown
- Wassim Chegham
- Stephen Berard
- Nuno Pereira
- Yong He
- Chris Woods
- Oscar Spencer
- Hung-Ying Tai
- Liam Randall
- Chris Dickinson
- Johnnie Birch
- Piotr Sikora
- Fedor Smirnov
- Zalim Bashorov
- Merlijn Sebrechts
- Trevor Elliott
- Saúl Cabrera
- Alex Crichton
- Jamey Sharp
- Behnaz Pourmohseni
- Brian Hardock
- Yosh Wuyts
- Maximilian Seidler
- Radu Matei


### Notes

[Slides](https://docs.google.com/presentation/d/1PGYkm_oJEOXsCFNH45uJl0L43XsTsEe5wOZnsQB706o/edit?usp=sharing)

** Bailey Hayes** Starting with going through the phase criteria - Vote to include in Preview 2 needs to have the proposal voted for inclusion of the world into the Preview once it has reached phase 3. This is a window for Preview 2 - this set is the launch set, more can be added after the launch until we launch the next Preview 3.

** Bailey Hayes ** We have reached phase 3 for two worlds. Here is the criteria we voted on for that at a previous meeting.

** Bailey Hayes ** We vote by consensus, following the wasm CG’s process. We are going to vote SF, F, N, A, SA.

** Bailey Hayes ** Wasmtime’s implementation status is complete for wasi:cli/command and wasi:http/proxy worlds. The only change since the phase 3 votes is that wasmtime now has more tests that pass.

**Guy Bedford ** JCO is a JavaScript implementation running on Node.js, by myself, Yosh Wuyts, and Wassim Chegham. Last meeting we had a little delay to work on the polling system, thanks Trevor Elliott for helping with that work.

**Guy Bedford** JCO now passes all of wasmtime’s tests on mac and linux. On windows it passes all except one (104/105). The failing test has to do with readonly directory behavior on windows. The CLI world works with `jco run` and the http world works with `jco serve`. We even have CPython working just as it does on wasmtime, as further demonstration that it is conformant.

**Bailey Hayes ** What does the launch criteria mean? Stability - there are two implementations that conform

**Bailey Hayes ** What does it mean for preview 3 to launch? Is the question in the chat. The question is asking about what the window means. Our goal with Preview 3 is support within the component model for native async - futures and streams. Preview 3 applications will be a breaking change and not run on Preview 2 runtimes.

**Pat Hickey ** Preview 3 will launch no sooner than 1 year from now

**Luke Wagner ** Before Preview 3 we can have minor releases in the Preview 2 family, with additive changes - new features that we can add, but not change any existing interfaces. Those releases can happen at a much faster cadence. We can add new proposals to preview 2 as part of those point minor releases.

**Bailey Hayes ** This is a feature of having versioned, modular interfaces, making those minor releases possible.

**Bailey Hayes ** The first vote we have is about the wasi-cli world. Here is its portability criteria. Wasmtime and JCO meet those criteria. We’ll now hold the vote where everyone can enter the 

**Till Schneidereit ** Adding to prev discussion, to clarify that preview 3 is additive because it extends what wit and the component model can do, rather than change the behavior of existing content for Preview 2. So, Preview 3 implementations will run Preview 2 programs.

** Dave Bakker ** Between preview versions, do we need to conform to backwards compatibility within wit itself? Or is an adapter module considered backwards compatible

** Bailey ** Its only additive - for streams we could add a new operation for forward splicing, but we cant change any existing methods on streams.

** Luke ** with preview 2 minor releases we can use the subtyping the component model already allows, which is adding new functions. 

Vote begins

SF: 24
F: 10
N: 1
A: 0
SA: 1

** Bailey Hayes ** We have confirmed the count. I declare consensus based on that vote, to include wasi:cli/command world in preview 2.
**Till Schneidereit ** We typically record the reasons an against voter votes against a proposal

** Syrus Akbary ** As I said in a previous meeting I dont believe that wasi cli is up to the state it should be in for termios, compared to other proposals

** Bailey Hayes ** Preview 2 allows for additive changes so we can add things to that world at a later date.

** Bailey Hayes ** Moving on to the next vote for wasi-http proxy world inclusion in WASI Preview 2. Wasi http has two implementations, again wasmtime and jco, and there are users running it in many contexts beyond those implementations - fermyon is consuming it, wasmcloud is as well, (notetaker adds: fastly is as well).

Vote Begins

SF: 23
F: 7
N: 4
A: 0
SA: 0

** Bailey Hayes ** We have confirmed the vote tally, that means we have consensus to include wasi-http in preview 2.

** Bailey Hayes ** Our last vote. The launch criteria is that two independent criteria define worlds, and all their dependencies have met the requirements for inclusion and the WASI subgroup has voted to launch it.

** Syrus Akbary ** In the bytecode alliance you have worked on wasmtime and jco, in wasmer we are behind. Have you thought about halting or waiting until wasmer implementation is done.

** Bailey Hayes ** We have reached phase 3 for a few months. What would be the value of holding the launch if your inclusion is fully additive, we already have two very different runtimes and met the criteria this preview 2. There are other runtimes working on implementations, Michael Yuan gave an update to this group on WasmEdge adding support for Preview 2, and we dont have motivation to hold the launch for other runtimes. If breaking changes turn out to be necessary based on feedback from other runtimes we have preview 3 to work on that.

** Guy Bedford ** On the jco side this is a collaboration with microsoft, in terms of implementation feedback we had a lot of very interesting discussions, from the implementor perspective we satisfied we answered all the questions that came up during our implementation.

** Till Schneidereit ** These are completely separate implementations that do not share code, and they are done by different sets of people, so we are not only conforming to the letter of the rules but also to the intent, which is to have different implementations vetting the design. If other groups have started later and are behind on implementing it, that is no reason to hold up.

** Bailey Hayes ** To reiterate what Robin said in chat, there are a lot of folks who need a point of stability to add Preview 2 support in their platforms and applications, and I don’t want to wait on that.

Vote Begins

SF: 25
F: 9
N: 0
A: 1
SA: 0

** Syrus Akbary ** I will choose against because of the wasmer thing.

** Bailey Hayes ** With that we have consensus to launch preview 2. Thank you everyone for putting the work in over years. This standard has taken a lot of different folks, we thanked a lot of people before break and put those in the notes and i’m certain that was not everyone, thank you all for putting in the effort.

** Pat Hickey ** I want to thank you all, this is a great community to be a part of and I’m proud of what we accomplished together.

** Till ** I want to thank Bailey and Pat for shepherding this process, and I think we are at a great place with a great set of specs and implementations, I look forward to many more implementations to come. This is a big moment for WASI and WebAssembly.





"
main/2020/CG-09-01.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 1st video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: September 1st, 4pm-5pm UTC (September 1st, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. [Proposal for changes in EH proposal for two-phase unwinding support](https://github.com/WebAssembly/exception-handling/issues/123) Part 2 + discussions (Heejin Ahn) [30 min]
       - Potential poll: Should we make the change?
    1. [Proposal for First-Class Stacks (Phase 0 in design#1360)](https://github.com/WebAssembly/design/issues/1360) (Ross Tate) [30 min]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Adam Klein
* Alex Crichton
* Alon Zakai
* Asumu Takikawa
* Benjamin Titzer
* Ben Smith
* Conrad Watt
* Daniel Hillerström
* Daniel Wirtz
* David Piepgrass
* Derek Schuff
* Francis McCabe
* Heejin Ahn
* Ioanna Dimitriou
* Jacob Mischka
* Jakob Kummerow
* Jay Phelps
* JLBirch
* JP Sugarbroad
* KC
* Keith Miller
* Lars Hansen
* Luke Imhoff
* Luke Wagner
* Manos Koukoutos
* Mitch Moore
* Nick Fitzgerald
* Paolo Severini
* Pat Hickey
* Paul Dworzanski
* Rich Winterton
* Rick
* Ross Tate
* Ryan Hunt
* Sabine
* Sergey Rubanov
* Syvatoslav Kuzmich
* TatWai Chong
* Thomas Lively
* Zalim Bashorov
* Zhi An Ng

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Thomas Lively seconds

### Proposals and discussions

#### Review of action items from prior meeting.

#### [Proposal for changes in EH proposal for two-phase unwinding support](https://github.com/WebAssembly/exception-handling/issues/123) Part 2 + discussions (Heejin Ahn) [30 min]

HA presenting slides
TODO(heejin): add link to slides

HA: Follow up to presentation from two weeks ago. Not about 2-phase unwinding itself, but how to change current proposal.

[Audio issues, deferring to later in meeting]

##### Potential poll: Should we make the change?

#### [Proposal for First-Class Stacks (Phase 0 in design#1360)](https://github.com/WebAssembly/design/issues/1360) (Ross Tate) [30 min]

Ross presenting slides
First-Class Stacks [(pdf)](presentations/2020-09-01-tate-first-class-stacks.pdf) [(pptx)](presentations/2020-09-01-tate-first-class-stacks.pptx)

JS: You have catch resuming, but resuming should receive the stackref but it seems to drop it, is it meant to be resumable?

RT: resuming knows its payload doesn’t have stackref in it.

JS: thought there was always a stackref in it

RT: Look at switch.call, look at this event. There doesn't have to be a stackref there. You can use a switch.call to hand the stackref off to the function, not the event.

JS: in this use case you’re not using switch calls, you should have received a stack

RT: High level is there are two common patterns… yield control and have stackref of yielding stack. Sometimes the yielder knows what to do, sometimes the resumer knows. stack.switch says yielder knows, stack.switch_call says yielding stack has some responsibility.

[back to slides]

JP: It's possible for two promises to interleave each other… multiple promises that resolve out of order.

RT: this is still fine with that, basically you can conceive it as, you have a promise you want to wait for… resume this stack that is storing the f with this value, then keep going

JP: How do you know which stack to actually resume… could be multiple suspended?

RT: this is running under the assumption that C++ is already under, that there is only one stack, another version we have in the writeup with multiple stacks

LI: I think it might just work in browser environment, we use Rust w/ promises to do this. We have event handlers and requestAnimationFrame that runs in background process, they don't seem to have problem interacting, they are both happening on UI event loop in JS. They are not actually happening in parallel so it doesn't seem to have an issue.

JP: makes sense

[back to slides]

LI: Would switch_drop handle destructors?

RT: switch_drop is just basic cleanup, not unwinding. That is written up in the example. This was called at the new root, so there's nothing to unwind.

LI: right now we have extra code for rust promise, if you get to the end the executor drops then assume promise is rejected. We still have to do that, switch_drop won’t do that for us

RT: You there are other things you can do, switch abort, etc. switch_drop is a shorthand.

[back to slides]

CW: How important is it that stackrefs are unique. Can you give a high-level on how that would be enforced.

RT: Not critical, could be either way. We think it's more useful that way. If you can guarantee that it's unique, it has more obvious resource management.

CW: How would it be enforced, don't need to implement a borrow checker....

RT: most instructions in Wasm are already linear/affine, we found a few instructions you can give an affine version of, and you call that, everytime you use get, clears out the old value, make sure no one else grabs it. That’s written in the proposal. That’s the sort of thing we can toggle based on community feedback. This is based on our analysis, we found this to  work better- affine is easier to manage in low level language

CW: Makes sense thanks.

HA: Wondering about then/within instructions, multiple times you mention implementing two-phase unwinding using these. My proposal is about using the current EH instructions to implement two-phase handling instructions, so if we use then/within instead, then what is the point of making the changes I'm suggesting?

RT: Haven’t talked about two-phase unwinding yet. Stack inspection is related to that, but is different than what is presented here.

HA: Two different set of instructions, so there's no point in changing if we are deciding to use the other one.

BS: maybe we should talk about this in another venue, question doesn’t sound related to presentation

HA: Will present assuming that we will use the current EH proposal for two-phase unwinding, not stack inspection, so need to understand motivation for stack inspection.

RT: we can revisit stack inspection another time, this is designed such that however we designed EH or stack inspection, they complement each other, no fundamental locking between each other

HA: confusing, but will continue presentation without switching

HA: i have not presented it yet, can’t ask for vote/questions

TL: you should present it first

HA: we have 10 mins only, i cannot finish this, will go as far as I can

[Back to discussion on Ross's slides]

CW: do you think you can implement 2 phase unwind with without changing it

RT: went through a couple of times, not easy without changing it

LI: which instructions are the new one? Answer? Or within?

HA: we are using throw and catch. RT’s stack inspection is using call_stack, which is something similar to throw, and within is something like try-catch. RT’s inspection does not use try/catch/throw, uses different set of instructions. I am confused because… we have respectively different views for the change. I was confused that the current proposal is not extendable, but you don’t want to extend it.

LI: I can understand how redirect_to, can be a nested try instead. But why can't call_stack...

RT: … it looks for a function on the stack that can handle/answer the questions

LI: lumen really needs stack switching, we don’t care about 2 phase unwinding, we use stack switching to switch processes

HA: I wasn't talking about stack switching, I don't think they are related.

RT: fgm and i had a thought, having a stack subgroup. The issue is that, there are a lot of interacting issues, need coordination,need to coordinate inspection, unwinding, etc.

HA: I asked a single question and it wasn’t answered. You said current proposal has to change for 2 phase unwinding. But in other proposals and issues, you clearly want to use stack inspection instructions for 2 phase unwinding. I’m confused why do you even want to see the changes in the current eh proposal. I still want to extend the current proposal myself. That’s my reason I propose my changes, because I thought we were on the same page, I’m not sure about that right now.

RT: your changes make us happy. That’s the important thing.

BT: q on stack switching, switch_call instruction, you can call fn on stack you want to switch you. If that fn throws exception/even that matches the handler on the stack, does that mean you can throw exception on other stack.

RT: yes

JS: you can build stack frames on a different stack, and you can execute over there

### Closure
"
gc/2023/GC-04-04.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 4 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: April 4, 4pm-5pm UTC (April 4, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Status checks
        1. Spec documents
        1. Bulk array operations
    1. Discussion: Text format field names ([#333](https://github.com/WebAssembly/gc/issues/333))
        1. Dependent field names
1. Closure

## Meeting Notes

### Introduction of attendees

 - Thomas Lively
 - Conrad Watt
 - Ilya Rezvov
 - Matthias Liedtke
 - Alon Zakai
 - Ashley Nelson
 - Nick Fitgerald 
 - Adam Klein
 - Zalim Bashorov
 - Sergey Rubanov
 - Petr Penzin
 - Manos Koukoutos

### Status checks

TL: Conrad, were you able to do the code review Andreas was waiting on?

CW: No, have to focus on other things for the next two weeks. Will be first priority after that.

TL: Will we be able to have the spec documents done in the next three months?

CW: Maybe? It’s a problem of bandwidth if only Andreas can write them and few people can review them. Will present sometime on a research project I’m starting to make spec writing easier. It will be a DSL for writing the spec that will give us the reference interpreter for free.

TL: Sounds very cool. Maybe that’s something we would want to work on if it can help us improve the bus factor for spec work.

### Discussion: Text format field names ([#333](https://github.com/WebAssembly/gc/issues/333))

CW: Even if we have globally unique field names in the custom section, you are still going to need the typing information to go from the binary format back to the named text format. Is that definitely true and I’m surprised this hasn’t come up in conversation before?

TL: That was a late stage realization. I don’t think there was a special reason it didn’t come up, just no one realized it. The format of the proposed name section is a two-level namespace so it’ll have a type index, a field index, and a name. So it does assign names to specific fields in specific types. In a hypothetical future where we have struct access instructions that don’t have a type and only a field index, even with a complete name section, say the field index is 0 and you don’t have type information, you can go through your name section and collect every single field name that is at index 0 in some type but that is going to be an arbitrarily large set of field names and without knowing about what type you are accessing, there is no way to pare down.

CW: That makes sense, but that becomes an issue in the hypothetical world where we have instructions without type annotations and now everything ties together.

TL: Right, this was a response to Andreas’s argument that a two-level namespace would have a bad debugging experience in that hypothetical future. So will single-level namespace, so it doesn’t matter.

CW: I buy it.

### Discussion: Type annotations on branching cast instructions

ML: If you specify the source type as non-nullable and the target type as nullable, is it legal? Does it compile? Is it rejected?

TL: If I remember the details of AR’s proposal, there were some number of syntactic combinations that were allowed. Eight syntactic combinations and two of them wouldn’t validate so I think that was one of the ones that wouldn’t validate.

CW: Actually in his current PR, I’m not sure they validate, I had also this thought because there are combinations that don’t make sense which I think ML is alluding to.

ML: We have flags for the target and source nullability,. Two combinations don’t make sense but there is nothing wrong with allowing them, you just lose nullability information because you used this combination that is like an up-cast on the nullability.

CW: Depends on specifics of AR’s PR which is off my memory, but I think the way he expresses the two types get combined to look at the output type even if you look at the output type as nullable if the input type is nullable the whole type becomes nullable regardless of the type. But we didn’t evaluate all the edge cases of the PR.

ML: I tried to look at the changes themselves and had issues understanding how that derives the return type. And on the issue itself, I think there was a comment about 6/8 combinations validate. But then I couldn’t find validation error in the PR or changes.

CW: I’m looking at the changes now and if you have non-null input type and a null output type annotation the output type is still non-null. The definition [here](https://github.com/WebAssembly/gc/pull/359/files#diff-0428d866a3b1cf7a48c6da6ddaa09671223f7b44af03f4447d09bf482963e2bcR197). We shouldn’t assume thai is what the spec will say but that is what the PR says right now. 

ML: You’re referring to the diff_ref_type?

CW: I believe so, I could be misreading it but I think... Oh no, I need to think about this harder, I could be totally misreading it. That is the piece of code that needs to be understood to understand what the current PR is doing. 

TL: We can push for clarity on this issue. It’s been stagnant and I agree it’s confusing and not clear what we are going to do here.

CW: Sorry ML, I may have given an incorrect response there, but we can ask in the issue.

ML: Okay, yeah I have no idea.

TL: I found that the [corresponding prose](https://github.com/WebAssembly/gc/pull/359/files#diff-1df1ea4af362cad5073bac12a65046e4c21bdaa644f69e203b41687b933ac91dR636-R638), null1 is the input and null2 is the output, but yes it is confusing.

Discussion: WasmGC implementation in wasmtime

NF: I’m going to start an implementation for wasmtime soon. Q, is the most up to date place as far as the spec goes, my understanding is it’s not written, should I look at mvp.md as the main source of truth.

TL: Absolutely

AK: What about the [milestone doc](https://docs.google.com/document/d/1DklC3qVuOdLHSXB5UXghM_syCh-4cMinQ50ICiXnK3Q/edit#heading=h.lqaesg5voz6r)?

TL: I was thinking only spec document stuff, but milestone doc is even better, thanks AK.

AK: Parallel track that engines and producers have been coordinating on.

TL: Binaryen, v8, everything else.

NF: MVP.md is getting ahead and then there is a coordinated step?

TL: Exactly, mvp.md is the canonical one, combination of where the actual implementation is going next and also when there are brand new instructions, the semantics are given in mvp.md and the binary op codes should match the milestone doc but the milestone doc is definitive as far as the implementation binary op codes go. For the implementation in wasmtime, can you share more about what you're planning? What’s the GC going to look like? What’s the implementation strategy?

NF: Are you familiar with the RFC process that wasmtime uses? I’m starting there and it’s going to have all that detail but it’s not written yet. For reference types we have a deferred reference counting implementation. We don’t mutate reference counts on the stack and use stack maps instead. I was wondering if we wanted a cycle collector, and don’t think we do. The other thing is that wasmtime is used in a lot of different production environments. Not just implementing for a browser, so I think this is going to necessitate a pluggable GC, so I’m thinking about how to define those interfaces right now. I think we’re going to have, just to get the spec tests working, a null GC that crashes on OOM. I would like to have a MMTk backend, something we can plugin. And for function-as-a-service, which a lot of embedders of wasmtime have, I am toying with the idea of a semi-space collector because it gives you fast-allocation but the 2x heap overhead is not fun. Ideally you have lots of short lived programs, so how can we have fast allocation without having fast GCs. So maybe a simple Immix mark-region thing, so we can use the full heap space rather than the semi-space thing. What’s tempting about the semi-space thing is it’s very obvious what the bookkeeping overheads are. And the way wasmtime works is you have a pooling allocator where you allocate space upfront and you divy it among the instances you want to run concurrently. And trying to think about how to statically allocate AOT the bookkeeping heap space is very easy for a semi-space collector and less simple for others.

TL: Thanks for sharing, looking forward to the RFC. Will definitely check it out.

NF: Will share once it’s ready.

ZB (chat): no-GC? :)

NF (chat): yeah, we will have one, but I don't think that will fly in production :-p

ZB (chat): why not? for short living programs, like lambdas?
"
main/2019/CG-03-19.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 19 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: March 19, 4pm-5pm UTC (March 19, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email Ben Smith to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. [Normative: Permit work in parallel during instantiation](https://github.com/WebAssembly/spec/pull/745)
    1. [WebAssembly ESM integration](https://github.com/WebAssembly/esm-integration/blob/master/proposals/esm-integration/README.md) for Phase 2 ([spec](https://webassembly.github.io/esm-integration/js-api/index.html#esm-integration), [HTML PR](https://github.com/whatwg/html/pull/4372))
    1. Growing shared WebAssembly.Memory and updating SharedArrayBuffer objects
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Adam Klein
* Alex Crichton
* Alon Zakai
* Ben Smith
* Ben Titzer
* Conrad Watt
* Dan Gohman
* Daniel Ehrenberg
* David Piepgrass
* Deepti Gandluri
* Derek Schuff
* Flaki
* Francis McCabe
* Jacob Gravelle
* Jensengrey
* Lars Hansen
* Limin Zhu
* Luke Imhoff
* Luke Wagner
* Pat Hickey
* Paul Dworzanski
* Paul Schoenfelder
* Sergey Rubanov
* Sven Sauleau
* TatWai Chong
* Thomas Lively

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Daniel Ehrenberg

### Proposals and discussions

#### [Normative: Permit work in parallel during instantiation](https://github.com/WebAssembly/spec/pull/745)

DE: queueing is a continuation of discussion from a year ago. JSC needs to do work during instantiation, different types of memory, may need to do more work. This PR yields to the event loop, to do work. Yields to the event loop unconditionally. All browsers need to do this. That was recommended to make things consistent.

BS: Were any concerns expressed on the issue?

DE: No concerns were expressed there. It was a normative change, maybe wait for implementations? Needed for ESM modules.

SS: I think there were concerns about [inaudible] yielding to the event loop.

AK: It was only Dan who mentioned that it was a performance concern.

BS: I assume that BT and LW are not speaking out so I would assume this is not a concern?

BT: So after you instantiate a module, you have to yield to the event loop once?

DE: between

BT: Oh, not sure about that, will try out.

LW: Makes sense to allow this kind of flexibility.

BS: So maybe we should try and see if there were implementation concerns?

LW: Probably won’t break anything in practice.

SS: Maybe make another proposal for that?

LW: May be a 2-hour patch, so I can try it out and see if it breaks anything.

DE: thanks

#### [WebAssembly ESM integration](https://github.com/WebAssembly/esm-integration/blob/master/proposals/esm-integration/README.md) for Phase 2 ([spec](https://webassembly.github.io/esm-integration/js-api/index.html#esm-integration), [HTML PR](https://github.com/whatwg/html/pull/4372))

DE: The ESM integration proposal is ready for phase 2. It has a dependency on top-level await, async work for compilation. There is ... we need the evaluate phase of the module to be asynchronous. I reviewed this with people who work on bundlers, the explainer has been updated.

DE: What do people think, should we put this in stage two?

BS: [describing phase 2]

DE: Lack of tests is because of no top-level await. Until then, it doesn’t make sense.

SS: Does it mean that the [inaudible]

DE: Not at the javascript level... this differs from how wasm modules are implemented in bundlers, since they are done earlier without allowing certain types of imports.

BS: Do you know of anyone planning to prototype this?

SS: We have a preliminary implementation in webpack, but is currently not up to date with the spec.

DE: We should consider native implementations necessary for moving ahead, but we have had positive feedback from tooling as well. We may be able to work on this at Igalia.

AK: Comment about dependency (top-level await)?

SS: I don’t think it’s really a dependency?

DE: It is, but we want to go forward with top-level await, at stage 2. I think it would be good if wasm moved forward with this too as a signal. It doesn’t make sense to ship in browsers until stage 3.

SS: My understanding, async modules are a hard dependency, but top-level await is just using it.

DE: I see that this is being developed in concert, so I think we should move them forward in standardization as well.

AK: I second Dan’s concerns that there is a strong enough signal. Changes are likely to come from the JS side, not our side.

BS: So ... is the premier concern?

[unanimous consent to move to phase 2]

#### Growing shared WebAssembly.Memory and updating SharedArrayBuffer objects

AZ: In pthreads + memory growth, we use webworkers to implement pthreads. We allow JS work in those pthreads too. When you grow memory, it grows fine for wasm, but JS outside needs to update it’s views of memory. There’s no great way to do it, if you’re running JS and memory grows in another thread, it’s memory might be out of date. So we’ve been thinking about options here, some ideas for spec things.

BS: We were brainstorming how to solve this problem, whether we were missing some obvious solution. The major issue being, TypedArray views cannot grow out of under you, but ... 

LW: When memory grows, they remain valid, they just reference a subset. For that particular range it should be accessible.

AZ: This simple cases can be handled, if you add a call to JS from malloc.

LW: You have to consistently refresh the buffer.

AZ: One option is to work around in JS, instrument the code, people need to find where to do this. Concerned about the lack of guarantee.

On the spec side, we could also call into read/write into wasm memory, if we provided a way to do that then we’d be safe.

We could also have a WebAssembly.Memory.seti32...

LI: ...?

BT: Your comment targets the implementation level, this is more the language level. The array buffer has length, and we can’t update them because of JS semantics.

LW: This would be a burden to insert refreshes. Is there any technical problem, other than that it’s annoying?

DS: The real problem is ensuring that the other threads are updated. You can pass an allocated pointer to another thread.

LW: That JS will receive the new memory, every time you read a new i32 you have to validate it.

BT: Every time you go through the memory object, you have to use buffer. You can’t cache it.

LW: For e.g. loops you would still need to access it once, that being said I can see the value of having a Memory.get/set... method

BT: Is it worthwhile to have grow memory sending post message?

LW: You wouldn’t have return to event loop to receive it, you have to handle the worst case pessimistically.

BT: You would still get a signal that you should update your views.

BS: My concern is you’d still need to create a view to pass it to a WebAssembly API...

LW: You could imagine that you have a getView that creates a new one that is always valid. You could polyfill... the object itself could be implemented in JS.

BT: could we put something on the prototype for out of bounds accesses?

AK: Not sure you can handle OOB here because typed arrays are too fancy.

AZ: We could polyfill this in the meantime. May want to tell users that pthreads + memory growth are not an option.

LW: Abstraction boundaries? Is there any interface between the user an wasm memory. We have our own JS that we can audit by hand. Users can write their own JS. Very risky. 

BS: You would suggest them use this slower interface only for the pThreads+memory growth case?

AZ: yes, possibly

BT: How prevalent is it that people write code accessing the buffer?

AZ: Extremely common, how often the buffer is changing is hard to tell.  To some extent it depends on how common this is for users to use. It would be nice to think about spec part.

BS: Seems like the type of thing we are unlikely to do here, but some JavaScript experts here might want to do it and throw it over the fence?

AZ: It’s on WASM.Memory so maybe it should be this group...

LW: ...

DE: The idea is to have wasm memory allow direct reads, even when growing.

AZ: Yes, have memory.readI32, writeI32, same as wasm memory.

BS: Someone should write something up, or write a polyfill probably to move this forward...

AK: Write-up is probably a good next step.

[some discussion of in-person meeting logistics]

### Closure
"
gc/2022/GC-10-04.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 4 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: October 4, 4pm-5pm UTC (October 4, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Deferring i31 to post-MVP ([#320](https://github.com/WebAssembly/gc/issues/320))
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Aske Simon Christensen
- Justin Michaud
- Ben Titzer
- Francis McCabe
- Rick Battagline
- Conrad Watt
- Slava Kuzmich
- Jakob Kummerow
- Asumu Takikawa
- Alon Zakai
- Manos Koukoutos
- Zalim Bashorov
- Ilya Rezvov
- Sergey Rubanov
- Pierre Chambart
- Léo Andrès
- Andreas Rossberg
- Yulia Startsev

### JS

YS: I offered to work on the JS side a few months ago but haven’t gotten to it.

TL: Jakob has been working on MVP minimal interop, will need more later.

AK: I believe Yulia is referring to the unrelated JS types proposal https://github.com/WebAssembly/js-types.

### Discussion: Deferring i31 to post-MVP ([#320](https://github.com/WebAssembly/gc/issues/320))

TL presenting [slides](https://docs.google.com/presentation/d/1f7jc82JxvuW8krsyCGr5q8revL8rVYLHXr32ihSL5mU/edit?usp=sharing)

BT: I would say that OCaml counts as a production language.

TL: Agree if folks were working on it.

PC (Chat): Leo and I are working on this (OCaml) already. The current version of i31 works well, but don’t have performance numbers. Getting numbers by comparing to boxing all integers would be too much work.

TL: News to me, would be great to hear more about this. If you could post an issue with your experience, that would be great.

BT: Want to avoid self-fulfilling prophecy where people don’t use it because we don’t include it.

AR: Talked to OCaml folks and they are waiting for the proposal to settle. Agree about self-fulfilling prophesy.

FM: Which is the more important use case, representing small integers or uniform representation?

AR: Both.

FM: But Aske’s experiments use it as an optimization.

AR: I think that’s a more advanced use case.

BT: Agree. And would want additional instructions to support that use case.

ASC: Yes, those are the kind of instructions I suggested.

AR: To be clear, they are useful, but that’s the part that we should push to the MVP because it’s less clear to me what we need there.

BT: I generally agree with Andreas. Given that interface types will have variants as a primitive, they will need to be able to implement those efficiently.

AR: The only runtime I have worked on that used tagging for small integer optimizations was V8.

FM: I don’t think the IT consideration is relevant because the interface types are not materialized.

BT: They’re lowered?

FM: Yes, but not materialized. My reading is that there was a misunderstanding of what i31 was for.

BT: This is really a space optimization to avoid boxing when you have the union of a small scalar and pointer.

AR: Also a time saving from avoiding allocation, I hope.

TL: AR mentioned in the past that i31 as currently specced would be compatible with future addition of unions.

AR: They're orthogonal. Unions would be a union over heap types, it'd just work out. As to ASC's use-case I don't see why we couldn't add such instructions in the future.

CW: To echo what I said before, introducing a union type that is i31-or-something

TL: That's the i31-as-type-dimension discussion?

CW: Yes

TL: Are we concerned about weirdness where i31 appears in multiple places: as a heap type, and also as a separate item in this union list?

CW: …

AR: We could have a step where a union has a heap type and an i31, and then generalize from there.

CW: If it was between that and having i31 as a type dimension, I would choose this halfway step.

BT: externalize and internalize are nops in Wizard. That will be observable once we have unions. (note taker missed details about casts making this observable)

AR: This is why I think it's bad to be able to cast to any type. For this reason and others, it's not gonna scale.

ASC: Want branching instructions to perform sharpening. That’s key to the benefit from unions in the i31 optimization case.

AR: A union would be defined as an ordered list in the type section (ordered to avoid quadratic costs), and casts would only be able to strip the last type in the list to perform sharpening. Compilers would have to be careful in how they compose types, but it would make for good performance.

CW: Is the problem of casting an arbitrary type to a union worse than casting a struct that contains a union?

AR: Yes, because the struct has its own type definition that does not depend on the contents. For subtyping on unions, if it’s the ordered thing, it’s not very useful for casts. Might still need a quadratic number of checks. Won’t scale. The property would be that a value never has union type, so it might be linear.

BT: Right, no dynamic union types, so the value only has a single type info on it.

ASC: Could simulate cast to union with a block where the target type is a union and have a sequence of checks.

TL: Would love to hear more from OCaml about whether i31 works for them. For post-MVP it sounds like we may want to add more things like ASC has suggested.


BT: On the subject of having it as a dimension, I think it would be ok if we end up having redundant ways of using/specifying i31 as a trade off to get it into the MVP.

JM: Couldn’t find literature about “type dimensions.” Is there another phrase?

AR: It’s basically something we came up with, since nullability (or i31ness) is independent of what the heap type is.

CW: I’d be very happy if we never added any other type dimensions, since it affects every single heap/reference type.

AR: Agree, and also it doesn’t match how it’s needed in practice, since it’s needed in union.

ZB (chat): Can we do something like ref i32 and depend on small value optimizations?

TL: This was discussed in one of the issues. It’s too unpredictable for Wasm.

AR: In particular we don’t want implicit allocations.

JK: We speculatively inline call_ref based on type feedback, but not with deopts. We may add them eventually.

CW: I remember that you previously said it could apply to call_indirect as well. Has that happened?

JK: We’ve thought about it, but haven’t implemented it yet. There’s not a high priority. One issue is with type canonicalization and function subtyping.

AR: IIRC, the proposal as currently written has function subtyping, but not for call_indirect.

JK: My understanding is that it’s intentionally conservative and we would like to find a way to lift that restriction without regressing performance.

AR: I think the best thing to do if you want to check subtying in call_indirect would be to have a fast path that checks equivalence and a slow path that checks subtyping.

BT: Don’t you know statically that there are no subtypes?

AR: No, because some other module might have defined a subtype of the intended signature and passed a function in.

BT: (more details)

CW: Question for Aske: does that change to use function subtyping also depend on it in call_indirect?

ASC: No, we’re using covariant subtyping in struct definitions.

BT: I think Java doesn’t need function subtyping because it requires generates bridge methods when overrides change types. Virgil does have this subtyping in both parameters and returns, but it generates bridges and would need the full generality and would need func.bind to attach function types from a different hierarchy.

ASC: Dart also has variance in both arguments and returns. But for call_indirect, still need some signature on the call site. Could use the most specific type, but you don’t generally have it at the caller.

AR: Wouldn’t it be the other way around? The annotation would be the most general type and the function that gets called could end up being a subtype of that.

ASC: Think you’re right. Could take LUB of all functions that could appear.

AR: Another option is to keep call_indirect as it is now, and it could be emulated with table.get + downcast + call_ref. Don’t know if an engine could get that as fast.

CW: Question would be whether it would be faster or smaller in the engine to do that or to support generalized subtyping in call_indirect.

BT: Fast path to check signature ID in table entry might save one instruction maybe.
"
wasi/2020/WASI-12-03.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the December 3 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: December 3, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Lin Clark
    - Email: lclark@fastly.com

### Registration

None required if you've attended before. Email Lin Clark to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Review of action items from previous meeting(s).
    1. Ralph Squillace to write up a draft on ""WASI experimental"" or versioning for WASI API experimentation.
1. Proposals and discussions
    1. Discussion topic: Repository organization to enable independent proposal repos ([#360](https://github.com/WebAssembly/WASI/issues/360))
    1. Discussion topic: Using releases to make the repo citable ([#356](https://github.com/WebAssembly/WASI/issues/356))

## Meeting Notes

### Attendees
Lin Clark (LC)
Pat Hickey (PAH)
Martin Duke (MD)
Andrew Brown (AB)
Dan Gohman (DG)
Till Schneidereit (TS)
Matt Fisher (MF)
Mingqiu Sun (MS)
Mark McCaskey (MM)
Johnnie Birch (JB)
Ralph Squillace (RS)
Peter Huene (PEH)
Sam Clegg (SBC)

LC: Action items from last meeting - Ralph is not on the call, so we’ll skip over follow ups with him

LC: Dan put up a PR yesterday about repo organization to enable independent proposal repos

DG: In a CG there's the core spec repo, and proposals that add new features are fork repos of the spec. When a proposal gets to stage 5 (spec), the proposal gets merged into the central repository. We want WASI to have a parallel structure to this.

DG: One thing we want to move away from is a single snapshot path. So when we make a snapshot its url remains stable (we don't put it into old). What this enables is one snapshot referring to another. We want documentation to describe the differences between snapshots and eventually tools will too. Stable URLs are a good first step towards that

DG: Another feature is moving away from ephemeral. That was envisioned as the place where we do development, where PRs target, but we want to move all development into proposal repositories. The main proposal repo will no longer have an ephemeral directory.
DG: A final piece of this is a place in the repo for a script, similar to core CG’s test suite repository, that pulls in the proposals from all the places they live, and creates the snapshot. All of the proposals will be separate modules in the snapshot.

AB: When do proposal repos get added to the script so they land in the snapshot?

DG: As soon as you create them you can create a PR to the script. One rule we could have is that if there's a merge conflict or other obvious errors we just skip over merging a proposal for now. But we want a snapshot to contain all proposals.

DG: In the root spec repo, there will be a `standards/` directory, it's empty for now because we aren't at stage 5 yet. But out in the proposals they can put whatever they want to land in the spec repo snapshot in their `standards/` directory. This convention is that we don't have to wait for everyone to sync up

TS: Will it make sense to say “only show me sections for proposals for stage of my choice in the rendered output”.

DG: We don't have that information yet but that's a good idea. Maybe a magic doc comment in the witx files. Or we can iterate

TS: There has to be some index about pulling in the proposals, and that can contain the metadata about what stage various proposals are at.

AB: This is a better system than we have today

DG: We are learning from our mistakes

TS: We need to iterate on the infrastructure of the spec in a central place, and make use of it without copying code over, are you envisioning the proposals will pull in the (upstream) spec repo? And we iterate on that outside of the snapshot mechanism?

DG: Some proposals need to make change to witx. They all have a witx crate in them to make changes to how witx works. You can experiment there and make a non-snapshot PR into the spec repo to merge bigger changes in. You can keep 

PAH: For some changes to WITX, it would make sense to do in the core spec repo and then proposals merge or rebase

DG: That is something that becomes more awkward with this setup. The question is would you also modify existing snapshots to use the new syntax? Because if not, then snapshots don’t work with new tooling.


PAH: let’s set that discussion aside. We have been updating to keep semantics but use new syntax. The hard part of this is that if we have to make a breaking change to WITX that could affect our ability to merge in proposals that haven’t taken in the breaking changes yet. Is it the responsibility of WITX maintainer to un-break all the proposals?

DG: Initial way that falls out is that the script that merges will run the new version of the tool over that. If it doesn’t run, we leave out of the snapshot

PAH: That sounds fine to me. What I’m thinking now is the CGs waterfall, continuous integration of tip of tree which makes it possible to find before releases. Could run it on a cron job and does red/green for various proposals

DG: If someone wants to set up a waterfall, that would be good. Might be more than we need right now.

PAH: If you have to update both your WITX files and ref implementation on downstream tooling, might not be able you

DG: You can do it on your local as a champion

PAH: This also makes me think about the value of the snapshot version being date based. You could have an id and a date. E.g. nightly-YYYY-MM-DD. That could give people ability to find breakages before time for snapshot. I think the biggest thing I’ve messed up in WASI and WITX is not having tooling that makes ephemeral work. Want the new process to be tip of tree always working. I could be wrong on that, but that’s my personal feeling.

DG: Ephemeral in main repo goes away. If they want to dev in standards dir, they can. If they have their own ephemeral, then it’s on them to keep it working.

TS: It seems to me that there’s value in cross-proposal CI so that you don’t find out when cutting a snapshot more work to do. I could see value in /standards and /in-progress, where we maybe have GitHub action that tries to do an integration build

PAH: I think I agree. I would love it if the CI action could be run in any of the fork repos so that they could alert on their own breakage.

DG: If we put that in the main repo, then they’ll all have a fork of it

PAH: They’d be able to id if any contrib to main repo is breaking. That’s an implementation detail.

TS: I feel like it would also be kind of nice to have a snapshot that’s always up to date for what it looks like today with all proposals combined.

LC: Are there more questions? (no). Dan what are the next steps?
DG: I can make a PR into the spec repo and proposal repos to adopt the new organization. The first step is to reorganize the spec repo and get the scripts setup, then reach out to the proposal champions to integrate up there.

LC: You can put that list of work into the issue and we can distribute that work out.

LC: Ralph has joined, do you want to talk about experimental stuff at all or next time?

RS: I need more time before I present that.

LC: Next thing on the agenda, we need to talk about releases. Someone is asking us to make citation easier using a tool called zenodo. For that to work we need to cut (GitHub) releases. Should we do this and when should we do them? It seems like we should do them when we do a snapshot. Does anyone have opinions on this?

JB: Question about zenodo: what does that tool do?

LC: It (??) DOI’s. I don’t know exactly why a DOI is important for a bibliography but its recommended over a URL when possible by the (APA?). The tool archives the data associated with the DOI, I believe.

LC: Then we’ll start cutting releases with snapshots. We can do one release now to capture the current snapshot. I’ll work with the wasm cg chair to get zenodo configured for the repo.

LC: Any other topics? (None)
"
gc/2022/GC-09-20.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 20 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: September 20, 5pm-6pm UTC (September 20, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Cast operations (https://github.com/WebAssembly/gc/issues/274)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Zalim Bashorov
- Aske Simon Christensen
- Rick Battagline
- Manos Koukoutos
- Asumu Takikawa
- Ben Titzer
- Luke Wagner
- Matthias Liedtke
- Alon Zakai
- Adam Klein
- Francis McCabe
- Justin Michaud
- Slava Kuzmich
- Andreas Rossberg
- Emanuel Ziegler
- Conrad Watt

### Discussion: Cast operations (https://github.com/WebAssembly/gc/issues/274)

TL: Recap of discussion. Want constraint that we can cast directly from `any`.

AR: Tried to come up with design where the two instructions end up with the same codegen.

MK: Can’t have same map for all data types because arrays are different.

AR: The problem is that we have introduced the array type, then.

ASC: Not the type as such, but rather that the implementation of `is_data` is “is_struct or is_array”.

BT: There’s a tag check for i31 as well that will be in every cast.

ASC: Right, if the input can be i31 then it has to check that tag as well.

MK: But that will happen whether we cast from any to a specific type or not.

AR: First step would check that we have a data, second step wouldn’t have to check i31.

BT: Also depends on how we treat null.

ASC: is_data is too specific… (note taker missed this)

AR: Fast path where you ignore subtyping and check equality, and only if it fails you go on a slow path?

ASC: Yes, and Manos did some experiments that showed that having the fast path was faster unless it’s completely unpredictable.

AR: I can believe that. In most cases the hierarchy is probably shallow, just one or two deep. Do you know what the numbers were for that optimization?

ASC: Think it was about 10% faster with the fast path, still with as_data there, so difference will be bigger without that. Then the fast path can save a cache miss (looking up the RTT) as well.

AR: This only happens when casting down from any or eq. How often does that come up?

ASC: It doesn’t occur very much in dart2wasm at the moment, but could become very common if we start to use the current i31 spec that would force the LUB to be higher up.

AR: In my experience, you usually have larger unions so you check i31 first and never need to check it again.

ASC: Yeah, except we don’t have the ability to express that in the type system. We don’t have a type for “not i31”.

AR: Wouldn’t data take that role?

ASC: But if you have to test for data first, then you’ve wasted that time as previously discussed.

BT: Trying to express Andreas’s concern to see if I understand it. Is it a problem that the code you get from a single cast instruction is different depending on what you’re casting to?

AR: Yeah, that’s one problem. It’s very heterogeneous, especially since we’ve hidden away the runtime types.

BT: I definitely see an argument for a new instruction using RTTs in the future. But I’ve been thinking about the issue of having heterogeneous casts and I think it’s ok. Casts are already weird and engines might have different implementation strategies. Whether they’re heterogeneous depends on the implementation.

AR: I can see that to some degree. There’s some difference along these lines that will materialize in any implementation. All engines are going to have more complicated object descriptions for some types. Also want to point out that the Wasm type information is not what you need at runtime except for casts. For example eqness and mutability are important for soundness but not codegen. You could imagine that the internal layout information is much simpler than the Wasm type system. I want to be able to eliminate the more complex information where possible.

TL: But the instruction factorization is just a hint for that. Engine implementors can still do whatever they want.

BT: Whole program analysis…

AR: Within a toolchain, will have conventions about which types have additional information. With generics, can compile entirely without casts and remove a lot of runtime information. There should be options to have representations without overhead. Want pay-as-you-go.

BT: Once you have the ability to have code you don’t know about, the engine doesn’t know what runtime information is unnecessary because of cross-module type canonicalization. Even if the current module doesn’t have an rtt.canon, some other module might have one on the same types.

AR: I don’t follow. Linking and canonicalization is about static types. But I’m talking about not requiring embedding this information in the allocated heap objects.

BT: But that’s not the design we currently have. Another module can cast a value you pass to it.

AR: But we are assuming that other module is from the language runtime, so it would be an invariant of that language runtime that the objects have RTTs.

TL: If language supports casts at all, will have RTTs no matter whether a particular module contains casts. Only elide RTTs if the language doesn’t support the cast at all.

AR: Yes, but of course it’s more nuanced. Different types support different casts, etc. In OCaml something like 99% of allocations are less than 4 words, so saving this space is extremely important.

BT: I think we’re shooting for maximum one header word on objects. There are definitely languages that don’t even need that, but you only know that if you have the whole program.

TL: Andreas is assuming we add a new allocation instruction that does not tie an RTT to the allocation.

LW: But you actually need to statically separate those types if you want to remove the header word entirely because that affects field layout.

AR: That’s true. I hadn’t been shooting that high. I am imagining new allocation instructions where you specify an RTT that might be a supertype. If you specify `any`, then you can’t cast to anything. Trying to keep the door open for a design like this.

BT: We can’t keep the door open for significantly different designs. Need to design based on current language needs.

TL: Popping back to concrete question of what MVP casts should look like, has the background discussion changed any opinions? Andreas, what do you think about casting from any given the discussion on performance?

AR: Least ugly thing would be to have one instruction for `any` to concrete type and a separate instruction for `any` to abstract types.

BT: Another dimension is what to do with null.

AR: Could add an immediate to the instructions saying whether they mean to include null.

BT: If we made the cast target a value type, it could encode the nullability. This could also generalize to other new complications we add on top of nullability in the future.

AR: I think most of the possible extensions will go into the type section rather than in the value type encoding.

BT: General problem that we’ve been baking choices of type constructors into instructions. Will be difficult to add more dimensions in the future. For example const and mutable references.

ASC: Or i31 as a type dimension.

AR: Not comfortable using value types when we don’t know what that will mean in the future.

TL: Could always add new cast instructions when we add those new complications.

BT: Just trying to find the most future-compatible option. We have some warts in the binary encoding

TL: Do we even need to parameterize all the instructions? When I looked before, it seemed that only ref.cast needed it.

AR: Think that’s right. Branches can be decomposed into multiple branches, so maybe only ref.cast and ref.test need it.

ASC: Needs extra blocks in some cases if it’s not combined. You want a branch on “this type or null” and on “this type and not null”

TL: Few minutes left, seems like there are more details to discuss. Let’s lock in the high-level design of having one set of instructions casting from `any` to concrete types and another set casting from `any` to abstract types, and let’s try to figure out the remaining details on the GitHub issue before the next meeting.
"
debugging/2019/debugging-09-05.md,"## Agenda for the September 5 video call of WebAssembly's debugging subgroup

- **Where**: zoom.us
- **When**: September 5, 6pm-7pm UTC (September 5, 11am-12pm Pacific Daylight Time, 8pm-9pm CEST)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Derek Schuff
    - Email: dschuff@google.com

### Registration

None required if you've attended a wasm CG meeting before. Email Derek Schuff to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.

Installation is required, see the calendar invite.

## Agenda items

1. Opening
2. DWARF and Wasm


## Meeting Notes

# Attendees

- Yang Guo
- Paolo Severini
- Derek Schuff
- Nick Fitzgerald
- Yury Delendik
- Bill Ticehurst
- Till Schneidereit
- Eric Leese
- Philip Pfaffe
- Z Nguyen Huu
- Deepti Gandluri
- Luke Imhoff

Yury has prototype of DWARF w/ extensions to encode wasm locals.
Patch posted upstream for LLVM but questions about approach, not landed yet

Paolo also using this patch for debugging wasm running in v8 from lldb

Alternative suggestion from adrian on llvm review was to reuse a different target’s expression type, seems like a big stretch.

Philip Pfaffe and Eric Leese are going to work on Wasm debugging on v8 for google

BT: any progress in other areas?

YG: Ingvar (RReverser) worked on a Rust tool to extract DWARF from wasm binary for making source maps. Based on Gimli

PS: have done something similar

BT: do we want to base the work on this:

PS: it’s pretty rough, maybe not


NF: update on Interface work: working on some webIDL interfaces. It’s almost ready to share. Should I do that in the form of a PR to the repo?

DS: yes

BT: how far along is the wasmtime work?

YD: it only support what we output in wasm dwarf today, and converts it into native dwarf. So it has the same gaps that wasm dwarf has

BT: does it use a separate wasm debug module concept?

YD: no, it just does everything at JIT time and registers the module with the debugger

BT: Nick’s design would be the debug module API, but that’s not part of this prototype
Right.

NF: this is more for people who are AOT compiling their library into a native lib/executable, who want to work with native tools that expect native dwarf. The APIs assume a situation where theres’a runtime that has its own tools that want to support source-level debugging.

BT: Paolo’s design the target wasm engine would expose the lldb interface

PS: or expose the debugger directly.

BT: at LLDB level you talk at the wasm layer.
But these are sort of separate parallel tracks?

TS: in some sense yses. For wasmtime we focuse on the debug info and extending the DWARF for wasm, and make wasmtime interpret that. Whether we’d keep that, we’ll see. It wouldn’t work for every case (e.g. a system like Mono). But we’ll need the debug format in any case. So this is a subset of what we need anyway. Bundling LLDB as a debug server on the side would still need a debug format, which could be the dwarf extension.

BT: this demo only works with interpreted wasm. If we JIT the engine has to track a lot more.

YG: currently the plan is an interpreter PoC first. For V8 weve talked about also adding debugging support in Liftoff, which is simple enough that there’s still 1:1 mappings for things like stack slots, so it could have the same set of features.

BT: so that’s nice that we woudln’t have to run things in an altenate mode or something

YG: yes. Turbofan would be much harder, to track everythign through the optimizations.

BT: so you’d have to fall back to the baseline for those.

YG:yes. Turbofan does smater regalloc

NF: that makes a lot of sense for recovering variables, scopes, etc. IDeally you should be able to access line table info anyway, even for e.g. the profiler.

YG: yeah line table info tracking is easier, that could be done.
BT: we can’t deopt, right? So we’d have to reload the wasm to debug it?

YG: right, for wasm. For JS we do have to be able to deopt so we have a way to do that for debugging too. But not for wasm; its unlikely because it would only be used for debugging.

YG: my understanding is that cranelift tracks the source info through to optimized code already?

YD: yes

BT: would you have it on by default? There must be a cost to that?

YD: hard to say currently. The code is not super optimized in any case yet, but it’s acceptable so far.

BT: are there things we need to agree on further in this group, in terms of standards?

YG: so far it seems that we are wanting to keep up

DS: one issue is API vs protocol, there was some reaction to that 

YG: the main thing is that we want the debugger out of process. We used to have it directly in the JS process but it caused 
a lot of issues. Once you move out of process, message-passing is easier than an API

NF: that could be an impl detail. You could have message-passing under the hood behind the API

YG: true, they could wrap.

PS: we could have 2 protocols: one higher-level exposed by the debugger module (could be an API). the way to talk to the debugee in the runtime. In my prototype that’s the low-level LLDB protocol. It’s a detail.

YG: that could make sense.

NF: I’m not sure we want to standardize 2 protocols.

PS: we might need to make some wasm-specific changes to the protocol but it wouldn’t necessarily have to be a new protocol, or standardized.

NF: the other thing about apis vs wire protocols is that as soon as we talk about wire protocol we have to talk about bytes, serialization, how to extend, etc. that question is easier with interfaces. If things can be impl details, it’s easier not to standardize them.

BT: you’d want protocols to be able to talk to multiple engines. I you define it as an interface how do you avoid specifying formats?

YG: you could just have a JS function interface

PS: do you want the debug module in the engine or in the program?

YG: []

DS: non-JS?

NF: definition would be in interface types eventually, not webIDL. We should also move DWARF doc into debugging repo

NF: other document this group should take responsibility of is the DWARF & Wasm document

BT: DWARF&Wasm doc is almost an appendix

DS: we make similar separation between conventions and standards in tools-conventions repo

TS: do MS have plans to extend PDB for wasm?

BT: no plans that I know of; don’t know what blazor team does

LI: related to blazor/mono question: Erlang/elixir just released our compiler. We’d like to debug the runtime and generated code. The runtime is in Rust, and the erlang is on top of LLVM. 
Blazor proxies the CDP

NF: we probably don’t want to worry about debugging interpreted code for the MVP

DS: you said you compile erlang to llvm ir; do you statically link that with your rust runtime code?

LI: yes

DS: if you generate llvm debug info for the erlang-generated llvm ir, then llvm should handle the linking of debug info for you and it should Just Work
Post-compile tools are breaking the debug info, its something they need to fix.

LI: we are very interested in the debugger module proposal because our language is so different from C

YD: lld can link any object file that has wasm dwarf, so you could link them and get DWARF

LI: we are interested in browser having similar UI for debugging wasm compared to JS

NF: that’s certainly something we want to eventually have.

AI: for moving the DWARF doc from the tool-conventions repo to the debugging repo. (there is an open issue but not a PR).

BT: there’s nothing for the API yet.

NF: I’ll put something there when I’m ready

BT: do we want MVP goals or scenarios we want to capture there?

NF: good to file an issue and hopefully come to an agreement about that next meeting. Previously we had discussed source-level stepping first, before doing scopes, vars, etc

BT: sounds good to capture that. I guess things like implentation details don’t necessarily need to be in standards

BT will open issue for dicussion on MVP. NF will open one when he has a proposal for API

LI: it would be great to have a link to flags and other implementations for people to try

DS: yeah, something like we have in the CG

LI: it would be good to have actual flags or instructions to make it easy to try


"
main/2018/CG-01-26.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 26th video call of WebAssembly's Community Group

- **Host**: Google Hangouts
- **Dates**: Friday January 26th, 2018
- **Times**: 17:00–18:00 UTC (9AM–10AM Pacific Time)
- **Location**: *same Google Hangouts link as before*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

None required if you've attended before. Email JF Bastien to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. [HTTPS everywhere](https://blog.mozilla.org/security/2018/01/15/secure-contexts-everywhere/)
        1. Discussion of what this means practically for WebAssembly, and what other browser vendors' current thinking is.
    1. [Contribution policies and repos for tools targeting WebAssembly](https://github.com/WebAssembly/binaryen/issues/1358)
        1. Currently Binaryen and WABT require contributors to join CG and agree to its IP policy (in addition to Apache2), which is a hurdle for some contributors. Should we continue this? What are the alternatives?
    1. [Combining Bulk Memory Operations and Conditional Segment Initialization proposals](https://github.com/WebAssembly/conditional-segment-initialization/issues/1)
    1.  Should the `spectest` module in the wasm testsuite be
        [implementable in wasm](https://github.com/WebAssembly/spec/issues/650)?
    1. Other items TBD
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

Changed day to avoid interfering with TC39.


## Meeting notes

### Roll Call

* Alon Zakai
* Andreas Rossberg
* Arun Etmr
* Ben Smith
* Ben Titzer
* Brad Nelson
* Dan Gohman
* Derek Schuff
* Eric Holk
* JF Bastien
* Jacob Gravelle
* Luke Wagner
* Malcolm White
* Marat Dukham
* Marco Trivellato
* Paolo Severini
* Peter Jensen
* Sean Westfall
* Sven Sauleau
* Thomas Nattestad
* William Maddox
* Wouter van Oortmerssen
* Yury Dekendik

### Opening

#### Adoption of the agenda

Derek seconds.

#### Find volunteers for note taking (acting chair to volunteer)

*JF volunteers.*

### Discussions

### Review of action items from prior meeting.

Brad says progress on the spec. Now goes through katex (all math is rendered offline!) and passes W3C validator. Luke is enthused. It’s a single page for now, some people like it, some less so.

https://flagxor.github.io/spec-drafts/spec/bikeshed_katex/

No other progress to report.

#### TC39 recap

* JF: TC39 sometimes feel left out, and want to make sure things such as weak refs don’t just sneak into the web platform.
* JF: Discussion of SAB being pulled. No real action for now.
* Brad: the group is very functional now! The new chair, and their little web app to control speaking are great.
* Peter: anecdotally biggest TC39 I’ve been to.

*AI:* JF to talk to Brian about using that tool.

#### [HTTPS everywhere](https://blog.mozilla.org/security/2018/01/15/secure-contexts-everywhere/)

Discussion of what this means practically for WebAssembly, and what other browser vendors' current thinking is.

* Luke: rationale is everything, even small features, would be HTTPS to help push adoption. There’s a reasonable practical limit, we can’t gate every tiny thing, but new opcodes could cause validation to fail. Multivalues might not need to be gated because it only removes a restriction. Anything significant would force secure context. What would be great is if we can put this in the JS spec so that implementors can sync if they so wish, and users can know which APIs fit this.
* JF: we’re not ready to express an opinion on this. I’d like non-browser people’s inputs.
* Brad: would say exception handling be under this?
* Luke: yes.
* Brad: feature detection?
* Luke: yes this would just work with feature detection.
* Brad: you don’t remove any API surface?
* Luke: no.
* Brad: fun tidbit, ad networks now use WebAssembly to detect real browsers versus low-capability bots.
* Luke: if our tools just hide constructors (e.g. the “try” opcode constructor) from the JS API spec, then it’s very simple to specify.
* Brad: I’ve spoken to folks at Google and we definitely haven’t reached consensus yet. Whatever we do, we’ll reach an independent consensus. Some folks are proponents of a similar direction, but we try to balance with what’s most useful for the web overall. We definitely want HTTPS everywhere. One caveat is if WebAssembly finds itself on common frameworks, then they’d have to use older toolchains because they can’t use e.g. exceptions. One of the things we’re trying to figure out is how localhost is treated.
* Ben Smith: how would we add this to the spec? What’s the status of addressing these types of limitations such as max sizes?
* JF: open action item to do so.
* JF: it would be nice if WebAssembly weren’t the first spec to ship this kind of feature behind secure context only. If other web specs did it first it would be easier for us to figure things out.
* Brad: this might propagate the life of asm.js.

*AI:* group, always discuss secure context for each new feature.

#### [Contribution policies and repos for tools targeting WebAssembly](https://github.com/WebAssembly/binaryen/issues/1358)

*Derek [presenting](https://docs.google.com/presentation/d/1sgxnT7pD5bTfmPv6MLnFlzIcszUDyTc9SKiSV6LZAJk/edit?usp=sharing)*

* Derek: Currently Binaryen and WABT require contributors to join CG and agree to its IP policy (in addition to Apache2), which is a hurdle for some contributors. Should we continue this? What are the alternatives?
* Derek: Other tools such as LLVM are in their own repo.
* Derek: The IP policy is a hurdle to contributing versus Apache2, because lawyers don’t know about it, it’s just different, and they have to do research versus just agreeing to Apache2. This adds contributor friction.
* Derek: Original intent was that any significant contribution to the spec needs to be protected by W3C IP agreement. Tools sometimes contribute new ideas to the spec. On the other hand, one could argue browser implementations are the same, and are in their own repo without this protection. We just make sure that bringing things to the spec is done by CG members. Also, as new tools get developed they probably won’t be under our repos and our W3C agreement.
* Derek: At the same time, our charter makes it clear that tools aren’t part of the CG / WG deliverables. Note that we didn’t have a charter when we initially decided to put the tools under the IP agreement.
* JF: if we make a decision I’d like to make it slowly so that it doesn't seem like we’ve snuck this in. I’d like to bring it up at the WG meeting (with W3C reps resent) and maybe in-person meeting, before making any decision binding.
* JF: I want to make sure we don’t overly privilege any tool by putting them under the WebAssembly organization. I’d be wary of accepting anything too, because then we’d have problems similar to npm’s where there are complex security issues to how things are managed. Maybe we can just grandfather some projects in, and not accept new ones, or move some out to individual orgs.
* Derek: practically speaking, we also grant privilege by having our engineers working on these tools. There’s some reliability and up-to-date-ness.

*AI:* Brad to put this on the WG agenda. JF to bring back results to next CG meeting.

#### [Combining Bulk Memory Operations and Conditional Segment Initialization proposals](https://github.com/WebAssembly/conditional-segment-initialization/issues/1)

*Ben Smith presenting*

We talked about this at the last meeting (splitting 3 proposals out of the threads proposal). Rossberg pointed out that these two are pretty similar and could be combined, instead of having two self-standing ones.

*POLL:* unanimous consent to do this merge.

####  Should the `spectest` module in the wasm testsuite be [implementable in wasm](https://github.com/WebAssembly/spec/issues/650)?

*Dan Gohman presenting*

Some of the tests import a module called `spectest` and import a function called `print` which is overloaded by the embedder. Each import re-imports it with a different signature, but that’s weird because WebAssembly itself doesn’t have overloading. That way you could implement the `spectest` module in WebAssembly. Same with kinds: a global and function could have the same name.

* Andreas: we could remove it from core tests, but we should still make sure that it validates.
* Luke: I like the principle of being able to implement standard library in WebAssembly.
* Andreas: I would propose removing the print function from the spec tests. We should use assertions instead. It’s no longer relevant. We’ll still test imports, but it doesn’t have to be print.

*POLL:* unanimous consent to remove polymorphic imports.

*AI:* Dan to update spec tests to not be polymorphic.

#### Rename memory operations

Rename to `mem.grow`, and `mem.size`. This would be a change to the text format, but compatible with binary otherwise. Should it be `mem` or `memory`? We’ve been inconsistent in naming. Would the section now be “mem” as well? JS API is a different topic.

*AI:* move forward, and discuss next meeting.

#### Future in-person meetings

*Out of time*
"
main/2021/CG-03-16.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 16th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: March 16th, 4pm-5pm UTC (March 16th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. [Relaxed SIMD](https://github.com/WebAssembly/design/issues/1401) and poll for phase 1 (Zhi An Ng) [10 min]
    1. [Propose to initiate phase 1 of stack switching proposal](https://docs.google.com/presentation/d/1teI1N282B7Dog314G22Emmaur2XCVtqYwwq5c_AK-BE/edit?usp=sharing) (Francis McCabe) [15 minutes]
    1. [Branch Hinting](https://github.com/WebAssembly/branch-hinting) - Poll for Phase 2 (Yuri Iozzelli) [5 min]
    1. Discussion on irreducible control flow ([slides](https://docs.google.com/presentation/d/1KE7z7ry3VEug3nyIvnLwTtxxPhkp73CrYjpATpnNSF8/edit?usp=sharing)) (see [[1]](https://github.com/WebAssembly/design/issues/796) and [[2]](https://github.com/WebAssembly/funclets/blob/master/proposals/funclets/Overview.md)) (Conrad Watt) [30 min]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

### Opening of the meeting

###  Introduction of attendees

Luke Imhoff

Mike Voronov

Chris Fallin

Derek Schuff

Francis McCabe

Arun Purushan

Paolo Severini

Zalim Bashorov

Daniel Hillerström

Jay Phelps

Jakob Kummerow

Nabeel Al-Shamma

Slava Kuzmich

Paulo Matos

Zhi An Ng

Thomas Lively

Yury Delendik

Yuri Iozzelli

Dan Gohman

Ben Titzer

Sergey Rubanov

Lars Hansen

Alex Crichton

Rick Battagline

Andrew Brown

Pat

Conrad Watt

Mingqiu Sun

Ryan Hunt

Dan

Paul Dworzanski

Alon Zakai

Manos Koukoutos

Asumu Takikawa

Sam Lindley

Ioanna Dimitriou

Nicholas

Emanuel Ziegler

Paolo Matos

Shravan Narayan

Pretnar, Matija

Flaki

Rich Winterton

Ross Tate

Gen Ashley

Sean Jensen-Grey

Adam Klein

Heejin Ahn

Sam Clegg

jlbirch

Sean Jensen-Grey

Jacob Mischka

### Find volunteers for note taking (acting chair to volunteer)

### Proposals and discussions

#### [Relaxed SIMD](https://github.com/WebAssembly/design/issues/1401) and poll for phase 1 (Zhi An Ng)

<ZN Presenting [slides](https://docs.google.com/presentation/d/1Qnx0nbNTRYhMONLuKyygEduCXNOv3xtWODfXfYokx1Y/edit?usp=sharing)>

CW: For the question of you want to have instructions that are underspecified, do you need more granularity than one instance, or one bundle of consistent execution. ‘Fpenc’ seems much more granular

ZN: Should this be a goal of the proposal? On the web I don’t see it being particularly effective. In other environments, I see this being useful so we can pass this around. I don’t know, needs more discussion about what the scope of the proposal will be

<From chat>

DanG: Will this mean there will be unsafe/fast/relaxed variants of existing instructions?

BT What do you mean by unsafe?

DanG: gcc -ffast-math unsafe on one side. On another, allowing more implementation specific behavior that pushes quirks up to the end user

ZN: We have a couple of instructions in mind, we won’t have unsafe versions for everything, will be tackling one at a time. If you have a tool chain using the  -ffast-math flag, it’s basically adding support for new instructions, i.e. combining with fast math we will be able to use new instructions

FM: I thought that one of the reasons we wanted determinism was for security and anti-fingerprinting?

ZN: yes this is something we have to bring up early enough in the process (e.g. TAG) to look at the privacy and security implications. The existing SIMD has some finger printing concerns but during the review it was found that it doesn’t reveal any new bits. You can also determine some hw specification based on whether SIMD is supported.
But in general we’ll try to bring it up as early in the process as possible.

DanG: Worth mentioning the reciprocal instructions will expose more information

ZN: yes, those are among the hardest to specify

DG: we’re over time we should move forward. Should we do that poll?

**POLL: Relaxed SIMD to phase 1**

|SF|F|N|A|SA|
|--|-|-|-|--|
|11|18|7|0|0|


####  [Branch Hinting](https://github.com/WebAssembly/branch-hinting) - Poll for Phase 2 (Yuri Iozzelli) [5 min]

YI: Last time we didn’t have time for a poll and there were a couple of issues.
<presenting>

CW: do we have someone willing to implement a prototype lined up?

YI: I didn’t file the patch yet, it’s in a good shape, can have that ready in a couple weeks, don’t know about engines. Not sure how to implement in the reference interpreter, what would it do? 

CW: in terms of the process, the reference interpreter wouldn’t be a priority, but a real implementation would be much more important since the point is to see if we get performance improvements

<YI Agrees> 

NA: The 0 byte for extensibility is in the table? 

YI: yes. for every function there’s a vector of instruction hints. 

DG: we need to move on, if there are objections to the poll we should bump to the next meeting. Do we have any?
<none>
OK. so the poll is to move 

**POLL: Branch hinting proposal to phase 2**

|SF|F|N|A|SA|
|--|-|-|-|--|
|1|17|19|0|0|


#### [Propose to initiate phase 1 of stack switching proposal](https://docs.google.com/presentation/d/1teI1N282B7Dog314G22Emmaur2XCVtqYwwq5c_AK-BE/edit?usp=sharing) (Francis McCabe) [15 minutes]

<FM presenting>

HA: There have been multiple versions of the proposal, which one are you proposing?

FM: There will be.. I have avoided talking about that - the final proposal will not look like anything we’ve done so far. 

HA: Moving to phase 1 for candidate proposal? 

FM: at this point i want to focus on the requirements and not on the answer.

RT: at this point from phase  0 to 1 we want to recognize that it’s a problem we want to solve.

SL: At a high level there’s interest in solving the problem

DG: getting to the end of the time allotment. we’re indicating interest, and phase 1 will move forward with an overview doc, etc.
We’ll do unanimous consent, I haven’t heard any real objections or concerns

**Poll: Any objections to stack switching moving to phase 1?**

None heard and none in the chat.

[Chat]

BT: Does hardware CFI basically preclude moving executable stacks?

RT: it does not appear so yet, but it's still being investigated

BT: My recollection of the arm proposal is that it is based on signing ret addresses with stack addresses


#### Discussion on irreducible control flow (see [[1]](https://github.com/WebAssembly/design/issues/796) and [[2]](https://github.com/WebAssembly/funclets/blob/master/proposals/funclets/Overview.md)) (Conrad Watt) [30 min]

<CW presenting [slides](https://docs.google.com/presentation/d/1KE7z7ry3VEug3nyIvnLwTtxxPhkp73CrYjpATpnNSF8/edit?usp=sharing)>

AZ: I can give 2 quick comments: the term stackify isn’t really accurate (nor is the history). It’s a specific algorithm used in Cheerp. The algorithm there and in LLVM all do pretty much the same thing when they have structured code.

CW: The blog post by cheerp refers to llvm stackify, might need more standard terminology

BT: Probably the one opposed to this the most - multiloop construct looks good. Engines implementing unstructured control flow seems unlikely, they might opt out of it altogether

CW: if people have things they want to explore, we can carve out more time in the next meeting.

AZ: to see performance data on this, what would this actually allow us to make faster. 2 questions, how easy it makes for producers to produce code, and how much faster vm run. Big question for me is does this make vm run faster and by how much?

CW: I don’t have data, the kind of program you would be looking for is when passed through stackify it needs a lot of indirections, It’s possible to construct a program that would do this but I don’t have any information on how many programs there are in the wild, and this I’d really like to collect more data

RT: another nuance: I’ve been talking with Luke and Francis about Interface Types, we’ve been trying to ensure that the fusion algorithm can efficiently create a CFG, but it might end up not always being semi-structured. So it might end up pushing some problems down to the engine side in that case.

CW: there might be another feature in flight that punts cfg out of semi-structured territory

FM: it’s a little early, very possible that this could end up being an issue for fused adapters

RT: something I've been wondering, you mentioned in your talk that the big blocker is the optimizing compilers. Certainly that’s the case for JS where you need heavy optimization to get good performance. Wasm itself in theory isn’t supposed to need such heavily optimizing compilers to get good performance. Do we know how much difference that makes in practice?

BT: good rule of thumb is that baseline tiers are 1.5x to 2x slower than optimizing tiers

<chat>

PM: Is there any writeup on multiloop outside this presentation?

CW: it’s scattered across individual comments on github. The idea is really more due to Andreas. I’ll be happy to writ something up

RT: it'd be useful to have more insight into why the baseline vs optimizing compiler performance differs

BT: Primarily register allocation

### Closure
"
simd/2022/SIMD-07-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 8th video call of WebAssembly's SIMD Subgroup

-   **Dates**: 2022-07-08
-   **Times**:
    -   4pm-5pm UTC (9am-10am PDT)
-   **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this
[form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1.  Opening, welcome and roll call
    1.  Opening of the meeting
    1.  Introduction of attendees
1.  Find volunteers for note taking
1.  Adoption of the agenda
1.  Proposals and discussions
    1.  Relaxed BFloat16 Dot Product (Marat Dukhan)
1.  Closure

## Meeting notes

### Attendees

- Andrew Brown
- Anton Kirilov
- Evan Nemerson
- Illya Rezvov
- Johnnie Birch
- Justin M
- Marat Dukhan
- Petr Penzin
- Richard Winterton
- Thomas Lively
- Yury Delendik
- Zhi An Ng

### Relaxed BFloat16 Dot Product (Marat Dukhan)

https://github.com/WebAssembly/relaxed-simd/issues/77

MD: newer arm and intel CPUs have bfloat 16 support, however differences in implementation, moreover ARM has differences in ARM v8.6 and ARM v9.2, up to 2x speed up on CPUs that support this.

PP: newer CPUs that support this, thats AVX 512 extension, pretty rare

MD: not common so far, but those CPUs are on the market

RW: future will have it

PP: bfloat 16 is useful exclusively in ML operation, not something for general purpose, because it lacks floating point numbers. we don't have a bfloat16 type to begin with, not sure if we should be adding something that we don't have

MD: we don't need new instructions to support bfloat16 type, it's just high 16 bits of float32, can work with it using current instructions, even without Wasm SIMD

PP: accelerators would actually manipulate it directly

MD: that's why i'm proposing this, when hardware supports this can be efficient

PP: it's not completely free right?

MD: pretty much the same way you do it in software, each 32 bit lane will have 2 packed bfloat16, extract each of them into two multiply adds

RW: how does lowering know it's a bfloat 16

MD: lowering reads them as 2 16 bit ints, pad with 0 in low bits, then uses floating point multipliers

RW: treated as 16 bit integers, how do you know bfloat 16

MD: add special instructions to process a dot product by prepadding bfloat16 with 0s in low 16 bits

ZA: why not add in the future, when more machines in the world support it

MD: don’t want to create a new proposal for this instruction

PP: some existing SIMD operations can be implemented with AVX 512, AVX 512 is so rare in client hardware that implementations like V8 don't care about it. Second point is that we have existing holes in proposals, e.g. missing extend for x86, we have 8 -> 16, 16 -> 32, but not 8 -> 32, x86 supports, cheap to emulate in ARM. We have to file a new proposal for this.

MD: the issue with extend is that ARM lowering is not optimal, not any better than current lowering. With bfloat16, emulation is expensive.

PP: doesn't negate what was said about AVX512, from V8 POV, AVX512 is not feasible.

MD: can't speak for V8, but AFAIU, AVX512 will get popular enough that V8 will care about it, or intel will backport to AVX2, like VNNI, there will be a version for consumer CPUs

RW: there will be a set of instructions that will support AVX 512, back ports

AB: having seen bfloat16 improvements in performance that people have presented, i'm in favour of this type of thing, that's a way of speeding up inference and training. less worried about current support of AVX 512, petr brought up correctly that client machines don't have it, on server side it is supported by currently shipped chips, and also in the future, and possibly supported in client. less concerned that it currently isn't widespread

ZA: Is this one bfloat16 instruction enough? Is it sufficient to speed up core computations, or would we need more instructions?

MD: this single instruction is sufficient, principalling we need 3 primitives, extension from bfloat16 to 32, easy toe mulate with Wasm SIMD, fp32 to bfloat16, not worth adding to Wasm SIMD, can truncate, in most use case, most computations in fp32, only bfloat16 for storage, we need an instruction for FMA, which is this dot product.

RW: adding this into relaxed SIMD now wouldn't inhibit us from moving this into a non-relaxed version, you can implement it otherwise.

MD: to have it as a regular instruction, has to be bitwise compatible between architectures

RW: that's what you will have to do if you want to migrate that to SIMD

MD: don't see that it's possible as a non-relaxed instruction, it would have to be emulated, not using hardware instructions

RW: if there is a 5 year window that we see it is worth emulating, then it could be

MD: yes, if we look at the spec, latest version on ARM is not x86. current hardware instructions don't provide it. on x86, instructions treat denormals as 0, regardless of global settings, on ARM, compute dot product as fused operations without intermediate rounding in 9.2, then addition with rounding.

RW: so you think going forward there will not be support

MD: will have to see, currently is not identical

AB: MD, confirming what you’ve said - when we have a bfloat 16, we need conversion to and fro 32, we will just take 16 bits, thats equivalent to rounding towards 0, and that's fine for these use cases?

MD: fine if you don't do it very often, for neural network, we do it at the boundaries

AB: this point about rounding and conversion to and from fp32, should document in the issue, in the future, we might get questions why we don't implement the conversion instructions

RW: we can add in conversion instructions in the future

MD: conversion instructions are hard to emulate without hardware support

PP: what's the difference between adding conversion ops and not adding?

MD: there are libraries doing this truncation, haven't heard issues about accuracy, when using bfloat16 you already lose a lot of accuracy. Should be addressed with IEEE fp16 conversion in the future. Think Wasm will eventually need to fill this gap. That's completely outside of relaxed SIMD. That can be done bit-exact.

ZA: anyone wants to raise a point against this instruction

PP: from engine, AVX 512 is not supported

AB: what engines

PP: V8, no AVX 512 support

YD: no plan to support AVX 512 any time soon

AB: maybe we should get an implementability comment from the main engines, is this something we actually want

ZA: have implementers comment about support for AVX 512 and ARM v8.6 with bf16 extension

AB: for ARM we have CPUID check

PP: no EVEX in V8

MD: amd is about to start flooding market with ZEN 4, which will have AVX 512 bf 16, probably consumer variants

PP: rumor is that they will come up with AVX 512, will every single consumer chip have it? it's a relatively rare instruction set

YD: not just CPUID, also fingerprinting question, better to see fallback implementation for no AVX512, to see how deterministic they are. Otherwise it will be easy to detect what CPU it is.

AB: opening the can of worms this has opened, by running a combination of the other instructions, one can figure out

YD: in this case, if we don't document fallback, every engine will choose their own implementation

PP: right now we can distinguish x86 and ARM easily, will also allow us to distinguish different kind of chips, does NEON have bfloat16

MD: on arm, can implement this in a way that doesn't expose information, slightly less efficient, need 2 native instructions instead of 1

ZA: We need comments from engine teams on viability of native lowering on the issue. Yury if you can comment there and I’ll ask Deepti to comment as well.

AK: looking at issue, about emulating with 2 native instruction, don't understand, looks like both sides use bf16

MD: can get bitwise identical result with and without bf16 extension

AK: can measure performance right?

MD: yes, that's always possible

AK: on ARM, 2 generations of client cores that support, current server has (AWS graviton 3)

MD: cpus on market that we can buy today, chip in Galaxy S22 seems to support it

AK: soc vendors disable some extensions for reasons, some SOC include necessary support, graviton 3 definitely support bf16

MD: bfloat 16 supported in US galaxy S22

AK: no physical phone to check, going by CPU core documentation

JB: quick question on fingerprinting, is it primarily on the client or server side?

PP: more on client, server side you likely already know what is the server, on client it's wild code running on your device

RW: probably steer clear of that and let security team deal with that
"
wasi/2024/WASI-05-30.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: May 30 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: May 30 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. Yosh Wuyts: `@since` and `@feature` gates have landed on the Component Model ([link](https://github.com/WebAssembly/component-model/pull/332))
1. Proposals and discussions
    1. Yosh Wuyts: Leveraging the `@since` and `@feature` gates in WASI
    1. Yosh Wuyts: Extending `wasi:clocks` with `timezone` support

## Notes
### Attendees

- Bailey Hayes
- Colin Murphy
- Yosh Wuyts
- Nick Fitzgerald
- David Bryant
- Oscar Spencer
- Pat Hickey
- Marcin Kolny
- Hung-Ying Tai
- Sean Isom
- Sergey Rubanov
- Syrus Akbary
- Yong He
- Dan Gohman
- Jeff Charles
- Trevor Elliott
- Mingqiu Sun
- Merlijn Sebrechts
- Zalim Bashorov
- Wouter Hennen
- Robin Brown
- Stephen Berard
- Andrew Brown
- Mike Warres
- Chris Woods
- Yage Hu

## Leveraging the @since and @feature gates in WASI
[Presentation](https://github.com/WebAssembly/meetings/blob/main/wasi/2024/presentations/2024-05-30-yosh-wuyts-leveraging-since-unstable-gates-in-wasi.pdf)

**Yosh Wuyts**: Hello, I’m Yosh, I work at microsoft.

**Yosh Wuyts**: @since and @feature gates have landed on the Component Model [https://github.com/WebAssembly/component-model/pull/332](https://github.com/WebAssembly/component-model/pull/332)

**Yosh Wuyts**: I have prepared a little presentation for this that’s really two presentations in a trenchcoat.  

**Yosh Wuyts**: First I want to talk first about the mechanics of @since and @unstable and check in, then talk about how it applies to WASI itself. The question is how do we keep evolving WASI between major (breaking) versions. We already know many things we want to ship - changes to wit documentation, bug fixes, in-progress worlds we want to add, and evolving existing worlds/proposals. One example is we want to add timezone support to WASI clocks. We took that support out right before shipping 0.2.0, but we want to ship it in a future version.

**Yosh** First we are worrying about making it mechanically possible to extend existing wit documents. We want to do that without making complete copies of the spec for each separate version, so that we have a single document for the spec. 

**Yosh ** [webassembly/component-model#332](https://github.com/WebAssembly/component-model/pull/332) is the PR for this feature to wit. <shows an example>.
**Yosh ** The expected workflow, we start extending an existing document with an unstable feature-gate. Once we feel confident something should be stable, we change the @unstable to a @since, and give it a version, and the feature name can remain if we want. And at some point we could choose to remove the feature from the since gate.

**Yosh** importantly, @since and @unstable do not have any runtime semantics of components. You can think of them as a compile time macro only. Here’s an example where our tool has a spec that is at version 1.1.0, but your tool could choose that it’s only ready to implement version 1.0.0, so by evaluating these since annotations it can interpret the spec as it existed at 1.0.0. Or when you are ready to upgrade here’s the spec as it exists at 1.1.0. We think this is a much better alternative to git history.

**Robin** Is there a tool somewhere that takes this wit and filters it down to what the document was at some version?

**Yosh** We have an implementation in wasm-tools but I don’t know if it specifically supports that translation. Maybe Alex can give a better answer.

**Zalim, and andrew brown, and colin** Are you going to add @deprecated, to subtract something from an interface

**Yosh** @deprecated is not part of this proposal. For example we had a bug in wasi-http where we accidentally used the wrong term for a variant name, and we wish we could change it. So maybe that’s a motivating reason to pursue @deprecated in the future. But right now that’s not in scope. We can tackle adding @deprecated later.

**Yosh** these are the first attributes we have added to the wit language, so we had to define the mechanism to do that. Now we have a mechanism to add more attributes when we need to.

**Robin** what about the translation of wit to a binary, and back to wit - does that preserve this information? There are flows like registries where we store the binary encoding of the wit.

**Yosh** the components themselves do not encode the gates, the gates are compile tools only.

**Luke** I think this may work like documentation - we will need to encode it in a custom section in the component, so it can be put back in later.

**Syrus** features with dependencies can get convoluted. Do you have examples of how features work with interfaces and dependencies?

**Yosh** In the next section I will cover more of that. In general the gates can be applied to any item, just not fields of records or variants. I have an example of how this will work in the next part of my presentation.

**Yosh** Let’s talk about applying it to the WASI specs. Here is WASI clocks as it exists today at 0.2.0. We would like to add a timezone interface, which looks like this - two functions and a record. Pretty minimal additive change.

**Yosh** The process defined in [webassembly/wasi#605](https://github.com/WebAssembly/wasi/pull/605) says that extensions/additions need to independently advance through the phase process, starting with Phase 0. I filed a PR yesterday that says here’s the clocks timezone proposal starting at Phase 0, to start that process. So, here are the gates I’m adding to the wit that says unstable for feature clocks-timezone. We can bikeshed the exact name elsewhere. So here’s the model of how when the phase advances, they can be released in 0.2.1 by changing the unstable to a since.

**Yosh** Right now nothing in the WASI specs is documented with what version it was introduced, it’s just all at 0.2.0. So right now we are considering what forward compatibility will look like. We could tag (for example) wasi-random with @since(version = 0.2.0). Then if we update wasi-random package to 0.3.0 as part of a future release, we can leave those since tags in and tools now know that any wasi-random that was compiled for old (0.2.0) versions will work directly on the new 0.3.0 interface. So this is a documentation of forward compatibility.

**Yosh** Here is a case from [webassembly/wasi-http#115](https://github.com/WebAssembly/wasi-http/pull/115). We are talking about how wasi-http defines a world which has an include wasi:clocks/imports@0.2.0. So what if we upgrade the package wasi:http@0.2.1. We could still include clocks at 0.2.0. Or we could now explicitly do an import of wasi:clocks/monotonic and wall clock at 0.2.1, so we are depending on the most recent version of those interfaces but not pulling in the new timezones interface, because maybe proxies shouldn’t have time zones.

**Syrus** what are the edge cases in this proposal, anything you haven’t covered here

**Yosh** Transient dependencies that you accidentally end up exporting more than you intend to, because the underlying clocks dependency changes and you end up re-exporting more, that can take people off guard so it’s something to think about. Robin also mentioned a good one about preserving this information in the binary encoding. So I’m presenting here so we help surface these things. I think the basic shape of this is OK but as we apply it we will learn more.

**Yosh** I added gates to literally everything in the entire WASI api and added gates for timezone and tried it with the tooling, and it all worked with the latest wasm-tools. Alex wrote a lot of tests inside wasm-tools as well.

**Syrus** Let’s say you have a function with a since gate on future version 0.2.1, and its using a new type that’s not available in 0.2.0 and is in the new version 0.2.1 spec, but only the function has the since gate, is the type suddenly available in 0.2.0.

**Yosh** You can add since gates on the types as well. You can add since gates to entire type definitions. You cannot add them to specific fields of records or variants of enums. We may pursue doing that in the future but we aren't yet.

**Syrus** capnproto has a good article on additive fields in interfaces. [https://capnproto.org/faq.html#how-do-i-make-a-field-optional](https://capnproto.org/faq.html#how-do-i-make-a-field-optional)

**Robin** Can we apply gates to interfaces?

**Yosh** Yes, every item is supported, everywhere you'd expect it to work it does work with the exception of fields and variants that I covered.


"
wasi/2021/WASI-10-21.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: October 21 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: October 21, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Walkthrough of converting a proposal to the new syntax (@sunfishcode, 15 min)
    1. Making it easier to draft WASI APIs, part 2 (@linclark, 20 min)
        - [Make the release process more modular](https://github.com/WebAssembly/WASI/issues/450)
        - [Simplify the main WASI repo](https://github.com/WebAssembly/WASI/pull/451)
        - [wasi-proposal-template](https://github.com/linclark/wasi-proposal-template)
    1. Continue from last meeting: Walk and talk through some example WASI component scenarios (@lukewagner, remainder of the time) ([slides](https://docs.google.com/presentation/d/11lY9GBghZJ5nCFrf4MKWVrecQude0xy_buE--tnO9kQ))

## Notes

### Attendees

- Lin Clark
- Bailey Hayes
- Jun Gan
- Shiqi Wang
- Jacob Gravelle
- Amanieu d’Antras
- Saúl Cabrera
- Steven Prine
- Pat Hickey
- Piotr Sikora
- Till Schneidereit
- Dan Gohman
- Vibhav Pant
- Yong He
- Luke Wagner
- Johnnie Birch
- Mingqiu Sun
- Peter Huene

### Walkthrough of converting a proposal to the new syntax

**Dan Gohman:** First proposal is clocks, very simple so wanted to convert for that purpose.

This is a conversation of original wasi-clocks that was based on the prev model, where you’d have a fork of the original WASI repo. One of the recommendations we’ve been hearing in WASI is that we don’t need a central repo. 

I think this will help a lot because the proposals are pretty cluttered. In this, we just have tests, the README that explains it, and spec. In this case, all the tooling is external.

Lin created a wasi-proposal-template that people can use to clone. This is an example, just filled in all the blanks. 

The Phase 4 criteria hasn’t actually yet been approved by this group. We expect that proposals will vary on portability needs. 

We have a brief intro, I didn’t put a ton of content here. We have goals. Very importantly, we have non-goals in here as well to be clear about scope. 

We have an API walk-through. We have a detailed design discussion, and stakeholder interest and feedback. I probably should say more here, but for now just showing the flavor. Acknowledgements also needs more work.

Most important part is the wai.md file. The markdown file is kind of an envelope format with the wai in code blocks. Three slashes is for documentation comments that autogenerate end user documentation.

Interesting question about how much detail WASI proposals should go into. At this time, wasi-clocks is depending a lot on additional external standards. If we need to go into additional detail, we can do that in markdown text under the code block. 

You’ll notice that you can also have markdown syntax in the code block. This would be rendered in end user tooling.

Any questions about the wai.md file?

**Lin Clark:** One thing we should clarify. Tossing around the name wai, that’s the new witx. Pat pointed out that we should rename it. It was wasm interface types extended, but now we’re just using interface types.

**Till Schneidereit:** Also we can expect to need to support both for a while, so the different names help differentiate.

**Vibhav Pant:** This kind of reminds me of Jupyter notebooks.

**Till Schneidereit:** I think that makes a lot of sense because one thing we’ve been talking about is besides the GitHub default rendering, having a different hosted site where you can post one of these URLs and it will show you the bindings for different languages, so you can actually look at this in the language of your choice.

**Dan Gohman:** One additional thing about how you use this file. This witx-bindgen tool (which we should rename) will be able to read this file directly. It will strip out the markdown parts and just extract the code blocks, concating together to create the actual bindings.

**Till Schneidereit:** We have a pull request open that strips the markdown.

**Dan Gohman:** wasi-random is another proposal in Phase 2. Same basic idea. I added more implementation details here.

Along with this, I’m developing a test harness.

**Vibhav Pant:** Is the idea that the harness is engine agnostic?

**Dan Gohman:** Yes, definitely the intention. Same command line arguments are already pretty common across different engines to run programs, so we’ll be able to plug them in.

**Vibhav Pant:** Will it be up to those engines to implement this harness?

**Dan Gohman:** There’s no fixed plan here. It seems to be the case that many current engines support the same arguments.

**Till Schneidereit:** As a matter of formalities, at some point it has to be up to engines to add their own support for this because it can’t be the responsibility of this group to do the work to support all of the engines.

**Dan Gohman:** Yeah, this is new territory. There’s a test harness in core. Every engine I’ve seen ends up building own test harness. We can do better than the core CG here because we’ll have more of a framework, but up to engines to work on their engine.

### Making it easier to draft WASI APIs, part 2

https://github.com/WebAssembly/WASI/issues/450
https://github.com/WebAssembly/WASI/pull/451
https://github.com/linclark/wasi-proposal-template

**Lin Clark:** We’ve been talking about how to make the process easier. Part of this is making releases more modular.

I put up an issue to [vote on next week](https://github.com/WebAssembly/WASI/issues/450). Instead of having a snapshot versioned by a single integer, we would version separately. This makes it possible to use semver.

I think these are separable questions—whether to split and whether to use semver.

Start with splitting. We’d add tools like GitHub actions to the template Dan just showed to make it easy to cut new releases. Any objections?

**Vibhav Pant:** Is there a chance this increases clunkiness?

**Lin Clark:** Do you mean for implementers?

**Vibhav Pant:** Potentially even for people using.

**Till Schneidereit:** I think it’s more of a toolchain concern.

**Vibhav Pant:** Yeah, I’ll need to come up with a more concrete example.

**Piotr Sikora:** Question—what happens with cross-component dependencies?

**Lin Clark:** We’d make it possible to specify the semver of what you’re depending on.

**Piotr Sikora:** What if you depend on one version of a component and have a transitive dependency on another version of it.

**Till Schneidereit:** Remains to be seen. Fully expect hosts will want to support both versions for backwards compat reasons anyway.

**Piotr Sikora:** While we’re on the topic, how do we expect version number to be exposed, because right now we use module names.

**Luke Wagner:** I like idea of putting version in module name string.

**Piotr Sikora:** Last question, right now we have a flat repo. Where would older versions be?

**Lin Clark:** This isn’t decided yet. I personally like using GitHub history for that, but others disagree. I should mention that this is open for discussion and should be what this group decides.

**Piotr Sikora:** As long as there is a convention that all the proposals follow.

**Lin Clark:** Next, using semver. We already got into this a little bit, but any concerns?

**Till Schneidereit:** I just want to flag what Sam Clegg brought up in the issue that patch versions aren’t a good fit.

**Lin Clark:** We actually could need patch versions. Came up in a discussion with someone. We’re going to be displaying comment text to end users. If a comment has something that’s unclear or a typo, that would be a patch.

So I think all levels in semver apply to us. We talked a lot about process for majors. You can see that [in my PR](https://github.com/linclark/WASI/blob/new-process/Proposals.md#versioning). Idea is that champions have a build a tool that implements old API in terms of new API. If they can’t, need to have a new name for the API.

**Till Schneidereit:** Idea is that implementers wouldn’t need to have two native implementations of the same API. They could use the virtualized version of the old API.

**Luke Wagner:** Might be a good reason to have all versions in GitHub directory structure. Then you could have a directory with old release plus tool.

**Lin Clark:** Will schedule a vote for next time.

### Continue from last meeting: Walk and talk through some example WASI component scenarios

**Luke Wagner:** ConditionallyNormalizingCache Rust impl [slide]

This is where I wanted to conditionally normalize to reduce cache hit ratio. 

Fifth component [slide ]

The next component I want to write is locking versions of all dependencies. 

ResolveConditionallyNormalizingCache.wasm [slide]
"
wasi/2022/WASI-05-19.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: May 19 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: May 19, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Toying around with wasi-sql (impromptu addition to fill time for tech difficulties) ([slides](presentations/2022-05-19-ricochet-wasi-sql.pdf))
    1. Vote on Native Threads API proposal
    2. _Sumbit a PR to add your agenda item here_

## Notes
### Attendees:

- Lin Clark
- Pat Hickey
- Till Schneidereit
- Kevin Moore
- Arne Vogel
- Jeff Charles
- Steven Prine
- Shiyu Yuan
- Sergey Rubanov
- Yong He
- Mingqiu Sun
- George Kulakowski
- Andrew Brown
- Piotr Sikora
- Isabella Tromba
- Chris Suszynski
- Jonnie Birch
- Petr Penzin
- Bailey Hayes
- Jiaxiao Zhou
- Dan Gohman
- Erico Galli
- Krisztian Gacsal
- David Justice
- Dan Chiarlone
- Alexandru Ene
- Aaron Schlesinger

### Toying around with wasi-sql (impromptu addition to fill time for tech difficulties)

**Bailey Hayes:** Toying around at KubeCon. Name up for discussion. Go might look like this, Ts might look like this. Question is: How would we convert this to something that is portable. A lot of ways that we might be able to do this. Back to Go example, Go has a database API. That’s what this one is coded to. There would be some downsides to creating the amount of APIs you would need. ALso contrary to other idaes liek wasi-data. What would it look like for minimal amount of work but that’s still portable. 

A component imports wasi-sql and specifies what driver it uses. Benefit here is that we get out of the business of defining what they can do. The driver could attach to drivers for MySQL or Posgres. Could have modules in the browser that could run against indexDB, or against an HTTP endpoint. If they are running on socket-enabled platfgorm, that would be bound.

This isn’t quite ready yet, this is just something I’m toying with. Love to hear opinions. Don’t really love the idea that you have to specify your own SQL dialect. Want to have computational DAGs. That’s where we’d get most extensibility. High-level goal is for interop.

**Lin Clark:** Thank you for sharing,

**Jiaxiao Zhou:** Is this in Wasm

**Bailey Hayes:** This would be WASI. I expect that this would only be used with module linking. I don’t know the exact syntax of the component model. That’s why it’s just sketched out now. Goal would be for it to be defined by wit.

**Petr Penzin:** I think this would be an API for accessing SQL. 

**Bailey Hayes:** Yes, possible that it could be that query could fall back to grpc.

**Jiaxiao Zhou:** Could you please elaborate on SQL syntax. 

**Bailey Hayes:** So I expect you to have a string that is defined in wit as a query string. I think wasi-query is maybe a better name.

**Kevin Moore:** My understanding is that WASI stuff is that it covers sys level stuff

**Lin Clark:** Yes, it has evolved since then for other APIs useful for portability

**Bailey Hayes:** This was created in response to someone doing string interpolation

**Jiaxiao Zhou:** Is this public on Internet?

**Bailey Hayes:** I’ve cloned template but will put it up. One Problem is if you have to register drivers. 

**Chris Suszynski:** Could you show once again what function call returns?

**Bailey Hayes:** Typical query returns a result, which would be a stream. Because we know what the schema is, we can return something that is its own struct type. It would have bool, string, etc. That would mean that we could have strong types across the stack, great for optimization

**Bailey Hayes:** To be clear, this sketch mostly came from Luke. Lin, we can move forward next meeting?

### Poll for wasi-native-threads
**Alexandru Ene:** I did a presentation last time. Main idea would be to add native threads to Wasm. There’s a couple of tricky design choices, but we could proceed with cloning module instance when we create new thread and take the hit for mem consumption. I had a chat with the people who work on adding a new instruction and qualifier based on the weakening wasm paper. It’s quite likely that this would be forward-compat. If wasm adds an attr, they have to define what happens when module doesn’t have that attr. That’s one tricky design choice. Another is that first proposal would only have spawn, quite similar to pthread create. There would be quite a bit of interest in having special functions for join, detach, cancel because it would simplify life of implementers. So far pthread create is only there because join could be wasm atomics. I haven’t fully fleshed out, I don’t know for this phase if it’s necessary. I have todos in there for what we want to support, and todo for whether it’s one function or more. 

**Lin Clark:** Good question. Not necessary for this phase.

**Alexandru Ene:** The tricky design choice would not change the API. It might change some behavior if wasm standard evolves in a way that is incompoatible.

**Dan Gohman:** As I was researching, browser case, new worker has to return to event loop before create new worker. We may need to change API for browser.

**Petr Penzin:** So if there was no join, that’s not a problem.

**Dan Gohman:** Mutex wait 

**Petr Penzin:** Mutex wait is out of scope

**Dan Gohman:** But it wouldn’t work. Need to figure out if we would change the design for the browser case.

**Alexandru Ene:** Some ideas around polyfilling. Might be a case where it isn’t compat with the browser. I don’t know if we can do that. Emscripten can do that right?

**Dan Gohman:** Can create pool up front. Can proxy to a worker instead of main thread. In EM, the way that works is that JS does a bunch of work, and we’d need to discuss API

**Petr Penzin:** I think we were talking about doing it the emscripten way

**Dan Gohman:** What I’m saying is that it wouldn’t be possible to have a library polyfill. You could do an Asyncify rewrite.

**Petr Penzin:** I don’t think this is what you meant by polyfill. It exists with all the limitations right now. I don’t think we want it to solve the problem of the main thread cannot be blocked

**Dan Gohman:** I’m responding to a goal in there. It seems like it isn’t enough 

**Alexandru Ene:** I can adjust it to say that it will work

**Dan Gohman:** But what will work

**Alexandru Ene:** Today we can solve it by creating the threads up front and dispatching work. That bit would stay the same. 

**Dan Gohman:** Ok, so you’d plan to polyfill with up front pool.

**Alexandru Ene:** Yes, and I can adjust the text to say that more clearly.

**Andrew Brown:** I think that what this clarified for me is that it is a goal to polyfill for browsers. There must be a solution for this to get to later.

**Alexandru Ene:** Is that correct? Do these have to work across browsers

**Dan Gohman:** We’ve been saying that every API defines its own requirements. It’s desirable

**Lin Clark:** And that’s before Phase 2

**Till Schneidereit:** We want as many wasi APIs as possible to be virtualizable. That’s clearly not possible for multi-threading

**Alexandru Ene:** It would be more compat once we have shared attrs on globals. It gets closer to outside browser scenario.

**Till Schneidereit:** What I guess is different is that it’s fundamentally about sharing memory. Normally components have shared nothing linking between them. That’s very diff for this proposal. For most cases, the question of whether it can run in the browser is a different question. For most WASI APIs, the answer should be to run in browser—worst case having fully virtualized. We clearly can’t require full virtualizability here. But we shouldn’t go all the way to the other direction. We should have the host call for spawning a thread be implmentable in terms of web semantics.

**Alexandru Ene:** Is it sufficient to work with a thread pool? I guess we can figure that out later.

**Lin Clark:** Ok, ready to poll. This will be a consensus poll. Any objections? No? Great, we have a new WASI proposal!
"
wasi/2022/WASI-06-16.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: June 16 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: June 16, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Propose including WIT as a part of the WASI subgroup
    1. Component Model async proposal (part 2) (slides: [pdf](presentations/2022-06-16-luke-async.pdf), [live](https://docs.google.com/presentation/d/1MNVOZ8hdofO3tI0szg_i-Yoy0N2QPU2C--LzVuoGSlE))


## Notes

### Attendees
George Kulakowski
Bailey Hayes
Bálint Molnár
danbugs
Lin Clark
Saúl Cabrera
Luke Wagner
Mingqiu Sun
Aaron Schlesinger
Jeff Charles
Ilya Rezvov
Dan Gohman
Yong He
Kyle Brown
Jake Champion
Piotr Sikora
Francis McCabe
Dave Bakker
Joel Dice
Josh Triplett
Radu Matei
sbc
Patrick Hickey
Petr Penzin
jlbirch
Andrew Brown
David Yamnitsky
Krisztian Gacsal
Isabella Tromba
David Justice

### Propose including WIT as a part of the WASI subgroup

- **Bailey Hayes**
  - Singlestore (my employer) has shipped wasm to production!
  - thinking a lot about backwards compatibility because of that
  - as part of that thought process, we are considering the idea of the WIT IDL as part of the WASI subgroup
- **Lin Clark**
  - another potential home that I see is the component model
  - I definitely agree that it should be standardized, and I think that is uncontroversial
- **Bailey Hayes**
  - maybe thoughts about what we want to add could help inform that
  - we interface to databases a lot
  - one thing people want to do is express a lot of mathematical functions
  - want to have something like simd-backed wit interfaces to meet that use case
  - in a lot of ways that is not a systems-level interface but instead building blocks you need to build those interfaces
  - so in that sense, not about WASI-as-system interface, but it does feel like this is the right group to raise it with
- **Luke Wagner**
  - absolutely makes sense to standardize it
  - I’ve waffled on where to do so
  - component model feels like lower level syntax targeted by higher-level tools
  - that makes me think it should be a layer higher, where things that compile down to component model live
  - and maybe WASI is the layer higher
- **Francis McCabe**
  - I think the question of where it should go depends on how independent WIT is from everything else, and whether it is the original source of truth about a given interface or whether that is another IDL
- **Bailey Hayes**
  - I think that’s dependent on the component model
  - derived from a component - you could generate wit from a component
- **Luke Wagner**
  - true, but I could also go the other direction
  - so it may not be the case that there’s a single answer to the question of what the original source of truth is
- **Josh Triplett**
  - I wanted to second that I also desire to use interface types in production in the next 12 month timeframe, so I also want more stability and therefore standardization
  - to Luke’s point, I can understand both wanting the layering and the abstraction, and also the value of having the One True IDL
  - it would be nice if, from my rust perspective, we could point to only one IDL that covers all layers of functionality
- **Petr Penzin**
  - wit doesn’t support everything
  - if you are targeting cloud and everything is already (de)serialized
  - but certain things like funcrefs aren’t supported in WIT (yet)
  - so for certain use cases WIT doesn’t support it
- **Josh Triplett**
  - I am very much hoping that is a “yet” and that that will be supported in the future
- **Luke Wagner**
  - a very big point to solve in the design space is closures across boundaries, so we have cycles
  - browsers cycle collect but control lots of code on either side of the boundary
  - we have different parts of the answer
  - async is one part, by providing another solution rather than passing callback closures around
  - but the case of passing funcrefs and pointers, the shared memory multithreading scenario
  - one way we’ve thought about that, that isn’t in WIT yet, is to describe in WIT the imports of a module, and instantiate that module with my own memory, and have control over the memory sharing
  - I do hope that this feels like the very advanced case and is often not needed
- **Petr Penzin**
  - I don’t think we have to get too deep into this since it’s not directly the topic
  - I want to highlight that WASM pointers are technically different from C pointers
- **Francis McCabe**
  - I’m not sure I see what function pointers have to do with where WIT is standardized
  - when we were working on interface types, we did have a strategy
  - long story short, we found it better to not have them at all at this point in time
  - this discussion does expose some confusion about where WIT should live
  - I personally think it is better as part of the component model due to all the entanglement with component model design choices
- **Lin Clark**
  - not sure we will get to resolution in this meeting
  - consider: we could reflect on this and re-raise the topic in a future meeting
  - let’s do it

### Component Model async proposal (part 2)

**Luke Wagner** presenting

- optimization: streams
  - an optimized version of something you could (almost!) express anyway
  - futures-that-maybe-return-more-futures not quite fast enough
  - bytestream could be optimized to be faster
    - bulk copies
    - directly copied
  - but want types too
  - also want to plug in to backpressure
  - and languages/ecosystems increasingly have similar abstractions, and want to keep those idioms
  - so: stream<T>
  - worked example of compilation of gzipping a stream, how it lowers to the canonical abi, and how it optimizes compared to the non-stream equivalent

- **Petr Penzin**
  - how’s it work in the browser case?
- **Luke Wagner**
  - bundling the runtime which exposes this “syscall” like interface
  - so in JS, this gets into the native JS api for streams
- **Petr Penzin**
  - reason I’m asking is about the callback-based JS async api
- **Luke Wagner**
  - but moving to promises
  
- optimization: splicing and skipping streams
  - canonical ABI operations to splice and forward and skip in bulk
  
- **Josh Triplett**
  - what about a stream of variably-sized objects. say, strings
- **Luke Wagner**
  - builds on what’s already in the canonical abi, which places things in separate allocations
- **Josh Triplett**
  - my question was about validity, so the pointers have to remain valid until you get the complete event

- state machine
  - outline of all the states and transitions a stream object can be in
  - leads us to want to generalize to Tasks
- a task is a stateful resource representing an asynchronous computation
  - producer state
    - like the stream state
  - consumer state
    - listening or not listening
  - write/return/listen
    - look at both states to enable things like eager return
- now we can start working towards structured concurrency
  - tasks form a task tree
  - using the supertask and subtask terminology
    - to avoid parent/child which language is already used by instance relationships
  - unique ownership because the graph is a tree
    - but subtasks can be transferred to new supertasks
  - host-implemented tasks
    - a single root
    - can have host leaf tasks
- canonical abi repr of tasks
  - task table
  - subtask table
    - track edges
  - both tables instance-wide
- structured concurrency
  - task tree is effectively the “async version” of a sync callstack
  - add invariants
    - subtasks can’t outlive their supertasks
      - … although they can be moved
      - get nice things like debugging/tracing help
  - how does a task finish?
    - canon finish
  - how is a subtask deallocated?
    - canon drop

- **Petr Penzin**
  - where is all of this implemented? who manages the per-task state machine?
- **Luke Wagner**
  - the runtime
- **Petr Penzin**
  - does this become part of core wasm?
- **Luke Wagner**
  - one viewpoint, the core module imports the canonical abi, that’s it
  - more interesting thinking about linking multiple modules
  - trampolines between modules
  - those trampolines can manage the task records
"
simd/2021/SIMD-08-06.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 6th video call of WebAssembly's SIMD Subgroup

- **Dates**: 2021-08-06
- **Times**:
    - 4pm-5pm UTC (9am-10am PDT)
- **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this [form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking
1. Adoption of the agenda
1. Proposals and discussions
    1. WASPR (Evan Nemerson)
    1. AES
    1. SIMD ship status in browsers
    1. SIMD instructions with multiple return values
1. Closure

## Meeting notes

### Attendees

- Andrew Brown
- Deepti Gandluri
- Evan Nemerson
- Jan Wassenberg
- Johnnie Birch
- Lars Hansen
- Marat Dukhan
- Sergey Rubanov
- Yury Delendik
- Zhi An Ng

### Waspr (Evan Nemerson)

https://nemequ.github.io/waspr/instructions

EN: From SIMDe, using LLVM MCA, parsed out

ZN: This linked anywhere? Emscripten or anywhere? We should put a note in emscripten - there is a table there that describes lowerings, but this could be useful too. Would you like to add it to the docs?

EN: Can figure out where it is

ZN: Can send you a pointer

AB: I can send you data as well

EN: If you send it in this format, I can integrate. Willing to figure it out

ZN: If you need a way to figure out how to get data from V8, file an issue and cc me, and I can help you as well

EN: Would like it to be automated

AB: It’s linux specific, if you’re fine with that then..

EN: I use linux.. Would like github actions to build the lowerings, some sort of issue during cross-compilation, would like to integrate that. The platform we generate the data on does not matter.


JW: Double to int conversions are very branchy.

EN: Will take a look at it, the big orange box has a warning about inaccurate instructions, there is a link that should take you to the implementation. I did the portable ones to start with, going on to add optimizations, but help is appreciated. Will get around to it eventually

JW: Branches come from scalar code, can share an implementation that might help.

MD: Lowering for ext-mul-high looks off on ARM, maybe LLVM bug?

EN: Have not added optimized implementations for this. These are the same issue that I added bugs on the issue tracker for the Wasm backend. (Check with Thomas)
This is especially the case if you disable the native implementations. IT would be great to improve the compiler to the point where it generates the same data.

MD: Tried in compiler explorer with the latet LLVM, seems to generate the right code

EN: Generated on clang11, but I’ll paste a link, there is a way - amalgamated headers for each architecture, easy to play with compiler architecture.

MD: Went back to clang11, and still generates the right code looks like a simde bug `extmul` instruction

EN: it’s the 8 -> 16 bit one?

MD: all ext except 32 -> 64.

MD: Using slightly different lowerings in V8, lower + shifts instead of two shifts.

ZN: It’ll be easy to do this when Andrew shares automated..

MD: Is there a way to see this for Firefox?

AB: More familiar with V8, but not sure how to do this in spidermonkey

LH: There’s a way to dump it from the engine in the log, or with JS - use it to verify disassembly.

ZN: If you want to check for the jit code, there’s an open bug for it, so reach out if you run into issues

AB: tried it in the past, and it looked ok. Is there anyway to get JitDebugInfo out from SpiderMonkey?

LH: print to stdout is the way, don’t mind adding stuff to the shell

AB: send me info on how to print to stdout?

EN: Just posted the link to the tool used for generating the code, we could coordinate on the issue tracker today.https://github.com/nemequ/wasm-simd-data

### AES

ZN: Nothing more on the agenda, should we discuss AES?

(ZN describes PR, summarizes replies)

JW: flexible vectors could be an option?


ZN: At this point it depends on whether they want to tie the advancement to flexible vectors, this independent of flexible vectors would be useful. Splitting from flexible vectors makes sense, and then PP can decide to include for the flexible vectors.

JW: useful op, whatever is quickest to standardize is best

MD: there are some users of Wasm who strongly prefer to have no non-det in it, it’s likely these uses will never ship relaxed simd proposal. Or ship it in a constrained way. So preferable to not bunder deterministic instructions into the same proposal.

AB: a bit of friction in creating a proposal and taking it to the CG, they brought it here because it was easier

MD: there is web crypto API, in JS, not Wasm. Designed with a single purpose of exposing crypto. Think there is not much benefit from exposing this in Wasm.

JW: I have seen use cases that would benefit from this - like a permutation or a hash, not a cipher.

LH: one thing to bring up to CG is to have a process to add simple instruction, not just SIMD, like byteswap. Should be simple and minimal friction, straightforward and has utility. Can there be a streamlined process?

DG: we’ve been trying to do more nominal changes, esp when it comes to Web API, or small spec changes, maybe we can do something of this sort for opcodes as well. I can add it to next CG agenda to discuss this.

ZN: Up to the person who brings it up to see how they’re willing to push forward with it.

### SIMD ship status in browsers

AB: Intel discussion about Safari support for Wasm SIMD, what their status is. What they feel about relaxed-simd and AES.

DG: Safari’s stance is usually they don’t comment on implementation until they ship. As part of Chromium shipping process, we have to collect Intents from other browsers. Safari is positive towards SIMD, doesn’t mean they will implement it soon. Relaxed-simd will be the same thing, if we find a good enough use case, don’t see them opposing it, but don’t see them rushing to implement.

AB: Wasm SIMD is in stage 5, so that means it’s done. Or they going to have a non-compliant browser for some time.

DG: not new for them, they dont have some proposals like bulk-memory. Different applications feature detect and ship different versions to different browsers.

AB: is there a place that tracks the status of these proposals?

ZN (chat): https://webassembly.org/roadmap/

MD: wasmtime and nodejs ship SIMD under experimental flags

DG: for nodejs, they have a much other version of V8, usually 2 or 3 versions, may just be turned on by default when they use V8 9.1, trailing versions. Same for other proposals

AB: for wasmtime, the latest release should have SIMD turned on by default

JB: talked about it yesterday meeting, ARM support didn’t make latests release, want to do more vetting/testing before it was turned on by default

AB: Maybe the next release? That’s possible.

SR (chat): BTW I believe Node 16 ships SIMD (with v8 9.1)

SR (chat): and Node 16.6.0 is on v8 9.2

ZN: I don’t know how this roadmap is generated.

DG: can just file an issue, Ingvar can take care of this

ZN: MD want to talk about denormalied fp numbers control?

MD: participants should read offline and use comments

### SIMD instructions with multiple return values

MD: one thing about SIMD 2.0, multiple return values?

DG: possible, we shipped multiple returns. We didn’t want dependency between ongoing proposals, think we can do this. Will need a champion, and scoping this proposal.

MD: original SIMD proposal is pretty complete, but one area we can improve is to handle multiple values at once, e.g. extend mul of 2 vectors, produce both high and low, can be more efficient than current. Separate low and high part.

ZN: If we have multiple returns, what does it look like in the intrinsic functions?

MD: Neon has additional data types, Wasm intrinsics could also have v128x2 values

LH: looked at this in add with carry out, it becomes hairy because Wasm is a stack machine, you always get one result underneath and the other on top, sometimes that is a wrong order, so you have variants of instruction that produces results in one order or the other, to avoid moves. It’s not completely straightforward

ZN: We don’t have a swap, if we have that instruction, but maybe we could make it better?

LH: Not sure, but we definitely would need some experimentation.
"
stack/2021/sg-3-8.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 8th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  March 8th, 17:00-18:00 UTC ( March 8th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants

- Francis McCabe
- Luke Wagner
- Sam Lindley
- Ross Tate
- Alon Zakai
- Lars Hansen
- Derek Schuff
- Thomas Lively
- Zhi An Ng
- Andreas Rossberg
- Rick Battagline
- Ioanna Dimitriou
- Luke Imohoff
- Ryan Hunt
- Thibaud Michaud
- Asumu Takikawa
- Daniel Hillerström
- Zalim Bashorov


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. Ensuring coherence with external async code
      1. JavaScript integration (Luke Wagner) ([slides](https://docs.google.com/presentation/d/1B0ib04vTEzdrtgrACwjo3Zj2LSwLSXHIKl_5rnLq-Ww))
      1. Erlang Promises (Luke Imhoff) ([slides](https://docs.google.com/presentation/d/1zueIL_COgMoNNjDEpBjVlyVv09_VHeNmyBj70Zrt-aw)) ([Lumen](https://github.com/lumen/lumen/tree/d494661ef54aee497622b08f3ebb935eddaf071c)) ([WASM Spawn-Chain Example](https://github.com/lumen/examples/tree/ae03d0742004fd9d3e8819a9809cdd028f1a988f/spawn-chain/wasm))
      1. Discussion
   1. Next meeting [2 mins].
1. Closure

## Meeting Notes

### Adoption of the agenda

### Discussion:

LW Presenting [Notes]

?? Confirms that JS engines will not want to allow JS off the main stack.

...

FM: What if Wasm calls a JS import, which calls a Wasm function?

LW: That is reasonable.

LH: We could also copy in and out of a possibly dedicated stack area to avoid switching stacks.

FM: Copying the stack will be incompatible with CFI.

LW/LH: We still want copying to be a feasible implementation strategy.

... Low level API 

AR: Is the JS suspendCaller the same as the suspend instruction?

LW: Semantically the same as throwing an exception up to JS-Wasm boundary, where a suspend occurs.

RT: But all the JS frames up to the next Wasm are lost.

LH: better name is throw to Wasm on suspend

LW: weird function, but is essential

RT: also you’re requiring the results of event line up with results of function, anyone who wants to be suspendable, it has to overlap two paths (return and suspend) and the signatures have to match. You can’t get an int from JS for example, unless you suspend an int.

LW: when JS want to suspend its Wasm caller. This is not happening n-deep. This is JS glue code that is specifically implementing async Wasm call.

RT: for most other settings, when you call into a function, which might suspend, the normal return type can be different from suspending type.

LW: Because JS is different and this is glue code, don’t think we need that flexibility. This is intrinsically tied to Wasm suspensions.

AR: Assumes immediate caller of yourself is Wasm

SL: will you show a high level example of handling await promise in Wasm?

LW: nope. I have a slide describing an interesting case where the low-level API can do but high-level API cannot.

... High level API

FM: What happens with re-entrant code?

LW: implied loop that happens that keeps calling the continuation, same way as original code did.

AZ: does this assume when Wasm call JS, that JS will return a promise.

LW: This WebAssembly.await takes a promise.

FM: looks like foreign frame scenario, capturing foreign frames. This would allow Wasm library to implement coroutining for JS. We can’t permit Wasm to surreptitiously implement.

AR: If I understood Luke correctly, you would have to do the capture manually rather than having it happen magically.

LW: you’re basically building up a whole chain of promises, propagating inner continuation to outer one

RT: all functions are async

AR: all have to aware of this pattern, and cooperate

LW: there is a higher-level ABI that they all have to follow. The JS in between has to know and follow continuation ABI

RT: sounds like Arjun’s stopify js to js compiler

SL: very similar to what we do in Links, treating JS as a target language rather than what you want to program by hand. Seems inevitable that if you want to support something like this you have to do something horrible. Aligns with what FM is saying, impossible to do it in a pretty way.

TL: AZ, we haven’t observed that interleaved frames have been very important

AZ: yea, not important, but doesn’t mean don’t exist

TL: worry for asyncify, even though not observed in practice, in principal, someone could write arbitrary JS code. We get a chance to process that in Emscripten, not sure if we can programmatically and generally transform that into this interleaving ABI.

RT: it’s a tool that does that, possible with restriction

TL: either way, not high priority for emscripten use case, not observed in practice

FM: i think we have to prevent it. We will not get past the TAG if Wasm allows JS to be coroutining, without the promise.

RT: it only works if all the code was already set up using async/await, not automatically making it coroutining. Coroutining JS can be hooked into this

LW: if JS is unaware, dynamic error

FM: for 4-tuple, what happens if JS returns a 4-tuple.

LW: The 4-tuple only pops out if you use callSuspendable. You know whether you have results based on whether you have the results field.

... End

RT: higher level API is similar to Alon’s previous proposal.

LW: I guess the difference is that I moved the suspend from inside Wasm to outside.

AZ: …

LW: …

AZ: Statically knowing the sites for asynchrony sounds fine, so I wouldn’t object to the medium or high level APIs.

AR: in JS you have to know, defining an async function there, seems similar

RT: LW and I talked about this, a component, make everything async without changing inside. Run it on a different host stack.

LW: The wasm.wat is a synchronous code.

ID: This needs to interface with the current EH proposal. Would that work as-is?

LW: seems like they would go well together. The EH proposal has been preemptively framed to compose well with events. Similar things in Wasm.event, exceptions will have a similar thing, if not exact.

ID: AR has something with delimited continuations with resume, is it similar to extension of EH with events.

LW: maybe not exactly that, but something like that is standardized for core wasm. This is what the JS API can do to account for that and do the suspending itself.

LI Presenting (TODO:slides)

TL: what do you do instead of using Wasm stack?

LI: only for Wasm target, we have a stack frame of (not wasm stack) what to call and args. We don’t know if we need to GC or run out of time. When you exit, scheduler tries to put it on the actual stack. The queue is the side data structure, not the actual Wasm stack, just a vec in Rust. That’s so we can yield partway through, we don’t have to ensure stuff is reentrant when we hit GC.

FM: Is this analogous to the cpp shadow stack?

LI: probably. The stack per process on Wasm is a single thing in memory called the heap, same as x86, stack and heap on opposite end towards each other, GC triggered when they collide.

FM: sounds like prolog.

LI: erlang was first implement in prolog, now it’s in C. Lumen is in rust.

SL: what about the GC.

LI: GC written in Rust. We couldn’t port the Beam code to Wasm, it does POSIX vm instructions, it uses 2 gigs of mem but doesn’t commit so it is fine. We use what BEAM calls supercarriers. Process only grows at certain intervals, more block-based. The tricks of page-marking and not allocating, we can’t use. It’s a copying-compacting collector. This is me doing by hand. With stack switching we hope that we don’t have to do the shadow. The way I did that was that everything is on shadow stack, it’s slower than it should be, but not terrible, 64k processes, not that bad compared to native speeds, but can be better.

RT: if you take the higher version of LW’s thing, stack per instance. You need more than 1 stack per instance, you can do something similar, everytime it yields, it gives you a stack, when you call async into Wasm, you can specify which of its stack to use, or use a new stack. Wasm module is a black box, but JS API gives you the structure.

LI: The way the x86 code is generated, there’s a check at every function to see whether the reduction limit has been reached. If the limit is reached, the process is swapped out, but the scheduler might swap it out anyway. The scheduler in WebAssembly needs to have multiple stacks and be able to switch between them itself. If this was driven from JS, we would only call one process per frame (60/s) this is too slow.

### Adjourn


"
main/2023/CG-11-07.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 7th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: November 7th, 5pm-6pm UTC (November 7th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Announcement: Updates to the consensus process document to include online meetings [PR](https://github.com/WebAssembly/meetings/pull/1418) [Deepti Gandluri, 5 mins]
    1. Memory control: Proposal update and Implementation report [Deepti Gandluri, Ryan Hunt, 40 mins]
    1. Freezable/Sealable GC values and globals proposal [Pierre Chambart, 15 mins]
        1. Poll for phase 1 
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
 - Deepti Gandluri
 - Thomas Lively
 - Alon Zakai
 - Andreas Rossberg
 - Andrew Brown
 - Ashley Nelson
 - Asumu Takikawa
 - Behnaz Pourmohseni
 - Ben Green
 - Ben Visness
 - Brendan Dahl
 - Chris Woods
 - Daniel Hillerström
 - Daniel Lehmann
 - Dennis
 - Emily Ruppel
 - Fedor Smirnov
 - Francis McCabe
 - Heejin Ahn
 - Ilya Rezvov
 - Jakob Kummerow
 - Jeff Charles
 - Justin Michaud
 - Keith Winstein
 - Léo Andrès (OCamlpro in the notes)
 - Luke Wagner
 - Manos Koukoutos
 - Michael Ficarra
 - Nick Fitzgerald
 - Nuno Pereira
 - Paolo Severini
 - Petr Penzin
 - Pierre Chambart (OCamlpro in the notes)
 - Ryan Hunt
 - Sam Clegg
 - Sean Jensen-Gray
 - Sergey Rubanov
 - Shoaib
 - Shravan Narayan
 - Slava Kuzmich
 - Talg
 - Yuri Iozzelli
 - Yury Delendik
 - Zalim Bashorov


### Proposals and discussions

### Memory control: Proposal update and Implementation report (Deepti Gandluri) [slides](https://docs.google.com/presentation/d/1ijomp-4avvgnLfWlcUg0e-1lWcGRu7vKkPcIBgzNr9s/edit?usp=sharing)

RH: From SM perspective, we’re open to prototyping with read-only memory and things like that. I think there are concerns about portability but if we could get something acceptable in performance in portability it would be really useful. Adding a memory type might be useful here because it might have different performance characteristics for portability.

DG: Thanks i do agree it will be useful to prototype just to get some data and then we can figure out how to move forward.

KW: Thanks for the proposal. Right now the spec prohibits any API from reducing the size of a memory but it would be nice if you were trying to map a file if the memory could be sized to the actual file you are mapping. I think it would take time to relax that in the threaded context.

DG: Gone back and forth on reducing the size of the memory but impl perspective V8 makes a lot of assumptions about not shrinking the memory and there are implications like how much memory we reserve upfront. Would be interesting to prototype but I want to be realistic about the security sensitive surface. Tried to poke at it but never successfully done it. Take it as a note and might be useful in the next section of this which is about the Impl on discord.

KW: No opinion on host imports but at a future stage it would be helpful if the imports API was not a web browser API and was done with a broad base of comfortability.

DG: I would imagine web engines would prototype and present the results of the implementation and if we decide to put it in the core spec and the wider ecosystem would benefit, it would be challenging to add to the core spec. We can walk back to the core spec after prototyping.

KW: Would be nice if a memory had a validation error if you wrote to the read-only memory.

DG: Thanks, will follow up offline.

AR: How do you spec this, would be difficult with the combination of threads. The memory model for this is nontrivial. Already the memory model is at the forefront of the current stage of research on memory. We pushed the boundaries of what was done before. I’m not entirely up to date with the literature but I think it’s outside what anyone has tried to specify so this will be challenging.

DG: I think that’s why what we’re trying to do is prototype in a tiny scaled way. Working thru the issues when threads is involved and took a break from it. But there is a lot of value in zero copy memory sharing. The goal is to just to iterate here to find the subset that is possible to implement, portable and performant. I don’t know what that subset is but I think it will be experimentation.

AR: I don’t want to discourage experimentation, very valuable, but just want to warn everyone that it might take quite some time to spec and figure this out. Might be as hard to figure out implementation issues. Doesn’t mean we shouldn’t ry, but worth noting.

DG: Appreciate the note. I don’t know if I grasp how hard but I know it will be hard.

PP: Something along these lines happened at the embedded presentation. There was something from Shin? that they were looking to get zero copy access. Think they also wanted universal pointers that would work across different memories. Just a reminder.

DG: Thanks

Chris Woods [from chat] Yup, overlap with the embedded world. Think this is an awesome idea. Would love to follow up with Deepti.

### Memory control: Proposal update and Implementation report (Ryan Hunt) [slides](https://docs.google.com/presentation/d/1TnEs6W3x5kVRgrtivat-fIyyBTevYoEPdErjwAFtvDg/edit#slide=id.g24db1a5543c_2_0)

Demo website (works in Firefox Nightly): https://bvisness.me/apps/discard/

AR: If I access it I don’t trap, it’s just 0? 

RH: It’s not that after you do this the pages are no longer accessible, it’s that if you access them again you will get zeroes.

AR: Is this an atomic operation? How does it interact with other threads? 

RH: Difficult because from a semantic perspective we want it to be equivalent to memory.fill which is not atomic but in terms of what the OS does, it’s fuzzy and I’m not an expert of that. Definitely not atomic of the whole range because that doesn’t seem possible.

OCamlPro [via chat]: That might work with a segault handler to handle the accesses between the two syscalls

Thomas Lively [via chat]: unless some other thread writes a non-zeros in the meantime?


Ben Visness [via chat]: That's effectively the same as racing on memory.fill - we assume that if you have data races, you might not get all zeroes at the end.

Sam Clegg [via chat]: wouldn't other threads writing non-zeros will always bring a page back into the working set.. regardless of method


DG: Thanks for all the data. Unity requested this for low memory devices. The blocker is tool support so they can compile and use it? 

RH: This is the only real experiment we’ve done at this point. I would love to have Unity or other folks. And would be happy to help with others experiment. Whatever they are using, malloc or libc, would need to integrated with it.

BV: I believe the Unity employee integrated the memory discard into Emscripten’s memory allocator but we never heard back if that was useful, but it was easy to integrate at least.

Keith Winstein <via chat>: Do we think modules will often want to discard regions from the interior of a linear memory, or is this something we envision will mostly be used on a suffix of the memory's current size?

RH: If anyone is here from windows, and can give us the semantics we want, would really appreciate that

KW: Re-asking questions from chat

RH: It does appear that in certain cases, that just doing the suffix at the end, with discarding the lower end can work, there are concerns about fragmentation for long running applications. The length of memory, when you were talking about shrinking, decreasing the length is hard in spidermonkey, we don’t want to change the memory length because we want to move the memory arouynd, update guard pages. So reducing the length makes it harder. 

BV: Doing the discard, removing pages from the working set is really as good as shrinking memory. The only thing that matters to memory metrics like OOM killers is the impact to the working set of memory pages. Reserved memory or memory that has not been touched yet, really has no impact, though it’s more subtle on Windows. At this point I don’t think shrinking matters given how good discard it at removing memory pressure.

"
wasi/2024/WASI-08-22.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: August 22 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: August 22 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. @abrown: discuss moving wasi-nn to phase 3 (30 minutes, [slides])
    1. _Submit a PR to add your announcement here_

[slides]: presentations/2024-08-22-abrown-wasi-nn-phase-3.pdf

## Notes

### Attendees

- Bailey Hayes
- Andrew Brown
- Pat Hickey
- Dave Bakker
- Syrus Akbary
- Colin Murphy
- David Bryant
- Stephen Berard
- Ayako
- Mingqiu Sun
- Jeff Charles
- Nick Fitzgerald
- Johnnie Birch
- Chris Woods
- Stephen Berard
- Till Schneidereit
- Dave Bakker
- Dan Gohman
- Yong He
- Joel Dice
- Luke Wagner
- Emily Ruppel
- Alex Crichton
- Nuno Pereira
- Kate Goldenring
- Yosh Wyuts
- Mendy Berger

### discuss moving wasi-nn to phase 3

**Andrew Brown**: wasi-nn currently at phase 2, we aren’t holding a vote today to go to phase 3, just want to discuss what it takes to get to a vote.

**Andrew** wasi-nn was initially proposed in 2020, I implemented it in Wasmtime, others implemented it in WasmEdge and WAMR, have a list of interested parties and contributors in my slides, have an informal working group in Bytecode Alliance. 

**Andrew** We did the big change from the preview 1 ABI to the preview 2 WIT definition. And we have some changes to the architecture.

**Andrew** Wasmtime has an implementation of the WITdefinition, WasmEdge has an implementation of preview 1 definition, WAMR is working on wasip2 module abi implementation

**Andrew** During the phase we have met one or more implementations to prototype the API, and we are working on the portability criteria. We’ll discuss that plan in a few slides. The ML Working Group has been meeting since Oct 2023, if you want to join those meetings every other Monday that's how we have been gathering feedback, we have notes online as well.

**Bailey (in chat)**: https://github.com/bytecodealliance/meetings/tree/main/machine-learning

**Andrew** I'd like to ask for phase 3 acceptance in Q4 of this year. It depends on the portability criteria plan. Here are the previous portability concerns brought up:

**Andrew** Its hard to test wasi-nn. If we are testing the internal model functionality we are getting out of scope of what WASI can describe, it varies widely in the many implementations. The other problem is that the user of wasi-nn just provides the binary bytes of a model, there are many ML frameworks and they change over time (Onnx has many versions, openvino has many versions etc), new frameworks being added too. So the question is how do you interpret those bytes.

**Andrew** My proposed plan is: 1. We need a test suite based on an “echo” model. If you pass in a tensor you get back the same tensor. This can test the API surface without testing the ML frameworks themselves.  2. We need to get rid of the current `load` and replace it with `load-by-name`, bump up the level of abstraction (which is already in the spec) and eliminate the old way of loading models. We have to resolve some changes: we are considering a prompt extension for LLMs, and error shape. So if we do all those things I propose we vote on phase 3 in Q4 of 2024, and then update implementations in 2 engines.

**Pat** Does the implementations happen before or after the vote

**Andrew** There is no requirement to have the implementations complete before the vote

**Pat** the way we handled that last time with e.g. wasi-http was we said Wasmtime is fully passing all tests and jco is passing 6/10. The requirement is left ambiguous because context matters but we were looking for “the end is within reach” of the 2nd implementation rather than “we don't know whether we will ever get to the end”

**Andrew** Ok then let's move that step up before the vote.

**Andrew** On the test suite: challenges include small floating-point differences between ML frameworks and parameters. Some of the models rely on randomness. There's many frameworks, many models, and many values, which is a really large space to test. We debated “if you can run this model x, that's the test suite” but there is no one model that runs in all the frameworks and how would we pick just one. So let's just test the wasi-nn api itself, and not test the internals of the ML model logic. So we have this idea of an echo model and the before and after tensor are identical, that can be mechanically checked for equality. We can explore all of the different tensor item types. So this would test that the wiring and logic between a wasi-nn interface and the framework implementation are working.

**Andrew** to address previous concern of loading by bytes, the graph encoding list is never complete, the encoded bytes are opaque, retrieving the bytes is slow because the models are really big so most users dont want to use that mode anyway, some of the models dont even fit in a wasm32 linear memory. The previous solution we proposed was to replace the `load` with `load-by-name` which is a higher level of abstraction where the implementation is responsible for having a model available. Load gives a lot of really low-level control of where the model runs on physical resources and things like that. So the idea we have is to eliminate load and rename load-by-name to load - make that the only abstraction available.

**Andrew** Error design. A PR for tensor residence (cpu, gpu?) which some frameworks support and some do not, and in our latest abstraction I feel like we do not need that - it's opaque to the user in the load-by-name api. Coalesce tensor parameters: first we setup the inputs, then run, then retrieve the outputs in separate calls. PR 77 makes compute a single function call, it's a function from list of named tensor to result of list of named tensor, error. This would simplify the implementation side to not have to hold state between calls. And we have had several requests to configure models by tweaking parameters, so there's a PR for listing the parameter names and then you can get and set them by names. Finally a prompt interface, currently you have to do a ton of work in the wasm side to make prompts work, so this proposal says to put that over in the implementation where you have a string to string compute, this is what LLMs and their users expect. This means there's 2 paths in the wasi-nn spec, either there's a graph to use with tensors or a graph to use with LLMs.

**Andrew** I want process feedback, and help on resolving all these problems, I'm on Zulip if you want to ping me to help. 

**Pat** I want to hear from the stakeholders who are interested in deploying this interface that they're all happy with how these questions are resolved. I don’t know if all of the representatives from those stakeholders are on this call to tell us they are happy with the state of this proposal

**Bailey** If they cant do it live on this call they can provide that sort of endorsement async on github

**Andrew** Meeting for 2 years we have collected a lot of that feedback. It’s not clear to those who are gathered here now because it's in many issues and PRs. 

**Pat** So I'd suggest that you resolve these outstanding questions and then make a github issue on wasi-nn saying motion to move to phase 3, and collect an endorsement and objection from a large majority of your stakeholders before bringing it to the WASI subgroup for a vote.

### Announcements

**Pat** Bytecode Alliance component model plumber summit is happening sept 26-27 in Redmond Washington, email me pat@moreproductive.org or David Bryant david@bytecodealliance.org to get more information. This event is for Bytecode Alliance implementers and users to collaborate in-person and remotely. A public invitation will happen soon.
"
gc/2021/GC-03-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 9 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: March 9, 5pm-6pm UTC (March 9, 9am-10am Pacific Standard Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Update on spec interpreter [Andreas Rossberg]
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Francis McCabe
- Conrad Watt
- Zalim Bashorov
- Rick Battagline
- Lars Hansen
- Ross Tate
- Ben Titzer
- Adam Klein
- Zhi An Ng
- Daniel Wirtz
- Sabine
- Fil Pizlo
- Ryan Hunt
- Jakob Kummerow
- Andreas Rossberg
- Mano Koukoutos
- Keith Miller
- Luke Wagner
- Asumu Takikawa
- Ioanno Dimitriou
- Tim Steenvoorden
- Emanuel Ziegler
- Yulia Startsev

### Presentation: Update on spec interpreter [Andreas Rossberg]

AR Presenting [slides](https://github.com/WebAssembly/meetings/blob/master/gc/2021/presentations/2021-03-09-rossberg-update-wob.pdf)

AR demonstrating [Wob interpreter](https://github.com/WebAssembly/gc/tree/wob/proposals/gc/wob)

Strings loaded into memory then copied byte-by-byte into array
Arrays, tuples, generics work.
Only boxed types allowed for generics because it’s the simplest thing. Want to explore further.
Need to do ref.as_data then ref.cast to get from any to concrete struct. Ref.as_data doesn’t support null, so a null check is necessary as well. Slightly painful.
Classes represented by 5-tuples. Vtable, constructor, pre- and post-allocation hooks, pointer to superclass. Need hooks to get 2-phase initialization of immutable data.

ZB: Does this language have non-nullable types?

AR: Right now it uses nullable types in most places. Non-nullable locals become useless if you don’t have locals of that type. Wob uses non-nullable locals only in vtable and class definitions.

FM: This example maps strings to array of mutable i8s?

AR: Yes, to make initialization possible.

FM: We’ve been talking about sealing or marking things read-only after initialization.

AR: Agree.

FP: What would a sealing capability give you as a client of this? Can see it would be useful in the source language.

AR: One important thing is subtype, if source lang has immutable field on which you allows subtype, you can only map to Wasm if you map to read-only fields. If they are immutable then you can’t initialize them. If you have a read-only mode, a super type of both mutable and immutable, you can allocate something as mutable, it is not subtypable in contents type, but subtypable in its mode. If you forget it’s mutable, you can also subtype its contents.

CW: Would that require an affine type to ensure there’s not another mutable reference hanging around?

AR: read-only is not immutable, it wouldn’t matter for soundness, would be different from immutable, cannot write it, but can be changed by someone else with a more precise type. That’s sound on the Wasm level.

TL: question about spec interp, for rtt.canon, what algo do you use to canonicalize all the types? 

AR:The ref interp doesn’t canonicalize anything, doesn’t have to, does the graph traversal algorithm each time, kind of like the declarative specification.

TL: if i have two equivalent but different declarations of equirecursive types, they need to get the same rtt.canon, how does it determine those two get the same rtt value.

AR: it doesn’t, it ends up being equivalent rtt values. It puts in whatever you wrote, when it compares rtt it does the right comparison. It is not the implementation you would want to use in the engine, for ref interp that’s the canonical thing you want to do.

BT: we have limited set of init instructions which are blessed, whats you’re thinking on allocating/writing to array, so you can describe initialization of arrays.

AR: what do you mean by initialization?

BT: e.g. for globals, you can read from another global. If we expand that to include object allocation, writing fields, we can have object literals.

AR: I agree that we want to do that. Especially for allocating rtts, but also i31, structs, and arrays. Anything without observable side effects should be fine.

BT: another question about array, i foresee in the future people will want to mix i/o with array and memory as well. Should we consider instruction that do bulk copies or make array look like memories, or first class memories.

AR: probably want some more low-level instructions over arrays that are byte arrays. Maybe first class memories are a way? Would expect that to be a separate concept, presumably more heavyweight. From the string init example, sort of stupid to copy byte by byte in a loop. Can unroll. Probably want to extend it. Might want to restrict it to some degree, so that the engine has leeway how it lays out its struct/array internally. For pure byte array like i8, can probably make exceptions and say it is always packed densely, so we can convert to other types, e.g. all the numeric types always pack densely. Not needed for MVP, more of a performance thing.

CW: Would it make sense to implement the efficient canonicalization algorithm in the interpreter as a reference for other implementors.

AR: yea… the interpreter doesn’t implement anything efficiently at all, could definitely write an implementation.

CW: i just mean efficient in the sense that different from the graph traversal each time comparing rtt

AR: wants to do the declarative thing, follow the spec, which is the graph traversal. There is nothing stopping us from writing and impl and playing with it. Maybe there are ways to avoid this graph canonicalization and reduce it to just tree normalization, which will be hash consing if we do it the right way. That’s a separate discussion.

TL: that will be useful discussion to have sooner rather than later, currently in Binaryen, reducing Binaryen functionality rather than implementing the canonicalization of type. Binaryen used to calculate LUB of everything, taking that out because it is too complex

AR: been on my plate for a while, want to get back to it soon.

RT: separate compilation working? You have to know all the internals of C?

AR: you don’t need to know, will show an example of that.

RT: doesn’t have class inheritance across modules?

AR: that works, one reason why i package the class up as a tuple, only import and export the tuple, gives me everything i need

RT: doesn’t that tell you all the internals of the classes?

AR: yes, in C++ you depend on the layout of class, if you change it you have to recompile your deps.

AR: I would also like to try a different representation strategy for classes that doesn’t require recompilation.

FM: speak a little bit about making classes themselves typed and not nominal?

AR: classes are nominal in the language

FM: in the wasm representation as well?

AR: no, that’s not necessary. That’s a separate problem. Right now there are no casts, it’s only a static type check. For casts, whether the Wasm is nominal or not, you can’t use Wasm rtt to represent source language casts. Either they are too weak, if all rtt are structural. Or if rtt are nominal, they are too strong. Neither works to implement source semantics. You have to implement type representation for these casts in userspace. That is the case until we have Wasm generics themselves.

CW: this is about C#, languages with proper generics?

AR: yea. In interpreter you have fully reified generics, polymorhpic recursion, etc. The Java thing is not what you want by design, what they got out of historic accident. 

CW: not the semantics that is most challenging to support, but have to compile to Wasm.

AK (chat): I'm curious about your statement that MVP is about expressiveness, not performance; we've talked about how ""performing better than JS"" is a pretty important feature, at least in Web embeddings.

AR: yea it should still be somewhat better than JS, if you can’t even compile stuff, then performance won’t help. First thing we have to validate is to compile stuff. Then worry about performance. Agree that mvp should be on par with JS or better. Positive that it will be. This runs using ref interpreter, so wont help with performance. The Wasm module that it generates should run in any engine that supports the proposal. You can observe using return export, or assertions.

"
wasi/2022/WASI-06-30.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: June 30 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: June 30, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. WASI Preview2 proposal (slides: [pdf](presentations/2022-06-30-gohman-wasi-preview2.pdf))

## Notes

### Attendees:

- Dave Bakker
- Bailey Hayes
- Kyle Brown
- Lin Clark
- Dan Gohman
- Dave Bakker
- Syrus Akbary
- Nathaniel McCallum
- David Justice
- Piotr Sikora
- Jeff Charles
- Benjamin Titzer
- Istvan Szmozsanszky
- Shiyu Yuan
- Mingqiu Sun
- Luke Wagner
- Danilo Chiarlone
- Joel Dice
- Richard Msiska
- Adam Mohammed
- Michelle Dhanani
- Yong He
- Andrew Brown
- Kevin Moore
- Steve Schoettler
- Jonnie Birch
- Ralph Squillace
- Jiaxiao Zhou

### WASI Preview 2

**Dan Gohman**: Take a look at where WASI is today. Anticipating where IT and CM were going. IT has changed a lot. Things that were going into WASI are now going into CM. WASI focuses more on API level.

CM model has become focus for a lot of the things that are important to us. E.g. cross lang interop, robust composition, IDL.

With that background, introducing preview two built on top of that foundation. Snapshot 1 is in a ot of upstream toolchains. Idea for preview 2 is to be a new island of stability. Big tent pole feature is to build on top of wit.

Wit based tooling is aligned with the CM, but doesn’t require engine to implement the CM. Has a core wasm abi. Also gives us easy to use bindings. This allows us to get away from POSIX system call limitation. With wit based interfaces, we can have high-level enough types that we can expect devs to use the APIs directly. Less need for virtual filesystem APIs because the IDL based approach makes it easier to define without going into libc. Less pressure on generically designed APIs.

IDL thinking is a pretty big shift. Not a single ABI. Lots of different possible ABIs that map to the IDL.

Preview 2 allows us to bring in things like wasi-sockets more easily. Also work toward a milestone while allowing more development in the future. 

Other improvements: remove the rights system, more convenient preopen system. Make more of the APIs capability based. Revamp how readdir works and lots of other quality of life improvements. 

Dev plan: let’s define a milestone. Keep the feature set scoped rather than full CM. No async support, can’t link multiple components yet, no support for DLLs. This is consistent with preview 1. Also going to use GitHub project trackers (WASI Preview 2 (github.com) , WASI Preview2 Tracking (github.com)). One for standards work in WebAssembly org, and a corresponding one in the BA org for the implementation work that the BA is doing to prototype and implement.

**Dan Gohman**: questions

**Nathaniel McCallum**: Questions about sockets. Where/when to raise?

**Lin Clark:** Raise on the issue tracker, and then we can address in this meeting if anything can’t be resolved there.

**Syrus Akbary:** Wanted to remove the rights system, can you explain that?

**Dan Gohman**: Something that came from CloudABI. It’s very flexible but not in the ways that people need it to be.

**Syrus Akbary:** POSIX compat?

**Dan Gohman**: Complex question. Wasm will likely never have support for things like fork. Full POSIX compat isnt’ a meaningful goal for WASI because platform.

**Piotr Sikora:** Question about semantic versioning and split up in different modules.

**Dan Gohman**: There are some things useful to put into standard libraries. That kind of set makes sense to bring into preview 2. The milestone will have 2 meanings. This block of APIs, filesystems, etc that libc would need. Preview 2 also stands for a transition to WIT based tooling in general. The reduced dependence on libc will be involved here. When you can talk directly to WASI streams, you don't’ need to think about libc and using the filesystem to do that. 

**Nathaniel McCallum**: as we’ve been impl WASI in Tokio, undefined behavior. Would like to prioritize.

**Lin Clark:** Let’s handle that in separate meeting.

**Bailey Hayes:** With preview 1, able to add new features. Would we fold new features in preview 2.

**Dan Gohman**: My experience with preview 1 was that we weren’t able to iterate quickly.

**Bailey Hayes:** For async?

**Dan Gohman**: Preview 2 isn’t the end of the road. We don't’ see this as the final step, which is why we are calling it preview.

**Syrus Akbary:** There are some langs that are going to need support for exceptions. Do you see support of that it WIT.

**Dan Gohman**: WIT is a cross lang abstraction layer. Exceptions are lang dependent. Across interface boundaries, we’ll have a way to express errors, but we won’t have unwinding

**Luke Wagner:** Expected type has a failure case. Thats how we keep exception handling as a impl detail of the component.

**Syrus Akbary:** JS?

**Luke Wagner:** Yes

**Dan Gohman**: WASI Preview 2 commands

**Ben Titzer:** What about pausing for debugging?

**Dan Gohman**: Don’t think debugging needs to be defined in semantics of lang

Now that we’ve defined what a command is, how do we get to core Wasm ABI. Canonical ABI defines a mapping from a component into core wasm type. Engines can actually impl Canon ABI directly.

Another things CM gives us is concept of profile. A profile can define the shape of the component. Describes what imports and exports can be. 

Can model this as a command profile file. Let’s pull in env, logger, preopen, etc. All commands can use APIs that are in this list. All engines that provide this profile can run components that use this profile. WASI SG can define this profile. We can ask whether things like crypto belong in the command profile. We’ll have different platforms.

**Syrus Akbary:** Conflicts between transitive dependencies?

**Dan Gohman**: There is no global namespace, we can have multiple copies of env

**Luke Wagner:** And in general the type sharing is a key part of the design of the CM. This allows us to very precisely define.

**Dan Gohman**: Let’s look at cmd line args. We’ve been talking about plan for Typed Main. Status quo: strings require ambient perms, implicit agreements, etc. We want to move to a world where main takes streams and handles instead of strings. These handles carry perms with them. Plan for how this is going to fit in.

Env variables are the next thing in pantheon of Unix. Env can just be *: String. Programs will have to declare up front what env vars they actually want to use. This will make it a lot easier for developers to understand what env vars they need to declare.

Next is preopens. Designed a new system that doesn’t have out-of-band declaration. Propose that we automatically infer preopens. We’ll then bind with a UUID so that the program doesn’t see names.

**Nathaniel McCallum**: Strongly opposed to this for security.

**Dan Gohman**: This is erring on the side of usability.

**Nathaniel McCallum**: Goes against the general thrust.

**Luke Wagner:** Isn’t this a bit of the opposite? Before it would pass the filepath. It’s actually obscuring it with the UUID. 

**Dan Gohman**: This is a great discussion to have. In the context of this meeting, we should defer.

**Syrus Akbary:** One question was Deno in this case does something interesting. Allow or deny?

**Dan Gohman**: Not always the most convenient thing. There’s a usability tradeoff. Commands also won’t be the only story for WASI. 

**Nathaniel McCallum**: In our use case, interactive perms won’t work.

**Kyle Brown:** My question, what about false positive? E.g. a git branch that’s now being misconstrued.

**Dan Gohman**: We can actually check does this path actually exist. If it’s not there.

**Nathaniel McCallum**: Precisely race condition that has caused problems.

**Lin Clark:** Let’s take this discussion to a different context

**Nathaniel McCallum**: I agree

**Dan Gohman**: Preopens example

Final piece—Exit status of main. 

Stream i/o libc will present a sync API but the async API will be in place.

Next steps:

Discuss and convert these slides into design doc
"
simd/2022/SIMD-11-18.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the 2022-11-18 video call of WebAssembly's SIMD Subgroup

- **Dates**: 2022-11-18
- **Times**:
    - 5pm-6pm UTC (9am-10am PST)
- **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this [form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking
1. Adoption of the agenda
1. Proposals and discussions
    1. Relaxed mode next steps
    2. Request to test testing instructions
    3. Instruction for every variant
1. Closure

## Meeting notes

### Attendees

- Andrew Brown
- Anton Kirilov
- Deepti Gandluri
- Johnnie Birch
- Marat Dukhan
- Nabeel Al-Shamma
- Thomas Lively
- Petr Penzin
- Yury Delendik
- Zhi An Ng

### Relaxed mode next steps

TL: is it a no for keeping, or no for removing

ZA: no for keeping

DG: semantic change overall, out of scope for relaxed simd, there is a part of proposal for relaxed mode

AB: can be done separate, after relaxed mode in in place

PP: Dan is not here so hard to discuss there, could be added later

ZA: path forward is to tidy up and present to CG?

DG: worthwhile to talk about relaxed mode and profiles in the CG, before including it. few people seem to have opinion about it, preemptively handle ahead of time, discussion on profiles repo is quite recent, ideas on how to clean that up, what the goals are

ZA: are you suggesting we show relaxed mode, and show how it fits into profile

DG: can do this in partnership with Dan, point the group at relaxed mode, doesn't need a full talk, need to  see how CG feels about it

PP: reading through profiles, talks about features to include or exclude, not 100% clear if an instruction does different things in different modes, that's something to clarify, idea is pretty much the same

DG: orthogonal, that's a spec mechanism to state what instructions are supported in what mode, in deterministic mode you have relaxed SIMD in non-relaxed mode. those 2 are orthogonal.

PP: Dan's presentation has instructions that work in both modes, although you could entirely remove them in strict mode.

AB: want to agree with DP, to check in with profiles work to make sure that this is going to align with that, before doing too much work. Think it will align. Have not been voting on some of these polls because I feel uncomfortable about the decisions we are making that are picking winners and losers in the ISA world. Addition of relaxed mode gives a way to express Intel semantics in a way, but we are fragmenting the Wasm concept to do that, can really only get that semantics in some fragment. Don't feel great about that in the future. In the future with new instructions, will we fragment further. Semantics for different ISA are not coalescing.

TL: Is that a fundamental objection to existence of the relaxed SIMD proposal? How do you feel this is actionable?

AB: not super actionable, if we get relaxed mode, we have some way to express Intel semantics, 2 years down the road when we have 20 versions of this, then what?

DG: address the philosophical fragmentation issues, Wasm is expanded to different needs, whether on cloud, server, embedded. At some point fragmentation is unavoidable, we some way to state what features are important, some structured way. In general not realistic that in 2 years we have so many different semantics. Silicon moves slower, adoption is slower. VMs don't easily adopt that.

PP: it's not only Intel, it's x86 semantics. Share same sentiment too. Some validity to being careful to what we add. Adding is much easier than removing. Canonical nan use case is writing interpreters.

DG: there's a balance there, be careful and add very few things. We want to enable applications and move the standard forward. Especially when we are in the early stage of adoption, need to be judicious about risk and tradeoff

PP: Agree completely. We cannot just chase a narrow use case, not the case for relaxed simd.

ZN: Sync with Dan, and see how we can share this at the next CG meeting

AB: Are we all agreed with DG that canonicalization of NaNs should not be a part of the relaxed SIMD proposal?

MD: agree, it affects beyond SIMD

PP: single NaN value for deterministic profile

MD: maybe in the scope for deterministic profile once it gets to the stage

AB: it can be argued at that stage then

DG: meeting next week, but it’s also the Thanksgiving week

ZN: Will sync with Dan and schedule

### Request to test testing instructions

MD: request to add specific instructions for testing which way it is implemented, for relaxed madd, is it fma or separate mul + add. This request came from Apple, idea is that if they get bug report if a webpage works or doesn't on certain archs, want to figure out if it is relying on some specific feature.

MD: since we are exposing implementation specific options, it is possible to start using them, so we should explicitly provide functions to test for them, so that browsers can quickly know if this was used.

PP: have to disassemble the whole module to see if people are testing it, maybe canonical pattern, but have to disassembly the module

MD: in order to test for specific implementation, from engines POV, there is no difference between modules that test for implementation specific instructions

TL: wider CG will have strong opinions on implementation specific instructions, should have this in a public issue.

DG: at this point, the realistic expectation is to relitigate this every couple of weeks. Confused about the testing issue, what Justin is testing for. Will expect that to be very hard to get approval for. From engine perspective, there are only a couple of valid semantics.

PP: 2 sides to this, in general instructions with single or double rounding, it's more critical. E.g. if OOB lanes, you can test x86 or ARM. If you want to test FMA, you provide 3 values and test output for exact bit pattern. We don't know what 3 floating point values you will use. If you get a bug report that it is report, you don't know if it is testing fma. It's not that you get a NaN and check the sign. If you provide an explicit way to do it, you won't have to guess.

DG: there's no reason you need to have that in a spec. You can put that in a function or a document. What do you propose we include in the spec.

PP: sounded like an actual instruction which says if fma is single rounding.

MD: yes, is relaxed madd single rounding.

DG: more useful to have when Justin is present, hard to annotate all the semantics that can be used. You could hardware the engine to generate muladd and see if it works. Different ways we can do it, what sort of exported functions we can use to test bit patterns, can document it somewhere.

### Instruction for every variant

MD: Ben wanted to expose each implementation option as an explicit instruction.

TL: agree that it is not desirable

PP: if we cannot get CG to agree on the mode, then we do this. Will be much worse performance.

DG: should have consensus that we are willing to push for relaxed mode. We don't want to entertain all of the options presented

MD: phase 4 relaxed simd?

ZA: probably not, present relaxed mode, then poll

DG: cannot over index on one or two influential members. put onus on them to come to meeting and discuss options

PP: will try not to attempt to go for something important during holiday week

DG: 6 weeks is a long time, even if we decide to present relaxed mode, and then poll the room.

PP: not really solving what people have complained about, pushes discussions...

DG: you introduce all forms of intrinsics, applications only use what makes theirs fast, you also introduce user confusion on which to use, and what differences there are

PP: intrinsics are not a good idea, introduce deterministic variants maybe better, but we don’t have to seriously entertain them until we discuss the modes

ZA: to summarize, we will focus on two modes, I’ll sync up with Dan and we will ask Justin to put his concern into an issue
"
stack/2021/sg-4-19.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 19th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  April 19th, 16:00-17:00 UTC ( April 19th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
* Francis McCabe
* Luke Imhoff
* Sam Lindley
* Rick Battagline
* Paul Schoenfelder
* Zalim Bashorov
* Alon Zakai
* Arjun Guha
* Thibaud Michaud
* Derek Schuff
* Adam Klein
* Thomas Lively
* Ioanna Dimitrou
* Zhi An Ng
* Andreas Rossberg
* Ross Tate
* Luke Wagner


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. [Lightweight threads, actors, async/await, ..., in a minimal extension of the WebAssembly reference interpreter](presentations/2021-04-19-lindley-continuation-examples.pdf) (Sam Lindley) [45 mins]

   1. Next meeting [2 mins].
1. Closure

## Meeting Notes

### Adoption of the agenda

### Discussion:

[SL sharing slides]

SL: I’m talking about this.  The extension that we proposed and implemented and a reference interpreter.  Trying out examples to see if this is practical.

The original issue is WebAssembly/design#1359.

Andreas made a formal spec at effect-handler/wasm-spec/blobk/master/porposals/continuations/Overview.md


Recap:
`event`: abstract commands/resumable exceptions
`suspend`
`cont.new`: function reference -> continuation type that does the stacklet creation.
`resume`: form of application that takes a continuation type and the expected arguments to run it.  Also installs event handlers.  Event handlers are the event type + label to jump to.
`resume_throw`: continuations are single-shot.  Can’t guarantee continuations are invoked, but if you need to tidy up the continuation.  The compiler is required to call `resume_throw` to clean up continuations.  Runs finalizers or language equivalents.  To be safe, guard every event handler with an exception handlers that calls `resume_throw`.

[SL showing “Encoding handles with blocks and labels” slide]

Uses `loop` with nested `block`s that maps event types to labels.  `resume` is the inner most call.  The label on the block refers to the code at the end of the block (This is how `block` labels work already.  Just a refresher for how `br` works in block to jump to the end.)  `block` are written in reverse of the order of the events.  The result type of each block is the arguments to the event and the continuation type last.

AR:
This is the similar to the encoding of a switch using `br_table`.

SL:
The end of each clause branch back to the loop.

FM:
How do you write the loop in a source language.  How to implement Loom where it allows the event loop being written in Java.

[SL showing lightweight thread example]

Events:
`yield`
`fork`

The interesting part is the implementation of various different schedulers:

Synchronous scheduler with loop with block for yield and fork.  Runs until dequeuing returns null.  Since this is a synchronous scheduler it does not yield at all.

FM:
We need to make sure the continuation is not re-enterable.

SL:
That is part of the design.  It will trap.

FM:
Another way to do this is linear or affine types.

SL:
That would be a big change to the type system.  Expecting compilers to guarantee linear code might be a bit much.   We’re doing the simplest thing you can do.  This is what Multicore OCaml does.

RS:
Does that not require a synchronization check on each stack switch.

SL:
That requires a null check.

RS:
Which could be shared.

AR:
Only if it is a shared reference.

SL:
YOu need to expose the continuation reference type.  With the current design, you need to check the continuation is not dead.

Anything else?

FM:
I’m OK.

SL:
`fork` takes a continuation and returns a continuation

What else I showed last time was instead an asynchronous scheduler.  On yield, run the next continuation.  Enqueue the new thread on fork.

[SL end of review of previously presented information]

RT:
Curious about parallelism.

SL:
What Loom does: if you have some event, you can give it different handlers - single thread or parallelism.

RT:
The issue is that I brought up before that it is possible to have stackswitching that doesn’t require synchronizaiton.

SL:
I have not thought of that deeply.

AR:
Shared state is very deep in WASM’s type system.  If continuations are not shared references, then you don’t need any synchronization.

TL: 
You can’t have a work-stealing system.

AR:
Can’t have work stealing without shared references.

RT:
The Linear version does have that.

SL:
The Linear approach is worth looking at.

[Back and forth occurs.  Sorry, couldn’t record while participating]

[SL shows actor example]


`self` gives mailbox
`spawn` creates a new mailbox

I was dependent on `func.bind`, but that creates a closure and that gives an unknown lifetime.  Added `cont.bind` to partially apply a continuation.  A continuation is expecting some arguments.  Partially apply to some arguments.  Does not suffer from lifetime problems because continuation is one-shot.

FM:
This might be a good time to talk about lifetimes in general.

We’re assuming it is up to the language runtime.

SL:
The backend of the compiler is disciplined enough to explicitly throw away a continuation it will not run.

If an exception is throw, resume_throw must be run.

Easier with linear type system or a static analysis.

`cont.bind` avoids code duplication.  If you have an event that returns an argument, you’ll have a continuation that expects arguments.  You’ll end up with code that needs to handle multiple arities continuations.  Using func.bind the arity is always the same.

Can `resume` be simplified to no arguments and have to fill arguments with `cont.bind`?

[SL shows the send 42 message through a chain of spawned actors]

The on_self handler gets a continuation that expects the mailbox.

There is a more problematic example with `receive`. Block the thread until the mailbox is non-empty.  If non-empty continue, else need to wait again if mailbox is empty.  Need to compose receive with the existing continuation.

If handlers can be composed actors can be written in terms of lightweight threads.


FM: put test inside the test not hte scheduler

SL: You don’t want to leak details, the thread is user code

FM: in user code you call library to receive message

SL: the interface to user code is just these things, no access that lets you see if there are any messages. You can have a design that does that, but not what is here.

FM: user code can’t directly suspend

SL: yea. Separations of concerns here, what is lower level, and what is going on here. Every case i come across, you can always work around this kind of thing. Maybe code gets more convoluted, or expose more lower level details.

FM: is this kind of pattern going to show up in other use cases?

SL: what use cases

FM: number 1 is async await

SL: what i’m about to go on to

FM: no actual i/o, have to resuspend immediately

[SL showing async/await example]

SL: I didn’t have any async behavior in the reference interpreter, so added some simple functions



async
await

Silly example is computing sum and putting it in a promise.  Async calls it three times and awaits and multiples results.

Interesting bit is the handler.  A very similar setup.

`$await-promise` itself import from “promise” “await”.  It only adds observers to list.  All work is done in `fulfill`.  If you await check for fulfilled.  If fulfilled give value otherwise store the continuation in the promise.  `fulfill` takes observers out of the promise and queue them.

[SL shows links. p12]

FM:
Settle work stealing.

SL:
Andreas, you said it depends on other things

AR:
That’s way in the future.

SL:
We want something to do the things we need to do now, but not rule out what will shoot us in the future later.

FM:
Other question: What a source language can do for itself.

SL:
Another question I want to raise: Concerned that these continuations get nulled, but you just keep generating more and the table keeps growing forever.  In practice that could be a problem.

AR:
You need memory management.

SL:
Array of continuations in space array

AR:
Just allocated in the engine.

SL:
What if they right to the same space again.

FM:
They’re not forgable.

AR:
It’s just a spec device.  Not observable.

RT:
For work stealing to be possible on the web it needs to contain no externref.

FM:
Need to unpack that too.  That was very helpful.  



### Adjourn

FM:
Thank you for going through that.

Links in the notes

Action Items:
SL send slides to FM

"
wasi/2019/WASI-12-05.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the December 5 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: December 5, 17:00-18:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Stack trace API
       1. https://github.com/WebAssembly/WASI/issues/159
       1. Whare are the next steps here?
    1. Character encodings
       1. https://github.com/WebAssembly/WASI/issues/8
       1. Can we decide on this, or do we need more information?
    1. Case sensitivity
       1. https://github.com/WebAssembly/WASI/issues/72
       1. Can we decide on this, or do we need more information?
    1. ANSI escape sequences
       1. https://github.com/WebAssembly/WASI/issues/162
       1. Can we agree on the overall framework proposed here?
    1. Input sequences
       1. https://github.com/WebAssembly/WASI/issues/163
       1. What standards govern this space?
1. Closure

## Meeting Notes

Attendees:

Dan Gohman
Pat Hickey
Stefan Junker
Wouter van Oortmerssen
Jan Falkin
Andrew Brown
Mark McCaskey
Peter Huene

Meeting notes:

https://github.com/bytecodealliance/wasmtime/pull/235#issuecomment-518897502

DG: If people have comments on the process we’re following with these meetings, please give feedback.

PH: I’ll second the agenda

DG: First item, stack trace API. Thomas Lively proposed this, but he’s not in the meeting at this time. Let’s table this until he’s here.

DG: Character encodings. This issue has been open for a while and there’s no easy answer. There’s a shape of a proposal in the issue that most engines are following - we say that everything is UTF-8. Is there any disagreement with that consensus here?

(none)

DG: For things like environment variables, it would simplify things a lot if we could guarantee those are UTF-8 strings.

DG: What about filesystems with file names that are unencodable? Can we find a way to tunnel that through? We currently use pointer+length to pass all filenames. No filesystem permits null in a filename, so we can encode a non-UTF8 string by putting extra information after the null. The trouble comes when you have to manipulate the path.

PH: What about interface types interaction?

DG: The stuff after the null will still be valid UTF-8 which encodes the non-UTF-8 part of the filename. So any library code that expects UTF-8 will still work.
DG: We’ll take this as consensus, and go forward with this design for now. We can change it if problems happen or we have objections during implementations.

AB: Can you clarify what is being encoded after the null?

DG: Two things: in the part before the null we want a normal-looking string, so any bytes that cant be translated get the unencodable-character (uffd). Then, after the null, we put the information that was lost. Something like, index of the string, then the missing bytes. We want something that is reversible. I agree it is goofy. Does anyone know how to encode an arbitrary integer in a utf-8 byte pattern? Obviously we could invent something, like using ascii digits. If theres an existing way to encode it, we’d want to follow that.

AB: So we can’t just say we support all unicode strings?

DG: The problem is that there are names out there that can’t be expressed in unicode. And from people I’ve talked to, its rare in practice. So the goal here is that if you get a path from one wasi api, and treat it as a utf-8 string without manipulating it, and then pass it to another wasi api, it works exactly as is.

AB: I misstated my question - is there no unicode format where this reconstruction wouldn't be necessary? Or will there always be some way for there to be an unencodable string?

DG: My understanding is there’s no way out of this.

Peter H: This would be for bytes which are not valid unicode codepoints.

DG: I’m looking for enough agreement that we can keep designing this for now.

Peter H: is there currently a part of the spec that allows non-utf8?

DG: Witx String type is always UTF-8. We don’t have a byte vector type right now, but there are byte pointer-length pairs. For any string passed to WASI we’ll require it to be UTF-8, and any string coming from WASI would be guaranteed to be UTF-8.

DG: Next topic, case sensitivity in filesystems. If you look at issue 72, the big picture strategy is that WASI doesn’t dictate case sensitivity or insensitivity, or what variation of sensitivity it has (because different filesystems have different rules, whether they case map ascii or different versions of unicode). I think the point of the API is to interact with existing filesystems, and we can’t control those, so this is going to be a portability hazard for WASI. We can make tools that help you detect these pitfalls. Does anyone have ideas of how we can make this better?

DG: Ok, so to use the wasm scary word, it is nondeterministic to use different cases to access the same file in the WASI api.
DG: Alright, so the next two issues are about virtual terminal handling. Its a space largely defined by compatibility with existing systems like xterm, unix consoles, and windows consoles. It makes sense to have something simple here. You could imagine unifying terminals with GUIs, modernizing terminals, lots of blue sky stuff here. My sense is that the value here is to find a simple thing that will interoperate with lots of different existing systems.

Sbc: Not just to interoperate with existing systems but to allow existing programs to run on many different systems?

DG: Yes my goal is something like vi on wasi just works. It looks like lots of people don’t use terminfo to figure out colors and just hard-code them. And windows support is tricky because it doesn’t have exactly the same features as unix.  In cases where the terminals differ, should we expose WASI programs to the differences between them?

DG: The direction I’m going is we don’t try to do terminfo, the WASI implementation will be responsible for remapping escape sequences and all that. You could imagine having an environment variable TERM=WASI. It would look a lot like xterm, which in turn looks a lot like windows.

DG: On that topic, input sequences are a subfield of escape sequences. Input varies way more than output, across platforms. This made me think we could do a cool radical thing like use unicode symbols. But maybe the simplest thing is, just do what xterm does, and if it needs to be remapped by a WASI implementation to fit another console, thats up to them. But there are interesting questions to still ask here like what set of input sequences to support

DG: Its tempting to say, we can go and design a modern system that doesn’t have all the legacy baggage. But my instinct now is to pull back from that and pick a reasonable set of defaults based on some of the successful modern implementations. If someone wants to design a whole new system, I won’t stand in their way.

SJ: Can you clarify about how vim would work on this?

DG: Vim itself wouldnt have to change. Terminfo is a library that gets linked in, but hopefully we could provide a radically simplified version that works on wasi. Inside the wasi implementation, anything like a TTY would have to filter the output coming from WASI program to neutralize all escape sequences, and then encode in terms of whatever its client expects.

SJ: I would have assumed that stdin/out/err just map to whatever the host of the WASI implementation expects

DG: We’re worried about security, because the terminal interface wasn’t designed to deal with untrusted code running on the terminal. So one example is that you could run a program and you think that it exited, but really its just showing you something that looks like your shell. We want to not allow applications to do things like that, by default. So if you wanted to run vim, you’d have to give it permission to rewrite your entire screen, versus just print ordinary text to stdout, which would be the default. So, controlling cursor position and colors and that would be exposed to wasi as a capability.
"
README.md,"# WebAssembly meetings

Information on official in-person WebAssembly meetings hosted by the W3C
[Community Group](https://w3.org/community/webassembly/). Each meeting will have its own
agenda published before the meeting, and minutes will be posted in the
invitation document after the meeting, including topics discussions and
decisions.

There are also several [subgroups](process/subgroups.md), which are smaller groups
focused on a particular topic. They have their own repositories and meetings;
see the subgroups page for links, and contact the subgroup chair if you want to
be added to those meeting invitations.

If you're unfamiliar with standards meetings,
[Allen's paper on standards committee participation for newbees](http://wirfs-brock.com/allen/files/papers/standpats-asianplop2016.pdf)
may be helpful.

## Process

Meeting process is documented:

* [Attendance](process/attendance.md)
* [Day-of](process/day-of.md)
* [Consensus](process/consensus.md)
* [Hosting](process/hosting.md)

## Meetings
<details open>
<summary>2024</summary>

   * [CG January 2nd video call](main/2024/CG-01-02.md)
   * [CG January 16th video call](main/2024/CG-01-16.md)
   * [CG January 30th video call](main/2024/CG-01-30.md)
   * [CG February 13th video call](main/2024/CG-02-13.md)
   * [CG February 27th video call](main/2024/CG-02-27.md)
   * [CG April 9th video call](main/2024/CG-04-09.md)
   * [CG April 23rd video call](main/2024/CG-04-23.md)
   * [CG May 7th video call](main/2024/CG-05-07.md)
   * [CG May 21st video call](main/2024/CG-05-21.md)
   * [CG June 5th-6th in-person hybrid](main/2024/CG-06.md)
   * [CG June 18th video call](main/2024/CG-06-18.md)
   * [CG July 2nd video call](main/2024/CG-07-02.md)
   * [CG July 16th video call](main/2024/CG-07-16.md)
   * [CG July 30th video call](main/2024/CG-07-30.md)
   * [CG August 13th video call](main/2024/CG-08-13.md)
   * [CG August 27th video call](main/2024/CG-08-27.md)
   * [CG September 10th video call](main/2024/CG-09-10.md)
   * [CG September 24th video call](main/2024/CG-09-24.md)
   * [CG October 8th video call](main/2024/CG-10-08.md)
   * [CG October 22nd video call](main/2024/CG-10-22.md)
   * [CG November 5th video call](main/2024/CG-11-05.md)
   * [CG November 19th video call](main/2024/CG-11-19.md)
   * [CG December 3rd video call](main/2024/CG-12-03.md)
   * [CG December 17th video call](main/2024/CG-12-17.md)

</details>

<details>
<summary>2023</summary>

   * [CG January 3rd video call](main/2023/CG-01-03.md)
   * [CG January 17th video call](main/2023/CG-01-17.md)
   * [CG January 31th video call](main/2023/CG-01-31.md)
   * [CG February 14th video call](main/2023/CG-02-14.md)
   * [CG February 28th video call](main/2023/CG-02-28.md)
   * [CG March 14th video call](main/2023/CG-03-14.md)
   * [CG March 28th video call](main/2023/CG-03-28.md)
   * [CG April 11th video call](main/2023/CG-04-11.md)
   * [CG April 25th video call](main/2023/CG-04-25.md)
   * [CG May 9th video call](main/2023/CG-05-09.md)
   * [CG May 23rd video call](main/2023/CG-05-23.md)
   * [CG June 6th video call](main/2023/CG-06-06.md)
   * [CG June 20th video call](main/2023/CG-06-20.md)
   * [CG July 18th video call](main/2023/CG-07-18.md)
   * [CG August 1st video call](main/2023/CG-08-01.md)
   * [CG August 15th video call](main/2023/CG-08-15.md)
   * [CG August 29th video call](main/2023/CG-08-29.md)
   * [CG September 12th video call](main/2023/CG-09-12.md)
   * [CG September 26th video call](main/2023/CG-09-26.md)
   * [CG October 11th-12th in-person hybrid](main/2023/CG-10.md)
   * [CG November 7th video call](main/2023/CG-11-07.md)
   * [CG November 21st video call](main/2023/CG-11-21.md)
   * [CG December 5th video call](main/2023/CG-12-05.md)
   * [CG December 19th video call](main/2023/CG-12-19.md)


</details>

<details>
<summary>2022</summary>

   * [CG January 4th video call](main/2022/CG-01-04.md)
   * [CG January 18th video call](main/2022/CG-01-18.md)
   * [CG February 1st video call](main/2022/CG-02-01.md)
   * [CG February 15th video call](main/2022/CG-02-15.md)
   * [CG March 1st video call](main/2022/CG-03-01.md)
   * [CG March 15th video call](main/2022/CG-03-15.md)
   * [CG March 29th video call](main/2022/CG-03-29.md)
   * [CG April 12th video call](main/2022/CG-04-12.md)
   * [CG April 26th video call](main/2022/CG-04-26.md)
   * [CG May 10th video call](main/2022/CG-05-10.md)
   * [CG May 24th video call](main/2022/CG-05-24.md)
   * [CG June 7th video call](main/2022/CG-06-07.md)
   * [CG June 21st video call](main/2022/CG-06-21.md)
   * [CG July 5th video call](main/2022/CG-07-05.md)
   * [CG July 19th video call](main/2022/CG-07-19.md)
   * [CG August 2nd video call](main/2022/CG-08-02.md)
   * [CG August 16th video call](main/2022/CG-08-16.md)
   * [CG August 30th video call](main/2022/CG-08-30.md)
   * [CG September 13th video call](main/2022/CG-09-13.md)
   * [CG September 27th video call](main/2022/CG-09-27.md)
   * [CG October 11th video call](main/2022/CG-10-11.md)
   * [CG October in-person/hybrid](main/2022/CG-10.md)
   * [CG November 22nd video call](main/2022/CG-11-22.md)
   * [CG December 6th video call](main/2022/CG-12-06.md)
   * [CG December 20th video call](main/2022/CG-12-20.md)

</details>

<details>
<summary>2021</summary>

   * [CG January 5th video call](main/2021/CG-01-05.md)
   * [CG January 19th video call](main/2021/CG-01-19.md)
   * [CG February 2nd video call](main/2021/CG-02-02.md)
   * [WG February 10th video call](main/2021/WG-02-10.md)
   * [CG February 16th video call](main/2021/CG-02-16.md)
   * [CG March 2nd video call](main/2021/CG-03-02.md)
   * [WG March 10th video call](main/2021/WG-03-10.md)
   * [CG March 16th video call](main/2021/CG-03-16.md)
   * [CG March 30th video call](main/2021/CG-03-30.md)
   * [CG April 13th video call](main/2021/CG-04-13.md)
   * [WG April 14th video call](main/2021/WG-04-14.md)
   * [CG April 27th video call](main/2021/CG-04-27.md)
   * [CG May 11th video call](main/2021/CG-05-11.md)
   * [WG May 12th video call](main/2021/WG-05-12.md)
   * [CG May 25th video call](main/2021/CG-05-25.md)
   * [CG June 8th video call](main/2021/CG-06-08.md)
   * [WG June 9th video call](main/2021/WG-06-09.md)
   * [CG June 22nd video call](main/2021/CG-06-22.md)
   * [CG July 6th video call](main/2021/CG-07-06.md)
   * [CG July 20th video call](main/2021/CG-07-20.md)
   * [CG August 3rd video call](main/2021/CG-08-03.md)
   * [CG August 17th video call](main/2021/CG-08-17.md)
   * [CG August 31st video call](main/2021/CG-08-31.md)
   * [CG September 14th video call](main/2021/CG-09-14.md)
   * [CG September 28th video call](main/2021/CG-09-28.md)
   * [CG October 12th video call](main/2021/CG-10-12.md)
   * [CG October 26th video call](main/2021/CG-10-26.md)
   * [CG November 9th video call](main/2021/CG-11-09.md)
   * [CG November 23rd video call](main/2021/CG-11-23.md)
   * [CG December 7th video call](main/2021/CG-12-07.md)
   * [CG December 21st video call](main/2021/CG-12-21.md)

</details>

<details>
<summary>2020</summary>

   * [CG January 7th video call](main/2020/CG-01-07.md)
   * [CG January 21st video call](main/2020/CG-01-21.md)
   * [CG February in-person](main/2020/CG-02.md)
   * [CG March 3rd video call](main/2020/CG-03-03.md)
   * [WG March 11th video call](main/2020/WG-03-11.md)
   * [CG March 17th video call](main/2020/CG-03-17.md)
   * [CG March 31st video call](main/2020/CG-03-31.md)
   * [CG April 2nd video call](main/2020/CG-04-02-Subtyping.md)
   * [CG April 14th video call](main/2020/CG-04-14.md)
   * [CG April 21st video call](main/2020/CG-04-21-Subtyping.md)
   * [CG April 28th video call](main/2020/CG-04-28.md)
   * [CG May 12th video call](main/2020/CG-05-12.md)
   * [CG May 26th video call](main/2020/CG-05-26.md)
   * [CG June 9th video call](main/2020/CG-06-09.md)
   * [CG June 23rd video call](main/2020/CG-06-23.md)
   * [CG July 7th video call](main/2020/CG-07-07.md)
   * [CG July 21st video call](main/2020/CG-07-21.md)
   * [CG August 4th video call](main/2020/CG-08-04.md)
   * [CG August 18th video call](main/2020/CG-08-18.md)
   * [CG September 1st video call](main/2020/CG-09-01.md)
   * [CG September 15th video call](main/2020/CG-09-15.md)
   * [CG September 29th video call](main/2020/CG-09-29.md)
   * [CG October 13th video call](main/2020/CG-10-13.md)
   * [CG November 10th video call](main/2020/CG-11-10.md)
   * [CG November 24th video call](main/2020/CG-11-24.md)

</details>

<details>
<summary>2019</summary>
  
   * [CG January 8th video call](main/2019/CG-01-08.md)
   * [WG January 16th video call](main/2019/WG-01-16.md)
   * [CG January 22nd video call](main/2019/CG-01-22.md)
   * [CG February 5th video call](main/2019/CG-02-05.md)
   * [WG February 13th video call](main/2019/WG-02-13.md)
   * [CG February 19th video call](main/2019/CG-02-19.md)
   * [CG March 5th video call](main/2019/CG-03-05.md)
   * [WG March 13th video call](main/2019/WG-03-13.md)
   * [CG March 19th video call](main/2019/CG-03-19.md)
   * [CG April 2nd video call](main/2019/CG-04-02.md)
   * [WG April 10th video call](main/2019/WG-04-10.md)
   * [CG April 16th video call](main/2019/CG-04-16.md)
   * [CG April 30th video call](main/2019/CG-04-30.md)
   * [CG May 14th video call](main/2019/CG-05-14.md)
   * [WG May 22nd video call](main/2019/WG-05-22.md)
   * [CG May 28th video call](main/2019/CG-05-28.md)
   * [CG June in-person](main/2019/CG-06.md)
   * [CG July 9th video call](main/2019/CG-07-09.md)
   * [WG July 17th video call](main/2019/WG-07-17.md)
   * [CG July 23rd video call](main/2019/CG-07-23.md)
   * [CG August 6th video call](main/2019/CG-08-06.md)
   * [CG August 20th video call](main/2019/CG-08-20.md)
   * [WG August 28th video call](main/2019/WG-08-28.md)
   * [CG September 3rd video call](main/2019/CG-09-03.md)
   * [CG September 17th video call](main/2019/CG-09-17.md)
   * [CG October 1st video call](main/2019/CG-10-01.md)
   * [CG October 15th video call](main/2019/CG-10-15.md)
   * [CG October 29th video call](main/2019/CG-10-29.md)
   * [CG November 12th video call](main/2019/CG-11-12.md)
   * [CG December 10th video call](main/2019/CG-12-10.md)

</details>

<details>
<summary>2018</summary>

   * [CG January 9th video call](main/2018/CG-01-09.md)
   * [WG January 11th video call](main/2018/WG-01-11.md)
   * [CG January 26th video call](main/2018/CG-01-26.md)
   * [CG February 6th video call](main/2018/CG-02-06.md)
   * [WG February 12th video call](main/2018/WG-02-12.md)
   * [CG February 21st video call](main/2018/CG-02-21.md)
   * [WG February 28th video call](main/2018/WG-02-28.md)
   * [CG March 6th video call](main/2018/CG-03-06.md)
   * [CG March 20th/21st video call](main/2018/CG-03-20v21.md)
   * [WG March 21st/22nd video call](main/2018/WG-03-21v22.md)
   * [CG April in-person](main/2018/CG-04.md)
   * [WG April 4th video call](main/2018/WG-04-04.md)
   * [CG May 1st video call](main/2018/CG-05-01.md)
   * [WG May 2nd video call](main/2018/WG-05-02.md)
   * [CG May 15th video call](main/2018/CG-05-15.md)
   * [WG May 23rd video call](main/2018/WG-05-23.md)
   * [CG May 29th video call](main/2018/CG-05-29.md)
   * [WG June 6th video call](main/2018/WG-06-06.md)
   * [CG June 12th video call](main/2018/CG-06-12.md)
   * [CG June 26th video call](main/2018/CG-06-26.md)
   * [CG July 10th video call](main/2018/CG-07-10.md)
   * [WG July 18th video call](main/2018/WG-07-18.md)
   * [CG July 24th video call](main/2018/CG-07-24.md)
   * [CG August 7th video call](main/2018/CG-08-07.md)
   * [WG August 15th video call](main/2018/WG-08-15.md)
   * [CG August 21st video call](main/2018/CG-08-21.md)
   * [WG August 29th video call](main/2018/WG-08-29.md)
   * [CG September 4th video call](main/2018/CG-09-04.md)
   * [WG September 12th video call](main/2018/WG-09-12.md)
   * [CG September 18th video call](main/2018/CG-09-18.md)
   * [WG September 26th video call](main/2018/WG-09-26.md)
   * [CG October 2nd video call](main/2018/CG-10-02.md)
   * [WG October 10th video call](main/2018/WG-10-10.md)
   * [CG October 16th video call](main/2018/CG-10-16.md)
   * [TPAC - CG/WG October in-person](main/2018/TPAC.md)
   * [WG November 7th video call](main/2018/WG-11-7.md)
   * [CG November 13th video call](main/2018/CG-11-13.md)
   * [CG November 27th video call](main/2018/CG-11-27.md)
   * [WG December 5th video call](main/2018/WG-12-05.md)
   * [CG December 11th video call](main/2018/CG-12-11.md)

</details>

<details>
<summary>2017</summary>

   * [CG May in-person](main/2017/CG-05.md)
   * [CG July 6th video call](main/2017/CG-07-06.md)
   * [CG July in-person](main/2017/CG-07.md)
   * [CG August 8th video call](main/2017/CG-08-08.md)
   * [CG August 22nd video call](main/2017/CG-08-22.md)
   * [CG September 5th video call](main/2017/CG-09-05.md)
   * [WG September 15th video call](main/2017/WG-09-15.md)
   * [CG September 19th video call](main/2017/CG-09-19.md)
   * [CG October 3rd video call](main/2017/CG-10-03.md)
   * [CG October 17th video call](main/2017/CG-10-17.md)
   * [CG November in-person](main/2017/CG-11.md)
   * [TPAC](main/2017/TPAC.md)
   * [CG November 14th video call](main/2017/CG-11-14.md)
   * [CG November 28th video call](main/2017/CG-11-28.md)
   * [WG December 6th video call](main/2017/WG-12-06.md)
   * [CG December 12th video call](main/2017/CG-12-12.md)

</details>
"
main/2018/CG-06-26.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 26 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: June 26, 4pm-5pm UTC (June 26, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email JF Bastien or Ben Smith to sign
up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Discuss [removing ahead of time bounds checks during instantiation](https://github.com/WebAssembly/spec/pull/820)
    1. TPAC Early Bird registration is open; discuss which days of TPAC we should use for wasm CG/WG
    1. Update on Layer 1 Compression (Katelyn Gadd)
    1. POLL: [Disallow IndexedDB serialization of WebAssembly.Module](https://github.com/WebAssembly/spec/issues/821)
    1. Discussion: [Why not have native wasm threads?](https://github.com/WebAssembly/threads/issues/95)
       1. This was originally discussed in the
          [May 2017 meeting](https://github.com/WebAssembly/meetings/blob/master/main/2017/CG-05.md#native-webassembly-threads---needed-for-v1),
          but there are some recent concerns that this may be difficult for non-web embeddings.
    1. Discussion: raise import/export limit to 1 million?
    1. POLL: [Allow creation of default i64 global values](https://github.com/WebAssembly/spec/pull/829)
    1. POLL: Include in v1 spec: [[spec] Normative: Support [Serializable] for WebAssembly.Module](https://github.com/WebAssembly/spec/pull/711)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Alon Zakai
* Andreas Rossberg
* Anirudha Gupta
* Ben Smith
* Ben Titzer
* Conrad Watt
* Daniel Ehrenberg
* David Piepgrass
* Deepti Gandluri
* Jay Phelps
* Katelyn Gadd
* Lachlan Sneff
* Lars Hansen
* Limin Zhu
* Luke Wagner
* Michael Ferris
* Michael Hablich
* Mike Rourke
* Pat Hickey
* Sven Sauleau
* Sergey Rubanov
* Thomas Trankler
* Ulrik Sorber
* Yury Delendik

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Titzer seconds.

### Proposals and discussions

#### Review of action items from prior meeting.

No discussion.

#### Discuss [removing ahead of time bounds checks during instantiation](https://github.com/WebAssembly/spec/pull/820)

Conrad Watt presenting
https://drive.google.com/open?id=1d9Gle2mkyLI3_DNF5oytEhUNK0gYg5L8

LW: I like your principled solution, it also matches how we handle the start function, we’re just queuing up something new.

AR: This just turns active segments into syntactic sugar. Perhaps active segments were a design mistake.

BT: Agree.

CW: Is anyone concerned that this may cause errors for programs that were previously rejected?

AR: Only makes previously illegal programs legal. We have to allow such changes in general, otherwise we could never evolve the language.

LW: I doubt this breaks any existing code.

BS: Should this be included in v1?

CW: Change is small.

LW: This is probably bundled with bulk memory operators

AR: I’m fine either way

#### TPAC Early Bird registration is open; discuss which days of TPAC we should use for wasm CG/WG

Sign up for TPAC. Which days are we attending. One day is the plenary day, Wednesday.

Raising the question.

Last time was 2 CG days, 1 WG day.

Day of GC types
Host bindings, SIMD, ES module integration

Tuesday, Thursday, Friday

#### Update on Layer 1 Compression (Katelyn Gadd)

We discussed this initially. Nothing much happened after this. Is there something I can do to move this along? It’s at the hand of the WG to determine what to do here. It is in a state that we need more research on this, perhaps with the spec interpreter or a real implementation. If it adds cost to loading modules then it’s not a win. Aside from whether we can implement this in the spec.

BS: Looking for help?

KG: I can move this forward some, but need help with others if possible.

BT: Karl Schimpf started work on some of this, perhaps that is a place to look.

KG: I’ve seen this, but it is pretty complicated. Perhaps doing something simpler. Making gzip work better. His proposal is very aggressive macro techniques, perhaps even that brotli can’t give you. Do you want to start with something simpler or just use brotli. With my tests, layer 1, bring gzip very close to brotli. But still not as good as brotli, perhaps it’s best to just use brotli. Does this get resolved in the spec repo? From the perspective of someone shipping v8 in chrome, do you want to

[... chair was unable to finish notes, since meeting was going to end abruptly]

#### POLL: [Disallow IndexedDB serialization of WebAssembly.Module](https://github.com/WebAssembly/spec/issues/821)

Move ahead with only indexeddb serialization for postmessage and message channel.

SA: 0
A: 0
N: 0
F: 9
SF: 0

#### Discussion: [Why not have native wasm threads?](https://github.com/WebAssembly/threads/issues/95)

This was originally discussed in the [May 2017 meeting](https://github.com/WebAssembly/meetings/blob/master/main/2017/CG-05.md#native-webassembly-threads---needed-for-v1), but there are some recent concerns that this may be difficult for non-web embeddings.

LS presenting

LS: working on nebulet. My issue with this proposal, it is not agnostic. Biased toward web. Possible to have ABI to create threads. Splits the ecosystem. Currently you need to create a thread in a worker, you need to call back into JS. I believe PH is doing something non-web wasm, and it seems to create an issue. I know that BS said we want to do this in the future, but I think we need to do this more quickly.

CW: Is there anything that you need outside of the ABI?

LS: I want to run the same wasm on the web, and in nebulet.

AR: I think we all want that eventually, but it may be more difficult than you think. Even ignoring JS, we would need to extend the weak memory model to more than just linear memory. Would need to generalize it to other forms of shared state: globals, tables, references. The current proposal intentionally avoids that as a first step.

LW: I think that a thread.create instruction requires a shared instance, which is complicated. In particular, we have no story for a shared table right now.

#### Discussion: raise import/export limit to 1 million?

Autocad is currently hitting the limit at 100,000.

AZ: They are using emscripten dynamic linking, if they moved to a new system they could use a smaller count. I don’t endorse this use case :)

LW: There are some issues w/ performance here.

AZ: We could use function pointers to do this, but we don’t have it yet. With some work it could be fixed.

JP: Any other issues w/ 1000000 vs. 100000.

LW: They’re both somewhat arbitrary.

SS: Can we increase this to full 32-bit?

BS: No, we want implementations to be aligned on what they can reasonably be expected to allow.

AI(binji): move this discussion to an issue.

#### POLL: [Allow creation of default i64 global values](https://github.com/WebAssembly/spec/pull/829)

AR: there is a slight gap in the JS API now in terms of what import objects one can create. We don’t allow the JS API to generate globals of i64, because of the init value parameter. Since there is a default for that, we could allow creating it, just without an explicit value. You can already create it, but not in a convenient way (by creating a temporary module exporting a global, which is silly).

LW: Can we support exporting functions w/ i64? [SS: it throws] perhaps we should be more lenient here.

[discussion about allowing coercing values to/from i64 for function exports and globals]

LH: If we make it work for globals we should have a general rule.

BS: We may just include this with bigint integration.

AR: This is a slightly different case. Not proposing any new conversion to i64, just allow absence of i64 argument thanks to default value.

N: 1
F: 8
SF: 2


#### POLL: Include in v1 spec: [[spec] Normative: Support [Serializable] for WebAssembly.Module](https://github.com/WebAssembly/spec/pull/711)

JP: Some clarification. Didn’t we say we didn’t want this for indexeddb? How does that work for structured clone?

DE: The spec allows you to differentiate between forStorage (indexeddb, history) and not (postMessage).

[unanimous consent]

LS: Shared globals?

LW: It has been discussed. When we ship SAB, then we can talk about shared globals. Then we have GC types, we can have other shared global types. Just like with shared memory, you’d have a shared flag that could be set.

#### Closure
"
wasi/2021/WASI-06-17.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the June 17 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: June 17, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Lin Clark
    - Email: lclark@fastly.com

### Registration

None required if you've attended before. Email Lin Clark to sign up if it's your first time. 

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Making it easier to draft WASI APIs (Lin Clark) [Slides](presentations/2021-06-17-process-update.pdf)

## Notes

### Attendees
- Lin Clark
- Mark McCaskey
- Till Schneidereit
- Dan Gohman
- Andrew Brown
- Luke Wagner
- Mingqiu Sun
- Pat Hickey
- Piotr Sikora
- Yong He
- Johnnie Birch


**Lin Clark:** I had originally intended to only talk about how to improve the proposal authoring experience.

But as I was preparing slides, I realized that it might be good to do a more general check-in.

For the past few months, we've been talking through a lot of the technical decisions that are critical to all the work happening in the different proposals. 

And we’ve been talking through concepts that set up a foundation for the secure and composable kinds of interfaces that we want.

While we've been discussing all that, Alex has been churning away on tooling that will help WASI make the switch to Interface Types. And this work unblocks us in a lot of ways. We can now start pushing existing proposals to Phase 3, and it will be easier to get started on new proposals.

So for this meeting, I wanted to switch gears for just a little bit, away from the technical concept discussions, and talk more about process and how we're going to drive this work forward. 

And I see two parts in that discussion. Pushing forward the in-progress proposals and then getting more proposals in progress.

For the in-progress work, there are a few things on my radar that are high priority.


So one is wasi-io. Dan is going to be focusing on pushing wasi-io to Phase 3, 
as well as some of the other proposals that are close.

Another priority for a lot of the folks here—us at Fastly, but also Envoy, Microsoft and others—are HTTP APIs. 

Piotr presented a few meetings ago and then Luke presented a way to unify the various ways of handling async. 

Now that our team is wrapping up our work on moving WASI to Interface Types, we’re going to start prototyping how that unifying approach to async could work, and we can iterate on the shape of the various APIs from there.

So that’s what’s on my radar, I’ll also be reaching out champions for other proposals after the Interface Types change and if anyone is looking to push towards Phase 3, we can talk about next steps.

I’ll pause here and check—does anyone else want to give an update on their priorities?

Ok, so the next part looks past the immediate future and is more long term—Getting more proposals started.

For this, we need to make it easier to propose new APIs. When I was first coming on as co-chair, I asked a few people who were interested in proposing WASI APIs but hadn’t actually started doing it what challenges they were facing. 

And here are some of the things that I heard:
- Understanding the whole ephemeral vs standard thing is a challenge
- They were overwhelmed or confused by the repo structure
- Understanding the s-expressions used in witx is hard

We already talked about how to solve the first one as part of the modularization discussion. 

All of the work that would be considered ephemeral today will be happening outside of the WASI repo, in repos dedicated to the new module that's being proposed. Then, once a proposal has made it to Stage 5, it will be moved into the standards directory in the WASI main repo. 

On the second one… I’ll be going through and streamlining the main WASI repo. I mentioned this in passing in a call a couple of weeks ago, but I wanted to give everyone here more context for that.


First off, we already moved meetings out of the repo. 

We’ll be getting rid of phases with the move away from the ephemeral system. 

We’ve never used the proposals directory. We based it off of the way that the WebAssembly CG repo is set up, which uses that directory as an archive of the discussion around proposals, but the standards directory will cover that for us, so we’re just going to remove that.

Ideally, we’ll be able to remove the design directory longer term. That contains the command and reactor ABI doc, which will move to the classic commands repo that Dan has been talking about. 

And longer term, we plan to move optional imports to the component model. So once that’s done, we can get rid of this. And then we’ll be going through the docs directory and updating those docs to reflect the new way of doing things.

So that covers the second point. Any thoughts or questions on that?

Now for the third one. Someone who’s new to WASI looks at a WASI API and immediately bounces off of it because they can’t make heads or tails of it. So it would be better for those people who will be authoring new APIs to encounter a syntax that looks closer to most languages. 

This is really only a spec authoring concern, so we don’t need to come up 
with the most perfectly elegant syntax. But we should have something that’s more inviting and readily understandable to new API authors

Till had some ideas around this, so he worked with Alex to create a draft syntax 
and a prototype for tooling that can consume that syntax and turn it into bindings. And to test it out as an author, Dan converted the wasi-io proposal to use it. 

Here’s a snippet using s-expressions, and the alternative for comparison. 

We’d be happy if proposal authors want to take a look or try it out and see if there’s anything missing. The prototype is available in the witx-bindgen repo, and I’ll add a link to the chat in a moment.

So that’s it for what I have prepared. It felt like a good time to check-in on this process and roadmap stuff, especially since things will be picking up a bit now 
that Interface Types support is landing. Happy to take the remaining time to talk through all of this more.

**Piotr Sikora:** WebAssembly is a moving target. Interface Types, Canonical ABI, Stack Switching, etc. It’s hard to design APIs around so many moving parts.

**Lin Clark:** The Canonical ABI is supported in witx-bindgen that Alex is working on. But in general, yes, a lot of pieces are still moving.

**Till Schneidereit:** Yes, it’s a huge challenge. The goals of the Canonical ABI and this new witx-bindgen are to pull together enough pieces to get to an island of stability. The goal is to get to a robust environment and production quality fairly soon, with enough design room built in to allow iteration going forward.

**Lin Clark:** It would be good to find a way to give new proposal authors the needed context to work in this new environment.

**Andrew Brown:** There have been a bunch of different tools for working with witx APIs; is witx-bindgen the new official tool now?

**Till Schneidereit:** Right now, the tooling in the WASI repo has the witx crate contains support for the current s-expression syntax and APIs, and witx-bindgen can be a tool for working with the new syntax and the canonical ABI for future snapshots.

**Andrew Brown:** Which tool should proposal authors focus on?

**Till Schneidereit:** witx-bindgen should be the main tool going forward.

**Andrew Brown:** When we we expect the canonical ABI PR to be merged?

**Luke Wagner:** We’re still waiting on some details, but we should hopefully be good to merge after the CG meeting next week.

**Till Schneidereit:** And this will unblock us from basing the next WASI snapshot on it, even if the ABI continues to evolve beyond that point.
"
main/2023/CG-09-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 12th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: September 12th, 4pm-5pm UTC (9am-10am Pacific Time, 18h-19h Central European Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Exception handling announcements [slides](presentations/2023-09-12-ahn-eh-announcements.pdf)
        1. Reminder: Upcoming vote on the exnref proposal in the Oct CG meeting
        1. Adding Ben Titzer as a co-champion to the proposal
    1. Vote to advance function references and GC proposals to phase 4 [30 min]
    1. Teaser: a DSL for authoring the spec [Andreas Rossberg, 30 min]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
  
 * Zalim Bashorov
 * Sergey Rubanov
 * Deepti Gandluri
 * Alon Zakai
 * Nuno Pereira
 * Derek Schuff
 * Thomas Lively
 * Slava Kuzmich
 * Ben Green
 * Asumu Takikawa
 * Heejin Ahn
 * Yury Delendik
 * Conrad Watt
 * Ilya Rezvov
 * Jeff Charles
 * Paolo Severini
 * Ryan Hunt
 * Ben Titzer
 * Saul Cabrera
 * Francis McCabe
 * Sam Lindley
 * Ben Visness
 * Adam Klein
 * Yuri Iozzelli
 * Luke Wagner
 * Andreas Rossberg
 * Fedor Smirnov
 * Dan Gohman
 * Ashley Nelson
 * Sean Jensen-Grey
 * Petr Penzin
 * Gordon Aplin
 * Andrew Brown
 * Dan Philips
 * Brendan Dahl
 * Manos Koukoutos
 * Ashley Nelson
 * Ioanna Demetriou
 * Daniel Hillerström
 * Jakob Kummerow
 * Chris Woods
 * Bailey Hayes
 * Emanuel Ziegler
 * Shoaib Kamil
 * Matthew Yacobucci
 * Matthias Liedtke
 * Marat Dukhan
 * Johnnie Birch
 * Shravan Narayan
 * talg
 * Sam Clegg
 * Dean Srebnick
 * Ghislain HUDE
 * Igor Iakovlev
 * Alex Crichton
 
 ### Proposals and Discussions



#### Exception handling announcements

HA presenting ([slides](presentations/2023-09-12-ahn-eh-announcements.pdf))

Introducing BT as co-champion

Couple of issues are linked in the EH proposal to reintroduce Exnref

Will be voting on the proposed changes (reintroducing exnref) in Oct in-person CG


#### Vote to advance function references and GC proposals to phase 4 [30 min]

AR presenting ([slides](presentations/2023-09-12-rossberg-gc-func-ref-type.pdf))

BT<in chat>: SA vote to advance both proposals to Phase 4

AT: The test covers the JS API behavior for structs and arrays, it’s ready and updated with the latest opcodes. What's missing is more tests for the casts that are used at the boundary; eg if you call a wasm function from JS. so we need that but the tests for objects are there.

AR: What about i31 interaction with that?

AT: I think that should be included in the tests for casts

AR: I should also thank TL and AT who both contributed to the core spec, and the JS spec.

AR: not sure about firefox implementation status?

RH: We are feature complete without array.fill, we have patches for it, they’ll be reviewed and merged soon. But they are very straightforward and I would consider our implementation feature-complete

DG: question about the JS API tests. In a lot of other proposal we do have those tests running on some engine before we merge  the spec. Have we run these tests against any engines?

RH: these from the upstream spec, or WPT or something else?

DG: I think the ones that were mentioned in bullet 3, the open PRs for JS Tests

AT: the current PR has been tested against the current JSC implementation that’s WIP. I tested a previous version against V8. I haven’t tested the latest version but I can do that soon.


AR: This is my update, we would be all good for Phase 4, and minor syntax tweak

RH: If this is purely about getting details of text syntax, I’m comfortable with that, fine with figuring it out in the next week or so, was there also a PR for i32… ref.i32?

AR: yes, that already landed

RH: Text format, I don’t think is as important. We’re not doing anything with the binary, anything significant. We can resolve that after.

AR: if people are worried, I would think the JS tests would be a bigger hurdle

AK <via chat>: Something not mentioned in the slides is that there are also toolchains targeting the proposal (in various levels of completion): Kotlin, Dart, Java, Ocaml (possibly others I'm not aware of)

DG: We could ask if there are any objections to going for Phase 4. Explicit objections and go from there. 
Does anyone have concerns or object to taking the poll today for both of these proposals together? Also, questions?

DG: i think that sounds good for the phase 4 poll then. DS should we do a zoom poll or a full poll?

RH: What’s the difference?

DS: One of these unanimous consent polls vs a full poll with the 5 options. If anyone is not able to use the zoom poll, just type in the chat and we’ll add those.

AR: I would suggest Zoom poll because it’s anonymous. Gives more honesty to the votes. I’ll have to stop screensharing to vote, unless there are further questions.

Poll:
 * SF: 25 + 3 in chat
 * F:16
 * N: 4
 * A: 0
 * SA: 0

LW: congratulations and great work by all the folks who worked on getting the consensus

DG: Quick note to GC subgroup. Those meetings worked well. Thank you to everyone who made them a productive environment and congratulations again. Very exciting.

TL: thanks also to our toolchain partners; without the input from Kotllin, Dart, J2wasm, this wouldn’t have been possible

CW: Tangential question. Given this is the second (somewhat) conditional phase 4 vote we’ve taken. When we conditionally moved SIMD to Phase 4, did we end up satisfying the spec requirements or are those still pending?

DG: my understanding is that this isn’t a conditional vote, i think there was enough consensus that the changes are far enough along that people are comfortable that the missing pieces will be resolved soon.

CW: I’m fine with interpreting it that way, still curious on the state of SIMD, though it’s less related to this discussion.

DG: We wanted a full discussion on profiles before we do a “final” phase 4 vote. So that’s scheduled for the next meeting in Sept. Then we’d have a vote on the deterministic profile. In the context of relaxed SIMD, all the spec tests, texts exist and the requirements have been satisfied. But we need to have that one final  discussion on the profiles proposal, and have a vote for making sure that we have a deterministic profile that exists, which the relaxed SIMD spec depends on before we can advance to Phase 4.

#### Teaser: a DSL for authoring the spec [Andreas Rossberg, 30 min]

AR Presenting ([slides](presentations/2023-09-12-rossberg-spectec.pdf))


TL: Is there a way to get involved or provide early feedback?

AR: We haven’t structured it yet, we have biweekly meetings, but not in a US friendly time, we have a repo, is it open?

CW: Currently not open but one of the things we’re preparing right now is to make a snapshot of it open. We want to have that available and discuss it at the in-person meeting. 

AR: We should get it to a stage for the MUC meeting so people can look at it in more detail

PP: This is potentially going to be a huge SWE effort. How was that taken into account?

AR: How will this be maintained over time is a question we’re asking ourselves. This will require some maintenance especially when we extend the wasm spec in non-trivial ways. We’ll also have to extend the spec in non-trivial ways. One thing to say is the risk is not that large because we can always go back. We can generate a version of the spec and keep manually maintaining it if this does not work out anymore. I would hope it’s not the case but a real problem we have to think about.

PP: let’s talk more about that on github

DG: in-person CG will be hybrid and there will be virtual attendance too. Please register so we can send you the details.


"
wasi/2023/WASI-03-09.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: March 9 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: March 9, 17:00-18:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. [Proposal: Union of Worlds](https://github.com/WebAssembly/component-model/issues/169) — [slides](https://docs.google.com/presentation/d/1HD05eyUya-fNYDHG1mfVdQGKPjL_8Sk4rS0TYJHe6aI/edit#slide=id.p) by Mossaka
        1. initial feedback
        2. related proposal: [wasi-cloud-core](https://github.com/WebAssembly/WASI/issues/520)
    2. New proposal: gpio/i2c/SPI API
        1. https://github.com/WebAssembly/WASI/issues/443
        2. initial feedback
        3. Vote: approve for Phase 1

## Notes

### Attendees
- Lin Clark
- Pat Hickey
- Dave Baker
- Brian Hardock
- Joel Dice
- Slava Kuzmich
- Emiel Van Severen
- Bailey Hayes
- Andrew Brown
- Colin Murphy
- Dave Hay
- Jeff Charles
- Zalim Bashorov
- Peter Vetere
- Chris Woods
- Ali Mohammadpur Fard
- Ben Green
- Kate Goldenring
- Piotr Sikora
- Sébastien Deleuze
- Dan Chiarlone
- Ivan Font
- Adam Mohammed
- Steve Schoettler
- Jiaxiao (Joe) Zhou

### Proposal: Union of Worlds

**Jiaxiao (Joe) Zhou**: Motivation that we want to rapidly form bigger worlds by combining smaller worlds. Will introduce new syntax. Will sketch out what that means for use statements. Simplest example: imagine we have two worlds, A and B. A is importing a, b, export c. B imports foo, bar, exports baz. We can union with the include syntax.

Include syntax should be able to specify a world path. The world path will be very similar to the use path. That means the world path will have qualifications like self, etc. Example of including external package.

More challenging example: name conflicts. Suppose we have two world, 1 and 2. Both include A and B. Besides basic include, have with syntax.

Last example, deduplication. A bit more fuzzy on this one. Want to solve transient dependency problem. Two worlds are including same. We can just rename because they are structurally the same.

Next thing is a little more subtle. Union subtyping. We define component subtyping as in the CM. What does this mean for union for worlds. This means that any component that can run in A or B is a subtype of C. This means that any imports in A or B, must be present in C. But goes reverse for exports, and exports of C must be present in A or B. But in example A, that doesn’t apply. This creates a subtyping issue we have to solve. There are two solutions. Short term, have to ask host binding to implicitly interpret exports as optional. This is just a short term solution because not explicitly expressed in wit. Longer term, need to make optional imports and exports.

Final question: can wit package store not only interfaces but also worlds?

**Bailey Hayes**: One thing that might help in the PR is an explainer for the difference between ""use"", ""include"", and ""with""

**Joel Dice**: My understanding from the way wit parser works is that you can have worlds at any point in the hierarchy. I think some proposals are already doing this. Don’t know if that helps.

**Jiaxiao (Joe) Zhou**: Yes, it does help.

**Bailey Hayes**: I have a particular question about C, when you intro-ed wit. Just the dedupe that might need to happen here. Trying to wrap head around instances. In your union mu-world, you include a as a1. My-world 1 and 2 are both importing a, so that’s why you need to rename. But you now have two imports of a, which I think would be disallowed. I don’t think renaming will resolve the issue.

**Jiaxiao (Joe) Zhou**: : That was a mistake in the slides.

**Pat Hickey**: I wanted to call something out that I’m nervous will be a problem Two worlds each import two different logging. People have to agree that they’ll import under same name. If you don’t do that, you can’t compass. So it’s like you better always name wasi-logging console, or you might be stuck later.

**Jiaxiao (Joe) Zhou**: If wasi-logging is being imported twice in two worlds. Does it make sense to run de-dupe first so we don’t have to handle the name conflict?

**Pat Hickey**: Does this mean that we only dedupe when name is same and not URL.

**Jiaxiao (Joe) Zhou**: That’s the kind of unclear part that I mentioned. Are we going to have structural or nominal typing.

**Pat Hickey**: I think I’m advocating for structural typing.

**Jiaxiao (Joe) Zhou**: I agree with structure matching. Actually more challenging because at moment wit parser doesn’t do any structure matching.

**Pat Hickey**: Guy Bedford and I were talking about a very related issue last night. But that’s a sidetrack.

### New proposal: gpio/i2c/SPI API

**Emiel Van Severen**: Proposal regarding embedded world. Until now, focus has mostly been on runtimes that work in very constrained envs. Also things like wasi-messaging, which will probably be used a lot since it introduces a lot of protocols. Until now, no real interface for hardware. Gpio pins, etc. I want to introduce these hardwares. Can take example of embedded Rust. SVD files created by board creators. These files can be parsed by a cli tool, and creates a lowlevel crate that allows you to write into specific registers. Devs don’t usually want that, so you often have higher level API called HALs. Two people might use different names, though. Idea for embedded HALs is to provide traits to offer compatibility. If you implement the traits, then can use across these different boards. I think WASI could be the mapping layer.

I think we should also maybe think about the high level APIs like LED. If we think about WASM, we think about completely agnostic. In this case, how do we fix? Maybe manifests like Android? LEDs could be desbribed as whether they are optional or not. This is where it’s a bit fuzzy for me. You probably have HALs that have to interface with memory. But since each has its own memory. How can I interact with the memory. If I use what’s in the module, it should be immutable. It’s a bit fuzzy for me.

Want to finish with is WebAssembly the solution. Could be a lot of work but I think the embedded world is very fragmented and this could help. Eventually people want to program in higher level languages, and I think wasm will enable this.

**Bailey Hayes**: This is great and I love it. I’ve also been thinking about this problem. I’ve been trying to make this work with WAMR and vxworks. Approach I’m interested in is WebIDL and a way to interop between that and wit. There are a few different APIs I think you’d be into like sensors, others. Would love to collaborate!

**Emiel Van Severen**: would love that.

**Kyle Brown**: On the subject before about different devices having different quantities of hardware, like LEDs. That seems like a good use case for wit templates. That then becomes part of the component. The component is then self-describing.

**Emiel Van Severen**: Haven’t looked at wit templates.

**Kyle Brown**: Have been several presentations.

**Bailey Hayes**: https://github.com/WebAssembly/component-model/issues/172

**Kyle Brown**: Talked about sharing memory between host and guest. Might be able to handle as a transparent optinmization at the end.

**Emiel Van Severen**: could be an option

**Chris Woods**: We’ve been doing a lot on this work too. We did some perf analysis. Like Bailey, would love to collaborate. Regarding the memory sharing. Rust version you showed is something you see a lot. There’s a nuance in understanding what you’re exposing. That shifts the requirement for response time to something outside wasm. The business logic is in wasm but the underlying real time control that would be done outside the wasm world. You see that with filesystems, server for network interface. With that, you don’t need to share memory. That would map quite well with the component model. But the smaller the device, the harder it is to make the case.

**Lin Clark**: Ok, poll for Phase 1. Any objections? No? Congrats on new proposal! Email me to get set up.
"
wasi/2021/WASI-11-18.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: November 18 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: November 18, 17:00-18:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. Renaming WAI to WI (@tschneidereit, 5 minutes)
    1. Walkthrough of proposal automation (@alexcrichton, 5 minutes)
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. _Sumbit a PR to add your agenda item here_

## Notes

### Attendees

- Lin Clark
- Amanieu d’Antras
- Shiqi Wang
- Johnnie Birch
- Sam Clegg
- Andrew Brown
- Alex Crichton
- Syrus Akbary
- Yong He
- Piotr Sikora
- Till Schneidereit
- Ralph Squillace
- Luke Wagner
- Jun Gan
- Dan Gohman
- Johnnie Birch
- Pat Hickey
- Steven Prine
- Bailey Hayes

### Renaming WAI to WIT

**Till Schneidereit:** New development. The two co-champions of the IT proposal talked about the extension that interface types have as part of the IT proposal, agreed to by CG. .wit, s-expressions type format. Came to the conclusion that IT proposal won’t need to make use of that file format, so won’t need the extension. That means that .wit is available as a file extension, and might actually be immediately useful in IT themselves. That part is up in the air, more to be looked into. With this new development… for context, we had talked about renaming witx to wai. Then issues were raised with that. To make it as straightforward as possible to avoid any complications, we’ll just take another file extension so that no one has to make any hard choices. `wi` would be the fallback, but looks like we can use the `wit` extension. 

Luke just joined, I explained that IT doesn’t need the extension and is happy to relinquish. With all that, idea is now to use wit as the extension. 

Any questions/comments?

**Syrus Akbary:** I would like to thank you for being flexible. I realize that you probably didn’t realize we were using that.

**Sam Clegg:** Are IT thinking that they don’t need file format?

**Luke Wagner:** When we started, we thought all you need is a type. Since then, we realized that you need other things like use statements. Difference between just the type and the IDL. So we started with naive assumption and realized that’s not quite what you want. What people do want to write is like what we’ve been calling witx. Let’s not claim .wit for something that no one will use. Witx was extended because we didn’t know what we were doing yet, but we are close with IT now.

### Walkthrough of proposal automation

**Lin Clark:** Now Alex will show wit in action and the automation he’s been working on.

**Alex Crichton:** What you see on your screen right now is the WASI repo, an ABI file. Idea is that we probably want autogenerated documentation, human readable as markdown, and make sure that it’s in sync.

This is Lin’s current proposal template, we will all be writing the wit.md files. This is the raw markdown file. Idea is that we have English prose, interspersed with code blocks. The proposal is the concatenation of the wit blocks. Idea is that we can take all the wit blocks, and then turn that into an abi file. The abi.md is automatically generated. This is intended to be very similar to the abi doc in the current WASI repo.

We now have wasi-tools, which has the tool for generating the abi. Everyone follow so far?

**Sam Clegg:** So flipping it so that you’re writing markdown and extracting?

**Alex Crichton:** correct

**Sam Clegg:** Why not flip it around, like with Java docs?

**Till Schneidereit:** That’s something that I pushed strongly for. Idea is that we want to have a low hurdle for people to write these things, and to optimize as much as possible for human consumption. This gives you a nice rendering by default on GitHub, if it was contained in wit then we don’t get that. So it’s optimizing for humans rather than machines, but it’s simple to machine read still.

**Sam Clegg:** Yeah, that’s kind of cool actually. So you can just search for triple backticks And then you’ll just have tools that validate what’s in the triple backticks.

**Till Schneidereit:** Our tooling is able to consume this as if it’s wit. Some tricks with line breaks.

**Andrew Brown:** Clarifying question. Tooling will be removed, and we should use wasi-tools. 

**Alex Crichton:** Yes, proposal template doesn’t have tools. Using tooling in GitHub actions that comes from elsewhere. But the idea is that wasi-tools is the canonical source for what it looks like to actually generate these markdown files.

**Andrew Brown:** OK, and your going to explain how we check in the markdown stuff and it would happen automatically?

**Alex Crichton:** Correct, wanted to make sure everyone understood the file structure.

**Till Schneidereit:** Reason for being in its own repo—Lin pointed out that it would be good for the main repo to be the channel for high-level updates about proposals without being spammed with tooling.

**Syrus Akbary:** Side question. I know you have witx-bindgen repo. Propose to move to WASI tools.

**Till Schneidereit:** wasi-tools has wasi specific tooling, also has external dependencies. This is an external dependency.

**Syrus Akbary:** Maybe a wit-tools?

**Till Schneidereit:** Where do you draw the line? Do all transitive dependencies need to be in WASI control? Quite frankly, speaking for the team that maintains that, we are also using this for other things and not all of that is suited for inclusion in WASI.

**Syrus Akbary:** I was meaning to ask that it might be a good idea to move the WIT repo to whe WebAssembly Community Group.

**Lin Clark:** The work of the W3C is specification. Implementations of the specification don't tend to get pushed into the org. W3C’s work, and WebAssembly CG, is about specification, not about coordinated implementation.

**Till Schneidereit:** The specification of the WIT file format is something that absolutely needs to be in the WebAssembly org because very clearly needs to be under control of the CG. And then I hope that there will be multiple implementations that make use of this file format.

**Syrus Akbary:** Yeah, I was asking because right now it seems to me like only one implementation exists, and it’s a case similar to the reference Wasm interpreter present in the WebAssembly proposals.

**Luke Wagner:** Someone separately could submit a reference implementation, but that would be a separate discussion

**Till Schneidereit:** At this time, we as the people who have built this implementation, we don’t have contributing the tool to the WebAssembly org on our roadmap

**Alex Crichton:** Any other questions about the general structure and the markdown formats involved

A couple things here, ABI files need to be kept in sync. Handling this with GitHub actions. 

[Walk through of CI]

**Bailey Hayes:** Is this ready to go?

**Alex Crichton:** Yeah! I think the only thing is to move proposal template and rename to wit.

**Andrew Brown:** So when are we going to move all the original proposals over to the new syntax and new template structure?

**Lin Clark:** I don’t think we have a set date yet. We can talk about that in this meeting.

**Till Schneidereit:** I know Dan has done some work updating existing proposals and seeing what snags we’re hitting. It also means changes for tooling like the sdk.

**Sam Clegg:** Is there some tool that can generate the C header file?

**Alex Crichton:** That’s going into realm of other projects. Whether wit-bindgen is suitable for wasi-libc is an open question.

**Till Schneidereit:** Most important part is the ABI description. Hopefully multiple toolchains for converting one to the other, and then you can check against the ABI.  Makes sense to evaluate overtime what makes sense to live in WebAssembly org and be generated by WASI specific tooling.

**Sam Clegg:** I’m sure that’s mostly wasi-libc. I think that’s a pretty important use case.
"
gc/2022/GC-06-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 14 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: June 14, 5pm-6pm UTC (June 14, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Alternatives to `let` (https://github.com/WebAssembly/function-references/issues/44)
    1. Discussion: Split externref out (https://github.com/WebAssembly/gc/issues/307)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Conrad Watt
- Zalim Bashorov
- Ryan Hunt
- Aske Simon Christensen
- Igor Iakovlev
- Rick Battagline
- Ben Titzer
- Sabine Schmaltz
- Alon Zakai
- Deepti Gandluri
- Adam Klein
- Slava Kuzmich
- Ilya Rezvov
- Manos Koukoutos
- Luke Wagner
- Emanuel Ziegler
- Francis McCabe
- Jakob Kummerow
- Andreas Rossberg
- Keith Miller
- Michael Knyszek
- Sam Clegg

### Discussion: Alternatives to `let` (https://github.com/WebAssembly/function-references/issues/44)

JK: (Summary of findings posted on GitHub issue.) Seeing compile time improvement with implemented no-annotation option because code size decrease offsets cost of inference.

CW: It looked like 20% of control flow blocks propagated information. After Alon’s latest post it seems that the tracking could track lots of locals that will never be used again. Annotations could save that work.

JK: Yes, but that should happen rarely.

BT: Question about implementation.

JK: Pseudocode on the github issue.

BT: If there’s an annotation, then you don’t need an undo stack, or do you?

ASC: Would still need the undo stack since the annotation doesn’t give you the state from before the block.

JK: In the case of a non-defaultable local initialized in a nested block then never used again, the annotation could save some work. OTOH, the initialization is very cheap.

CW: But Alon, you found that this was common, right?

AZ: Yes, at least in the current Java toolchain.

ASC: Temporary locals would cause this pattern as well.

AR: I would also assume this is a common case because compilers generate lots of locals.

TL: Hypothetically, could we be comfortable moving forward without annotations if that’s what further data shows is faster?

CW: Would still want to see a fairly large difference to introduce the inconsistency.

BT: Would this affect multiloops?

CW: Think multiloops could work either way.

TL: If annotations are meant to improve performance, I don’t see how you can argue to have them even if they decrease performance.

AR: There’s also future-proofness. For example in the past type inference would have been simple, but it isn’t any more so it’s good we have block types.

JK: Example of try blocks having to be treated conservatively.

ASC: This arose as a complication in Binaryen, which had a more precise control flow graph. Moving non-nullable locals into try blocks broke validation of locals.

CW: That seems to slightly lessen the argument that not having annotations makes things simpler for producers, since they have to do this extra work anyway.

BT: This is a question of priority. Performance or consistency?

CW: Hopefully both.

TL: Sounds like the clear path forward is to prototype annotations.

AZ: I am worried about the worst case scenarios where a single initialization causes N annotations due to deeply nested blocks.

AR: We’ve already swallowed that cost for block types.

AZ: I’ve never seen a large stack of blocks with result types.

AR: That’s because C wouldn’t have them, but other languages might.

BT: We can try to come up with a dense encoding of the bitmaps using e.g. run length encoding and LEBs.

KM: Sounds similar to what you would with ARM.

BT: Similar to how compilers group locals by type to take advantage of run length encoding of locals.

AR: This adds another dimension to the problem, but in principle is similar.

JK: Please suggest something concrete so we can prototype it.

AR: Will do.

LW: Can we take advantage of nesting to have blocks inherit information from outer blocks?

AR: Could also factor out block types into a shared section and use just an index.

JK: Another idea is to have two modes, one with a list of locals and one that inherits the parent block’s initialization.

AR: Instead of extending the type section, we could add something to the mini local declaration section inside each function.

BT: We should also consider adding zero bytes to type definitions as well for extensibility.

LW: … Iterating on the idea of having the local effects as part of function types in the type section. It might be more generally useful if we have pluggable inline caches or similar in the future.

### Discussion: Split externref out (https://github.com/WebAssembly/gc/issues/307)

AR: Could be annoying if every module has to choose whether it’s going to optimize for the host or Wasm representation.

TL: Agree policy question is tricky, but much better to put it in the hands of the toolchain rather than baking some arbitrary policy into the engine.

JK: It’s making costs more explicit since all the conversions and checks need to happen anyway.

AR: We’re trading complexity for some performance wins that might be relatively specific to the JS API. Not sure the complexity is worth it.

CW: Probably won’t show up in C API, but could show up in other embeddings with dynamic languages.

AR: The special case this is dealing with is where the host and Wasm heaps are shared. Other embeddings might assume some wrapping and unwrapping anyway.

JK: It’s more than just one check, too. Could add more differences in the future, making this a long if-else chain just to pass pointers around without having to look at it explicitly.

LW: An externref is kind of like a lazy internref. Source can try to keep it opaque as late as possible.

BT: When you re-wrap it, there’s an expectation that you get the same identity, so it has to have pointers internally.

MK: Already doing that for functions.

AR: Not sure you would want to do that for structs or arrays.

JK: Depends on how the JS API evolves. Currently plan is to not change representation on boundary for structs or arrays, but depending on future requirements we might need an object-object pair.

CW: Would like to settle this discussion and freeze the type hierarchy soon. It blocks other issues every time it comes up.

TL: Agree, we should thoroughly investigate the options for the current discussion and then settle it for real.

BT: +1, we’ve been holding the door open to changes here for a while. We should finish it.

AR: We should either keep the representation universes separate (with 3 different bottom types) or combine them.

BT: We can decide about whether funcrefs should be separate based on empirical data, and if it is worth splitting out, we can just keep all three separate.

ASC: If we solve the boundary problem by keeping externref types separate, do we still need funcref to be separate, though? That was solving the same problem.

JK: Yes, If we have these lazy extern types, then the performance problem with func <: any would be solved.

LW: There were some other optimization ideas that func </: any would allow, but no one is working on them now.

TL: What experiments are we trying to run?

CW: Seems that the only experiment would be try to show that the cost of implicit checks is not that bad. Ben was suggesting experiments for func <: any, but externref seems more fundamental.

BT: it’s still useful data though.

TL: Part of the problem is that J2CL currently doesn’t pass a lot of data across the boundary, so that will be hard to measure. Maybe we can do something with Dart?

AR: That sounds like a useful data point, too. If J2CL doesn’t pass much across the boundary, then maybe it doesn’t matter too much?

JK: No, that’s temporary and reducing the boundary surface was an explicit goal to get things going. More will be passed across the boundary in the future.
"
gc/2020/GC-08-25.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 25th video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: August 25th, 4pm-5pm UTC (August 25th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
1. Closure

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees
 
* Adam Klein
* Andreas Rossberg
* Benjamin Titzer
* Ben Smith
* Daniel Wirtz
* Emanuel Ziegler
* Francis McCabe
* Jakob Kummerow
* JP Sugarbroad
* Keith Miller
* Lars Hansen
* Luke Wagner
* Ross Tate
* Ryan Hunt
* Sabine
* Syvatoslav Kuzmich
* Thomas Lively
* Zalim Bashorov
* Zhi An Ng

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

### Proposals and discussions

Presentation: High-level summary of research into low-level GCs (Ross Tate)

Ross presenting: Typed Assembly Languages [[pdf](presentations/2020-08-25-tate-typed-assembly-languages.pdf)] [[pptx](presentations/2020-08-25-tate-typed-assembly-languages.pptx)]

[pseudo-instructions: slide 16]

TL: Here the type variables are explicit in the language, (beta) is part of the syntax. For a stack machine like wasm, we don't have type variables, but we do have implicit types on the stack machine. How would unpack/pack instructions work on Wasm, and would we need explicit type variables?

RT: few ways to do this, if you were going to use pack/unpack explicit instructions, you will have type variables on stack that are not real variables, phantom that are erased at runtime, or locals, use let. Unpack can be let with destructure.

TL: in places where we currently have type annotations we'd have to reference those local type variables.

RT: lot of this work has block labels parameterized by types

JS: It's worth noting that there are solutions to this problem that Ross is going to talk about that don't require this.

RT: will get to that, thomas wants more evidence what this will entails

[back to slides]

[slide 23]

TL: Validation is 50% relative to compilation time, but what does that include? Our compilation time is half of LLVM and v8… so what are they comparing to?

RT: don’t remember the details of the numbers, they say how long it takes to compile and valid. This is over 20 years ago, take that in mind when i give absolute numbers… for absolute, a MB file to validate takes 8 mins (this is a long time ago), don’t know what our times will be. We will talk about techniques that reduce both numbers substantially

[back to slides]

[slide 28, point on “Bounded polymorphism is undecidable”]

AR: Certain versions of it are undecidable.

RT: yup

[back to slides]

[slide 35]

TL: Am I correct in observing that this is very similar to schemes from SOIL proposal?

RT: Disconnect is that schemes are able to be converted to this, but this is more expressive than schemes.

[back to slides]

FM: What's the takeaway for GC?

RT: 1st we have to have a discussion about existential types. If we just want to have dynamic methods, that's ok, we just need to have a discussion. If we want to do existential types, then we should incorporate the strategies from Juan Chen et. al. since they've found how to do this for other languages.

FM: Anything special about Java that wasn't covered by C#?

RT: some differences… in the call tags stuff, talked about interfaces, the way these two do interfaces are difference, java has single instantiation inheritance, C# has multiple, some optimizations you can do for Java that you cannot do for C#. C# 1.0 was pre generics, only for arrays, we got arrays working and sketched for other generics as well. These are three biggest differences, value types, reification, interfaces. For C# to be compatible with java, has covariant arrays. In Java, string array can be an obj array, then when you assign value (e.g. int) to object array, there is a runtime check, to ensure all string arrays only contain strings.

BT: Is there any work on applying TAL to late binding? Separately compiled modules?

RT: yes, golden age group has a paper on that topic. Can pull it up for your afterwards. Other papers too. Also has stuff on JIT-ing too.

BS: include those links to papers that will be great, put it in meeting notes

[end of meeting]

### Closure

### Related Works

#### Laying Foundations for Typed Assembly Languages

* [Typed Closure Conversion](https://doi.org/10.1145/237721.237791) by Yasuhiko Minamide, Greg Morrisett, and Robert Harper [1996]
  * Introduced existential types for typing low-level closure operations
* [From System F to Typed Assembly Language](https://doi.org/10.1145/319301.319345) by 
Greg Morrisett, David Walker, Karl Crary, and Neal  Glew [1999]
  * Type-preserving CPS translation from System F to assembly-like system
  * Improved upon above paper's representation of closures
  * Introduced pseudo-instructions for manipulating existential types
* [Stack-Based Typed Assembly Language](https://doi.org/10.1007/BFb0055511) by Greg Morrisett, Karl Crary, Neal Glew, David Walker [1998]
  * Adds typed infrastructure for using a stack
  * Supports custom calling conventions, multiple return addresses, and stack-allocated data
* [TALx86: A Realistic Typed Assembly Language](https://research.cs.cornell.edu/talc/papers/talx86-wcsss-abstract.html) by Greg Morrisett, Karl Crary, Neal Glew, Dan Grossman, Richard Samuels, Frederick Smith, David Walker, Stephanie Weirich, and Steve Zdancewic [1999]
  * Compiles a halfway-point between C and ML, called Popcorn, to typed macroed x86
  * Introduces simple typestate for tracking initialization of freshly allocated memory
* [Scalable Certification for Typed Assembly Language](https://doi.org/10.1007/3-540-45332-6_5) by Dan Grossman and Greg Morrisett [2000]
  * Explores scaling typed assembly languages, such as type-annotation size and type-checking time
  * Found that, even with compression, omitting input types on non-merging blocks substantially saved size and time
* [Type-Safe Linking and Modular Assembly Language](https://doi.org/10.1145/292540.292563) [1999]
  * Links separately compiled TALx86 object files
  * Links are direct, i.e. no use of a run-time module-instance data structure
  * Linking is done statically, but hypothesized to scale to dynamic loading, though left unresolved due to there not being an obvious right choice for various policy considerations

#### Striving for Object-Oriented Languages

* [Object Closure Conversion](https://research.cs.cornell.edu/talc/papers/occ-tr-abstract.html) by Neal Glew [1999]
* [Type Dispatch for Named Hierarchical Types](https://doi.org/10.1145/317765.317797) by Neal Glew [1999]
* [An Efficient Class and Object Encoding](https://doi.org/10.1145/353171.353192) by Neal Glew [2000]
* [Simple, Efficient Object Encoding using Intersection Types](https://pdfs.semanticscholar.org/63e0/b115f6dc39771677c443197433678fdc8746.pdf?_ga=2.210686230.2016311759.1599250886-758140777.1599250886) by Karl Crary [1999]
* [Typed Compilation of Inclusive Subtyping](https://doi.org/10.1145/357766.351247) by Karl Crary [2000]
* [A Certifying Compiler for Java](https://dl.acm.org/doi/abs/10.1145/349299.349315) by Christopher Colby, Peter Lee, George Necula, Fred Blau, Mark Plesko, and Kenneth Cline [2000]
* [Type-Preserving Compilation of Featherweight Java](https://doi.org/10.1145/514952.514954) by Christopher League, Zhong Shao, and Valery Trifonov [2002]
* [Type-Preserving Compilation of Featherweight IL](https://flint.cs.yale.edu/flint/publications/filcomp.pdf) by Dachuan Yu, Valery Trifonov, and Zhong Shao [2002]
* [Precision in Practice: A Type-Preserving Java Compiler](https://doi.org/10.1007/3-540-36579-6_8) by Christopher League, Zhong Shao, and Valery Trifonov [2003]

#### Scaling to Major Languages and Existing Compilers

* [A Simple Typed Intermediate Language for Object-Oriented Languages](https://doi.org/10.1145/1040305.1040309) by Juan Chen and David Tarditi [2005]
  * Related-work section provides concise summary of the limitations of each of the above object-oriented works
  * First system to express Java arrays
  * Switches to predicative quantification over a domain-specific space (in this case, the class hierarchy)
  * Switches to nominal type system for reasoning about low-level records and data structures
  * Introduces nominal machinery for expressing custom casting mechanisms
* [Type-Preserving Compilation for Large-Scale Optimizing Object-Oriented Compilers](https://doi.org/10.1145/1379022.1375604) by Juan Chen, Chris Hawblitzel, Frances Perry, Mike Emmy, Jeremy Condit, Derrick Coetzee, and Polyvios Pratikaki [2008]
  * Retrofitted an existing optimizing C#-to-x86 compiler to produce typed x86 (based on above work)
  * Type-annotation size and type-checking times were both much better than prior (measured) works
  * Required modifying 10% of the compiler
* [Inferable Object-Oriented Typed Assembly Language](https://doi.org/10.1145/1809028.1806644) by Ross Tate, Juan Chen, and Chris Hawblitzel [2010]
  * Redesigned typed assembly to be completely intraprocedurally inferable (no pseudo-instructions necessary)
  * Required very little modification of the existing (non-type-preserving) optimizing C#-to-x86 compiler
* [Inferable Existential Quantification](https://www.cs.cornell.edu/~ross/publications/italx/existentialstr.pdf) by Ross Tate, Juan Chen, and Chris Hawblitzel [2010]
  * The theoretical framework for developing inferable existential types (for typed assembly languages)
"
main/2018/CG-02-06.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 6th video call of WebAssembly's Community Group

- **Host**: Google Hangouts
- **Dates**: Tuesday Febrary 6th, 2018
- **Times**: 17:00–18:00 UTC (9AM–10AM Pacific Time)
- **Location**: *same Google Hangouts link as before*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

None required if you've attended before. Email JF Bastien to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Rename memory operations (carry-over from the previous call)
    1. Advance [Sign-extension operators proposal](https://github.com/WebAssembly/sign-extension-ops)
        1. Spec text: https://webassembly.github.io/sign-extension-ops/
        1. Has tests and reference interpreter implementation
        1. [Should we add i32.sext](https://github.com/WebAssembly/sign-extension-ops/issues/1)?
    1. Advance [Import/export Mutable Globals proposal](https://github.com/WebAssembly/mutable-global)
        1. Spec text: https://webassembly.github.io/mutable-global
        1. Has tests and reference interpreter implementation
        1. [Should we add accessors for mutability and type](https://github.com/WebAssembly/mutable-global/issues/2)?
    1. Discussion: How should we hand out WebAssembly repos for proposals.
       (Brad Nelson)
        1. Current phases document implies we hand them out when appropriate,
           but is vague on what the bar is.
        1. [Phases Doc](https://github.com/WebAssembly/meetings/blob/master/process/phases.md)
        1. POLL: We should liberally hand out repositories for proposals
           brought to the CG. This can be done between meetings by directly
           contacting chairs at their discrection.
        1. POLL: We should require a CG meeting vote to create a
           github.com/WebAssembly repo for a Phase 0 proposal.
    1. Propose we create an unmanged-closures repo (Mark Miller).
        1. POLL: We should create an unmanaged-closures repo for this
           phase 0 proposal.
    1. Propose we create a js-types repo (Andreas Rossberg).
        1. [Overview](https://gist.github.com/rossberg/64693ede51116a57d820ff09df031e47)
        1. POLL: We should create a js-types repo for this phase 0 proposal.
    1. Future in-person meetings
    1. Other items TBD
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting notes

### Roll Call

* Arun Etmr
* Ben Smith
* Ben Titzer
* Brad Nelson
* Dan Gohman
* Deepti Gandluri
* Eric Holk
* JF Bastien
* Jacob Gravelle
* Lars Hansen
* Lin Clark
* Luke Wagner
* Malcolm White
* Marcos Diaz
* Mark Miller
* Martin Bing
* Michael Bebenita
* Michael Holman
* Michael Starzinger
* Paolo Severini
* Pat Hickey
* Peter Jensen
* Richard Winterton
* Sean Dinwiddie
* Sean Westfall
* Sergey Rubanov
* Sven Sauleau
* Trabelsi Marwen
* Tyler McMullen
* William Maddox
* Yury Delendik

### Opening

#### Adoption of the agenda

Adopted.

#### Find volunteers for note taking (acting chair to volunteer)

*JF volunteers*

### Discussions

#### Review of action items from prior meeting.

[Tracked in the meetings repo’s issues](https://github.com/WebAssembly/meetings/issues)

* [WebRTC hosting of video calls](https://github.com/WebAssembly/meetings/issues/157): let’s discuss on the issue.
* [Polymorphic work going forward](https://github.com/WebAssembly/meetings/issues/155). Good to land.
* Others: no update.


#### Future in-person meetings

Tentatively mid-April hosted by Fastly in SF, or Mozilla in Mountain View. Otherwise Google can find space.


#### Rename memory operations

*Ben Smith*

*carry-over from the previous call*

Renaming `grow_memory` and `memory_size` to `mem.grow` and `mem.size`. Let’s look at the PR #649 in spec repo and discuss next meeting.

* https://github.com/WebAssembly/spec/issues/627
* https://github.com/WebAssembly/spec/pull/649


#### Advance [Sign-extension operators proposal](https://github.com/WebAssembly/sign-extension-ops)

*Ben Smith*

Was split from thread repo.

        1. [Spec text](https://webassembly.github.io/sign-extension-ops/)
        1. Has tests and reference interpreter implementation

[Should we add i32.sext](https://github.com/WebAssembly/sign-extension-ops/issues/1)? *Decided not to do for now, nobody cares enough*

Requirements to enter [implementation phase](https://github.com/WebAssembly/meetings/blob/master/process/phases.md):

* Test suite has been updated to cover the feature in its forked repo.
* The test suite should run against some implementation, though it need not be the reference interpreter.
* Formal notation in the spec need not be updated.

It’s in Firefox nightly, and in spec interpreter (in the repo fork).

*POLL:* move this proposal to implementation phase?

*Unanimous consent*

*AI:* Ben to update the repo with the status, and JF to update the tracking issue.


#### Advance [Import/export Mutable Globals proposal](https://github.com/WebAssembly/mutable-global)

*Ben Smith*

Similar state, but not quite as baked.

        1. [Spec text](https://webassembly.github.io/mutable-global) (for core and JS APIs)
        1. Has tests and reference interpreter implementation

[Should we add accessors for mutability and type](https://github.com/WebAssembly/mutable-global/issues/2)? Might be covered by Andreas’ JS types proposal.

Implemented for immutable globals in Firefox. Lars is working on the rest. Haven’t seen any web compatibility issues so far.

* Michael: do we have usecases for this now besides threads?
* Ben: mostly trying to get ahead of web compat issues.
* Luke: also toolchains can put the stack pointer in there.
* Brad: also, nice shared libraries with threads.
* Michael: I’d like to have it stand on its own before we move forward.
* Ben: also, you can’t export an `i64` for now.
* JF: what if we ask for this feature to be used by a toolchain? The way we’ve worded the phase document is VM-centric, but really this is being driven by toolchains right now, so the requirement on having one implementation should be on toolchains.
* Dan: LLVM emits this today.
* Michael: I’m good with this if LLVM emits it today.

*POLL:* move this proposal to implementation phase?

*Unanimous consent*

*AI:* Ben to update the repo with the status, and JF to update the tracking issue.


#### Discussion: How should we hand out WebAssembly repos for proposals.

*Brad Nelson*

Current phases document implies we hand them out when appropriate, but is vague on what the bar is. Where does one request, who approves, and who creates the repo?

[Phases Doc](https://github.com/WebAssembly/meetings/blob/master/process/phases.md)

* File an issue on the design repo. Discuss there, and start basic design work.
* Add to schedule for the next CG video call or in-person meeting.
* Vote on whether we think this might be something we want to do at some point in time. Is it in scope for the CG?
* Repo and tracking issue are created.

*POLL:* We should liberally hand out repositories for proposals brought to the CG. This can be done between meetings by directly contacting chairs at their discretion.

*Tabled*

*POLL:* We should require a CG meeting vote to create a github.com/WebAssembly repo for a Phase 0 proposal.

*Unanimous consent*

*AI:* Brad and JF to update the phases proposal.


#### Propose we create an unmanaged-closures repo

*Mark Miller*

* Current repository: https://github.com/erights/wasm-linkage
* Mark: The name is bad.
* Mark: Some things in the GC proposal are good but can be moved out. Opaque functions. When linking different modules, they don’t have common indices. You also want protected entry points. Closures don’t imply dynamic allocation.
* Eric: has anyone else contributed to this repo?
* Mark: not right now.
* Dan: what do you expect the producers to do with this?
* Mark: example, Salesforce expressed interest. With module linkage rules, the module can be a perfect sandbox to prevent code to do anything unauthorized. Expressivity problem with least-??? Plugins. Similar to frozen realms in JavaScript. Don’t share address space (disjoin memories and tables), but have rich API which passes functions and closures. Leverages perfect sandboxing of WebAssembly, but with more expressiveness, and without needing dynamic allocation.
* Dan: what languages do you expect them to use?
* Mark: Google Earth does something similar, with plugins, in C++.
* JF: I think what Dan is getting to is how does a C++ toolchain know what to generate from this feature? Attributes, lambdas, etc?
* Mark: won’t be an accidental outcome of existing toolchains. Andreas suggested adding an explicit constructor which takes the function and the payload, and gives you a closure. He didn’t like it, but thinks it’s the natural way to do it.

*POLL:* We should create an unmanaged-closures repo for this phase 0 proposal (move Mark’s repo to the WebAssembly organization).

*Unanimous consent*

*AI:* Mark to coordinate with Brad. JF will create tracking issue.


#### Propose we create a js-types repo

*Brad for Andreas Rossberg*

[Overview](https://gist.github.com/rossberg/64693ede51116a57d820ff09df031e47)

Examine information in a module’s headers from JavaScript. This is a comprehensive introspection proposal. We have a few open issues in the design repo, this does more.

*POLL:* We should create a js-types repo for this phase 0 proposal.

*unanimous consent*

*AI:* Brad to work with Andreas on repo. JF to create tracking issue.
"
stack/2020/SG-12-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 14th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**: December 14th, 17:00-18:00 UTC (December 14th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants

Francis McCabe 
Daniel Hillerström
Ross Tate
Alon Zakai
Paul Dworzanski
Zalim Bashorov
Derek Schuff
Luke Imhoff
Sam Lindley
Luke Wagner
Rick Battagline
Ioanna Dimitriou
Thomas Lively
Heejin Ahn
Arjun Guha
Michał “phoe” Herda


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. [Requirements for stack switching](https://docs.google.com/presentation/d/1iDomt9mJdocJporD2PvsuOpjqemV_DyK8FRTK0QD9KY/edit?usp=sharing) (Francis McCabe) [35 mins]
   1. Call for presentations [2 mins].
   1. Next meeting [2 mins].
1. Closure

## Meeting Notes

### Adoption of the agenda

### Discussion:

FM presenting [slides](https://docs.google.com/presentation/d/1iDomt9mJdocJporD2PvsuOpjqemV_DyK8FRTK0QD9KY/)

LI: With stack walking, would C still need a shadow stack?

RT: Yes, C would. With a different “limited lifetime pointers” idea for interior pointers into the stack, many languages would be able to use that instead. But until then they need shadow stacks (possibly heterogeneous).

LI: What do you mean by heterogeneous?

RT: Mixed linear memory and reference values on the shadow stack.

LI: Runtime integration with run loop, had to manually exit to the JS event loop. Would be nice to not have to do.

FM: Depends on application. Database application w/ async IO would have to be more aggressive about returning to the event loop than even a video application.

RT: Could have a “check in with JS” event that is triggered every so often.

LI: If we get async/await in wasm would I still have to do requestAnimationFrame()?

RT: I think a recurring event to check a timer would work as well.

LI: I’m just looking for any places we can get rid of JS so we can have a better deploying experience.

FM: Different applications will have different requirements around this…

FM: One thing you might have noticed is that stack walking is not in the requirements right now.

LI: It seems like we will need stack inspection to find GC roots in Erlang anyway.

PS: We could use a shadow stack as well if we had to. The most important thing is having some form of stackful coroutines/green threads/continuations.

LI: You’re right, but it still seems weird that everyone needs a shadow stack and there isn’t better support for that.

LI: I hope we can do this in less than three years.

FM: Hopefully by making requirements solid up front we will be able to do that.

FM/RT: Want feedback on requirements.

LI: Definitely need JS Promise integration.

FM: One thing I (and others) would be interested in is whether there is anything missing from the critical use cases.

PS: You commented that async/await is the most important. For us the stackful coroutine aspect is critical as well, with entire separate stacks.

RT: And you gave a great presentation showing why that is.

SL: Do we have any other representatives who would like to similarly argue for the importance of async/await?

LI: I think Google really wants that.

FM: There are also many language implementors not present. It would be great if we could all reach out to them and let them know this is happening. Java, C# making moves in this space. Google believes async/await is important for its community of Wasm users.

RT: Luke mentioned earlier that being able to use JS Promises for async IO is important as well.

LI: It would be good to make sure that all languages with an “async” keyword can actually use the feature we design. It would be weird if they had to still ship a runtime.

SL: Interactions with existing implementations are going to be tricky, in particular JS’s existing async/await.

RT: Francis, you were saying that JS doesn’t want to add full async/await?

FM: If you are a regular JS function and you call a regular JS function, then you are entitled to believe that the only effects on the global state will be caused by the function you called. This is important to maintain for JS (and for many other languages) but the C world may be less clear on this. On the other hand if you’re an async function and you await on another async function, you know something else may happen to the global state in the meantime. We may need to have the equivalent of a critical region in our design.

RT: The JS community might give us pushback if we can capture JS frames through our async/await.

LI: Since async pollutes upward, on our JS boundary we need to guarantee that it’s async/await handlers as opposed to other event handlers. Do we need a standard JS async/await event for Wasm to use to make JS happy?

FM: Many languages have this, not just JS.

SL: We have some experience with this in the Links(?) language. Works fine if you’re not doing anything funny, but we need to think more carefully about this.

AG: If we had effect handlers and you knew you were calling an async JS function, that means enriching the JS-Wasm API in some interesting ways. If you don’t want to do that, you have to work with callbacks instead.

RT: I worked through the async/await example we had in the first-class stacks proposal, and it already doesn’t capture any JS stack frames. So could be possible to implement async/await in WebAssembly without having it spread out to JS. So you register callbacks on promises that have just Wasm stacks (rather than mixed stacks).

LI: That worked in our example. Either when the process exited or died, the `drop` on the promise executor would call reject on the Promise.

FM: Going to be more interesting with multiple modules/components. The limitations we have may reduce the utility of that because certain things like async I/O will be disallowed across those boundaries.

LI: If you’re in a web worker and you have to yield to the main thread to do I/O, do we consider that async I/O?

RM: My initial reaction is that there might be library support for that for a particular language, but it won’t be part of Wasm itself.

RT: Luke, are you getting at coordinating between different stacks on different threads?

LI: Web workers being processes rather than threads makes work-stealing schedules difficult.

RT: There are some limitations like not having concurrent access to JS processes. So for stack-stealing we would need to guarantee that JS objects aren’t shared.

LI: … JS considerations …

FM: Nothing we do is going to change anyone’s mind about how Web Workers work.

SL: We need to run experiments to see what kind of interactions there are going to be.

FM: The Web Worker story doesn’t belong to Wasm and we should not be trying to change that.

SL: My point is that there are many approaches we can try with varying effort and convenience.

LI/PS: Sad that we don’t have real threads on the Web.

RT: Current C stacks don’t have any references on them, so you can move those stacks to different threads potentially. We haven’t been able to investigate in much detail.

LI: Do we expect to test this in implementations? Wasmtime? I know the browser is difficult.

FM: Multiple places. We are looking at V8, others (e.g. Arjun) are looking at Wasmtime. V8 will take longer.
LI: We can try it as long as LLVM supports it in assembly.

TL: Not a problem to add it to LLVM assembly.

SL: Should we try multiple designs?

AG: Could quickly try multiple strategies in Wasmtime, would be significant work but could be done. Hard to do in toolchains as well.

SL: We should be able to do this quickly for research languages and e.g. the reference interpreter. But after that we need to work on bigger engines and languages.

LI: Does multicore OCaml compile to WebAssembly?

SL: No.

FM: Next scheduled meeting is December 28. Suggest to skip that meeting.

SL: Next meeting is January 11.

FM: No agenda for that meeting yet.

SL: Do you have someone who can talk about the implementation of async/await in V8?

FM: I will attempt to locate someone who can talk about this.

### Closure

"
main/2018/CG-04-03.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 3 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: April 3, 4pm-5pm UTC (April 3, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

None required if you've attended before. Email JF Bastien to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Future in-person meeting: [hosted by Fastly in San Francisco in April](https://github.com/WebAssembly/meetings/blob/master/main/2018/CG-04.md)
    1. Discussion: Should we drop the APAC timezone video meetings? (Brad
       Nelson)
       * POLL: We should drop the APAC timezone meeting.
    1. Discussion: Could we simplify the meeting signup process? (Brad Nelson)
    1. Create CG sub-groups
       * Following up from last CG meeting with feedback from the W3C
       * [Details](https://github.com/WebAssembly/meetings/issues/191#issuecomment-376171112)
       * Which sub-groups should we start with, and how should they function?
    1. HTML serialization of WebAssembly.Module objects (Daniel Ehrenberg)
       * https://github.com/WebAssembly/spec/pull/711
       * Where should this be in the process?
    1. Discussion: Process for assigning opcode numbers (Ben Smith)
       * We have some top-level opcodes left, and prefixes -- how to choose between?
       * Topic came up w/ bulk-memory-operations instructions
       * See [here](https://github.com/WebAssembly/bulk-memory-operations/issues/9#issuecomment-376300850)
       * Current polling results:
         * [Use opcode prefix for scarcely used opcodes](https://github.com/WebAssembly/meetings/blob/master/main/2017/CG-05.md#non-trapping-float-to-int)
         * [Use LEB128 after prefix](https://github.com/WebAssembly/meetings/blob/master/main/2017/CG-05.md#webassembly-threads-proposal)
         * [Reserve 0xff prefix, count backward from 0xfe](https://github.com/WebAssembly/meetings/blob/master/main/2017/CG-05.md#webassembly-threads-proposal)
    1. Consider alternate video service?
       * Unicko offers WebRTC based conferencing that apparently scales to 100:
          * https://demo.unicko.com/
          * https://www.unicko.com/pricing
       * Discussion: Should we prefer a WebRTC based solution? Should we try out this service?
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Attendees

* Alon Zakai
* Andreas Rossberg
* Ben Smith
* Bernhard Scholze
* Brad Nelson
* Conrad Watt
* Dan Ehrenberg
* Deepti Gandluri
* Derek Schuff
* Eric Holk
* Heejin Ahn
* JF Bastien
* Jacob Gravelle
* Lars Hansen
* Limin Zhu
* Luke Wagner
* Malcom White
* Mark Miller
* Pat Hickey
* Peter Jensen
* Richard Winterton
* Sam Clegg
* Sean Larkin
* Sean Westfall
* Sergey Rubanov
* Sven Sauleau
* Till Schneidereit
* Tyler McMullen
* Ulrik (?)
* Yury Delendik

## Meeting Notes

### Opening, welcome and roll call

1. Opening of the meeting
1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)

JF volunteers.

1. Adoption of the agenda

Luke seconds.

### Proposals and discussions

#### Review of action items from prior meeting.

Will discuss next week.

#### Future in-person meeting

[Hosted by Fastly in San Francisco in April](https://github.com/WebAssembly/meetings/blob/master/main/2018/CG-04.md)

#### Drop APAC timezone?

*Brad Nelson*

Discussion: Should we drop the APAC timezone video meetings? We’ve had a couple of iterations, and except for the first meeting we’ve had very few people show up (both for WG and CG video calls).

*POLL*: We should drop the APAC timezone meeting.

*Unanimous consent*

#### Simplify meeting signup

*Brad Nelson*

Discussion: Could we simplify the meeting signup process? We were concerned about folks just dropping in to the video call, Brad keeps a list of attendees to add to an agenda. We could have a form that people fill out to get the meeting URL.

Brad will do this.

#### Create CG sub-groups

* Following up from last CG meeting with feedback from the W3C
* [Details](https://github.com/WebAssembly/meetings/issues/191#issuecomment-376171112)
* Which sub-groups should we start with, and how should they function?

*AI*: discuss a the next in-person meeting.

#### HTML serialization of WebAssembly.Module objects

*Daniel Ehrenberg*

* https://github.com/WebAssembly/spec/pull/711
* Where should this be in the process?

Proposal to share across agent clusters. Maybe we want to do origin check instead of agent cluster check? We can’t serialize agent cluster to IndexDB.

* Mark Miller: what’s the rationale for not wanting to send compiled code between origins? In JS it’s sending a string.
* Dan: similar to CSP.
* Luke: what’s the google-side constraint?
* Brad: we’ve got folks trying to litigate whether we should postMessage at all. I’m having trouble with CSP analogy.
* Dan: more about how do we restrict code sharing across origins in JS? Even in WebAssembly we’d look at the response path.
* Brad: so one origin could compile, and pass the result to another origin.
* Mark: I don’t buy this. In JS the source text isn’t equivalent to module. It’s closer to function object. CSP prevents turning string to executable. If the function is passed…
* JF: I think we need that discussion with webappsec people. We haven’t agreed on threat model, and especially whether we distrust the import object. Because we do capabilities, you can’t do anything with a module without imports letting you do this.
* Dan: we should present 2 options to webappsec people.
* Mark: agreed, agents clusters don’t make sense.
* Lars: we want to also consider dynamic reoptimization, and timing attacks if we share compiled code.
* Brad: a browser could distrust shared origin code and recompile instead. Weird thing is module is both source and code.
* Ben: original idea was that agent cluster represented a process.
* Dan: IndexDB already has to cross boundaries though.
* Mark: IndexDB only has to do with origin boundary.
* Dan: right, if you close the browser, or open a new window.
* Mark: the module object is totally immutable as seen from JS?
* Luke / JF: yes.
* Mark: ignoring side-channel, sharing versus copying means it’s the same thing as strings. Not observable, not semantic difference.
* JF: timing observable though, if we recompile.
* Brad: for SAB we have things we guarantee about sharing versus copying.
* Brad: security team might force us to recompile.
* JF: can the spec even legislate this? Or can it just be a note?
* Brad: double-keyed iframe origins might even defeat this. Say a framework distributes its runtime.
* Dan: hadn’t realized that there were implementation reasons to care about agent clusters. Could reword to include agent cluster, but not for IndexDB.
* Mark: the agent is an event loop. Agent cluster is multiple event loops sharing memory, or processes with re-mapped memory say for SAB. Agent cluster is cross-cutting.
* Luke: can agent clusters span origins?
* Brad: I thought it was same origin as well.
* Malcom: “may be same origin” with iframes.
* Mark: ECMA doesn’t speak of origins in this context.
* Dan: “could be same origin” in the HTML spec.
* Dan: do we want wasm memory to be transferable?
* Luke: shareable, but not necessarily transferable.
* Ben: it goes in the transfer list only if detached.
* Luke: so transfering is straight out. With shared bit we can share. Might help remove a copy. But otherwise never.

*AI*: Dan to come back with update next meeting.

#### Process for assigning opcode numbers

*Ben Smith*

* We have some top-level opcodes left, and prefixes -- how to choose between?
* Topic came up w/ bulk-memory-operations instructions
* See [here](https://github.com/WebAssembly/bulk-memory-operations/issues/9#issuecomment-376300850)
* Current polling results:

  * [Use opcode prefix for scarcely used opcodes](https://github.com/WebAssembly/meetings/blob/master/main/2017/CG-05.md#non-trapping-float-to-int)
  * [Use LEB128 after prefix](https://github.com/WebAssembly/meetings/blob/master/main/2017/CG-05.md#webassembly-threads-proposal)
  * [Reserve 0xff prefix, count backward from 0xfe](https://github.com/WebAssembly/meetings/blob/master/main/2017/CG-05.md#webassembly-threads-proposal)

0xFE threads, 0xFD SIMD, 0xFC math. What do we do for the rest?

* Ben: 0xFC could be “misc” instead of “math”.
* Andreas: we talked about compartmentalization. Some implementations could leave out certain opcodes. Could make the spec easier.
* JF: I wouldn’t really worry about that, I think the spec should call out compartments.

*POLL*: use 0xFC as “misc” bucket instead of just“math”.

*Unanimous consent*

#### Consider alternate video service?

* Unicko offers WebRTC based conferencing that apparently scales to 100:

  * https://demo.unicko.com/
  * https://www.unicko.com/pricing

* Discussion: Should we prefer a WebRTC based solution? Should we try out this service?

People agree that solutions that are web standards are great. We could try out at in-person meeting as a dry-run.

*AI*: Brad to try it out.

"
main/2017/CG-09-19.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 19th video call of WebAssembly's Community Group

- **Host**: Google Hangouts
- **Dates**: Tuesday September 19th, 2017
- **Times**: 9:00am–10:00am Pacific Time
- **Location**: *same Google Hangouts link as before*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

None required if you've attended before. Email JF Bastien to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Summary of the [September 15th Working Group call](WG-09-15.md) (Brad Nelson).
    1. Discussion of coordination with Working Group (Brad Nelson)
       1. Discussion of [draft phases proposal](https://github.com/WebAssembly/meetings/blob/master/process/phases.md).
       1. POLL: We should revise the phases proposal to include recomendations on when browsers ship features.
       1. POLL: We should adopt the phases proposal.
1. Closure

## Agenda items for future meetings

1. [Versioning of external standard dependencies](https://github.com/WebAssembly/spec/issues/566).
1. Web platform test repository, discussion, and poll (Ben Titzer).

### Schedule constraints

None.

## Dates and locations of future meetings

| Dates                    | Location          | Host       |
|--------------------------|-------------------|------------|
| 2017-11-01 to 2017-11-02 | Santa Clara, CA   | Intel      |
| 2017-11-06 to 2017-11-07 | Burlingame, CA    | TPAC       |

## Meeting notes

# Roll Call

* Arun Purushan
* Bradley Nelson
* Dan Ehrenberg
* Deepti Gandluri
* Derek Schuff
* Edgar Pek
* Eric Holk
* Gabriel Dos Reis
* Heejin Ahn
* JF Bastien
* Keith Miller
* Luke Wagner
* Michael Holman
* Peter Jensen
* Richard Winterton
* Roberto Malatesta
* Sergey Rubanov
* Shiv Kishwaha
* William Maddox
* Paolo Severini
* Marcos Diaz
* Michael Ferris
* Pat Hickey
* Ulrik Sorber
* Unbug Lee

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees

1. Find volunteers for note taking (acting chair to volunteer)

Derek volunteers to take notes

1. Adoption of the agenda

Derek seconds.

1. Proposals and discussions
    1. Summary of the [September 15th Working Group call](WG-09-15.md) (Brad Nelson).

* In order to have W3C standard, we need a WG. WG has extra IP protections, and membership is restricted to W3C member organizations. However one of the first actions of the WG was to open the meetings to observation by CG members.
* We will reuse the same mailing list (i.e. one list for CG and WG)
* Wanted core language spec separate from JS/Web embedding. Had a poll on the agenda w.r.t. going ahead with the core spec even though JS/Web isn’t done yet. didn’t have poll. Need more discussion about the interrelationship of the various documents.
* Scheduled next WG call for Monday sept 25
* Tabled a couple items (one of which is now on the agenda below).
* [Note to the meeting](https://github.com/WebAssembly/meetings/blob/master/main/2017/WG-09-15.md#meeting-notes)

    1. Discussion of coordination with Working Group (Brad Nelson)
       1. Discussion of [draft phases proposal](https://github.com/WebAssembly/meetings/blob/master/process/phases.md).

 * Missing from PR is expectations on browsers and what they ship (make more explicit? Leave more wiggle room?) 
 *  Tried to be very explicit about entry/exit requirements (based on experience with TC39)
* (explanation of stages from PR)
* Phase 4 starts the patent clocks.
* Is it sufficiently explicit?
* Is this the process we want? 
* JF: which part of these phases can browsers ship in? Where do they know that they can ship and know that it won’t be changed/break? This doc leaves it a bit open, we should discuss/clarify.
* Browsers should be OK to ship at state 4, but can WG introduce breaking changes?
* BN: can imagine cases where someone finds something, but more likely there could be a patent issue. 
* But in that case we need lots of lawyers anyway.
* JF: concrete comparison: C++ library-evolution/language-evolution vs library WG. New features come from evolution groups, then trickle to core groups, who make it fit with the rest of the language. They do sometimes throw stuff back to the evolution group, but they don’t do substantial changes. This separation of concerns is good. WG can hold the philosophy of what the standard is, and CG chooses where it goes.
* BN: if you ship in stage 4, you expect things not to change.
* JF: in C++, compilers ship, but with an opt-in command-line flag. Not really an equivalent with the web.
* AR: we ship behind a flag, is this equivalent?
* anyone can ship behind a flag, this is for without a flag. Do we need to really wait for WG? 150 days is a long time. We should make a very explicit choice.
* threshold of how bad something can be broken to rewind?
* need an expectation that browsers can count on
* EH: how do other W3C standards handle this?
* BN: sometimes there’s only 1 impl, very far through the process. We are more aggressive about getting prototypes/multiple impls.
* JF: we also have non-browser embedders and tooling, which are more important for us. Tooling is not as tied to standards as the rest of the web.
* LW: entry to 4 is too early, exit of 4 to 5 is too late. Should we split out a 4.5? In past we vetted among impls, tools, stakeholders, etc informally.
* people shipping raises the bar to changes drastically.
* JF: suggestion: add floating item in 4: WG holds a vote on shipping? Has a high bar, we can hold the vote more than once. Can happen anytime during 4
* LW: SGTM
* BN: WG hold periodic polls on ship-worthiness of feature? Q: why is this not implicit in entering 4?
* LW: part of entry to 4 is CG consensus. Do we say WG really can’t do much at all?
* BN we do want to keep as much as possible in CG
* DE: analogy: no separation in TC39, but when something gets to stage 4, it waits for annual release, 90 day opt out, etc but nobody waits for that to ship. (just multiple impls, tests, spec, etc). There can still be editorial changes, tweaks, but browsers still expect stability. We can say that concerns should be brought up in CG.
* BN: concern in past was that WG gets handed a thing, they haven’t voted at all
* JF: balancing act between CG and WG: it could go back and forth as WG concerns about how things fit into web
* BN: add a step in 3-4 transition, that WG votes
* JF: you lose the clocks ticking in that buffer time. Now it’s baked into stage 4, and that doesn’t optimize the expected case of no issues (extra delay)
* BN: current core format is in WG and is really pretty done, high shipworthiness. [add votes in stage 4?]
* DE: *DS got a phone call :(*
* JF: we want to bake our process assuming good intent
* Proposal on table is, add to stage 4, periodic WG votes on shipworthiness of the feature, to inform shipping process of the browsers.

**POLL: We should revise Phase 4 to add the requirement that the WG periodically hold polls to measure the sense of how ""ship worthy"" the feature is to allow browsers to make decisions about when to ship.**

*Unanimous consent*

**Action Item:** Brad to do the pull request.


JF: we can always revisit the process, and should be willing to as we gain experience.
Want to get a sense of how people feel about this, so that if we revisit we can see whether we have gotten better consensus.

JF: reminder: this process is documented in [meetings GH repo](https://github.com/WebAssembly/meetings/blob/master/process/consensus.md).

**POLL: We should adopt the phases proposal (with the modification above).**

| SF | F | N | A | SA |
|----|---|---|---|----|
| 9 | 10 | 2 | 0 | 0  |

2 Neutrals: any comments?

MD: Don’t think it really matters, we aren’t going to need new stuff very soon?
BN: threads is coming up.
No other comments from neutrals.

1. Closure

*Adjourn*
"
stack/2023/stack-2023-01-30.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 30th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  January 30th, 17:00-18:00 UTC ( January 30th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Luna Phipps-Costin
Luke Wagner
Brendan Dahl
Daniel Hillerström
Ilya Rezvov
Lucy Menon
Zalim Bashorov
Deepti Gandluri
Thibaud Michaud
Sam Lindley
Andreas Rossberg
Adam Klein
Thomas Lively
Ross Tate

## Agenda items

1. Typed Continuations on Wasmtime (Luna Phipps-Costin)


## Meeting Notes

### Adoption of the agenda

### Typed Continuations in Wasmtime

LPC presenting [slides](https://docs.google.com/presentation/d/1Yh6fu0NfuyiBJAfPG2PaSlB4v9Tmot6yUNQVZcg5K1c/edit#slide=id.g201398232bd_0_83)

LPC: Static semantics were easy to implement as specified, but the dynamic semantics are specified in terms of rewriting rules, so we had to do something else.

LPC demos odd-even program running on wasmtime.

FM: You get rid of a stack when you finally return from it?

LPC: Yes, in theory. Right now it just leaks. We should be able to solve it with reference counting.

FM: I thought func.bind wasn’t happening?

LPC: Right, that and `let` both were removed from the spec proposals so we were able to avoid working on them. The initialization checking that replaced `let` was pretty easy to implement.

FM: What happens if you call a C function inside Wasmtime?

LPC: I’d have to try it! The stack switching is predictable. The trampoline between Wasm and C is super simple–just checks that your registers are saved. Should mostly just work.

FM: C programs don’t check for stack overflow.

SL: How big are the stacks?

LPC: Fixed, size provided when a fiber is created.

SL: We can experiment with this later.

AR: How does libmprompt handle this in a C environment?

SL: Uses virtual memory so it can grow without moving.

AR: Might fail, right?

AR: The efficient passing of arguments would probably require abandoning the fiber ABI and doing it yourself, right?

LPC: Daniel’s idea is to put the values directly on the stack.

DH: We can look at the types to figure out the size on the stack. Right now it’s just a box.

AR: I would think we would want ot pass these in registers eventually. What stack are the values written to?

DH: The receiving stack. Since you know the types, you can reserve space up front and pass a pointer. This should be compatible with the fiber API.

LPC: If you want to save it in a register, you definitely have to do something different since the fiber API clobbers saved registers.

AR: Did you have thoughts about what calling conventions you might use if you had full control?

DH: I haven’t thought about that.

AR: Would you want to match the function call convention or is there a reason to do something different?

DH: Not sure.

LPC: Could definitely pass in caller-saved registers.

SL: What’s the next step?

LPC: Benchmarking. Would love to see how we can start writing some programs and running them.

FM: Can you share an estimate of the number of hours you spent implementing it?

LPC: If you don’t count function references, it’s not that bad.

DH: We were completely new to the wasmtime code base and jumped right into function references.

LPC: Static semantics was not more than a week. Fiber.new and resume was another week. Then another very busy week working together.

DH: Most pieces are there already. It was just a matter of putting them together.

AR: How hard would it be for you to inline whatever wasmtime does, i.e. to generate the code directly for these primitives.

LPC: Wouldn’t be too bad. Would have to go through ISLE (wasmtime’s code gen backend infrastructure) because wasmtime is opinionated about generating arch-independent code.

DH: Hard part might be segmented stacks. Would want help from someone working on wasmtime.

AR: One thing you didn’t show is what the trampoline or liftoff code you generate for cont.new. You probably need to generate some code that handles the first resume and handles terminating the continuation, right?

LPC shows assembly implementing the trampoline. Q&A ensues.

SL: Who imposes the CFI requirements?

LPC: Yeah wasmtime ran this. If you mess it up you can’t run gdb on it.

RT: You system is implemented on top of the wasmtime Fiber API, so how does it do dynamic scoping?

DH: It always returns to the parent, so it needs to jump from parent to parent to find the correct handle. You get a “resume button” that takes you to the parent, and the parent changes over time as the continuation is resumed.

FM: The fibers API is very similar to the Python greenlets API.

RT: Right, where each fiber has a mutable reference to the parent.

FM: One of the things we’re concerned about in JSPI is calls to C code in a way that doesn’t crash the browser. Have you thought about that? Like switching to a central stack for C code?

SL: The obvious badness is the stack overflow.

AR: That’s orthogonal because you can always overflow the stack whether it’s been switched or not.

SL: Other spectrum of Francis’s question is what happens if you create a million stacks.

FM: Right, if they’re fixed size, then most of the space is wasted, but otherwise you need growable stacks.

SL: Would be interesting to try plugging in libmprompt or segmented stacks as a different backend. What’s V8 doing?

FM: Growable, segmented stacks.

IR: Will be presenting on this next week.

FM: We’ll also switch to a central stack to run C, which I would prefer not to do.

SL: But at least it’s safe.

RT: Another issue is that some systems assume the stack is linear and will break if that breaks.

FM: We have that problem. For example, if one of the C functions does a stack walk, and they do for profiling at least, then that caused a crash until we fixed it.

RT: Windows SEH has similar assumptions.

FM: Can you talk about exceptions?

LPC: Right, the dynamic semantics are not implemented yet in wasmtime.

SL: Do you know what the plan is for exceptions in wasmtime?

DH: Yes, they will be implemented. Someone else has committed to doing it.

RT: What portions have to be specialized for each platform?

LPC: Just the portion I showed earlier. There’s also a Windows-specific version of that code.

AR: So the allocation of new stacks is normal Rust allocation?

LPC: Yes. It’s an MMAP with a guard page.

RT: I thought Windows required allocating stacks with a special mechanism?


FM: That’s for CFI, but Microsoft hasn’t implemented that for Windows yet. Maybe the CFI in wasmtime is a different kind of CFI?

DH: This CFI is not control flow integrity, but control frame instructions, used for debugging.

FM: How does the segmented nature of the stack show up on GDB when there is a backtrace?

DH: It shows the jump to the other stack. It works quite naturally. You have a linear segment for each stack.

FM: Can you see that it is segmented?

DH: You see different addresses.

FM: I’d like this group to consider debugging in the future. We’re just starting to look at this in V8/DevTools. It’s hard to debug programs that switch stacks like this.

RT: Implementing effect handlers on top of the fibers API, have you found any deficiencies in the API for your purposes?

LPC: As mentioned before, the 2N crawl up and down the linked list is suboptimal.

SL: First step is to run benchmarks.

DH: Also had to extend the header format for more context for child stack pointers.

AR: So you wanted more control over the stack format than the library gave you? There’s also the problem of passive values in registers.

FM: My guess is that if you make all these changes, there won’t be much of the Fibers API left.

SL: Any good suggestions for benchmarks?

FM: Sieve of aristothenes with a separate continuation for each filter.

SL: Anything more real?

TL: Would need toolchain support.

DH: Talked to some people interested in compiling their languages down to this.

SL: We can take any program that uses asyncify.

LPC: For example ruby and go use asyncify for their stack switching.

### Adjourn



"
main/2017/WG-10-23.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 23th video call of WebAssembly's Working Group

- **Host**: Google Hangouts
- **Dates**: Monday October 23th, 2017
- **Times**: 9:00-10:00am Pacific Time
- **Location**: *Brad will email Google Hangouts link to WG members + registered CG guests prior to the meeting*
- **Contact**:
    - Name: Brad Nelson
    - Email: bradnelson@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. MIME type for wasm
       1. Discussion on if we should seek IANA allocation of 'application/wasm' as the mime type for WebAssembly content.
          * Added to Web.md along with streaming methods: https://github.com/WebAssembly/design/pull/991
          * Shipping in Chrome.
       1. POLL: We should pursue allocation of application/wasm with IANA.
          Working Group empowers the chair to register this MIME type on behalf of the WG.
    1. More spec repo logistics (Eric Prud'hommeaux)
       1. [ash-nazg](https://github.com/w3c/ash-nazg/) integration for spec repo
          * ash-nazg watches for PRs (not branch merges) from folks who are
            not members of a {W,C}G. There's an
            [interface](https://labs.w3.org/hatchery/repo-manager/pr/open)
            being substantial vs. editorial.
            For example, in the bottom of
            [this](https://github.com/w3c/ServiceWorker/pull/1190
            you'll see ""All checks have
            passed"". To the right, click <Show all checks> and you'll see
            ""ipr — PR deemed acceptable"".
            [Example Diff](https://s3.amazonaws.com/pr-preview/w3c/ServiceWorker/0aefcc4...948e077.html)
       1. Given that ash-nazg can be used for checking WG membership,
          should be consider using an https//github.com/w3c/webassembly-spec
          repo?
    1. Adoption of CG specification
       1. Discussion of state of the core specification + JS & Wed embedding.
       1. POLL: We should adopt the current WebAssembly core spec as
          a ""First Public Working Draft"" for WebAssembly Specification v.1.
    1. Future meetings
       1. Confirm next meeting date + time.
       1. TPAC
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Dates and locations of future meetings

| Dates                    | Location          | Host       |
|--------------------------|-------------------|------------|
| 2017-11-01 to 2017-11-02 | Santa Clara, CA   | Intel      |
| 2017-11-06 to 2017-11-07 | Burlingame, CA    | TPAC       |

## Meeting Notes

### Roll call

* Arun Purnushan
* Conrad Watt
* Edgar Pek
* Eric Prud’hommeaux
* Heejin Ahn
* JF Bastien
* Peter Jensen
* Luke Wagner
* Ben Titzer
* Derek Schuff
* Jacob Gravelle
* Daniel Ehrenberg
* Sam Clegg
* Limin Zhu
* Wouter van Oortmerssen
* Michael Holman
* Mircea Trofin
* Andreas Rossberg

### Find volunteers for note taking (chair to volunteer).

JF volunteers.

### Adoption of the agenda

JF seconds.

### Proposals and discussions

#### MIME type for wasm

*Brad presenting*

Discussion on if we should seek IANA allocation of 'application/wasm' as the mime type for WebAssembly content.

* Added to Web.md along with streaming methods: https://github.com/WebAssembly/design/pull/991
* Shipping in Chrome.
* JF: only implication is for streaming APIs?
* Brad: correct. In particular, Chrome will treat it as an error if the response doesn’t have the right MIME type. This was suggested as a security mitigation (although you can already spoof JavaScript).
* Luke: Firefox also does application/wasm.
* Brad: I tried to add it to Python’s source so SimpleHTTPServer would make it work, got pushback because not official.
* Luke: did the same [with GitHub pages](	
Luke Wagner	9:07 AM
https://github.com/jshttp/mime-db/blob/master/src/custom-types.json#L267). Should work soon.


**POLL:** We should pursue allocation of application/wasm with IANA. Working Group empowers the chair to register this MIME type on behalf of the WG.

**Unanimous consent**

#### More spec repo logistics

*Eric Prud'hommeaux presenting*

  1. [ash-nazg](https://github.com/w3c/ash-nazg/) integration for spec repo
    * ash-nazg watches for PRs (not branch merges) from folks who are
      not members of a {W,C}G. There's an
      [interface](https://labs.w3.org/hatchery/repo-manager/pr/open)
            being substantial vs. editorial.
            For example, in the bottom of
            [this](https://github.com/w3c/ServiceWorker/pull/1190
            you'll see ""All checks have
            passed"". To the right, click <Show all checks> and you'll see
            ""ipr — PR deemed acceptable"".
            [Example Diff](https://s3.amazonaws.com/pr-preview/w3c/ServiceWorker/0aefcc4...948e077.html)
  1. Given that ash-nazg can be used for checking WG membership,
     should be consider using an https//github.com/w3c/webassembly-spec
     Repo?

There are two tools: diffing tool, and membership check tools.

POLL: The group’s advice to Rossberg is that we should add the diffing tool to the spec.

**Unanimous consent.**

* JF: what’s interesting is that with our current process we fork each repo for the CG to work on, and then nobody but an editor touches the spec repo. Each of those forks could benefit from this tool.
* Brad: Eric had mentioned being under the W3C github organization.
* Eric: tooling is better supported there. May be 5% better for our life.
* JF: I’d like to discuss separately. Advantage of our own org is we’re admins for it. We can just fork without asking anyone, and adding tools is trivial in the github API. I like having everything under one roof.
* Brad: How weird does this make us? What do other W3C groups do?
* Eric: I’ll say 5% (random number) of the groups don’t live under the W3C org.
* Brad: I assume there will be copies of the final documents under the W3C.
* JF: I think it’s useful for the tooling to tag contributors as coming from CG / WG for all repos under the WebAssembly github org. Some repos have content which isn’t spec, but may be standardized in the future.

**POLL:** The group recommends to Rossberg that we set-up ash-nazguh tied to CG membership on all repos other than the spec, and for WG membership on the spec repo. Ideally the tooling would identify membership in WG and CG for all repos.

**Unanimous consent.**

#### Adoption of CG specification

*Dan Ehrenberg presenting.*

Discussion of state of the core specification + JS & Web embedding.

Sent [a PR to the WebAssembly spec repo](https://github.com/WebAssembly/spec/pull/591) adding JS / Web standardese. Some things are still missing (source map, structured clone, CSP). Please send comments.

* Brad: my understanding is that source map should be out of scope because even the main source map document isn’t official.
* Andreas: I already reviewed it. Looks good so far. Only issue is WebIDL talks about very Web things, like DOM string and DOM exception. I don’t know what they mean in a non-Web context.
* Dan: it just has a funny name, but it’s not Web specific.
* Brad: would we be comfortable iterating on this towards a first draft?
* Dan: and before we have CSP integration, and structured clone?
* JF: I would drop CSP for the first version, and only do structured clone.
* Mircea: there’s divergence, I’m not sure we want structured clone either. We might want different constraints.
* JF: OK dropping structured clone as well for first version.
* Brad: I think that makes sense. Will avoid confusing the issue. I like that we capture the points of strong convergence between browsers in the docs.
* Dan: are tools a point of strong convergence? Developer-facing display conventions (call stacks, etc).
* Brad: no.
* JF: I think this is minor, let’s discuss offline.
* Brad: agreed.
* Brad: given that we can drop CSP and structured clone, are we comfortable with these 3 docs as a first public draft.
* Mike: I definitely have objections. Are we adopting it? It’s just a pull request right now.
* Brad: it’s true that we haven’t looked much yet, but it’s just a transcription of what was in Web / JS design repo.
* Dan: I’d definitely appreciate feedback. Some of the changes weren’t typographical.
* JF: I don’t think we’re in a rush.

**POLL:** We should adopt the current WebAssembly core spec + WebAssembly JS API + WebAssembly Web API as a ""First Public Working Draft"" for WebAssembly Specification v.1. Intentionally leaving out CSP and structured clone (to be addressed in a future version)

*Brad tables the poll in light of Mike’s objection. We should look at the document more and take our time.*

#### Future meetings

TPAC coming soon.

Confirm next meeting date + time. Wednesday at 9AM on November 15th.

Closure

*Adjourned*
"
wasi/2021/WASI-11-04.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: November 04 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: November 04, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Poll: Adopt a release process that versions interfaces separately and uses major/minor/patch tuples (aka semantic versioning) to express the versions. More info in https://github.com/WebAssembly/WASI/issues/450 (@linclark, 5 min)
    1. _Sumbit a PR to add your topic here_
    1. Continue from last 2 meetings: Walk and talk through some example WASI component scenarios (@lukewagner, remainder of the time) ([slides](https://docs.google.com/presentation/d/11lY9GBghZJ5nCFrf4MKWVrecQude0xy_buE--tnO9kQ))

## Notes

### Attendees

- Lin Clark
- Saúl Cabrera
- Dan Gohman
- Ben Titzer
- Shiqi Wang
- Piotr Sikora
- Till Schneidereit
- Steven Prine
- Jun Gan
- Mingqiu Sun
- Bailey Hayes
- Amanieu d’Antras
- Yong He
- Luke Wagner
- Pat Hickey
- Johnnie Birch
- Sam Clegg

### Poll on Semantic Versioning

**Lin Clark:** Poll is to version APIs separately and use semantic versioning for that. Consensus vote. Anyone object?

I will take that resounding silence as enthusiastic support!

### Walk and talk through some example WASI component scenarios 

**Luke Wagner:** Last time talking about versioning. Helped me see that some of the examples should have versioning. Seemed like versioning info should go in package.json, etc. Syntax is different, but same thing in wasm.

Now cargo.toml doesn’t just have this one thing. Types will be internally visible to Rust. Same with origin and cache. On exporting side, they generate a trait that you implement. With that, we realized that you’re exporting an instance that supports an interface. Capitalization is different, because it gets kebob cased for this ecosystem. 

This is the updated way it looks in the Rust code.

**Ben Titzer:** What is kebob case. 

**Luke Wagner:** Where you have dashes between. It’s what’s used in package management ecosystems commonly.

**Ben Titzer:** Makes sense

**Luke Wagner:** In the wasm, only change is to include the version. This would be the minimally compatible version. Anything in that series before bumping to major should be compatible, so would also be compatible with this component.

Now there’s a nice symmetry between Rust and JS, since JS doesn’t have macros.

Any questions?

Redirect404 Rust Impl [slide]

If I have two backends, have import-as in .toml. Looks the same in wasm as before. We’ve basically wrapped the previous thing in a named instance.

NormalizingCache Rust impl [slide]

Looks the same as normal, non-component dependencies.

**Ben Titzer:** How exact is the versioning here

**Luke Wagner:** Follows the ecosystem rules.

**Piotr Sikora:** Quick question, shouldn’t version be in generated Rust.

**Luke Wagner:** Uses the conventions of the ecosystem.

Would capture the exact information from cargo.toml and put it in the name in wasm. Gets transformed based on the target ecosystem for publishing. Still an open question.

JavaScript looks about the same.

In this version, I’m using two deps. Not syntactically much different than before. Got a static DAG, when I instantiate at runtime, imports instances that might be shared with others. Shows up concretely in importing an instance. I don’t get to force that I import the same instance.

Interesting thing is when I want to lock this down. This is that .lock convention, but doing it in the package. Before I’ve done any locking, don’t know what I get at runtime. I want to run a resolve and spit out a new component.lock.wasm. It will embed precise versions. At runtime, I get an instance that contains the dependencies. In the generated wat, the interfaces are still semver queries, but other components are precise versions that I’ve included. This is using module linking as an executable package lock file.

Any questions?

Module imports could easily have been nested imports

**Bailey Hayes**Have you considered including a sum file?

**Luke Wagner:** Great point—yes, you could imagine integrity= some SHA hash. Then I’m being ultra precise.

[discussion between Lin and Till on semver resolution in npm and cargo around differences between npm and cargo in resolving queries specified with only the first two digits, e.g. 1.3]

Non isomorphic case a little tricky, where do we put it in package.json/cargo.toml. What if we had a linker script?

I’m going to import dependencies, but as private dependencies, they come in as modules that I instantiate privately. 

…

A little like dependency injection that was popular a decade ago. Academics were wondering “Isn’t this just perameterization?” And that’s what we’re doing here.

**Sam Clegg:**These private instances and private deps, that’s just wasm specific, right? 

**Luke Wagner:** Yes, but talking to the JS folks and they see use cases, maybe something using Realms. But at the moment, Wasm specific.

**Sam Clegg:**And the purpose here is to avoid depending on first class instantiations. Trying to do something more declarative?

**Luke Wagner:** Yeah, really want to have this declaratively.

**Sam Clegg:**Yeah, and we don’t have runtime constructs in Wasm yet, so we don’t want to depend on JS.

**Luke Wagner:** And this allows me to optimize and cross-module inline. In this case, I’ve injected JS in between so limits optimizability, but 

**Sam Clegg:**Once we have fully dynamic runtime, I worry that it will just be that.

**Luke Wagner:** Good point, but you know how we do Wizer? Hoping we could potentially snap shot. But, at same time, JS doesn’t look ergonomic in this case. For example, some default stuff is happening with types which makes it hard to use WebAssembly.instantiate.

**Sam Clegg:**Makes sense, thanks

**Luke Wagner:** What if I didn’t want to do hooking or wrapping. Did I need to pull in a whole JS engine to link these up?

Wat is quite verbose for this. What if I could just write this, and then we could have a single tool that generates the wat for us.

CacheyRedirector via (hypothetical) linker script [slide]

**Sam Clegg:**This is link an easy way to write wat files. Could be useful for writing wat in general.

**Luke Wagner:** Now that I think of that, that takes us down a rabbit hole.

**Sam Clegg:**But just doing outer wrapper

**Luke Wagner:** Doing logically the same thing as Docker compose. That’s the point, to specialize on just the composition part. 

Here’s what we ellided. Default propagation of imports.

Any questions?

One kind of fun thng is that this is an executable linker script. I think that’s cool—one thing that we keep using to build bigger and bigger things.

Seventh component [slide]

Eight component [slide]

I want to locally test using mock components. I have filesystem natively, but not backend and cache. I have this component. It runs in a prod host. It’s a single wasm file, with nested components etc. What I’d like to do for my local testing scenario is create instances of the mock backend and cache and then wrap it and scripts my exports. 

Final thoughts

This is not normal function composition, like the Unix pipeline model. This is more like HOC functions plus currying. This is a far more powerful form of composition because it allows recursive control flow. If we want to do any of these HTTP scenarios, I need this more powerful form of composition. ReadThroughCache wouldnt’ work with simpler composition. I think prev component models stopped here, because they didn’t have imports. I think that’s in part what prevented it from working in previous iterations. But some of the research ones did.

**Ben Titzer:** There was a component system from Java called Jiazi(?). I think it was done by Matthew Flat.

**Luke Wagner:** This units model has propagated through lots of things. Talked with him after stack switching group. Was it any good?

**Ben Titzer:** I remember reading the paper when it came out.
"
gc/2023/GC-06-27.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 27 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: June 27, 4pm-5pm UTC (June 27, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Status checks
    1. Discussion: final opcodes ([#372](https://github.com/WebAssembly/gc/pull/372))
        1. Type encodings ([#337](https://github.com/WebAssembly/gc/issues/337))
    1. Discussion: extending type difference to heap types ([#381](https://github.com/WebAssembly/gc/issues/381))
    1. Text format for final types ([#333](https://github.com/WebAssembly/gc/issues/333))
1. Closure

## Meeting Notes

### Introduction of attendees

 - Thomas Lively
 - Ashley Nelson
 - Alon Zakai
 - Bruce He
 - Zalim Bashorov
 - Andreas Rossberg
 - Jakob Kummerow
 - Nick Fitzgerald
 - Manos Koukoutos
 - Igor Iakovlev
 - Luke Wagner

### Status Checks

TL: Implementing finally types in Binaryen. Because of the encoding differences, looks like it will take a two-step thing where we update Binaryen and then tell producers to update what they output and then update Binaryen again to have more restrive output. Also been working on spec documents. AR is putting out many PRs. I did a couple for bulk_array instructions. Hope to get that one landed today. Anything else?

AR: I think there is almost PRs for everything, but there hasn’t been progress for reviewing them unfortunately. The main bulk missing is the prose for execution. Other than that, it’s only small things for now.

TL: Conrad, when he emailed to say he couldn’t make the meeting, said he is working on reviewing the first of the PRs.

AR: The two on CW’s plate are the type system stuff so I think he should look at that. Of course the more eyes the better.

TL: Another development is I reserved a slot at the Sept 12 meeting to deliver an update on GC. If everything goes well, we can update that from an update to a vote.

NF: Wasmtime, almost done parsing and validating, babystep progress.

AR: Parsing you mean decoding or binary format or text format?

NF: Both. 

AR: Yes because of the opcode reshuffling we still have to do.

NF: Been working off the google doc so far.

### Discussion: final opcodes ([#372](https://github.com/WebAssembly/gc/pull/372))

TL: Disagreement about whether we should leave holes in the space or not. AR you were arguing it was useful holes for future extensions. BT was arguing not that useful. From my personal experience in SIMD, it didn’t turn out to be useful when we tried it out. Unclear how that generalizes. Seems minor and not worth a lot of debate time. We don’t have a critical mass but we could have a popularity vote on the GH issue since I don’t think it matters too much. Unless you feel more strongly AR?

AR: Not a big thing but what we did so far worked, so I don’t see a reason to deviate in this case. Especially since most of the counter arguments are not critically strong either. Doing what we did so far, not just jump around.

TL: We’re not close to taking up the second byte in the LEB encoding, are we? That was a consideration for SIMD as well. If we’re not close, I can’t say I care at all.

AR: Right, I think we’re not even ½ of that space, even with all the gaps. One thing I mentioned in the reply is that it’s not the gaps, it’s having nice groupings so if you have FB3 you know it’s an array instruction, which I find useful sometimes. Not a biggie.

TL: BT is not here, he felt the most strongly, so we shouldn’t proceed without checking in with him but i’m happy to go with your proposed encoding solution and see if we can get BT to go along with that, then close out the issue. Any other opinions on the final opcode numbering?

JK: Posted on GH, I’m also in favor of not having holes because I don’t see the point. All the reasons are totally minor, I agree it’s not a huge issue. Only thing that cares about the opcode design is the decoders and they don’t care if they are particularly in order. My biggest reason for not leaving holes is I think the likeness of the holes having appropriate size is very small. 8 x i31 instructions, if we happen to adopt the 8, there would be a natural place to stick them. If we are going to add 2 more instructions or 20 more instructions, it makes sense to just append them at the end. Very mild preference to just compact but not worth discussing at all. 

TL: Worse thing is we leave holes, and add more instructions later, and the holes are the wrong size, so then the new instructions have to go afterwards. Then we use the second LEB byte and we have a larger encoding. Even if these 8 x i31 instructions don’t fit in a hole, they go on the end and we’re still not close to the second LEB byte. I propose we do a non-binary poll with an option for “do not care” and see who feels what and how strong and try to resolve it quickly. 

###  Discussion: extending type difference to heap types ([#381](https://github.com/WebAssembly/gc/issues/381))

TL: Related issue about heap-type indices. Ryan isn’t here, he was concerned about the types being counter-intuitive. We can skip the discussion since Ryan isn’t here.

AR: Should we move the previous one right away? 337 type opcodes one.

TL: Right, okay, yes. We can just close it now? Great. I just closed it. Great progress. Anything else folks want to discuss? This was every open issue I could find on our bug tracker. Not much left.

AR: Thanks for your help in the spec? Do you plan to do the validation? Should be fairly straightforward.

TL: I’ll take care of that. There is also extending the name section for field names. I’m happy to take a look at those as well. Maybe I’ll edit the big laundry list in the spect to note that I’m working on it.

AR: I think so, the name section would be, there is a group of appendices, you can just add an item there.

TL: I still have a bunch of work to do in Binaryen, but I’ll finish up the bulk array operations and finish up any other stuff I can.

AR: Field names I didn’t think of that but that’s another thing.

TL: Check out the list of issues, there are a few lists of issues which aren’t done. Writing down somewhere the embedder is not allowed to create impossible values like cycles of immutable references. We have few other issues like that.

AR: I forgot there is one other non-minor section still missing which is the soundness appendix but that’s blocked on CW reviewing the validation. That would go there because it ties into the notion of valid store I think would basically forbid a store that forms cycles in impossible ways.

TL: I’m not sure there are many people who read the soundness appendix. Should we put it somewhere else also?

AR: Yeah, I think we should put a note somewhere. The only place it really matters is in the axiomatization function calls. That defines the host function can only extend the store in valid and legal ways. And that’s where it would formally end up in. But we can put a note there as well. I don’t know what that section is saying informally right now. 

TL: Ok, sounds good. Anything else? Short meeting, we are running out of issues to discuss, so it’s a good thing. See you.

### Text format for final types ([#333](https://github.com/WebAssembly/gc/issues/333))

Ryan not present, so deferring this discussion.
"
wasi/2021/WASI-02-25.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the February 25 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: February 25, 17:00-18:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Lin Clark
    - Email: lclark@fastly.com

### Registration

None required if you've attended before. Email Lin Clark to sign up if it's your first time. 

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Discussion: Better error handling in WASI
    1. _Sumbit a PR to add your agenda item here_

## Notes
### Attendees
- Lin Clark
- Dan Gohman
- Andrew Brown
- Johnnie Birch
- Sergey Rubanov
- Mark McCaskey
- Peter Huene
- Radu Matei
- Luke Wagner
- Ralph Squillace
- Pat Hickey
- Till Schneidereit
- Mingqiu Sun
- David Piepgrass
- Yong He

**Dan Gohman:** Overview—errors handled like POSIX with single enum of errno. More APIs in WASI, not feasible to have a single errno enum. Also not reasonable to have a single error type. My expectation for errors is that every library will define its own error types. IT will make it possible for us to define a variant type like Rust’s Result. Does that shape of things make sense?

**Andrew Brown:** Makes sense to me. Errors for wasi-nn are just a totally different sphere than files.

**Dan Gohman:** wasi-libc will still have errno. Errno only describes small set of system errors

**Andrew Brown:** Right now wasi-nn has own kind of error types. What’s changing? Will we just change witx and wiggle

**Dan Gohman:** It’s not a fundamental change. We’re just making what wasi-nn is doing explicit. We’ll also be getting new features from IT which will describe what you’re doing in a better way. Enum with either success or failure, maybe called Expected.

**Andrew Brown:** I think Alex has already made this change.

**Dan Gohman:** Yeah, we wanted to give people a heads up about this plan. 

**Andrew Brown:** One question about the future—will this expected type, in the failure case will you be able to pass things that aren’t just an integer, like strings and stuff

**Dan Gohman:** There is no master plan, but I expect the basic mech will be that you can have any type for errors, with full expressiveness of IT. One caveat, how do we want to handle strings? English isn’t appropriate for all envs. Will need to apply more design thought. Underlying tool won’t have a restriction against that, though

**Andrew Brown:** Agreed. On thing I’ve found with wasi-nn is just having an errno isn’t enough

**Dan Gohman:** Agreed, and that’s a place where tooling might be able to help. We can go down the path of thinkking of enums not just as ints but high-level types

**Luke Wagner:** Along that line, one thing that has bugged me about classical error codes, is sometimes you want to use them for conditionals, and sometimes you just want to debug. Two level nesting of variants? Top level “You called it wrong” and second level provides detail of how you called it wrong.

**Dan Gohman:** Yes, let’s do that. I think that’s totally a good idea to do. Another idea, in POSIX they have system calls that are never supposed to crash. In WASI, we don’t need to be as strict. If you pass a bad pointer into a syscall, it could trap. 

**Pat Hickey:** Yeah, that’s also a kind of a concession for virtualization. Awfully convenient for that

**Dan Gohman:** So that’s the basic vision of it. Any more questions on that level of detail? One thing this does mean, we won’t have unified error handling across WASI. Another thing, we want to go through the APIs and figure out what errors things like the clock apis can return. In practice, the only thing that can fail in a clock is failing to get a clock. Wasi-filesystem will probably be where most of the error codes land. Simplifying property across different APIs. Don’t overload error codes to represent similar but not the same errors. Exception handling is coming. A possible approach is to use unwinding. I think that for WASI, errors work better. If languages want to use unwinding, they can expect errors and unwind. I think using variants instead of exceptions will work well for us.

**Pat Hickey:** The one thing I’ll call out is that proc_exit should be implemented as unwind.

**Dan Gohman:** That’s true. I’m going to claim that proc_exit is special. It might be something that we unwind and then turn into a clean exit status. Then the unwinding becomes an implementation detail. That wouldn’t be a thing that leaks across module boundaries. Often not a good idea for libraries to call exit directly. 

**Pat Hickey:** So we basically get rid of proc_exit as a library function

**Dan Gohman:** So I think what we want to say is return type from main is an error type.

**Pat Hickey:** Yeah, that way we keep types all the way down and don’t turn into bare integer.

**Dan Gohman:** Yeah, so 3 error types. Return values, unwinding, and trapping. Trapping is for program has a bug. Maybe sometimes when return values. ____. And we’ll use unwinding across language boundaries.

**Pat Hickey:** Unlike with errors, we can’t invent new ways to trap.

**Dan Gohman:** Although I wonder if there’s something we could do there. I wonder if it makes sense for wasm to be able to trap with extra info.

**Luke Wagner:** Or there could be a WASI function that says “I’m going to trap, but you can provide me with an error to print”

**Pat Hickey:** You can imagine that a malicious module would do that

**Luke Wagner:** They can do that already. We don’t want wasm to casually be able to catch traps. Because at a very fine granularity. But having a blast zone that allows a set to go away without taking down the rest. I think that belongs at some point of time in wasm’s future.

**Dan Gohman:** yeah, if we add those mechanisms, then programmer errors could just be trapped. 

**Lin Clark:** Best way to collaborate

**Dan Gohman:** Once we’ve fully modularized, each module will audit their own errors. The wasi-libc work will start after the next snapshot which includes those changes.

**Andrew Brown:** Question about sockets. Who’s driving that

**Dan Gohman:** Haven’t heard from them. Don’t know what their status is. Expect that if they don’t respond soon we’ll find someone else

**Andrew Brown:** Who was originally driving it?

**Dan Gohman:** Somebody working for a company called ____. The person who filed it is the person working there.

**Andrew Brown:** Radu, was someone on your side interested in that?

**Radu Matei:** We should probably have a chat at some point. How will that relate to these changes?

**Dan Gohman:** Sockets are the other major user of errno. I expect sockets will have their own errno, and then wasi-libc will have some way to concatenate errnos and turn it into appropriate POSIX errno space. I think that’s basically it.

**Radu Matei:** How about IO Streams?

**Dan Gohman:** We haven’t talked about how it’s going to work with libc. I expect from a POSIX point of view, we might have a bunch of different error codes in wasi-io. Have been talking about wasi-io not reporting very specific errors because it leaks information. We aren’t necessarily going to want to return a lot of detail there either.

**Ralph Squillace:** I think we want to try to figure out, if we help pick up the PR, what’s the best way to move forward without having to reimplement too much. Will reach out to original champion.

**Dan Gohman:** I see wasi-filesystem and wasi-sockets being peers. At a good place for them to work the same way.
"
main/2019/CG-02-19.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 19 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: February 19, 5pm-6pm UTC (February 19, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email Ben Smith to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Update on [producers section](https://github.com/WebAssembly/tool-conventions/blob/master/ProducersSection.md): [tool-conventions/#93](https://github.com/WebAssembly/tool-conventions/issues/93) points to likely non-use in practice and so next steps would be to either remove or [soften wording](https://github.com/WebAssembly/tool-conventions/issues/93#issuecomment-459879563).
    1. Discuss implementation and spec status of [bulk memory](https://github.com/WebAssembly/proposals/issues/18).  Move to [phase](https://github.com/WebAssembly/meetings/blob/master/process/phases.md) [3](https://github.com/WebAssembly/meetings/blob/master/process/phases.md#3-implementation-phase-community--working-group)?  (Possible POLL.)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Alex Crichton
* Andreas Rossberg
* Ben Smith
* Ben Titzer
* Conrad Watt
* Daniel Ehrenberg
* Flaki
* Jacob Gravelle
* Keith Miller
* Lars Hansen
* Limin Zhu
* Luke Imhoff
* Luke Wagner
* Mitch Moore
* Nick Fitzgerald
* Pat Hickey
* Peter Jensen
* Sam Clegg
* Sergey Rubanov
* Sven Sauleau
* TatWai Chong
* Thomas Lively
* Ulrik Sorber
* Wouter Van Oortmersson
* Yury Delendik

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Thomas seconds.

### Proposals and discussions

#### Review of action items from prior meeting.

#### Update on [producers section](https://github.com/WebAssembly/tool-conventions/blob/master/ProducersSection.md): [tool-conventions/#93](https://github.com/WebAssembly/tool-conventions/issues/93) points to likely non-use in practice and so next steps would be to either remove or [soften wording](https://github.com/WebAssembly/tool-conventions/issues/93#issuecomment-459879563).

LW: short update. Tools would emit by default. Emscripten team pointed out why not emitting by default. Changes the nature of it -- not useful for live telemetry. Changed some of the wording.

JG: My take: it still seems like a useful thing to have. Maybe not from emscripten perspective. Emscripten has an idea of how many people using it -- most wasms today. For other producers it might be more useful. I’ll add a link to GH link to chat.

AZ: Just to add -- market share issue is a factor, there’s also a code size issue and privacy leaking issue as well.

JG: For us it’s all code-size cost, not as much benefit to paying that cost. For F#.js perhaps it’s more useful, they may want to pay the cost.

LI: It may be possible to infer backend from generated wasm, so you don’t necessarily need the producer section -- you can get the same effect without putting it in there.

JG: If you look at the JS minifiers today, it doesn’t add this sort of thing. For end-to-end toolchain maybe the don’t care about the code size as much.

Flaki: Does this have any use-case for chaining tools, or just for human readable.

LW: Initially it was to have all the tools in production use this.

#### Discuss implementation and spec status of [bulk memory](https://github.com/WebAssembly/proposals/issues/18).  Move to [phase](https://github.com/WebAssembly/meetings/blob/master/process/phases.md) [3](https://github.com/WebAssembly/meetings/blob/master/process/phases.md#3-implementation-phase-community--working-group)?  (Possible POLL.)

LH: Want to know what the status is. Want to know if it’s stable.

BS: [explaining status.]
BS: I mean technically we are implementing, so we are in the implemention phase.

BS: All we miss currently is the testsuite. We both have our individual tests, so this might be just an issue of bringing them into the spec format.

AR: Have we resolved where to put the missing table stuff?

LH: The table indices? The bulk table instructions.

BS: table.grow and table.size?

LI: is there a proposal to cover C’s memchr command? That scan command makes scanning much faster, there’s a SSE2 version that’s much faster.

LW: I thought about this too, might be useful to fill.

BS: That sort of feature would probably get subsumed by the SIMD feature, depending on what we think would ship first.

BT: Another argument for memcopy is you can do virtual memory tricks, more than you can do for simd.

TL: Regarding splitting memory operations apart, it will probably happen in LLVM. They’re treated as two separate features. Doesn’t have to be same for spec and toolchain -- something to be aware of.

BS: for memchr if people are interested they should probably create a proposal for it

BS: for table[...]

LH: That’s true you need the value argument for table.grow … also table.fill.

AR: If we don’t want to add them to bulk then we can add them to reference types -- but that’s further along. Or we can have a third proposal.

LH: They would be dependent on reference types.

BT: Should be easy to add.

AR: Need some volunteer to spec that, then need to test. [LH: i can review]

BS: As far as the status is concerned, we don’t have tests for the bulk memory proposal, that’s the only thing keeping us from moving to phase 3.

AR: Somebody should write the tests I guess!

AI[BS]: I’ll work on this.

AR: Testing the reference interpreter as well is important.

#### In-person meeting

BS: New dates proposed June 12-13

BS: The issue with that is actually pretty close to the TPAC meeting in Fukoka in September

BT: most folks will have to travel far for Japan.

DE: w3c has invited expert travelling, you can get support for travelling and financial support.

BT: Concern is environmental impact and logistics.

LH: Probably won’t go either.

LW: What about a smaller group for TPAC, such as people concerned with cross-cutting interactions, then later in-person meeting maybe November. Someone will have to host that, though, we can’t just piggyback on TPAC.

BT: I like that.

DE: The nice parts were where Anne and BZ could come in for other topics.

BS: So it feels we are sticking with the plan of the June CG in person meeting and a smaller meeting at TPAC, then a CG in person meeting in November, preferably early November to avoid issues stemming from the holidays.

DE: If somebody wants to host in Munich -- we could swap A coruna and munich for November and June. It won’t be as cold.

BT: I don’t think that’s impossible.

BS: Is it beneficial to anyone?
BS: People sounded pretty supportive for the June meeting so let’s try to stick with that.

DE: Could we conclude the dates for the June meeting?

BS: There is not many other dates that work.

FM: Could we move it forward 1 day (11-12?)

DE: We wanted to keep it possible to travel on Monday.

BS: There is a holiday on Monday, so we don’t want folks to have to travel on their holiday.

[discussion about timing flights to a coruna]

DE: There are flights 6-times per day from a coruna.

Poll: Is it feasible to travel to a coruna for the in person meeting
Yes: 15
No: 1

Poll: Is it feasible to travel to barcelona
All: many yeses and a probably

BS: Should we investigate travel to Barcelona?

DE: That’s a lot of extra work for me, it seems like given the results a coruna works for most? Perhaps I can work with FM to find better flights.

[discussion about travel plans]

BS: There are constraints here -- hard to move forward a day due to travel, and it’s a lot of effort for DE to move to barcelona as well. Given that most can attend at the given days (Jun 12,13) we should go forward with that schedule.

FM: I probably won’t be able to attend then.

BS: Understood, this is tough to schedule. But we will have a VC setup available for remote viewing as well, Dan has used this in the past and has been able to communicate with the group using it.

#### Closure
"
main/2021/WG-03-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 10th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: March 10, 2021 at 4pm-5pm UTC *( March 10th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Discuss potentially switching to an [Evergreen Recommendation / Living Standard](https://www.w3.org/wiki/Evergreen_Standards).
1. Closure

## Attendees

- Luke Wagner
- Derek Schuff
- Eric Prud'Hommeaux
- Andreas Rossberg
- [Probably others, unfortunately I missed this in the notes]

## Meeting Notes
Looking at https://www.w3.org/wiki/Evergreen_Standards

We think this is a good match for our process, since we make all the decisions in the CG.
The act of merging into the spec at stage 5 happens after we get consensus, so we don’t need the extra call-for-consensus step of publishing a CR.

Discussion about how snapshots can be used to periodically get IP cleared and that can be done more-or-less independently of merging PRs that have reached stage 5.  Likely the snapshots would not have significance to implementers or tool vendors (who will mostly pay attention to the practical facts of which engines support which features).

The ES process allows the WG to produce RECs from the ES at a future point in time, if needed.

What would the process be to switch?

We’d need to get all the AC reps to approve it.
We’ll need a charter extension anyway but going evergreen would still be a bigger change. Just re-upping our charter would be simpler.

To update the charter:
Luke will look at the current list of proposals, and organize it a bit
Eric will write up a new charter based on the existing one plus that list

It would probably be worth putting it in front of the CG, asking if anyone has concerns about the evergreen process, maybe even present the proposed charter.

But most of the work for the charter will be the same either way.

Also we can still put out REC-type documents even with the evergreen charter.

EP: then we have to figure out the publication process.
Thinking about how to handle the HTML format: accessibility, mathML etc
Didn’t really get a response from [?].
We could just try to put something together and see what they’d suggest to fix it.
So put some boilerplate at the top, and then generate the multipage like we have it.

AR: we punted on everything sphinx for a long time, we are stuck on an old version because updating breaks everything.

EP: do any of the sphinx maintainers work for any of the companies in the WG? Maybe we could get their help that way

AR: don’t know.

LW: what was the issue? We have all this prose text by the formalism, was it just linking them?

EP for accessibility, i made the claim that the math stuff was duplicated, but the problem was the inline math?

For sphinx the question was whether we could get some help from the maintainers. Do any of them work for WG member companies?

AR: I don’t see any affiliations listed on the page. Certainly when you work with it you get the impression that it’s not very mature.

LW: wasn’t it automated by Brad?

AR: the bikeshed stuff is automated. But it all depends on special hacks that are hard to understand and probably fragile. It is still running automatically.

EP: we could just grab all that HTML and put it in some bigger document?

LW: the current build puts out 2 docs, multipae is the one we like to read and the other is more in the W3C format

EP: last time we did this i had to deal with a bunch of validation problems. So it made everything hard. So if i’m going to go through that i’d rather deal with the multipage doc.

AR: the bikeshed pipeline only generates the single page. The multipage is just the regular sphinx output

The pipeline is a bunch of hacks to make Katex work (we use that instead of mathjax)

LW: could we use mathML now?

AR: they are starting up a new standards process but it seems early. Converging on existing state across browsers but it seems it will be a while before it’s ready

EP: the mathjax is more complete and sphinx just renders that on its own? And katex is for accessibility?


AR: katex is static and mathjax is all rendered in JS and is slow, also made it impossible to process in bikeshed? (not sure)

EP: I guess the question is that if we’re going to say that the math is nice-to-have that is duplicated, then maybe that’s OK?

AR: also bikeshed couldn’t handle multiple pages at the time.

EP: so the question is, if BS can handle multipages, and sphinx is outputting valid HTML, then the question is could we use that and postprocess it

AR: that would certainly be easier. One of the other things was maybe adding the right front matter with BS

EP: taking that and modifying the DOM could be easier. BS also keeps track of some of our configurations, which we’d have to do some other way. But we aren’t using a lot of BS’s big features.

AR: also the JS and web spec are all BS. and the core spec doesn’t have any dependencies on web stuff.

EP: would one of you want to sit with me sometime and show me the process with sphinx and see if we can produce a doc with a small amount of effort?

AR: I wonder if we can find someone who can contribute too. We did have an external person who contributed some stuff, updated to the latest sphinx that worked

Oh, it was Zhi.

EP: what broke when we tried to upgrade?

AR: some of our math plugins. We were using it to define macros for embedded latex. I found a little code snippet somewhere on the web and it used some sphinx API that apparently went away. I assume there’s a replacement but I didn’t understand it well enough

DS: are multipage, mathjax vs katex, and formatting/front matter all separate issues?

EP: would have to add the font matter, might have to change the markup/ToC sidebar, want to see if we can get away with mathjax and see if someone complains.

AR: the katex is the thing that we know the least.

DS: maybe we should figure out exactly what we need to change, starting with the multipage output that we have now, then we can see if it’s easy enough to just hack/postprocess or if we think we want to update sphinx itself, or what 

AR: the sidebar looks static. I don’t see anything dynamic looking in the first page

LW: we should come back to this, since we’ll need to have this automated for the evergreen spec.

EP: did I forward you a thing about W3C’s echidna tool? Automated publishing of CR-type docs from git.

LW: before the next WG, can you take a look at the output to see what is needed

EP: maybe i’ll take one and try to make it TR compliant and see what it takes.

AR: there are 2 parts in configuring sphinx, you can create style sheets for the sidebar and such it might be easier to hack ours incrementally than write a new one from scratch or maybe even compared to trying to postprocess it


"
debugging/2019/debugging-09-19.md,"## Agenda for the September 19 video call of WebAssembly's debugging subgroup

- **Where**: zoom.us
- **When**: September 19, 6pm-7pm UTC (September 5, 11am-12pm Pacific Daylight Time, 8pm-9pm CEST)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Derek Schuff
    - Email: dschuff@google.com

### Registration

None required if you've attended a wasm CG meeting before. Email Derek Schuff to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.

Installation is required, see the calendar invite.

## Agenda items

1. Opening


## Meeting Notes
### Attendees:

* Nick Fitzgerald
* Derek Schuff
* Bill Ticehurst
* Luke Imhoff
* Paolo Severini
* Yang Guo
* Yury Delendik
* Philip Pfaffe
* Z Nguyen-Huu
* Arun Purushan


Debugger modules PR: https://github.com/WebAssembly/debugging/pull/6

NF: mostly interested in people’s thoughts on that

BT: comment from PR: is there prior art? VSCode tried to standardize DAP. Anything we could apply?

NF: haven’t looked at DAP in particular. This is informed by experience with spidermokey debug API and source maps. 

BT: does wasmtime have a similar mechanism?

NF: no, it takes wasm DWARF and generates native dwarf at compile time.
Not exactly like lldb, but itj ust converts the dwarf, and then a native debugger can be used on the native code.

LI: SInce there’s an official python wasmtime binding, do the python debugging tools work? Or do you need to use lldb? E.g. in general for other languages that load wasm.

YD: wasmtime converts the dwarf, and then waits for lldb to get the debug info. Python tools wouldn’t know about native debugging AFAIK. 

NF: Similarly to another native module in python. We could extend it for python debugger.

NF: we treid to keep it a very sm all API surface, not based on firefox in particular.

LI: in terms of efficiency, would having ignore counts, or limited trips per breakpoint be better? I.e. to make it full speed until we hit the point we care about. So you woulnd’t need an API call every time.

NF: the function will need to be recompiled to hit a breakpoint, but there would be an extra call to the debug module. We would probably want to consider this and not rule it out for the future, but maybe keep an MVP really simple.

LI: yeah this should be compatible going forward.

NF: The other thing is that Wouter left a comment. He basically said why not reuse a serialization mechanism (protobuf, flatbuffers, etc). I need to respond online, but basically: how do you get that into the debugging module? We don’t have calling conventions or a function call protocol. So you’d need that anyway. But also wasm interface types already has the means to describe this, so why not use that.

BT: is there capacity to example linear memory?

NF: not yuet. We first discussed as MVP just to have source-maps replacement; i.e. line numbers, breakpoints, stepping, without inspecting variables. That would be the next milestone. I think they’d be disjoint APIs, and wojldn’t affect the line table APIs.

BT: so the goal is to prove out the architecture and not be a usable initial release?

NF: this is as good as JS debugging is now, lots of languages compile to that.

BT: you’re definitely dealing with modifying memory more often with wasm.

PS: today browsers do expose the memory and low-level primitives.

NF: true, we have 2 layers today where one is what programmers want to see (e.g. std::string rendered vs just the buffer). 
So those are different.
So this is the discussion of, do we want to have these both in the MVP or have them in 2 differebnt milestones.

LI: so this level is useful for e.g. finding out basic things like whetgher you got to the right place, which branch, etc. 

PS: we have to start with something, could be just this

NF: it might be useful for our purposes to separate these even if we want both together to advertise something useful for users.

LI: Don’t know how we’d do the graphical rendering that visual debuggers do …[missed some bit of this]

BT: it is interesting to think how the debugger would display e.g. std string

LI: JetBrains API works well for a variety of languages, e.g. java and elixir
Could think about other things like microtasks, threads, etc. How do we tell browser that our langauge supports things like that, and have it display something useful for e.g. greenthreads.

BT: also IDEs have a bunch of knowledge about e.g. things like standard library types.

NF: e.g. in gdb all the pretty formatters are python code.

LI: we’d want basic stuff like folding, grouping, color

NF: we want to start with a common base and not the union

DS: display as separate from VM and debugger nodule

YG: for things like prettyprinting, the frontend is probably the better place

BT: for every lannguage that gets reimplemented?

DS: makes sense to have it in the debugger module but some UI entity would be calling it.

BT: could be 

NF: do we want to move forward on this PR?

YG: how binding is this if we land it? What’s the process for changing it? Some staged process like JS would be good

NF: yes its definitely not final. Basically looking for consensus that this is worth doing

LI: keep in this repo?

NF:

DS: doesn’t fit with existing CG process but could be similar.

NF: LLVM itself wouldn’t generate the module but rust/emscripten would

LI: how do we coordinate it?

NF: makes sense to commit the PR rather than leaving it open forever. Then we could have new PRs to make changes 

LI: would be nice to have some way to show the implementation status, to find out where the work is going on.

DS: we don’t have this currently for wasm CG.

<discussion about vendors keeping up with a doc linking to their inplementation status>


DS: makes sense to have a vote next meeting, in two weeks, for whether to officially adopt debugging modules for stage 0

LI: does this need to be broadcast to the larger group?

DS: don’t think it is necessary for every step, but could be polite for bigger things

AI: dschuff will put something ont he CG agenda, and will schedule the agenda for next debug  meeting to vote

NF: that’s it for this agenda

BT: the only other thing is the definition of our first MVP. we seem to have different ideas of what constitutes “viable”. My perspective was that this first milestone is that it wouldn’t be useful for a user to debugg their program.

NF: yeah maybe milestones is a good term, since it doesn’t imply user value and what they’d require. The things you called out are what I imagined as the 2nd milestone.

BT: should we define some milestones, like a roadmap?

NF: that makes sense. We also want to not try to unnecessarily sequentialize. But it does make sense to align it with the capabillities

LI: a roadmap of capabilities would be useful to help users who come to the repo to find out what’s going on.

PS: technical question> looking at the dwarf prototype. See that LLVM has a stack in memory, separate from the wasm stack.

(Discussion summary)
There needs to be extra info in debug info describing the linear stack, which global is the stack pointer, which local is the frame pointer in each function etc.
There is an out-of-tree LLVM patch for part of this.

For other languages they will need to keep different data (e.g. about greenthreads).
Only the VM has access to the real callstack. Currently emscripten and Rust are calling out to JS to get error().stack info for stack traces. Eventually it would be good to have an API in wasm to get this kind of info so it wouldn’t be necessary to go to JS. Probably the debugger module would use it since each language/platform would have a different ABI and different data.

"
wasi/2024/WASI-05-02.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: May 02 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: May 02 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Long-term support for WASIp1 https://github.com/WebAssembly/WASI/issues/595
    1. Discussion and Vote: Advance `wasi-keyvalue` and `wasi-runtime-config` proposals to Phase 2
## Notes
### Attendees

- Bailey Hayes
- Colin Murphy
- Pat Hickey
- Nick Fitzgerald
- Michael Warres
- Marcin Kolny
- Mendy Berger
- Chris Woods
- Jeff Charles
- Zalim Bashorov
- Hung-ying Tai
- Wouter Hennen
- Luke Wagner
- Yong He
- Radu Matei
- Robin
- Dan Gohman
- Oscar Spencer
- Dave Bakker
- Merlijn Sebrechts
- Frank Denis
- Chris Woods
- Stephen Berard
- Thomas Trenner
- Emily Ruppel
- Yage Hu
- Joe Zhou
- Nuno Pereira
- Taylor Thomas


### Long-term support for WASIp1 WebAssembly/WASI#595 (35 min)

**Marcin Kolny**: Summarizing context of WASI#595 

**Marcin Kolny**: Not interested in extending the spec itself. Interested in getting the tooling to support long-term support. We want it extended to support wasm64. The reason we need extended support is that we have a lot of devices that have the devices with the firmware baked into the runtime. We have to stay on this for as long as the customers have these devices.

**Marcin Kolny**: Mem64 requires updating the runtime. We don’t want to update to P2 yet. It may or may not change and there may be more backward incompatible changes. We want to stick to P1 to avoid additional fragmentation. Another reason is that mem64 is close to completion in the runtime we use, WAMR. Support for this in P2 is going to take more time. 

**Marcin Kolny**: I know that other folks have similar challenges so we started looking into solutions.

**Marcin Kolny**: The first was proposed by I think Andrew Brown. It would be to keep support for p1. I expect this will make this a little more difficult in adding changes to P2 and forward. SLA to address CI and keep this maintained.

**Marcin Kolny**: Preview 2 to Preview 1, I think is an excellent idea. But I found a problem that it is difficult with our code to address that preview 2 API’s are not called or eliminated so that new code does not accidentally unintentionally call unresolved symbols. Bailey mentioned tooling that is being built for transitioning 0.2.0 to 0.2.1. 

**Marcin Kolny**: My recommendation is that we move forward with both proposals. When we ever get to a point that we are satisfied with the adapter and have high confidence, then we will consider dropping the aforementioned p1 maintenance. 

**Ayako (in chat)**: Until wasi-threads is supported in p2, we must also stay in p1. so I guess we must follow you.

**Marcin Kolny**: If anyone else is interested or has a similar problem, please contact me. And this will be an upcoming topic in the Bytecode Alliance special interest group.

**Robin Brown**: This continued support will require maintainer work. Are the people who need this and are asking us to commit to it going to provide resources to do it?

**Marcin Kolny**: Yes, as long as we need this support, we will maintain it. We should agree on SLA’s. 

**Marcin Kolny**: Our priority in addition to supporting our use-cases, we do not want to block WASI progress. So if we don’t respond to CI for a couple weeks for example, maintainers should be able to disable the CI.

**Taylor Thomas**: Let’s make sure we don’t unintentionally fragment the ecosystem by holding on for too long. 

**Marcin Kolny**: We already have devices that run for 6-7 years so we must hold support for a long time.

**Marcin Kolny**: There might be some corner cases so we will need to evaluate.

**Bailey Hayes**: Agree we should keep maintenance on wasip1 going.

**Bailey Hayes**: Request to keep a feedback loop with new incoming changes so that we know the new designs work well for your use case.

**Marcin Kolny**: Adaption to p1 to p2 is much easier because its a lot easier to go to the superset. Going backwards is much harder.

**Nick Fitzgerald (in chat)**: I am in favor of the approach that Luke outlined in the issue thread

**Marcin Kolny**: If the adapter approach works, then I have no interest in maintaining wasi-libc for p1.

**Marcin Kolny**: We will explore the adapter further; in case it’s not viable or it’ll take longer, we’ll work on the wasi-libc preview1 support and add features like memory64 or exception handling. We will move forward with both approaches 

**Stephen Berard**: Related to the last topic.  I'm fairly new to this group.  As there any resources regarding what needs to be done when migrating from 0.1 --> 0.2?

### Discussion and Vote: Advance wasi-keyvalue and wasi-runtime-config proposals to Phase 2

**Taylor Thomas**: These are cloud resources not necessarily system resources. These are not exactly the same bucket of the previous ones.

**Taylor Thomas**: github.com/WebAssembly/wasi-keyvalue

**Taylor Thomas**: Some of these will be implemented into hosts but I don’t expect this to be necessarily baked into wasmtime or other runtimes. 

**Taylor Thomas**: For the portability criteria, the implementations will be host plugins.

**Taylor Thomas**: We believe the best way to test this will be in the wasi test repo. This will be an optional section of the suite alongside the more system wasi type tests. We haven’t written the test suite yet. But will do so as part of the next phase.

**Taylor Thomas**: We have been working on this with Fermyon, Microsoft, and from the wasmCloud side (Cosmonic). We have boiled this feedback down to the interface that is in this repo. Joe, did I miss anything in regards to the portability criteria I should add in? (No)

**Taylor Thomas**: We have an implementation of this in wasmCloud and this is ready for implementation by others.

**Bailey Hayes**: Vote to phase 2

**Bailey Hayes**: wasi-keyvalue advances to phase 2

SF: 15
F: 9
N: 5
A: 0
SA: 0

** Taylor Thomas ** Lets move on to wasi-runtime-config. This is for multitenant systems that may not expose environment variables. One of the implementations we are working on is with wasi-virt, which can expose runtime config as environment variables, or vice versa, depending on the applications needs. This can be used by databases and [missed examples], and provided by runtimes like wasmtime, wasmcloud, and spin. The portability criteria is that it should be provided on all the operating systems and provided by many providers. This is a collaboration across multiple runtimes. We already have an implementation in wasmcloud.

https://github.com/WebAssembly/wasi-runtime-config/tree/main

** Dave Bakker** Whats the added value compared to virtualizing environment variables?

**Taylor Thomas** Multitenant systems require that we never expose or target environment variables. Semantic difference between environment variables, secrets, and types of configuration that may be configured at runtime.
[notetaker missed discussion about secrets]. 

**Taylor Thomas** Several community members have collaborated. In the WebAssembly WG in the CNCF, Danielle from Fermyon. Eyes from the CNCF Wasm WG. 

**Bailey Hayes**: Vote to phase 2

SF: 17
F: 6
N: 5
A: 0
SA: 0

**Bailey Hayes**: wasi-runtime-config advances to phase 2

**Taylor Thomas** If you are an implementer, please implement and give feedback.

**Joe**: Repo for wasi-cloud wasi-cloud: https://github.com/WebAssembly/wasi-cloud-core. wasi-cloud-core is a proposal for a world that includes the other worlds including wasi-runtime-config and wasi-keyvalue and other world proposals.

"
wasi/2021/WASI-04-08.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the April 8 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: April 8, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Lin Clark
    - Email: lclark@fastly.com

### Registration

None required if you've attended before. Email Lin Clark to sign up if it's your first time. 

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Phase 4 advancement requirements for current Phase 2 projects (Lin Clark)
    2. Blockers for advancing wasi-filesystem to Phase 3 (Lin Clark)
    3. Updates on wasi-io, with discussion of [Short reads versus determinism](https://github.com/WebAssembly/wasi-io/issues/7) and [What is a push?](https://github.com/WebAssembly/wasi-io/issues/9) (Dan Gohman)

### Attendees
- Lin Clark
- Radu Matei
- Piotr Sikora
- Mingqiu Sun
- Sam Clegg
- Andrew Brown
- Till Schneidereit
- Dan Gohman
- Yong He
- Matt Butcher
- Taylor Thomas
- Mark McCaskey
- Luke Wagner

### Phase 4 entry requirements

**Lin Clark:** Because of timing of phase system being finalized in 2019, we didn’t set requirements for entering stage 4 for proposals currently in stage 2. Proposal is for the following requiremen**Till Schneidereit:**
Implemented in 2 engines in production at scale. But this should just be taken as a guideline. At the end of the day, this is a tool for the group to assess the viability of the proposal, so if the group feels confident in the viability of the proposal despite only having 1 implementation in an engine in production at scale, and the proposal has very strong support, then the group can choose to advance it. But the default should be 2.
Implementation demonstrates it works in all 3 major operating systems—Windows, Mac, Linux.

**Andrew Brown:** All of the proposals being championed by Dan, those are in the Node implementation, right?

**Lin Clark:** I haven’t kept up with whether they are keeping it up to date. I wouldn’t see Node being necessarily the implementation that we use to demonstrate. It could be, but I don’t think it would have to be.

**Piotr Sikora:** Could you clarify the rule about multiple operating systems?

**Lin Clark:** I should clarify that each proposal can have its own phase 4 requirements. So if these 3 OSs don’t apply to a particular proposal, then you can decide as you’re going into phase 2 to say “we don’t think this should apply to us”. But for the general case, we want these to be portable across the different OSs, that’s one of the key goals of the WASI work, so that requirement is just to ensure that’s upheld.

DECISION (consensus): Ratified

### Phase 3 requirements for all proposals

**Lin Clark:** Requirements for moving any proposal to phase 3. Really important that there are no custom ABI mechanisms required for WASI interfaces. All should be built on Interface Types interface mechanisms. Any other goals people think need to be completed before we move any proposal to phase 3?

**Andrew Brown:** What do we mean exactly by custom ABI?

**Till Schneidereit:** Early on, decision was made that WASI would use interface types for everything about how data types are encoded for things that can’t be represented by core wasm. That hasn’t been the reality for the work in progress as defined in the witx files, but idea was always to transition to IT as soon as it was far enough along. This is about the individual pieces of data exposed in an API, not the shape of the API itself. IT provides the ABI (the type grammar), WASI provides the API.

**Andrew Brown:** So once IT is integrated with witx, if we write our specs in witx, we should be good, right?

**Sam Clegg:** Are we saying then that everything is blocked until IT is basically done?

**Till Schneidereit:** Entire encoding mechanism for the ABI shouldn’t change after a proposal moves to phase 3. Idea is to avoid that kind of situation here

**Dan Gohman:** Yeah, phase 3 isn’t final in any sense. My understanding is that there is a bit of concurrency, but that IT will be factored so that the parts that WASI needs won’t depend on the parts of IT that are taking the longest time e.g. adapter functions, which aren’t necessary for WASI’s work. WASI only needs abstract type defs and at the very least a simple ABI to map those to. That can be on a different schedule than rest of IT. That’s not ready yet today either, and may not be necessary for phase 3, but probably for phase 4.

**Sam Clegg:** IIUC you’re talking about parts of IT that map core data types like strings. And we can implement that on an engine that doens’t necessarily support IT, because it’s the mapping down to the Wasm types.

**Dan Gohman:** Yes, some work to say how we do that, but that’s basic idea.

### Phase 3 requirements for wasi-filesystem

**Lin Clark:** Create a project board with issues I’m aware of. [lists issues]. Any other blockers? Take the silence to mean enthusiastic ratification.

Will be looking to do this for more of the proposals over coming months as well.

### wasi-io updates

**Dan Gohman:** Not in POSIX but in other systems. In posix, have read and write and can return fewer bytes than requested. That can mean end of stream, or stream interrupted, or could mean that the sending side has ended the write. So this is how POSIX works, get less bytes and don’t know why

In wasi-io, idea is to make that explicit. Reader will know based on status why there are fewer bytes returned. 

Transform from one stream to another. POSIX doesn’t tell you info you need to know what to do.

In POSIX, if you get a short read, have to assume that you might have more data. Wasi-io can tell you, so you can do fewer system calls.

Push tells you stream is open but work with bytes that you have. Pushes can make sure that data gets pushed all the way through a pipeline without getting stuck in a buffer somewhere. Some amount of non-determinism, but that’s true of POSIX. Only difference is that you don’t get info in POSIX.

Could say that short reads can only happen at end.

Pushes are considered not part of the semantics of the stream.

**Radu Matei:** So will it be left to implementors of streams to return the push status?

**Dan Gohman:** Yes, each implementor will have to decide when push happens. This is a relatively minor corner of wasi-io proposal, but interesting because not in POSIX

**Piotr Sikora:** Why ""push"" and not ""flush"", which is more commonly used to refer to this kind of behavior?

**Dan Gohman:** Comes from TCP. Flush would also work. Don’t have a strong opinion. One idea is that in future that if we can talk to TCP directly, we could go all the way through with push. Wasi-io has a flush function, and the idea is that it can be used to ___ buffering. Reflects reality. If you’re talking to a TCP stream, there’s buffering happening in between. SSH is one use case for push.

**Piotr Sikora:** Is there a use case for having force push? Pushes force end-to-end like TCP flag you mentioned, vs a hint where transformations along the way can decide.

**Dan Gohman:** This is intended to be a force push. 

**Piotr Sikora:** In your example, said it could be buffered along the way

**Dan Gohman:** Good point. Useful to take a stream to direct to a file and then redirect back, in which case the file doesn’t keep the pushes. 

**Piotr Sikora:** Not sure.

**Dan Gohman:** Same. This is very early stage.

"
main/2021/CG-11-23.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 23rd video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: November 23rd, 5pm-6pm UTC (November 23rd, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Interpreters (30 min) - Ben Titzer ([slides](https://docs.google.com/presentation/d/1QnlLXHaySUF3lJhQsOgMmsE4ynZiZx6kBMk4OAML-mY/edit#slide=id.p))
    2. Discussion: moving tail calls forward ([issue](https://github.com/WebAssembly/tail-call/issues/15)) (15 min) - Thomas Lively
1. Closure

## Meeting Notes

#### Attendees

- Ben Titzer
- Francis McCabe
- Paolo Severini
- Sean Jensen-Grey
- Derek Schuff
- Arun Purushan
- Slava Kuzmich
- Gordon A
- Yuri Iozzelli
- Daniel Hillerström
- Zalim Bashorov
- Sergey Rubanov
- Sam Lindley
- Luke Wagner
- Heejin Ahn
- Andrew Brown
- Ryan Hunt
- Radu Matei
- Nabeel Al-Shamma
- Keith Winstein
- Adam Klein
- Hannes Pyer
- Jakob Kummerow
- Johnnie Birch
- Asumu Takikawa
- Alon Zakai
- Ethan Lee
- Petr Panzin
- Intel Seven
- Pat Hickey
- Ioanna Dimitriou
- OCamlPro
- Andreas Rossberg
- Ross Tate
- Bailey Hayes
- Steven Prine
- Sam Clegg
- Zhi An Ng

#### Interpreters - Ben Titzer

 ([slides](https://docs.google.com/presentation/d/1QnlLXHaySUF3lJhQsOgMmsE4ynZiZx6kBMk4OAML-mY))

AZ: you said that translating to AST/IR takes more space. Can you just rewrite and then discard the original wasm?


BT: to debug, you need to refer to the original bytecode.

AZ: debugging isn’t something you do all the time though?

BT: it’s not really a niche. You do it rarely but it matters. One other thing is instrumentation. For that you often refer back to the bytecode. Wizard is designed in particular for debugging and instrumentation

FM: One issue with guard page is that it’s not consistent with stack switching

BT: there are definitely issues there, where do you put the branch, where to put the pages, etc. haven’t solved that yet.

VM: V8 uses guard page but also has a stack chekc on function entry.

BT: I don’t think for the C execution stack. The check is explicit in the code. It’s actually fairly unreliable. For Wizard I implemented that for Virgil to cover virgil code too

PS <chat>: What is the performance of the best interpreters compared to jitted code? Is it sufficient to run ""normal"" Wasm workloads like Facebook games? Google Earth? What is the threshold for the kind of apps that work with an interpreter?

BT: somewhere between 10-50x (mostly more toward 10x). Every interpreter will be 10x compared to JIT. JSC is 10-15x slower than baseline

AR: without the tagging is the value stack only 32 bits wide? How did yo utag 64 bit vals?

BT: 2 64 bit worlds. The first word is only a byte, but full for alignment. On x86 unaligned accesses are pretty fast, not sure it matters, but it makes the math easier

AR: I assume no SIMD yet?

BT: not yet. For 128 bit values there are a couple options (next slide)
You can box them (5-10x slowdown). You can try to reuse boxes, but that gets a bit crazy. Since I”m using 128 bit slots, maybe they are untagged for SIMD. Then you need conservative GC. Or you go to 256 bit value stack slots (that’s probably not to bad, 5-10% cost). I’ll probably do that.

AR: could you split the stack per type somehow?


BT: I’ve thought about that, but it doesn't really work. There are polymorphic bytecodes, local, drop etc. There are things you can do but they aren’t really better than tagging

<end of slides>

FM: Do you still think it’s worth having an interpreter?

BT: yes. The way I see things going is that production engines will have 3 tiers unless they are for offline compilation

FM : what do you think about V8s approach wrt debugging in liftoff?

BT: V8 started by doing JS debugging in its baseline tier. THere are a lot of issues with debugging JITed code. Patching code, etc. It’s a hassle and a security issue. It’s just so much simpler.

FM: what liftoff does is if you turn on debugging it throws away the JITted code and recompiles

BT: yeah, same as FullCodeGen in JS. it made things more complicated with an extra mode. It caused a lot of bugs there. We wanted to avoid putting debug info where we could get away with it. It just caused a lot of bugs. An interpreter is dead simple to get right.

FM: JS now has an additional tier (sparkplug). Why have one compiler when 2 will do the job? :)

BT: there are performance issues with just an interp + top tier, and debugging issues with just a baseline and opt. I think that is part of what leads engines to do that.

PS: You said this is useful as first tier, but good for security to avoid JIT? Is that perf good enough for some usages?

BT: I guess it depends on your application. If we had launched wasm from the beginning at 10x slower than native we wouldn't be here today. Sometimes you really need that. Other things aren’t super important. E.g. if you embed wasm in your program to use for lightweight scripting, e.g. they aren’t performance critical, interpreter is probably fine.

FM: the other approach to debugging is DWARF-style, codemap approach, so you don’t try to keep the original, you just keep pointers to the original source. For apps in C or OCaml, you don’t really care about the wasm bytecdode, just the application source. So the use case for debugging wasm seems limited

BT: if your static compiler generates source mapping, the target of those is going to be wasm code offsets. For any request to the engine, it will be wasm code offsets. So the wasm engine needs to tell the source level debugger where it is in terms of wasm bytes. So it needs to reverse the mapping.

FM: thats not what you want though, you want it direct. Could you support it more directly? You could have an opcode whose job is to record the offset?

### Tail calls


TL: discussions on emscripten repo got us thinking about this again ([issue 15](https://github.com/WebAssembly/tail-call/issues/15)).
The C++ toolchain is ready to use, there’s an implementation in chrome. All that’s missing is a 2nd engine implementation (and this issue is only the 15th ever). It doesn’t look like consensus on the design will be an issue.
There’s good discussion about it on the issue; a lot of people chimed in with different use cases: 6 just on that one thread (lumen/erlang, asterias/haskell, CakeML, CheerpX, OCaml, C++ coroutines and general TCO). Lars said it’s basically a matter of prioritization to see that it’s worth spending time on. So I wanted to put out a public call if you have other use cases for tail calls, please let us know. And if you’re in a position to run some benchmarks to prove the performance benefits, that would be super helpful as well (details on how to turn it on are in the issue too).

AR: I’d point out that it’s not just about benchmarks. There are things you just can’t do without tail calls. YOu can’t implement e.g. trampolines in JS.

TL: yes definitely cases where there’s no good workaround are good to hear about too.

BT: Wizard does implement it. Does that count?

TL: we still have the requirement that the engines be web engines

AR: what about wasmtime, does that have support yet?

PH: wasmtime doesn’t have it yet, we haven’t really discussed it. We can do that.
"
process/consensus.md,"# Determining consensus

Consensus is critical in a standards process:

* Gathering consensus helps champions guide their proposal with confidence.
* Consensus prevents needlessly revisiting topics unless new information
  surfaces warranting such revisitation.
* If members don't believe that their voices are heard then the process can,
  over time, break down. Recording dissent is therefore a critical part of
  building consensus.

## In-person meeting consensus

For in-person meetings, champions are expected to list points for which they
will seek consensus in the meeting agenda, and new consensus points can be added
in-person as the discussion proceeds.

Polling consensus is done by the chair:

1. The champion asks a question, which is written down for all to see. Multiple
   related consensus points could be polled back-to-back, in which case they are
   all declared before polling takes place.
2. The chair asks all participants to express their opinion to the question,
   asking in turn whether they are `Strongly For`, `For`, `Neutral`, `Against`,
   or `Strongly Against`. Participants vote for a single option by raising their
   hand, or abstain entirely. Aggregate votes are recorded by the note-taker.
3. If deemed relevant, the chair can ask certain participants if their wish to
   explain their vote for the note-taker.
4. The chair determines whether consensus was reached.
5. A participant may decide to register a formal objection to the decision. An
   individual who registers a formal objection should cite technical arguments
   and propose changes that would remove the formal objection; these proposals
   may be vague or incomplete. Note: in the Working Group, formal objections are
   reviewed by the W3C Director. Such review is not guaranteed for the Community
   Group. Formal objections that do not provide substantive arguments or
   rationale are unlikely to receive serious consideration by the Director.

There is no specific number of votes required to establish or block
consensus. In some circumstances a single implementor's or user's concerns may,
at the chair's discretion, block consensus. That being said, it is critical that
all participants believe the consensus process works! The chair must strive for
consensus on consensus.

Lack of consensus doesn't necessarily prevent an idea from being revisited
later. ""More information requested"" or ""request more work"" are acceptable
outcomes for lack of consensus.

In some cases where consensus seems to obviously have been reached, the chair
may poll a lighter-weight request for objections to unanimous consensus. A
single objection is sufficient to force the above consensus process.

## Online consensus

It is critical that work progresses between in-person meetings: agreed-upon
designs need to move forward, and new ideas need to reach some level of maturity
before being discussed in-person. To that end, this group can reach consensus
online, either on GitHub repositories under the WebAssembly organization or in
official video calls. In the latter case, the consensus vote must be added to
the agenda at least 24 hours before the video call is scheduled to begin, except
in the case of general interest votes moving pre-proposals to phase 1, which can
be added as the discussion proceeds. Consensus decisions are recorded in meeting
notes and published just like in-person meeting notes are published.

We introduce the following concepts to help the online decision process:

* Contributors of *different affiliation* are individuals who are affiliated
  with different companies or institutions.
* *Interested parties* are individuals, companies, or institutions who usually
  participate in the WebAssembly Community Group or Working Group and are
  interested in a particular topic.
* *Small group* is a subset of Community Group and Working Group participants
  who decide to collaborate on a single targeted proposal.

We differentiate the following cases:

1. Editors are empowered to make changes that have no technical impact without
   explicit group decision. GitHub issues and pull requests are
   sufficient. Their title should identify them as editorial. Closing or merging
   them after a full work day of positive review by at least one contributor of
   different affiliation is acceptable as long as there is no objection. Editors
   shall revisit the editorial nature of the change if there is any contention.
2. Small technical changes or additions can be discussed in GitHub issues and
   pull requests. It is the author's responsibility to ensure that interested
   parties sign off. Simply mentioning people on GitHub may go unnoticed, the
   onus remains on the author to contact interested parties and obtain their
   feedback. Closing or merging after a full week of positive review by at least
   three contributors of different affiliations is acceptable as long as there
   is no objection. Consensus will be deemed to not have been reached if
   interested parties did not sign off. At any point in time a contributor can
   request that final consensus be delayed to an in-person meeting. In this
   case, the chair puts the item on the group's agenda of upcoming
   discussions.
3. Substantial technical changes or additions are usually carried in their own
   GitHub repository by a champion. It is critical that these proposals be able
   to evolve quickly without much process. Early on in such a proposal's
   lifetime no consensus is needed and a single champion can modify the proposal
   at will. As the proposal matures it is expected that the champion will seek
   collaborators to form a small group. Gauging consensus in the small group is
   left up to the champion, with input from the chair. When a proposal is near
   maturity the champion shall bring it to a meeting and seek wider
   consensus on open design points and contended issues. All decisions made by
   the small group can be revisited until consensus is reached at an in-person
   meeting.

Only 1. and 2. apply to the Working Group since the Community Group is the sole
venue where substantial work can occur. It is expected that Working Group
changes or additions in 2.'s category are validated by the Community Group
before being adopted by the Working Group. It is expected that all changes or
additions which reach consensus in the Community Group will be forwarded to the
Working Group for adoption.

## Decision process

As per the [Community Group charter](https://webassembly.github.io/cg-charter/):

    This Group will seek to make decisions where there is consensus. Groups are
    free to decide how to make decisions (e.g. Participants who have earned
    Committer status for a history of useful contributions assess consensus, or
    the Chair assesses consensus, or where consensus isn't clear there is a Call
    for Consensus [CfC] to allow multi-day online feedback for a proposed course
    of action). It is expected that participants can earn Committer status
    through a history of valuable contributions as is common in open source
    projects. After discussion and due consideration of different opinions, a
    decision should be publicly recorded (where GitHub is used as the resolution
    of an Issue).

    If substantial disagreement remains (e.g. the Group is divided) and the
    Group needs to decide an Issue in order to continue to make progress, the
    Committers will choose an alternative that had substantial support (with a
    vote of Committers if necessary). Individuals who disagree with the choice
    are strongly encouraged to take ownership of their objection by taking
    ownership of an alternative fork. This is explicitly allowed (and preferred
    to blocking progress) with a goal of letting implementation experience
    inform which spec is ultimately chosen by the Group to move ahead with.

    Any decisions reached at any meeting are tentative and should be recorded in
    a GitHub Issue for Groups that use GitHub and otherwise on the Group's
    public mail list. Any Group participant may object to a decision reached at
    an online or in-person meeting within 7 days of publication of the decision
    provided that they include clear technical reasons for their objection. The
    Chairs will facilitate discussion to try to resolve the objection according
    to the decision process.

    It is the Chairs' responsibility to ensure that the decision process is
    fair, respects the consensus of the CG, and does not unreasonably favour or
    discriminate against any Group participant or their employer.
"
gc/2021/GC-07-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 13 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: July 13, 4pm-5pm UTC (July 13, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Problems with nominal types [Andreas Rossberg] (1 hour)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Tim Steenvoorden
- Manos Koukoutos
- Ross Tate
- Alon Zakai
- Conrad Watt
- Andreas Rossberg
- Francis McCabe
- Zalim Bashorov
- Ryan Hunt
- Emanuel Ziegler
- Adam Klein
- Daniel Wirtz
- Asumu Takikawa
- Slava Kuzmich
- Jakob Kummerow
- Keith Miller
- Luke Wagner
- Fil Pizlo
- Deepti Gandluri
- Petr Penzin
- Paulo Matos
- Ioanna Dimitriou


### Discussion: Problems with nominal types [Andreas Rossberg] (1 hour)

AR presenting [slides](https://github.com/WebAssembly/meetings/blob/master/gc/2021/presentations/2021-07-13+-rossberg-modulariy.pdf)

AR: The different degrees of modularity are part of the value proposition of Wasm in my view.

RT: These are components like Luke explained, right?

AR: Not necessarily, these components could be anywhere on the range of coupling from the previous slide.

CW: But we’re drawing a distinction between components and modules. If you get too far away from Luke’s model, that might not be useful any more?

AR: Not sure what you mean. There are two things Luke proposed. The module linking proposal that does not commit to an abstraction layer and then interface types which establishes a particular abstraction.

RT: In the highly-coupled setting, one of these components might be a language runtime.

AR: Yes, absolutely.

CW: By calling these separate components, we’re going to get some accidental cross-pollination of rhetoric.

AR: How about libraries?

CW: What about modules?

RT: Packages.

AR: “Packages” sounds good.

< demos of a REPL for a toy object-oriented language that incrementally generates and loads modules that can use previously used modules >

CW: Comment about goals: We already hit on a kind of idea that we would be ok not supporting separate compilation of mutually recursive types. So we already don’t support some things. Is there more wiggle room?

AR: Will come back to that and motivate making this distinction in a couple slides.

AZ: It’s true that it’s possible to do these things in Wasm today, but using things that are not in core wasm, e.g. wasm-ld and object files. For dynamic linking we add a dynamic linking section and it is rather complex. I expect we would need to do the same for Wasm GC.

AR: Fair point, but I would argue that dynamic linking can be simple. Things are complicated because we are emulating native ld, not by necessity.

TL: That complexity is necessary to support real-world ecosystems when not spinning up a new language/ecosystem with the freedom to do the simple thing.

RT: Are you saying it’s currently possible to do deferred linking without knowing types?

AR: Yes, you link the RTTs the same way you link the functions.

RT: In my example, to create a Foo, you need the Rtt for Foo. In many languages you don’t need the dependent Bar to be loaded first. High level point is that you’re overstating what is possible.

AR: The point is that this [deferred linking] is a non-goal because we don’t expect to support it without overhead.

TL: I hope we can all agree that these are non-goals for the MVP, regardless of how well we could support it in the future.

RT: The J2CL team requested deferred loading.

CW: It’s not clear that they meant the kind of deferred loading that AR is saying is a non-goal here.

RT: I’m not comfortable declaring this a non-goal without more feedback from the community.

AR: At least it is for the MVP.

CW: When you say imports are an implementation detail of each module, it seems that even with equirecursive imports, if you had a convention of not importing anything, then you still need to care about what the other module is importing because it may have a different convention that requires e.g. importing RTTs.

AR: I’m talking about a typical module system where you’re not explicitly instantiating modules. The instantiation is an implementation detail.

CW: So this is just describing the user experience at the source level?

AR: Yes, a language module model, but also a lower-level import semantics.

TL: What about the linker/loader that has the global knowledge that may or not be more Wasm?

RT: There just needs to be a convention that allows the linker/loader to load everything.

CW: To cut to the chase, this is going to lead back to the discussion of whether nominal types allow for such a convention.

CW: I appreciate the distinction between the point of view of the app, registry, user, linker, etc. But the registry needs to know the full client set eventually, but it might grow over time.

AR: Yes, but critically it does not know the full client set up front.

RT: The loader I sketched with nominal + staged compilation looks similar and can support.

CW: Can also just keep track of the things exported so far?

TL: It seems that the big picture is that AR is getting to the point that equirecursive types are more expressive and able to easily handle these dynamic repl-type situations. It seems that RT’s response is that the staged type linking

RT: If two modules are independent, then they only share runtime types. If they aren’t dependent, then they can import / export from each other.

AR: That conclusion is false.

RT: It would be great to see an example.

AR: Getting to it.

CW: It’s ok if nominal typing is less expressive, as long as it’s less expressive in ways we don’t care about.

TL: To be clear, most source level languages have structural types that do not rise to the expressivity of full equirecursive types.

CW: It also seems that you don’t need binary compatibility of the structural types. For example in OCaml and Haskell.

AR: No, of course you do, you can separately compile OCaml and Haskell modules and they need to agree.

RT: The reason is because there is a runtime type constructor.

AR: In native compilation, at some point in the pipeline types are erased, but that doesn’t make the compatibility problem go away. In Wasm we cannot erase types.

RT: In OCaml, the function type A - > B compiles down to OCamlRef.

AR: Yes, but then you have to downcast where you use the function and the caller and callee still have to agree on the type structure.

RT: The runtime package can provide the package type.

AR: Not if they’re infinite in number, for example the infinite space of tuple types.

RT: The only example so far of infinite structural types is tuples. Many runtimes lower tuples to max sizes.

AR: But it’s still exponential in the width of the tuple because each element can be a different type.

RT: Without generics, you would just have “tuple of size 2” rather than “tuple of int and float”

AR: I would definitely want to unbox a “tuple of int and float”

RT: Many systems work perfectly well with just “tuple of size 2.” Only C# does otherwise.

AR: The Wob compiler uses “tuple of int and float”. Waml unboxes all structure fields. This isn't uncommon. 

TL: We’re at time, so we should continue next time.
"
main/2024/CG-04-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 9th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: April 9th, 16:00-17:00 UTC (09:00-10:00 PDT, 18:00-19:00 CEST)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Announcement: Nominating Thomas Lively as CG co-chair (Deepti Gandluri, 5 mins)
    1. SpecTec update (Andreas Rossberg & collaborators, 40 minutes)
        1. Repo: https://github.com/Wasm-DSL/spectec/tree/main/spectec
    1. Phase 3 poll for ESM Integration (Guy Bedford, 15 minutes)
        1. Repo: https://github.com/webassembly/esm-integration
        1. Slides: https://docs.google.com/presentation/d/1iZzoRE3LhlMuJz8-npW5Kc9GnUydVI6PPj8lgPuwdi4/edit?usp=sharing
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
 - Yuri Iozzelli
 - Derek Schuff
 - Dongjun Youn
 - Sukyoung Ryu
 - Kirk Shoop
 - Fedor Smirnov
 - Andrew Brown
 - Yury Delendik
 - Ilya Rezvov
 - Thomas Lively
 - Jae Hyun Lee
 - Jeff Charles
 - Emanuel Ziegler
 - Sam Clegg
 - Conrad Watt
 - Ben Visness
 - Paolo Severini
 - Ryan Hunt
 - Daniel Hillerström
 - Deepti Gandluri
 - Zalim Bashorov
 - Robin Freyler
 - Nick Fitzgerald 
 - Jakob Kummerow
 - Andreas Rossberg
 - Michael Ficarra
 - Guy Bedford
 - Keith Winstein
 - Manos Koukoutos
 - IS
 - Johnnie Birch
 - Brendan Dahl
 - Matthias Liedtke
 - Nuno Pereira
 - Francis McCabe
 - Richard Winterton
 - Daniel Lehmann
 - Thomas Trenner
 - Chris Woods
 - Julien Pages
 - Sam Lindley


### Proposals and discussions

#### Announcement: Nominating Thomas Lively as CG co-chair (Deepti Gandluri, 5 mins)

Deepti will be stepping down as CG co-chair (but will continue participating in the CG) and is nominating Thomas Lively as a new co-char (to continue with Conrad and Derek). Anyone who has comments, questions, or concerns should contact the chairs before the next meeting.


#### SpecTec update (Andreas Rossberg & collaborators, 40 minutes) [slides](main/2024/presentations/2024-04-09-rossberg-spectec.pdf)

Repo: https://github.com/Wasm-DSL/spectec/tree/main/spectec

BV (chat): When we say ""prose"", do we mean the sort of prose in the validation and execution sections?

AR: Yes, and the auxiliary definitions, and other stylized pieces that we have in the spec.

[spectec paper](https://people.mpi-sws.org/~rossberg/papers/spectec1.pdf)

FM (chat): What steps do you expect to happen after CG sign off?

AR: Getting the spec conversion to the point where it’s complete enough where it makes sense, where we’ve converted whole chapters and not just random bits, e.g all of execution, 
binary format as well. Rendering is good enough to replace hand-written spec.

Also we want to have the tool mature enough and UX and docs good enough that other people can use it.

FM: suppose we said yes, what would happen right after that?

AR: we are still committed to continue working on this for a long time. We have research ideas and other groups are looking into this as well. We won’t necessarily do everything they want but it has a broad enough interest .

CW: there wouldn't be an immediate switchover. This is about a statement of intent so we can justify continuing to work on it, and then at some point later we’d want to officially look at the product and decide when to integrate it.

FM: Ok. Follow-on. Because it won't be a bit-for-bit replacement of the existing spec, will we need additional process at the W3C level?

AR: the document itself is very incremental. We’ve set up the infrastructure so you can substitute things piecemeal. The overall doc is basically the same modulo minor layout, but it doesn’t replace the whole document, but only how pieces are generated. So I don’t think W3C should care.

CW: In particular as long as we can generate a doc that satisfies their criteria in terms of indices, TOC, etc. it shouldn't be a problem.

AR: from their perspective it’s purely editorial changes. We already have quite a bit of a toolchain to generate a W3C document and this is just another step.

MF (chat): since this is entirely editorial, I would say it should be up to editor discretion whether to switch toolchains

AR: not necessarily. It’s an investment if we add something nontrivial to the toolchain and it will require investment in the toolchain. If it’s injected into the critical path of maintaining the document it also affects not just the editor but also proposal authors and others downstream. But also this is not a dead end. We can generate a document and if the whole toolchain breaks down, we could take the output and continue to work on it. Not ideal but not too different from what we have now.

ZB: Would it be possible to combine in-progress proposals automatically? E.g. generate an interpreter from in-progress proposal, e.g. if someone depends on more than one in-progress proposal it would be great if you could generate the interpreter that they could use.

AR: I don't think there's any magic there. If there are multiple proposals, it will be some work to combine them.

ZB: when there are interactions, one proposal depends on another, so the the last one could define some override rules or something, we could find ways to make it easier.

AR: right now the structure of the spec files is a bit monolithic. One thing I'd like to add is an include capability so you can modularize a little bit and make it easier to combine stuff. But it doesn’t solve the general problem in principle. E.g. you still have to resolve when you have diamonds. But it could still help with that; but it’s not a problem we are trying to solve with this, and I don’t really know how to solve it.

CW: the situation with conflicting proposals is particularly bad now because you have to merge latex. Hopefully this syntax will be better but there could still be conflicts.

AR: the more annoying conflicts are in the prose, and it gets really bad. Part of this is with rst, you have to renumber things, and makes big conflicts. Hopefully we can go to auto-numbering with the tool.

TL (chat): Andreas Rossberg, process-wise, I think a normal consensus vote at the F2F would be sufficient as a formal declaration of intent to adopt the new infrastructure. No need for the phase process. However, it's important that stakeholders can do due diligence before the vote. I'll take a look at the paper and file an issue with questions and documentation suggestions soon.

(three thumbs up reacts)

### Phase 3 poll for ESM Integration (Guy Bedford, 15 minutes)

Repo: https://github.com/webassembly/esm-integration

GB: I’ll just cover updates since the last presentation

.. presenting

CW: you used the term “cyclic module record”:  is there any case where wasm could have to deal with dependency cycles?


GB: no, it refers to ECMA spec terminology, it doesn’t refer to “cyclic” in the way you’re talking about.

CW: this was the criteria we informally agreed on in the previous meeting, and we do seem to have met this.

GB: the implementation of the module shims is passing the web platform tests (this was deemed more relevant than having core wasm tests).

SC: question about source imports: does that allow us to still get the benefits of instantiate-streaming?

GB: yes, compile streaming, but we've moved to sync instantiation.

AR: if we needed to annotate imports in wasm, could we use a custom section to do that?'

GB: Right, in JS we have import attributes, string-to-string maps.

Vote to advance ESM integration to phase 3

SF: 3
F: 15
N: 7
A: 0
SA: 0

Poll passes, ESM integration to phase 3."
main/2020/CG-09-15.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 15th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: September 15th, 4pm-5pm UTC (September 15th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. [Proposal for changes in EH proposal for two-phase unwinding support](presentations/2020-09-15-ahn-eh-two-phase-unwinding-pt2.pdf) Part 2 + discussions (Heejin Ahn) [30 min]
       - Potential poll: Should we make the change?
    1. Proposal for a new sub-group focusing on stack issues (Francis McCabe) [10 min]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Adam Klein
* Alon Zakai
* Andrew Brown
* Asumu Takikawa
* Ben Smith
* Clemens Backes
* Conrad Watt
* Daniel Hillerström
* Daniel Wirtz
* David Piepgrass
* Derek Schuff
* Emanuel Ziegler
* Francis McCabe
* Heejin Ahn
* Ioanna Dimitriou
* Jakob Kummerow
* Jay Phelps
* Lars Hansen
* Luke Imhoff
* Luke Wagner
* Manos Koukoutos
* Mitch Moore
* Nabeel Al-Shamma
* Nick Fitzgerald
* Paolo Severini
* Pat Hickey
* Paul Dworzanski
* Petr Penzin
* Rich Winterton
* Rick Battagline
* Ross Tate
* Ryan Hunt
* Sabine
* Sam Lindley
* Sean Jensen-Grey
* Slava Kuzmich
* Thomas Lively
* Vivek
* Wouter Van Oortmerssen
* Zalim Bashorov
* Zhi An Ng

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Derek seconds

### Proposals and discussions

#### Review of action items from prior meeting.

#### [Proposal for changes in EH proposal for two-phase unwinding support](presentations/2020-09-15-ahn-eh-two-phase-unwinding-pt2.pdf) Part 2 + discussions (Heejin Ahn) [30 min]

[Heejin presenting]

LI: How does catch_br interact with unwind, I assume it skips the catch branches, similar to unwind?

HA: we don’t need to consider unwind and catch_br... 

RT: I think you can think of catch_br saying reuse the handler, so unwind still uses the same unwind.

HA: we need to consider unwind, because try can have labels, we can consider unwind as a target for catch_br, we don’t need to rename it. It helps us find next frame to search for, if it says unwind, continue the search. Catch_br tells us which to check next, it can be either unwind or catch. In second phase, we have to visit every unwind block. To visit the right sequence of unwind blocks, we need that catch_br.

LI: Yes, that's what I thought. And you addressed my other concern which is that catch_br can branch to another unwind. Combining the catch/unwind names would be verbose.

TL: question about last slide. Where the label corresponded to the function. Is that an extension? You were pointing that the proposed changes allowed for that? Or are you saying we can allow for it in the future?

HA: We need it, without that we don't have any way of redirecting the exception to the caller. It happens not infrequently even now. We're dealing with it on exnref, by adding an extra block that wraps the whole function. We are simulating that with exnref now, so now that we don't have exnref we need a way to do this.

BS: question about rethrow with immediate argument. That can be implemented by branching out of block and rethrowing while still inside the outer try.

HA: possibly. I don’t have a full knowledge of possible future list of things we are going to support. But C++ is not going to use that future. If we have feature we will always set that to 0. We won’t need that immediately. I wasn’t super closely involved with the first version of the discussion, wondering if people who were there remember why this was introduced, or know why other languages think they need it.

##### Potential poll: Should we make the change?

| SF | F | N | A | SA |
| - | - | - | - | - |
| 7 | 14 | 7 | 0 | 0 |

Poll passes

#### Proposal for a new sub-group focusing on stack issues (Francis McCabe) [10 min]
(signup form)[https://docs.google.com/forms/d/e/1FAIpQLSfB-QGuZcOokHaaLF_Gl2mF1FVZQZq2LwbGw7U9-x6tmieJKw/viewform]

LH: Why should we not keep these topics in the main CG?  What’s the CG doing that prevents it from tackling these issues?

FM: Mostly a question of bandwidth and time, seems like we are often running out of time in the CG meetings. 

ID: Is this also connected to the typed continuations proposal?

FM: Yes, that would be appropriate for this meeting. There are a family of efforts that we have interest in.

RT: The form you sent out has bullets instead of check boxes, may want to fix.

FM: I'll fix.

CW: some of the proposals mentioned in the slides seem interesting because they extend how control flow works. Could extensions to exceptions end up interfering with some of this things this sub group will talk about

FM: EH is a potential topic… this isn’t to replace any decision making or discussion point. I would expect that EH would be the sort of thing we will talk about

CW: Is this really a control-flow subgroup then?

FM: could be another way of thinking about it yea.

HA: I think exception handling is related, depending on how which way we take it, maybe only tangentially or significantly. Two-phase unwinding changes things in various ways, and we haven't decided which to go. In theory the overhead is too big, but we could use two-phase unwinding to handle these things. We could extend ...

FM: need to be clear about something, we are not making any particular proposal here. If you wanted to be able to discuss and have more time to talk about EH issues, this is a good place to have it.

CW: It seems like there could be a divergence that discussions would happen in the subgroup and then not filter to the larger group.

RT: other purposes of this group will be to coordinate those sort of things

HA: don’t think EH should be exclusively discussed in that, might have some intersection between EH and stack. E.g. Ross is proposing something related to EH and stack. There are some intersection between these 2, but EH shouldn’t be exclusive to that meeting, agree with that.

LI: There's already overlap between the subgroups and main groups. Debugging for example. Seems to be OK so far.

TL: think this is extra bandwidth on top of what we already have. Meant to be additive, and not detract from the main group.

BS: opportunity for better communication. Perhaps subgroups should take the chance to present to the larger group, to make it clear to larger groups that bigger decisions are made.

FM: From a process point of view, I'm not proposing that the subgroup takes ownership of decision making. If there's a decision to be made, it should be made in the larger group. That should streamline the main groups discussion. If you had a deeper discussion about a topic, then you could make a summary to the main group.

BS: next steps will be to fix the forms…

FM: fixed

BS: have people fill out the form, by the next CG meeting we’ll see

BS: at least 1 meeting will probably be fine

### Closure
"
main/2019/CG-01-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 22 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: January 22, 5pm-6pm UTC (January 22, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email Ben Smith to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. [Coordinate encodings between bulk memory and reftype proposals](https://github.com/WebAssembly/reference-types/issues/18)
    1. [WebAssembly SIMD issues](https://github.com/WebAssembly/simd/issues) triage meeting on 01/23/2019, at 2:00PM PST. Fill this [form](https://docs.google.com/forms/d/e/1FAIpQLSfCbRJXnTjDJw5Ei6k5M4vzj1VAr34_Jg_W4bKbqpj3ZMfaeA/viewform?usp=sf_link) to be emailed a link to the meeting.
    1. js-api updates
        1. [inconsistent utf-8 decoding](https://github.com/WebAssembly/spec/issues/915) follow up; a [PR](https://github.com/WebAssembly/spec/pull/947) is available.
        1. Please review [update limits.any.js](https://github.com/WebAssembly/spec/pull/946) and [sync wasm-module-builder](https://github.com/WebAssembly/spec/pull/944).
    1. Split typed function references from GC into [their own proposal](https://github.com/WebAssembly/gc/blob/funcref/proposals/gc/Funcref.md).
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Adam Klein
* Alex Crichton
* Andreas Rossberg
* Arun Purushan
* Ben Smith
* Conrad Watt
* Daniel Ehrenberg
* Deepti Gandluri
* Francis McCabe
* Gus Caplan
* Heejin Ahn
* Jacob Gravelle
* Jensen Grey
* Keith Miller
* Lars Hansen
* Limin Zhu
* Luke Wagner
* Richard Winterton
* Sven Sauleau
* Thays Grazia
* Thomas Lively
* Yury Delendik

### Find volunteers for note taking (acting chair to volunteer)

BS takes notes.

### Adoption of the agenda

Lars seconds

### Proposals and discussions

#### Review of action items from prior meeting.

#### [Coordinate encodings between bulk memory and reftype proposals](https://github.com/WebAssembly/reference-types/issues/18)

LH: two things here. We're not making a lot of progress on bulk memory.
Reftypes proposal has ideas about encodings, it has multiple tables and so on.
It makes assumptions about encodings so we need to decide soon.

BS: Seems like we've aligned behind two bytes instead of a flag byte.

...

BS: What are the other things we need to decide now?

LH: Table.fill? Should we assume this will land at the same time.

AR: One or two of the instructions need to be spec'd as well. Then they will
reference the ref types.

BS: Concern about creating a prereq chain.

LH: We assumed feature testing. Could ship bulk tables without bulk tables.

BS: May have issues with tooling and such.

AR: Hard to use a feature without all browsers already. Recommend not using
till everyone has it. Don't recommend feature testing.

DE: I think it's a real danger that we could end up in elaborate feature
testing paths. In JS we've seen this. I try to encourage people in JS shipping
features as a whole. Has been hard to do this, seems like an OK pragmatic path.

AR: I hope that we can't compare JS w/ wasm here, because it's user-facing, and
regarding libraries. For Wasm it's most interesting w/ features that you can't emulate at
all, but then feature test doesn’t help.

DE: Hope you're right, but we've seen this in tools. This had concrete compat
impacts.

BS: w.r.t. splitting bulk memory out from bulk table.

AR: No concerns.

DE: Most important that MDN and browser compat info is documented properly.
Don't worry about proposal repos.

AR: One comment; the most important thing is when we move to phase 4. Shipping
in phase 3 means users have to be careful.

* Some comments about shipping phase 3 vs phase 4 *

#### [WebAssembly SIMD issues](https://github.com/WebAssembly/simd/issues) triage meeting on 01/23/2019, at 2:00PM PST. Fill this [form](https://docs.google.com/forms/d/e/1FAIpQLSfCbRJXnTjDJw5Ei6k5M4vzj1VAr34_Jg_W4bKbqpj3ZMfaeA/viewform?usp=sf_link) to be emailed a link to the meeting.

DG: There's going to be a meeting to triage the SIMD issues. We want to bring
things up, and move it forward. There's a form that's linked.

#### js-api updates

* [inconsistent utf-8 decoding](https://github.com/WebAssembly/spec/issues/915) follow up; a [PR](https://github.com/WebAssembly/spec/pull/947) is available.
* Please review [update limits.any.js](https://github.com/WebAssembly/spec/pull/946) and [sync wasm-module-builder](https://github.com/WebAssembly/spec/pull/944).

SS: utf-8 decoding between section names and API. Creates mismatch between
surrogates. Have PR that switches from UVString to DOMString. We cannot
normalize surrogates anymore. It would be nice if someone can review it.

BS: Probably best for Dan or ms2ger to review.

SS: I have updated the limits tests, I want to synchronize the
wasm-module-builder in v8 w/ spec repo.

BS: Sounds like we just need to review and merge.

#### Split typed function references from GC into [their own proposal](https://github.com/WebAssembly/gc/blob/funcref/proposals/gc/Funcref.md).

AR: We've discussed this a few times before. There's a link here; copying out
function references from the GC into its own repo. That contains function
references, forming a reference, calling a reference, and func.bind creating a
closure.

New block type that introduces new locals (let). Because refs don't have a
default value.

One open Q: whether optional refs should be part of that proposal. How relevant
is not clear to me. Some bikeshedding about names.

LH: Were you thinking about advancing more quickly than GC?

AR: Yes, that's the idea.

DE: Are the browsers interested in shipping this proposal?

AR: Maybe Lars?

LH: not committing to this yet, but think it's interesting.

AR: func.bind is the most controversial part, because it's a closure. If that’s an obstacle we might want to separate it

LW: Already kinda is a closure, because they close over the instance.

AR: Hope is that it isn't a significant extra cost as a result.

BS: Unanimous consent?

FM: Can't do closures without GC...

AR: They already are closures -- in a fully static setting you might imagine that
instantiation is static, then a function pointer is more expensive.

LW: I think that you could do ref counting instead here.

FM: How will these be stored? In a table?

AR: This builds on top of ref type proposal, so yes.

FM: This is an issue for languages ... that need to put a closure in an object.

AR: You need to create an indirection, store a table index in linear memory.

FM: I'm not sure you can do that.

AR: We're already doing this; you can ref count if you don't want to use full
GC. It's more awkward to use than GC types of course, but this is meant to be an
intermediate thing.

One example: if you want to communicate a function from one language to another
you can't do this with in-memory-closures; you need this to be built in.

FM: The closure needs an environment. Does this have a standard layout?

AR: No, it's completely opaque.

FM: So you need to call, is that in the proposal?

AR: Yes call.ref.

FM: Need to have the function and environment...

AR: The engine has its own heap that you can't access. In current engines that
is identical to the JS heap. In standalone engines they'll also already have their own heap
somehow. They'll have to manage memory for various instances.

FM: Seems an awkward representation.

LH: Why is that?

FM: If I'm implementing closures, it's an n+2 record, size, code, ...

AR: In reality, with your own closure in linear memory, you have a record n+1, code pointer really is a pointer to another heap object, which has the pointer to the actual code and its module instance. This proposal allows to merge these records.

FM: I didn't see this [AR: sorry, it's new from a day ago].

AI(BS): Discuss this in the next meeting.

DE: Related question about splitting proposals. I was wondering about the array
types in the GC proposal. But made a bug item instead.

### Closure
"
wasi/2021/WASI-01-28.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the January 28 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: January 28, 17:00-18:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Lin Clark
    - Email: lclark@fastly.com

### Registration

None required if you've attended before. Email Lin Clark to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. Lin Clark on WASI modularization milestone
1. Proposals and discussions
    1. Presentation: Update from Luke Wagner on handles and resources in interface types
    1. _Sumbit a PR to add your agenda item here_

## Meeting Notes
### Attendees
- Martin Duke, F5
- Sam Clegg
- Dan Gohman
- Luke Wagner
- Mark McCaskey
- Lin Clark
- Dave Protasowski
- Alex Crichton
- Andrew Brown
- Mingqiu Sun
- Till Schneidereit
- Pat Hickey
- Josh Dolitsky
- Matt Butcher
- Ralph Squillace

### Announcements
**Lin Clark:** We now have a [milestone for WASI modularization](https://github.com/WebAssembly/WASI/milestone/1). Will be using milestones more in the future.

### Proposals and discussions
#### Presentation: Update from Luke Wagner on handles and resources in interface types [(Slides)](https://docs.google.com/presentation/d/1ikwS2Ps-KLXFofuS5VAs6Bn14q4LBEaxMjPfLj61UZE)

**Luke Wagner:** Handles and resources. Have been working on this for a while with a number of y’all
Give background, motivating problems, and proposed solution
Not at all final, still working on a PR. Your feedback is most welcome

IT gives WASI a bunch of value types
In addition to core basic types, a bunch of abbreviations
Don’t want to have to add core types
This lets us take a WASI function and use a bunch of high level types

Plan of record for a while has been abstract types for file descriptors
Type imports builds on reference types
Reference types are unforgeable, better than ints

How does this get virtualized?
Virtualization is a core value of WASI. You can implement with another WASI module
For this, we use module linking proposal

What does it look like to write that virtualized WASI? (walk through)
Packed the file index into the reference, that’s efficient

Type imports and exports are transparent by default
This is forgeable. That’s why that was take one

Type imports has a private type definition
I would take abstract type and make it a private type definition
Private.get and private.new only works inside module that defined the type definition
These private types have to be boxed. 
Actually no worse than the native implementation to have one level of indirection

Two remaining problem areas: resource lifetimes and dynamic casting

Resource lifetimes
How do resources get released?
Could reference count. 
Problematic for a variety of reasons. 
Not virtualizable. 
Because of downsides, WASI resources have explicit destructor

Virt WASI then looks like….
What happens on double close or use-after-close?
Spectrum of options, none of them good
How do I efficiently support cross-instance resource sharing?
Not great options either
How can a WASI impl robustly clean up after clients are destroyed?
Could leak.
Want FDs to be closed when the instance goes away, just like OS process
A native WASI impl could do this, but not a virtualized one
How do instances even get different lifetimes? This is a next step, to add ability to dynamically create and destroy instances
Also problems around dynamic casting
E.g. when store n distinct DOM node types in a single table
Not supporting would be a kind of regression

Dynamic casting breaks otherwise-static invariants
If there’s a run function and I pass a RO, is it possible for X to somehow do a write?
It would be nice to have that answer based only on the static type
Fix is to treat different imports as different things for purpose of dynamic cast
To fix this, you need a wrapping at some membrane/boundary
OK for core wasm, because that’s just a compiler target
But not ok for ecosystem

When we’re virtualizingWASI we want: …
Is all of this just for virtualization?
Resources are not a uniquely WASI concern
We should treat WASI as an unprivileged set of library interfaces

Proposal
Add a new interface type called handle
Handle is a value that can be copied
Refers to a resource
A resource is some entity with a lifetime. It can not be copied
So resource types are like abstract type, but only private option
Additionally resource type definitions can have an optional destructor
Resource creation and use is symmetric to private.new/get
Handles are semantically ref-counted and call the destructor when they get to 0
That’s what gives virt WASI same privileges as native
Also possible to explicitly destroy handles, and references trap

**Sam Clegg:** would need to be at WASI core?
**Luke Wagner:** So far everything in Interface Types

**Pat Hickey:** Attenuation
**Luke Wagner:** I’ve gone back and forth. Have an idea in open questions

**Luke Wagner:** High level summary of IT
They’re lazy copy operations
Need a way to box all interface types
Generally valuable because it solves interesting performance use cases
For handle values, creates a root that creates the stack
That makes it so handles can outlive stack frame

Once I have a reference, it can be cast
Will always trap if cast to differently privileged 

IT gives us the boundary/membrane where to wrap

Proposal summary
Additions
New types
New definition
New instructions
Extend rtt.canon

Problems:
Robust and efficient handling of double-free/use-after-free
….

Open Questions
Add abstract subtyping?
Should we have specialized versions of handle (e.g. a strong handle, unique handle)

Next steps
Need to give lifetimes to instances
Can instances just be resources?
Could implement WASI command pattern in the toolchain rather than host magic

**Sam Clegg:** What happens if you destroy a resource and another module still has a copy

**Luke Wagner:** It will have a handle. That handle is then in a null state. When you try to use the handle, it would trap probably at resource.get

**Sam Clegg:** So the trap would happen in the callee

**Luke Wagner:** That’s where we might want to have a strong handle where no one could pass you an invalid handle. It’s an open question

**Ralph Squillace:** For what it’s worth, I’ve been spinning around Pat’s question and going back to DCE-RPC. Believe that you should make or signal a strong decision about shared resources. 

**Luke Wagner:** That’s one of the reasons I like unique, because then when I give you a handle I’m explicitly saying I dont’ still have it. I guess that’s an argument for both unique and strong

**Ralph Squillace:** Having the ability to make those choices is what comes to mind. If I choose a convention, I can signal it to others. Previous technologies tried to let people do it without signaling capabilities

**Luke Wagner:** Would a summary be that you’re in favor of those two types of handles

**Ralph Squillace:** I would say those two handles express two slices of the problem space. I wouldn’t say that I’ve thought through other possible types.

**Luke Wagner:** Your’e right, I was trying to survey the literature and there are like 20 types

**Ralph Squillace:** Even if you don’t have strong type, at least you can trap. Maybe that’s the first step.

**Luke Wagner:** Hierarchy, undefined is worst, trap is better, statically preventing is best

**Sam Clegg:** These handles are at IT types and at core go to reference. So references can be copied

**Luke Wagner:** Once you exclusively use IT, there’s no back door

**Sam Clegg:** Any incremental steps?

**Luke Wagner:** In some sense, witx already has handle

**Lin Clark** proposes that we make that the main topic for next meeting

"
stack/2021/sg-6-28.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 28th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  June 28th, 16:00-17:00 UTC ( June 28th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants

 - Francis McCabe
 - Elle Imhoff
 - Ross Tate (RT)
 - Thomas Lively (TL)
 - Luke Wagner (LW)
 - Daniel Hillerström
 - Alon Zakai (AZ)
 - Arjun Guha (AG)
 - Zalim Bashorov
 - Thibaud Michaud (TM)
 - Sam Lindley (SL)
 - Ioanna Dimitrious
 - Heejin Ahn
 - Rick Battagline
 - Paul 

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. Progress on JS API for stack switching (Ross Tate & Luke Wagner)
   1. Next meeting [2 mins].
1. Closure

## Meeting Notes



### Adoption of the agenda

### Discussion:

[RT presenting “JS API for suspending wasm on promises” [(pdf)](presentations/2021-06-28-tate-async-await-js-api.pdf) [(pptx)](presentations/2021-06-28-tate-async-await-js-api.pptx)]

RT: FM, LW, AZ and I have been meeting to discuss this.

[Slide: Understanding Usage Scenarios]

RT: AZ helped us understand classes of exports.

[Slide: Balancing Tradeoffs]

RT: LW introduced bindAsync while I introduced instantiateAsync.  They are on opposite ends of a spectrum.

[Slide: JS-Wasm Interchangeability]

SL: Going to show examples?
RT: Few slides after showing considerations.
SL: Concrete examples would help

[Slide: JS-wasm cross-call]

RT: Have to check if on the JS or separate stack
TL: Performance overhead on existing engines?
RT: We think not much overhead when checked with TM for V8.

[Slide: Example Usage]

RT: Wasm functions return i32 and doesn’t worry about Promises.

[There is an error in the code that uses parseFloat instead of the updated parseInt]

RT: Without suspender.returnPromiseOnSuspend, main would trap when called when it hits a JS Frame.
AG: Re-entrancy restrictions?  Can call main again?
RT: Can’t call main again.  Prevents re-entrancy. Forward-compatibility could allow it.
FM: To clarify main could not be called, but unwrapped exports could be called.
RT: Make a Suspender to wrap imports and exports.  The same Suspender can be used if multiple modules are using the same shadow stack.
FM: How does it solve the shadow stack alignment.
RT: It does not because we gave up on that guarantee.  You have to use Suspender right to maintain invariants.
LW: If you don’t wrap and try to call, it will trap.
RT: Right
LW: If you called an wrapped export it would fail, so you don’t need to worry.
RT: If called from JS it will fail.
SL: I have a basic question.  From a basic perspective from WASM, sync and async is the same.  This is only different from the JS side.
FM: That is the intention.
RT: We didn’t want to change wasm.
SL That seems fair.

[Slide: Semantics]

RT: Caller is Active state is a delimited continuation, but just calling it “caller” for now.

[Slide: susp.returnPromiseOnSuspend(func)(args)]

SL: Can I ask a quick question?  There can only be 1 caller?
RT: Yes, you’ll see that because there the state has to be inactive (no caller).
SL: Thanks.
RT: Conceptually step (3) is on a new stack, but it doesn’t need to be.
SL: Can you elaborate on how caller became caller prime?
RT: Suspender is stateful
FM: When the promise is resolved, the `then` is the microtask runner.
SL: So you carried on the chain father.

[susp.suspendOnReturnedPromise(func)(args)]
RT: (1) checks that on the suspender’s stack.  (2) Suspending allows for an immediate stack switch to function’s stack.  (3) is on whatever stack the function belongs to.  Step (5) frames are the delimited continuation.  Can do (6) without an inspection of the stack, but implementation requires change to current JS to WASM calls, so there is overhead. (7.A) is on microtask scheduler.  Conceptually in (7.B) the caller prime is the microtask scheduler.

[End of Slides]

TL: On the last line when it is thrown as an exception, is it as WASM exception or normal JS exception?
RT: For onRejected it is something called from JS, so it is JS value, so the JS Exception API.
TL: The coerced value will be an externref?
RT: Yeah
FM: This is the same as if JS called an exception to WASM.
TL: Thanks.  Wasn’t sure if that was the intention.
AG: Just to clarify the suspender object tracks a single caller.  The JS can callback into WASM?
RT: Where are you in the timeline.
AG: WASM calls async JS, which can call into WASM.  There’s a restriction that WASM can’t call a suspender.
RT: It can’t call the same suspender.
RT: It can call a different suspender.  You can chain 3 WASM modules together and change any to use this instead and wrap them with a new suspender that will do the appropriate stack switching and it will all behave the same.
AG: This suspender has this little state, but multiple suspenders at once?
RT: Forward-compatibility can make a new suspender on the fly.
SL: Don’t you have the ability to make new suspenders?
RT: The susp callee actually an argument to the function.
SL: Isn’t passing susp to an outer function equivalent.
RT: can’t go into it, but you can’t
AG: Can a ask related question?  Going back to code example. 

[Slide: Example Usage]

You’re running async code in JS.  Ah, I see you’re returning a promise, when the fetch returns you resume into WASM.  Can you effectively unwind the WASM stack?  Can you abort an inner WASM suspension?
RS: I can use the code to show why extension is needed for multi-suspension.
AG: Does anything enforce a stack discipline from JS?  There is a different example where you call another function in WASM that calls another async import that is using a different suspender object.  Does this API give a stack discipline?  Do you need to return in the inner suspender before the outer?
RT: There is something more advanced where nested suspenders are effectively suspended, but nothing is enforced as a hierarchy and the order can change.
SL: Maybe you illustrate the example to my question.
RT: asyncimp is used to figure out the baked in suspender.  There is no way to have a suspendOnReturnPromise where suspender is a call argument.  I don’t want to think of a way to make it dynamic on the fly during the call.
FM: It does not change the export/import signature of the WASM.  If you want to dynamic suspender, you need to change the import signature to pass in the suspender.
SL: What I suggested you could do with suspender as an argument, just when you call sORP, but you need a concrete suspender.
RT: For multi-suspension to work you need to compile differently for multiple shadow stacks.  When doing that you can thread suspender through.  Currently WASM programs have 1 shadow stack.
LW: To make it complete, the multi-suspension.  It is common to call async functions and not wait for one to finish like 5 fetches in-flight.
SL: You could have multiple versions of a function.
TL: Multiple versions of the same function or multiple instances of the same module.
LW: JS API allows multiple instances.
RT: Talked about suspender pools.  
SL: Presumably multiple implementations instead of hard-wiring one pool implementation.
RT: Have to ensure JS frames not suspendable. 
EI: Would you need multiple suspenders for the usecase of event callbacks while previous events are still being resolved?
LW: If you …
EI: There’s the processes running in the background on timers or other non-DOM events driving by requestAnimationFrame. Then there’s the form interaction callbacks. They launch a new [erlang] process and can return to JS using the rust-wasm bindings support for returning promises.
RT: Out of time; would be good to send email to see if this use case requires an extension or not.


### Adjourn

"
gc/2021/GC-09-21.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 21 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: September 21, 4pm-6pm UTC (September 21, 9am-11am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Announcement: TC39 incubator call (Asumu Takikawa, 5 min)
    1. Discussion: Separate compilation (Ross Tate, 30+ min)
    1. Discussion: AOT compilation experiments (Ross Tate, 15 min)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Deepti Gandluri
- Sergey Rubanov
- Lars Hansen
- Asumu Takikawa
- Aske Simon Christensen
- Zalim Bashorov
- Francis McCabe
- Ben Titzer
- Rick Battagline
- Slava Kuzmich
- Jakob Kummerow
- Alon Zakai
- Igor Sheludko
- Ross Tate
- Petr Penzin
- Ryan Hunt
- Keith Miller
- Adam Klein
- Emanuel Ziegler
- Manos Koukoutos
- Michael Knyszek
- Ioanna Dimitriou
- Daniel Ehrenberg

###  Announcement: TC39 incubator call (Asumu Takikawa, 5 min)

AT: Thursday 23rd at 9 pacific. Intent to talk about Wasm and JS interop. Dan Ehrenberg will be presenting. Will not be specific to GC.

[calendar invite](https://calendar.google.com/calendar/event?eid=MmNkNWwybTNrdXRxYzN2M205c2YwM3FoZTcgbW96aWxsYS5jb21fbDdiNTBpdHBhYTlibnJ2cjYxbmVicXJuZThAZw&ctz=America/Los_Angeles)

###  Discussion: AOT compilation experiments (Ross Tate, 15 min)

Slides: [(pdf)](presentations/2021-09-21-tate-experiments-with-aot-compilation.pdf) [(pptx)](presentations/2021-09-21-tate-experiments-with-aot-compilation.pptx)

RT: Context is work on gradual typing. Have three benchmarks. AOT performs as well as JVM and Node on classes/objects benchmark. For short-lived objects, Racket’s GC makes it particularly fast and JVM’s speculative optimizations make it faster than everything else. Node is similar due to speculative optimizations. On float benchmark, packing floats has a large performance benefit over boxing floats. Takeaway is that AOT compilation of Java programs performs better than JS, so we should be able to see that Wasm GC performance match JS performance without advanced optimizations like Alon has been doing.

KM: What is the X-axis?

RT: Basically a continuum of source code typing between JS on the left and Java on right.

RT: We used call tags - basically how SpiderMonkey implements call_indirect - to handle bridging between typed and untyped code and for interface calls and lambdas and saw that it was faster than strategies implemented in other systems. Specifically call tags was just as fast as typed function pointers, so we hypothesize that using call tags instead of typed function references in WebAssembly would have the same performance but more expressiveness and flexibility.

###  Discussion: Separate compilation (Ross Tate, 30+ min)

Slides: [(pdf)](presentations/2021-09-21-separate-compilation-prioritization.pdf) [(pptx)](presentations/2021-09-21-separate-compilation-prioritization.pptx)

RT: Java modules are the unit of Java code that does not have recursion, which we’ve said we don’t want to support.

FM: What about mutual recursion between modules?

RT: I don’t believe Java supports mutual recursion.

TL: Where would you say the current proposal with the currently proposed type imports sits on this continuum?

RT: Seems to work out for splitting but not for Java modules.

BT: One weird thing I found is that in Java null is a bottom type but we don’t have a bottom type in Wasm. When you translate Java bytecode to Wasm, you need to compute where the nulls are going so you can add a (possibly imported) type.

AT: For “no separate compilation” slide, might you still need to import types defined in JS?

RT: I’m assuming that you would use a declarative custom section for interop rather than declaring types in JS.

KM: What about DOM integration? Could import type layout for fast access.

RT: If you’re importing the layout of engine-defined types, you’re exposing and standardizing engines’ internal representations. Need some sort of offset translation to keep that layout private.

BT: What are your thoughts on what to do about initializing objects/v-tables whose layout is defined across modules? Importing a struct with a vtable as its first reference requires it to be immutable to get depth subtyping for example.

RT: There are a number of solutions that we should talk about as a group. Can treat vtables specially to get the required subtyping, for example.

DE (chat): yeah agree that initializing things is hard and the current GC proposal doesn't handle the separate compilation of superclass/subclass for non-defaultable/immutable fields
I guess I figured that people had deemed that unimportant but this presentation gives reasons to doubt that

FM: What are the risks here?

RT: One risk is having redundant instructions, another is that we design ourselves into a corner and can’t add new things we want.

AK: What kind of work are you thinking of doing as a result of this conversation?

RT: Would design things differently if we know up front that we will want to eventually support separate compilation.

FM: You can have different compilation schemes or use different features if you (the compiler) know you are or are not doing separate compilation.

FM: Another way to look at it is to ask what communities are unlocking. If we’re heading toward supporting no separate compilation, what communities does that block?

AK: We have not seen that the teams we’re working with have needed separate compilation and separate distribution. We’ve talked about modularity, but mostly for development time so the requirements are completely different.

BT: We’re coming up from raw bytes to just barely having managed layout, so we should continue climbing up this ladder of expressiveness. We should anticipate that we might have field accessors in the future.

SK: Would be great for MVP to not block separate compilation, but I don’t think kotlin needs separate compilation now.

ASC: For dart, we’re most interested in deferred loading of some parts in a whole-program compilation setting. Also interested in modular builds where the compiler still sees the whole program.

BT: Is the splitting you’re talking about e.g. using a separate standard library or is it a custom splitting?

ASC: For the former, was thinking of a custom splitting.

DE: Can circle back to tools people in Igalia to see what they need. Also wondering how this would affect the JS interop story. If we think about separate compilation at all, there are plenty of other strategies like using numeric indices instead of separate vtables or using RTT-based dispatch. Don’t want to go back to the drawing board, but there’s a lot we could strip away.

AK (chat): +1, As someone who spoke up, I don't want my saying ""I don't think we need to support Java modules for the MVP"" imply ""please remove type imports""

TL: So far no one has spoken up with a requirement for separate compilation beyond splitting or parallel building + whole-program linking.

FM: This is really about what the application developers need, not just toolchain developers. Adam’s point was salient because he speaks for large Wasm application developers.

BT: I was also looking at IT and want to make sure IT can be lowered to GC types, so it can implement separate shared-nothing IT modules at least.

FM: Yes, that’s certainly the plan. The IT question here is whether separate modules cross ownership boundaries.

BT: It came up that Luke Wagner is working on a suite of new stream types, which is similar to generics.

FM: Not a goal to let folks “define their own types” in IT.

TL: At time and no one has expressed a concrete requirement for separate compilation, so I would lean toward not focusing on that right now for continued work, Ross.
"
gc/2021/GC-10-19.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 19 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: October 19, 4pm-6pm UTC (October19, 9am-11am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Presentation: Wob (Andreas Rossberg, 30 minutes)
    1. Presentation: Waml (Andreas Rossberg, 30 minutes)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Aske Simon Christensen
- Igor Sheludko
- Lars Hansen
- Zhi An Ng
- Paulo Matos
- Asumu Takikawa
- Ben Titzer
- Keith Miller
- Luke Wagner
- Andreas Rossberg
- Manos Koukoutos
- Ross Tate
- Alon Zakai
- Francis McCabe
- Jakob Kummerow
- Slava Kuzmich
- Fil Pizlo
- Deepti Gandluri
- Zalim Bashorov
- Emanuel Ziegler
- Sergey Rubanov

### Presentation: Wob (Andreas Rossberg, 30 minutes)

[slides](presentations/2021-10-19+-rossberg-wob.pdf)

RT: do you have interfaces?

AR: No interfaces, will get to what I don’t have.

BT: can you downcast from readonly arrays to mutable arrays?

AR: Arrays are not objects, so you cannot cast them at all. But you could wrap them up in an object and then cast that wrapper.

FM: why did you do Wob? what kind of experiments do you see being able to run with Wob?

AR: want to have something to experiment with and see if certain language features can be compiled. When I started this, Dart wasn't that far along yet, and other compilers like J2CL and Dart used whole compilation, I wanted to evaluate support for separate compilation with the current proposal, in both OO and functional setting. Don't think anyone has looked into how to implement currying.

FM: One reason for asking is that there are performance pain points that are showing up. Do you anticipate being able to run experiments about those?

AR: performance eval is not my first interest here, only validating expressiveness first, that I can actually compile, even though it's slower than I wanted. Performance evaluation is the second step after that. The compiler doesn't do fancy optimization, a one-pass compiler. One thing we can look at e.g. is where I use cast. Can get an idea of what constructs induce extra costs.

FM: will be interesting to look at performance down the road

AR: yes, I am interested as well, will be quite a bit of work to get sufficient optimizations. For straight line code it probably doesn't matter that much, worth playing with.

RT: if your goal is to eval separate compilation, what happens if you make tuples into objects?

AR: You mean like with a wrapper type?

RT: what other languages do, this is a class with vtable and operators on it?

AR: not sure what exactly your question is targeting. You can implement them as classes, it would be less efficient. Is your question about representation?

RT: A common issue is that particular tuple types need their corresponding particular vtables. How would you support that in your compilation scheme?

AR: good question, I don't know. There are reasons to not make them objects, think it is a bad langauge design. Will need to be solved as well, if you have a language with that semantics

BT: do tuples have identity in wob?

AR: reference identity. The obvious way around it is just box everything. Tuples are represented as arrays essentially. Easy way to get around separate compilation. But you miss the unboxing representation.

RT: then no longer have this 8^N issue as well

AR: doesn't seem particularly desirable. How you have unboxed structural types...

RT: C# does this as a concrete example

AR: C# uses runtime JIT-ting, which we don't have

RT: you can pre-generate, JIT is something it does to have faster load times

AR: not actually true in general, it is true with <missed this> but not with respect to type identity

FM: if you have a tuple variable with generic argument, will it match with a non generic value?

AR: when you compose and embed them you have to lower to eqref for that reason

FM: you wouldn't permit generic tuple with a byte

AR: you can have a tuple with generic type, but can't abstract over the byte type, only over the boxed byte type. No difference from Java.

TL: does the first class polymorphism imply that you need RTT values you need to pass into generic methods

AR: yes, need a runtime rep for types, will talk about it quite a bit

BT: do you canonicalize these type representation objects, or do deep comparison on cast?

AR: at the moment do not canonicalize, but you will want to do that in production quality implementation

FM: if you have a source level cast, you run a little proof that the thing you want to know is the right type in this sort of AST of types you have, then Wasm adds its own casting, then you're doing casting twice. Have you thought about how to organize this so that if the source level proof works, the the Wasm cast is implied

AR: how do you convince Wasm, without a powerful type system, that your source cast is right? What can work is to try to piggyback custom casts on Wasm casts, but we will need more features on the Wasm side as well.

BT: how exactly does that work? vtables have types themselves?

AR: vtable is struct, has to be struct since function types are diff

BT: this is the cast after you cast the wasm level struct

AR: this is the wasm level struct representing the vtable,

RT: lots of implementation of reified generics instead of putting type in objects, they put it in vtable

AR: But then you would need a new vtable for each instantiation.

RT: Usually that’s done during linking.

AR: Not good enough.

RT: Then have hashmap then get canonicalization for it

AR: usually the number of class in hierarchy is dominated by number of methods, not a deep hierarchy where every class just adds one method

RT: point of this is to eliminate T, so instance are smaller objects

AR: yes, that would make the instance object smaller. It's similar to what JS engine does, where construction time constant fields are merged into V8 map/shape object, various ways you can skin this, this is the simplest one

RT: concern here is how the separate compilation scheme would work if the type representations were stored on the vtables rather than the instances, as is the standard.

AR: I’m not sure that’s the standard representation, but either way I haven’t thought about it.

FM: null thing is interesting, there are different null values for all different types

AR: quite annoying we don't have a null type, need to jump through hoops

RT: the issue about canon becomes important with interfaces, you need to canon for that to be efficient

AR: yea, think we will want canonicalization

RT: this is not canonicalization that any of the stuff currently supports, manually done through loading, on your own?

AR: yes

RT: also need canonicalize the vtable first for production systems

AR: vtables don't necessarily require canon, in practice that would be needed, won't affect the casts though

### Presentation: Waml (Andreas Rossberg, 30 minutes)

Deferred until next meeting.
"
wasi/2020/WASI-10-22.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the October 22 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: October 22, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: hello@sunfishcode.online

**Note**: This meeting will be hosted by the subgroup co-chair Sam Clegg (@sbc100)

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Review of action items from previous meeting(s).
1. Vote to move wasi-nn to stage 2; see [witx here](https://github.com/WebAssembly/wasi-nn/blob/master/phases/ephemeral/witx/wasi_ephemeral_nn.witx).
1. Character encodings
    1. A presentation on: Summarizing several current discussions around character encodings
    1. For details, see the individual issues:
        1. https://github.com/WebAssembly/wasi-filesystem/issues/5 ""case-sensitivity of filesystem apis""
        1. https://github.com/WebAssembly/WASI/issues/8 ""Specify UTF-8 as the character set""
        1. https://github.com/WebAssembly/gc/issues/145 ""GC story for strings?""
1. Discuss about how to move forward with a [WASI Logo](https://github.com/WebAssembly/WASI/issues/3). Proposals:
    1. We would never like to change the [current logo](https://github.com/WebAssembly/WASI/raw/master/WASI.png).
    2. We would like to keep the [current logo](https://github.com/WebAssembly/WASI/raw/master/WASI.png) for now, and change it in the future when WASI is more mature.
       TODO: Ask the risks of changing the logo short-term and see if there is any way to address them.
       TODO: define what ""mature"" means (objectively) and how the process will be then
    3. We would like to start researching on a new logo now.
       TODO: define how the process will be
    4. Other ideas?

## Meeting Notes

### Attendees

- Sam Clegg
- Thomas Lively
- Martin Duke
- Syrus Akbary
- Pat Hickey
- Tanya Crenshaw
- Alon Zakai
- Andrew Brown
- Mingqiu Sun
- Alex Crichton
- Dan Gohman
- Steven Dabell
- David Piepgrass
- Johnnie Birch
- Martin Duke
- Yong
- Sergey Rubanov
- Arun Purushan

### Find volunteers for note taking

TL volunteers

### Adoption of the agenda

PH seconds

### Notes

#### Review of action items from prior meeting

DG: Next time ??? is in the meeting we will check up on ???

#### Vote to move wasi-nn to stage 2

- Phases: https://github.com/WebAssembly/WASI/blob/master/docs/Process.md

AB: We proposed wasi-nn a while back. Have a witx spec. I’ve been creating a POC
to see if this works. When looking at docs, realized we are essentially in stage
2. Moving to phase 2 would reflect reality. Asking for feedback on API.

SC: English spec text requirement doesn’t apply?

DG: Right, we only have witx.

AB: Also generates md, which might count.

SC: Implementation and test writing starts in stage 2. Probably don’t need a
full vote. Does anyone have any comments or objections?

PH: I followed it and I’m happy with how it looks.

SC: Unanimous consent achieved to move to stage 2.

AB: I will submit a PR updating which table it is in.

#### Character encodings

DG: Several threads about encodings going on. Want feedback about direction.

<DG presenting> TODO: Add link to slides

SC: Won’t the C program truncate on strcpy?

DG: Yes, but then you’ll get a file not found error. <Back to slides>

SC: Where does this ARF encoding come from?

DG: I invented this after a lot of tries.

SA: Is this for filenames only or also for contents?

DG: File names, env vars, commandline args, but not file contents.

SC: Anywhere a known string crosses the WASI boundary?

DG: There might be other places. Where invalid strings should be roundtrippable without trapping. Some APIs trap, others wouldn’t. Some tools will want different things as well.

TL: wasi seems like it may be the wrong layer to solve encoding problems since it is not related to capability-based security. Can we leave this to an optional userspace virtualization layer?

DG: That seems reasonable since virtualization is an option.

PH: When IT describe interfaces, it would be great to use strings for these types, and IT guarantees unicode. ARF lets us use the IT string type.

AC: In windows, filenames are lists of 16-bit values. How do we go from 16-bit to 8-bit strings? We need an extra layer.

DG: We can extend ARF to handle Windows character space as well. ARF would be a little different on Windows and Linux.

SC: But there are filesystem out there with different filename encodings.  e.g. Shift-JIS in asia.

DG: wasi engines can translate host character encodings into unicode.

AC: What would the users look like? Not raw API users, but e.g. rust stdlib users. Would the entire ARF string be stored in Rust’s Path object?

DG: Two cases: in do nothing case, use all the standard APIs. In ARF encoding case, get string as ARF encoded OSString or similar. WASI will either detect ARF string and not validate or would get file not found. There is a Rust library that can take an OSString and be ARF-aware to do things.

SC: But most programs won’t need to do this because these files don’t exist in practice.

AC: Not sure about this. Rust stdlib would want to do the proper decoding to show better error messages. It seems only extremely low-level C developers would be in the do-nothing case.

SC: Do-nothing only prints first half, right?

AC: Only in C. When there is a pointer and length, the second half gets printed too.

DG: Good point. Don’t have an answer for that.

SC: Curious about prior art.

DG: Perl 6 has UTF8-C8. Uses highest private use code point as an escape char.

AC: Using nul character seems reasonable given that native filesystems already disallow it.

DG: Python uses lone surrogates. Not great because you end up with invalid unicode.

SC: To be clear, status quo is passing through raw bytes from OS with no validation?

DG: Some implementations already have some validation and different behavior.

#### Discuss about how to move forward with a WASI logo

Slides:
https://speakerdeck.com/syrusakbary/wasi-logo-proposal

WASI issue:
https://github.com/WebAssembly/WASI/issues/3#issuecomment-714740192

SA: I’m the founder and CEO of Wasmer, want to see what the risks are about
moving forward with a different logo and what are the issues with the current
logo.

SA: Show we replace the logo at some point?

TL: Agree with identified issues.

SC: Another options would be to fix the problems in the current logo.

TS: It’s clear that the current logo is a draft. I actually like this property
because WASI itself is also in a draft stage. For example, the proposed logo
uses an office CLI metaphor, which is not what WASI has shaped up to be about.

SA: One idea would be to replace the current logo with a short term logo that
fixes some of the issues and is more accessible. Then separately it would be
good to organize a contest for a new WASI logo. Back to slides…

TS: It would be good to mention reasons on the issue so others can weigh in.

SA: Will follow up on the issue.

TL: What if we just fix all issues except for wasted space in the current logo?

SA: That would be an improvement, but it would be good to fix the wasted space as well.

SC: Any objections to incremental fix?

PH: Don’t want to spend any more time on this.

SA: I can handle this and release the results with a copyleft license to resolve any other issues.

TS: I think we still need to check what the situation is with IP rights just in case.

SA: I understand those concerns and want to make this as easy as possible.
"
wasi/2021/WASI-08-26.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the August 26 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: August 26, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Lin Clark
    - Email: lclark@fastly.com

### Registration

None required if you've attended before. Email Lin Clark to sign up if it's your first time. 

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Discuss wasi-parallel issue tracker (5 minutes)
    1. Second half of `async` and `stream` presentation (starting [here](https://docs.google.com/presentation/d/1WtnO_WlaoZu1wp4gI93yc7T_fWTuq3RZp8XUHlrQHl4/edit#slide=id.ge7fd2f6194_0_177))

## Notes
### Attendees
- Lin Clark
- Bailey Hayes
- Syrus Akbary
- Mingqiu Sun
- Till Schneidereit
- Johnnie Birch
- Andrew Brown
- Piotr Sikora
- Ben Titzer
- Alex Crichton
- Radu Matei
- Vibhav Pant
- Luke Wagner
- Radu Matei
- Yong He
- Saúl Cabrera
- Dan Gohman

### Closing out wasi-parallel from last meeting

**Andrew Brown:** Since we brought up wasi-parallel, met with Bailey and SS and Luke. Both meetings really productive. Brought up questions and potential solutions and ways of using. Want to thank them. Trying to get POC code as a Wasntime branch. Ran into issues with wiggle, pinged Alex. Don’t think final solution will be pretty, but will let people play with it. Then can figure out right way to fix. We published the spec at https://github.com/abrown/wasi-parallel-spec so that people can look at that. Started populating the issues with stuff we’ve discussed, will add more soon. Issues there are place to go for discussion.

Other thing is whether to vote for Phase 1. Don’t think that’s a critical step, but we’d be ready.

**Lin Clark:** IIRC any vote has to be on the agenda 7 days in advance. I agree that you’re ready, so let me know when you want to put it on.

### Closing out async discussion from last meeting

**Luke Wagner:** Last time we stopped at cliff hanger, will give brief review. Let’s start with basic stream. Why can’t we just have stream. What happens when A imports fetch from B? What if we could do this with simple module linking. When A read how does be get to run and write those butes. Separate thread? That’s how it usually works today. I think problem is that the threads are not ideal for being mandatory when you’re composing components. Add racy non-determinism. Also have context switching and sync overhead. And now have a dependency on threads. And in a serverless context, don’t need more scheduling units. Already have embarrassingly parallel model. Nice write up on this from Joe Duffy from Midori, talking specifically about too much stuff to schedule.

Instead, I think we want control flow to be deterministically transferred to B. That sounds a lot like corountines or callbacks. But how does that show up in IT?

Proposal is not directly. Let’s say new stream type that can be added in the signature. Basically a list passed incrementally over the course of the async call. Stream has two ends, writer and reader. When I pass, The caller gets the writer and the callee gets the reader. On return, it’s the reverse. Thus the ends are local to a single component instance. Just like futures, the canonical ABI defines ops on the reader and writer ands.

Stream built-ins [slide]. Basically lifting WASI I/O streams into IT.

**Piotr Sikora:** I think the ""normal"" read/write versions could be expressed using the same prototypes as the ""short"" versions if you pass min=len.

**Luke Wagner:** Dan has thought about that

**Dan Gohman:** Short read and short write have non-determinism built in

**Syrus Akbary:** Why having skip built-in rather than as a layer on top the read api? (Kind of stream -> filtered stream)

**Luke Wagner:** optimization

**Vibhav Pant:** Question about handle itself. In this case, it’s an i32. Any reason this can’t be extern ref?

**Luke Wagner:** Decreases dependency on future proposals. From perspective of C compiler, can treat this as an int. Even though this looks forgable, can only forge to your own table.

**Dan Gohman:** In the witx description, not i32. Canonical ABI is just toolchain

**Vibhav Pant:** Another small question. Idea is that one doesn’t want to stick to a single concurrency model. Could I implement these in my engine in a way that preempts the caller.

**Luke Wagner:** With ABI=callback you can do either. Blocking needs to happen somewhere, either in host or in your greenthread. So you have a lot of flexibility if you use greenthreads. If your engine only has callback, you’ll only be able to use that ABI.

Before talking about canonical ABI need to talk about deadlocks.

Deadlocks [slide] How can we avoid deadlocks by design? When we create a new coroutine, coroutine lifetime is tied to the stream.

Now let’s see how it shows up in canonical ABI. [slide]

Let’s see what an actual concrete component in wat would look like. Example streaming component [slide]

**Ben Titzer:** So these components all get encoded into an extended import section… these all become part of the binary.

**Luke Wagner:** Yes, embedded in that binary is the core. Then this format is like a container for holding one or more core module.

**Syrus Akbary:** Can we have the slides uploaded somewhere and liked from the docs? Thanks
https://docs.google.com/presentation/d/1WtnO_WlaoZu1wp4gI93yc7T_fWTuq3RZp8XUHlrQHl4/edit#slide=id.p

**Lin Clark:** As Piotr pointed out last time, slides are already in the agenda for last meeting.

**Luke Wagner:** So that’s a single component. Let’s talk about composability. Async streaming composition example [slide]

Let’s look at what async looks like in the JS API [slide]

What about stream in the JS API [slide]

**Vibhav Pant:** One small question—idea is that this will plug into any langs runtime irregardless of how it handles concurrency, right? 

**Luke Wagner:** Yes, in some langs might not have abstraction like JS does with stream, but hopefully we’ve given you the primitive to build it

**Vibhav Pant:** So by design it is agnostic?

**Luke Wagner:** Yes, as much as possible

So that’s the base proposal. A few expected additions [slide]

Final thoughts [slide] Callbacks are kind of like the async version of goto. Even if ones implements this as callbacks, specifying in times of these virtualized coroutines gives us structured concurrency for those callbacks.

**Vibhav Pant:** One small question about async resources. Kind of remind me of async traits in Rust. Am I correct in assuming that since stream handles are concrete types, the whole problem that Rust has with boxing. 

**Dan Gohman:** I’m not familiar with the problem in Rust.

**Vibhav Pant:** One issue with async traits in Rust… futures in Rust are essentially trait futures. If you want to do async traits in Rust, you have to box them. Because in this design, because stream handles are i32, does having async resources not have the same problem.

**Alex Crichton:** I think this does help and not help. The trait problem in Rust is very specific to Rust. WASI is going to give us all of the concrete things, but probably going to abstract in Rust. Up to languages how best to bind.

**Luke Wagner:** You might have noticed that I used backtick T. Not a witx thing, but way of showing that this isn’t a generic interface. It becomes concrete once it’s in a component. The built-ins doing reads and writes are monomorphic. Statically known element type.
"
gc/2022/GC-12-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 13 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: December 13, 5pm-6pm UTC (December 13, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Types on the JS-Wasm boundary ([#279](https://github.com/WebAssembly/gc/issues/279))
    1. Discussion: Final types and call_indirect subtyping ([#329](https://github.com/WebAssembly/gc/issues/329), [#339](https://github.com/WebAssembly/gc/pull/339))
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Sergey Rubanov
- Zalim Bashorov
- Justin Michaud
- Slava Kuzmich
- Deepti Gandluri
- Francis McCabe
- Asumu Takikawa
- Ilya Rezvov
- Alon Zakai
- Adam Klein
- Andreas Rossberg
- Jakob Kummerow
- Ryan Hunt
- Manos Koukoutos


### Logistical note

TL: This will be the last meeting of the year. We will resume on January 10, 2023.

### Discussion: Types on the JS-Wasm boundary ([#279](https://github.com/WebAssembly/gc/issues/279))

TL: (recap of the discussion so far, potential future problem that implicit casts won’t scale to explicit RTTs)

AR: Concerned that this sets expectations that would lead to dead ends.

TL: Is there a solution you would prefer?

AR: Would prefer the conservative approach of just using the top types.

RH: Was there discussion of how a Wasm function would be invoked from JS with explicit RTTs, or was it always expected that the cast would have to be explicit in Wasm?

AR: Good question. Expect to be able to create RTTs from JS. Can do explicit cast on either side.

RH: Could use WebAssembly.Function to create wrapper that knows which RTT to use.

TL: Sounds like there is some design space to figure out something nice here in the future.

TL: Worried that top types only do not have enough ergonomic benefits over just externref. For wasm-split, for example, we would want arbitrary types to avoid having to change the cross-module ABI.

TL: We will also want arbitrary types to cross into JS eventually, it’s just a matter of time. Would be good to solve now instead of waiting for someone to need it.  (FM agrees)

AR: Concerned that the solution doesn’t scale.

TL: It scales for producers who don’t want generics / type imports, etc. and don’t need explicit RTTs.

RH: Using canonical RTT is no worse than it not working at all in those situations.

AR: Fair point. You can always have the casts, but it might be more expensive.

RH: There will always have to be a cast. Question of what you are casting to. Canonical RTT is the only option now, but in the future that might not be what folks want. But we don’t plan to extend toWebAssemblyValue.

FM: From a naive point of view, it seems like a no-brainer to allow arbitrary types. But I accept that folks don’t need it now.

AR: What does this mean for function types? Needs higher order casts.

RH: Can you elaborate?

AR: Does this involve only Wasm casts or also JS values?

TL: Only Wasm values that have flowed out and are flowing back in, at least for structs and arrays.

JK: For functions, needs to be a Wasm function or the result of a WebAssembly.Function so it has a type. It sounds pretty wild to me to automatically invoke WebAssembly.Function. Let’s not do that now.

AR: Agree. Given that, since all functions have declared subtypes, I guess it makes sense.

AT: For the implicit casts in the anyref hierarchy, it’s also an extern.internalize before the downcast, right?

TL: Yes.

JM: If I send a Wasm value to JS, and in the future I might be able to add properties to it or something, then pass it back in to Wasm, should I expect that extra information to be preserved?

JK: Safe to assume you will never be able to change the shape of Wasm values.

RH: What about exported functions, which you can add things to?

JM: In that case it causes the Wasm function to transition to a different representation. We want to avoid having representation checks everywhere.

AR: Not sure I understand. How does the GC proposal change anything about this?

JM: If all you can do is call a function, it’s fine. But if we have to figure out what RTT is canonical for that function, we’ll have to store extra info in the structure. If they never change shape, that’s fine. But if they do change shape, we’d have to do extra bookkeeping. We don’t want Wasm values to ever change shape in Wasm.

AR: I don’t think we should ever allow changing the shape that’s visible to Wasm.

RH: Sounds like you’re using the shape both for properties and casting. Using the same thing for both gets weird.

AR: Right, I’ve said before that using e.g. V8 Maps as the RTT is not scalable. You’d need a separate RTT.

JM: It would be bad to pessimize everyone passing things across the boundary to support adding properties to WebAssembly exported functions.

AR: Probably too late to specify exported functions objects as frozen. Do we know?

JM: Keeping the hidden Wasm type sounds reasonable, but concerned about losing perf here in the future.

AR: Why didn’t we make them frozen? Was that an oversight?

AT: They are not specified as frozen right now.

AR: Would it be worth experimenting with fixing this?

JM: That would be good.

RH: I also want to mention that SM is in a similar situation where we’ve been trying to use the same representation in Wasm and JS. Ran into this implementing function downcasts. I was soft planning not to reuse the shape for the type info but rather to store it in a slot. That makes them different from structs, but that’s ok because they have a different representation.

AR: I was assuming something like that as well. Can save space by hanging it off the shape, but then there’s another indirection.

TL: If Ryan was planning to do this anyway, is this a hit we already have to take for unrelated reasons?

JM: Don’t think so. Want flexibility.

TL: Would not want to vote on this until known potential blockers are investigated and resolved.

AR: Can’t change the type as long as WebAssembly still holds a reference, though.

JM: Oh no.

JK: We also used to do this, but we ended up splitting our representation into a pair of objects that refer to each other, one Wasm and one JS, and on the boundary it just flips which one is visible.

JM: Sounds interesting.

TL: Should we resolve this now or do folks want more time to investigate and report back on the issue?

RH: Would be fine resolving for now.

JM: Would also be fine resolving for now.

Unanimous consent: Allow arbitrary GC types on boundary and have an implicit downcast in toWebAssemblyValue.

### Discussion: Final types and call_indirect subtyping ([#329](https://github.com/WebAssembly/gc/issues/329), [#339](https://github.com/WebAssembly/gc/pull/339))

TL: Any objections to implementing final types as proposed and allowing downcasting on call_indirect?

RH: Did anyone implement it?

TL: V8 implemented and did experiments with Dart that showed benefits.

MK: Can confirm that.

RH: No objections.

(Unanimous consent)
"
stack/2021/sg-9-20.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 20th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  September 20th, 16:00-17:00 UTC ( September 20th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
- Francis McCabe
- Elle Imhoff
- Daniel Hillerström
- Andreas Rossberg
- Ross Tate
- KC Sivaramakrishnan
- Arjun Guha
- Zalim
- Luke Wagner
- Ioanna Dimitriou
- Rick Battagline
- Thibaud Michaud


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. [Typed continuations as the basis for stack switching](https://github.com/WebAssembly/meetings/blob/main/stack/2021/presentations/2021-9-20-TypedContinuations.pdf).  (Daniel Hillerström)

      I will provide an update on the progress of the typed continuations proposal. I will begin by recapping the gist of the proposal. Next, I will discuss some extensions that we have found to be important through experimentation. In the last part of the presentation, I will discuss some further extensions that I currently consider as ""post-MVP""
   2. Next meeting [2 mins].
1. Closure

## Meeting Notes

DH: AR talked about this last year.

[Slide: Operational Interpretation, Continuations ~ Stacks]

DH: Activation frames are a(), b(), c(), … f().  Delimited continuations are described back in the 1960s. In Racket, call/cc uses delimited continuations even though call/cc is an example of non-delimited continuations.

[Slide: Delimited Continuations as Segmented Stacks]

DH: Pointers are from child to parent.  On suspend, the continuation becomes a structure back to the delimiter and the pointer flips direction, so the parent can point to the child stack segment as the continuation.

[Slide: Typed Continations at Glance]

DH: 

FM: When adding switchable stacks to V8 we assume garbage collection because we can’t guarantee it will be entered, which will cause a memory leak.

DH: We assume continuations must be invoked and not doing it is a programmer error.  I assume all implementations have GC underneath.

AR: The important bit is that reference counting is enough.

FM: Reference counting is not enough because you need to explicitly forget a count.

AR: No you don’t. The redline for full GC is you don’t have cycles, so counting is enough.

FM: Begs to differ on the GC front, but we’ll continue.

[SLide: Typed Continuations, the Idea]

DH: Think of suspend as sending data over a channel.

[Slide: Control Tags]

DH: tag from exception handling proposal. The result is new.  Cont.new takes a function reference and allocates a new stack that can run that function.  A key point is that the new stack is suspended.  Execution is still with the parent stack.

To start the parent stack,cont.resume, maps tags to handlers.  Handler is a basic wasm block.  Value stack needs trs and applies the continues to those trs, which returns t2s and then cont.resume returns those t2s.

Cont.throw injects a normal exception into the continuation.

RT: Some systems don’t need a separate cont.throw.
AR: You’d need something to inject the function call into the continuation.
FM: What is $ft in cont.throw? 
DH: That’s the function type.
AR: It needs to be t2.
FM: It doesn’t consume the continuation.  It will catch the exception in the continuation.
AR: These two instructions are dual to regular and exception running code.
FM: I have unanswered questions.

[Slide: Cont.resume, Operationally]

Cont.resume installs handler $hfoo.

[Slide: Cont.throw, Operationally]

Injects throw into continuation stack. Continuation can catch locally.

FM: We throw an exception into the continuation.  It could catch the acception and later do another suspend.  That means that what should be on the stack should be the same as a normal resume type wise.  The state of the stack needs to be the same whether resume or throw.

RT: How do you have the exception handler in the continuation suspends.

AR: cont.throw might need tag handlers

FM: It MUST have tag handlers

DH: It only might.
AR: Should you ever do that?  Cont.throw is only for abort.
DH: It’s not a flaw in the design.
FM: There’s still a gap.  You resume a continuation and it throws an exception.
AR: You can catch that with an exception handler.
RT: You can register an exception handler with the cont.resume.
FM: It is up to the application to decide.  It is normal for the continuation to throw an exception that is not to kill it.  If you have exceptions, then this is a normal pattern.
RT: This is bidirectional algebraic effects.
FM: Leave the cont.throw stack in the same state as cont.resume with a handler in place.
AR: Canonical extension is cont.throw to have a handler list.
RT: Another extension for bidirectional algebraic effects sends suspending events into the other continuation.
DH: I’m not aware of uses for that and so haven’t looked at it.
AR: You can always encode by dispatching at the resume point.
RT: There are primitives that exist to express this.
AR: But not first-order.
RT: They exist.
 
[Slide: Suspending Continuations]

FM: Go back a slide. I believe cont.suspend knows the final type of the computation.  In order to type check the suspend you need the final type.
DH: No.
AR: The type is the type of the hole on the child stack. Tp is upstack and tr is downstack.

[Cont.suspend does not guarantee O(1) transfer]

RS: Experimental evidence of stack depth of 1-2. 
DH: React and multicore OCaml.
AR: Linear in the number control abstractions.
FM: LW and I have discussed multiple levels if there are multiple modules running their own event loops then there could be cascading stacks.  If you’re deep in a module chain and it needs something from the browser event loop, then deep stack chains can occur.
DH: Each loop you’ll install a stack
FM: No, if you have lots of modules you have browser event loop and each cascaded event loop.  If you need something I/O then you need to go to the browser, that is a real world example.
RT: If async/await then there are long chains.
DH: There is only 1 handler.
FM: Depends on if I/O is virtualized.
RT: Did you analyze Racket?
DH: I have not looked at Racket.
RT: Why are we not interested in O(1) transfer?
DH: This gives modularity and composition.  If you need O(1) you need static dispatch.
AR: It doesn’t need to be linear.  There are other implementations.  Is there research in this?
DH: Dan Lyon’s work.
AR: It requires a global transformation.  Static transfer is compatible with this.
RT: You haven’t mentioned that the static one has abstraction properties.
AR: Actually other way around.
RT: Maybe I don’t understand what static means then.  There’s a paper showing that that approach and this doesn’t.

FM: When Mathew Flat (sp?) gave presentation on Chez Scheme, it is considered a part of the design for tail recursion resumption.
DH: No
FM: What does it mean to tail-resumptive resume?
DH: Tail resumptive can be inlined.  It is not possible to identify those clauses.
FM: OK.

[Slide; Control Barriers]

DH: Stop things crossing language boundaries.
FM: Wait.  This is new.  Is this similar to WASM/K?
DH: Yeah.
AR: It intercepts every tag and traps.

[Slide: Partial Continuation Application]

DH: Can get around not having cont.bind with code duplication.

[Slide: Extensions]

DH: This is asymmetric stack switching because you need to visit parent.  Symmetric would allow switching between siblings.

[Slide: Closing Remarks]

AR: GitHub repo goes into extension
FM: There are older languages like Simula67 that needs symmetric stack switching.


### Adoption of the agenda

### Discussion:

### Adjourn

"
gc/2023/GC-01-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 10 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: January 10, 5pm-6pm UTC (January 10, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Presentation: OCaml on WasmGC (Pierre Chambart and Léo Andrès, 60 min)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Pierre Chambart
- Leo Andres
- Alon Zakai
- Ryan Hunt
- Ilya Rezvov
- Zalim Bashorov
- Francis McCabe
- Slava Kuzmich
- Asumu Takikawa
- Jakob Kummerow
- Manos Koukoutos
- Luke Wagner
- Emanuel Ziegler
- Dmitry Bezhetskov
- Adam Klein
- Deepti Gandluri
- Jean-Christophe Filliatre
- Ioanna Dimitriou

### Presentation: OCaml on WasmGC (Pierre Chambart and Léo Andrès, 60 min)

PC presenting [slides](presentations/2023-01-10-chambart-ocaml.pdf)

PC: There are two OCaml compilers: native and bytecode. We control both completely and we control the GC completely, but making changes is hard. Lots of polymorphism and low-level utilities users use to examine values. Users also depend heavily on the GC. Users expect exceptions to be fast.

PC: Js_of_ocaml compiles the untyped bytecode to JS, which works fine because JS is untyped. But we want to target WasmGC because it will have slightly better performance than compiling the GC to Emscripten, and it has much better interop with external values.

FM: Are you planning to use i31?

PC: Yes, we’re using it everywhere.

TL: How long were the subtyping chains you were seeing?

PC: The size of the largest block. Could reduce it, but it would be difficult. Top level modules are blocks and tend to be quite large. The alternative to using structs is to use arrays of fields, but we statically know all the indices, so using structs is better.

TL: Will it be hundreds or thousands?

PC: Hundreds mostly, but a few libraries will have thousands. For example one library that exports a separate value for each unicode code point. We can do something special for those strange cases.

PC: Must use mutable values because many things can be cyclic.

PC: Have a special representation for float arrays to avoid boxing, but it requires some extra dynamic checks.

FM: What kind of strings are these?

PC: Strings are byte arrays. Some specific libraries additionally validate that the strings are valid unicode.

FM: What about when you want to interop with JS or DOM, etc?

PC: The JS compiler has a lot of problems there because it has to keep both representations. It uses memoization to try to avoid going back and forth a lot.

PC: Have different function types for different arities, they all take Env arguments. Won’t need function subtyping anywhere. Different code paths for currying or when there is the exact right number of arguments. Avoiding partial applications can avoid allocating intermediate closures. The compiler is good at optimizing this.

PC: GADTs, where the output type depends on some input value, is basically impossible without a uniform representation.

TL: To clarify, you are using Wasm exceptions, but just with a single tag covering every OCaml exception?

PC: Yes.

FM: wasocaml is still slower than js_of_ocaml?

PC: Yes, on this simple fibonacci example, but for larger tests and applications we’re already quite faster than js_of_ocaml. Compiling to JS is generally good, but bad cases are very bad (40x slower than native in real examples).

TL: Will this work be upstreamed to OCaml or will it stay separate?

PC: Too early to tell. If it’s very compatible with the entire language, then we might be able to upstream it, but it would take a while.

AK: Do you have examples of users using OCaml on the Web today with the JS or Wasm versions?

PC: There are a few companies using js_of_ocaml. There is some social network stuff and some graphical interfaces. Jane Street uses it a lot. They generate a lot of code that is too much for the JS JIT compiler.

LA (chat): https://jscoq.github.io/scratchpad.html same for Why3 and alt-ergo

FM: Have you looked at using [JSPI](https://github.com/WebAssembly/js-promise-integration/blob/main/proposals/js-promise-integration/Overview.md) to help implement effect handlers?

PC: Not sure promises are sufficient. Maybe with CPS as well?

FM: The idea is that the internal code would not be CPS transformed. The promise only appears on the Wasm-JS boundary.

TL: Some other language is using JSPI to implement async things, right?

FM: Right, Dart is using it to implement generators and async functions, although not efficiently.

PC: You need to be in the JS world in order to use it?

FM: Yes, it’s only in V8 right now, but it is standards track.

FM: What kind of applications do you see using OCaml on the Web?

PC: Same as what’s using js_of_ocaml now. The Wasm compiler is a big improvement over js_of_ocaml.

FM: Do you see OCaml being used with Wasm outside the browser?

PC: Yes, I think it already works with Cloudflare. It would also be good to see the OCaml representation become the lingua franca between GC languages. For example calling between OCaml and Java requires a complicated hop through C. Using the OCaml representation would be nicer.

FM: That would require agreement between the OCaml and Java backends on what an object looks like.

PC: Yes, but you could also have a small WebAssembly module to do conversions.

AZ: Do you have any data on code size of the Wasm compared to JS?

PC: I think it’s smaller, but I’m not sure. Will have to look at that.

AZ: Can you run the Wasm reference interpreter in wasocaml?

PC: Probably not because we haven’t implemented all the primitives yet. But in principle there’s no reason we couldn’t.

IR: Have you compared performance to the melange compiler? (A ReasonML to JS compiler)

PC: It’s hard because the language isn’t quite compatible.

RH: Is there public code I could play around with as we develop features in SpiderMonkey?

PC: Things are in flux and hackish, so for now it’s probably best to ask me directly for a wat file.

AT: You mentioned that most of your instructions are casts. Have you seen this to be a bottleneck?

PC: Haven’t compared to a version without casts, so not sure about performance. Most of the casts should be easy for the engine because we cast directly to the exact runtime type. Blocks are an exception, but we might stick with arrays for those.

AT: Are these block casts common?

PC: Yes, very common.

TL: Are there code patterns that Binaryen could optimize but doesn’t?

PC: Unboxing boxed values would be a good candidate. It’s hard because the OCaml compiler already optimizes heavily and knows a lot about the language. Binaryen does a good job of optimizing locals. Sometimes we are going between i32 and i31. Optimizations would have to know about dropping bits being ok.

JK (chat): in V8, we have --experimental-wasm-assume-ref-cast-succeeds, which turns ref.cast into a no-op, so you can measure casting performance overhead for programs where you know that all casts succeed
"
process/phases.md,"# WebAssembly W3C Process

This file describes how feature proposals will progress through
the standardization process.

A feature is a substantial change to WebAssembly, such that it for example
requires additional opcodes, types, tests, or module sections.
See case #3 [here](consensus.md).

Something is definitely a feature if it:

  * Adds an opcode or other pieces of abstract syntax
  * Changes or extends the binary format
  * Changes or extends the text format
  * Requires adding or changing tests
  * Requires extending or changing the reference interpreter

Something is out-of-scope if it doesn't fit the [WebAssembly Working Group's charter](https://www.w3.org/2017/08/wasm-charter) and there's agreement that the charter should not be amended to cover the proposal.

In general, the process moves forward through a series of numbered phases.
However, if issues are uncovered or consensus devolves,
proposals should back up to the appropriate prior step.

No vote is required for a proposal to enter phase 0. To advance from one phase
to another, a vote proposing the advancement is added to a
[Community Group meeting](https://github.com/WebAssembly/meetings/) agenda
through a pull request, and the CG votes on whether to approve it, evaluating
whether the new phase's entry requirements have been met.

## 0. Pre-Proposal [Individual Contributor]

Entry requirements:

  * A Community Group member has an idea. Notably, no CG vote is required to begin phase 0.

During this phase:

  1. An issue is filed on the [design repository](https://github.com/WebAssembly/design/issues) to present the idea.
  1. Discussion on the feature occurs on the issue.
  1. A champion or champions emerge. They may add the proposal to the [proposal list](https://github.com/WebAssembly/proposals/blob/main/README.md) at phase 0.
  1. The champion(s) put together a somewhat-formal description of the feature in their own GitHub repository or on the issue.

## 1. Feature Proposal [Community Group]

Entry requirements:

  * There is general interest within the CG in this feature.
  * The CG believes the feature is in-scope and will plausibly be workable.

During this phase:

  1. If the proposal is not already listed, it should be added to the [proposal list](https://github.com/WebAssembly/proposals/blob/main/README.md) at this time.
  1. A new repository, forking the spec repo, is created by one of the WebAssembly organization administrators, or transferred to the WebAssembly organization by the champion. See the [how-to](https://github.com/WebAssembly/proposals/blob/main/howto.md) for this step.
  1. The champion will attempt to reach broad consensus in the Community Group.
  1. Pull requests and issues are used to iterate on the design of the feature. Specifically, an overview document must be produced that specifies the feature with reasonably precise and complete language before attempting to move to phase 2 (meaning it is sufficiently precise to be implemented following this description, without obvious holes or ambiguities).
  1. If relevant to demonstrate the viability of a feature, prototype implementations of the feature are implemented by interested embedders (possibly on a branch).

## 2. Feature Description Available [Community + Working Group]

Entry requirements:

   * Precise and complete overview document is available in a forked repo around which a reasonably high level of consensus exists.
   * *Updates to the actual spec document, test suite, and reference interpreter are NOT yet required.*

During this phase:

   * One or more implementations proceed on prototyping the feature to the point that a comprehensive set of tests can be added.
   * A test suite is added in the forked repo. These tests need not pass the reference interpreter at this point, but should pass on the prototype or some other implementation (this primarily is to check that the test suite is functional).
   * Updates to the reference interpreter are not yet required at this point, but recommended.

## 3. Implementation Phase [Community + Working Group]

Entry requirements:

   * Test suite has been updated to cover the feature in its forked repo.
   * The test suite should run against some implementation, though it need not be
     the reference interpreter.
   * *Updates on the actual spec document and reference interpreter are NOT yet required (but can happen earlier).*

During this phase, the following proceeds in parallel:

   * Engines implement the feature (where applicable).
   * The spec document in the forked repo is updated to include the full English prose *and* formalization.
   * The reference interpreter in the forked repo is updated to include a complete implementation of the feature.
   * The feature is implemented in toolchains.
   * Remaining open questions are resolved.

## 4. Standardize the Feature [Working Group]

Entry requirements:

   * Two or more Web VMs have implemented the feature and pass the test suite (where applicable).
   * At least one toolchain has implemented the feature (where applicable).
   * The spec document has been fully updated in the forked repo.
   * The reference interpreter has been fully updated in the forked repo and passes the test suite.
   * The Community Group has reached consensus in support of the feature and consensus that its specification is complete.

NOTE: By this point the proposal is basically frozen, since
the Community Group is the sole venue where substantial work can occur.

At this point:

   * The feature is fully handed off to the Working Group.
   * During this phase, Working Group members discuss the feature,
     consider edge cases, and work to confirm consensus that the feature is now
     complete.
   * Periodically, the Working Group will hold polls on how ""ship worthy"" the feature is,
     in order to help browsers to make decisions about when to ship.
   * Only minor cosmetic changes occur at this point.
     If substantial changes are deemed required, the feature is sent back to
     the Community Group.

## 5. The Feature is Standardized [Working Group]

Entry requirements:

   * Consensus has been reached amongst Working Group members that the feature
     is complete.

During this phase:

   * Editors perform final editorial tweaks and merge the feature into the main branch of the primary spec repo.

W3C snapshots (for REC) are made at a regular cadence (in a W3C repo), used
to stamp official version. Matching tags are added in the github spec repo.


## FAQ

#### Who owns the various existing W3C repos?

They are owned in common by the Working + Community Groups. The Working Group
uses the github.com/WebAssembly/spec repo to iterate on finalized proposals
for hand-off
to the W3C's snapshotted copy of the spec. The other repos are primarily
overseen by the Community Group.

#### What about licenses?

The spec and spec forks will move to a
[W3C Software and Document Notice and
License](https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
Other related repos for prototypes + tools will continue under their respective
licenses.

#### What is the Community Group for?

Incubation.
To provide a safe harbor for a broad set of stakeholders to discuss, design,
and iterate on new features during Steps 1-3 above.
It should attempt to address all concerns, but need not reach 100% consensus.

#### What is the Working Group for?

To finalize and ratify mostly complete specs + test suites from the Community
Group.
Changes to the spec need not have reached full consensus in the Community Group
to move to the Working Group, but key Working Group stakeholders should resolve
outstanding mismatch in the Community Group.

#### Who will have admin rights + close issues etc?

This can be distributed and handled by multiple folks.
In terms of github issues specifically, chairs will mainly step in to drive
consensus, keep discussions civil, and as a first escalation point if someone
is unhappy with how the collaboration is conducted (for instance if someone is
unhappy a particular issue was closed over their objections).
This is a general part of their role in community building:
https://www.w3.org/Guide/chair-roles
"
main/2024/WG-07-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the 2024-07-10 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: 2024-07-10 at 15:00-16:00 UTC *( July 10th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Vote to advance Tail Call, Extended Constant Expressions, Typed Function References, Garbage Collection, Multiple Memories,
       Relaxed SIMD, Custom Annotations, and Branch Hinting to Phase 5.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes
![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the 2024-07-10 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: 2024-07-10 at 15:00-16:00 UTC *( July 10th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Vote to advance Tail Call, Extended Constant Expressions, Typed Function References, Garbage Collection, Multiple Memories,
       Relaxed SIMD, Custom Annotations, and Branch Hinting to Phase 5.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Attendees

- Ms2ger
- Andreas Rossberg
- Derek Schuff
- Zhaoyu Dong
- Zalim Bashorov
- Luke Wagner
- Thomas Lively
- Pete Gonzalez



### Discussion

#### Vote to advance Tail Call, Extended Constant Expressions, Typed Function References, Garbage Collection, Multiple Memories, Relaxed SIMD, Custom Annotations, and Branch Hinting to Phase 5.

Threads is the only one missing from the list of phase 4 proposals. It has several open issue in the spec, and not really ready for merging into the spec

AR: most of the other proposals, except maybe for relaxed SIMD are merged into the wasm-3.0 branch in the spec repo. The current version of SpecTec is based on that branch, so it contains all those proposals.
Branch hinting won’t end up in the main core spec. The plan is a separate document for that.

DS: The CR publication advancement is announced,  just waiting for the 2 weeks to expire.

AR: will that involve some more steps? Do we have to make some other cut of the current document?

DS: I don’t think so? I think that whatever we push to the W3C TR URL is officially the CR

AR: I have a branch where I did some minor changes to build/CI but haven’t pushed because we have to wait for the change. Now I’m forgetting exactly what the change was.

DS: maybe the bikeshed change from making it an “editor’s draft” or WD to CR?

AR: yes, I think that was it. Change from draft to CR. I will make a PR out of it to show.
There also have been a bunch of minor spec fixes lately which should also be included automatically.
The PR is pretty minor, will be part of the process on our end. Hard to test since it’s CI. It pushes it to the W3C TR directory. IIRC that’s also the place where the CR goes

DS: After the 2 weeks is up, I’ll check with Mike to clarify.

Let’s do the vote:
Vote to advance Tail Call, Extended Constant Expressions, Typed Function References, Garbage Collection, Multiple Memories, Relaxed SIMD, Custom Annotations, and Branch Hinting to Phase 5.

|SF|F|N|A|SA|
|--|-|-|-|--|
|4|1|0|0|0|

Vote passes.

AR: any updates from the other 2 proposals we’re waiting on, EH and memory64?

DS: EH is on the CG agenda for phase 4 next week. We have the JS API tests that we discussed in Pittsburg. Memory64 is waiting for Firefox to finish the table64 implementation, plus whatever open spec issues there are.

AR: spec is basically done, the one open question is about Bigint in the JS API. Maybe the conservative option for now is not to allow bigint, should be enough for the foreseeable future.
On EH tests: one thing I noted when I implemented the core tests to the new version of the proposal is that the coverage seems a little low. Does anyone own improving that?

DS: nobody is on the hook for that right now, I can check and see if there are any V8 tests we can bring over.

AR: what about the JS API?

DS: It’s in OK shape. It covers the way we use it in emscripten, plus some reference-related stuff, plus coverage of the constructors and other JS-specific stuff

AR: I guess there was also the question about the type method. What’s up with the type reflection? Proposal? I think it’s the last of the original first generation of extensions we discussed.

DS: Nominally Ilya still owns that; we don’t really have users asking for it or known use cases, so I think it just didn’t get prioritized.

TL: what’s the latest thinking for spectec transition? Any plans or timeline?

AR: We had a group meeting at PLDI, Sukyoung was there with a bunch of students, and Conrad, me and Sam. We have regular meetings to push it forward, we made a list of packages and priorities to work on. Most of the items are on their end right now, they expect to make progress in the summer. I have a list of smaller TODOs, missing spec bits but the bigger part is polishing the prose and making the user experience with the prose backend and interpreter better. My plan was to target something like november to bring it back to the CG, I’m hoping to get it done by the end of the year.

TL: so the plan is to get the spec doc into shape and then bring it to the CG?

AR: right, we should plan on some amount of iteration on that. From the presentation i gave, the boxes are checked except for the prose part, and the things I said wouldn’t be done in the first go (e.g. numerics). The text format needs a little thinking to make it more precise. Thought about numerics a bit too, that’s hard because it requires real numbers. Looked at a library with bigints and big rationals. Everything in wasm except for sqrt is actually rational; so was thinking about rationals for that plus an approximation for sqrt. Not sure how slow that would be, e.g. for huge exponents. But speed doesn’t matter much for the reference interpreter

"
wasi/2023/WASI-04-20.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: April 20 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: April 20, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Request stage 1 vote for `wasi-pattern-match` -- 5 minutes (refer to @jianjunz's previously
       presented [slides](presentations/2023-03-23-wasi-pattern-match.pdf))
    1. Adding an initial current working directory to wasi-filesystem (Dan Gohman)
        - https://github.com/WebAssembly/wasi-filesystem/issues/24

## Notes
### Attendees
- Pat Hickey
- Dan Chiarlone (danbugs)
- Lin Clark
- Jeff Charles
- Bailey Hayes
- Dave Bakker
- Chris Suszynski (cardil)
- Chris Woods
- Piotr Sarna
- Brian Hardock
- Shivansh Vij
- Johnnie Birch
- Jianjun Zhu
- Andrew Brown
- Steve Schoettler
- Dan Gohman
- Piotr Sikora
- Stephen Doyle
- Mingqiu Sun
- Yong He

### Request stage 1 vote for wasi-pattern-match

**Chris Suszynski:** Question about how many proposals are being proposed. Problem for runtimes to implement large scope

**Lin Clark:** This is where worlds come in. Can just limit to a subset of interfaces in the world, and the runtime only needs to support the world.

**Pat Hickey:** This poses a communication problem. We don’t yet have worlds. For this one, this can be written in pure WebAssembly so it can be virtualized, so not really an issue.

**Chris Woods:** I’d second that concern. Concern about fragmentation. Some discussion around a repository of components. Some thought into having a consolidated set of worlds, and some base APIs around them. Worthwhile having a discussion on that at some point, probably not today. What kind of developer experience.

**Pat Hickey:** I agree, something I and others are actively working on. What I believe is first preview 2 implementation. All the basic. So there is a core set of things like std-io being available. And clocks. There does need to be some kind of idea that there is a core base that we expect a whole bunch of languages to target. We’ll come up with that world at some point. Haven’t really figured out the exact details.

**Bailey Hayes:** I just wanted to add. I agree with Andrew (message in chat) that this is an awesome problem to have. Just wanted to call out that virtualization, as Pat said, it makes it really easy to adapt. For a ton of these, where syscall isn’t 100% required, this is great. I’ve been asking for this one, have been asking if people would use as a syscall, and for this have been hearing a lot of yeses.

**Andrew Brown:** Yeah, I don’t think stage 1 would be blocked. Maybe not in default world, but this is just about getting a repo.

**Chris Suszynski:** Wondering whether it’s useful to add as a field to the template whether certain proposals should be virtualizable

**Andrew Brown:** I think for this particular one, we should explain virtualizability in the README

**Pat Hickey:** One tricky part is that this is a standards body, but implementation isn’t the scope of this group. Those are the bounds we have to stay in as a standards body.

**Chris Woods:** Need to put some thought into the developer experience. If the standards become too many or too confusing. Base world.

**Pat Hickey:** Happy to discuss that offline. Email address is in all my commit messages.

**Shivansh Vij:** Fallback syscall… there’s very little incentive to not create overlapping syscalls that focus on very specific use cases. Way to standardize against that? (bailey adds “Best practices”). Yeah, best practices.

**Pat Hickey:** I agree and I think the purpose of these very early votes is to establish whether it’s in scope

**Lin Clark:** Don’t have to collapse the decision space in the early stages

**Pat Hickey:** Agree. One other point for those who haven’t been involved in the Wasm CG. Only a few of the Wasm CG proposals have made it. Some take a long time, some get explicitly cancelled. So an early Stage 1 decision doesn’t guarantee that this makes it to standard. We need to find ways to make sure we communicate these early stage proposals could go nowhere.

**Dave Bakker:** Wondering where the WebSQL standards fall, where SQLite became dominant. Because there was no way to specify.

**Lin Clark:** Tension to figure out. This is where the design phase comes in. We'd need to push back on anything that doesn't meet WASI's constraints.

**Pat Hickey:** Agree, if there is only PCRE then I’d say no.

**Andrew Brown:** It will be a subset of PCRE 2

**Pat Hickey:** Yes, and something that we’ll need to make sure is well standardized. We’ve run into this at our company, the fact that the entirety of PCRE has just one implementation, and the spec is just however that one implementation works. Carving off a smaller part of that spec so that there is a strong spec and multiple credible implementations is hard work, Fastly has spent 10s of engineer years working on those problems. I do believe solutions can be found to this problem, but its going to be work. We’ll spend Stage 1 working on that.

**Andrew Brown:** Seems to me that these are good sections to put in the README

**Jianjun Zhu:** Yes, and once we have the repo we can better define the API.

**Lin Clark:** Poll. Success!

### Adding an initial current working directory to wasi-filesystem

**Dan Gohman:** Adding a string to the pre-opens. If present, it would be essentially an initial working directory. Add an optional string in preview 2. Unclear on how to do it in preview 1 in a way that wouldn’t break existing code

**Lin Clark:** Yeah, let’s not break preview 1.

**Dan Gohman:** Agreed. So there’s an issue open, let’s do this.

### wasi-nn announcement: change needing feedback

**Andrew Brown:** Quick announcement. Want to solicit feedback on a change we’ve been discussing with Matthew from Fastly.

- [issue](https://github.com/WebAssembly/wasi-nn/issues/36)
- [PR](https://github.com/WebAssembly/wasi-nn/pull/38)

Only way to load a model is to get all the bytes together and pass to a load. Those models can be very large. That ends up being the largest amount of time you spend. Now we’re at a place where we want to load models a lot more quickly. Discussing named models. Ability to register a model and give it a name, then load the model by name. That means you dont’ need to retrieve the model bytes again.

Planning to make this change soon, let me know if any concerns.

**Dan Gohman:** Only concern is the name. At first, was global namespace, but you said that was also a problem for you.

**Andrew Brown:** Matthew and I met with Pat to work through what to say in the spec about the scope fo the names. Decided spec shouldn’t say when they are available. The host should make that decision. Should only guarantee in the current instance.

**Dan Gohman:** There’s an instance called link time authority. Is that right?

**Andrew Brown:** Probably need to explain that more. Let’s take offline.
"
wasi/2023/WASI-07-13.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: July 13 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: July 13, 16:00-17:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. Luke Wagner and Joe Zhou: `wasi:keyvalue/cache` interface
    1. Dan Gohman: CLI world and resources
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. _Submit a PR to add your announcement here_


## Notes
### Attendees
Bailey Hayes
Pat Hickey
Luke Wagner
Dan Gohman
Zalim Bashorov
Dave
Kyle B
Timmy Silesmo
Joe Zhou
Jamey Sharp
Jeff Charles
Ayako
Wilson Wang
Dan Philips
Till Schneidereit
Kate Goldenring
Andrew Brown
Piotr Sikora
Yong He
Brian
Syrus Akbary
Chris Woods

#### wasi:keyvalue/cache interface

Joe: This is a new cacheing interface in the keyvalue proposal. There are a lot of similarities between cacheing and storage, and cacheing is very important to applications. Cacheing is not persisted. The cache interface is very similar in terms of access pattern and datastructures. Typically a distributed cache has TTL Time To Live support, for eviction. Uncommon for a keyvalue to have eviction. Should persistent keyvalue and cacheing be the same interface, or different? Luke and I have come up with the new cacheing interface

Luke: Some of the signatures look slightly different from persistent keyvalue. This is a different interface, but its part of the same package as key value because it is related. We are covering a lot of cache use cases but not every single advanced use case. In the browser there is a Web Cache that takes into account all of the HTTP semantics - that is a separate thing, this is just a simple key-value cache.

Luke: [describing the wit interface file on github] The interface uses pollable for async. We reuse the common key-value types for key, incoming and outgoing values. Here is future-get-result, returns an option which is some when it is ready. Exists is an optimization of get where you don't need a copy of the value. Set passes the outgoing value and the time to live, and a future result for when the set is done. There is a common pattern in caches, when a cache miss happens to eliminate the race to set. There are lots of consistency questions for how to implement this, so we designed get-or-set: i want to see if its there, and if its not, compute the value. Get-or-set a key gives you a future that gives a variant: either its a hit, or we get a vacancy resource. The vacancy resource we can call a fill method on, which has the contents or the time to live. This is ergonomic from e.g. javascript, wit will come up with better ways to show.

Andrew Brown: Does the vacancy resource give exclusive access to the slot

Luke: We are giving the implementation the choice to implement this any way it wants - as much or little flexibility to rendezvous with other get-or-sets as it wants. Whatever is appropriate for that implementation.

Luke: The only consistency guarantee is that the cache will never give a result that nobody ever stored - this is the weakest possible guarantee. A valid implementation of this cache is the no-op cache - always has a miss. Something thats super persistent is also a valid implementation. There is a huge array for hosts to implement whatever cache they need.

Luke: We think this interface would be a thing we want added to the imports of the http proxy world, because this is a really common feature found in proxies and really useful for applications.

Kyle: do we guarantee that anything past its time to live wont be returned

Luke: modulo distributed systems definitions of time being a little fuzzy, yes.

Luke: please file issues on the wasi-keyvalue repo to discuss further

Bailey: Are there example implementations yet?

Joe: Not yet



#### Dan Gohman: CLI World and Resources

Dan: This is my personal fork of the io repo, I also have forks of the various other related proposals.

https://github.com/WebAssembly/wasi-io/compare/main...sunfishcode:wasi-io:resources#diff-d7278433294421dd40c269a9713850cdb52dc0d9e7da0ea7b9f3ccfdc420e19c

Dan: Using my own fork of joels fork of wit-bindgen to piece together all the pieces that are missing upstream.

Dan: Also we have a wasmtime implementation of handles. Fairly soon we will have an end-to-end resources system. Once it does I hope to update all the wasi proposals to use resources pretty quickly.

Dan: Once the transition to resources is done we will have all the features we needed for preview 2, so soon it will be time to talk about exactly what preview 2 means and how we’re releasing it.

Dan: I’m hoping next meeting we will have a proposal for two sets of criteria: one for what it means for a proposal to be part of preview 2, and another set of requirements for preview 2 to be launched. We want to see preview 2 will remain open so additional proposals that meet the requirements can be added to it.

Kyle B: Does that mean language implementors will see preview 2 as a moving target, that will change during implementation.

Dan: What most people want is for preview 2 is to be stable - once a proposal is in there it does not change. But we will allow adding new features - you can opt into new functionality that gets added to preview 2, but nothing we make part of preview 2 will break.

Pat: We expect the parts of preview 2 that get integrated in standard libraries to be part of the launch of preview 2 - the cli command world is what we had from preview 1 and gets integrated with standard libraries is intended to be part of the launch set for preview 2. We also want the http proxy worlds to be part of the launch, because the whole idea 

Kyle B: What about the templates idea with a more advanced cli experience

Pat: wit templating is on hold, if and when implementation picks back up in the future it wont be part of preview 2.

Dan: The typed main story is a place where the standard worlds for cli and proxy, we expect people to have their own custom worlds, where you can do typed main without needing it to be a wasi standard. So that is more of a thing that the ecosystem and tooling will enable, not explicitly connected to wasi preview 2 but something that can happen in parallel

Kyle: a typed main is just a normal function, so with good bindings generators like we are already doing, it will enable it. We need to solve those problems for the wasi proxy world.

Dan: Some guest languages are more tied to the idea of being in charge of the lifetime of their program via main anyway. So we have a struggle there for tooling no matter what

"
gc/2023/GC-01-24.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 24 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: January 24, 5pm-6pm UTC (January 24, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Extern conversions as constant expressions ([#348](https://github.com/WebAssembly/gc/pull/348)) (5 minutes)
    2. Discussion: `br_on_cast` typing and when to use annotations ([#342](https://github.com/WebAssembly/gc/issues/342), [#347](https://github.com/WebAssembly/gc/pull/347)) (15 minutes)
    3. Discussion: `array.copy` and friends ([#313](https://github.com/WebAssembly/gc/issues/313)) (15 minutes)
    4. Discussion: Preparation for phase 4: spec documents and tests (15 minutes)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Conrad Watt
- Ben Titzer
- Rick Battagline
- Francis McCabe
- Asumu Takikawa
- Alon Zakai
- Luke Wagner
- Jakob Kummerow
- Ilya Rezvov
- Zalim Bashorov
- Matthias Liedtke
- Emanuel Ziegler
- Andreas Rossberg
- Aske Simon Christensen
- Deepti Gandluri


### Discussion: Extern conversions as constant expressions ([#348](https://github.com/WebAssembly/gc/pull/348)) (5 minutes)

TL: Summarizing issue. Any objections?

No objections.

### Discussion: `br_on_cast` typing and when to use annotations ([#342](https://github.com/WebAssembly/gc/issues/342)

TL: Summarizing issue. We are happy with polymorphism over nullability in binaryen. Andreas, can you explain your objection?

AR: Nullability in polymorphism is fine, but it’s also polymorphic in the heap type. That makes analysis of code fragments without context more complicated. Why do we have annotations at all? To make typing simpler (not related to reference types) and also to simplify execution semantics, but we didn’t establish what precise properties we wanted to uphold. In particular it was argued that there is a fundamental difference between struct.get and something like a cast where the type details don’t need to be known. Want

TL: Two questions: heap type polymorphism? Principled design principle?

AR: “Return type” isn’t the right criteria because e.g. struct.set doesn’t return anything.

CW: My impression is that you could rephrase the typing rules to remove the polymorphism, since it only arises from trying to ensure that the top types match. 

AR: Right, but that determines the output type as well, so it’s polymorphic. We can 1) add a new annotation to cast, 2) refine our design principles, 3)...

TL: What if we do the thing that all the implementations want and take an action item to come up with a consistent rationale later?

BT: Would want to swing for the fences. What if we allow struct.get to specialize based on stack type as well?

AR: Objections.

ASC: I would like to understand the rules here. Br_on_cast null same as old br_on_null? If it validated under the old rules, why is it a problem under the new rules?

AR: Problem existed with old rules as well.

TL: The way we solved this for struct.get was to run code size experiments showing that the code size hit for the annotation was somewhat acceptable, then we just added the annotation. Could try the same thing here. Both annotations are and would be completely useless as far as Binaryen and V8 are concerned.

BT: Could annotations affect semantics in a future extension?

AR: No, it’s just a helper for validation and maybe execution.

ASC: Would we need to add an annotation to other instructions?

AR: Yes, would need to add annotations to all four general cast instructions.

TL: Unhappy if our go-to solution is to add annotations that no implementer wants.

AR: Agree, but unclear what the consistent rationale is.

TL: Can we agree on type sharpening today and defer the discussion on heap type polymorphism to the next meeting? That wouldn’t regress the state of the heap type polymorphism problem.

AR: Begrudging agree.

### Discussion: Preparation for phase 4: spec documents and tests 

TL: Andreas, do you want / need help writing tests?

AR: It’s all over the place. Complex things have more tests, but “obvious” things have fewer tests. Hard to say specifically where we are lacking. Would be helpful for implementers to add their own tests.

BT: I would be happy to merge some tests. Feature request for wast would be top-level variables.

AR: You can do that by wrapping state in a module.

BT: There are many tests that initialize a table, then call a method with a table index.

AR: Don’t think those would work with globals because the point of the table is that you don’t have full static type information…. Oh no, I think it makes sense.

BT: Would be convenient to write short tests with globals rather than tables.

AR: Would be nice to have a richer expression language. Missing type expressions.

TL: Great, will also take personal AI to check in on getting V8 tests upstreamed. Let’s take the discussion of richer assertions offline.

AR: Next steps for spec are to rebase tail calls. Conrad should review PR for typed function references.

TL: Asumu has volunteered to take the JS spec. Thanks, Asumu! Do we need to do anything for the Web spec?

AR: No, that shouldn’t be affected.

AT: There are also Web Platform Tests. I can work on those.

FM: You should coordinate with Ilya. He’s championing JS types now.

AR: What is the state of that?

IR: …

AR: The intersection will be interesting. Sequentializing is a good way to resolve conflict. Maybe we just continue in parallel.

TL: Agree, seems unlikely that both will be ready to merge at the same time. Let’s just let the first one win and update the other.

### Discussion: `array.copy` and friends ([#313](https://github.com/WebAssembly/gc/issues/313)) (15 minutes)

TL: These are a straight performance win, what would it take to get into MVP?


CW: Let’s do it!

ZB (chat): we also see perf benefit in K/Wasm.

AR: Would prefer to have all 3? Instructions.

TL: There are a lot of instructions possible if you think about it. Could copy between memory and arrays, for instance.

AR: Maybe let’s not do that but still have a complete set of instructions for arrays.

CW: As a compromise, could we reserve opcodes for the other two and commit only to array.copy for now?

AR: That’s extra complicated in terms of spec overhead.

BT: I agree with AR. Would be nice to have a complete set.

ASC: Dart would actually like to use the array-to-memory instructions.

CW: Could immediately spin up a post-MVP proposal with all the instructions including array.copy?

TL: Probably don’t want to wait for array.copy, but will check in with the team.

AR: Other thing is that I don’t want to write the spec, implement it in the interpreter, or write tests for this.

TL: We can do tests, but you reviewing us trying to do the spec might be more work for you.

AR: Ok I can do the spec.

CW: I can do the interpreter.

TL: Great, thanks. Don’t go off and do a bunch of work just yet, but let’s plan to commit to this direction soon.
"
main/2017/CG-07-06.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 6th video call of WebAssembly's Community Group

- **Host**: Google Hangouts
- **Dates**: Thursday July 6, 2017
- **Times**: 9:00am–10:00am Pacific Time
- **Location**: *link sent to registered participants*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

[Sign-up](https://goo.gl/forms/9iKZxiHSWFcB99cz1)

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Follow-up from the May meeting:
       - Non-trapping float-to-int conversions [open on the design repository](https://github.com/WebAssembly/design/pull/1089)
       - Threads
         * Update `Overview.md` to match CG meeting decisions:
           - Remove float atomics
           - Use 0xfe as prefix byte
           - Add sign-extending conversion operators
           - Remove sign-extending atomic-operators (encoding proposal 3)
         * [Reference ECMAScript Agent/AgentCluster](https://github.com/WebAssembly/threads/pull/29)
         * [Rationale examples for WebAssembly.Global](https://github.com/WebAssembly/threads/pull/31)
         * `WebAssembly.Memory` [clarified, and potentially `frozen` buffer](https://github.com/WebAssembly/threads/pull/32#issuecomment-311175403)
         * Sign-extend: [fix naming and add `i64.extend32_s`](https://github.com/WebAssembly/threads/issues/34)
       - SIMD
         * Added a separate document for the binary encoding of SIMD.
         * Update per CG meeting consensus:
           - Changed the float-to-int conversions to saturating semantics
             instead of trapping.
           - Removed some of the `i64x2` operations.
           - Removed all shuffles and swizzles except for `v8x16.shuffle`.
         * Removed the boolean types. The CG meeting did not reach a consensus
           on the direction to take, so we'll go with the simpler version for
           now.
    1. Adopt [Online consensus](https://github.com/WebAssembly/meetings/pull/18)
    1. Upcoming Kirkland meeting: discuss potential agenda items
      - Specification
      - Multiple return values
      - Tail call
      - GC
    1. Working Group formation
1. Closure

### Schedule constraints

None.

## Dates and locations of future meetings

| Dates                    | Location          | Host       |
|--------------------------|-------------------|------------|
| 2017-07-18 to 2017-07-20 | Kirkland, WA      | Google     |
| 2017-11-06 to 2017-11-07 | Burlingame, CA    | TPAC       |

## Meeting notes

### Roll call

* Alan Cezar Araujo da Silva
* Andreas Rossberg
* Arun Purushan
* Ben Smith
* Ben Titzer
* Bobby Powers
* Brad Nelson
* Clemens Hammacher
* Dan Gohman
* David Voyles
* Deepti Gandluri
* Derek Schuff
* Dimitar Bunav
* Domenic Denicola
* Ed Coyne
* Ido Neeman
* JF Bastien
* Jakob Geavelle
* Jakob Olesen
* Jason Yu
* Keith Miller
* Lars hansen
* Luke Wagner
* Mark Miller
* Michael Ferris
* Michael Holman
* Peter Jensen
* Sercan Sulun
* Sergey Rubanov
* Vincent Belliard
* Yan Z
* fanmingfei

### Agenda adoption

Schuff sconds meeting adoption.

### Follow-up from May meeting


#### float-to-int conversion

Gohman presenting.

* [PR open](https://github.com/WebAssembly/design/pull/1089).
* Not merged yet, waiting for Google review.
* Titzer asks about process. Bastien explains how [CG to WG process is intended to work](https://github.com/WebAssembly/meetings/tree/master/process). Process still being clarified, mentions [Nelson's PR](https://github.com/WebAssembly/meetings/pull/25) (discussed later).
* Rossberg mentions the spec draft is already in good shape, he'd be ready to try merging this proposal to the spec. Asks that we do the full process with a fork of the design repo.
* Wagner proposes that we could just do a PR against the design repo.
* Titzer thinks we should do the full process.
* Nelson said the proposed process used to have this, but he removed it.
* Rossberg says having a fork allows getting the tests and specs right, and uploading a draft spec properly on github.io.
* Denicola do like TC39? Don't need design process for bug fix, but you shouldn't edit spec if doing a substantial change.
* Nelson spec is fairly readable, maybe we should consider deprecating design repo.
* Gohman volunteers to try out this process.

#### Threads

Smith presenting.

* Match CG choices as detailed in agenda above (*list not repeated for notes*).
* Rossberg found a difference in extend, different from CG discussion.
* Miller asks what it means to extend an i64. Smith: it refers to sign extension, the low 32 bits only.
* Another question about `wait` operator which takes a float timeout. Could take `i64` instead.
* Schuff: some work on the toolchain, in LLVM and binaryen, not fully ready yet.
* Smith: Scheidecker has implemented the older proposal in [wavm](https://github.com/AndrewScheidecker/WAVM).
* Bastien: no complete implementation in browsers yet.
* Nelson hopes to have implementation in V8 by July, may be missing 64-bit opcodes but will have prototype.

#### SIMD

Olesen presenting.

* Match CG choices as detailed in agenda above (*list not repeated for notes*).
* Not sure about benchmarking.
* Nelson: hoping to do a presentation about general numbers on portable SIMD, representing a subset of interesting applications. Should be a quick update, not complete.

### Online consensus

* Bastien explains [the proposal](https://github.com/WebAssembly/meetings/pull/18).
* Was adopted on GitHub, want to make sure wider group gets a say.
* Titzer: ship it!
* Bastien asks for unanimous consensus to adopt? **Yes**.

### Upcoming meeting

Bastien presenting the current list of topics (see agenda above).

* Bastien asks for more detailed agenda items, including proposal details and straw polls.
* Miller emphasizes that GC really changes the character of WebAssembly.
* Rossberg agrees that all language communities are really interested in WebAssembly. Was surprised by interest in places such as PLDI. For some the lack of GC is a showstopper.
* Titzer thinks we should really call it ""managed data"", it's not really about ""garbage"". Brings different conotations, not all positive.
* Rossberg: there are two directions, either as a primitive or in some way provide necessary hooks so you can implement it yourself. Titzer and him have strong opinions about this and think the latter have huge issues, but we need to discuss this in-person.
* Miller: the surprising thing to him was it changes from Von-Neumann to heap allocated opaque things. It's not a flat address space anymore.
* Bastien: technically WebAssembly is currently Harvard.
* Rossberg: yes, this changes things from ""assembly"" to higher level, similar raising of abstraction level to exceptions.
* Nelson: yes, exceptions aren't on the agenda, we want to try out C++ exceptions more before presenting to in-person group. Work happening in [repository](https://github.com/WebAssembly/exception-handling).
* Titzer: we're not sure yet how languages would use the managed object proposal. The discussion should be about the context and gathering people who would target it.
* Rossberg: yes we're far away from a final thing yet.
* Limin: GC proposal will attract people who are interested about just GC. Would be good to allow folks to attend just that discussion.
* Nelson: we could do a day for this.
* Bastien: will send a PR for Wednesday all day GC discussion.
* Wagner asks about cadence of meetings? Every two months seems a lot.
* Bastien: was thinking about doing every 3 months for now.
* Wagner: 3 or 4 a year is OK.
* Bastien: still look for a venue in November. Maybe Munich next year.

### Working group formation

Nelson presenting.

* There's a draft charter out for review for the W3C. Out for vote with advisory committee. Ending in July 12th. Will ping WebAssembly folks whose company is on the advisory group. Need 17 votes, only have 7 right now. Hope to have an announcement shortly after. Hope by Kirkland.
* Bastien charter proposal on [mailing list](https://lists.w3.org/Archives/Public/public-webassembly/2017May/0003.html).
* Nelson: charter is super standard W3C, nothing special.

Meeting adjourned.
"
stack/2023/stack-2023-09-25.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 25th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  September 25th, 16:00-17:00 UTC ( September 25th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants

Francis McCabe
Yuri Delendik
Ilya Rezvov
Luke Wagner
Ryn Hunt
Deepti Gandluri
Thibaud Michaud
Andreas Rossberg
Brendan Dahl
Ben Tizer
Ross Tate

## Agenda items

1. Discussion on JSPI/core stack switching integration (Francis McCabe)
   Slides are [here](https://docs.google.com/presentation/d/1WTzcNXHVKZjdLnmxtdnT___BVmqTTjIkpZniIv9OkTw)

  This meeting was recorded, the recording is [here](https://us02web.zoom.us/rec/share/ATZrIvteewJyRHUzlojiuNjz2zd6ocuxpQjlwGNR4DfSb_WN76pIGW6kYefkk2w2.NKRnyBeAdn0tLZSQ)


### Adoption of the agenda

### Discussion

#### Discussion on JSPI/core stack switching integration

FM Presenting [slides](https://docs.google.com/presentation/d/1WTzcNXHVKZjdLnmxtdnT___BVmqTTjIkpZniIv9OkTw)


RH: Would it be possible to go back to the slide with the SS application that used JSPI? Is each one of these boxes a different boxed? What does it represent? 

FM: Each one of them represents a different coroutine? 

RH: The scheduler calls a different stack..?

FM: You can implement the scheduler however you want, its not important for the scheduler to running in its own computation, if you have it so that the logic of the scheduler is distributed across the tasks, the data structure for the scheduler is messed up, it would only work if the data structure is global to the whole program. Also, this is a simpler picture.. (However.. slide) will show up between components, there’s no shared linking between the components

RH: Let’s stay on a single component slide. Why should a scheduler not be aware of the computations? And be able to handle different resume patterns

FM: That is one solution, there is another problem with that, many languages/libraries that support coroutining, they also allow their applications to do their own scheduling, in Loom you can write your own scheduler, if you’re bringing your own scheduler, then the users schedulers also need to be aware of this. If you have a Kotlin web specific scheduler, it wouldn’t have the same freedom that a non-web scheduler would have to do fine tuning of user applications. You can, but it will affect the difficulty of bringing an application to the web

RH: The solution that I would think of is that the scheduler should be aware of how the host should schedule this application, 

RT: A scheduler only needs to be aware of the tasks that are ready to be resumed; it can’t/shouldn’t schedule a task that’s still waiting for input. So why does it need to know about tasks waiting for promises?

FM: There is another thing, there has to be agreement across the boundaries, what this means is that the integration between the tasks and scheduler, task2 can wake up the scheduler, even though the scheduler is waiting for someone else. You could do this, it’s made substantially harder if you have a hierarchical model of coroutining, the scheduler may not be in a resumable state, which is where the actual core stack switching model will matter (SLIDE: Task2s promise gets resolved)

AR: Isn’t that true here as well? Because you can get into an inconsistent state, I can’t claim that I fully understand the state that, it looks like you’re running into the problem of composing multiple effects, this is what effect handlers are supposed to do, but it might not be able to solve this because JS layer is not composable

FM: This is caused by composability, and not solved by it. All the hierarchical effect handlers need to know about each other

AR: If you do it carefully, they don’t need to know about each other, that’s the point of effect handlers, it has to invoke the right effect, depending on why it suspends, it needs to go to the right resume point

FM: It doesn’t know that it was resumed in a  funny state, in a hierarchical system, task2 would not be resumable by itself, it has to be resumed by itself

AR: In a hierarchical system, it has to say what it reason it suspends, by construction the baseline only handler you suspend to will only know how to resume

FM: Its woken up by the event loop, the hierarchy has been bypassed

AR: The hierarchy has been bypassed, not suspended, that's always the case, if you have these types of hierarchical structures, you can only resume… only the point that you have suspended to can resume

FM: That is the logic that I was assuming, however, if you go back to (focusing on semantics slide), these are the current semantics for JSPI. S.suspend is a legitimate thing to do, the issue is that we cannot, or should not take the form S.resume, because that is what causes the crash, the then function is not called by the scheduler, its called by the event loop, its bypassing the natural hierarchy of the tasks. We can make this work if we don’t resume the thing we suspend, if we don’t resume what we suspend, what do we resume? The top level task might be the one to resume, and we have to figure out what task it restartable, and if we go to the component model, the other component doesn’t know which task is resumable, then it needs to pass something to say which task can be resumable


AR: Agree that there’s a problem when we go to the Wasm boundary, JS is just not expressible (or JS as the proxy for the web architecture) is not expressible enough, and we have to work around it somehow
FM: Agree, if we do this in a real OS, when you create a promise, this is half of a pair, there’s a computation that is suspended, and another that has a resumable pair. With the promise architecture half of that is outside of our control, in a real OS, they’re both in control of the application, so the scheduler can be made aware locally, that’s the thing missing on Web architectures

AR: The fundamental problem here is that you want some.. The user space shceuler, and the WebAssembly scheduler somehow need to coordinate, because they’re not hierarchical, together they have to collaborate as one big scheduler, that’s inherently not composable. The scenario is very specific, and not necessarily related to component boundary

LW: In a multi-language scenario with different layers, you do want this hierarchical two-layer scheduler, what is the JSAPI between core Wasm? JSPI is close, but not sufficient. There’s a different lower level JSAPI, there should be a continuation reference that can flow in/out of JS. When you have a continuation reference, that accepts a promise, what does that mean? <TODO: LW to fill in> 


AR: Except what FM was talking about was that we need more than two levels..

LW: I think you only need two levels of scheduling, one at a top level and one intra-componen, you can avoid the n-level computing

RT: 

LW: Kotlin can do it that way, and when you have a different language implementing it in a different way, then that’s when the component model makes sense. When it’s all one language, we can assume there’s a common ABI and the modules can share memory etc., and that tis all core wasm. 

(FM & RT discussion on differences between Web & OS)



### Adjourn

"
wasi/2023/WASI-11-16.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: November 16 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: November 16, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Announcement of postponing [changing WASI initialism] (Luke Wagner)
    1. Discussion and poll to merge [wasi-http/#68](https://github.com/WebAssembly/wasi-http/pull/68), changing WASI HTTP's portability criteria (Luke Wagner)
    1. Announcement of Phase 3 votes on 11-30 for io, filesystem, clocks, random,
       sockets, cli, and http (Pat Hickey)

[changing WASI initialism]: https://github.com/WebAssembly/WASI/issues/563

## Notes
### Attendees

- Pat Hickey
- Bailey Hayes
- Andrew Brown
- Jorge Prendes
- Kevin Moore
- Kyle B
- Colin Murphy
- Sam Clegg
- Hung-Ying Tai
- Conrad Watt
- Deepti Gandluri
- Luke Wagner
- Wouter Hennen
- Wilson
- Dan Gohman
- Dan Philips
- Oscar Spencer
- Yong He
- Ben Green
- Wassim Chegham
- Fedor Smimov
- Michael Warres
- Till Schneidereit
- Piotr Sikora
- Jeff Charles
- Mingqiu Sun
- Chris Woods
- Syrus Akbary
- Yosh Wuts
- Ivan Font
- Zalim Bashorov

### Announcement of postponing changing WASI initialism (Luke Wagner)

**Luke Wagner**: Since our discussion last week Chris Woods had a thoughtful comment on the Github Issue. Paraphrasing, “Given that lots of things are changing, maybe this will add more confusion than necessary, so lets let preview 2 ship and once things are calm lets do it then”. That sounds good to me, no rush to change the name, so lets bring it up again in half a year.

**Bailey Hayes** Please leave more comments on the GitHub issue if you have more feedback on this.

### Discussion and poll to merge wasi-http/#68, changing WASI HTTP's portability criteria (Luke Wagner)

**Luke Wagner**: Last time we talked about changing the portability criteria for WASI-HTTP. We filed an issue on that, collected feedback, positive approval from several of the WASI-HTTP champions and no disagreement so far. So lets bring it up to a poll.

**Bailey Hayes**: For entering preview 2, we have launch criteria and the general phases we have for WASI proposals. For the launch criteria of preview 2, we need two different implementations of the WASI interface proposed, and the portability criteria of the proposal says where those things are able to run. The proposal is that WASI HTTP doesn’t also have to run in the browser, in addition to node.js. 

**Luke Wagner**: The wording is “WASI-http must have at least two complete independent implementations
demonstrating embeddability in a production HTTP server context.” https://github.com/WebAssembly/wasi-http/pull/68

**Bailey Hayes**: Holding a poll, the categories are strongly in favor, in favor, neutral, against, strongly against. Post your answers in the chat.

Poll results:
Strongly For: 16
For: 2
Neutral: 6
Against: 0
Strongly against: 0

**Bailey Hayes**: We will move forward and change the criteria for wasi-http.

### Announcement of Phase 3 votes on 11-30 for io, filesystem, clocks, random, sockets, cli, and http (Pat Hickey)

**Pat Hickey**: Heads-up that next meeting is a heavy agenda. Part of the criteria for launching preview 2 are all phase 3 proposals. A phase 3 proposal means that you have a credible plan for meeting the portable criteria: 

```
Entry requirements:
* The portability criteria must be either met or there must be a plan for how they're expected to be met.
* All dependencies of the wit descriptions must have reached phase 3.
```

**Pat Hickey**: The goal is to launch preview 2 with the two worlds being wasi-cli world and wasi-http-proxy world. This set is those worlds and all of those dependencies. The criteria for all of these is that there are two implementations, and that it runs on mac, linux, and windows. This is complete with wasmtime. The second implementation for each of these is the JCO project. They are using the wasmtime test suite to measure their completeness. Thank you to the tracker Yosh setup yesterday to measure that they are at 53% completeness. JCO is expected to be complete, maybe by the end of the year or by January.

**Pat Hickey**: Given this information, we believe we are ready to open this to a vote. If you are looking to understand anything about these proposals or discuss what it means to vote next meeting.

**Sam Clegg**: You mentioned the that the tests live in wasmtime. Will this be something that will live next to the specs?

**Pat Hickey**: We have not yet done the engineering effort to move these to a separate test suite that wasmtime, JCO, and all other implementations will be able to use.

**Pat Hickey**: This is a nice to have and not required to launch Preview 2. We think we will be able to do this soon. In lieu of having the tests in an open place, we welcome people to scrutinize and provide feedback on the tests in wasmtime. The more time people spend time banging on and using these implementations, the better. 

**Pat Hickey**: Feedback from JCO has been valuable. Guy and Yosh have been doing a good job of posting questions as issues to help document and improve the suite. We have also had a lot of good questions and discussions from Till Schneidereit while he has been doing implementations as well.

 
**Yosh Wuyts**: (in chat)
https://github.com/bytecodealliance/wasmtime/tree/main/crates/test-programs/src/bin

there are currently 100 separate test programs checked in; each containing one or several test cases

**Ivan Font**: What is the relationship between the WASI Test Suite in the WASI org.

**Pat Hickey**: All of those tests are targeted at WASI Preview 1. Many of those are taken from the wasmtime test suite. Wasmtime also runs the WASI Test Suite.

**Ivan Font**: Do we think this is a reasonable place to move the preview 2 tests from Wasmtime?

**Pat Hickey**: Yes definitely. I can’t promise that’s something we can do right now, but when we get resources. 

**Syrus Akbary**: Is there a good place to compare the implementation differences between wasi-sockets and posix sockets?

**Pat Hickey**: Dave Bakker is the champion. In general the doc text in that project is exemplary. Look at that proposal repo for more info and file issues for missing information.

**Bailey Hayes**: Dave presented in this meeting with a comprehensive matrix. Till posted a link to this in the chat. 

**Till Schneidereit**: (in chat) 
the proposal is very detailed and explains where there are differences, and why: https://github.com/WebAssembly/wasi-sockets/
 
and more specifically to this question: https://github.com/WebAssembly/wasi-sockets/blob/main/Posix-compatibility.md

**Syrus Akbary**: That’s very helpful, thank you.

**Pat Hickey**: There isn’t a requirement to ask questions in this meeting. We encourage folks to discuss by opening issues in the proposal repo, or to talk with the proposal champion. Please reach out ahead of this vote. 

"
wasi/2022/WASI-09-22.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: September 22 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: September 22, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Overflow on poll from last time
    1. [Introducing Worlds for WIT](https://github.com/WebAssembly/component-model/pull/83)

## Notes
### Attendees:

- Lin Clark
- Dan Chiarlone
- Piotr Sikora
- Dave Bakker
- Chris Suszynski
- Kevin Hoffman
- Jiaxiao Zhou (Mossaka)
- Adam Mohammed
- Luke Wagner
- Jeff Charles
- Saúl Cabrera
- Joel Dice
- Till Schneidereit
- Chris Woods
- Mingqiu Sun
- Dan Gohman
- Yong He
- Bailey Hayes
- Brian Hardock
- Andrew Brown
- Steve S
- Kyle Brown
- Kevin Moore
- Victor Barros
- Johnnie Birch
- Arne Vogel
- Michelle Dhanani
- Dan Mihai Dumitriu
- Steven Prine
- David Justice
- Antoni Bofarull

### Poll: gRPC

**Lin Clark:** Piotr, Dan and Joe will collaborate as champions on HTTP and gRPC
**Kevin Hoffman:** Concern that gRPC is conceptually a different thing
**Jiaxiao Zhou:** also has code generator
**Kevin Hoffman:** also has bi-directional stuff
**Piotr Sikora:** HTTP also has bidirectional stuff
**Kevin Hoffman:** Not saying HTTP doesn’t support. But the basic HTTP interface doesn’t utilize that. When you describe a HTTP server, lot more description of what’s going one way, one going another
**Lin Clark:** Sounds to me that we could decide later
**Piotr Sikora:** Technically could consider gRPC as a layer above WASI
**Luke Wagner:** Given a gRPC request, would you want access to headers, etc.
**Piotr Sikora:** I dont’ think so
**Luke Wagner:** If you don’t want underlying HTTP stuff, then it makes sense to have gRPC separate
**Kevin Hoffman:** I could be misremembering, but IIRC it’s supposed to be transport agnostic. 
**Piotr Sikora:** I don’t think that’s true
**Kevin Hoffman:** That’s why I asked to refresh my memory, wasn’t sure
**Piotr Sikora:** I think gRPC is defined on top of HTTP headers and status codes
**Jiaxiao Zhou:** Side note: I believe HTTP and gRPC are quite different from previous proposals we discussed. They are protocol specific. Should we just have layer 7
**Lin Clark:** My sense is we do want protocol specific.
**Lin Clark:** Any concerns about gRPC moving forward?
**Lin Clark:** Congrats on the new proposal!


### Introducing Worlds for WIT

**Brian Hardock:** Nothing final, everything in flux. Bringing up here because it’s really exciting development in wit and tooling space

What does wit currently define? Single interface IDL. No way to capture directionality of the API. Taking motivation of http handler. Common practice to split out common types. Today, 4 ways to consume HTTP handler interface. Dot product of guest/host and export/import. Grappling with different perspectives is a challenge. For this example, might imagine condensing some of these. But for each interface that might be required to be implemented, might have any number of itnerfaces. Having to chain multiple invocations is hard. This will make codegen for our component much more complicated. In general a single component will refer to 0-N interfaces. 

World is designed to address this complexity. It expresses it in the IDL. A World is just a collection of imports and exports. They express the contract between guest and host components. Allows us to actually articulate and collect something that you can feed into a code generator. Can say generate bindings for a particular world. Interesting consequence of operating over worlds is we can ask whether a guest’s requirements can be satisfied by a particular host. 

The real benefit is that as developer, we only have two perspectives to think about. Some more motivations: all hit issues with trying to share types across interfaces. In terms of shared tooling, we want to give a world to wit-bindgen and have host and guest bindings generated for a particular language. 

Type sharing and linked bindings is the problem we’ve all come across. Alex did the diligence of collapsing into issue 266 in wit-bindgen. 

Realized we can perform a global resolution to check for equivalency across interfaces. Particularly focused on global resolver for shared bindings. 

Ongoing discussions that are happening: how do we actually structure wit files. Can we write one wit file. How do we reference types in other namespaces. Consensus developing around supporting single wit and also support split out into multiple files for reuse and distribution.

How do we treat wit with all interfaces is open question.

Example of HTTP proxy.

**Dave Bakker:** What’s the difference between a component interface and a world. 

**Brian Hardock:** The world is effectively a component type. The interface maps to instance type. More generically, a world is a family of components. A world is a function that takes imports and as a result returns exports. Type at time of instantion is fixed. A world is meant to reflect that it’s a higher order over any number of interfaces which could result an instances. I’ve been trying to shift away from thinking of a world as a component. 

**Steve S:** Question about futures. Is an interface tightly bound to whether it’s async or not? Is that something that can be abstracted? Could the world bind it to being async or not?

**Luke Wagner:** Whether a func is async or not just shows up as the return. It returns a future result of response. Not a whole world, binary decision. Goal of async types is that they should compose.

**Andrew Brown:** Higher level question about registry. If someone wants to publish to a registry, would require a world?

**Luke Wagner:** Ideally a component is entirely self describing. Should be able to ask the most tightly fitting world for a component. Lots of worlds. Standard ones, host-specific ones, which world they target doesn’t matter because the interfaces line up with where I want to publish them. What world I used isn’t encoded in the component. It’s just interfaces used.

**Andrew Brown:** To follow on to that, all importa dn exports will have URLs. All proposals will have URLs. What about custom interfaces. 

**Luke Wagner:** URL is an optional part of the name. If you have your own bespoke, then you would leave off the URL.

**Chris Suszynski:** Doubt—always the biggest problem is naming. I worry about really similar Worlds. Some kind of union of worlds would be useful?

**Brian Hardock:** Yes, in the PR we’ve discussed the concept of extends, which allows for composition.

**Chris Suszynski:** I’m thinking about wanting to target two worlds. Something like and keyword would be useful.

**Luke Wagner:** Big motivating design challenge was trying to support union and intersection of worlds. So part of that is that the particular world I use doesn’t matter. World is just a convenience thing. 

"
wasi/2023/WASI-06-29.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: June 29 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: June 29, 16:00-17:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Continuation of last week's Vote: Advance [wasi-sockets](https://github.com/WebAssembly/wasi-sockets) to phase 2. In this discussion we will finalize the Phase 4 advancement criteria for the proposal.
    1. Pat: Versioning of pre-release proposal wits

## Notes

### Attendees

- Bailey Hayes
- Pat Hickey
- Allison Durham
- Colin Murphy
- Kate Goldenring
- Jeff Charles
- Joel Dice
- Kevin Moore
- Frank Schaffa
- Dave Bakker
- Colin Murphy
- Piotr Sikora
- Ivan Font
- Chris Woods
- Lin Clark
- Dan Phillips
- Ayako Akasaka
- Jiaxiao Zhou

#### Vote to advance wasi-sockets to phase 2

Reminder: [phases process](https://github.com/WebAssembly/meetings/blob/main/process/phases.md)

Continuation of last week's Vote: Advance wasi-sockets to phase 2. In this discussion we will discuss some of the Phase 4 advancement criteria for the proposal.

**Dave Bakker:** Concern last time about what it means to be POSIX compatible. Do we have any special requirements regarding the socket? PR document that details the mappings. Main goal today is to define the advancement criteria.

**Chris Woods:** Dan Gohman suggested as an advancement criteria, show that the interface is capable of supporting an existing piece of software. Discussion on a GitHub issue in the meantime and the document for a bit of existing software (e.g. rust and python).

**Chris Woods:** What about openSSL? For an advancement criteria, looking for some assertion that we have some level of support.

**Dave Bakker:** Drafted document in [wasi-sockets PR](https://github.com/WebAssembly/wasi-sockets/pull/40/files)

**Dave Bakker:** The most ambiguity is in the socket options. After going through multiple code bases and observing which options are typically used. Most are single-platform. Only the top is cross-platform and used across projects.

**Chris Woods:** Maybe openssl isn’t too large of a project to display support?

**Dave Bakker:** Gut is that only one project is insufficient for defining phase 4. There is a lot of stuff that is not used anywhere and can be eliminated quickly. The remainder is used for multiple software packages using this. If more than one uses this software option, then we should include it as supported or have a very clear definition of why it is not included. For example SO_ERROR will not be supported because this will be supplied by native sync support within the component model.

**Dave Bakker:** Two others for example will not be included because they are specific for raw sockets and therefore is out of scope for this standard.

**Dave Bakker:** We could take a subset of this table and all of the ones used by one piece of software and declare that as something that will be specified by WASI.

**Bailey Hayes:** Entry requirements:

- Precise and complete overview document is available in a forked repo around which a reasonably high level of consensus exists.
U- pdates to the actual spec document, test suite, and reference interpreter are NOT yet required.

**Pat Hickey:** No votes against. wasi-sockets moves to phase 2.

- SF: 13
- F: 4
- N: 2
- A: 0
- SA: 0

[Proposal passes.]

#### Pat: Versioning of pre-release proposal wits

[slides](https://docs.google.com/presentation/d/1t8rTwkJA28IvFvyqy3K49jy8Sm0xUsk-vZssFAruD8o/edit?usp=sharing)

We do not have a reliable way to make updates to specs (yet), which means every change is a breaking change.

There are two host implementations:
- Wasmtime
- JCO -> related to Wasmtime

Do let us know if implementation is underway for other hosts.

Proposal repos reflect what we need

On the guest side, most are using a project from wasmtime that is called the wasi-preview-1-component-adapter.

When using the component adapter, this “locks-you-in” on the version of the proposals when this adapter was built. This covers the ground that was already covered in preview 1.

For all other interfaces, we do not have or need this component adapter. For all other components it invokes wit-bindgen. Inside JCO there is some tooling for transpilation.

What do you feed into wit-bindgen? Feed wits manually written, a git submodule, sometimes with wit-deps, but the ultimate goal is to use a component registry. The goal in the near-ish future is to use the registry for wasmtime.

WIT has versions now. Poll is the one thing that you can’t live without because this is how blocking is implemented. Streams build on poll. <Pat displays an example wit of these>

Version syntax is semver. Major.minor.patch-<pre-release suffix>. 
Proposed versioning scheme. We’re looking to ship preview 2, it’s not 2.0 it’s something pre-1.0.
We’re focused on shipping preview 2. We know we want this release to be `0.2.0`. We are not defining the release that comes after preview 2.

0.2.0-rc-2023-06-29.1

ISO 8601 Date.
Monotonically increasing number for “goofs”. Integer that is an escape hatch if we need it.

Pre-release process:
Take the grammar previously shown and make a PR to the proposal repo. The proposal repo has a CI step that validates the WIT using wasm-tools to validate.

Merge PR to main, create a git tag with -a. `git tag -a v<version number>`.
The MVP would publish a release. Improvement would be publishing to a registry.
Expected cadence to be about once a month.

**Frank Schaffa:** Just thinking aloud: suggest we use something based on cargo package toml, that will apply to all, except ones that have explicit notation

**Pat Hickey:** We aren’t ready to add the registry tooling yet. But that could be an optional solution.

**Bailey Hayes:** Talk with Guy and Peter showing this off: https://www.youtube.com/watch?v=JCIwpc7x4jU

**Till Schneidereit:** I think it should always be possible to use WASI and WASI's WIT definitions without depending on a registry that's not owned by the Wasm CG. Obviously that doesn't rule out using a registry as an optional thing, but it shouldn't be a hard requirement

**Jiaxiao Zhou:** When we release release WIT version, do we also want to release a wit-bindgen version?
Ideally each WIT version should be bundled with a wit-bindgen version
I would appreciate to hear your takes on https://github.com/WebAssembly/wasi-http/issues/46
Specially about releasing client bindings together with WIT release.

**Eduardo Rodrigues:** https://crates.io/crates/wasi-preview2-prototype

**Pat Hickey:** First we’re aiming to standardize the versioning for wasi WIT files.

**Eduardo Rodrigues:** It makes sense for us to have some base implementation. Difficulty re-implementing within JavaScript for wasi-http.

**Pat Hickey:** We want to begin hearing feedback on issues with implementation to strengthen the standard.

**Pat Hickey:** We do not have a reasonable way to patch and work on a CVE within an org that is open to everyone.

**Pat Hickey:** Reinforces Till’s chat message that a working registry should not be a requirement to use a standard."
main/2018/CG-06-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 12 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: June 12, 4pm-5pm UTC (June 12, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email JF Bastien or Ben Smith to sign
up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Update on Conrad Watt's work on threads proposal
    1. Update on Layer 1 Compression (Katelyn Gadd)
    1. Discuss module serialization via indexeddb in v1 spec (Derek Schuff/Luke Wagner)
1. Closure

## Agenda items for future meetings

* Discuss [removing ahead of time bounds checks during instantiation](https://github.com/WebAssembly/spec/pull/820)

### Schedule constraints

*None*

## Meeting Notes


### Opening, welcome and roll call

#### Opening of the meeting

#### Roll Call

* Ben Smith
* Ben Titzer
* Conrad Watt
* Deepti Gandluri
* Derek Schuff
* Heejin Ahn
* Jay Phelps
* John Hall
* Limin Zhu
* Mark Miller
* Michael Holman
* Pat Hickey
* Richard Winterton
* Sean Westfall
* Sergey Rubanov
* Sven Sauleau

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Derek Seconds

### Proposals and discussions

#### Review of action items from prior meeting.

Implementation Limits? (Ben T)

4k compile limits. Some small differences with each of the engines. Compile vs validate, was different on FF. Limitation for initial size of memory -- JSC and FF enforce smaller limit as validation error.

TAG guidance on indexeddb and modules (Dan E)

#### Update on Conrad Watt's work on threads proposal

Conrad watt presenting: https://drive.google.com/open?id=1JZF_PP6OmkpTMSDAvJjDp_HDL9kDuV_Y

Bounds checks: basing decisions on GH issues. Seq Cst ordering, everything appears atomically. Not particularly onerous. Some knock-on effects. JS already does this. JS length of ArrayBuffer is fixed. In JS bounds check can be operational, w/ wasm memory is changing, affects consistency. So values that trap/not trap based on length can affect model.

Pretend grow memory does atomic write, and other operations do atomic read of memory length. Non-atomic accesses have to do seq cst synchronizations, but only for length.

[Some zoom presenting slides troubles]

MM: So you can only change memory by growing, right?

CW: There is a future proposal to add memprotect, which is kind of like shrinking memory.

MM: The memory protect thing… about that?

CW: On the agenda is a link to a PR that describes how to fix instantiation in the presence of memprotect. The only question is whether people are happy about what it should do.

MM: Are there design choices there that are not clear?

CW: Adding memory protect invalidates some assumptions that are made, guarantees that you can make. Not sure if this should block memory.protect.

MM: Given mem protect, are the design choices forced on the memory model? Or are there open questions that we should discuss in the future.

CW: I think the model will make sense, JF reminded me to take memory.protect into account.

MM: The choices are forced.

CW: Forced sounds negative, meant to be intuitive :-)

Other memory model issues: WASM wait/wake needs to agree with JS wait/wake, but JS spec had a mistake/bug. Got consensus on a fix at March TC39.

Current spec for host environment doesn’t work with threads, a host function runs all in one step but other threads need to be able to observe intermediate stages. Specify host as an abstract machine?

#### Update on Layer 1 Compression (Katelyn Gadd)

Postponed because KG isn’t here [BS: this was my fault, I accidentally wrote the wrong date on the CG meeting announcement]

#### Discuss module serialization via indexeddb in v1 spec (Derek Schuff/Luke Wagner)

Derek: originally we decided to allow caching module storage in indexeddb explicitly.

The other option is to allow implicit caching when you using instantiateStreaming.

AFAIK, Mozilla is the only implementor [Actually, Edge implements it too]. We haven’t sent it to the WG because of implementation status.

We’ve been discussing module caching in v8. We and others have started implementing baseline compilers, which makes this less valuable.

Luke has suggested unshipping this feature, because it may be less useful, less valuable, and not implemented. Some other issues w/ double keying.

On the Chrome side we’ve started implementing implicit caching which we’re going to be doing regardless.

Propose that we remove -- actually not in the WG spec, so actually just removing from the plan.

JP: Is that unrelated to postMessage of module to worker?

DS: Yes…

JP: I thought structured cloning and storing in indexeddb is the same thing as far as the spec is concerned.

DS: It’s kind of different… the module in a way represents the compiled module and the module bytes. Part of the problem is that w/ baseline compilers and tiering, if you compile the module the VM does something, but you don’t know what it has done yet. On Chakra may have done nothing yet. You really want to store the actual compiled code. Some VMs will specialize the module to the instance, so may be worse if cloned.

We’ll still want postMessage -- we need more spec work so we can allow postMessage to worker. Have the same problem potentially w/ workers though.

JP: Hoping to figure out (using iframes), if wasm ever becomes prolific, problem w/ big standard libraries on each website (like jquery). In this case it might be worse since the libraries are large. CDN usage would be a pretty important thing. There doesn’t seem to be a way for a CDN to cache its module. How can we solve this?

DS: IDB is nice in that it is explicit and reliable, we need some way to provide that to developers. One way we could do that is with the cache API. 

JP: Is that service workers?

DS: It is spec’d by service worker spec, but it can be used outside the service worker. That was one of the original objections to adding serialization to IDB. 2 years ago, we thought it would be simpler to implement this in IDB, but perhaps we were wrong. The cache API will likely make this easier. The capabilities that IDB caching allows will be valuable, we just need a new mechanism.

DS: Any thoughts from apple/MS people?

MH: Curious about speccing this, since it was just structured clone. Happy to see it gone though :-)

BT: TAG review about the postMessage API. There was a spec repo pull request from Dan that we need to look into.

[chair accidentally started meeting incorrectly, so it started a “free” meeting. The VC meeting ended abruptly as a result]

### Closure
"
stack/2021/sg-3-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 22nd video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  March 22nd, 16:00-17:00 UTC ( March 22nd, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Arjun Guha
Ioanna Dimitriou
Thomas Lively
KC Sivaramakrishnan
Thibaud Michaud
Lars Hansen
Daan Leijen
Adam Klein
Luke Wagner
Luke Imhoff
Rick Battagline
Zhi An Ng
Sam Lindley
Zalim Bashorov
Paul Dworzanski
Daniel Hillerström
Paul Schoenfelder
Ross Tate

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. [Effect Handlers in C/C++](presentations/wasm-libh.html) (Daan Leijen)
1. Next meeting [2 mins].
1. Closure

## Meeting Notes

### Adoption of the agenda

### Discussion:

FM: Can you explain why you don’t need color?

DL: Normally in C#/C++ you get a different type for functions that use async/await. The compiler transforms the function into a state-machine-like object. Need special primitives to compose them, like yield* in JS. In contrast, this work has no special types because it captures the stack up to the handler at run time rather than using a compiler transformation.

FM: For Wasm, the issue is that we are connected to JS. On the Web, we are required to not permit JS to coroutine.

DL: Yes, that would need something slightly different for interoperability. Question for Wasm, what is the right level this abstraction should be? At high level, there is effect handlers, there is lots of language design there, like masking, tail resumption stuff, finally handlers, etc. You can get a little lower, the #1359 proposal, the minimal resumable exceptions part of effect handlers, you can go even lower than that, multi prompt delimited control, used by the c library i have, it’s a low level interface. This is the primitive that does the magic, then put effect handlers on top of it quite easily. For Wasm, there might be something here that is the best, still needs discussion. Feel that this one is the lowest thing possible.

AG: there are lower level primitives, right, you can do ??? delimited control.

DL: if you go more down, you’re manipulating stacks and addresses and long jumps, those are also primitives, used to implement this at some point, my argument is that, that will be great to hide, for a portable abstraction. I imagine that Wasm will have abstraction at a higher level, and internally it will use multi-prompt delimited control. That will be an abstraction Wasm engines use internally.

RT: in your paper you talk about tail resumption, are you talking about that at all?

DL: not yet, maybe we can spend time at the end to talk about it more

RT: i bring it up because your paper shows 100x by optimizing for tail resumption

DL: yes, we have benchmarks that shows that, that will be an important part of an eventual Wasm proposal.

<Back to slides title “Multi-prompt is Well-Typed”>

SL: Do you know how multi-core OCaml avoids this hot-split problem?

KC: we use relocatable split stacks, you double the space and reallocate it, we can move our stacks, no pointers into it, don’t have that problem.

SL: if you don’t want hot splits, reallocate, but you need more space

RT: why does it require switch to stack

PS: ensure stack remains stable, keep the original c stack

RT: general case, what about for concrete case, like sin

DL: need to mark you functions, say some c functions are safe to call. Even with sin it is tricky, you need to know what size stack you want. E.g. if i am at the end of my stack, most functions have a prologue to check size of stack, but sin might not, so you need to check before calling it, otherwise will run out of space. Can be done, people go to lengths to do it. E.g. Haskell, you can mark c functions to be callable on green threads, before calling they will ensure there is a reasonable amount of stack space. Think it is solvable, but everything has drawbacks. If you have a GC, you might be okay that addresses are movable, but it also be not okay.

<Back to slides titled “Fragment Stacks(“fstacks”) (used by libhandler)”>

SL: the benchmarks you were doing, that was for counters, just implementing state, that’s not an example that you need to use an effect handler for

DL: It’s just overstressing the overhead of switching. Real async IO examples, for example, would be dominated by the IO overhead instead. Maybe for a tiny generator this would be more important.

PS: runtime has to switch between many different processes, the overhead has big impact on performance of program. It’s nice to know that performance of this is good.

SL: nice to have benchmark that is more in that spirit. You can even implement green threads here

LI: if we have an example, we can translate our test from lumen into this. Do we know why the Haskell one is fast?

DL: quite a fluke, there is also another library. It’s all monadic, compiler can fuse the handler, and removes overhead.

AG: C code is compelling, that’s how we get Wasm code now. If you can get that to work in emscripten, then can expose this to other compilers.

PS: part of the problem is without the low level primitive to save registers and switch, there is no way to implement it properly.

AG: yea ocne you get the lower level stuff in Wasm, you can build it

DL: i have to do magic in ASM to implement the interface

PS: what is the fastest way to get a wasm runtime with these primitives, to experiment. A lot of the presentations have been very informative, but we have to start an actual implementation in practice, how it integrates with JS. We will need an implementation in some runtime, maybe a playground. What are our thoughts on moving forward?

FM: on a lot of people’s minds, parallel tracks in this direction, we can cover in later discussions.

DL: hoping libmprompt can help with that. You can link your c program and you get these primitives, and can be used by wasm runtime to get it as it is.

LW: you can take c lib and link against the code you’re using to build lumen, and run it natively. And see what performance is. Wouldn’t be too far off from native engine.

PS: we essentially do something like this for native target. We know it works well for erlang programs. But for integrating with Web, esp JS, that gets interesting. We want to build for Wasm but with primitives here, so I can generate Wasm that uses these primitives, and see how it integrates with JS. A lot of the Wasm semantics we have to work, from JS it all looks like async code, not sure how that integration happens. Is that done by Wasm runtime? Or handled by of generating Wasm.




### Adjourn

"
main/2022/CG-09-27.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 27th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: September 27th, 4pm-5pm UTC (September 27th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
  1. Update on Stack Switching (Francis McCabe) [1Hr]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees

* Daniel Hillerström
* Yuri Iozzelli
* Conrad Watt
* Derek Schuff
* Rick Battagline
* Sean Jensen-Grey
* Benjamin Titzer
* Francis McCabe
* Sam Lindley
* Nick Fitzgerald
* Paolo Severini
* Ilya Rezvov
* Chris Woods
* Ross Tate
* Emanuel Ziegler
* Alex Crichton
* Alon Zakai
* Chris Woods
* Steven Prine
* Thomas Lively
* Justin Michaud
* Ashley Nelson
* Andrew Brown
* Adam Klein
* Slava Kuzmich
* Luke Wagner
* Asumu Takikawa
* Manos Koukoutos
* Mossaka (Joe)
* Matthias Liedtke
* Brendan Dahl
* Sean Westfall
* Richard Winterton
* Petr Penzin
* Krisztian Gacsal
* Andrew Brown
* Zalim Bashorov
* Dmitry
* Kevin Moore
* David Piepgrass
* Shravan Narayan

### Update on Stack Switching (Francis McCabe) [1Hr]

FM Presenting [slides](https://docs.google.com/presentation/d/1HNKDujTXMiDe0pJsrEU2Elvq8nVl10TDbMfY2gNEL1Y/edit?usp=sharing).

SL: Point out that you’re presenting one particular proposal, there’s two proposals active - one of them is called typed continuations, and has some prototype implementations, this is not the only proposal in flight. 

FM: I’ll be addressing that at the end of the presentation.

<list of languages the stack subgroup talked to>

RT: One other team that’s been very involved - the Erlang team. They were helpful with informing the usage model, which is switching is immediate, or the yielding is voluntary and the target is determined by running a scheduling function on the current stack.

SL (chat): The typed continuations proposal was deliberately designed to avoid the need for GC

BT (chat): IIRC implementing a generator with the typed continuation proposal requires creating garbage?

SL (chat): I don't think so... but some form of reference counting is needed.

RT: One useful aspect of that is, similar to WasmK, you can have a table that’s just a fiber reference table, so it becomes simpler for applications

RT: For those interested, I can walk through how to implement this without boxing

<Slide: Compared to typed continuations>

FM: Typed continuations is another approach for this, a sort of functional-programming way

SL: IMO typed continuations have nothing to do with functions and make sense in an imperative setting as well.

CW: You mentioned in an earlier slide, Source languages want to optimize for many suspension points that are not used. When you talk about GC pressure is it per suspension point? 

FM: In the fibers model the GC pressure is per prompt point, potential suspension point. With continuations every time you suspend you have additional allocation independent of that. IN both cases you have places you might suspend to and places you actually suspend. You have potential pressure in both places, but in typed continuations you get allocation when you suspend.

SL: Could you explain what you mean by not compatible with uniform representations?

FM: For generic representations, you have a pointer for each generic value
RT: the bullet point means that the fix to reducing the GC pressure isn’t compatible with uniform representation. E.g similarly with anyref, the fix is to have wide references, but that’s not compatible with uniform either

CW: We decided to split out Funcs, to support non-uniform representations, so this seems to be compatible with that

SL: I think there are other solutions to this, we should discuss more offline.

CW: It seems to me that the extent to which handlers are identified statically/dynamically seem uniform across the proposals, at least at a per-frame level. In what way is typed continuations more dynamic?

FM: the fiber proposal isn’t dynamically scoped at all. When you suspend, you suspend a particular fiber and there’s one “hop”, the resume parent  (the last resumer of the fiber) must have a handler for the suspension so there’s no search. With dynamically scoped continuations you have to do an EH-style walk up the stack to find the handler. 
Sam will say that there’s a variation in typed continuations where you can label the handler in an analogous way, but there’s other issues: unwanted capture is one. It also makes it difficult when you’re crossing components/ownership boundaries you have to do a lot of work to make sure that the other component outside your ownership doesn't have access to your scope, it’s a problem with “ambient capability”

SL: Whether you use dynamic scoping or not is completely orthogonal to whether you use typed continuations or the Fiber based model.

FM: that’s true

RT: It’s a signal of a nice reusable thing. The only thing we don’t support is multi-shot continuations. Everything else we support the same way they would have done natively.

FM: The potential benefits of implementing multi-shot continuations doesn’t justify the investment at this time

BT: A vote doesn’t seem to be the right way to resolve this, are there other objective other criteria that we can resolve here? 

SL: I don’t think we’re ready for a vote anyway, we need to resolve certain technical issues.

CW: my only comment given how this presentation has gone, it’s not enough just to say that one proposal satisfies the stakeholder needs, we need to compare them directly

SL: Viewing as two competing proposals is not helpful, we should explore this as a design discussion, and explore the problem space - it’s more a question of what are the features that are most important to have. The other thing we’re doing that i think will be helpful is that we’re implementing typed continuations in wasmtime. Then we can do some experiments and benchmarks and get some evidence to show what works better rather than hand waving. But that won’t happen immediately. So I'd suggest it would be better to make a bit more progress on that before deciding and committing.

DP (chat): I ♥ stack switching

LW (chat): I'd also like to see the two proposals to converge

BT (chat): +1, especially in terms of terminology and naming

NF (chat): +1

FM: I’m happy that SL mentioned that they’re not that far apart, there are definitely qualitatively different to get over. As far as the vote has concerned, it may slightly seem premature to move to a vote soon. However the engineering resources devoting to this, and it risks going away if we lose momentum, that’s the biggest risk.

"
stack/2021/sg-8-23.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 23rd video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  August 23rd, 16:00-17:00 UTC ( August 23rd, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
- Francis McCabe
- Daniel Hillerström
- Sam Lindley
- Ryan Hunt
- Ben Titzer
- Alon Zakai
- Elle Imhoff
- Rick Battagline
- Derek Schuff
- Sam Clegg
- Zalim Bashorov
- Luke Wagner
- Adam Klein
- Thomas Lively
- Zhi An Ng



## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. Switchable Stacks & V8 (Francis McCabe) ([slides](https://docs.google.com/presentation/d/1oYzhndtUQXLRe28FGu7JkhMCe4j_yDvo8x-60sdJ-_4/edit?usp=sharing))
   3. Next meeting [2 mins].
1. Closure

## Meeting Notes


### Adoption of the agenda

### Discussion:

#### Stack Switching & V8 by Francis McCabe

FM: One motivation to share is that I’d like to encourage a second implementation as soon as possible.

SL: Why only desktop Linux? What about Mac as well?

FM: Mac more constrained, Windows even more so, in terms of memory

BT (chat): Are native (C/C++) frames stored inside stack segments?

FM: will come back to it, in short: probably. Thought about it, but not sure what the final result will be.

EI: re: arch specific registers, does that mean that currently V8 is targeting Intel's and ARM's way of doing it?

FM: yes

EI: see a similar issue with stdlib with rust, it uses a lot of stack space, actual erlang can use 4k stack, but when we hit dashmap, it blows up stack, so we have to keep our stack much larger.

FM: yea, if you have a million of these stacks, it's a lot of wasted memory

SL: are you envisioning deliberately forgetting stacks? We have that in Wasm typed continuations design (cont.throw). Distinguishing between forgetting on purpose or accidentally

FM: more concerned with accidentally - memory leaks

EI: how does that work with JS async await? are those globals?

FM: if you register with some IO event, it is effectively part of global, not actually, but conceptually

EI: any plans to allow stack size to be set when you jump to a new stack? In Erlang it's process memory size, both heap and stack. You pre-size it so you never hit a GC or allocate new segment. Do you think that will be opened up so that you won't hit perf cliffs? Say upfront how much space you need?

FM: thought about it, but can't see how this will work. If you have a Wasm instruction for forking a new computation, and has a number for estimated size, what are the units for it, what does it mean? In terms of actual instructions, can't see this happening. If there are hints in the custom section, then there can be a way of doing that, as an optional part.

EI: Won't work for our use-case. Users of Erlang/Elixir specify the size. Custom section won't work for us.

FM: can't see specifying this in a useful way without a lot of spec machinery. This will also be different on different platform. Strategy on Android device will be different from a big server. Hard to imagine a single piece of information being useful in all those scenarios.

BT: C/C++ frames in stack segments. If they are, then it is impossible to move the stack segments. You designed moving stack segments out.

FM: you still won't be able to move them, due to Control Flow Integrity

BT: that's unfortunate

EI: for Erlang, we can move frames, it's a single process memory, compacting GC, will be ok moving our frames in theory.

FM: if you have a return address or stack pointer or stack reference, you basically can't and be consistent with CFI. Pointer signing means that the value stored on the shadow stack is an entanglement of the current value of the stack pointer, and value you are storing. Relies on 64 bit memory have at least 8 bits that no one is using at the moment. The 64 bit value stored in memory, contains the pointer you want to store, and hash of the current value of stack pointer. If you move that value around, if you pick it up, the stack pointer will be different, the signing will fail.

SL: That will also be a problem in this Erlang setting, if you were concerned about CFI.

FM: if they put return addresses in stack. CFI is a new thing, new generation of hardware has it, most people have not enabled it. Chrome has or is about to enable it. In principle, we can say we are not supporting CFI, but you get a headline in some blog somewhere that says Wasm is insecure by design, which we don't want.

BT: you mentioned you'll need to resign some things

FM: if you go back to the stack overflow scenario, ""Function Call Across Stacks"" slide. We move spill from old stack to new stack as part of the special function call. One way to ameliorate the perf cliff is to not just move the most recent frame, but to move the previous frame as well. That would involve resigning the previous fp and contents of previous frame. If you have a stack overflow for a particular function call, it will only happen once.

BT: if you can resign by copying one frame, you can copy and move stacks, will require resigning all the return address.

FM: yes, that's possible, an option in our back pocket. Unknown unknown here. Don't know if we can do one frame, let alone all of them.

EI: how are you testing that stack switching works? are you making up instructions to test it?

FM: we are going ahead with JS API promise integration. That will exercise a lot of this, including the overflow. That plus unittests in various places. We can test a lot of this without adding anything to Wasm.

EI: re debugging, if one of you implementor open devtools, it will happen if it happens?

FM: it needs more resources than I can put on this project at the moment.

SL: any significant concerns about design you have considered and discarded

FM: virtual memory for stack management, that has been discarded. Were going down that road, but got feedback that we don't have much address space.

SL: that's even considering that you're initially focussing on Intel 64-bit Linux

FM: over the horizon but only just, we knew that we needed to do something for 32-bit arch, what changed for us was that we had to do this for 64-bit arch as well.

BT: do you know the fudge factor is?

FM: about 4k, unsure. Quite hard to find. Another design we looked at was switching to main stack for calls to imports. Getting that right would destroy our overall arch. may end up doing that, but getting details of it right was difficult. We felt that we didn't need to.

### Adjourn

"
wasi/2022/WASI-11-03.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: November 3 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: November 3, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Worlds in SpiderLightning interfaces (wasi-kv-store, wasi-pubsub, etc.) - Jiaxiao (Joe) Zhou
    2. SQL Embedding - Kyle Brown

    ## Notes 11-03
### Attendees
Joel Dice
Pat Hickey
Jeff Charles
Michael Yuan
Dan Gohman
Bailey Hayes
Kevin Hoffman
Sam Clegg
Mossaka (Jiaxiao Zhou)
Yong
Marcin Kolny
Piotr Sikora
Brian Hardock
Luke Wagner
Kyle B
Valery Antopol
Steve Schoettler
Kevin Moore
Ralph Squillace
Dan Chiarlone
Hung-Ying Tai
Andrew Brown
Johannes Becker


### Worlds in SpiderLightning interfaces (wasi-kv-store, wasi-pubsub, etc.) - Jiaxiao (Joe) Zhou
 
Mossaka: SpiderLightling is a set of capability interfaces designed to make distributed applications portable across hosting providers. There are many interfaces but today we will focus on `wasi-kv-store`. A kv store is like a hashmap/dictionary: it stores key-value pairs efficiently. Values have limited datatypes (often json) and are schemaless. <a discussion of consistency>. <a discussion of transactions>. 
Mossaka: now lets go into the interfaces. Here is an interface for non-transactional data stores, the operations are get, set, del, and exists. Here are the common type definitions for kv: Error is a resource, payload is a resource that can be consumed synchronously or asynchronously (list of u8 or stream of u8). Key is just a string, and keys are a stream of key. 
 
Joel Dice: your interface is using resources and async, do we need to wait on this proposal until those are in wit?
 
Mossaka: We can get rid of async for now, this is part of why I made payload a resource type so we can just implement the sync part for now. Set value would be a list of u8 instead of a stream of u8.
 
Mossaka: Many datastores do not fully support transactions but they do support single-object transactions, often called atomic. I have an interface called `kv/data/atomic` which has a single function `incr: func(key: key) -> result<u64, Error>` Often time to leave is a useful feature, so here is a `kv/data/ttl` with a func `set-with-ttl: func(key, value, ttl: u64) -> result<_, Error>`. So now we have four interfaces total that are the non-transactional interfaces.
 
Mossaka: for transactional interfaces, there are distinct read-transactional and write-transactional interfaces, because some databases are only read-transactional. <more in-depth description of slides>. There is a query interface as well, for scanning across the whole set of keys.
 
Bailey: It is not obvious that these interfaces are transactional - will users know this has transactional behavior or do users need a higher level interface? The transactional part of this interface is a lot trickier so maybe it is better off being separate.
 
Kevin: My concern is that there are many possible implementations of these transactional interfaces and they will have different amounts of transactionality. I don’t know what bulk is supposed to do without going to read documentation on the interface. The guarantee or lack of guarantee around transactions needs to be explicit in the interface.
 
Joel: Compare and set are valuable to define different atomics, you can build mutexes
 
Mossaka: Someone asked about etags in the chat. The payload resource could have additional operations to describe the version of the value.
 
Dan: Time check
 
Mossaka: Now lets talk about worlds. Here is a world that imports kv with crud operations, and exports an http handler. Then there is a world for cloud services, it imports kv and mq and etc, and exports an http handler.
 
Colin Murphy: Interfaces between kv stores, across the ecosystem, are very inconsistent. The kv interface for dynamodb is way different from the one wasmcloud exposes, so I actually switched to using the sql interface to dynamodb. This interface would work for <missed> and redis, and thats about it
 
Mossaka: <notetaker missed this answer>

Ralph: I think the Key-Value plus Transactions portion needs more thought before it's settled. And usage will tell us a lot there.
 
Kevin: A worlds part of the standard?

Dan: The world construct is being developed to be standardized in the component model.

Kevin: Is the set of Worlds to be fixed?

Dan: WASI will define some standard Worlds, but embedders can also define and use their own derived or even fully-custom worlds.

Colin: Interfaces feel like lenses/windows/views. If you hide dynamodb behind a key-value ""lens"", then you can only see/interact with the key-value shaped surface area. OrientDB is a great example of this, where you can interact with graph features in one mode or relational in another. Some databases will fit with wide utilization into a key-value interface (redis), whereas others might be shoehorned (dynamo).
 
### SQL Embedding - Kyle Brown
 
Kyle: There is another side of the SQL coin, how to use wasm in SQL rather than using SQL in wasm. Function-like embeddings: a user-defined function defined as a wasm component, you can use it when selecting things in a where predicate. User defined functions are scalar functions (no side effects). User defined aggregate functions accumulate inputs from many rows into one output. Table valued functions: function whose output is a table (example: calendar_for_year(). Type mapping: users are not always required to specify SQL types, so there needs to be a component value type to sql type mapping. This proposal has a table: for example i64 maps to sql bigint. We could also have a set of allowable mappings, for example float32 can map to either sql float or double, float64 can only map to sql double. Sql doesnt have a concept of result or error values, we don’t know how to map that exactly, you could treat an error as ending query execution but that is a little brittle. Sql provides types without a component equivalent, most basic being dates, also custom types. We could parse a string as a date using an iso standard, or take a record with the fields, we need some explicit type mapping.
 
Kyle: bundling sql functionality: users will want to contain one component with multiple UDF, UDAF, and TVFs, as a library of SQL functionality. We propose to use custom sections to describe how a function export maps to sql land, for example treat this function as a UDF with the following name in sql. UDAFs have multiple different functions in it, so we would annotate each of them with the same UDAF name to treat multiple exports as a single UDAF.

Mossaka: I wonder how `resource` type would map to SQL type?

Ralph: We're going to learn where this boundary lies.
"
gc/2020/GC-12-01.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 1st video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: December 1st, 5pm-6pm UTC (December 1st, 9am-10am Pacific Standard Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Presentation: Type checking with multiple upper bounds (Ross Tate)
1. Closure

## Meeting Notes

### Introduction of attendees

Thomas Lively
Slava Kuzmich
Zalim Bashorov
Tim Steenvoorden
Francis McCabe 
Conrad Watt
Lars Hansen
Keith Miller
Ross Tate
Luke Wagner
Jakob Kummerow
Emanuel Ziegler
Rick Battagline
Ryan Hunt
Andreas Rossberg
Adam Klein
JP Sugarbroad
Daniel Ehrenberg


### Presentation: Type checking with multiple upper bounds (Ross Tate)

Slides for Exponential Non-Determinism: [(pdf)](presentations/2020-12-01-tate-exponential-nondeterminism.pdf) [(pptx)](2020-12-01-tate-exponential-nondeterminism.pptx)

<RT presenting>

AR: Clarification: The current MVP is not NP-hard. This is assuming some additions to the MVP.

CW: Specifically the addition is multiple upper bounds BT needed, which we probably can’t have as a result of this.

RT: Maybe. Conclusions will come later. It’s important that we are able to recognize these np-hard patterns when they come up because they are common.

<back to slides>

TL: So essentially each vertex could be either red, green, or blue

RT: Yes.

JP: I see, there’s no principle type for struct.get because the first field is never named.

<back to slides>

TL: non-determinism in this case means there are choices to make, not necessarily that the search algorithm is non-deterministic.

RT: Right.

TL: Does that mean you always need a principle type so there are no choices?

RT: That’s one solution, but it has its own drawbacks.

FM: Is the `pick` important? Would this work with `rotate`?
RT: <describes a similar setup using rotate> It seems that having non-linear types is important, but WebAssembly will certainly have many non-linear types.

Slides for Determinizing Fields: [(pdf)](presentations/2020-12-01-tate-determinizing-fields.pdf) [(pptx)](2020-12-01-tate-determinizing-fields.pptx)

RT: Some systems specify a particular typing algorithm, but I’m assuming we want to specify declarative typing rules instead.

JP: Shouldn’t one of these types be a union?

RT: No, this depends on some type sensitivity in the Ceylon semantics that I won’t bother elaborating on here. There is a more general version that uses unions…. <finds possible mistake on slide and fixes it, making claim slightly weaker>.

<back to slides>

CW: Without intersection types, if you have multiple bounds… What is the expressivity gap between intersection types and just having multiple bounds without intersection types?

RT: When you construct the generating automaton, it changes what kind of types you could generate.

CW: So there is something that intersection types could express that you couldn’t express with multiple subtype bounds.

LW: With intersection types, the various bounds can be completely unrelated. Otherwise they would have to be compatible.

AR: I wonder how Steven Goldman’s work is related? In practice, you can often calculate the type. Various cases don’t come up.

RT: Looking at the practice of type systems is useful because it can tell you how to patch the system to remove bad algorithmics. Second issue is that at present I don’t know of any system that can fix this for low-level structural typing. I believe the work you’re referring to is for surface-level structural types, which look very different. Two questions: 1) is there a way to patch the system to make it efficiently decidable, 2) is that restriction practical. Right now we’re depending on our intuition for (2).

<back to slides>

FM: Is ITalX is the dominant type the same as the polarity AR was talking about?

RT: No, it’s because there is a concrete class hierarchy tree.

<back to slides>

CW: Let’s imagine that as a result of these issues, we don’t add support for multiple upper bounds for many years. What would we lose as a result? For the post-MVP we’ll have lots of opportunities to think about different options and interactions.

RT: Well you wouldn’t be able to do BT’s Jawa system.

AR: There are also other things we would need to add to make Jawa work anyway. One early question we had was whether WebAssembly should have subsumption. Making upcasts explicit might help.

RT: Multiple upper bounds would make the MVP’s subtype relation PSPACE-hard. You couldn’t solve the problem with explicit subsumption (i.e. explicit upcasting) because subsumption itself would be PSPACE-hard.

AR: Not sure I understand how that could be the case. If we put in an upcast instruction....

RT: Even answering the question of whether two types are in a subtype relation would be PSPACE-hard, so type checking the upcast would be PSPACE-hard.

JP: You could have casts only do one step, so to go up multiple steps you need to chain them, so the checker doesn’t have to do a search.

AR: I’m not sure we need multiple structural upper bounds in the first place. Enforcing that some bounds are abstract would prevent merging modules, which is no good. Perhaps tracking which types are nominal or structural and ensuring that only nominal types are used as upper bounds or something like that would work.

RT: For user-level casts, you often introduce new structural upper bounds.

CW: That’s very hypothetical since we aren’t doing user-level types.

RT: The most conservative thing would be to allow bounds to be categorized into funcref, dataref, etc. but without any more interesting structure.

FM: Ross said at the beginning that we shouldn’t rely on an algorithm. In related field description logic, simple logics are decidable but also not very useful. Various attempts to increase expressiveness have all resulted in non-decidability, so the field accepts that.

AR: For Wasm you want to be deterministic in the programs you allow.

FM: That’s why you would specify the algorithm.

AR: There is a spectrum between nice systems and ad hoc algorithms. Advantage of staying declarative is that proofs and composition properties are easier. Also provides a clearer picture of interactions with various extensions. May be hard to extend algorithms with new features without breaking existing programs.

RT: Can make program transformations in tooling very sensitive to whether they break the algorithm, even if they’re otherwise obviously correct.

AR: Algorithmic semantics can be seductive.

FM: The logicians have a dual semantics as well. So the declarative semantics wouldn’t be thrown out. I mildly suggest we consider having an incomplete system that rejects some correct programs.

AR: Unclear how that would work out in practice.

RT: We should probably have a WebAssembly-wide discussion about whether we want our type system to be decidable and then whether we want it to be polynomial. It would be good to get consensus on that and add it to the requirements.
"
gc/2022/GC-11-01.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 1 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: November 1, 4pm-5pm UTC (November 1, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Taking stock of remaining issues
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Rick Battagline
- Justin Michaud
- Igor Iakovlev
- Francis McCabe
- Aske Simon Christensen
- Slava Kuzmich
- Ilya Rezvov
- Asumu Takikawa
- dbezhetskov
- Alon Zakai
- Adam Klein
- Zalim Bashorov
- Luke Wagner
- Ryan Hunt
- Yulia Startsev
- Deepti Gandluri
- Conrad Watt

### Discussion: Taking stock of remaining issues

CW: Want to redo br_on_null to make it more consistent - make it propagate null in label

ASC: br_on_non_null: it would be inconvenient to preserve the null. For br_on_null, it’s the other way around, used for null lifting operations. 

CW: We can keep br_on_non_null as not propagating the null because the spec can just describe its behaviour in terms of an extra a drop instruction. Sounds like it’s neutral or slightly helpful to change br_on_null?

ASC: lots of different patterns involved - had to say immediately

RH: Lots of GitHub issues, hard to understand current state.

TL: Agree, we should go through and close more issues.

RH: Lots of big idea issues as well.

TL: Maybe we can close and suggest making a PR to the post-MVP doc.

DG: Can also use labels.

RH: Phase 4 should be blocked on i31 discussion.

TL: Asked OCaml folks for update, can follow up if they don’t respond.

FM: Other uses of i31 as well. ADTs and small number types in functional languages with uniform representation.

TL: If we added Aske’s proposed instructions to MVP, could we use i31 for small integer optimizations in Dart, etc in MVP?

ASC: Full benefit would require union type for sharpening and merging of results. In absence of union type, there would be some extra casts. New instructions would help code size a lot, though.

TL: Would we still see mixed performance or would performance become strictly better?

ASC: Some of the overhead could be eliminated by a more extensive analyses to remove boxing and unboxing. The casts are difficult to avoid because of type system expressivity.

TL: Sounds like this might work to motivate i31 in the MVP, but it’s not a slam dunk. Ryan, what would the bar be for supporting i31 in the MVP if OCaml is using it for multiple things but other languages aren’t?

RH: Would have to think about it more, but my initial impression is that it would be unfortunate if i31 were not used for multiple languages.

FM: Follow-up question: What features for OO languages have not been proposed or included?

RH: Things about method dispatch. A self type, vtables, etc.

FM: Supporting these languages is important. 

CW: method dispatch will be important for post-MVP. There’s a whole package of stuff like self types, type parameters, explicit rtts, or alternatively questions of how to do vtables language-agnostically. Will be high priority post-MVP.

RH: For i31 ref, it’s mostly a timing question. Not trying to kill i31ref, but want it to be properly motivated. Deferring things does delay the MVP, so it’s not something we can do for free. Mostly want to keep momentum up.

ASC: I could also do some more benchmarking, for example with branch-and-convert instructions to see what difference it makes.

CW: I’ll make an issue on br_on_null and tag you on that.

ASC: I just looked at that in dart2wasm. None of them have to rematerialize the null. If it was preserved, it would just be extra drop instructions.

CW: Ah sad.

LW (chat): seeing concrete wins from i32ref for Dart (which would be actually shippable) would be pretty compelling evidence of MVP utility, i'd think

CW: I remember there was a firm belief that we were not going to have subtyping in call_indirect for the MVP. Has anything new come up that makes us believe we need it?

RH: Not that I know of. I think there’s some belief that the subtype check can be made a non-issue. Mostly just for symmetry, not language need.

ASC: Might be able to use it in Dart in some places. But benefit probably not significant.

TL: I’m flexible on this. Would be nice for symmetry if there are no downsides, but if any problems crop up I would be ok not including this in the MVP.

RH: (Details of how this could be performantly implemented) Is the subtyping check too slow to be practical? Don’t know yet. I would prefer not to add it until we have data.

ASC: If exact match case is as fast as otherwise, we should include it, but if there is any slowdown, we should keep it out.

FM: Meta-point, we shouldn’t depend on people complaining to figure out what to do.

CW: Folks have been switching between both, so it would be good to be uniform.

RH: One missing set of issues here is about binary size. Will we do a pass to try to minimize binary size?

TL: Planning to redo opcodes, but not aware of any plans to reduce code size specifically. Could move instructions to non-prefixed space if necessary.

CW: Savings in type definitions seem less important from numbers. Savings in the code section seem much more important. Could we do get-and-cast to save size?

TL: Would want Andreas to be present for a discussion of how much we are willing to add such macro instructions. Then we could look for specific patterns.

LW: Opcode renumbering is basically the same as what brotli does already.

CW: Does it find macros where indices can change?

ASC: Could also change things to make binary more easily compressible.

AZ: Text format?

TL: Yes, had to make up my own abbreviations when writing new parser.

RH: Also had to make up abbreviations.

TL: Will take an AI to start an issue about this.

CW: Also finish conversation about whether rec groups are size one are the same as non-rec-group types.

RH: Also differing limits number of recursion groups and types in a recursion group and types overall. I implemented this to check total limit as we were parsing types.

LW: Any depth limits?

TL: No nested groups, so no issues.

ASC: Maybe include number of total types before vector of recursion groups as well?

TL: Sure, worth discussing.

CW: It’s nice to be discussing such small issues.
"
main/2022/CG-12-20.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 20th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: December 20th, 5pm-6pm UTC (December 20th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Phase 1 poll: [alternate floating-point rounding mode instructions](https://github.com/WebAssembly/design/issues/1456) (Kloud Koder)[20 mins]
3. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees

- Thomas Lively
- Derek Schuff
- Kloud Koder
- Dan Gohman
- Ilya Rezvov
- Slava Kuzmich
- Chris Woods
- Ryan Hunt
- Heejin Ahn
- kevmoo
- Matthias Liedtke
- Brendan Dahl
- Zalim Bashorov
- Benjamin Titzer
- David Piepgrass
- Petr Penzn
- Andrew Brown

### Notes

#### Phase 1 poll: [alternate floating-point rounding mode instructions](https://github.com/WebAssembly/design/issues/1456)

KK: I’ve been advocating for interval arithmetic primitives because 15 years ago I learned the importance of interval arithmetic for mechanical engineering and software engineering. I assumed it would go mainstream because of how important it is for safety in engineering, but it hasn’t. As I realized all the problems of implementation of rounding modes, I figured it wasn’t going to just happen itself, so I decided to help do something about it. There’s an interval arithmetic library in Rust, and its authors have agreed to implement it in wasm, so thanks to them for their help too.

KK presenting [proposal](https://github.com/WebAssembly/design/issues/1456#issuecomment-1359657787)

KK: All of these are the same as instructions that we have, with different rounding modes. The order is the same as in the existing spec.
From the discussion, I’m proposing a separate rounding mode byte. There do exist other rounding modes (e.g. away from zero) that may appear in hardware in the future, so this leaves room for them. SIMD is not included, because unfortunately ARMv8 does not implement them.

There are also sign extraction instructions. F32.sgn just extracts the sign bit, even if it’s just a NaN. the asgn version gets the arithmetic sign, (e.g. + or -0)

We need these instructions because you would need to emulate it on every multiply or divide.

TL: Can you explain the sign extraction again, why it’s needed?

KK: This is outlined in the issue somewhere; if you do a multiply in interval arithmetic, literally the method you use, that yields the final interval has a bunch of ifs that ask about the sign of the inputs. If you have really wide SIMD you could do all the possible sign permutations and mask them off, but practically hardware doesn’t really support that. So you are asking the same thing all the time, which requires converting from float to int, and it’s expensive.

TL: Is there a more efficient hardware implementation of this than the equivalent sequenc of wasm instructions today?


KK: Intel I believe has an fsign/ftest/fextract sometthing like that, that can get the bits in ah

TL: you mentioned this Rust interval library. Do you know who their users are? Any interesting applications?

KK: don’t actually know.

DS: Any other use cases besides interval arithmetic for these alternative rounding modes?

KK: Maybe hardware vendors thought that intervals would matter, I don’t know. The other application is integer rounding. Apart from that, I don’t know.

CW: there are applications in cyber-physical control systems, and that would be of interest to us as a potential user, as a global manufacturer of lots of things, power equipment, industrial, and shop-floor stuff, etc.

TL: you’re the first large company that’s expressed interest in this proposal, do you have resources that could be put toward the development of this proposal?

CW: we do have some resources, but they’re currently committed to other parts of wasm. Obviously our use cases are outside of the browser world. WE could probably help some with e.g. validation, but most of our resources are currently allocated.

TL: just thinking about the process, I don’t see a problem going to phase 1 today. But going forward, unless the process changes we need 2 browser implementations, so browsers need to be convinced that it’s worth implementing. As a step toward that it would be useful to get real-world experience with it, even if it’s not in the browser. So e.g. if someone implemented in something like WAMR and got some real world testing (e.g. you) that could help motivate the browsers to implement even without

CW: yeah that’s something I think we could talk about directly.


DP (chat): Btw, does anyone know if, of anyone who is taking a serious interest in unums/posits (http://loyc.net/2019/unum-posits.html)?

DP: there’s a book called “the end of error that talks about unums, that discusses rounding error and getting tighter bounds than you can get with interval arithmetic. It has unum as the building block, which is better than FP number. You get ranges of results like interval arithmetic, and it gets a tighter bound around the answer by using more than 2 numbers. It’s really interesting but does need hardware support to be fast.

DS: This sounds vaguely familiar. We might have had folks suggest this for Wasm in the past. Historically the response has been that it’s one of the design goals of wasm to expose existing functionality rather than coming up with completely new primitives.

DP: Unums have a long history at this point of interesting ideas, but also of over-hyped ""this fixes everything!"" advertising and not entirely fair characterizations of IEEE 754.

PP: Missed beginning of presentation, but intel was discussed, right? I.e. the performance considerations? E.g. in Intel the rounding mode is global; if you have individual instructions and you might end up flipping the rounding mode back and forth a lot.

TL: yeah this is one of the things I think an implementation can help with, to see what the actual performance is.

PP: yeah this is also something that a compiler optimization could help with, just wondering if you’d discussed it. If someone implements this in a system without separate instructions you’d need to find a way to group them.

Vote for phase 1:

SF: 4
F: 3
N: 8
A: 0 
SA: 0

Phase 1 vote passes

BT: I think these rounding modes are great for converting integers as I mentioned on the issue. Also because this is in hardware we should find a way to expose this and there are niche uses. So the issue is just finding a good encoding

DG: I’ll also add that this has been an open question in wasm for a long time so I’m happy to see it making progress.

"
stack/2022/sg-1-24.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 24th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  January 24th, 17:00-18:00 UTC ( January 24th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Elle Imhoff
Alon Zakai
Ben Titzer
Ioanna Dimitriou
Rick Battagline
Sam Lindley
Thibaud Michaud
Ross Tate
Lars Hansen
Andreas Rossberg
Luke Wagner
Derek Schuff
Zalim Bashorov


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. [Asyncify in practice](https://kripken.github.io/talks/2022/asyncify.html#/) (Alon Zakai)

   2. Next meeting [2 mins].
1. Closure

## Meeting Notes

This meeting is recorded. Recording can be found at [Audio](https://drive.google.com/file/d/1iE6J01YhPQNVbxXxdIHD_rqj_eAgvt6x/view?usp=sharing), [Video](https://drive.google.com/file/d/1rOVoA4_dGdI_dsRkQi2ou0RIaoCmmY3S/view?usp=sharing)

[AZ presenting slides.  Notes omitted when they match text on slides]

[Slide 2]

WASM has had synchronous code since 2015.

[Slide 6]

Limitations since 2015

[Slide 8]

4 APIs calls for Asyncify

Start_unwind
`stop_unwind`
`start_rewind`
`stop_rewind`

Necessary in MVP. More recently could have used multi-memory or allocating multiple arrays.

[Slide 10]

Example does a sleep operation.  Global is checked at the beginning because the $sleep function will be re-entered on rewind.

[Slide 11]

FM: In JS promise integration if we call an import that returns a promise, your sleep function would call an external function that returns a Promise.  Then a version of the Promise is returned from $main.

AZ: We would not have the function $sleep. We would call an imported function. The runtime code would need to be in the JS side to resolve the Promise.  The code on the slide is pure WASM.

FM: You want to return from the sleepified function you need to re-enter the code.  We can take this offline.

SL: There are two calls to $main.  The first prints 1 and returns.  The second call to $main is called after the $sleep?

AZ: Exactly right.

SL: Thanks!

[Slide 12]

50% code size and speed downside.  Is acceptable for some use cases.


[Slide 13]

Asyncify does not do CPS-style transformation.  This made sense in MVP. Today with tailcalls, indirect calls may be cheaper.

[Slide 16]

Fade effects in DOOM 3 render in a loop outside of the main loop.  It is not easy to refactor. Just add a sleep there.

[Slide 19]

Asyncify originally for async/await, but now for setjmp/longjmp.

[Slide 22]
Emscripten used LLVM to transform and then JS for unwinding, but did not work in WASI that only has WASM

[Slide 23]

Ruby is using asyncify for setjmp/longjmp in WASI

[Slide 25]

Game, TinyGo, and Ruby use with 50% overhead shows the need for stackswitching.

[Slide 27]

LW: Does Ruby need conservative stack scanning.
AZ: I only know what people told me.  I did not read the code.

[Slide 28]

Asyncify API is minimal

[Slide 29]

Could stackswitching API be simple?

[Slide 30]

FM: Does it handle multiple pauses?
AZ: When you pause, it stores the position in the function.  You can swap between the stacks at runtime.

FM: Where does the 50% overhead come from?
AZ: I’d have to look at the JIT code emitted.  Register pressure seems to be because of the serialize and deserialize at the start and end of the function that keeps all the locals alive.

SL: The 50% is in the amount of code?
AZ: 50% larger and 50% slower

SL: Sounds like “Continuations from generalized stack-inspection” (https://cs.brown.edu/~sk/Publications/Papers/Published/pcmkf-cont-from-gen-stack-insp/paper.pdf)

[Also see Florian Loitsch’s work on implementing this idea in JavaScript using exceptions: https://florian.loitsch.com/publications - “Exceptional Continuations in JavaScript” + his PhD thesis]

AZ: I have never heard of that paper.
SL: In order to suspend and resume you annotate your functions.  Labeled switch statements and raise exceptions.  Sound like the same idea.
AZ: Labeled switch makes me think every statement turned into a big switch, but asyncify preserves ifs and loops.  Do they preserve loops?
SL: Yes. Includes generalization like call/cc.  It is fully general?
AZ: It seems so.  Once you can have multiple stacks and resume you can do all this.
SL: You could implement backtracking.  It’s a scary thing.
AZ: Yeah, you can get it wrong.


FM: How many instructions does a stack switch cost?  It is the depth.  For generators it is very swallow. For a yield style generator it’s not a deep tree.  You’re iterating over an array.  The call stack is quite shallow.  In that scenario, is there zero or almost zero overhead?
AZ: Yeah, but it is both how shallow and how much code that needs to be skipped over.
AR: Number of locals you need to restore.
DS: The number of calls that don’t need to be instrumented like indirect calls in C++ that can’t be proved to not be paused.

FM: For setjmp/longjmp you don’t know what functions will be called.
AZ: In LLVM we cheat.  We only let longjmp be called statically.  We don’t allow using a function pointer.  We haven’t found a program where this is a problem.
FM: That’s smart.
AZ: It’s more than the spec allows, but it works.
FM Like how eval in JS works differently when called indirectly.

FM: Can you see that you would do to asyncify to improve it?
AZ: We have a list of ideas to improve the optimizer around asyncify.  Asyncify assumes that we save the locals in one location, but having multiple sets would increase code size.  As the code gets around 50% we decided not to do this work and hope stack switching would do this.

FM: There’s a fiber API?
AZ: In emscripten using JS and the Asyncify API.

FM: Benefit you get with asyncify you can bypass WASM restriction of accessing your locals.  How important is this?
AZ: Are you asking about users?
DS: How many actually access the locals?
FM: Yeah.
DS: Emscripten it is a side-effect.  An implementation detail unless they’ve reverse engineered.
AZ: Probably not. We have scan_registers in Emscripten.  The Ruby VM does use it. [EI Ruby VM patch appears to be https://bugs.ruby-lang.org/issues/18462, which was opened 11 days ago].

AR: Not accessing WASM locals is a security concern.  Everything is in linear memory and anyone can smash stack frames. Can anything be done to make this more secure?
AZ: Could be misused.  Anyone shipping own code it’s fine.
AR: They could modify too.
DS: Depends on security model. Registers are to protect the VM.  If you can transform a WASM modules and get someone to execute it.

FM: Has anyone used Asyncify for a source-level debugger?
AZ: Not that I know.  We would need to emit a mapping.
FM: If you have a language-specific toolchain with its own debugger it could do it itself.

LH: You don’t pay attention to liveness.  You save all of them?
AZ: If it is alive at least one pause point, but a lot aren’t.

EI: Shadow stack means we have the locals exposed already.
FM: Yeah
DS: Yeah, not just for stack switching. Also for address of variables in C++.

### Adoption of the agenda

### Discussion:

### Adjourn


"
stack/2022/sg-1-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 10th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  January 10th, 16:00-17:00 UTC ( January 10th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
- Francis McCabe
- Sam Lindley
- Daniel Hillerström
- Luke Wagner
- Ben Titzer
- Adam Klein
- Rick Battegline
- Thibaud Michaud
- Lars Hansen
- Ioanna Dimitriou



## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. [Towards an ontology of stack switching](https://docs.google.com/presentation/d/1OoVTsCuQH8FMkEkhOsuZwnNkVFW_6_PFq_WEYYFOiS0/edit?usp=sharing) (Francis McCabe)

   2. Next meeting [2 mins].
1. Closure

## Meeting Notes


### Adoption of the agenda

### Discussion:

#### Towards an ontology of stack switching (Francis McCabe)

Francis McCabe (FMC) presenting slides.

- Sam Lindley (SL): Many claims, not sure I understand them all, high level, what is a resource exactly. What does it even mean, or how can you measure the claim that resources are better than a function. What is a resource? Is it an OO object?
- FMC: Aristotle talked about the representation of the thing, the thing, the effect (affordance) of the thing.
  Triangle of identity - affordance - thing
- SL: That doesn't answer my question, what are we talking about here in terms of Wasm?
- Luke Wagner (LW): Wasm things, like instances, they don't have an end. Do we care about semantically defining the lifetimes and ownerships of things? If we say that resources are things with lifetimes and ownership of other resources, they have relationships, dependencies, etc. This should be more formal, parent/child or hierarchy of ownership. So if we define resources like this, then it seems it's a way we can describe a stack or concurrent computation. So this is not so relevant to ...[missed]... design, but it's good to have the notion.
- Ben Titzer (BT): The point concerning modelling (not design) is how do we bind the things we model.
- SL: Lifetimes? Is this against having a resource as a first class value?
- LW: Not necessarily, being a first class value is not necessarily conflicting with having a lifetime.
- SL: Ok but how does this all fit concretely?
- FMC: Not trying to design at this point.
- SL: I'm not even clear what the model is.
- FMC: That's what I'm trying to get to, not trying to design here.
- SL: You have a model though, right?
- FMC: The way I think about it is trying to establish terminology around this concept.
- LW: For example threads, a task that is like a stack, in GC we have an overall computation/task with possibly many spawned processes. Can we describe this in terms of resources with lifetimes? It's one stack that's growing and shrinking but one overall task.
- BT: Do we need to make these stacks really small, if we want them used heavily? They are like events happenning in the lifetime of a stack. ...[missed]...
- SL: I would like to see an example showing the benefits concretely.
- FMC: It would be good to have identity for stacks.
- SL: In Andreas's spec there is an identity for continuations.
- FMC: The notion of a task is closer to a POSIX thread. It has a persistent identity, which doesn't change.
- SL: So you're saying that if we naivly create a new identity every time we need a resource, then it would be better if we had a notion of a task?
- ...[missed discussion]...
- SL: What my question boils down to is whether we need to build this knowledge in our low level model, or can we do this in a library? ...[missed]... Disadvantages of simulating this on top of something that didn't expose certain resources would be difficulty in generating efficient code.
- LW: A year ago tried to map abstract spec down to an implementation so I can feel I have a cost model, a clear cost model seems like we all want to have. So a clear concept of a task, clear lifetimes, and a concept for when do I make new tasks, when do they get reused. A clear cost model could be a concrete benefit to have more present in the formal spec itself.
- FMC: That is an interesting idea of a cost model.
- LW: And a task or resource would be a straight up feature. If we have the notion of a task clearly defined maybe it doesn't become semantically visible other than cost model stuff, but maybe later it does, because a task will have storage, and even I wonder if there is structural concurrency things, like task ownership, with invariants like child tasks. So when a parent task ends it must either wait, join, cancel, destroy, track whether there exist any child tasks.
- SL: How to evaluate need for this? What experiment? It would be nice to come up with example to show that if we do have this info available, to track this task all the way, then we can easily compile in this way, and it will be faster/easier.
- LW: One experiment is could we design task local storage? Would it be possible to propose such feature meaningfully? There are requirements, need to know when to create storage, associated malloc storage, and when to destroy it and free that malloc storage.
- SL: I would then say, could we do task local storage as a library or do we need to build it in?
- LW: Good question.
- FMC: I think it's a legitimate question to ask what this concept buys you. But, without prejudice, if you wanted to do task level storage, if we would decide it's really important to do it, then if you simulate it on top of something else that misses the point of having task level storage. It violates the core layering idea that I was going to talk about before. In the design you'd force the concept of task level storage to be in a not natural place than if you did it from the beginning.
- SL: But surely you'd want to have the smallest number of structures.
- FMC: I said assuming we decide it is important, then you'd want to have it in the right place in the overall design. Having the right language to talk about it, it's not about simulation or implementing on top of something else, it's about where does it belong in the stack of designs. Maybe you decide it shouldn't be at the core level, or you may decide it should be more intrinsic. But having that discussion requires the terminology that we understand.
- SL: Yes then you need the semantics of thread or task level storage.
- FMC: Yes, and how it relates to the other things we're trying to do.


### Adjourn

"
main/2019/CG-03-05.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 5 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: March 5, 5pm-6pm UTC (March 5, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email Ben Smith to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Discuss lowering memcpy and memmove to [memory.copy](https://github.com/WebAssembly/bulk-memory-operations/blob/d97e8fb93746d3b18599695d2a91200b0ba22f94/proposals/bulk-memory-operations/Overview.md#memorycopy-instruction) and memset to [memory.fill](https://github.com/WebAssembly/bulk-memory-operations/blob/d97e8fb93746d3b18599695d2a91200b0ba22f94/proposals/bulk-memory-operations/Overview.md#memoryfill-instruction) in tools.
    1. POLL: Move [bulk memory proposal](https://github.com/WebAssembly/bulk-memory-operations) to [phase](https://github.com/WebAssembly/meetings/blob/be19e9b28ed8879af9b26565019f012ffa3019e9/process/phases.md) [3](https://github.com/WebAssembly/meetings/blob/be19e9b28ed8879af9b26565019f012ffa3019e9/process/phases.md#3-implementation-phase-community--working-group).
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Adam Klein
* Alex Crichton
* Ben Smith
* Conrad Watt
* Daniel Ehrenberg
* Deepti Gandluri
* Derek Schuff
* Francis McCabe
* Lars Hansen
* Limin Zhu
* Luke Imhoff
* Luke Wagner
* Mitch Moore
* Paul Dworzanski
* Paul Schoenfelder
* Peter Jensen
* Richard Winterton
* Sam Clegg
* Sergey Rubanov
* Sven Sauleau
* TatWai Chong
* Thomas Lively
* Ulrik Sorber

### Find volunteers for note taking (acting chair to volunteer)

Ben Smith

### Adoption of the agenda

Lars Second

### Proposals and discussions

#### Review of action items from prior meeting.

#### Discuss lowering memcpy and memmove to [memory.copy](https://github.com/WebAssembly/bulk-memory-operations/blob/d97e8fb93746d3b18599695d2a91200b0ba22f94/proposals/bulk-memory-operations/Overview.md#memorycopy-instruction) and memset to [memory.fill](https://github.com/WebAssembly/bulk-memory-operations/blob/d97e8fb93746d3b18599695d2a91200b0ba22f94/proposals/bulk-memory-operations/Overview.md#memoryfill-instruction) in tools

TL: Wanted to get feedback from engine implementers. Implementing bulk memory ops. Has a chance to lower memcopy, memmove and memset. One option, always lower to these instructions. Other option: memcopy, memmove, memset are compiled and included as normal functions. The tools in LLVM have the ability to optimize calls to these functions, that have constant, statically known sizes to loads and stores. Memmove 16 bytes, could become two pairs of i64 load+store. Using these load store pairs could be faster. But it is slightly larger on code size. Falling back to calling wasm functions of memmove and memset means these compiled functions need to be in module. Trading off potential performance issue, against code size over the wire. I want to lower memmove and memcopy to the bulk instructions.

LH: In firefox these are implemented as calls into the runtime.

TL: Is there an unreasonable amount of overhead in runtime?

LW: I think it’s better for people to use loads/stores, 32-bit, 64-bit, when size is constant to use lowered to inline stores. So there isn’t much of a code size tradeoff.

TL: If it can be implemented w/ a single load/store pair, then I do it that way, otherwise bulk memory.

LH: The general feeling would be that these are for larger data movements, and it might be better to use a different stragtegy for smaller movements.

TL: v8 team said they prefer bounds checking behavior of bulk memory, for small constants.

AK: The other side of this is that we would do the lowering in the compiler, not go to runtime for small constants. Use them a compression scheme on the wire and go back to load/stores later.

TL: Yes, that’s what I thought.

JG: In the presence of baseline compilers, will they do that too?

LW: I agree, if hot code is having many small memmoves/memcpys then it’s better to lower to loads/stores.

LH: If you have an unaligned pointer and constant size for copy, you don’t know if there’s an overlap. Semantics are that you get all bytes until OOB w/ bulk memory ops, load/store is different. There are a bunch of optimizations that may be limited if we try to do it inline.

TL: Sounds like there are reasons to be cautious. In that case, might be good to find performance/code size tradeoff. We’ll take some measurements and try to find best policy here.

JG: I would vote that we have two policies, optimize for size and optimize for speed. In -oz we may always want memcopy, in -os not sure.

TL: wasm is unique, even when optimizing for speed we care more about code size than other targets.

JG: We may need to do something special for -O3, throughput vs. start up time. Whether baseline or top-tier jit matters depends on payload as well.

LI: Are the number of loads/stores influenced by the host cpu, how deep the pipeline is, etc. it makes it hard for wasm to target because it can’t tell what the host will do.

TL: Yes, it makes a difference, flying blind here, trying to come up with a one-size-fits-all solution. If anyone has an idea about what we should optimize for, then we’ll come up with something kind of good.

JG: That trade-off is why for top-tier we’ll want to rely on engine to do best optimization here. For LLVM, we need to understand the space more, need to collect the data across browsers.

LI: Do you see the speed setting being actually used. Last meeting, everyone said they’d optimize for size, (producers section), so who will use this?

TL: Different case, those bytes didn’t matter for user.

RW: We have to be careful we’re not too browser focused, different requirements for node.js.

JG: Some applications are not sensitive to size -- one where it’s acceptable that you wait a while, load time is high because users are willing to wait for it. So we can optimize for speed against size.

TL: We will take those measurements and do some science, come up w/ something reasonable.

LW: Would there be a GH issue, here’s the recommended way for toolchains to compile. To discuss that resolution.

LI: Does x86 behave differently than arm here?

TL: Not sure, depends on engines too.

FM: If the majority of memcopy is generated due to assignment, then original requirements don’t need to be honored.

DS: middle end of LLVM already does this. 

#### POLL: Move [bulk memory proposal](https://github.com/WebAssembly/bulk-memory-operations) to phase 3

BS: [discussing moving bulk memory to phase 3] In the previous meeting we didn’t move to phase 3 because we didn’t have a testsuite, since then Lars and I have been working on this. Lars provided a large number of tests, and I wrote the reference interpreter implementation. As of a recent PR, we are in sync. The V8 implementation is also almost in sync.

Poll: Move bulk memory to phase 3

| SF | F | N | A | SA |
| -- | -- | -- | -- | --
| 15 | 5 | 0 | 0 | 0 |

### Closure
"
main/2020/CG-08-04.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 4th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: August 4th, 4pm-5pm UTC (August 4th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Poll: Should we allow non-normative updates to the v1 spec branch? (e.g. tests, clarifications) [5 min]
       1. See https://github.com/WebAssembly/spec/pull/1230#issuecomment-665669922
    1. Poll: Should we update the spec to use LEB128 encoding for prefixed opcodes? [10 min]
       1. The CG had a poll in May 2017 and decided to require prefix opcodes to be followed by a LEB128 opcode. However, the spec does not correctly reflect this, and some implementations differ in their behavior too.
       1. See https://github.com/WebAssembly/spec/issues/1228
    1. Continuations & effect handlers as typed stacks ([issue](https://github.com/WebAssembly/design/issues/1359
)) (Daniel Hillerström, Daan Leijen, Sam Lindley, Matija Pretnar, Andreas Rossberg, KC Sivaramakrishnan) [20 min]
       - Poll: Phase 1?
    1. A unifying view on stack-related mechanisms (Daniel Hillerström, Daan Leijen, Sam Lindley, Matija Pretnar, Andreas Rossberg, KC Sivaramakrishnan) [15 min]
    1. Lightly Typed WebAssembly [5-10 min]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Adam Klein
* Alex Crichton
* Alex Syrotenko
* Alon Zakai
* Alshamma
* Andreas Rossberg
* Andrew Brown
* Asumu Takikawa
* Benjamin Titzer
* Ben Smith
* Bill Budge
* Conrad Watt
* Daan Leijen
* Dan Gohman
* Daniel Hillerström
* Daniel Wirtz
* David Piepgrass
* Francis McCabe
* Heejin Ahn
* Ioanna Dimitriou
* Jacob Mischka
* Jakob Kummerow
* Jay Phelps
* Jlbirch
* JP Sugarbroad
* KC Sivaramakrishnan
* Keith Miller
* Lars Hansen
* Luke Imhoff
* Luke Wagner
* Matija Pretnar
* Nick Fitzgerald
* Paolo Severini
* Pat Hickey
* Peter Jensen
* Petr Penzin
* Rich Winterton
* Ross Tate
* Ryan Hunt
* Sabine
* Sam Lindley
* Sean Jensen-Grey
* Sergey Rubanov
* Sven Sauleau
* Thomas Lively
* Wouter Van Oortmersson
* Yury Delendik
* Zhi An Ng

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Jay Phelps seconds

### Proposals and discussions

#### Review of action items from prior meeting.

#### Poll: Should we allow non-normative updates to the v1 spec branch? (e.g. tests, clarifications) [5 min]

AR: Created the branch so we can do that, if we wanted to. I think it makes sense to fix typos and tests to that branch. Who does the work? Cherry pick from master makes sense.

LI: agree, more tests and bug fixes in the sense of missing tests or v1 implementation varies because of that, that’s good. Who does it? Up to people who care about v1, to back port changes that are non-breaking. Majority of us won’t be just supporting v1, up to them to support it. It might be that someone who cares enough about v1 becomes a maintainer of that branch.

BS: the details can be discussed on a GitHub issue, bigger qns is that whether we should do that, doesn’t look like much opposition. Do we have unanimous consent?

<unanimous consent>

BS: we will allow this.

##### See https://github.com/WebAssembly/spec/pull/1230#issuecomment-665669922

#### Poll: Should we update the spec to use LEB128 encoding for prefixed opcodes? [10 min]

##### The CG had a poll in May 2017 and decided to require prefix opcodes to be followed by a LEB128 opcode. However, the spec does not correctly reflect this, and some implementations differ in their behavior too.

BS: spec document does not say that the opcode is leb128 encoded, but we had a CG poll in May 2017 for leb 128 encoding. Since we decided this many years ago, i think it should be a spec mistake. But since there are multiple different implementations, we might want to discuss this.

JP: who are the divergences?

BS: binaryen wabt prefix + leb, v8 does prefix + byte, SM does prefix + leb.

TL: no visible difference right now?

BS: nope, long encoding

AR: extension operators and bulk operators

BS: bulk is not upstream yet, non-trapping. You can write those as a long encoding, that will diverge implementation.

AR: right now it is conservative, we won’t break anything if we allow LEB.

TL: i think we should make the change

BS: agree, any opposition?

AR: this is something we screwed up in proposals

AR: we could interpret this differently, for now we allow single byte LEB, but if we need more codespace, then 2 byte leb.

BS: danger there is that implementation have to care about that. Currently implementations already have to read LEB, it will be nicer to have uniformity.

KM: right now SIMD already have more, you have to support LEB if you have to support SIMD

BS: if you have a generic mechanism for opcode, if you read a prefix byte, you always LEB.

AR: rephrase: must be a LEB but no redundant bytes.

BS: you could do that, but that doesn't exist in the spec currently

JS: opcode encodings be canonical -> faster decoding

LH: decoding is slower since there is more check to do

KM: if you know everything is 127 or less then assert

LH: if you open code everything, but you prefer 1 reader for a opcode

KM: templated leb decoder that has max size and does it for you

TL: this doesn’t need to be complicated, make it LEB, call it a day

KM: also agree, we expect these not to be the common instructions, if they are slower by 1 or 2 instructions, not too bad

BS: sounds like not really opposition... Okay let’s say unanimous consent to make this change, to update to LEB128 to opcode? <silence> ... Okay, we can follow up on the issue.


##### See https://github.com/WebAssembly/spec/issues/1228

#### Continuations & effect handlers as typed stacks ([issue](https://github.com/WebAssembly/design/issues/1359)) (Daniel Hillerström, Daan Leijen, Sam Lindley, Matija Pretnar, Andreas Rossberg, KC Sivaramakrishnan) [20 min]

[Effect handler proposal SLIDES](https://github.com/WebAssembly/meetings/blob/master/main/2020/presentations/2020-08-04-rossberg-continuations.pdf)

[Multicore Ocaml Effect Handler SLIDES](https://github.com/WebAssembly/meetings/blob/master/main/2020/presentations/2020-08-04-sivaramakrishnan-ocaml-handlers.pdf)

##### Poll: Phase 1? (deferred to future meeting)

#### A unifying view on stack-related mechanisms (Daniel Hillerström, Daan Leijen, Sam Lindley, Matija Pretnar, Andreas Rossberg, KC Sivaramakrishnan) [15 min] (deferred to future meeting)

#### Lightly Typed WebAssembly (Ross Tate and SOIL Initiative) [5-10 min]

Slides: [pdf](presentations/2020-08-04-tate-lightly-typed-webassembly.pdf) [pptx](presentations/2020-08-04-tate-lightly-typed-webassembly.pptx)

### Closure
"
main/2020/CG-11-24.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 24th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: November 24th, 5pm-6pm UTC (November 24th, 9am-10am Pacific Standard Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. POLL: Advancing [Numeric Values in WAT Data Segments Proposal](https://github.com/WebAssembly/wat-numeric-values/blob/master/proposals/wat-numeric-values/Overview.md) to Phase 2 (Ezzat Chamudi) [10 min]
1. Closure



## Meeting Notes

### Opening

#### Attendees
Derek Schuff

Paolo Severini

Zalim Bashorov

Thomas Lively

Alon Zakai

Asumu Takikawa

Luke Imhoff

Luke Wagner

Gergely

Sergey Rubanov

Jay Phelps

Ross Tate

Sven Sauleau

Nick Fitzgerald

Eric P

Nabeel Al-Shamma

Nicholas Yang

Ioanna Dimitriou

Sam Clegg

Conrad Watt

Petr Penzn

Rich Winterton

Heejin Ahn

Ezzat Chamudi

Franics McCabe

J Birch

Daniel Wirtz


### Adoption of the agenda

Thomas seconds

### Proposals and discussions

#### POLL: Advancing [Numeric Values in WAT Data Segments Proposal](https://github.com/WebAssembly/wat-numeric-values/blob/master/proposals/wat-numeric-values/Overview.md) to Phase 2 (Ezzat Chamudi) [10 min]

EC: [presenting](https://docs.google.com/presentation/d/1zbYsfvDu76afrpeZ0xS_W8dvXAt9Bke_9MxgL4MR6dc/edit?usp=sharing)

FM: There are FP numbers that don’t have a decimal representation. What should we do about those?

EC: In the proposal, if the number is out of range...

FM: what i mean is, there are numbers that you can’t represent accurately

CW: In the text format, there are already text literals for arbitrary floating point numbers. Will do the same here.

EC: we’ll use the same representation of i32.const or stores, etc

PP: If you can represent those numbers now, you should be able to still do it because the string format is not going away.

NA: should we consider options for 256 or 512 SIMD?

TL/PP: It seems a bit premature since there’s no proposal for those now. We can always extend this as part of that future proposal.

CW: we’ll have to do that regardless of whether this proposal is adopted.

SR [in chat]: Are numbers always signed?

EC: No, the text format already handles signed and unsigned integers.

CW: just to be clear, this is the existing notation in the text format for the const instruction, nothing new needs to be defined.

DS: Any objections?

<silence>

SC: Would we imagine this would mostly be used for hand-written wat files or would compilers produce this as well?

EC: there are no changes in the binary. Engines wouldn’t change.

SC: I guess I meant tools that produce WAT, like WAT disassemblers, etc.

EC: not sure.

CW: they’d probably have to use the original raw form. If you go from binary to text you don’t have the original format. If you have the tool producing from a higher-level, you could imagine using this.

EC: Regarding the binary format, the binary section does not contain any data about the interpretation.

LI: Suggestion for disassemblers: Default to the back-compat method, but there should be options in tools for changing the format.

EC: that’s a good idea, but it doesn’t affect the spec.

LI: yeah, it's just good for disassemblers

EC: (shows demo in VS code using wasp, when disassembling back to text, it goes back to the string format)

CW: Vote?


F: 15
SF: 5

### Informational things

EP: W3C has a new patent policy for living documents. Basically means you get to circulate candidate recommendations as long as you want without publishing versioned documents. Advantage of new process is that companies have to commit to patent obligations earlier than in the old process. Has already been agreed to by W3C advisory committee. Cost to us is that representatives have to go click a button to opt in. This is technically a WG matter.

TL: what’s the “user-visible” change. There won’t be a versioned spec?

EP: we have the option of staying on one “Version” for a long time if we want. It’s similar to how they do the HTML spec.

LI: one thing that’s come up before is that we restructured some of the URLs so that academics writing papers can link to particular versions. Would that still be possible, to specify a version that way?

EP: This doesn’t have to change anything because we can choose not to partake of the living document path. Every publication has its own URL anyway, so even though there’s no major/minor number, there are still unique URLs to cite.

LI: that covers my concern, thanks

RT: as someone in that community: with that model where you update some number everytime some proposal goes to phase 4, as long as there’s a unique doc or URL, it should be fine.

EP: any other concerns, about practicality or patents?

LI: have there been other things that have gone from versoined to living? Since there’s not that clear cutoff anymore?

EP: it’s new, but others who are migrating to the new framework include CSS and several other working groups. Whether they will use a living doc is up to them, they don’t have to. 

LI: how does living doc change early proposal adoption and proving compatibility? E.g. JS adds stuff a lot, would we have to be more careful about breaking changes?

EP: i think the contract around breaking changes is pretty much the same.

TL: I don’t think there would be any change to our process doc up until phase 5, when things get published. So the CG wouldn’t change.

ID: Is there any link where we can read about these policies?

EP: Probably...

DS: I know the patent policy has been up for a while.

EP: Is it ok if this is member-only?

DS: If anything is member-only, I can just send it to Ioanna or other interested parties. To be clear, this is WG member-only?

EP: Any W3C member account.

DS: That’s the one you have to pay for, right?

EP: Yes. Will send Derek email to forward on.

TL: what’s the timeline where we have to decide on opting into the living doc process?

EP: it’s easier if we do it by december 7

DS: Other things:

RT: New SOIL seminar coming up. Adam from UBC on a type system for guaranteeing that all accesses into linear memory are in bounds. They want feedback on practical considerations on what would make this practical for generators and engines.

DS: Last thing: Zoom is now requiring passwords or waiting rooms, so we wanted a new meeting anyway. I will change the calendar invite with a new URL with the password embedded.



"
wasi/2022/WASI-08-11.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: August 11 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: August 11, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Typed Main ([hackmd](https://hackmd.io/2HVwwBRTQVmT-emTEkEDXw?view), [PR](https://github.com/WebAssembly/component-model/pull/80)) - Kyle Brown
    2. [WASI Crypto](https://github.com/webassembly/wasi-crypto) - Frank Denis


### Attendees:
- Dave Bakker
- Lin Clark
- George Kulakowski
- Nathaniel McCallum
- Bailey Hayes
- Dan Gohman
- Victor
- Arne Vogel
- Steve Schoettler
- Yong
- Nicolas Devillard
- sonder-joker
- Mingqiu Sun
- abrown
- Saúl Cabrera
- Brian Hardock
- Kyle Brown
- Shiyu Yuan
- sbc
- Richard M
- Piotr Sikora
- Petr Penzin
- David Justice
- Filippo Valsorda
- flaki
- Frank Denis
- Ghazal
- Jeff Charles
- jlbirch
- Joel Dice
- Kevin Hoffman
- Melanie Riise




## Typed Main (Kyle Brown)

- Kyle Brown
  - now named the CLI embedding proposal
  - goal is to infer as much as possible about how to infer as much as possible about CLI programs from their type, minimizing the amount of information that needs to be carried around in special sections
  - all value imports can be supplied as positional or named arguments
    - this choice of positional or named isn’t part of the type
  - value imports that are of file type automatically become preopened files
  - arguments can be optional
  - flags are exactly the arguments of boolean type
  - short flags have to be explicitly configured since names can collide on single letter flag names
- Nathaniel McCallum
  - like it overall
  - the one area that feels magical overall is how arguments are all automatically both positional and named
  - feels unintuitive relative to existing expectations
- Kyle Brown
  - decided that this was the more convenient default overall
  - there is an annotation to override it
  - the motivation is to let this work with components off-the-shelf not written with CLIs in mind
- Nathaniel McCallum
  - concerned about subverting expectations of CLIs in unintuitive ways
- Kyle Brown
  - can explore
  - welcome more feedback on the PR
- Petr Penzin
  - curious about how exactly this relates to existing libraries for parsing arguments
- Kyle Brown
  - note that the special preopen handling of files points to why its important for the host to be involved
- Petr Penzin
  - how would I write code to use this in a source language? or maybe you don’t have to?
- Kyle Brown
  - write down the type (via wit-bindgen or some other tool). everything else stems from that type, for guests. hosts have to do the work to implement this
- Dave Bakker
  - curious about subcommands like npm and git have
- Kyle Brown	
  - not (yet) addressed by this proposal
  - have thought about it, can imagine a discriminated union main type corresponding to subcommands

## WASI Crypto (Frank Denis)

- Frank Denis
  - a set of APIs to do cryptography from wasm
    - signatures
    - key exchange
    - encryption
    - hashing
    - key derivation
  - exposed from the host rather than in core wasm code
  - why?
    - speed
    - correctness
    - side channel hardening
    - compliance
    - reusability
    - access to hardware acceleration
  - not opinionated about APIs
    - expose things that are widely used, even if they are deprecated or better alternatives exist
  - keys
    - keys are exposed as handles by default
  - safety
    - strongly typed
      - as strongly typed handles
      - eg keys know their algorithms and parameters
    - nonces can be automatically generated only when safe to do so
    - only allow safe and commonly used parameters
  - not a crypto library
    - this is more like a set of system calls
  - stability as a constraint
    - simple, safe, easy to use from various languages
    - can’t churn
  - not directly intended for use by applications
  - allow languages newly targeting wasm to have immediate access to crypto
  - current implementations
    - runtimes: wasmedge, wasmtime
    - adapters: assemblyscript and rust
    - standard libraries: zig
    - applications: jwt-simple
  - in the next wasi snapshot?
    - need to finalize the first version of this spec
    - test suite
    - make sure that future features (e.g. streams) won’t introduce backwards compatible changes
  - does this need a dedicated wg meeting?
- jlbirch
  - how do you configure or provide a provider? eg the choice of openssl
  - second, performance: do you have benchmarks etc showing that having native code exposed via the host is much faster than doing it in wasm?
- Frank Denis
  - we may add the option later to configure the provider
  - but the goal is to abstract away any difference between providers, so there should be no change to guest code. in particular, want to automatically provide the fastest implementation for the given host
  - wanted to prevent applications from handcoding keys
  - can’t guarantee side channel freedom is wasm right now
  - can’t access e.g. aesni instructions from wasm directly right now
- Filippo Valsorda
  - I’m a maintainer of go stdlib cryptography. this direction is excellent for us
  - I understand the goal of wanting simple APIs, but don’t know how to build things using e.g. opaque identifiers
- Frank Denis
  - applications should not have to change anything to advantage of wasi crypto
  - but not for other things which may use their existing library code
  - again: wasi crypto is not a crypto library, it is a set of “syscalls” for libraries to be built on top of, and applications can use that
  - around opaque identifiers, say for keys. the runtime can block the operation of exporting the contents of key material. this is a policy of the host -implementing wasi-crypto
- Nathaniel McCallum
  - practical experience from being on redhat’s crypto team
  - this experience of making key material inaccessible and handle-based is well trodden ground by now
  - excited to contribute and I’d be very interested in a Working Group
- Frank Denis
  - will discuss on the github repo about meetings etc
- Nathaniel McCallum
  - maybe we can break the proposal up into smaller parts to have more digestible parts of the entire interface
  - one other piece of feedback, some APIs currently operate on global state
"
gc/2022/GC-04-19.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 19 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: April 19, 5pm-6pm UTC (April 19, 9am-11am Pacific Standard Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: [stringrefs](https://github.com/wingo/stringrefs) [20 minutes]
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Andy Wingo
- Asumu Takikawa
- Francis McCabe
- Roberto Lublinerman
- Sam Clegg
- Rick Battagline
- Zalim Bashorov
- Lars Hansen
- Conrad Watt
- Aske Simon Christensen
- Emanuel Ziegler
- Michael Thomas
- Luke Wagner
- Goktug Gokdogan
- Dmitry Bezhetskov
- Jimin
- George Kulakowski
- Manos Koukoutos
- Jakob Kummerow

### Discussion: [stringrefs](https://github.com/wingo/stringrefs) [20 minutes]

[slides](https://github.com/wingo/stringrefs/blob/main/stringrefs-gc-subgroup-19-04-2022-slides.pdf)

FM: Don't think it's true that JS strings are 16-bit code units. V8 has all kinds of strings, not all are 16 bit.

AW: Logically they are 16-bit code units, but e.g. single-byte encodings can be used as an optimization.

FM: I don't understand the comment about strings in GC memory because IT can already do zero-copy in the presence of provably immutable strings.

CW: But the component model might not be able to prove immutability.

TL: Let's not get hung up on details.

LW: When moving strings from the host to the module there is no way to avoid a copy with just IT.

ZB (chat): Couldn't it be enough to have immutable arrays + component model?

CW: Agree that the existence of a mature string representation in Wasm is a good reason to have stringrefs. But we will probably have immutable i16 arrays in raw GC, so probably not necessary to focus on immutability as a reason for existence.

FM: Some languages will have to bring their own GCs. Will be similar with strings.

AW: Yes, and good to take those into account in goals for string proposal.

FM: What are the other operations on strings that you think are important besides passing them between JS and Wasm?

AW: Depends on language. For example, Java wants O(1) indexing into code points. Creating strings from linear memory and writing them to linear memory is important. For example Rust would want to eagerly turn strings into UTF-8 so it can inline further operations. Also iterating over code points and code units.

FM: One of the pain points the J2CL team encountered is regex. This is a higher-level API than accessing a code point.

AW: Plan is to prototype with J2CL using their current scheme of depending on JS Regex.

GG: For clarification, we currently use re2j rather than native regex. We plan to next test by crossing the boundary to native JS regex with all the copying that will entail and after that we will be able to experiment with stringref to measure its performance.

ZB (chat): Isn't zero-copy interop with browser APIs more important than JS?

JK (chat): Zalim: ""same thing"". If one works, so does the other :)

ZB (chat): Jakob: is it ""same thing"" in all engines? 

JK (chat): all browsers are used to passing strings back and forth between JS and browser APIs, so I guess ""yes""

FM: At the beginning you said something about the module boundary being a source of inefficiency. Supposing this was not true, how would that affect the design?

AW: Hard question. WebAssembly implementations have not gone down the path of cross-module optimization.

FM: V8 is definitely going in that direction.

AW: Even with cross-module inlining, there are still dynamic checks, unpredictability in the form of where your code is used and where it will need to be inlined. Could end up megamorphic over string representation.

AM: If stringref is a library, who ships it? The browser or the user?

FM: Good question. Multiple possible answers. One of the things about the stringref proposal is that it is much higher level than the machine instructions.

SC (chat): bulk memory is also not constant time right?

FM (chat): which, IMO, is a ding on those instructions.
LH (chat): and hardware has variable-time instructions (string ops, vector ops)

TL: Could be standardized at the JS or Web platform layers.

ASC: For Dart, one of the most interesting things is to be able to declare string literals.
GG: Could you have your literals on the JS side?

ASC: We have lots of constant objects like arrays, maps, sets. And the components of those need to be constant and should include strings. Declaring the strings externally would prevent them from being constant and prevent containers that include them from being constant.

CW: Are these constants protected at the type level?

ASC: Yes, they are declared as const in the code and syntactically they can only contain other constants. They are immutable, so modification operations will throw on the constants.

CW: Trying to get at what would go wrong if the consts included external strings. It would work but you would give up some optimizations?

ASC: Right. The big issue is that constants are declarative in the module. It is theoretically possible to generate code to dynamically generate these things rather than declaring them. A previous implementation did that and changing it to use declared constants was about 20% improvement to code size and runtime.

TL: What if we could declare string data but otherwise use imports? Then we could use externref as the handle and off the web there could be similar versions that use i32 as a handle.

CW: For global initializers to be able to point at a data segment and create a string out of it, we would need a language-level instruction for that.

GG: Do we expect this proposal to make it more optimal to pass types across the boundary when they are modified on the JS side?

AW: For example, converting to upper case. Anything that could change over time as unicode changes. Intl facilities. This proposal would allow you to do those modifications with zero copy.

FM: Is zero-copy the most important thing?

AW: Yes, it's close. Also nice to have a single string on the platform.

CW: The point that the platform has a single idea of what a string is makes it useful to raise that up to WebAssembly. This is different from bringing high-level language constructs down to WebAssembly.
"
main/2024/CG-05-21.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 21st video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: 2024-05-21, 16:00-17:00 UTC (2024-05-21, 9am-10am PDT, 18:00-19:00 CEST)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Announcement: last call for f2f [registration](https://docs.google.com/forms/d/e/1FAIpQLSdqMDs4Y0uT5ngde6SqY19Dnz9FLxKhNsBLVSzK_QyOwlZuvQ/viewform), agenda proposals, and scheduling constraints
1. Proposals and discussions
    1. Discussion of [the `custom-page-sizes` proposal](https://github.com/WebAssembly/custom-page-sizes) and vote for phase 2 (Nick Fitzgerald, 30 minutes)
  1. Discussion: To keep or remove [@name annotations](https://github.com/WebAssembly/annotations/issues/21) (Thomas Lively, 30 minutes)
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

### Attendees

- Thomas Lively
- Robert C. Seacord
- Jeff Charles
- Manos Koukoutos
- Chris Fallin
- Nick Fitzgerald
- Yuri Iozzelli
- Conrad Watt
- Paolo Severini
- Ben Visness
- Yury Delendik
- Dan Phillips
- Michael Ficarra
- Adam Klein
- Andrew Brown
- Zalim Bashorov
- Francis McCabe
- Richard Winterton
- Linwei Shang
- Slava Kuzmich
- Brendan Dahl
- Kirk Shoop
- Matthias Liedtke
- Jakob Kummerow
- Paul Dennis
- Bailey Hayes
- Mingqiu Sun
- Andreas Rossberg
- Oscar Spencer
- Ben Titzer
- Heejin Ahn
- Daniel Lehmann
- Saúl Cabrera
- Adam Bratschi-Kaye
- Pedro Soto
- Deepti Gandluri
- Alex Crichton
- Petr Penzin
- Dan Gohman
- Keith Winstein
- Julien Pages
- Nuno Pereira
- Ilya Rezvov
- Johnnie Birch

### Proposals and discussions

#### Announcement: last call for f2f registration, agenda proposals, and scheduling constraints

TL: [register](https://docs.google.com/forms/d/e/1FAIpQLSdqMDs4Y0uT5ngde6SqY19Dnz9FLxKhNsBLVSzK_QyOwlZuvQ/viewform) by May 24. Submit agenda items and schedule constraints via PR to the meetings repo.

##### Discussion of [the `custom-page-sizes` proposal](https://github.com/WebAssembly/custom-page-sizes) and vote for phase 2 (Nick Fitzgerald, 30 minutes)

NF presenting slides: https://docs.google.com/presentation/d/1fVhVzeU1iPcyTbnZuehBAQp7aVk3o3EZ_gHaOGf7_dI/edit

PP: This approach disables guard pages, and that's why you have to do bounds checks? There would be a performance impact.

NF: virtual memory guard pages are never guaranteed, for example if there is not enough virtual memory.

AR: Also 32-bit systems can't use that.

NF: Nor can targets without an MMU.

KW (chat): 
My opinion (as somebody who's working on wasm for very constrained embedded environments, with Siemens) is still that a ""byte-granularity deterministic cap"" would be a lot simpler for the consumer to implement, and would require a much smaller spec change (all things considered), especially when you consider changes to the tools conventions, and would hit all the important use cases. I appreciate the new slide on that option here but... I guess I just have a different point of view. It's true that memory.size would no longer return the maximum writable address, but... there's no runtime mechanism to get the memory limits today either.

BV (chat): How does a 1-byte page size differ from a ""byte-granularity deterministic cap""?

KW (chat): it wouldn't change the behavior of memory.grow or the object format at all. Or to be clearer: the current proposal changes the execution of memory.size, memory.grow, and the tools conventions (__builtin_wasm_page_size and new linker behavior). A ""byte-granularity deterministic cap"" would be much dumber -- it wouldn't change any of those three things. It would just impose a requirement for the consumer to trap on loads and stores to addresses > the cap. My understanding from the last meeting was that we were going to discuss this on an issue thread -- but there hasn't been one on this topic yet. I'm sorry to be applying stop energy in these meetings.

AK: You mentioned that some engines have shipped the non-standard solution. It's odd that the proposal is coming from a different group. Do we have assurance that the engines shipping today will adopt the standard proposal?

NF: We're setting up an interest group in the bytecode alliance. Also there is no standard solution for this problem right now. The engines would follow the standard if they could.

CW: Don't want to hang up the poll on endless rounds of requesting feedback for more people. Nick, have you reached out to the engine implementers?

NF: Yes, I've reached out in meetings, on GitHub, to implementers, etc. I could always do more, but unclear where to draw the line.

AK: Want to avoid the situation where we adopt the proposal, but then the intended audience doesn't use it.

NF: Even if the non-standard thing has usage for a while, having a standard solution is a benefit in itself.

TL: What if we vote on the page size question, then separately discuss the issue KW raised further on GitHub.

BT: Is there time pressure? Seems an ecosystem risk.

CW: Let's move ahead with this poll and do a straw poll for phase 2 to see where we stand.

Poll: (if we proceed with multiple page sizes) there shall be two valid page sizes (1 byte and 64KiB), factored to be potentially extended in the future.

SF: 11
F: 17
N: 9
A: 0
SA: 0

Straw poll: Do we want to move forward with the multiple page sizes?

MP (for) : 15
N (neutral): 14
A (consider an alternative): 4

KW to take the action item to file an issue for further discussion.

#### Discussion: To keep or remove [@name annotations](https://github.com/WebAssembly/annotations/issues/21) (Thomas Lively, 30 minutes)

TL presenting [slides](https://docs.google.com/presentation/d/1a8ihfu9knCN9srCWFreb0E6JHmFwDnCsdvFD-YevKpI/edit?usp=sharing)

FM: Overloaded functions.

TL: But would anyone actually use them?

AR: Another dimension. Also allows multiple names on a single item. Names are in the domain of the source language, but symbolic identifiers are not. Also want to have text versions of all binary custom sections. Would be weird if only standard custom section doesn't have annotation. Workaround with @ custom annotation requires knowledge of binary encoding, etc. so not useful in text format.

YI: There is a bit of work to be done if we remove the name section. Tests, etc. Is the annotations proposal the best place for the extended identifiers?

AR: I'm ok with adding the extended identifiers, it's close enough.

BV: What's the connection between binary and text?

AR: The idea is that it gives custom binary sections corresponding text formats.

BV: I'm not sure I see the value of having it be human-editable.

AR: I don't know, people do various things with the text format. If it's not editable, I think it's value is diminished.

TL: Are there other tools that support the name annotations? Binaryen does not, and if I can't implement it before the phase 4 vote at the f2f, is that going to be a procedural issue? It's up to us.

AC (chat): wasm-tools has support for @name annotations.

TL: Great, no issue then. Seems like we have consensus to keep the name annotations.

### Closure

"
main/2021/CG-01-05.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 5th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: January 5th, 5pm-6pm UTC (January 5th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Announce next SOIL Seminar on Fri Jan 15 at 1pm PT: ""Compiling Project Everest to WebAssembly"" by Jonathan Protzenko (Ross Tate) [2 min]
    1. Update on the [Branch Hinting](https://github.com/WebAssembly/branch-hinting) proposal (Yuri Iozzelli) [10 min]
    1. Discuss activating the new GitHub Discussions feature for various repos (Ross Tate) [10-15 min]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

Jay Phelps

Francis McCabe

Sergey Rubanov

David Piepgrass

Yury Delendik

Yuri Iozzelli

Nick Fitzgerald

Léo Andrès

Fatih

Paolo Severini

Ezzat Chamudi

Ryan Hunt

Arun Purushan

Nicholas Yang

Lars hansen

Daniel Wirtz

Rick Battagline

Thomas Lively

Luke Wagner

Mingqiu Sun

Asumu Takikawa

Till Schneidereit

Ioanna Dimitriou

Ross Tate

Derek Schuff

Deepti Gandluri

Nabeel Al-Shamma

Sean Jensen-Grey

Dan Weber

Rich Winterton

Eric Prud’hommeaux

Ben Titzer

Petr Penzin

Wouter Van Oortmerssen

Gen Ashley

Sam Clegg

Luke Imhoff

Paul Dworzanski

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

### Proposals and discussions

#### Update on Branch Hinting proposal [Slides](https://drive.google.com/file/d/1-XoWyt9-dizxmyi4opKpIFKPbp1p_mpc/view?usp=sharing)

YI presenting 

YI: looking for feedback, how to link hints to code, forward compatibility

TL: instruction index and branch instr index might not be compatible with feature detection proposal, because it has conditional blocks. That would change the instruction indices depending on what features are supported. A byte index would work with that.

RT: I suspect you’re not the first person that’s going to want this - we should have a general solution that works for more use cases. 

NF: debug info uses byte offset within the code section. It may make sense to match up with that. 

DS: Similar thing we have is, when we have engines print stack traces, they have offsets in the module than the code section offsets - which we can fix in the future, but that’s another case where we are using a similar thing - we can talk about whether we use offsets in the module/code - but there is a precedent for both

YI: Definitely not a function offset then?

DS: Right.
RW: If you were using a module offset - do you have separate SSE/AVX modules

DS: This is the Wasm offset

LW: in the future we may get multiple code sections, so “which code section” becomes an issue

RT: Byte offset sounds like the right idea, what would it be relative to? Sounds like that

DG: Any other feedback? YI, is this feedback you can make forward progress with?

YI: yeah, this is good feedback. It sounds like these issues are relevant and pretty compelling argument for a byte offset of some kind.

DG: also a suggestion from Ben Tizer in chat, suggested a pair of function index + byte offset, since this is stable over module transforms and deletion/reordering of functions


#### SOIL Seminar announcement

RT: SOIL seminar next friday at 1PM EST about Project Everest from Jonathan Protzenko at MSR (general link at http://soil-initiative.org/seminar/) and [event link here](webcal://outlook.office365.com/owa/calendar/59288fd712504c0db706a7a8144850f9@cornell.edu/930d07a860c14a1b94235ba3adc9eb5e8828347062720001580/calendar.ics).

#### Discuss activating the new GitHub Discussions feature for various repos 

RT: Github has released Github discussions as a new feature, still in beta. At a high level, it compliments issues - some of them there are two kind of formats - open ended discussions, and questions. Seems like it would be a good fit for what we are doing

DG: what about morphing discussions into issues, for things which become more appropriate for that?

RT: Issues can be turned into discussions, but the other way around is still in beta. 
Sometimes it’s not known whether there is a concrete issue that we have, something that we want to change, etc. Once it’s known, an issue can be created.

FM: is this intended to be like Quora or Stack Overflow?

RT: There’s a Q&A thing that looks like Stack Overflow/Quora - not entirely sure if that’s what they’re going for - People do that already in questions - so that issues aren’t closed that are questions and are easy to find

EP: Are they threaded, like email?

RT: The Q&A are, the open ended discussions look just like the issues mostly

DW: my impression on discussions so far: not very different from issues, but has threaded discussion, allowing to reply to a specific post

RT: you’re allowed to have different categories of discussion, which can be different for different repos. We could impose some structure for really big general repos like the design repo.

DS: We should try a pilot and see how it goes

RT: the ones suggested by default are “Q&A”, “ideas”, and general

DG: we could try opt-in per-proposal, even if not a really narrow pilot. Particular suggestions?

RT: I’ve been working with EH and GC. I know some of the things I’ve brought up in EH are really discussion items that would be good for discussion

TL: it would be good to let champions opt-in and try it out for now and see how it goes. When we get some experience then we could put together some recommendations for how to use it

DW: looks like not actually threaded, but more like replying to top-level posts only

FM: One of the things about Quora/SO is you get the idea of a “settled” response to a question. It could turn into a kind of FAQ. That could be helpful for people unfamiliar with the proposals to get up to speed on what discussions and conclusions have been made. It’s a useful feature one could look for in this kind of tool.

RT: Right now, when you close an issue it goes away, there’s not a good forum to keep it alive as a reference. 

DG: yeah, that would be  nice. Not sure if there’s currently a way to do that other than maybe keeping a living document (e.g. md) with a list of those discussions.

### Closure
"
main/2018/CG-11-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 13 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: November 13, 5pm-6pm UTC (November 13, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email Ben Smith to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. [Rename memory.drop and table.drop](https://github.com/WebAssembly/bulk-memory-operations/issues/23)
    1. [Revisiting the edge-case semantics of wake](https://github.com/WebAssembly/threads/issues/108)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Adam Klein
* Alex Crichton
* Alon Zakai
* Arun Purushan
* Ben Smith
* Ben Titzer
* Conrad Watt
* Dan Gohman
* Deepti Gandluri
* Derek Schuff
* Francis McCabe
* Jacob Gravelle
* Jay Phelps
* Keith Miller
* Lars Hansen
* Luke Wagner
* Michael Holman
* Mike Rourke
* Pat Hickey
* Richard Winterton
* Sam Clegg
* Sergey Rubanov
* Sven Sauleau
* Thomas Lively
* Wouter Van Oortmersson
* Yury Delendik

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Lars seconds

### Proposals and discussions

#### Review of action items from prior meeting.

#### [Rename memory.drop and table.drop](https://github.com/WebAssembly/bulk-memory-operations/issues/23)

JP: I like `drop_segment`. It keeps it under the same table label.

AR: Bikeshedding but I would call it data.drop and elem.drop or `table.drop_elem` `memory.drop_data`. No strong preference

LW: Nice symmetry with data and elem, those are the things you’re dropping.

BS: [Trying to find consensus]

JP: Would like it to stay under table if it affects tables.

AR: But it doesn’t.

BT: I had another bikeshedding discussion. Dropping passive/active and renaming to autoload for active.

AR: What’s the opposite called?

BT: Absence.

BS: Yeah active/passive is not great, but else would we call it. Don’t like noautoload.

LW: The text format can have “auto” and nothing otherwise. Or maybe use lack of init_expr as passive.

LH: Things are becoming ambiguous in the text format already with multiple tables, I don’t think we should push our luck.

BS: The default now is active, so you want to keyword for passive.

BS: Seems like there’s not a lot of interest in bikeshedding, let’s follow up on GH issues.

#### [Revisiting the edge-case semantics of wake](https://github.com/WebAssembly/threads/issues/108)

[Conrad presenting slides] https://drive.google.com/file/d/1h4p5ZJoI2O38SZPu0pMoJTdsOxHDBMv0/view?usp=sharing

AR: This is not just for the spec semantics. It removes an edge case. In realistic cases you can `UINT32_MAX`. In unrealistic cases you shouldn’t use anyway, because it would trap anyway. There’s no benefit from the current case split, so we should simplify.

BT: How do you do this if you want to wake > 2<sup>32</sup> with these new semantics? Wake in a loop.

CW: Current semantics don’t cover this either.

BT: You could encode this as 31-bit int with another bit for “more waiters”

LH: You can already do this by adding a “num waiters” instruction.

CW: This is an unrealistic case, linux, windows, etc.

LH: This isn’t just OS threads, also asyncWait.

LW: Is it possible to have wait trap instead of wake?

CW: Would we say that the max number of waiters is 2<sup>32</sup> then?

That implies we that we specify that we can never create more the 2<sup>32</sup> waiters.

LH: There’s a poor interaction with JS -- they’d have to agree to this limit.

LW: Engine could just do it.

LW: You probably wouldn’t have made 2<sup>31</sup> waiters, and …

LH: Trapping is poor semantics.

LW: We already have to trap on grow.

LH: grow is single-threaded

LW: `memory.grow` is multi threaded though.

CW: Whatever we need is going to require more instructions.

Can we use the unsigned semantics given that we’ll have to add more instructions anyway.

BT: The semantics aren’t quite right, don’t want it to be a loop for “all”

[Discussion about resource limits]

LW: `table.grow` has to stop before the length fits in the i32

AR: Now that you mention it, there is weirdness with `table.size`, it’s 32-bits which is 1 more than you can index.

BT: You should be able to index the last one, oh you can’t have a full 4G table.

TL: Why don’t we have `wake_all` and doesn’t return how many it woke.

LH: It’s a ridiculous corner case, and nobody likes any of the solutions.

BS: In the past we punted on these decisions by adding traps. Maybe we should do the same as LW mentioned.

CW: So it sounds like semantics are preventing > 2<sup>32</sup> waiters, and using unsigned for wake.

BS: Any issue for TC39 that we’re introducing this limit?

AK: This doesn’t seem like an issue for TC39, there are many limits like this already in the spec.

Poll: trap wait > 2<sup>32</sup> and unsigned semantics.

| SF | F | N | A | SA |
| - | - | - | - | - |
| 11 | 6 | 3 | 0 | 0 |
 
JP: bikeshedding wait vs notify.

CW: We’re not doing the same as JS, wait takes nanoseconds in wasm, JS uses a float. So it’s different.

AR: I like wake/wait.

JP: I ran into the confusion, in a conference talk and 1-1. It’s easy to misunderstand. Nice to have a different name to have it different from JS, not a big concern for me. Notify is easier.

BT: I’ve never seen wake used before, always seen notify.

LH: Came from the futex interface in linux.

[discussion about TC39 history here]

LW: Oh, so JS renamed it to notify?

BS: Yes, they did it after all browsers unshipped because of spectre.

LW: So it has the benefit of being in alignment with JS and clarity when speaking.

Poll: Rename `atomics.wake` to `atomics.notify`

| SF | F | N | A | SA |
| - | - | - | - | - |
| 0 | 15 | 5 | 2 | 0 |

BS: Two people against, do you want to say anything about why?

AR: Already mentioned before (like wait/wake pairing, and no reason to follow JS)

MR: Wasm is it’s own language so it doesn’t need to follow JS.

### Closure
"
simd/2023/SIMD-01-20.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the Jan 20 video call of WebAssembly's SIMD Subgroup

- **Dates**: 2023-01-20
- **Times**:
    - 4pm-5pm UTC (9am-10am PDT)
- **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this [form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking
1. Adoption of the agenda
1. Proposals and discussions
    1. Phase 4 preparation, review of spec text update with profiles
1. Closure

## Meeting notes

### Attendees

- Andrew Brown
- Deepti Gandluri
- Justin
- Marat Dukhan
- Richard Winterton
- Thomas Lively
- Yury Delendik
- Zhi An Ng

(Probably missed a couple of names)

### Phase 4 preparation, review of spec text update with profiles

ZA: The spec text now includes text to talk about profiles, cherry picked from Andreas’s change which is a super set of the relaxed+deterministic semantics with a deterministic mode. The changes needed to support profiles are not extensive.

https://github.com/WebAssembly/relaxed-simd/pull/115

ZA: Relaxed swizzle, we already have the deterministic instruction. 

MD: The only ones that don’t have a deterministic version are FMA, and Dot product instructions

ZA: If we try to spec a deterministic FMA, we get back into the same conversation as before. The intermediate results, and range is different for a deterministic Dot product instructions

MD: But we probably want to think of ideal semantics

JM: personally thinks this looks like a good solution, seems like it is not imposing any problems we had, no slow emulation, no trapping, nothing weird, probably not that likely to get in the way of developers. the most conservative thing. if we decide to spec a deterministic mode for these instructions, it will be adding instruction to deterministic mode, doesn't break compatibility. Graceful degradation has been part of the web's DNA, Wasm doesn't have a solid story there yet.

DG: ask JM a clarification qns, what are you thinking of when you say graceful degradation w.r.t. this proposal

JM: places where you want to run this Wasm code, can't expect latest version of this engine, they can't ship all at the same time. Compounded further when users run unsupported OS, in embedded might not have new version at all. In Wasm, you build as many binaries as you support. Hard to test and ship multiple versions. Incentivizes us to implement instructions that might not be the best due to compatibility concerns.

DG: we tried to have a good answer for feature detection and conditional sections, a nicer way of detecting support. Agree that we have to work on this in the future. From the CG, in the environment where they want det, and they want to leverage FMA, the root of deterministic FMA is outside the browser. If we put this out, what feedback will we get from the CG? If we have deterministic fallback for some, and some outstanding ones, how does that look? How do we proceed with making sure we don't get feedback from folks interested in having an FMA, not sure what they will do if they are omitted in deterministic mode. Put deterministic FMA as a follow-up proposal. See if we can include them.

TL: First, the spec mechanism for the profiles looks great, and the guidance on how it’s supposed to be used looks great, subsets look good as well. The way it used in the doc is to remove the instructions, another way to be using this is to annotate the results in a way that fits the deterministic profile. For the instructions that are deterministic, there are fall backs in the profile, we could pick deterministic results

ZA: Decided to do this while I was writing the spec, because it seemed cleaner. The naming is another complication, where it’s not clear which one we would pick. 

TL: We can annotate it in the semantics, we wouldn’t need separate binaries in that case. And they can alias the other instructions in the deterministic mode

ZA: We could do that.. Either way it’ll be simpler

DG: if we alias, we will provide det semantics, open up can of worms

TL: for instructions that do not have det semantics, we can leave them out

DG: this is more conservative, maybe get more feedback from people who want to use it in deterministic mode, we can't avoid having 2 separate binaries

TL: if you leave out some, you might as well leave them all out, more feedback will be useful

MD: I would prefer to have instructions in the deterministic instructions in the deterministic mode

TL: web engines will never be running in det mode

MD: maybe in incognito

DG: not sure if we have a way to do that, privacy means not storing any user data, there is some vague fingerprinting issue, don't think we will do any different way in incognito in the engine level, at the renderer level it probably can. At least in the near term we don't expect to support deterministic mode at least in Chrome.

JM: don't think Safari would do this either, probably will be helpful if websites were compatible. Large barrier to entry if you have to implement all these instructions, small browsers, or browsers running on different platform

RW: RISCV is interesting, say there’s an ISA that came out that required a different

DG: orthogonal, with a new ISA, engines will have to do a bunch of work, will add extra overhead, in the scope of previous SIMD proposal, we are targeting a bunch of Intel and ARM devices out in the market, targeting speedups in real world. Still doesn't change the scope of this proposal, useful in the subset that we are targeting.

RW: wonder if there will be a change in the design if we know a new ISA design coming out.

JM: For SIMD, working on shipping it right now, it is an enormous engineering task - running the SIMD version is 10% slower than scalar? It makes sense to leave some set of the semantics on the deterministic mode open. We should gather more data from Wasi, or other folks that might use this before we commit to moving in one direction or the other

ZA: Any concerns with presenting at next CG meeting and phase 4?

DG: will be good to present, share updates, and discuss. Summarize in GitHub issues, cc interested stakeholders.

DG: standards opinions, any intent to ship soon?

YD: yes, want to ship thi

JM: no comments on future release, will take a while to implement
"
stack/2021/sg-6-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 14th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  June 14th, 16:00-17:00 UTC ( May 17th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
KC
Sam Lindley
Andreas Rossberg
Ross Tate
Luke Wagner
Thomas LIvely
Zhi An Ng
Emanuel Ziegler
Alon Zakai
Rick Battagline
Thibaud Michaud


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. Effective Programming in OCaml by KC Sivaramakrishnan [paper](https://kcsrk.info/papers/retro-concurrency_pldi_21.pdf)
   1. Next meeting [2 mins].
1. Closure

## Meeting Notes

FM: this is dynamic scoping isn’t it? Of the effect labels

DH (chat): yes

KC: what do you mean?

FM: if the function itself has its own scheduler, a tree of coroutining, each level of the tree is another coroutining set. You rely on dynamically going up each level each time

KC: yes that’s right. In terms of matching on the effects, this is just like exceptions. If you handle the exception within the function, you handle it, if not it forward it to the outer scope

AR: just like with exceptions

FM: same problem as exceptions as well

KC: yes, think about restartable exceptions

FM: one of the effects of this is that it might slow down FFI calls, how much does it do that?

KC: we see 15% more retired instructions if you call into these c functions, compared to stock ocaml. These effects are hard to measure in terms of time. We can make C calls really fast, if the arguments are all in registers, we have the current stack pointer of the system stack offset in a global variable, we can load global variable, save rsp… There are fast paths here for non-allocating functions, because OCaml is a GC language, you might need to save state, if C function allocate and trigger a GC, if not we can optimize it.

FM: what about when calling OCaml from C?

KC: the separate fiber 2 and 3, we end up using the same space if we can, we don’t end up paying allocation cost for every time we do a callback. Callbacks are infrequent, calls to C are frequent. We have to make OCaml -> C faster, C -> OCaml takes 40% more instructions compare to stock ocaml

RT: what do you do about parallelism if there is 1 system stack?

KC: each of them have their own stack, no synchronization. One such structure and layout for each of the domains

RT: no shared state?

KC: yes, this doesn’t need any shared state

RT: in general, you can’t have a global var that stores the current c stack

KC: global variables are domain local variables, maintained in registers, points to a table of domain local variables, the C stack pointer is just and offset there

SL: previous meetings, work stealing schedulers came up, continuations need to move between domains, is that something you looked at?

KC: we just implemented a very fast work stealing, with support for blocking, in one of the multicore libraries. There is no affinity for the fibers to a particular domain, you can freely move them around

RT: the concern is, javascript references stored on fibers, then you can’t move them to other domains.

KC: yea we don’t have that same problem

RT: everything was in local cache?

KC: possibly. We ran this program 13 times, first 3 times was to warm up the allocator, then we measure the average of the rest of 10 mins. So yea I can believe that the program has everything in cache.

RT: if they are reading from memory, then they would be slower

RT: this is special case of bidirectional algebraic effects, anything more general?

KC: no. We have a way of saying to perform this exception… we haven’t come across a need for it (general)

FM: does that mean this example baz is incorrect? (Slide on Linearity)

KC: compiler will accept this code, but this is not code that we want you to write

SL: imagine a sophisticated linter that says this is bad code, or not very sophisticated in this case

FM: it is obvious because you have underscore

SL: you can look at the RHS that doesn’t use the continuation. If you have more intricate control flow it is harder

KC: common example is you enqueue it, then drop it on the floor. We played around with installing a finalizer on every captured continuation, we have GC, if you don’t resume it, we discontinue with an exception you cannot catch. It turns out to be 4x more expensive, the finalizer is too heavy for us. Using GC is not for fixing this. If you have a linear type system you won’;t have a problem.

AR: finalizer will make GC observable

KC: not a great idea, just wanted to see what the tradeoff was

RT: you mentioned efficient exceptions, when do you do bt for exceptions

KC: what do you mean? You want a backtrace for when the exception was raised? If backtraces are on, when you raise exception, when you go through a function, you build up the backtrace as you unwind the stack

RT: same as python, if you catch exception, move to a different spot, will you collect

KC: we have a separate primitive you can do that, raise and reraise, which allows you to continue building the backtrace from where you left off. This is useful when you have async/await, your thread throws an exception and propagate through await thread, otherwise you see a truncated backtrace.

RT: when you say throw, you don’t accumulate the entire trace at that moment?

KC: no, we build as we unwind

RT: special handling for tail resumptive?

KC: no, standard tail call optimization, we don’t run those functions, we always switch to the handlers, no fancy stuff. It doesn’t matter, if doing stack switching, you’re doing something interesting. If you suspend to do an I/O, which is what we care about, async I/o, generators, we don’t optmize fo that.

RT: majority of effects in Leijn stuff is tail resumptive

SL: if composing lots of effects together, underlying are not, the ones on top are tail resumptive

SL: what lessons can we translate to the Wasm stack switching design

KC: I am still in favor of an approach like libmprompt. Because we cannot move stacks around. 

Don’t anticipate supporting multi-shot continuations

### Adoption of the agenda

### Discussion:

### Adjourn
"
stack/2021/sg-5-3.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 3rd video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  May 3rd, 16:00-17:00 UTC ( May 3rd, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants

Francis McCabe
Paul Dworzanski
Ross Tate
Sam Lindley
Zalim Bashorov
Alon Zakai
Daan Leijen
Thomas Lively
Luke Wagner
Lars Hansen
Thibaud Michaud
Ryan Hunt
Derek Schuff
Rick Battagline
Andreas Rossberg
Adam Klein
Emanuel Ziegler
Heejin Ahn


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. A Two-pronged roadmap (Ross Tate) [27mins]
   2. A Risk analysis for implementing Stack Switching in V8 (Francis McCabe) [Slides](https://docs.google.com/presentation/d/114dMzeEdPKC3PeV8_EIo93UP3McfAFxZAQHMTQdBhJQ/edit?usp=sharing) [27mins]
   3. Next meeting [2 mins].
1. Closure

## Meeting Notes

### Adoption of the agenda

### Discussion:

#### A Two-pronged roadmap (Ross Tate) [27mins]

Slides [(pdf)](presentations/2021-05-03-tate-two-pronged-plan.pdf) [(pptx)](presentations/2021-05-03-tate-two-pronged-plan.pptx)

FM: Want to note that we’re not backpedaling on stack switching, even if it ships second.

FM: “May” return a promise? Even though JS is not statically typed, individual functions will expect a promise.

RT: Have seen multiple designs; In JS it’s a common pattern to check if a value is a promise and if it is, you await and otherwise you just run with it.

SL: Won’t that be annoying for the caller?

RT: There’s already standard library functionality for handling this.

AZ: In the use cases I know of, the imports could be statically typed as returning a promise or not. Otherwise this looks good to me.

SL: I’m trying to understand what a stacklet is here.

RT: In delimited continuation space, you have a stack which is essentially a linked list of stacklets.

SL: But in JS you only have one stack.

RT: In this setup, only WebAssembly is ever run on a separate stacklet.

FM: We have a constraint that there shouldn’t be JS frames on a stacklet. If a call deep inside C++ calls JS, how does that switching story work?

RT: That calls an import. The engine provides a stub between the actually provided import function and the WebAssembly call and the stub handles the switching back to the main JS stack.

FM: So when you call JS, you’ve already switched out of your WA stack.

RT: Yep.

FM: When you combine lazy loading and stack switching, does the stacklet in the API become privileged?

RT: Looking forward, this should all be able to be done in Wasm directly.

RT: TL, you’re working on lazy loading. Does this extension look good for that?

TL: Yes, we definitely want the lazily loaded modules to be on the same stack as the original modules, but we need to be able to wait for the lazy load to resolve. As far as I can tell, this design would allow that.

SL: Do you anticipate shipping the basic JS API and this extension together or separately?

RT: Together.

AZ: Why can’t calls from one Wasm module to another implicitly use the same stack?

RT: That might work, but I’m not sure. There’s a semantic difference between synchronous and asynchronous imports that return an externref, which might be a promise that either is or is not awaited. The different stacklets define the boundaries of suspended chunks when promises are returned.

FM: Looking to the future, when we’ve done the Wasm side of this, is it going to be possible for Wasm-generated stacklet to be an argument for instantiateAsync?

RT: I don’t know. We’ll have to take a look at the design space.

FM: Regardless of the order of things, we’ll need a JS API anyway, so this isn’t wasted work.

RT: Agreed.

SL: Is this at all controversial?

LW: I was wondering what the logical diff between the JS API you presented and the one I presented a few meetings ago. Wondering how the stacklet concept helps. If there’s no first-class stacklet, you can switch only when you go back to JS, not just Wasm.

RT: My understanding of your design was that it wouldn’t work for this.

LW: The bindAsync is an explicit stack cut point, so everything is explicit and it should work.

RT: Will have to think about this. It’s possible there’s no real difference after all.

SL: Luke, is there a more detailed spelling out of the design in your presentation?
LW: No, it’s all just in the presentation.

TL: It would be helpful to see the two JS API proposals side by side.

FM: If the two-pronged approach sounds good to everyone, that sounds like a good thing to do in a future presentation.

#### A Risk analysis for implementing Stack Switching in V8 (Francis McCabe)

[Slides](https://docs.google.com/presentation/d/114dMzeEdPKC3PeV8_EIo93UP3McfAFxZAQHMTQdBhJQ/edit?usp=sharing) [27mins]

DL: There are lots of places where people make assumptions about the stack growing down or being contiguous, etc. For example a debugger might cut off the back trace when it is not contiguous. There are probably other places. I talked with (???) from the blog(?) and they said that inside Windows they have the same problem with hidden assumptions.

SL: Is V8 deployed in 32-bit environments?

FM: Yes. We’re very concerned about supporting billions of low-end phones.

LH: About control flow integrity, can I copy a stack somewhere else as long as I copy it back before returning to it?

FM: No, because that looks like return-oriented programming.

DL: OSes usually have an exception for longjmp and could in principle have exceptions for safe APIs we come up with.

FM: Windows has a Fibers API, Linux has something similar. It’s worrying that we would have to modify the OS to get stack switching to work on Wasm. That constrains the deployability of Wasm stack switching. On Windows, it seems the Fibers API is not a major supported API within Windows.

DL: That’s right.

FM: It’s deprecated but still there or something.

FM: Would love to hear if there’s anything I’ve missed. In many conversations, things we thought wouldn’t be important turned out to be important.

LH: We should talk about whether millions of stacks is reasonable. If there are that many, then it might not make sense to make them old objects.

FM: This is a reason to talk to lots of language people. Erlang folks were talking about 65k processes. Java’s Loom project anticipates ~1m virtual threads.

RT: We may have to consider multiple notions of stacks for different use cases.

FM: Maybe, but I hope not. The most important thing is to identify the risk factor first, then figure out a solution.

### Adjourn

"
wasi/2020/WASI-11-19.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the November 19 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: November 19, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: hello@sunfishcode.online

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Review of action items from previous meeting(s).
    1. Ralph Squillance to write up a draft on ""WASI experimental"" or
       versioning for WASI API experimentation.
1. Removing support for `seekdir`/`telldir` from wasi-filesystem
    1. https://github.com/WebAssembly/wasi-filesystem/issues/7
1. Filesystem Case Insensitivity
    1. https://github.com/WebAssembly/wasi-filesystem/issues/5
    1. https://github.com/nicowilliams/ietf-fs-i18n

## Meeting Notes

### Attendees
- Peter Huene
- Sam Clegg (SC)
- Lin Clark (LC)
- Andrew Brown
- Dan Gohman (DG)
- Sergey Rubanov
- Syrus Akbary (SA)
- Matt Fisher
- Eric Rosenberg
- Ralph Squillace (RS)
- Till Schneidereit (TS)
- Harun Oz
- Pat Hickey (PH)

### Action Items from Last Week
RS: had conversation with Pat and Dan about how people are testing out experimental proposals. Pretty obv that we wanted to use these experiments for inputs. At same time, second issue was wanting to be very clear that none of the experiments were destined to the spec

Wanted people to be able to play with sockets in Krustlet. Dan proposed creating an experimental namespace. Ralph will now begin tackling the doc. Will talk with Fastly about how they are handling exp.

DG: need standard convention for naming

SC: Are you talking about system level imports?

DG: We have wasi_ naming convention. Should be a naming convention for things not in snapshot yet

RS: That makes sense. Explicitly not destined to be migrated. Signal that these are things to be used as ways of stimulating thought. Kind of a firewall between these and what’s going into the spec.

DG: One additional thing—some prior art wrt web standards e.g. vendor prefixes. We can probably avoid

SC: How would we avoid. By not shipping prod VMs with them enabled?

DG: Yes, or behind flags

TS: Situation might become slightly different once module linking and ability to virtualize comes in. Then you could say you don’t need to ship as long as you provide a shim implemented in user space

SC: presumably not the module name

PH: unfortunate that there’s only one name

DG: Module linking has concept of nested modules. Might be useful

PH: That’s used for definitions but not for imports.

SC: You can chain imports

TS: IIRC you have to re-export

DG: typically you do, but … if we don’t have this, then mangling

PH: we need this before module linking lands in any toolchain. 

From chat: 
wasi_experimental_tests?
wasi_experimental_temp?
From Pat Hickey to Everyone:  12:16 PM
wasi_experimental_<modulename> for a mangling scheme

**ACTION ITEM: Ralph will compile doc**

### Removing support for seekdir/telldir from wasi-filesystem

DG: from days when OSs used flat lists. Now they are BTrees. These have become awkward abstractions.

DG: want to remove from WASI altogether. Can’t do a 64 bit seekdir. In order to satisfy POSIX, we’d need to do some complicated indirection. Theoretically possible, but think better to remove altogether.

SC: Proposal is just to remove, not emulate in user space?

DG: I don’t think it’s worth it unless use case

SA: Don’t have context, but what do you think wouldn’t be possible?

DG: ls will work. This is why I’m asking whether anyone has heard of someone using this. Scan through, then restart from beginning, and then keep going is pretty rare. This originated when it was hard to keep file in memory at same time

RS: What’s request? Could potentially search GitHub. There are tools

DG: Found a million hits in code, a lot are libc code

SC: Yeah, we’ll need to skip headers and impls

TS: Have experience from TC39. People have tried to use as code search, but there’s quite a lot more dark matter that’s not in public repos, and also test suites are copied all over place and not ways to exclude. Perhaps possible to do regex to exclude

RS: Both MS and GitHub have internal tools for this. GH is strongly motivated to make this work. If we can write a user story that’s in the sweet spot, I will see what can be done as a feature, either privately or as a preview test, or ultimately as a public feature

DG: That feature would be really useful for other questions too

RS: I do need a user story to pursue in an aggressive way, but I think they actively want user stories.

DG: WASI libc is already trying to guess what you’ll need.

RS: Side issue—feature set is that we want to know what the community is using.

DG: Roughly the plan for removal is to remove from libc. Second step is to remove from WASI itself, removing parameter and introducing rewind call

**ACTION ITEM: Ralph will use internal tool to search for use**
**(possible) ACTION ITEM: Put together user story for feature that would allow WASI SG to search for usage of other APIs**

### Filesystem Case Insensitivity

DG: GitHub repos and offline chatting. ONe question, what is the goal of the ___ API Fully deterministic? Will behave same way across all platforms. 

DG: People want to access existing files that already have their own restrictions. Hard to abstract away. If we can assume WASI runtime owns filesystem, could do a lot, but if we assume you have your own files, we have to pass it on to applications. Somewhat unfortunate, but after a lot of discussion think we’re going non-deterministic. Best we can do is good debugging tools. Those wouldn’t be part of the spec, just side debugging tools. Disappointing from the Wasm perspective, where we try to be deterministic. Not within our power at the WASI level to choose one side

DG: Also want to mention, link in meeting notes that will hopefully turn into an IETF proposal that will define portable semantics

### Additional Questions

SA: One quick question. What do you want me to do with the logo

DG: Researching IP rules

LC: I can help with this and serve as point of contact

SA: Lmk if you need changes to the PR

"
simd/2022/SIMD-03-18.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 18th video call of WebAssembly's SIMD Subgroup

-   **Dates**: 2022-03-18
-   **Times**:
    -   4pm-5pm UTC (9am-10am PDT)
-   **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this
[form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1.  Opening, welcome and roll call
    1.  Opening of the meeting
    1.  Introduction of attendees
1.  Find volunteers for note taking
1.  Adoption of the agenda
1.  Proposals and discussions
    1.  Relaxed SIMD Progress updates (Zhi An Ng)
    1.  AOB
1.  Closure

## Meeting notes

### Attendees

- Zhi An Ng
- Yury Delendik
- Lars Hansen
- Andrew Brown
- Richard Winterton
- Thomas Lively
- Petr Penzin
- Johnnie Birch

### Relaxed SIMD progress updates (Zhi An)

Instructions are mostly complete, though Marat is going to add bfloat16 (?) operations.

Need to implement reference interpreter, Zhi An has provided initial implementation. Changes to test infrastructure has been made, though we don’t have full test coverage (not a phase 3 requirement). Spec text isn’t a requirement, though we made progress on that as well.

AB: feature detection, lots of comments

TL: need it to settle down, then need implementation, no plans for that yet, trying to hire people

AB: which part?

TL: toolchain side, depends on where the proposal ends up, engine may be trivial or complex, will want opinions from this group, any specific direction we should push on

LH: we should scope it to the use cases we have, not try to cover everything we possibly ever want. Some type of function level proposal seems to have some traction. Whether we want something local to the code section or some global ifdef.

TL: hope that doesn't block progress

PP: yea don't think it does. For feature detection, few people in CG were suggesting ""is this fast""?

TL: it could be a separate structure, need a broad structure of how feature detection looks like, then follow up with ""fast""

PP: outside of this group, few people want that, we might not care. Ben and Luke bring this up every time we meet.

AB: doesn't block us for phase 3, but blocks the long term progress of this thing. Don't think this goes the whole distance without feature detection

ZA: if we ship relaxed simd first, feature detection after, they are compatible, we can start using feature detection to detect relaxed simd

PP: thought the other way around, we should use it before we ship it before the standard

TL: if it were available, we would use it, it looks like path to standardize relaxed simd is shorter

PP: AR has some idea about profiles, are we considering that?

TL: had a presentation, but no follow-up proposal, or details, current state of feature detection does not include that.

PP: Can we collapse lists where the same element is repeated more than once?

AB: Can we add a comment or a description that `signed(j)` means that top bit is set? Otherwise people reading would have to make mental mapping for those.

ZA: We can try add this, I am used to working with the spec, so it feels like the rest.

PP: Maybe use `top_bit` instead of `signed`, though it isn’t obviously that one is better than the other.

LH: how much can we change this? last row is

ZA: first 3 rows are not as important, can add cases

PP: are nans canonical? if we canonicalize we might not get this in one instruction.

PP: a little concerned about notation, someone might look at it and not understand/follow it

ZA: any other questions?

PP: a little concerned about notation, but this is probably the best we can do now

ZA: yeah, the spec text can still be tweaked

### AOB

TL: PP was saying we didn't bring up the is fast feature, will be helpful for me to get more perspective there

RW: provided some comments on the is fast thing, could be useful, but we kinda want to use feature detection thing

TL: we want proper feature detection, will additional is fast feature useful?

LH: i think v8 scalarize?

TL: we don't do that anymore

PP: BT's interpreter will scalarize. It feels useful, even for differences between platforms, standard SIMD case. Can open door for things for scalarizing everything and is slow

RW: XNN does some initial testing before they kick things off, can move it to application side for them to determine. libyuv does that too, detect and fallback

PP: not done in official manner, they know what instructions gives different result

LH: comes back to what we said before, user define bits in feature vector

TL: wonder if we have multiple users doing more specific detection to use different code paths

PP: i expect someone else is already doing this

RW: what's the advantage in moving it down

TL: advantage of feature detection at the core, can do that at the application level and pull down different modules.

PP: the fast thing, on arm v.s. other platform

LH: nothing is fast, variable width bit shifts on intel, won't do so much better if you scalarize, different algorithm. is fast doesn't buy you that

TL: xnnpack detects arm/intel, use SIMD, but use different code patterns, more complicated than is_fast bit, tricky to specify

PP: tricky to specify, need a discussion about those use cases specifically, you would run app in profiler, change to suit platform, avoid shuffles on intel, not fast.

TL: user definable bits in the bit vector, big feature of conditional sections, not sure how we would build that into clang

PP: usually done for math libraries, rather than user code

TL: clang has support for that, multi versioning, user facing toolchain feature folks will use, compile down to feature detection proposal. don't know how custom bits in the feature vector will integrate with that at the source level, what do you put on the multi version attribute

PP: intrinsics, same as using cpuid, my first reaction for feature detection is that we need cpuid

RW: is fast is subjective, feature detection is objective, is fast is an app-ish type of thing.

PP: is fast, different cost, certain semantics

TL: no need for is fast, user defined bits to doing specific platform detection up front

PP: bring up that is fast is not just a binary, some kind of number

TL: the more detail we put into there, more difficult

ZA: you might need is fast for every instruction

PP: encoding cost
"
gc/2022/GC-07-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 12 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: July 12, 5pm-6pm UTC (July 12, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Type hierarchy and usefulness of [`wasm`](https://github.com/WebAssembly/gc/issues/307#issuecomment-1178371115) [#307](https://github.com/WebAssembly/gc/issues/307)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Conrad Watt
- Rick Battagline
- Justin Michaud
- Luke Wagner
- Sergey Rubanov
- Slava Kuzmich
- Alon Zakai
- Andreas Rossberg
- Ilya Rezvov
- Francis McCabe
- Jakob Kummerow
- Manos Koukoutos
- Zalim Bashorov
- Emanuel Ziegler
- Sabine Schmaltz
- Ryan Hunt
- Asumu Takikawa
- Igor Iakovlev
- Adam Klein
- Deepti Gandluri
- Yulia Startsev


### Discussion

AR: Two constraints: uniform representation for internal and external references and also representation of different values must not overlap across intern and extern. That second constraint only matters for unboxed values, since boxed values are trivially disjoint.

AR: Titzer (not present) had argued that we need empirical data that keeping the types separate is useful.

JK: I would flip that around and say we need data to support having the uniform representation.

LW: Agree, all engines would have to change slightly to support the uniform representation. Wouldn’t want to have any performance consequence for the convenience of the spec. I think someone already proposed this.

AR: I proposed the option of keeping all of intern, extern, and func separate, since if we’re ok with any separation, we might go all in.

CW: Difference is that extern and intern mirror what modules already have to do on the boundary. There will be a class of hosts that could avoid work on the boundary even if not all hosts would be able to, and we should reflect that in the type system.

TL: If we go with the solution with three separate groups, are there any immediate problems we would run into?

CW: There might be some danger about breaking case analysis by moving func under anything.

JK: I thought we had consensus that the current func was unlikely to be directly usable and that we might add something like closure ref in the future. So I’m not worried about making unsafe changes to the current func.

AR: Would be unfortunate in practice if we introduced a new incompatible func type and old APIs became incompatible.

TL: Any objections to moving forward with the three separate types?

AR: I slightly prefer the uniform representation design, but I’m ok with this as well.

JK: For JS API, we could mandate use of extern rather than intern on the JS boundary.

AR: That would be bad for composability.

CW: Would work, but you’d need a wrapper module giving extern type signatures for use on the Web.

AR: Already went over why you want to use `intern` (we should call it `any`) wherever you’re not absolutely sure you’re dealing with an external value.

CW: Agree that we should do conversions on JS boundary. Unfortunate that `any` wouldn’t include `func`.

JK: Will have to think about it more offline, but maybe we can have lazy externref to avoid extra conversion costs.

AR: Would have to pull the laziness down into the intern type, which is not what you want.

CW: Agree in principle, but we can’t stop engines from doing whatever they think is fastest.

AT: If we go with the three-prong design, when we extend it, would we expect new types to go under the intern type? For example, with stringref, would it go under extern because it’s more of an external thing?

JK: Would expect that to be an internref with easy conversion to externref.

AR: Extern would always be completely opaque.

JK: As a corollary, we will never have subtypes of extern.

AR: Could actually have subtypes to constrain which internal references the extern references are extern versions of.

LW: Also for type imports we will want T <: extern.

CW: There has been some chatter about how externref will help with DOM interaction. Between that and stringref, how close are we to “solving” the DOM interaction problem.

LW: Need a way to pass receivers and a way to create typed array views without calling out to glue.

AR: Wouldn’t you want a way to access DOM objects as well?

LW: Imported functions solve that. Just need to “unwrap” the DOM function inside the JS wrapper. For example, when importing sin we can call it directly without going through JS because the signatures match up. There could be some JS API for configuring this (and it could also tie into JS promise integration).

AR: Why wouldn’t this work for strings as well?

CW: You want to munge strings from Wasm.

LW: Order of magnitude difference: string operations should be a few machine instructions, DOM calls may be more involved. Feels like a difference in kind.

FM: The WebAssembly JS Types is owned by Till, but he’s not active. The JS API Luke was talking about is potentially useful for stack switching, but it would depend on this phase 2 JS type proposal. We need someone to pick it up.

V8 and SM both implement but do not ship WebAssembly.Function

DG: Background: we tried to find a new champion, but until very recently there was no pressing use case. With compelling reasons we can find a new champion and push it forward.

AT (chat): IIRC type reflection is also missing a story on how it will integrate with types funcrefs and typedefs in general.

YS: I volunteer to champion JS types, but could use some help.

DG: I can help.

TL: To recap, we have consensus to move forward with the three-prong solution. We can revisit once we have very concrete user feedback, but it should be a high bar. Next discussions are about `wasm` type that Ben wanted, specifics of casting and conversion discussions.

JK: Also bikeshedding type names.
"
main/2018/CG-09-18.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 18 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: September 18, 4pm-5pm UTC (September 18, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email JF Bastien or Ben Smith to sign
up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Alex Crichton
* Alon Zakai
* Andreas Rossberg
* Arun Purushan
* Ben Smith
* Dan Ehrenberg
* Francis McCabe
* Jacob Gravelle
* Jay Phelps
* Keith Miller
* Limin Zhu
* Luke Wagner
* Michael Holman
* Mike Rourke
* Nick Fitzgerald
* Pat Hickey
* Richard winterton
* Sergey Rubanov
* Thomas Lively
* Till Schneidereit
* Tyler McMullen
* Yury Delendik

### Find volunteers for note taking (acting chair to volunteer)

Ben takes notes.

### Adoption of the agenda

### Proposals and discussions

#### Review of action items from prior meeting.

BS: [Discussing how to make the CG meetings more inclusive](https://github.com/WebAssembly/meetings/issues/304)

TL: I’ve not been around for a lot of the context. Sometimes discoverability for the decisions is difficult. Past notes are hosted, but it is hard to search. Wondering if we make it easier for people to discover context, if that would help get people up to speed.

JG: Maybe a tagging system using GitHub?

TL: I like this idea, but may require splitting up notes.

JP: A couple of the TC39 proposals, they’ll create a FAQ/discussion doc, which they’ll update with conversations and discussions. A lot of the tc39 proposals get really complex, repeated questions. I don’t know if that applies here to us, but it would be useful to distill common topics and backstory. I have questions about things like that -- I haven’t dug in super deep, but it would be useful to have decisions like that.

SR: Would be good to have something similar to https://github.com/tc39/proposals

TL: It’s nicer to have some way to watch without having to watch the entire design repo.

DE: It could be helpful to have status updates from ongoing repos. It seems like design discussions take place somewhere else.

AR: Some proposals are maybe just not making much progress. Some are just blocked on engine implementation.

DE: Maybe just go through proposals and talk about them, people can maybe help with implementation

FM: Is there an owner? [BS: yes] maybe they should be pushing it. Maybe not scalable.

DE: Sometimes difficult for that to happen in a committee like this.

DE: Another topic: [Allow optional asynchronous steps after instantiation?](https://github.com/WebAssembly/spec/issues/741)

What this patch does: when different webassembly implementations go off to do more work later. They need to yield to the event loop -- JSC differs from some other browsers. This patch removes some queueing. We discussed this some in issue 741. Keith Miller brought this up in IRC, from 6 months ago. I was delayed in rebasing and relanding.

Any opinions about this PR?

JP: Looks Ok at first glance.

DE: If your a developer, this might matter to you because it says when an event loop turn will happen. It basically says use instantiateStreaming instead of these, if you use another API it will take a pause at a different time.

BS: Emscripten already calls instantiateStreaming and falls back to instantiate, so many developers may not even know. [NF: wasm-bindgen does this too]

LW: What is the net effect here?

DE: It removes some event turns and adds some different ones.

When instantiating a module it would queue a task, but now it optionally enqueues task. WebAssembly.instantiate.

LW: And that’s observable because instantiate calls the start function.

KM: I think that wasn’t in the spec before, it used to be in the same turn, but that’s too constraining. We took advantage of the fact that we had a turn there.

DE: I think that’s the main change.

KM: I think there’s a risk for optional turns, then people implement whatever Chrome did, and then everyone else has to follow.

DE: It’s observable, but I haven’t written tests for this

LW: Bumping a counter during each state.

DE: You can overload promise.then, but what makes this difficult is all the different possibilities and optionality. I just wanted to document the shared practice and leave it at that.

LW: Maybe this should be fully defined and then specify that.

DE: We would have to come into agreement then.

LW/KM: We just specify when a turn happens.

DE: We could say that they all have to take a turn in the event loop.

KM: Promises will be optimized since people will be using them anyway, so I’m not too worried about additional turns.

DE: They happen at a different layer, in the DOM instead of in JS.

KM: At least in JSC and WebKit, this is just two queues in the same run loop. Agree that it’s more work, but I’m not sure how much it really matters.

DE: Two different ways we can go forward here. Encode the current practice, or try to get engines to align.

JP: Is the import object live?

KM: Unclear. JSC currently does it on the same turn as the start function.

LW: It makes sense that messing with the import object is at the same time as the start function, but not the same turn as WebAssembly.instantiate.

JP: How will this impact -- if you synchronously instantiate. If you are not using a start function, and your own convention. How does that work?

KM: All the engines in the sync compilation will just block.

JP: In the synchronous instantiation this doesn’t apply, OK.

DE: Great this is good direction, thanks!

### Closure
"
stack/2022/11-21-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 21st video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  November 21st, 17:00-18:00 UTC ( November 721stth, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Brandan Dahl
Ross Tate
Ilya Rezvov
Thibaud Michaud
Thomas Lively
Daniel Hillerström
Luke Wagner
Deepti Gandluri


## Agenda items

1. Brainstorm: examine [greenlets](https://github.com/python-greenlet/greenlet) as a use case for stack switching


## Meeting Notes

Ross introduces the use case using [slides](https://github.com/WebAssembly/meetings/blob/main/stack/2022/presentations/2022-11-21-tate-python-greenlets.pdf)

FM: You can’t move greenlets between threads?

RT: That’s what it looks like. Because they assume that C stack frames can’t be moved between threads.

TL: Are “threads” real threads?

RT: yes

TL: Are they python threads with the global interpreter lock?

RT: Yes, I think so.

FM: Does target.switch have a return value?

RT: Yes. Same with target.throw.

DH: Is the parent controlled by the library or user code?

RT: The C++ runtime code sets it up for you.

DH: What about the finalizers? Do they run non-deterministically?

RT: Yes. And all the stuff about the dead greenlets is also implemented in C++ as well.

FM: Do you happen to know if libraries are relying on this pass-through for switching to dead greenlets?

RT: I do not know how much they rely on any one of the individual features. I suspect that the better documented features are the ones that are used. This one was explicitly documented.

FM: It’s kind of bizarre.

RT: I guess it works for them. Since greenlets form trees, you have to consider where control goes if a child or parent is dead. Maybe that led to this design.

FM: We have to be careful. This is what people are doing, whether or not it’s a good idea.

TL: I think this could be implemented on top of any design we’ve discussed so far. With stack switching, obviously greenlet switching could use the direct switching. With delimited continuations, would have a broker thread with children for each greenlet. Incidentally, this is the same pattern Emscripten uses to spawn new threads, so I think it’s common. No matter what design we use, there will be user-level data structures representing all the Python data structures. The WebAssembly design only affects the handwritten Wasm that implements the switch itself.

FM: Even with direct switching, you can’t use the Wasm design directly because of the dead greenlet semantics.

TL: Right, those would be represented by the in-memory Python objects that haven’t been garbage collected yet. Python-on-Wasm is implemented by compiling CPython with Emscripten, so you could link the switching code directly into the Emscripten program.

TL: To generalize, we have to lower all sorts of different source semantics to Wasm. We shouldn’t aim to encode any particular language directly in Wasm. If there is some “emulation” and user-level coordination, that’s working as expected.

FM: Want to push back on that. If you’re trying to lower your language, you’ll do progressive lowering of your semantics. At some point they hit metal, i.e. WebAssembly or ARM, etc. Ideally what we want then is the ideal instruction at that point in the lowering. Our task is to meet them there.

TL: Runtime libraries are codeveloped with compilers, so it’s ok if lowering bottoms out as a call to runtime functionality rather than a single instruction.

RT: For the greenlets library, that runtime code for switching cannot be directly translated to WebAssembly because it assumes that stack state is available in linear memory. You have to change more code for porting to Wasm than for porting to other normal ISAs.

FM: The cutoff point for the platform-specific code is different for Wasm. The lower that point is, the closer it is to a normal ISA, the better. If you impose policy on the engine, that’s going to affect this porting process, so there had better be a good reason for that policy, e.g. soundness and safety. The higher-level the design, the higher up the compiler stack (including runtime library) you end up having to refactor.

RT: The more you put into the engine, the more you have to refactor the compiler/runtime code.

RT: It sounds like we’re all on the same page that to make greenlets work, 1) we don’t want to make greenlet semantics the same as Wasm semantics, 2) most of the C++ for greenlets would stay the same, 3) some of it would have to be translated to Wasm, and that might be more than for other ISA, and 4) they would have to emulate direct switching on top of whatever the WebAssembly design is.

RT: Hypothetically, we could consider adding a “change parent” instruction to the existing fibers proposal, but then we’d have to consider dead greenlets and all that would become our problem.

TL: Exactly, and the simplifying assumption is that there is a robust userspace layer keeping track of all that, so we don’t need to worry about it. Agree with everything you said before.

DH: I still don’t understand what it even means to change the parent.

RT: (explanation of greenlets semantics)

FM: It’s kind of an extreme, isn’t it? Does anyone know of any other system with this much mutability?

RT: I suspect that the way a lot of this is getting used is in ways Daniel was just describing. It’s not the library’s job to maintain these bigger invariants. The library just makes sure we can switch to things reliably.

DH: Do we know of concrete use cases for all this extra functionality?

RT: Not sure.

FM: I hope the greenlet author will come talk to us. Even if they do all reimplement the same structure on top of it, it would be much easier to bring the Python ecosystem to Wasm if we actually supported the full semantics of the library rather than something very different.

RT: Knowing a convention exists doesn’t help unless you know the entire ecosystem follows that convention with no exceptions.

FM: If you don’t support the full greenlets semantics, you get 180k porting projects instead of 1 porting project.

DH: I don’t think there’s a world where you can’t implement greenlets on top of Wasm, so that’s good.

FM: The big risk is making things more complicated for library/runtime authors.

### Adoption of the agenda

### Adjourn

"
gc/2023/GC-04-18.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 18 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: April 18, 4pm-5pm UTC (April 18, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Status checks
        1. Spec documents
    1. Presentation: Compiling Scheme to WasmGC (Andy Wingo, 30 minutes)
    1. Announcement and call for feedback: [Wasmtime's proposed plan for implementing Wasm GC](https://github.com/bytecodealliance/rfcs/pull/31) (fitzgen, couple minutes)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Léo Andrès
- Christine Lemmer-Webber
- Andy Wingo
- Slava Kuzmich
- Ben Titzer
- Asumu Takikawa
- Eric Patrizio
- Nick Fitzgerald
- Zalim Bashorov
- Dmitry Bezhetskov
- Justin Michaud
- Jun Xu
- Ryan Hunt
- Alon Zakai
- Ilya Rezvov
- Robin Templeton
- Ashley Nelson
- Jakob Kummerow
- Adam Klein

### Status Checks

None

### Presentation: Compiling Scheme to WasmGC

CLW (chat): I haven't officially joined the CG yet (will be shortly, account issues), but for context I'm the CTO at https://spritely.institute/ which is sponsoring / hosting the Scheme -> WASM effort, hence me joining this meeting :)

RT: likewise, i’m a compiler engineer at spritely institute, haven’t formally joined the CG yet but here to watch andy’s presentation

AW presenting [slides](presentations/2023-04-18-wingo-scheme.pdf)

AW: Would like to be able to read e.g. i64 out of i8 arrays.

TL: Nice to know you’re using br_on_cast. No one else is that we know of.

LA (chat): OCaml uses br_on_cast too :)

TL: How do benefit from the difference between mutable pair and pair if they are both mutable?

AW: Can cast to one or the other for reading or writing situations. It’s essentially a runtime flag telling me whether the Guile value is mutable or not. For example constants in the source are immutable. We can cast and handle failures. 

NF (chat): [About the virtualized calling convention] globals would probably not be worth it, in wasmtime at least.

BT (chat): I like this approach, as the engine has a limited number of registers it will use for the calling convention anyway

CLW (chat): \o/ tail calls in wasm!!!

CLW (chat): (delimited continuations are kinda like coroutines but you can resume them multiple times and you don't need to mark everything with async/await)

AW: Could give up multishot if we had to.

TL: Are the stacks represented as tables or arrays?

AW: Tables. There’s some question of whether to use a linear memory for unboxed values or not.

BT (chat): AFAIK the lightweight threads in the JVM now (project loom) also copy stacks into the heap

IR: What about JSPI?

AW: Is it correct that this suspends the entire Wasm module?

IR: Not the entire module, but just the current execution stack. You can use it to emulate the stack switching proposal.

AW: Can you have multiple calls of the same function?

IR: Yes.

AW: I’ll look into it. It would be great to have a call stack again.

RT (chat): ""beyond relooper"" paper: https://dl.acm.org/doi/pdf/10.1145/3547621

AK: If you didn’t have stringref, what would you have done with strings?

AW: I would probably use UTF-8 buffers and have to include a bit more in the standard library. I haven’t implemented enough to know how much I would save yet. I would probably give up when getting to regex.

BT: Would you not use JS strings because of the perceived cost of accessing characters via imports?

AW: That would mostly be awkward because I would have to emit JS, which I don’t currently do. It’s nice to have everything in one module.

AW: I would also have to figure out how to emit string constants as JS strings or as data segments or something like that.

LA (chat): Did you run any benchmark to compare performances on V8 vs. native code?

AW: Not yet. Goal is to have benchmarks by August to measure against Guile and other systems.

LA (chat): Is there some kind of Guile -> JS compiler right now ?

AW: There is a stagnant one that was a result of a GSoC project.

AK: How is Guile used?

CLW: The two main Schemes are Guile and Racket. We have targeted both. One of the biggest use cases is Guix (pronounced “geeks”). Besides that there aren’t very large use cases, so Spritely is making something of a bet on it. We’re writing the next generation of distributed programming, including e.g. a time traveling [distributed debugger](https://spritely.institute/goblins/). Scheme enables building these new paradigms really easily, but we also want to run our stuff in the browser. We’re excited to be participating in this group and helping other dynamic, GC languages come to the Web.

AW (chat): spritely goblins is in some ways a successor to web standards fellow traveller mark miller (& co)'s E language

TL: I would have reached first for arrays for the virtual calling convention. Did you consider that?

AW: Yes, but thought it would be slower than globals. Maybe that’s wrong!

TL: Are you using binaryen?

AW: I was initially, but found a few annoyances with things being out of date or non-standard. Ultimately I want it to be optional.


CLW: Also want to share our updates and design docs: https://gitlab.com/spritely/guile-hoot-updates, https://gitlab.com/spritely/guile-hoot-updates/-/blob/main/design/ABI.md, https://gitlab.com/spritely/guile-hoot-updates/-/blob/main/design/log.md, https://gitlab.com/spritely/guile-hoot-updates/-/tree/main/module/wasm,
https://gitlab.com/spritely/guile-hoot-updates/-/blob/main/module/hoot/compile.scm


### Announcement and call for feedback: [Wasmtime's proposed plan for implementing Wasm GC](https://github.com/bytecodealliance/rfcs/pull/31)

NF: Just want to say that Wasmtime plans to implement GC soon. I have an RFC up in the Bytecode Alliance RFC’s repo. The idea is that we can privately plug GC backends in and out and provide a few options. For example a general purpose GC based on MMTK, a semispace copying collector that integrates tightly with pre-reserved memory for FaaS use cases.

NF: Should I start giving status updates in this meeting?

TL: That would be great!
"
wasi/2022/WASI-12-01.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: December 1 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: December 1, 17:00-18:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. 'Let's Talk About: `wasi-pubsub`, and `wasi-message-queue`' by [Danilo (Dan) Chiarlone](https://github.com/danbugs)
    2. Let's talk about: `wasi-blob-store` and range requests in `wasi-keyvalue` by [Steve Schoettler](https://github.com/stevelr). Sub-topics include ""Resource handles for blobs"", and ""Designing wasi-cloud interfaces while considering variations in implementation""

## Notes
### Attendees
- Dan Gohman
- Joel Dice
- Chris Woods
- David Justice
- Steve Schoettler
- Jeff Charles
- Kevin Moore
- Kate Goldenring
- Adam Mohammed
- Colin Murphy
- Ayako Akasaka
- Dave Bakker
- Piotr Sikora


### Let's Talk About: wasi-pubsub, and wasi-message-queue by Danilo (Dan) Chiarlone

Slides: https://docs.google.com/presentation/d/1Kg5boq7L36B2Z_zM-v1tU-JB1aNb09DcZ-2JNJbFtSg/edit?usp=sharing

PR for wasi-pubsub: https://github.com/WebAssembly/wasi-pubsub/pull/2

Dan: Presentation

Dan: Proposal: Should we merge wasi-pubsub and wasi-messagequeue into wasi-messaging?

https://github.com/WebAssembly/wasi-pubsub/pull/2

Mossaka: Would it make sense to call this “pubsub” instead of “messaging”?

From Joel Dice to Everyone 09:12 AM
presumably Dan is trying to get away from pubsub since it implies topics and shared ownership of messages
From Bailey Hayes to Everyone 09:12 AM
let's dig into the wit because I think the interface might lean us more one way over the other

From Chris Suszynski to Everyone 09:13 AM
PubSub directly link to Google Pub/Sub product

From Steve S to Everyone 09:13 AM
I don’t think of messaging as specific to actors. Messaging is used for rest & grpc, and other protocols for any components. Even applies to client-server and websockets.

Joel: Kafka streams can specify where to start. Should we have an interface for that?

Dan: We could add that, though it would be a separate interface because not all impls could support it. It’s considered an antipattern in some impls. Though Eventhub could also implement it.

David Justice: I don’t think offsets are an antipattern. Log processing uses it.

From Joel Dice to Everyone 09:18 AM
being able to specify and offset allows exactly once delivery, which is extremely useful
*and -> an
From David Justice to Everyone 09:19 AM
*exactly once* or *at least once*

Mossaka: This uses CloudEvents; do we want to support other message formats?

Steve: On Cloud events: They have an arbitrary payload and a field for a mime type, so this could encapsulate any kind of message format. It could wrap anything else. 

From Bailey Hayes to Everyone 09:24 AM
CloudEvents is widely adopted
From Bailey Hayes to Everyone 09:25 AM
for projects that work within CNCF, it would be surprising to NOT see CloudEvents

From Bailey Hayes to Everyone 09:25 AM
* https://cloud.google.com/eventarc/docs/cloudevents

Mossaka: Also, the channel here has a queue and a topic, which are both identified as a string. Do we want to support queue patterns where you can specify eg. a regex that identifies a group of topic names?

Steve: There’s a lot of value in having a simple interface. If the server has the flexibility to interpret the strings, this API would work.

Steve: Stream receive and on-receive should also have a timeout.

From David Justice to Everyone 09:24 AM
The “inbox” RPC mechanism is often used in AMQP (Az Service Bus, etc)
From David Justice to Everyone 09:25 AM
In AzSB, the first message is sent with a “reply-to” annotation (I think)

Dan: Function for an acknowledgement: We could add an acknowledgement for stream-receive.

Chris: Is it worthwhile to walk through some example use cases?

Dan: The interface proposed here is very similar to spiderlightning repo. It’s implemented with Kafka and Mosquito, and we also implement messagequeue for ServiceBus and a filesystem implementation. But I’d be open to walking through other use cases. I could put something together for the next WASI meeting?

Chris: That’d be awesome.

From Dave Bakker  to Everyone 09:27 AM
No specific suggestion, but given the wide area of questions, the term ""messaging"" terminology&interface feels to too broad

Mossaka: When the publisher publishes a message, do they get an acknowledgement that the message was received by the receiver?

Dan: The receiver could commit the message.

Steve: Some kind of acknowledgement is needed for reliable delivery protocols.

Mossaka: I was imagining an on-acknowledgement hook.

Steve: Is the result from the public API not enough of an ack?

Mossaka: Ack from broker to publisher, so the publisher can publish a message asynchronously, and then the broker pushes an ack back.

Steve: Could this be done with a subscription?
*brainstorming in the design space*

From Bailey Hayes to Everyone 09:30 AM
Another source for inspiration and a good place we can add a reference implementation is https://github.com/wasmCloud/interfaces/blob/main/messaging/messaging.smithy

Luke: For a next presentation: It’d be helpful to see lists of concrete implementations and use cases, to see how this works out.



### Let's talk about: wasi-blob-store and range requests in wasi-keyvalue by Steve Schoettler. Sub-topics include ""Resource handles for blobs"", and ""Designing wasi-cloud interfaces while considering variations in implementation""


Blob store:

Storing potentially large blobs of data. S3, OpenStack object store, etc.

https://github.com/WebAssembly/wasi-blob-store

Key value:

PR adding range requests: https://github.com/WebAssembly/wasi-keyvalue/pull/4

Mossaka: Transactions?

Steve: I think this would be hard to implement with a streaming response. It’d be easy to get deadlocks; if the consumer crashes, would the transaction be released? I’d recommend against putting this in a transaction.

I’d like to explore interfaces for transactions for multiple cloud APIs. And more broadly, there’s a question of consistency across WASI interfaces. Is there a way to do transactions that’s not specific to each interface?

Joel: In the range APIs, would it make sense to make the end parameters optional? “Give me everything later than Oct 21” for example. Minimum or maximum kinds of usage.

Steve: Good idea!

Bailey:
	
https://github.com/WebAssembly/wasi-blob-store/pull/2
especially looking for feedback on:
```
get-data: func(name: object-name, start: u64, end: u64) -> result<data-blob, Error>
```"
main/2019/CG-10-29.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 29th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: October 29th, 4pm-5pm UTC (October 29th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting
    1. Feature detection proposal discussion
        1. MVP compatibility (https://github.com/WebAssembly/feature-detection/issues/5)
        1. Poll to rename from ""feature detection"" to ""conditional compilation""
    1. Trapping semantics of bulk memory operations (https://github.com/WebAssembly/bulk-memory-operations/issues/111)
        1. Recap of previous discussion
        1. Poll to change trapping to occur before writing if any bytes accessed would be OOBs
    1. Updates about next in-person meeting
        1. Tentative dates mid-week of Feb 10th, hosted by Google in the Bay Area. 

1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees
Andreas Rossberg

Francis McCabe

Conrad Watt

Arun Purusan

Alex Crichton

Lars Hansen

Deepti Gandluri

Adam Klein

Heejin Ahn

Thomas Lively

Michael Starzinger

Zhi An Ng

Ryan Hunt

Flaki

Ben Titzer

Alon Zakai

Jacob Gravelle

Ingvar

Luke Imhoff

Ms2Ger

Nick Fitzgerald

Peter Jensen

Petr Penzin

Rich Winterton

Shravan Narayan

TatWai Chong

Derek Schuff

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Lars seconds

### Proposals and discussions

#### Feature detection proposal discussion
<TL Proposes renaming feature detection to conditional compilation>
    
TL: The new mechanism enabled by this proposal is conditional compilation, not restricted to feature detection, and the condition could be features. 

BT: Do you have other options? A more general option that doesn’t imply code generation?

TL: Agree compilation maybe not the best term, open to options

AR<in chat>: Conditional sections?

TL: As written today, that’s a great name for the proposal, good transition to my next changes

TL: Short offline discussion to bikeshed the name, but are there issues with renaming?

<No objections>

TL: Goal is to promote cross engine compatibility, it’s currently not compatible with MVP engines, the way the design currently works is that it introduces conditional sections .. <describes current proposal>. In order to have MVP compatibility this needs to work with conditional segments, the process of parsing a binary becomes not parse some sections and concatenate, with MVP compatibility this becomes more complex, the other downside is that it introduces semantically significant changes. We don’t have custom sections that change the semantics that change the … How important is supporting MVP engines? In the long term/medium term, is it important to support MVP modules, without having to worry about MVP compatibility? 

TL: Interested in hearing feedback

TL: Personally feel, most engines eventually will support new features

BT: If it’s just a matter of adding new sections, then that may not be bad, the choice is not binary, if we fundamentally change how sections work then it’s further away on the spectrum

TL: Doesn’t fundamentally change about what it means to be a Wasm module

LW: There is a gradual following of standardization of features, it’s good to go the simpler route

TL: Is Keith on the call? Discussion on the proposal

<Keith is not on the call>

TL: Anybody else have comments, and concerns? 

CW: MVP engines may already be left behind, that’s already an implicit assumption

TL: On the tools side we haven’t decided when to make the switch, I also have the sense that’s the implicit assumption

TL: Nobody strongly disagreed, will continue along the current path with more discussion on the issue tracker

#### Trapping semantics of bulk memory operations 

<Ryan Hunt presenting [slides](https://docs.google.com/presentation/d/1ceBIAXBMgIeNhPrURpnEMozkutqd1iUpyPVoE_5mAzk/edit#slide=id.g646d412e2f_0_0)>

RH: Are there any general concerns? 

CW: so the problem with just system memmove, the current spec tries to pre-empt this problem but fails to accomplish the goal, so I’d be strongly in favor of going back to the bound-checked version as suggested

TL: Sounds good

CW: To be clear, this will still have a slight difference from the MVP, with this reversion the segments will be bounds checked one by one, and not when everything is completed

LW: that part of the change sounds reasonable

RH: Agree with that

TL: is the behavior of a 0-byte access one-past-the-end remain valid?

RH: 0-byte access is always valid, this doesn’t necessarily change that, and there are no pkans to change that

DG: any other concerns?
Doesn’t sound like it. Ryah, do you have what you want form the community?

RH: should we do a poll?

DG: yes, do you have specific wording in mind that you want to propose?

RH: what’s on the slide: 

revert the behavior of memory.copy/fill to trap if any access would be out of bounds, before doing the writes.

LH: this also includes the change to memory.init, right? It changes in the same way to mirror memory.copy?

RH: Yes..

LH: Memory.init was changed the same way as memory.copy

RH: yes, that’s the intention

DG: so this poll includes memory.copy, memory.init

AR points out that this applies to table operations too.

RH so yes all of the operations

TL: there are init, fill and move, for each of table and memory.

DG: so this poll applies to all of the operations, to trap if any access would be out of bounds, before doing the write.

| SF | F | N | A | SA |
| -- | -- | -- | -- | -- |
| 12 | 11 | 0 | 0 | 0 |

DG: Ryan, anything else?

RH: no, thanks.

#### Updates about next in-person meeting

Next in-person meeting will be hosted by Google in the Bay Area. we’re looking at the week of Feb 10, don’t have exact dates yet since we are in early stages of planning.

Other topics?

### Closure

"
main/2017/WG-09-25.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 25th video call of WebAssembly's Working Group

- **Host**: Google Hangouts
- **Dates**: Monday September 25th, 2017
- **Times**: 9:00-10:00am Pacific Time
- **Location**: *Brad will email Google Hangouts link to WG members + registered CG guests prior to the meeting*
- **Contact**:
    - Name: Brad Nelson
    - Email: bradnelson@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion of coordination with the Community Group.
       1. Discussion of [phases proposal](https://github.com/WebAssembly/meetings/blob/master/process/phases.md).
       1. POLL: We should adopt the phases proposal in coordination with the Community Group.
    1. Decomposition of specification
       1. Discussion how these parts of the spec should be published:
          1. [WebAssembly core spec](https://github.com/WebAssembly/spec)
          1. [JavaScript embedding](https://github.com/WebAssembly/design/blob/master/JS.md)
             * [Draft spec](https://littledan.github.io/spec/document/JS.html)
          1. [Web embedding](https://github.com/WebAssembly/design/blob/master/Web.md)
       1. POLL: We should publish the core spec, JS embedding, and Web embedding a separate documents, with appropriate cross references to each other.
    1. Spec repo logistics
       1. Should we branch or fork the repo to capture Working Group state?
    1. Adoption of CG specification
       1. Discussion of state of the core specification.
       1. POLL: We should officially tag and adopt a revision of the spec as
          the WG input.
       1. POLL: We should adopt the current WebAssembly core spec as a ""First Public Working Draft"" for WebAssembly Core Specification v.1.
    1. Future meetings
       1. Confirm next meeting date + time.
       1. Discuss meeting time + day at TPAC.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Dates and locations of future meetings

| Dates                    | Location          | Host       |
|--------------------------|-------------------|------------|
| 2017-11-01 to 2017-11-02 | Santa Clara, CA   | Intel      |
| 2017-11-06 to 2017-11-07 | Burlingame, CA    | TPAC       |

## Meeting notes

###  Roll call

* Bastien, JF
* Christiansen, Kenneth
* Ehrenberg, Daniel
* Ferris, Michael
* Gravelle, Jacob
* Holk, Eric
* Holman, Michael
* Jensen, Peter
* Miller, Mark
* Nelson, Bradley 
* Purushan, Arun
* Rossberg, Andreas
* Schuff, Derek
* Titzer, Ben
* Wagner, Luke
* Zhu, Limin

### Find volunteers for note taking (chair to volunteer).

*JF volunteers*

### Adoption of the agenda

*Dan seconds*

### Proposals and discussions

#### Discussion of coordination with the Community Group.

Discussion of [phases proposal](https://github.com/WebAssembly/meetings/blob/master/process/phases.md).

* Rossberg: Do we know how many people in WG aren’t in CG?
* Nelson: No. Anyone on the call?

**POLL: We should adopt the phases proposal in coordination with the Community Group.**

*No objections to unanimous consent*

### Decomposition of specification

Discussion how these parts of the spec should be published:

          1. [WebAssembly core spec](https://github.com/WebAssembly/spec)
          1. [JavaScript embedding](https://github.com/WebAssembly/design/blob/master/JS.md)
             * [Draft spec](https://littledan.github.io/spec/document/JS.html)
          1. [Web embedding](https://github.com/WebAssembly/design/blob/master/Web.md)

* Nelson: Concern in last discussion was that web / JS would highlight things that are missing from core spec, resetting the standardization clock.
* Rossberg: Last week I added wording about [embedder interface](https://github.com/WebAssembly/spec/pull/567).
* Ehrenberg: The embedder interface looks great. I am not positive it will address all JS and Web embedding spec needs, but at least the vast majority.
* Rossberg: There may be some trivial data structure manipulations, but this covers all the major points.
* Bastien: What timing would we aim for?
* Rossberg: I think we should coordinate the two. I’d be fine waiting for the JS spec. If there’s strong feeling that we should push for the core spec now I’m OK too.
* Nelson: I agree going forward we’ll want to coordinate. Only thing nudging us forward is IP clock. Other thing is we have interop, we have browsers shipping this.
* Ehrenberg: I’m not sure what W3C has to do with interop. We haven’t seen browsers waiting.
* Nelson: In light of that I think it’s fine to delay. Dan do you have timeframe?
* Ehrenberg: Within a month.
* Nelson: Should we just decompose?
* Ehrenberg: I expressed concerns about synchronization, maintaining different versions. Decomposing sounds good to me.
* Nelson: Are you doing web and JS embedding as separate docs?
* Ehrenberg: I can do separate if that what you’d want. I think web embedding has parts that can be used by non-web things. If it’s easier way to understand then let’s do that.

**POLL: We should publish the core spec, JS embedding, and Web embedding as separate documents, with appropriate cross references to each other, coordinating on release schedule.**

*No objections to unanimous consent*

### Spec repo logistics

Should we branch or fork the repo to capture Working Group state?

* Nelson: W3C folks had suggested we fork the spec repo to make explicit what was blessed by CG.
* Rossberg: Why fork instead of branch?
* Nelson: Not sure. Maybe they’re used to more process? WG needs to do more work on paper trail.
* Bastien: Seems simpler to branch. It’s easier to understand and track.

Adoption of CG specification. Discussion of state of the core specification.

**POLL: We should officially tag and adopt a revision of the spec as the WG input.**

*Tabled for now, wait for Dan’s work*

**POLL: We should adopt the current WebAssembly core spec as a ""First Public Working Draft"" for WebAssembly Core Specification v.1.**

*Tabled for now, wait for Dan’s work*

### Future meetings

Confirm next meeting date + time.

TPAC is in November. Ehrenberg can only attend remotely.

* Nelson: No reason to meet in-between? Is it useful to meet in two weeks given that Dan won’t be ready at that point?

*Crickets*

* Nelson: Goal of TPAC is outreach. We likely won't have substantive items on agenda. Any particular thing we should talk about at TPAC?
* Bastien: Should do a joint session with WebGPU.
* Nelson: Do we want to schedule a meeting for ~1 month from now, separate form TPAC? We could do October 23rd, same time 9AM Pacific time.

**Action item: Brad to create meeting page.**

Discuss meeting time + day at TPAC.

### Closure

*Adjourned*
"
wasi/2022/WASI-02-10.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: February 10 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: February 10, 17:00-18:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Discuss network APIs split. [PR](https://github.com/WebAssembly/WASI/pull/461) - [Slides](presentations/2022-02-10-bakker-sockets-and-address-lookup.pdf) - Dave Bakker (@badeend)
    1. _Sumbit a PR to add your agenda item here_

## Notes
### Attendees
- Lin Clark
- Ben Titzer
- Dave Bakker
- Chris Suszynski
- Johnnie Birch
- Pat Hickey
- Dan Gohman
- Piotr Sikora
- Andrew Brown
- Mossaka (Joe)
- Mohamad-Jaafar NEHME
- David Justice
- Bailey Hayes

### : WASI-Networking

**Dave Bakker:** I’ve been working on proposal for bringing networking to WASI. Quick agenda, goal is to bring people up to speed, some of the challenges, possibly discuss some next steps to take. 

Code snippets will be in Rust. Assume a basic knowledge of BSD sockets. Some of the goals: start with an MVP for TCP. POSIX compatibility should be possible on top of the proposal, but the proposal itself is not.

BSD socket interface is highly generic. Solution, inspired by Lin’s initial comment, is to provide one function that can be called on one kind of socket and push all socket functions into protocol-specific modules. This enables every socket function signature to be tailored to the protocol. Each protocol can be a stand-alone WASI module. One con is that not all functions differ per protocol, but they are currently duplicated.

**Dan Gohman:** Do you envision separation being along address type or socket type? 

**Dave Bakker:** Currently split along TCP and UDP. Can also envision proposal for datagrams, doesn’t need to be socket protocol but also subprotocol.

Currently imagine it that it will be based on socket protocol, although if you follow you need a separate module for Unix socket, then another for streaming UNIX sockets, another datagram UNIX sockets.

**Dan Gohman:** Does that mean different for IPv4 vs IPv6

**Dave Bakker:** Yes, could, currently an enum

Not all functions differ per protocol, so results in libc having many switch statements. 

Security, idea is to have a capability handle. To create a socket you need to have a capability handle of some kind. On top of that, having possession of a capability handle should not give you keys to the kingdom. Proposal does not currently dictate how this happens. One can imagine effectively building a firewall. This is imagined to be command line argument of Wasmtime. You can simply allow some operations to proceed. You can allowlist specific domains. Same applies to being able to connect to TCP. 

**Dan Gohman:** These options would be global to a runtime?

**Dave Bakker:** Up to implementation.

**Dan Gohman:** It would be interesting to map to handle in the same way that we do pre-open

**Dave Bakker:** These rules are connected to a handle.

One extra option, which I haven’t researched, is to specify domain name and that is same as allowing all connections resolved from that domain name. Similar for inbound, TCP listeners are allowed with capabilities

**Chris Suszynski:** Just openned a ticket about exactly this. Mapping all these options could be simplified. Would like to see it follow the Docker or K8 standard. If you allow to connect to something with outbound, then you should be able to resolve that name. We could merge unbound with resolve. It should be done in a way where Wasm module always sees same logical name. 

**Till Schneidereit:** I think it might make sense to not dive too much into these things right now because the way I would think about this is as an overview of a proposal. The decision here is broad strokes whether it makes sense to pursue.

**Dave Bakker:** Overview, introduce one tiny module which is just sockets in this case. Depending on what this function returns, in foreseeable future there’s only two kinds of sockets. Sockets can be bound, etc. 

Are there any questions?

**Chris Suszynski:** Did you take a look at the standard libc functions? Will existing code magically work?

**Dave Bakker:** That is the goal. The regular socket API takes a domain socket type. Inside the impl of the wrapper API, you do a switch on the type of socket. There are a couple of examples in the repo.

Address lookup—the proposed function is significantly simpler than getaddrinfo. I chose a different name because of that. Why not getaddrinfo? Because getaddrinfo is very generalized, this proposal is not.

**Dan Gohman:** How does network interface name ___ fit into this proposal

**Dave Bakker:** using link local, so they can be abused to enum all network interfaces

**Chris Suszynski:** You said that the goal is for code written now should work, but if I use getaddrinfo. You need to call this new function.

**Dave Bakker:** Yes, you need a libc that handles all these listed cases. But those should all be implmentable in libc itself. From outside, there’s just a conforming getaddrinfo, and just the domain name lookups get through to WASI.

Something to be decided, what is the inverse of resolve_addresses.

Next steps: my suggestion is to split into 4 modules: socket, socket_tcp, socket_udp, ip_resolve_address

**Dan Gohman:** I have a question about the name. WASI already has networking proposals in flight. Can we call this WASI-sockets?

**Dave Bakker:** Yes, the plan is for each module to proceed.

**Chris Suszynski:** Awesome proposal, I really like it.

SA: Same, nice job.

**Chris Suszynski:** Do you have any time map or roadmap of how you’d like to proceed?

**Dave Bakker:** Are you asking for an ETA? No I dont’ have and ETA
"
main/2024/CG-05-07.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 7th video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: 2024-05-07, 16:00-17:00 UTC (2024-05-07, 9am-10am PDT, 18:00-19:00 CEST)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
   1. [Branch Hinting](https://github.com/WebAssembly/branch-hinting) Update about [new spec document](https://webassembly.github.io/branch-hinting/metadata/code/) for Code Metadata (Yuri Iozzelli, 15 minutes)
   2. FP16 proposal update (Ilya Rezvov, 45 minutes)
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

### Attendees

 - Yuri Iozzellli
 - Linwei Shang
 - Jeff Charles
 - Robin Freyler
 - Chris Fallin
 - Yury Delendik
 - Paolo Severini
 - Nick Fitzgerald
 - Petr Penzin
 - Ben Visness
 - Ilya Rezvov
 - Adam Bratschi-Kaye
 - Conrad Watt
 - Oscar Spencer
 - Alex Crichton
 - Heejin Ahn
 - Deepti Gandluri
 - Thomas Lively
 - Chris Woods
 - Emanuel Ziegler
 - Bailey Hayes
 - Francis McCabe
 - Andrew Brown
 - Brendan Dahl
 - Jakob Kummerow
 - Zalim Bashorov
 - Sam Clegg
 - Daniel Lehmann
 - Adam Klein
 - Jpages
 - Jonchesterfield
 - Tal Garfinkel

### Proposals and discussions

#### [Branch Hinting](https://github.com/WebAssembly/branch-hinting) Update about [new spec document](https://webassembly.github.io/branch-hinting/metadata/code/) for Code Metadata (Yuri Iozzelli, 15 minutes)

YI presenting [slides](https://drive.google.com/file/d/1jUMEV0bOI7VvtKE_MJX_Qysvk6fWz9Mu/view?usp=sharing)

CW: Who is currently consuming the branch-hinting hints? To do something in the engine?

YI: Currently V8 supports it and JSC supports it. There is some work in Firefox, I saw an open issue about some ambiguity, I don’t know what stage it’s at.

DS: Would it make sense to move the name section metadata into the appendix as well?

YI: here was some talk on github about it. There is also some new stuff added in the custom annotation proposal that could maybe go in some document like this. There wasn’t a real consensus. It kind of made sense that something very basic like the name section could stay in the appendix. This doc in particular is that metadata format, and the name section isn’t in that format but there could be something like it.

#### FP16 proposal update (Ilya Rezvov, 45 minutes)

IR Presenting [Slides](https://docs.google.com/presentation/d/1LjMmYvT_q6CD7RnV7qS3AgyM5PZ4J1PZqT__1AUDwNI/edit)

[slide: instructions]
CW: I’m much happier with the proposal in this state, I think it makes a lot of sense under SIMD. In the previous version we already had i8, i16 SIMD vectors but didn’t try to add those scalar types either.

AB: what kind of value do you splat in f16x8_splat?

IR: You splat f32 to f16 lanes with conversion. Also we don’t need any specific load and store for f16 because we have load_lane, store_lane 16 so there’s no need to do extra

PP: Wouldn’t you also need to splat f16 too?

IR: you can load lane right now, splat lane from memory, it doesn’t care if it’s f16, i16 or whatever.


AC [chat]: Is there a good sense of scale, at this time, for how large the implementation is for platforms that don’t have native support for f16?

IR: I have numbers, after this slide.

PP: For FMA, it depends on what we have on hardware, is this available on hardware, and do they all do FMA the same way?

IR: unfortunately I haven’t been able to test AVX512.

PP:You’re not supporting dot products right? It has the same rounding issues

IR: dot products so far are supported only for integers

PP: we looked at bfloat dot, but that was the problem, that they rounded differently on different platforms.

IR: We’re in a better position here because F32 & F16 were around for some time, F16 is more or less consistent, or we don’t have hardware support - its not similar to the overflow/underflow conditions for previous instructions - we will probably need two conversion operations with/without overflow for faster conversions

PP: on the NaNs: we have a canonical NaN idea, the question is why would you need that in FP16 space. The original motivation was to do nanboxing, and now we have only a SIMD proposal, nobody will store a pointer in a 16, this could be exempt from the canonicalization rules

CW: Is the NaN non-determinism here same or different from scalar operations, or can this be more ambitious?

PP: If you have hardware support then yes, youd expect that x86 would have a different sign but

CW: is the nondeterminism in the sign bit something we already allow in scalars?

PP: I got this wrong, question is if you have a canonical payload, and you operate on two of them, you should get a canonical payload back. With the baseline spec you get a 2-3x instruction bloat in codegen. Here you might make the expensive more costly on x86, because f16 codegen is going to be more expensive

IR: I think it makes sense to be less restrictive here on determinism here

CW: we should carefully write up how it would be different from scalar nondterminsim so we can see how it comes out

PP: it should be straightforward

IR slide, implementation feedback

CW: for the analogous existing f32 and f64 SIMD instructions, do they all round to even, and do they have similar problems on x86?

IR: they are round to even, and they are natively supported, the only problem is with double transition, when you go from 64 to 32 and 32 to 16, there is no such issue for just 64 and 32. There’s no direct conversion from 64 to 16 in F16C.

CW: I’m not asking you to justify Intel’s decision, but asking if there’s more info :)

IR: yeah there’s no issue with just 64 and 32, no 2-hop conversion so, double-rounding isn’t a problem. It’s a similar issue to FMA. it’s a good idea maybe to move f64 to f16 conversion to relaxed SIMD

CW: Should be fine in principle, but we should document it carefully

IR: yeah, it’s a good idea. I assume most of the use cases don’t care about that rounding, especially e.g. for ML workloads.


### Closure
"
gc/2020/GC-06-02.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 2nd video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: June 2nd, 4pm-5pm UTC (June 2nd, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Status update on MVP GC proposal (Andreas Rossberg)
    1. Overview of SOIL GC proposal (Ross Tate)
    1. Overview of Linear memory GC idea (Wouter van Oortmersson)
1. Closure

## Meeting Notes

### Introduction of attendees

Ben Smith, Google

Cheng Shao, Tweag.io Haskell, interested weak refs

Jakob Kummerow, Google

Francis McCabe, Google

Syvatoslav Kuzmich, Jet Brains

Zhi An Ng, Google

Daniel Wirtz, AssemblyScript

Sabine Schmaltz, Tarides, interested in dynamic memory model of OCaml in wasm

Ross Tate, Cornell University, interested in wasm for wide variety of languages, balance short term + long term needs

Ben Titzer, Australian National University, interested in next generation of languages

Ryan Hunt, Mozilla, stay up to date, provide implementation feedback, help find consensus

Gergely Buday, Eszterházy Károly University Hungary

Keith Miller, Apple,  Been attending a bunch of WASM meetings for WebKit, want to see GC move forward since it’s the biggest missing feature of WASM, in my opinion.

Andreas Rossberg, Dfinity, previously Google on V8, champion of GC proposal as it stands, want to move the proposal forward now that some prerequisites are met

Luke Wagner, Mozilla, implemented in SpiderMonkey earlier, excited to see others interested

Deepti, Google, follow along, stay up to date

JP Sugarbroad, Android/Google, integrating Wasm

Adam Klein, Google, excited about seeing languages beyond C++/C/Rust target the web

Emanuel Zigler, Google WebAssembly Runtime Team (together with Jakob), bring additional languages to the web, interaction between JS and Wasm GC

Hans Hoeglund, Tweag.io, high level language support in Wasm

George Karachalias, Tweag.io, Austelius, Haskell -> Wasm compiler, stay up to date

Thomas Lively, WebAssembly Tools team at Google, curious observer, active in other proposals

Wouter Van Oortmerssen, WebAssembly Tools team at Google, see Wasm be the most awesome target for modern languages

### Agenda

(Andreas Rossberg presenting [slides](https://github.com/WebAssembly/meetings/blob/master/gc/2020/presentations/2020-06-02-rossberg-gc.pdf))

JS: What is the driving reason for structural types into MVP?

AR: idea was, want complete type information, want to avoid need for run time checks. For MVP you could not care, but this is fundamental to the design, you want to resolve it from the beginning. Want to have zero-overhead to structs and arrays. Haven’t looked too closely at what you proposed, but probably don’t have that.

JS: No, it would be a runtime type-check.

AR: related to performance, more in space in locality, composability… People proposed simpler models with a vector of refs and binary data (split everything into two worlds), when you compile something that mixes stuff, then you’ll need to transpose with every access, destroying locality. Gets worse when you nest more levels. So you want something that you can nest things without destroying locality.

BT: You don't think function subtyping is a full issue yet … doesn't that depend on type imports?

AR: it’s not “not an issue”, not a particularly interesting issue. Subtyping on functions become interesting only once you have struct types. Before that, every subtyping you might want to have isn’t interesting in the higher order case. You can defer all function subtyping until this proposal. For imports. Not sure… For type imports, it doesn’t make a diff, unless we already allow it. 

BT: How complicated do you allow the bounds to be… if type imports are bounded by other type imports, then you have subtyping… if you are embedding objects from another language, then function subtyping leaks into subtyping.

AR: yes. But you already assume that you have some other subtyping. If there’s nothing other than function subtyping, you can’t do anything interesting.


BT: In the limit, type imports will allow you to define subtypes...

AR: but there is no interesting way to use that, unless you have some other basic subtyping axioms

BS: we have a few other items...

AR: not entirely clear where this (function subtyping) belongs

BS: Ross can present next

Ross: I worked with a bunch of researchers on a different proposals, don't want to talk about differences, but want to show the context that led us to a different design

(Ross presenting slides: Overview of SOIL Initiative’s GC Proposal [(pdf)](presentations/2020-06-02-tate-soil-gc-overview.pdf) [(pptx)](presentations/2020-06-02-tate-soil-gc-overview.pptx))

KM: Ideas for post-MVP? Or during MVP?

RT: In my intro, mentioned about doing both short and long term. Trying to figure out a short term thing that is useful, and have a nice path for long term. So need to flesh out ideas (refer to ideas being explored slide) to allow a path for refinement. Not everything should go into MVP, it’s a lot. Acyclicity might be good, sounds like a lot of interest.

BS: Wouter, you were going to talk about linear memory GC? Do you have enough time?

WVO: didn’t make slides, made a summary on an issue, will share that on screen.

(WVO presents issue) TODO: add link to issue

CS: does the current type system for gc proposal support adding boxed/unboxed content, in haskell runtime we have a lot of places we would like a heap obj to contain references to .. also need them to contain machine words, current proposal, with struct types, it’s fine, if array, all the types have to be uniform. If i would like heap object to have runtime-defined length, i need an array, but means elements will be uniformed, it cannot contain both boxed and unboxed.

BS: Probably best to follow up on the issue tracker for this, since we're over time

## Closure
"
main/2023/WG-03-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 8th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: March 8th, 2023 at 4pm-5pm UTC *( March 8th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
   1. Tail calls to phase 5 / Wasm 2.1
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Attendees

Luke Wagner
Andreas Rossberg
Justin Michaud
Ms2ger
Deepti Gandluri
Sergey Rubanov
Justin Michaud
Keith Winstein
Petr Penzin
Thomas Lively
Eric Prud'hommeaux
PLH
Ashley Nelson
Ilya Rezvov


AR: what’s the current status / next steps for Wasm 2.0?

### Tail calls to phase 5

DG: status/updates from Apple re: rolling back of tail calls?

JM: Safari doesn’t have a working impl of tail calls; current impl is from a contributor but has serious flaws.

AR: Is it tractable?

JM: Yes, but it’ll take more work/time.

DG: Mozilla interested but not done yet.  But do the requirements require shipping vs. “implemented” to some degree?

AR: Shipping doesn’t seem required per the process.

JM: Not against, happy with the spec.  Just not done yet.  But do impl hurdles suggest any challenge?

DG: Maybe lets use the email mailing list to get status from Apple/Mozilla?

Ms2ger: Is there pressure to get this shipped right now?  In a month or two might have a clearer situation.

AR: This would get delayed indefinitely as it’s not a high priority. Not sure when we’d ever resolve it

Ms2ger: That’s an argument against it if we don’t have enough priority to ship this

PP: Did it linger this long b/c Chakra objected?

AR: No, that was resolved.  It just didn’t get prioritized yet.  But perhaps we should consider age of proposal.  But maybe we shouldn’t set a bad precedent here.  Is just the compiler working and can you turn off the interp to consider it a working impl?

JM: The only blocker is prioritization, no concern about being able to implement it.  Spec seems unobjectionable and small in scope.

LW: Wasmtime is working on an impl actively.

JM: That would make us more comfortable knowing that is coming.

DG: We may have already shipped (b/c Phase 4 and we have a working impl).  It doesn’t really change our shipping status.  But I have to check if it’s shipped for sure.

AR: I think it’s fair to ship at Phase 4; that means it’s feature complete.

JM: This is fine, we don’t want to set a precedent, and given how noone’s objecting to it. It’s not unreasonable to say this in particular is special

AR: I was going to suggest we work on 2.1, which will include extended const + tail calls, but we should probably wait a little bit more on that. Getting back to the earlier point of 2.1..

LW: Plh here! 

AR: Question is what the current status of 2.0 is? What’s left to be done and any AIs? From a W3C process

PLH: We have to start the horizontal review process, and it needs a published review, Wasm is special needs LaTex
* Publish working draft (dated, stable)
* Email out for horizontal review (horizontal groups: privacy, security, accessibility etc, in practice this takes 3 months)
* If everything works, then we ask the director to move to a candidate review
* Implementation report is after the CR (protections kick in). How do we demonstrate we have implementations, if we have a 
* Proposed recommendation, we have to demonstrate that we have implementations


EP: We can use old Sphinx workflow, it works but process not so automated, some manual text editing required

DG: I wanted to confirm (above)

DG: Can we use our webassembly.org status page to demonstrate implementation status?

PLH: Yes

AR: From our end, everything is done for ~1 year, nothing left to do that we know of.

PLH: Only thing is holding us back is complicating tooling to deal with Latex in the draft to convert and thanks ericP for being here.

EP: Bikeshed doesn’t offer hack that we did previously, need some manual manipulation.  Have other specs changed at all?

AR: not in major ways

EP: Publication would involve all three, reproduces the sphinx portions, puts in a W3C headers, adds page numbers, and some highlighting

AR: that’s the script you put together? And that should still work?

EP: Hopefully, two points of volatility, one is the python portion, and the other on how it interacts with the Dom

PLH: If it would only use MathML

AR: We want to get rid of Sphinx and not LaTex, we are dependent on Mathjax

AR: Who owns the next steps?

EP: Having a pair who would work with me on this?

PLH: Once we have a Working Draft, we can just stick “CR” at the top and that’s it.

AR: Then we’re in an evergreen model where we can just push a button to publish a new build?

PLH: We have groups automating this via GitHub already.

AR: Can we have that (help getting that working)?

EP: The only thing manual is to tweak the version/revision number, very easy to automate.  The sphinx2tr is in a W3C repo.  Other scripts are easy to grab.

PLH: Call with Eric so he can hand off?

AR: Is there anyone we can recruit for that?

DG: Let’s take it offline to email thread
"
gc/2021/GC-04-06.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 6 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: April 6, 4pm-5pm UTC (April 6, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Presentation: Equirecursive Types in Binaryen [Thomas Lively] (1 hr)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Zalim Bashorov
- Conrad Watt
- Zhi An Ng
- Lars Hansen
- Alon Zakai
- Francis McCabe
- Keith Miller (Apple)
- Rick Battagline
- Jakob Kummerow
- Ross Tate
- Ryan Hunt
- Ben Titzer
- Sergey Rubanov
- Derek Schuff
- Asumu Takikawa
- Sam Clegg
- Adam Klein
- Manos Koukoutos
- Filip Pizlo
- Emanuel Ziegler
- Andreas Rossberg
- Heejin Ahn
- Daniel Ehrenberg
- Luke Wagner

### Presentation: Equirecursive Types in Binaryen [Thomas Lively] (1 hr)

[slides](https://docs.google.com/presentation/d/1hHXGNSkm7gCF5UcntnR_w9LlV2ANVpgSoiECTQzLIso/edit?usp=sharing)

FM: if you do this as two separate calls to TypeBuilder, you should still get the two types are equal.

TL: yes, in this case you can’t construct A and B separately.

FM: if you did this again, if you did it for C and D, they should be equal.

TL: yes, it should be globally canonical across all TypeBuilders. Also, if we have a different form, if one of these were unfolded, if they gave us the same type structure, they would also be equivalent, even if the definition didn’t look the same.

CW: Future slide about how type declarations are related to nodes in the graph?

TL: yes (slide on HeapTypes as DFAs)

FM: can you explain why you make i32 an accepting state?

TL: accepting and not accepting doesn’t actually matter, because we are not actually doing a DFA. classic DFA has accepting and non-accepting states. I32 and f32 being different leaf types will be different final states, and will be distinguished in the initial partitioning. If you have two types taking the same path, one goes to i32 another to f32, then those are different types, hopcroft algorithm will end up separating them

FM: the language here is accessors to the type

KM: Would A & B in any dfa minimization be the same here?

TL: they will not, hopcroft works via partition refinement, the partitions will be split up, never merging. By virtue of starting out in different starting partitions, A and B will remain distinct forever.

KM: How are initial partitions decided?

TL: you go through each heap type, calculate a hash of the top level structure, up to but not including children, put in a hashmap. If you hash but it is already in there, you append it to the partition you created for that top level structure. If two types have the same top level structure, they hash and compare the same, will be put in the same partition.

RT: This is node-labelled dfa. If you think of accepting v.s. non-accepting, generalizing to shape labels.

FM: hopcroft algorithm would have started with two partitions.

RT: you generalize it, rather than label being accepting, now the label is the shape

KM: when you say top level structure, that’s with all the names of the things you reference to removed?

TL: yup

FM: if you are only looking at the top level, suppose that top level has struct by inclusion, not by reference

TL: not possible in the MVP, we would have to update the scheme for inline structs like that

FM: n^2 of what?

TL: n^2 in number of distinct types defined in the type section. We would have deduplicated any types, but maybe there were no duplicates. We have as many heap types as there were in the heap type section, which can refer to each other. The structure for each type could be the size of entire graph

RT: how do you compute the hash?

TL: same as before, with top-level to false. For each node, remember the index, if we hash again to that index.

RT: dynamically create ordering of vertices, then making sure you don’t walk it?

TL: in code, if we see heap type, then hash index if we saw it, without recursing into it

FM: that algo itself may be n^2 or something nasty, because every type in the tree you have to see if you already encountered it, it’s not linear in structure

TL: we use a hash map, the key to the hashmap is a heap type, not heap type info. Key-ing into hash is constant, since we are using the id. Originally, I did it wrong, using de bruijn indices, so you never recurse into the same time on the same paths, but possible from different paths. It took a long time for hashing to complete. n^2 at best.

CW: would canonicalization be done at compile or instantiation time in engine?

RT: instantiation time after all imports provided

CW: purely because of abstract type imports

RT: type imports specifically, have to compute all rtt canons, at instantiation time. A subset can be done at compile time, it depends.

LW (chat): I think a subset of the type graph can be done at compile time (that isn't dependent on type imports)

CW: we discussed neutering structural abstract type imports, not sure if we went further

RT: post-mvp would have you do this at runtime.

TL: some post-mvp where you get the type parameterization and create new rtts at runtime. Doing type canon on those would require you to do this at runtime.
"
main/2018/CG-07-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 10 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: July 10, 4pm-5pm UTC (July 10, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email JF Bastien or Ben Smith to sign
up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Upcoming [TPAC](https://www.w3.org/2018/10/TPAC/)
        1. Register early!
            1. Early Bird rate (until 31 Jul): EUR 92 (EUR 110 with VAT)
            1. Standard rate (until 30 Sep): EUR 135 (EUR 160 with VAT)
            1. Late/on-site rate (starting 1 Oct): EUR 170 (EUR 205 with VAT)
        1. There is an Invited Expert Fund to help support Invited Experts who participate actively in W3C groups and who request financial support to attend TPAC.
        1. Who intends to go?
        1. Topics of discussion?
        1. Will anyone require childcare? The W3C is looking for soft commitment to see what they should plan for.
    1. Discuss charter for debugging subgroup and poll for creation if there is support.
       1. Proposed charter text is available in a [PR](https://github.com/WebAssembly/meetings/pull/271)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Alon Zakai
* Ashley Williams
* Ben Smith
* Ben Titzer
* Conrad Watt
* Daniel Ehrenberg
* David Piepgrass
* Deepti Gandluri
* Derek Schuff
* Gaplin
* Heejin Ahn
* Jacob Gravelle
* Jay Phelps
* JF Bastien
* Keith Miller
* Limin Zhu
* Lin Clark
* Michael Ferris
* Nidin (01 Alchemist)
* Peter Jensen
* Rrwinter
* Sergey Rubanov
* Thomas Yeun
* Ulrik Sorber
* Wouter Van Oortmersson
* Yulia Startsev
* Yury Delendik

### Find volunteers for note taking (acting chair to volunteer)

*JF volunteers*

### Adoption of the agenda

*Wouter seconds*

### Proposals and discussions

#### Review of action items from prior meeting.

#### Discuss charter for debugging subgroup and poll for creation if there is support.

Proposed charter text is available in a PR

Derek: a while back we talked about creating sub-groups for the CG. This would
be the first. Breaking new ground. This charter tries to figure out what it
does, and keeps it subordinate to the CG charter. Goal is to provide
pre-standardization to debugging, static analysis, etc (see list). Could also
do specs in other standards bodies, including for the entire web (not just
WebAssembly). Will create non-normative reports and software.

JF: would be good to let it steep for a bit after the notes are posted to get
attention to it. Otherwise looks good for us.

Ben: what about a broader standard?

Derek: work could fork off from this if / when relevant.

Ystartsev: if we make wasm answer for everything on the Web we might deviate
from what wasm needs. I’ll be looking at starting a CG for this in the next
month or so.

Dan: sounds great.

**POLL:** adopt this charter in a week assuming no objections raised by then.

*Unanimous consent*

#### Upcoming TPAC

1. Register early!
   1. Early Bird rate (until 31 Jul): EUR 92 (EUR 110 with VAT)
   1. Standard rate (until 30 Sep): EUR 135 (EUR 160 with VAT)
   1. Late/on-site rate (starting 1 Oct): EUR 170 (EUR 205 with VAT)
1. There is an Invited Expert Fund to help support Invited Experts who participate actively in W3C groups and who request financial support to attend TPAC.
1. Who intends to go?
1. Topics of discussion?
1. Will anyone require childcare? The W3C is looking for soft commitment to see what they should plan for.

JF: TPAC is the w3c yearly meeting. The wg’s get to ask for a room to discuss
things. They meet in various rooms to discuss things. Brad ran it as a
conference where we had different talks. This time we want to run it as a CG
meeting with other groups. Last year the gpu group wanted to talk to wasm
folks. There may be other groups interested as well. It’s a good opportunity to
meet other folks who work on the web and advance CG work. The CG for wasm does
more standardization work for wasm. I don’t think we’ll get much advanced, that
depends on Ben. This will be best for CG work, in person discussions. This year
is in Lyon, France. It might be difficult for some people in US. It is useful
for people in Europe. The early-bird rates expire end of July. If it is
difficult for you to attend, there is an invited expert fund should help. If
you are in expert in WebAssembly, and your company cannot pay for you, we can
help figure out how to get you to go. For the C++ standards committee, we
have something similar and we have found it to be very useful.

Is anyone already committed to going. One thing that would be useful, if there
are enough people to go for debugging.

Ben: [discuss what we are doing with rooms at TPAC]

AI(Ben, JF): create a meeting page on GH, taking PR for ideas.

JF: Another question for w3 that we need answer to: whether anyone needs child
care. If there are a few people who need this, they would like to know. What
kind of need and age range are needed.

It looks like the rates are daily rates, so it is a bit expensive.

### Closure
"
gc/2021/GC-11-16.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: November 16, 5pm-6pm UTC (November 16, 9am-11am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Relationship between externref and anyref (20 minutes)
    1. Presentation: Waml (Andreas Rossberg, 40 minutes)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Sergey Rubanov
- Rick Battagline
- Tim Steenvoorden
- Francis McCabe
- Zalim Bashorov
- Manos Koukoutos
- Emanuel Ziegler
- Keith Miller
- Alon Zakai
- Deepti Gandluri
- Jakob Kummerow
- Adam Klein
- Ryan Hunt
- Slava Kuzmich
- Ben Titzer
- Andreas Rossberg
- Asumu Takikawa
- Ross Tate
- Heejin Ahn
- Luke Wagner
- Aske Simon Christensen
- Conrad Watt
- is (???)

### Discussion: Relationship between externref and anyref (20 minutes)

FM: What is externref for?

AR: It is the fallout of removing subtyping in reference types proposal. From my perspective, it is a stopgap measure that should never be used once we have anyref. Only anyref gives complete flexibility for how types are implemented, e.g. in Wasm or by the host.

TL: From that point of view, could just rename externref to anyref and re-merge them.

AR: Drawbacks are renaming and that we might in the future have new types that can’t be used externally. But I admit this is hypothetical and possibly a weak reason.

JK (chat): as I said on GitHub, I don't understand how externref allows us to build the kind of restriction Andreas just mentioned.

FM: If you assume that externref is the type of things that don’t belong to you, you just leave it at that and don’t pretend it has anything to do with other WebAssembly types. But then you might want to implement externref in one module with some Wasm type in another module.

AR: It makes sense that it should be an abstract type, but I think anyref should be that abstract type.

ZB: In some languages we would need to box more. For example when putting a DOM node in a collection, we would like to not box. 

TL: It will be great to get those experimental results.

RT: My understanding is that externref is for JS types, and I don’t think that requires changes. The GC overview says it will be used parametric polymorphism, but it is not being used like that.

AR: After I wrote that, I realized that for my compilers eqref is sufficient for the polymorphism.

ZB: It would be useful to be able to compare anyrefs as well.

TL: So make eqref the top type?

AR: Maybe eq should be an attribute on types rather than its own type. Should be simple. Main drawback is an extra bit to consider.

RT: Or you could make externref a subtype of eqref.

BT: I want to see the experiments, but I don’t want to commit Zalim to too much work. It shouldn’t be too hard to write benchmarks.

RT: Right now the problem is that Kotlin generally isn’t very fast.

BT: We could write microbenchmarks in the text format to get around that.

ZB: We need to find a more real-world micro and macro benchmarks.

TL: Ben, would you be interested in looking at the microbenchmarking?

BT: I have other priorities, but my main point is that I don’t think we should block on Kotlin becoming fast.

TL: There are so many options here that I don’t think it even makes sense to do a non-binding poll on what we think we should do right now. Let's pick this discussion back up once we have more implementer feedback on what would be useful.

### Presentation: Waml (Andreas Rossberg, 40 minutes)

[slides](presentations/2021-11-16-rossberg-wob+waml.pdf)

FM: Curious about the force operators about thunks?

AR: Maybe that’s an SML-NJ extension? I think that’s just frontend sugar, so not too interesting. Unlike in Haskell, which would be a whole different experience.

RT: Some time ago we shared this currying strategy with some OCaml people and they were worried about all the casts necessary in that strategy.

AR: Yes, I will get back to that. In general functional languages need much more casting in the current proposal, but it’s good that at least we can get the languages working at all.

RT: Interface calls are similarly bad to currying because you also have to cast the interface table.

AR: That’s probably right.

BT: Is there a way to use func.bind here?

AR: Maybe, I haven’t tried. Functors should work, but I’m not sure it matters much.

BT: An advantage of func.bind is that there is one less cast.

FM: We were looking at func.bind for IT and there some insurmountable problems with it having to do with lifetimes.

AR: I would expect it to be hard to use outside of a GC context.

LW: FWIW, func.bind was a huge monkey wrench ABI-wise when I was implementing it in SpiderMonkey. At least if we keep it, it would be great to not have it return a funcref.

BT: Virgil also has similar features, but some extra generality makes func.bind unsuitable there, too.

BT: About the new null type, are you suggesting a new instruction?

AR: Or just a new type to pass as the immediate to existing ref.null.

TL: Another option is to spec existing ref.null to ignore its immediate.

AR: True, but ugly.
"
wasi/2023/WASI-06-01.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: June 1 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: June 1, 16:00-17:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Prototyping resources using psuedo-handles
        - As a way to phase in the implementation of resources and handles,
          and enable guest-language developer-facing experimentation, I'm
          proposing a `resource` and handle syntax that uses pseudo-handles
          in the implementation. See here for more details:
        - https://github.com/bytecodealliance/wit-bindgen/issues/586

## Notes

### Attendees

- Kevin Hoffman
- Dan Gohman
- Ed Warnicke 
- Piotr Sikora
- Kyle Brown
- Jeff Charles
- Dave Bakker
- Timmy Silesmo
- Johnnie Birch
- Andrew Brown
- Bailey Hayes
- Hung-Ying Tai (hydai)
- Radu Matei
- Jesús González
- Frank Schaffa
- Adam Mohammed
- Yong He
- Pat Hickey

#### seudo-handles for resources

**Dan Gohman**: Resources are a feature we are looking to have in the component model and WIT syntax, and we are looking for ways to unblock the frontend side of the story.
This proposal is a way to generate the guest-side/language-side bindings.
This is an implementation we can complete sooner rather than later.

Using wasi-io as an example, the `input-stream` is a pseudo-resource handle implementation.
A way to pass in a virtual stream as an index into a table.

This is a low-tech implementation. If handles are u32 values and then enable this syntax in WIT files. In the guest-side bindings, we could now get `stream.read`. It would also mean if we have the resource syntax, we could have the bindings that we could call, e.g. `stream.drop-input` could be called automatically vs the current requirement of calling this manually.

When we have real handles, we could then switch them out on the host side.

**Bailey Hayes**: What are the downsides to this approach?

**Dan Gohman**: There are a few downsides such as

- There is still a global table that lives in the store. Because we have a global table we won't have  shared-nothing isolation, aka no isolation between components.
- No way to prevent use-after-free on resources and will require developers to be careful.

But these are things we can work on the backend and allows us to do this work in parallel.

We can begin talking about and demonstrating with resources with this implementation.
This will make it easier for us to rollout the end-user story for resources and will unblock a significant chunk of work.

**Luke Wagner**: Do you anticipate guest languages will have to change if we move from pseudo-handles to proper handles?

**Dan Gohman**: I do not think so.

**Dave Bakker**: Do you forsee a semantic change?

**Dan Gohman**: Yes, the per-component table will change. This will change and will be observable.

**Timmy Silesmo**: I started implementing the resource syntax. I want to change it to add reference counting. We can currently parse to the AST. Next will be lowering and lifting of handles.

**Dan Gohman**: These resources will do reference counting. The future plan is to add owned and borrowed handles. This will be a subset of the plan. Reference counting is the general solution but will have a small performance impact. Over time we will add additional resource handle types.

**Kyle Brown**: For forgeability, how hard would it be to put in a limited version of an approach like pointer-authentication so that pseudo handles are created with some of their high-order bits set in some random way and if you try to use a handle with an invalid bit pattern you trap?

**Timmy Silesmo**: We had a discussion right before this meeting. We had an idea for how this could be implemented but may not be in the first implementation.

**Dan Gohman**: Yes, we want to make sure we have the option to do this. Important to get something working now even if it has downsides like use-after-free.

**Luke Wagner**: One good thing is that for safe languages, e.g. JavaScript, the bindings will handle this. JS shouldn’t be able to hit this vs today’s u32 could hit this. Only for unsafe languages like C.

**Kyle Brown**: What does this look like for something that has a destructor?

**Luke Wagner**: For guest JS, the entire engine is being compiled and has a finalization hook that is built-in to the object.

**Kyle Brown**: So it will need to make types that calls finalizing.

**Luke Wagner**:  Right, we will need to do this in either solution. This will unblock that work so that we can get started now.

**Kyle Brown**: On reference counting, are we going to be able to prevent cycles?

**Luke Wagner**: Inside a guest, you can always any inter-component cycles since these will be black boxes. But for intra-component, component imports are acyclic so the component imports protect us from this.

**Kyle Brown**: Resources can’t be passed up or down in a diamond.

**Dan Gohman**: Resources can be defined by the host. Hosts will need to be careful about not defining cycles.

**Luke Wagner**: Callbacks in the JS heap. Callback will contain closure state and would create cycles. This is why we solved this in WIT to prevent a callback-y style way of handling resources.

**Pat Hickey**: Reminder to please send agenda items into the repo. Thank you for coming and see you in two weeks!
"
wasi/2023/WASI-08-24.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: August 24 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: August 24, 16:00-17:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Status update on [wasi-clocks timezone update](https://github.com/WebAssembly/wasi-clocks/pull/48)
    1. Vote: Advance wasi-cli proposal to phase 2
    1. _Submit a PR to add your announcement here_


## Notes
### Attendees
Bailey Hayes
Pat Hickey
Luke Wagner
Dan Gohman
Colin Murphy
Andrew Brown
Joel Dice
Chris Woods
Frank Schaffa
Piotr Sikora
Ivan Font
Jorge Prendes
Frank Schaffa
Dan Phillips
Eduardo Rodrigues
Chinmay Garde
Matthew Yacobucci
Eduardo Rodrigues
Tal Garfinkel
Yong He

##### Status update on wasi-clocks timezone update

**Colin Murphy**: https://github.com/WebAssembly/wasi-clocks/pull/48/files

Picked up host side implementation within Wasmtime to add timezone of wasi-clocks.
Timezone is currently written as a resource and not as a per-instance call. If you ask for now, like the system time, we don’t have a file handle for that or http-request. Timezone was originally written to be a resource, all of the clocks really. Changed to be an instance call. 

The tricky part is that on the implementation side it does bring in dependencies, iana_timezone, chrono and chrono_tz. 

**Dan Gohman**: It would be a valid implementation to always say you are in the UTC timezone. If you want to adequately represent the time for humans, then you would be interested in an implementation like what Colin added to wasmtime.

##### Vote: Advance wasi-cli proposal to phase 2

https://github.com/webassembly/wasi-cli

**Pat Hickey**: Dan Gohman would you like to talk about wasi-cli.

**Dan Gohman**: What we need to advance to phase 2, we need to define the portability requirements for phase 4. For WASI CLI, we will have the same requirements as the rest of the proposals. Those proposals support windows, linux, macos operating systems. There should be two implementations.  Those are the requirements that we will have to meet to advance to phase 4, but here we must define that is the advancement criteria to vote on phase 2.

**Pat Hickey**: Environment variables, ability to exist, and everything involving std-io. Ability to call is-a-tty on streams. All of these are interfaces within this CLI package definition.

**Bailey Hayes**: At one point this was called wasi-cli-core, right?

**Pat Hickey**: Well yes, in wasmtime. That was really because we didn’t have the expressiveness in WIT to define what we wanted.

**Dan Gohman**: Never something within this subgroup, only wasmtime.

**Pat Hickey**: Unanimous consent vote. Any objections to this passing?

**Pat Hickey**: OK the vote has passed with unanimous consent.


##### Changes to streams

[wasi-io#38](https://github.com/WebAssembly/wasi-io/pull/38)

**Pat Hickey**: Last meeting I talked about changes to streams. One of the discussion points that was brought up in this meeting that was super appreciated, we talked about back-pressure. We’ve also been talking about flushing. The wasmtime users have been using this proposed version of streams. We really need flush to determine when the stream has completed. You need to be able to write something, let the event loop go off and do something else, then also know when the stream has completed. A host implementation might be able to do some magic to allow for buffered output to stdout after your Wasm program has stopped or trapped. But the case we need flushing for is, what if your implementation of stdout is not the host but another component. That component will no longer be able to execute after another component in the system has trapped. So if the stdout implementation component has a buffer that should be flushed before that trap, the caller needs to explicitly communicate that intent to flush, and give the stdout component time to e.g. write a buffered line off to some log service in a cloud context. 

There is a wasmtime PR right now that is a work-in-progress for an implementation of flush. We resisted adding flush to output stream for a while, because we didn’t want to add it unless absolutely necessary, but we have not come up with another way to solve this problem other than with the method that I just described.

**Pat Hickey**: The other aspect we have changed is backpressure. When you write to an output stream you are sending a list<bytes> to another component, consuming their memory. They may not have enough memory to handle a really big write, so we need some way to communicate a bound on how much of another programs resources the caller consumes. We can’t let you consume an unbounded amount of resources. There is a new scheme that the user of an output stream calls a function to check how much its allowed to write, then the callee (implementation) can respond it can accept so much input, including none at all. We had the ability to for the implementation to not accept more input before by returning 0 length consumed, but the difference now is that we are doing this before we incur a copy of the bytes into the implementing component. If the implementation can only consume a small chunk at a time of a large write, this scheme avoids paying for the large copy over and over.

**Pat Hickey**: I was hoping the current streams PR would be the last one for Preview 2, but that’s not the case. There is at least one more for flush.
"
wasi/2023/WASI-03-23.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: March 23 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: March 23, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Discuss Status of WASI-Crypto, whether it still actively being championed, etc.
    1. Propose `wasi-pattern-match`; request stage 0 consensus vote -- 20 minutes (@jianjunz,
       [slides](presentations/2023-03-23-wasi-pattern-match.pdf))
    1. _Submit a PR to add your announcement here_

## Notes
### Attendees
- Pat Hickey
- Dan Chiarlone
- Slava Kuzmich
- Ben Green
- Mingqiu Sun
- Frank Denis
- Joel Dice
- Jianjun Zhu
- Lin Clark
- Dave Bakker
- Bailey Hayes
- Thays Grazia
- Sam Clegg
- Dave Bakker
- Joel Dice
- Johnnie Birch
- Chris Woods
- Stephen Doyle
- Dan Chairlone
- David Justice
- Steve Schoettler

### Wasi-crypto

**Frank Denis:**  We have discussions in the issues at WebAssembly/wasi-crypto, and bi-weekly meetings. There haven’t been meetings for a few weeks but they are back on now.
**Frank Denis:**  The why of wasi-crypto: performance for using native implementations of crypto, compliance requires you use certain implementations that have been reviewed/certified, security to keep keys opaque and mitigate side channels, and also all languages using wasi get to use a common implementation. Some new languages e.g. grain dont have implementations of their own right now so they can just rely on wasi-ctypto

**Frank Denis:**  The specification is still in progress, new apis are required for additional function classes: field arithmetic, batch operations. Constraints are that it must be compatible with a wide range of platforms, and stable by supporting current and future algorithms without breaking changes. The new features we are working on are incremental additions.

**Frank Denis:**  there are two implementations today: wasmedge is the most up-to-date, and there is one in wasmtime that you need to apply a PR on top of to make it up-to-date.

**Frank Denis:**  the todo list for the project: build an ecosystem on top of this spec. Libraries exist today for AssemblyScript, and two in Rust (wasi-crypto-guest, crypto-wasi). These are just bindings over the interface, not what end users should be expected to use. Real world users want transparent support in a JWT library, or in the Zig standard library.

**Frank Denis:**  We need a test suite, at very least test vectors to guarantee interoperability. A reference implementation would be nice, the wasmedge and wasmtime implementations are not very simple or readable in order to be fast.

**Frank Denis:**  with regard to wasi preview 2: the current spec and implementations are all in witx. We will need to create a wit version, which will also unblock support for streams. Supporting the new abi and getting more adoption [of the witx abi] are not mutually exclusive.

**Frank Denis:**  Next meeting is on April 4, 2023

**Bailey Hayes:** Is that a call to action, do you want a contributor for the wit version?

**Frank Denis:**  It is not as high priority, help would be really welcome on the other high priority things and then we can think about preview 2

**Bailey Hayes:** Kyle, did you get everything you needed out of that?

**Kyle Brown:** I look forward to seeing someone do the preview 2 work, and also the phase 2 of the spec process to get the spec text. Your approach makes sense.

#### Propose wasi-pattern-match

Discuss stage 0 consensus vote

https://github.com/WebAssembly/meetings/blob/main/process/consensus.md

**Jianjun Zhu:** Reasons for proposing this api: server side wasm are scanning network packets, and http requests/responses, to detect abnormal traffic (WAF applications). These scans must be very fast so they dont impact user experience. There is ongoing work for hardware acceleration of pattern matching - new instructions, hardware offloading like GPU or other accelerators, which wasm cant use.

**Jianjun Zhu:** Goals are to support the PCRE syntax, or a subset. The API would be for iterating over matches, find first match, or check existence. The biggest goal is to improve upon current wasm performance. PCRE Is also used for string replacement, but that is not a goal for this proposal, we only want to focus on matching.

**Jianjun Zhu:** Here are some draft apis [see slides for the api text] - create a scanner from a list of patterns, scan a single block (pass a buffer), scan a stream which has a large payload across several blocks which supports matching across the end of one block onto the start of the next block. Then an api to retrieve matches from a scan result.

**Jianjun Zhu:** Here’s an example of the api, we’ll create a scanner, scan a block, check if it has a match, close the scanner.

**Jianjun Zhu:** Here’s an initial performance experiment of using this implemented in wasm, vs calling out to this wasi api. It is 1.5 to 2.5x faster in the wasi api.

**Pat Hickey:** PCRE is a very big spec, i’m skeptical that it is portable across many implementations.

**Jianjun Zhu:** There are some modes that do work across many languages, so we’ll start from those.

(discussion of whether we meet the requirements for a consensus vote, we do)

**Bailey Hayes:** we’ll do a consensus vote for phase 0, the consequences are that we create the repositories in git. Is anyone against this proposal? Nobody has noted that they are against, so this proposal moves to phase 0.
"
stack/2021/sg-7-26.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 26th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  July 26th, 16:00-17:00 UTC ( July 26th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
- Francis McCabe
- Paul D.
- Ross Tate
- Ayke van Laethem
- Rick Battagline
- Paul Schoenfelder
- Thibaud Michaud
- Arjun Guha
- Sam Lindley
- Ryan Hunt
- Heejin Ahn
- Adam Klein
- Alon Zakai
- Thomas Lively
- Andreas Rossberg
- Luke Wagner
- Daniel Hillerström


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. Stack Switching JS API – recap and next steps [50 Mins]
   1. Next meeting [2 mins].
1. Closure

## Meeting Notes

FM: JS API has a tight focus. Wants to be able to switch stacks without Wasm being aware of it because we’re not changing the Wasm spec at all. The API is also limited by the JS API conventions that are different from what we would want for Wasm.

We would like to have everyone’s blessing for this JS API approach. One option is to move it forward using the existing stack switching repo, or we can have a new proposal. The merit for a new proposal is that we could move quite a bit faster than the “main” stack switching proposal. OTOH, we might design ourselves into a corner if we ship the API before designing the “main” stack switching proposal.

SL: How has this forking gone in the past?

RT: One norm in my understanding is that when we have separate timelines for different aspects of a proposal, the tendency has been to split them.

FM: We’re not completely dumb, so this has been a consideration. The risk of the “hostage to fortune” scenario is limited, IMO.

RT: That’s why we want everyone reviewing this thoroughly to make sure there won’t be other problems in the future that we haven’t anticipated. Better to identify and work them out now than in the future.

AR: In the past the real problem has been that when we split out a proposal they have both been slow.

AL: (in chat) I see. I'd like to share my views/requirements for stack switching for TinyGo, but I'm not sure how that's normally done. I think I could make a short presentation for example for a meeting. But not sure where/how to propose this. (Sorry if this is the wrong place to ask).

All: Yes, this is an appropriate venue for that. Email Francis to set that up.

RT: Question for today is whether we want to ship a JS API first and whether we want to split into a separate proposal.

TODO: link to slides


SL: There’s a more powerful version that lets you pass in the suspender as an argument, right?

RT: So far we don’t have a use case for that, but we know we are forward-compatible with that as an extension.

SL: It’s useful if you have multiple asynchronous calls in flight at once.

RT: Right. We know how to do that extension so if the use case comes up we can add it.

FM: To be clear, the scenario looks like this: you have a JS application that runs responses to your requests using WebAssembly threadlets. It’s not like running threads in your Wasm.

FM: Thoughts about whether to do a new proposal or not?

TL: If existing work and context will be useful in the future, then keep it an start a new repo. Otherwise just overwrite what’s already there.

FM: There has been work, but not really in the official repo, which is fairly empty.

SL: There has also been work on Andreas’s proposal, for example an interpreter implementation also outside the main repo.

RT: It would be good to see both proposals (JS API and Wasm changes) make progress at the same time.

AR: We usually have different repos for things we want to merge separately.

FM: We also want to keep the work separate to avoid trampling one on the other.

SL: Do you envision that we still discuss both in this meeting though?

FM: Yes.

RT: We also have to coordinate to maintain compatibility.

AR: We often have cases where we have to coordinate compatibility between proposals and it hasn’t been a problem. The two repos is mostly just logistics.

FM: Another option if we split repos is that depending on the final timing of everything, if we had a JS API repo, we could merge that into the other repo before the main Wasm spec if the timelines converge.

DS: +1 for a separate proposal to advance in parallel. Agree with AR’s points.

FM: Straw poll. Option 1: continue work as a separate branch within the stack switching proposal. Option 2: new proposal before the CG.

RT: Concretely, a phase 0 proposal.

No one prefers to keep using just one repo.

FM: Given scheduling constraints on the CG, we will probably be able to do this in late august.

DS: It doesn’t sound like this phase 1 proposal will take a long time. Probably just 5 minutes. I wouldn’t have any problem carving out 5 minutes from the August 3 meeting to get this going.

RT: I have a phase 0 writeup I can post today to head off any discussion that may arise.

FM: Any technical comments about the JS API besides the question SL raised earlier?

No comments.

FM: Personally I think it is very simple, and I like that. Am hoping to get a presentation from the Swift team in the future.


### Adoption of the agenda

### Discussion:

### Adjourn



"
main/2018/CG-05-15.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 15 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: May 15, 4pm-5pm UTC (May 15, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email JF Bastien or Ben Smith to sign
up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Propose creation of new repo (not a fork of spec) for debugging/debug info. Analogous to tool-conventions.
    1. Discussion: [Change Signature of Global Constructor](https://github.com/WebAssembly/mutable-global/issues/16)   
       Currenty uses `type`, but that looks redundant in `import.type.type`. Alternate names: `content`, `value`,
       `valueType`, `element`.
    1. Should Mutable Global proposal be included in WebAssembly v1?
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

Opening of the meeting
Introduction of attendees

#### Roll call

* Andreas Rossberg
* Benjamin Bouvier
* Ben Smith
* Ben Titzer
* Brad Nelson
* Dan Ehrenberg
* Dave Voyles
* Deepti Gandluri
* Derek Schuff
* Jacob Gravelle
* Jay Phelps
* JF Bastien
* John Hall
* Keith Miller
* Lars Hansen
* Limin Zhu
* Lin Clark
* Luke Wagner
* Mike Rourke
* Pat Hickey
* Peter Jensen
* Richard Winterton
* Sean Westfall
* Sergey Rubanov
* Splurp
* Sven Sauleau
* Tyler McMullen
* Ulrik Sorber
* Yulia Startsev
* Yury Delendik

### Find volunteers for note taking (acting chair to volunteer)

JF seconds

### Adoption of the agenda

### Proposals and discussions

#### Review of action items from prior meeting.

Titzer: AI from the previous meeting about limits. Some progress made, hope to finish by the next meeting. Working w/ Dan E.

JF: Dan, can this be added to the spec?

Dan: Would reset the clock?

Brad: this adds a 90 day clock.

JF: Tested all the current implementations, any differences?

Titzer: Yes, only small differences, pinged the GH issue.

JF: Memory limit?

Titzer: Will follow up.

#### Propose creation of new repo (not a fork of spec) for debugging/debug info. Analogous to tool-conventions.

Derek: Started w/ source maps. New interest from devtools folks from Mozilla and Chrome. Also mono. Would like to propose not just repo but also CG subgroup. More than one output, a spec for debug info used by tools -- something like DWARF or source maps. Also some extension to browser devtools protocol or extension API. 
Propose to have two co-chairs: Derek and Yulia. 15 people there at last week’s meeting. Will write a charter for subgroup and bring it forward next meeting.

JF: how to proceed? People contact Derek for charter?

Derek: Yes, I think so.

Discussion about electing Yulia. But not voting this meeting.

Luke: Same debugger format in JS, should this be the same group or different?

Derek: I think this is outside the scope of wasm CG. Possible that one output is not attached to wasm spec, but something more general. One complaint about source maps is that it is just a google doc, some would like to make it more formal. We should discuss how to integrate in the meetings.

Derek: Will post charter in gist.

#### Discussion: Change Signature of Global Constructor

Currently uses type, but that looks redundant in import.type.type. Alternate names: content, value,valueType, element.

Lars: I prefer valueType.

Andreas: Some more context: we don’t use type in other names.

Titzer: What are you proposing Andreas?

Andreas: Not favouring anything, none of the alternatives are great.

Ben S: Maybe rename element -> elementType? We’re also renaming initial -> minimum.

Jay: what is the actual type of that property? What does it represent?

Andreas: it’s an object representing a value type. For now it’s just a string, an enumeration, but could be more in the future. A JS value that describes a value type.

Jay: would “name” make sense?

Andreas: you’re interested in what the name denotes. The fact that it’s a string isn’t important. Its denotation is.

General agreement that perhaps “value” is better.

Dan: I kinda prefer the existing API, but not in a strong way.

[Unanimous consent to move forward with “value”]

#### Should Mutable Global proposal be included in WebAssembly v1?

Ben: there are 3 implementations. Core and tests complete. Big concern about shipping earlier is the breaking change, would like to do ASAP. Returning global object from exports instead of returning a number. Mozilla has it on in early beta, only bug report was from Alon.

Brad: it’s just a 90 day clock, would be fine.

JF: it’s in implementation phase. Seems to meet criteria to move to standardization phase. We could had off to WG, and WG can decide whether to put in v1 or not.

Titzer: I don’t think it should be in v1.

Lars: no implicit conversion from WebAssembly.Global to numbers, risk increases as we wait.

Brad: If there were to move to stage 3 or 4, would we ship it even if it wasn’t in v1?

Titzer: Yes, we’ll ship it as soon as possible.

JF: Moving to phase 4 only hands it over from CG to WG.

Brad: in either case we’ll be adding delay.

Unanimous consent to move mutable globals to standardization phase (phase 4), including the rename we just discussed.

#### Closure
"
simd/2022/SIMD-05-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 13th video call of WebAssembly's SIMD Subgroup

-   **Dates**: 2022-05-13
-   **Times**:
    -   4pm-5pm UTC (9am-10am PDT)
-   **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this
[form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1.  Opening, welcome and roll call
    1.  Opening of the meeting
    1.  Introduction of attendees
1.  Find volunteers for note taking
1.  Adoption of the agenda
1.  Proposals and discussions
    1.  Phase 3 feedback for relaxed SIMD (Zhi An Ng)
    1.  Wasm SIMD integer extend from 8 to 32 bits (Petr Penzin)
    1.  Opcode update (Zhi An Ng)
1.  Closure

## Meeting notes

### Attendees

- Anton Kirilov
- Deepti Gandluri
- Evan Nemerson
- Petr Penzin
- Yury Delendik
- Zhi An Ng
- Richard Winterton
- Andrew Brown

### Phase 3 feedback for relaxed SIMD (Zhi An Ng)

https://github.com/WebAssembly/relaxed-simd/issues/71

Request to relax semantics for NaN and signed comparisons, by removing correlations between expected platform-specific semantics. Any result in instructions that can return multiple results should be valid. This can mean that results can change over time, which wouldn’t work for some operations, for example FMA. We want to propose fixing the semantics in the same execution environment, but without correlation between different instructions.

PP: how to formalize this?

ZN: we will share this with Adnreas and Conrad

PP: what was the feedback about detecting platforms?

ZN: they raised it as a concern, and not a hard no. If we allow users to detect the platform we should have a good reason why we want to allow that. We’re willing to expose the platform dependent bits to the user

DG: there wasn’t too much concern, usually concerns come from browsers, when we do privacy reviews, etc, It was more of a discussion rather than concern.

PP: We could use feature detect to formally detect the semantics - instead of actual computational detection.

DG: we want to make sure we detect high level features, CG can check if it is too high level or granular. Exposing too low level details as part of feature detection would encounter pushback

PP: still possible to do similar detection, if we don't have explicit API, we encourage people to do it less

DG: as we are writing the standard, we decide what tools we give developers. That's parallel to CG conversation, we don't want people to rely on those type of semantics. If hardware changes, or we support newer changes, whatever we have, it's at a higher level of granularity.

### Wasm SIMD integer extend from 8 to 32 bits (Petr Penzin)

https://gist.github.com/penzn/e3f867b340f4fb650840e2ff8617c360

PP: we have extend 8 -> 16, and 16 -> 32. x86 has 8 -> 32. For image processing algorithm, 8 bits, computation on color values, result may no fit in 16 bits, use 32 bit int. Will have some benefit. We tried to evaluate this

DG: have you filed a toolchain bug? This could be an optimization issue in autovectorizer, for example.

PP: at some O level LLVM doesn't turn on simd128, have to turn on optimizer and simd support. Could be vectorizer, but more of a codegen problem, can detect extend mask in the backend, then check correct sequence and instruction.

DG: if we want a 8->32 extend, is this something you want to spin up a proposal for? you'll still need a lot of performance data to justify. Figuring out if toolchain can optimize it will be helpful. If you take it to CG as design issue, that's likely the first question.

PP: if i go to design today, it will be heavy, we don't have an example that does this yet.

AK: we were talking about codegen x86, can see this benefiting ARM, especially for SVE extension, there are loads with extension, can be generated with single instruction. Runtime can pattern-match. The shuffles and patterns there make it quite difficult.

PP: What you see on the screen is not good, last night I was trying to find what ARM does, couldn’t find it exactly

AK: doable with SVE, not exactly the same semantics, you have extensions of overlapping elements, what you're looking at is 8 bit extend element 0 1 2 3 4 to 32. With SVE you extend 0, 4, 8,the same elements which have to be in the same 32-bit granule. Has an extension from 8->32 but doesn't match the semantics here. There are loads with extensions that match your semantics.

PP: Makes sense, will still be faster probably

AK: this particular example, there is a dot product instruction that involves signed or zero extension and then addition, could be useful for this particular example.

PP: We have the dot product instruction

DG: how widely is SVE available?

AK: in SOC released this year, ARMv9, mediatek, one plus phone.

PP: What’s the new dot product instructions?

AK: Available in both

AK: good to be forward looking, SVE is a mandatory part of ARMv9, future SOC will be ARMv9 based.

### Opcode update (Zhi An Ng)

ZA: Browsers and toolchains that have to update the opcodes, previously we were using the holes in the SIMD opcode space, decided to move it to a more consistent opcode space. In the overview there’s a binary format section, the opcodes there should be up to date. Both toolchains and engines should use new opcodes.

DG: V8 using new opcodes since 1 week ago, toolchain might be mismatched, need to sync with Emscripten. File an issue to track browsers and toolchains. How about Firefox?

YD: Firefox updated, dot product also updated, PR not merged.

ZA: I’ll file an issue for opcode coordination

Browsers will also probably pull in spec tests shortly
"
wasi/2022/WASI-10-06.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: October 6 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: October 6, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. WASI Preview 2 status update - Dan Gohman - [slides](presentations/2022-10-06-gohman-preview2-update.pdf)
    1. Worlds: modelling Environment Variables - Dan Gohman - [slides](presentations/2022-10-06-gohman-star-imports.pdf)

## Notes

### Attendees
- Johannes Becker
- Kyle Brown
- Jeff Charles
- Lin Clark
- Dan Gohman
- Brian Hardock
- Yong He
- Kevin Hoffman
- Marcin Kolny
- George Kulakowski
- Alexandru-Vlad Onescu
- Steve Schoettler
- Piotr Sikora
- Arne Vogel
- Jiaxiao Zhou (Mossaka)
- Valery Antopol
- Dan Chiarlone

### WASI Preview 2 status update - Dan Gohman


- Dan Gohman

  (See the slide linked above)
```
shortening the part to transitioning to wit
new milestone that comes before:
streams/futures
value imports
resource subtyping
additional canonical abi simplifications
no name mangling
post-return functions
implement the wasi_snapshot_preview1 api with preview2 apis
shorten the path to adoption
prototype at https://github.com/sunfishcode/preview1.wasm
polyfilling the other direction may also make sense
in general, polyfills as bridges to preview3 and beyond
wasi-sockets is going to be integrated as well
```

- Steve S

  you mentioned Command a few times, is there anything that doesn’t work equally well for a Reactor as well?

- Dan Gohman

  this milestone is a hello world sort of milestone
  all of this is usable in a reactor context as well, though



### Worlds: modeling Environment Variables - Dan Gohman
- Dan Gohman
  - using `*`-imports
  - context: wasi:cli/Command
    - a world which imports filesystem, socket, etc and exports a main
  - new idea: use a preopen variant rather than subtyping
    - closed vs open set
  - link-time capabilities
    - need a handle to get a handle
    - how do you get initial handles?
    - via preopen is one way
    - another is what I’m calling link-time capabilities
    - example of getting default monotonic and wall clocks
    - extensible for other kinds of initial handles
  - so what about environment variables? not covered by the above mechanisms
  - considerations about envvars
    - portabilitity
      - case sensitivity, limits, naming conventions
    - sandboxing
      - more of a concern
      - dont want to expose paths, usernames, auth state…
    - composition
      - if two programs communicate, do they share an envvar namespace?
    - possible solutions
      - separate sandboxes
        - expensive
      - denylists
        - hard to be complete or universally applicable or up to date
      - end user control
        - tedious, so gets scripted around
      - manifest!
        - static sidecar description of what envvars they use
        - plausible because most getenv calls are passed string constants
    - so what if envvars were wit imports?
    - what types would components using these have?
    - `*`-imports
      - a World is a family of component types
- Nathaniel McCallum
  - like the idea of describing the environment as a file of some type
  - in secure embedded compute, we don’t trust the host, so having an external trusted description is compelling
- Kevin
  - wondering if the environment variables as imports go in a world file or a component wit file?
  - and if I have large composed hierarchy of components, how do I keep one component from being able to access envvars intended for another component
- Dan Gohman
  - proposing using imports to express this
  - imports are just functions, in this case returning strings
  - the names of the functions correspond to the envvars
  - the imports can be satisfied by exports with the same signature
  - so the person doing the composing decides how to wire up imports to exports
- Dan Gohman
  - `*` means any number which allows the host to say I have a namespace, I can accept a family of components
  - also useful for http backends, kv stores, etc
- Mossaka (Joe)
  - wondering what the rust programmer experience of this is like
  - ordinarily they can do something like just get an iterator over them all
  - now there’s a lot of separate functions
- Dan Gohman
  - imagining some way for the toolchain to wire these all together
  - in rust, maybe a macro generated via the wit-bindgen tooling
- Nathaniel McCallum
  - are you concerned about overloading on the types? especially importing an envvar and something else with a potentially colliding name
- Dan Gohman
  - the import mechanism in general has a two-level design that separates out things into namespaces
  - don’t need to do any type-based disambiguation
- Nathaniel McCallum
  - do you think this will be extensible to other kinds of resources?
  - an example that comes to mind is cryptographic keys
- Dan Gohman
  - subtle tradeoffs
  - comes down to, when do you want to close the set of names that are valid?
- `*`-imports does it at instantiation time
  - in wit files is much earlier bound
- Dan Gohman
  - another question from the chat is about versioning of urls
  - my understanding from the component model is that semver-incompatible changes will get new urls, which in practice might look like embedding a version in the url
"
main/2023/CG-12-05.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 5th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: December 5th, 5pm-6pm UTC (December 5th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. [Threads subgroup charter](https://github.com/WebAssembly/shared-everything-threads/pull/21), [Thomas Lively, 10 mins]
        1. Poll to charter threads subgroup
    1. [Frozen proposal](https://github.com/WebAssembly/design/issues/1493), [Pierre chambart, 20 mins]
        1. Poll for Phase 1
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
 - Deepti Gandluri
 - Derek Schuff
 - Thomas Lively
 - Paul Dennis
 - Leo Andres
 - Pierre Chambart
 - Robin Freyler
 - Paolo Severini
 - Michael Ficarra
 - Jeff Charles
 - Ben Visness
 - Conrad Watt
 - Yury Delendik
 - Daniel Hillerström
 - Slava Kuzmich
 - Matthew Yacobucci
 - Ben Green
 - Heejin Ahn
 - Oscar Spencer
 - Dan Gohman
 - Ryan Hunt
 - Luke Wagner
 - Mingqiu Sun
 - Shaoib Kamil
 - Chris Woods
 -  Manos Koukoutos
 - Andrew Brown
 - Brendan Dahl
 - Jakob Kummerow
 - Dan Philips
 - Ashley Nelson
 - Matthias Liedtke
 - Francis McCabe
 - Bailey Hayes
 - Alex Crichton
 - Sergey Rubanov
 - Zalim Bashorov
 - Jlbirch
 - Rich Winterton
 - Kevin Moore

### Proposals and Discussions

#### Threads subgroup charter

Form to sign up to attend subgroup meetings: https://forms.gle/3MvUwqiyCFGAAfmC8

TL Presenting [Threads subgroup charter](https://github.com/WebAssembly/shared-everything-threads/pull/21)

TL: Briefly, last time I was presenting the scope, scope is large enough, we want a dedicated forum for topics related to that effort, the plan is to reuse the meeting slot from the GC subgroup, drafter a new subgroup - copy pasted from the previous charters and updated to refer to threads and thread topics and deliverables. The scope is syntax, new instructions, TLS, synchronous sharing, type system extensions … etc. as in the charter. 

No new specification deliverables beyond the usual specs that the CG makes. Also includes the usual suites of tests
Looking for a consensus to form this group.

CW: are we naming sugroup chairs now too?

TL: I volunteered to be subgroup chair, Conrad and Andrew will also be co-chairs of the subgroup. Coincides with the champions for the shared everything proposal

Asking for unanimous consent, any objections?

[no objections]

Since it’s a new subgroup, we’re starting from scratch with a new Zoom meeting, please sign up with this form, the link is in the notes. The form just asks for your email address, to confirm that you’re in the CG. We will start meeting in January.


#### [Frozen proposal](https://github.com/WebAssembly/design/issues/1493),

PC Presenting [slides](presentations/2023-05-12-chambart-freeze.pdf)

FM: Why do you include the non-null part in the freezing? You may have a null value - you want to know the value is null in the frozen value. IF you don’t include the null check, you can do this in constant time that has the same representation of the value

PC: if you don’t check for null in the phases,

FM: Not about the phases, when you have a normal value and a frozen value, the difference is that none of the frozen values have nullable values and none of the nullable values have frozen values, why do you have the second condition?

PC: if you want the immutability, you need to prevent mutability from the old version, you need to say the old version is inaccessible, can’t be modified. So im not sure we can avoid converting the value.

CW: How necessary is the phase order? It seems to me like a nested module - would we be able to get away without adding it? E.g. if you could move the second phase into a second module that gets evaluated later?

PC: I suppose yes, it would be very similar

CW: I can see the value of the freezable and the frozen extensions, the phases messes a little bit with the nested modules story in the future. 

PC: if there were nested modules, i would be happy to do it that way.

DG: pause for questions: we can do a unanimous consent poll, since this seems in scope and could be valuable, and the threshold for phase 1 is low. 

objections?
[none]

FM: who would be the champion of this?

PC: I suppose one of us could do it. If anyone would like to help or take over, that would be fine

FM: I suggest you take it, a proposal needs a champion to move it forward.

DG: we do usually assume the person proposing would be the champion unless there are other arrangements

Proposal moves to phase 1, exact name TBD

RH:  is there an idea how this could be extended for shared GC values, if there’s a freezable bit, is there a potential concurrency issue?

PC: Certainly would be concurrency issues, haven’t thought about it-  but I wouldn’t expect mutable threads to want freezable values, and wouldn’t be surprising for it to be very expensive, you could be smart and use the order of freezing operators, but I would go for the simple version and mutex everywhere. 
But I don't see why there would be specific problems otherwise.

## Closure


"
wasi/2023/WASI-05-04.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: May 4 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: May 4, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. Acting Chairs: Pat Hickey and Bailey Hayes
1. Proposals and discussions
    1. Request stage 1 vote for [`wasi-cloud-core`](https://github.com/WebAssembly/WASI/issues/520) World - Jiaxiao (Joe) Zhou
       1. [Slides](https://docs.google.com/presentation/d/e/2PACX-1vRn6D7ODoRO79C_dWh3mdfNydurOkZRmIWfoJ2hw3Lerd3Llqh4QEfXDjlLyptjXT7jmuyiviTAtUTk/pub?start=false&loop=false&delayms=3000)

### Attendees
- Jiaxiau Zhou (Joe, Mossaka)
- Lin Clark
- Eduardo Rodrigues
- Bailey Hayes
- Julien Fabre
- Jeff Charles
- Colin Murphy
- Sam Clegg
- Ben Green
- Pete Vetere
- Till Schneidereit
- Andrew Brown
- Kevin Moore
- Joel Dice 
- Dan Phillips
- Ayako Akasaka
- Piotr Sarna
- Chris Woods
- Pat Hickey
- Stephen Doyle
- Benjamin Atkin
- Dan Chiarlone (danbugs)
- Johannes Becker
- Wilson Wang
- Johnnie Birch

### Announcement of Acting Chairs

**Lin Clark:** Not a surprise, explained in the issue that added this to the agenda. I have conflicts in the next few months, so two fantastic contributors—Pat Hickey and Bailey Hayes—are going to take on acting chair duties. Thank you both!

### Stage 1 vote for wasi-cloud-core

**Bailey Hayes:** Anything you want to add Joe? Basically means we’ll create the repo for it. Traditionally we have run a vote for if anyone is against this proposal. Open it up right now? Is anyone against moving forward with WASI cloud core?

**Jiaxiao Zhou:**  I actually prepared a short intro. I imagine most of you have already heard this proposal. It is an issue in wasi repo, 520. It’s a new world definition. World defines all the imports and exports of a component. This is the core set of func we want to do in distributed applications. Intended to support bursty workloads. We intend to support 80% of workloads. Last year, we proposed wasi-cloud set of interface proposals. Includes wasi-kv, etc. This is the concrete form of them all coming together. If you want to know even more background, portability you can watch our talk from CNCF Wsam Day. Most proposals have a draft under review. Please raise issues if you have questions. What’s interesting about wasi-cloud-core is that is does not expose lower level APIs like socket. That’s pretty different than the CLI world, which has lower level APIs. It will export a single HTTP handler. Include syntax not yet part of CM, but I’m working on that in issue 169 on CM repo. If you want to know more about include, I have a presentation from previous CG meeting.

Next step: I want to request vote to move to phase 1. Last I want to mention SpiderLightning, just our implementation. That’s how we’re verifying that these all make sense. If you’re interested, check it out.

**Pat Hickey:** So all those includes are what you said. What I’m missing is what’s inside each of those. What transitive dependencies does that imply. I don’t think we need to answer that in this moment. I think that’s just a tooling question we want to make really easy to answer. 

**Jiaxiao Zhou:**  I think semantics of include will do dedup. 

**Pat Hickey:** Right, we’re going to expect most if not all depend on HTTP. I think none of those imply depending on wasi-filesystem.

**Jiaxiao Zhou:**  No

**Pat Hickey:** The stuff I’m working on how libc integrates. THis doesn’t provide some things that your program might expect. The story we have there is this world doesn’t provide a filesystem, but if your program depends on it, then you need to compose your component with another component that provides those interfaces. So this is a case where what’s not in this world is actually important. 

**Jiaxiao Zhou:**  That’s a great point, that’s exactly what I was going to say. The power of virtualization plays a big role here. A component that uses wasi-cloud-core can be composed with a virtualed-fs that uses blob storage or kv. 

**Sam Clegg:** We’ll presumably have some flags in libc that target the cloud world

**Pat Hickey:** Dan Gohman just put up a PR that makes preopens lazy. If your libc never calls open, then you probably don’t need to populate the preopens table, which means at link time you don’t even include the preopens function. We’re hoping between laziness and link time optimization, we can get that effect. But we might also provide a flag for it—that’s a possibility.

**Bailey Hayes:** One thing to note: stdio is necessary. We got that working through composition with host APIs. That’s kind of the same idea, and it does work, so that’s kind of exciting

**Pat Hickey:** One other thing, the transitive dependency I’m imagining is wasi-logging

**Jiaxiao Zhou:**  it’s included in wasi-http

**Eduardo Rodrigues:** This takes the default world that is defined in wasi-kv. My assumption is that you’re just taking the default world

**Bailey Hayes:** Poll—Any objections?

### Heads up on PR

**Pat Hickey:** Not on the agenda, but just wanted to call out [a PR](https://github.com/WebAssembly/component-model/issues/193). Changes to wit syntax and packaging dependencies. We want to make some adjustments, and I think it’s pretty cool, so just want others to know about it.
"
wasi/2021/WASI-09-09.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the September 9 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: September 9, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Lin Clark
    - Email: lclark@fastly.com

### Registration

None required if you've attended before. Email Lin Clark to sign up if it's your first time. 

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Poll for wasi-parallel to phase 1 ([temporary spec repository](https://github.com/abrown/wasi-parallel-spec/))
    1. Async and resources ([slides](https://docs.google.com/presentation/d/13oogBiC_X3_IWla_K9noz8wH13fMJl7goSTObiP3X0s)) (30 min)
    1. _Sumbit a PR to add your agenda item here_

## Notes

### Attendees

- Lin Clark
- Piotr Sikora
- Luke Wagner
- Ben Titzer
- Till Schneidereit
- Vibhav Pant
- Yong He
- Bailey Hayes
- Andrew Brown
- Pat Hickey
- Alex Crichton
- Johnnie Birch
- Mingqiu Sun
- Ralph Squillace
- Brian Hardock
- Radu Matei
- Dan Gohman

### Poll: wasi-parallel

**Andrew Brown:** Currently spec is at abrown, but want to move to Wasm org because I’ll be out for 2 months. Also published a [POC implementation](https://github.com/abrown/wasmtime/tree/wasi-parallel).

Just a POC, ignore the hacks. Johnnie, Petr, and Mingqiu will be active on this while I’m out.

**Lin Clark:** consensus vote [no objections]

### Async and resources

**Luke Wagner:** Way back in Jan, gave preso about handles and resources. How do we pass opaque handles in a composable way. In May, talked about blocking and reconciling coroutine and callback style ABIs. In August, talked through async streaming. In that, proposal to generalize blocking to async effect. 

Lead user is HTTP API. If we can do it right for HTTP, I think it will pave the way for many other WASI APIs. Litmus tests are composability and bindability. 

Based on that, what’s still needed? [slide]

Resource methods [slide]

Any questions?

**Andrew Brown:** When you import foo, what does that look like in core wasm.

**Luke Wagner:** When we see the core wasm, I’ll get back to this question, but roughly looks like import of function with int. 

**Andrew Brown:** And import would be bar_foo?

**Luke Wagner:** Because you’re linking, you get to choose the name.

**Andrew Brown:** But you have to say the name you want to import, though.

**Luke Wagner:** Yeah, at the IT level, you would import resource R with foo… the whole thing.

**Vibhav Pant:** To the last point about virtual dispatching impl detail. Does that mean that how to dispatch is left to the language ABI. Doesn’t that mean this could impair interop?

**Luke Wagner:** Is there a specific kind of hazard that you’re thinking about?

**Vibhav Pant:** Since dispatch is left to each lang implementing in its own way, since you have different languages in the same app, that would impair?

**Luke Wagner:** My impression is that it will help interop because it’s a contract between two components. Whether it’s polymorphic dispatch or not is a detail of that language that’s on the other side of the call. What happens on the other side gets to be the languages decision. The constraint of specifying exactly what you’re calling opens up ___.

**Till Schneidereit:** Virtual dispatch doesn’t exist at component boundary. Only happens within a boundary. VD mechanism is fully encapsulated.

**Luke Wagner:** Yeah, that’s a good way to say it.

**Luke Wagner:** Resource constructors [slide]

**Ben Titzer:** Something special about type handle as R?

**Luke Wagner:** Yeah, that goes back to the Jan presentation. There’s a type constructor handle for any resource type R. ___. When you have multiple components, you have to care about lifetimes.

**Luke Wagner:** async constructor? [slide]

**Luke Wagner:** stream everywhere [slide]

**Luke Wagner:** Next I’ll show an example [slide]

**Luke Wagner:** Example resource impl [slide]

Here’s where I can arbitrarily create the string. These strings become an internal choice.

Invert this and that’s what the client sees.

**Andrew Brown:** Ok, I think I got it.

I had a question on the previous slide. Writer-func… what does zero mean

**Luke Wagner:** In general case, function pointer that gets instantiated ___. Zero is reserved. It means there is no writer function, second param is the stream. 

**Andrew Brown:** Let’s say we put number 42 there instead, what would that mean?

**Luke Wagner:** Have to be an index to a function ref in the funcref table.

**Till Schneidereit:** So functable needs to be 1-indexed?

**Luke Wagner:** Kind of nice to have zero not be a valid thing. 

**Luke Wagner:** Next steps [slide]

Any questions?

**Vibhav Pant:** Would uniqueness invariants be enforced statically?

**Luke Wagner:** Great question. Big constraint of Wasm is that it doesn’t have rich types, so can’t do constraint checking at boundary. With IT was can do it because handle already in semantics already has a ref count. Dynamic semantics can ensure at boundary. If your lang has static type checking, then you can rely on the langs safety checks.

**Vibhav Pant:** If this was imposed statically, could you opt it out?

**Luke Wagner:** It would be hard to tell the engine that it can trust without including this info.

**Till Schneidereit:** Also, langs like Swift have established pretty solidly that autoref counting at these kinds of boundaries are ok perf-wise. Components aren’t meant to be tiny-tiny.
"
wasi/2020/WASI-01-16.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the January 16 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: January 16, 17:00-18:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Proposals and discussions
    1. WASI design principles PR:
        1. https://github.com/WebAssembly/WASI/pull/192
    1. What should `poll` for no events do?
        1. https://github.com/WebAssembly/WASI/pull/193

## Meeting Notes

Attendees:

Dan Gohman
Jan Falkin
Johnnie Birch
Sam Clegg
Wouter van Oortmerssen
Mingqiu Sun
Andrew Brown
Alex Crichton
Peter Huene
Stefan Junker
Aaron Turner
Radu Matei
Brian Hardock
Ralph Squillace

Meeting notes:

##Pull 192: https://github.com/WebAssembly/WASI/pull/192
(...)
Note SJ: not sure about a conclusion on this one

## Link-time virtualization: https://github.com/WebAssembly/WASI/pull/69

DG: A way to override imports with alternative implementations of the same API

Sbc: How about using the term “interposition” vs “virtualization”?
(...)
Sbc: I’m okay with “virtualization” as long as we know we don’t mean dynamic dispatch
DG: let’s discuss dynamic dispatch. 
Sbc:  I like the idea of keeping system interfaces simple and not bring in object orientation
DG: okay, can revisit this later. It’s also tricky cause it depends on features which aren’t done yet, namely interface types and (...)
Sbc: embedder decides linking, so they could have interposition or not, so the module isn’t in the position to dictate that
DG: How linking is being done today is not final

Existing virtualization doc: https://github.com/WebAssembly/WASI/pull/69

Close this PR for now, citing the fact that the spec mechanisms we need to do this aren’t well defined yet, so we’ll focus on the simple thing for now.

## POSIX compatibility
DG: people are surprised that WASI does not align with POSIX. We see justified reasons for this, but it means that applications will have to port to WASI and can’t just recompile for a different target. For compatibility we can have an emulation layer, but for more performance usage to the native syscalls will be beneficial.
Sbc: agree that we need a compatibility layer for easier transition to WASI
DG: once we have a better solution for accessing files, a lot of concerns will go away


## What should poll for no events do? https://github.com/WebAssembly/WASI/pull/193
DG: As WASM doesn’t have signal handlers and might never have, does it make sense to poll indefinitely with no subscribers?
PH: Personally I think it should return `EINVAL` see (https://github.com/WebAssembly/WASI/pull/193#issuecomment-572737431)
AB: what happens to existing programs if we change this?
PH: if we start returning EINVAL from this, probably no one’s checking for it
DG: we could expose the change through a link failure with helpful documentation references. We could also put the feature back in once we have signals

## Framebuffer API https://github.com/WebAssembly/WASI/issues/174
AT: 
Sbc: Is this using an mmap’ed file?
DG: I don’t know the API, but could we mmap the file into the runtime
Sbc: it probably needs an extra copy for copying between WASI and host memory
AT: Is this a good idea or do we need WebGL, and only that?
DG: we don’t have to wait for use cases which require WebGL, and we can implement the simple thing (framebuffer) now
AT: are there documents on how to get started with new syscalls?
DG: A C header file would be enough to get started.
AT: Cool, so I’ll get started on that
DG: are we going to have an audio API too?
AT: probably
DG: we’ll have to be careful about synchronizing the data flow
Sbc: Will consumers call these functions directly as opposed to using a libc wrapper
DG/Sbc: (...) probably?
DG: It’ll be great to have this so other API functions can follow this trail, like bulk copy, clearing the screen. So we can figure out questions like if we should pull those APIs in the WASI SDK, etc.

## Presence on the upcoming in-person meeting?
Sbc to file an issue.




PE: Will be presenting on an embedder api for wasi at the cg meeting.
Sbc: maybe we should open an issue to collect items and see if it justifies an in-person meeting

## Status on networking syscalls
DG: fastly and DG had an in-person meeting to discuss HTTP proxy API. Lots of pressure on network API due to asynchronous requirements, which depends on mechanisms which we don’t have (standardized) yet, e.g. coroutines, expressing synchronicity in interface types, etc.
PH: where’s this work tracked?
DG: there aren’t specific issues 
SBC: Isn’t libevent which is synchronous the defacto standard?
DG: async depends on which level in the stack you’re looking at. Something which looks async to the application using callbacks, might be using a poll loop a layer below.
DG: we could have a single event loop for various events which is great for API builders, but not for application builders which might want their own event loop
SJ: what next steps are required to progress here?
DG: figuring out async, and then we need a proposal. We want to avoid a system which has either all networking or no networking. Ideally we’d like to have handles. Please reach out to me so we can discuss ideas. 
"
wasi/2022/WASI-07-14.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: July 14 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: July 14, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Poll: should the definition of wit move into the component-model ([WASI/#484](https://github.com/WebAssembly/WASI/issues/484))
    2. Component Model async proposal (part 3) ([slides](https://docs.google.com/presentation/d/1MNVOZ8hdofO3tI0szg_i-Yoy0N2QPU2C--LzVuoGSlE))

### Attendees:
- Lin Clark
- George Kulakowski
- Luke Wagner
- Mossaka
- Andrew Brown
- Bailey Hayes
- Brian Hardock
- Bálint Molnár
- Dan Gohman
- danbugs
- Dave Bakker
- David Justice
- Flaki
- Ghazal
- Jeff Charles
- jlbirch
- Joel Dice
- Krisztian Gascal
- Piotr Sikora
- Radu Matei
- Ralph Squillace
- Richard
- Saúl Cabrera
- sbc
- Shiyu Yuan
- Steve Schoettler
- Kevin Moore
- Chris Suszynski

### Poll: should the definition of wit move into the component-model (WASI/#484)

No objections, poll succeeds!

### Component Model async proposal (part 3) (slides)

Presented by Luke Wagner, hopefully the last of these installments :)

- revisiting a `future` example
  - task originally owned by the stack
  - can pass the ownership explicitly
  - respecting the full structured concurrency model
  - the canonical abi special cases the outparam case to enable eager return
- general case where we don’t eagerly return
  - let’s return a `future<list<future<string>>>`
  - walking through creation of and transfer of this set of tasks, which share a linear memory, to the host
  - in general, futures and streams can be arbitrarily nested in both parameters and results
- example passing through a parameter
  - taking a future through and forwarding it on
- something more realistic: a streaming file write
  - forward the finished-writing task on


Q: Is there a difference between a read and a write handle to a stream?
A: Yes, when you create the task, you also get a subtask which represents ownership of the consuming end of the stream. Slightly analogous to a pipe, but there’s no buffer or any of that

Q: So there’s no type distinction?
A: Right. Just whether it is a return or a parameter. You can take language-level readable and writable streams and map them down to this, though. In theory could have the other direction too, but doesn’t seem strictly necessary, and adding the other direction of polarity seems just confusing and adds the need to make an arbitrary choice as an API designer.

- Concurrent export calls
  - example of doing synchronous reads and writes from C
  - leads us to cooperatively interleaved native and shadow stacks
  - you can decide not to support it by having an input stream and output stream and you can’t be reentrant, instead things are called from the start
- Commands vs reactors
  - commands entered once
  - reactors reentrant
- Core wasm stack switching
  - under active development
    - CG meeting
    - V8 implementation work
  - low-level primitives for a number of control flow constructs
  - sketch of canonical abi wired up to this proposal

Q: What exactly is this `cur_eventloop`? How do we know it’s None before calls?
A: Global scope in our component instance. It shouldn’t be clobbered, we should always be updating it as we go along lifting and notifying.

Q: So these shouldn’t be reentered?
A: Yes! And this reflects that property in the component model docs. You may suspend but not get reentered.

- Task scheduling
  - Found that it had to be defined
  - The task tree is the scheduler state
  - Each iteration, one of the following transitions happens (nondeterministically)
    - host calls a component export
    - progress on a host leaf task
    - copy values from a writing/returning subtask to a listening supertask
    - notify done tasks
    - only if none of the above apply: allow partial read/write notification
    - only if none of the above apply: block
  - thus, two-level scheduling
    - inter-component via the scheduler loop
    - intra-component via the language runtime (or whatever! in the core wasm
- Task cancellation
  - canonical abi builtin for it
    - can’t just delete the task, have to unwind all the state up the tree
    - can’t just call it “once”
      - may legitimately need to schedule async work to unwind
    - need it to be cooperative, in general
      - note that we need a different and bigger scope for non-cooperative failure anyway (“blast zone”)
  - cancellation adds a new cancel state that tasks can transition to before finishing
    - still can’t drop etc too soon
  - can map down from language-level constructs
    - explicit, like JS AbortController
    - implicit, maybe like JS GC collecting an unresolved progress
  - working through interactions between concurrent cancellation and listening
  - other aspects of cancellation
    - unlistening, introducing backpressure, less than cancelling an entire stream
    - unlisten, unwrite, unreturn
- The bonus question: How does stream teeing work?
  - Wrap it up next time, with summary
"
main/2018/CG-02-21.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 21th video call of WebAssembly's Community Group

- **Host**: Google Hangouts
- **Dates**: Wednesday UTC (Tuesday PT) February 21th, 2018
- **Times**: 07:00–08:00 UTC (11PM–midnight Pacific Time, February 20th)
- **Location**: *same Google Hangouts link as before*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

None required if you've attended before. Email JF Bastien to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Future in-person meetings.
    1. Rename memory operations
       * https://github.com/WebAssembly/spec/issues/627
       * https://github.com/WebAssembly/spec/pull/649
    1. Layer 1 encoding proposal
       * https://github.com/WebAssembly/design/issues/1180
    1. Discussion of Anyref + Host-Bindings (Brad Nelson + Andreas Rossberg)
       * Discussion of reduced host-bindings proposal.
       * Gist:
https://gist.github.com/rossberg/be5962c37e5e749285272622f52b4223
       * POLL: We should create a separate 'anyref' repo
         to hold a Phase 0 proposal that peels of anyref + Table(anyref) 
         from the GC / managed objects proposal.
    1. Content Security Policy (Eric Holk, [slides](https://docs.google.com/presentation/d/13WYycQqqegM5B_G7gRtQpD6CfBvcEy9yGobRtio6A1E/edit#slide=id.p))
       * Discussion on use cases for and behavior of `'wasm-eval'` source directive
       * https://github.com/w3c/webappsec-csp/pull/293
    1. Annotation syntax for the text format (Andreas Rossberg)
       * Provide generic notation to represent custom (section) information in text format
       * POLL: We should create an `annotations` repo
         to hold a Phase 0 proposal to define annotation syntax for the text format.
    1. BigInt/i64 JS API integration (Daniel Ehrenberg)
       * https://github.com/WebAssembly/spec/pull/707
    1. Other items TBD
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting notes

### Roll Call

* Alex Danilo
* Arun Purushan
* Ben Smith
* Daniel Ehrenberg
* Deepti Gandluri
* Eric Holk
* Heejin Ahn
* JF Bastien
* Katelyn Gadd
* Keith Miller
* Lars Hansen
* Mark Miller
* Mark Nottingham
* Paolo Severini
* Sergey Rubanov
* Sven Sauleau
* Tyler McMullen
* William Maddox


### Opening

#### Adoption of the agenda

*Brad seconds*

#### Find volunteers for note taking (acting chair to volunteer)

*JF volunteers*

### Discussions


#### Review of action items from prior meeting

* [Update phases proposals](https://github.com/WebAssembly/meetings/issues/163) Brad will review and merge
* [Web-standards meeting technology](https://github.com/WebAssembly/meetings/issues/157) nothing so far


#### webassembly.org maintenance

*Alex Danilo*

webassembly.org was maintained by Seth, but he went to grad school. Now unmaintained. [See doc](https://docs.google.com/document/d/1pTG4BtIETf1wkZ5Xq3OHAKadv-hi13p7_CGHfBon9Yw/edit#heading=h.16it8hze90l7), provide feedback. We’ll revisit next meeting.


####  Future in-person meetings

Confirmed:

* April 10-12
* Fastly SF office
* 475 Brannan Street, San Francisco, CA 94107

At least half-day, maybe full-day, WG business on Thursday.

Agenda coming soon: https://github.com/WebAssembly/meetings/blob/master/main/2018/CG-04.md

No topic yet, let’s fill it out over the next few weeks.


#### Rename memory operations

*Ben Smith*

       * https://github.com/WebAssembly/spec/issues/627
       * https://github.com/WebAssembly/spec/pull/649

Let’s table and discuss next meeting.


#### Layer 1 encoding proposal

*Katelyn Gadd*

* https://github.com/WebAssembly/design/issues/1180
* JF / Brad: good start, interested in getting other people’s inputs.
* Lars (speaking for Luke) isn’t impressed by brotli wins, expected something like macros for layer 1.
* Katelyn: yes, there’s more that can be done.
* Keith: how do macros work?
* Katelyn: *explains*
* Keith: risk of over-fitting compression to what modules look like today, not tomorrow?
* Katelyn: yeah, but tradeoffs with macros versus streams, want to avoid baggage. Ideally most effort is on the compression, so browsers don’t have to change too often.

*AI:* Brad to ping tooling people, as well as Brotli people.


#### Discussion of Anyref + Host-Bindings

*Brad Nelson + Andreas Rossberg*

* Discussion of reduced host-bindings proposal.
* [Gist](
https://gist.github.com/rossberg/be5962c37e5e749285272622f52b4223)
* Potential simplification of host bindings we we peel this off.
* Opaque, doesn’t require GC, could be refcounted.
* Could make host bindings much simpler.
* Might require more type checks, lose some perf, but expect minor.
* JF: want to make sure non-web embedding also tries this out.
* Tyler: Fastly is interested in trying this out.
* Limin: difference with host bindings proposal?
* Brad: used to conflate levels, and allocation / pre-allocation of table slots.

**POLL:** We can (at champions’ discretion) create a separate 'anyref' repo to hold a Phase 0 proposal that peels off anyref + Table(anyref) from the GC / managed objects proposal.

*Unanimous consent*

*AI:* Brad to circle back with Andreas, choose direction.


#### Content Security Policy

*Eric Holk*

[slides](https://docs.google.com/presentation/d/13WYycQqqegM5B_G7gRtQpD6CfBvcEy9yGobRtio6A1E/edit#slide=id.p)

* Discussion on use cases for and behavior of `'wasm-eval'` source directive
* https://github.com/w3c/webappsec-csp/pull/293
* Need to have a WebAssembly + webappsec meeting to get to an agreeable design.

*AI:* Brad to set up joint meeting. Anyone interested should reach out to Brad.

#### Annotation syntax for the text format

*Andreas Rossberg*

       * Provide generic notation to represent custom (section) information in text format

*tabled since Andreas not here today*

**POLL:** We should create an `annotations` repo to hold a Phase 0 proposal to define annotation syntax for the text format.

#### BigInt/i64 JS API integration

*Daniel Ehrenberg*

* https://github.com/WebAssembly/spec/pull/707
* New JS proposal for arbitrary-sized integers. Now at Stage 3.
* Could now map i64 to BigInt in a JS embedding.

*POLL:* make a new repo for BigInt/i64 JS API integration.

*Unanimous consent*

*AI:* JF to create repo and tracking issue, with Dan as champion.

* [repo](https://github.com/WebAssembly/JS-BigInt-integration)
* [tracking issue](https://github.com/WebAssembly/design/issues/1186)

"
benchmarking/2024/benchmarking-02-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 9th of WebAssembly's Benchmarking Subgroup

- **Where**: Google Meet
- **When**: February 9th, 4pm-4:45pm UTC (8am-8:45am PDT, 11am-11:45am EST)
- **Location**: _Link on calendar invite_
- **Contact**:
    - Name: Petr Penzin, Saúl Cabrera
    - Email: penzin.dev@gmail.com, saul.cabrera@shopify.com


### Registration

If this is your first time attending, please [fill out the registration form](https://forms.gle/QCmhyM4QwvWvZR9b8) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

### Logistics

This meeting will be a Google Meet video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes
    1. Please help take notes.
1. Announcements
1. Proposals and discussions
    1. Logistics of this subgroup
    1. Current benchmarking related projects and a potential presentation of
       each.
1. Closure

## Attendees

* Saúl Cabrera
* Ben L. Titzer
* Andrew Brown
* Daniel Lehmann
* Marco Concetto Rudilosso
* Johnnie Birch
* Peter Penzin

## Meeting notes

### Logistics of this subgroup

SC: PR with notes templates is open

### Introduction of benchmarking projects

SC: A good next step is probably to make presentation about the various existing
benchmarking projects.

JB: Wasm Score. Built on top of Sightglass.

JB: Would it make sense to talk about Sightglass first?

AB: Would be good to have a joint presentation on sightglass. Is one of the goals to create a common benchmark suite?

BT: We created a charter that explicitly says that we won't do that. We should focus on recommendations and tools, but not necessarily a suite. Tools seem to be more important in this case.

AB: Agree that we shouldn't create a suite to rule them all. But sometimes it's easier to share a standard suite, for example when referencing papers in which people refer to performance results. 

JB: What would drive the agenda?  Good practices and understanding the lay of the land. What is that we'd try to produce. 

SC: What people are trying to measure, what things are missing currently, what to improve? I myself don’t have a great understanding of how/what to measure. There are different aspects of measuring - from compilers, hardware, etc

BT: For example, microbenchmark. IMO they have a lot of use and maybe we can think about how we are going to use micorbenches and what will we use them for: maybe measure teering or instantiation time etc. Also we should collect benchmarks together short of creating single authoritative suite.

DL: Interested in knowledge sharing and best practices. Also concrete workloads, but careful with producing a single score (which could be overfitted on). 

JB: Which is the vehicle for benchmarks? (e.g. the runtime). Maybe the benchmark has setjmp/longmp and needs to be supported by the runtime.

DL: Depends also on the host environment, e.g., V8 can rely on JavaScript. So necessarily won’t be a single suite for everywhere, but different subsets.

PP: Not every benchmark might apply everywhere, so depending on the context, you might want a different suite/engine. An interesting focus area is how to do things across different engines though.

AC: Some benchmarks could be domain specific. Real time embeddings for example are critical. 

DL: Should we start collecting current benchmark efforts in a list?

BT: There are different reasons: comparing hardware, comparing engines, comparing against native, or just even deciding if wasm would work for particular use case that you are interested in.

JB: It's important not to prescribe how the benchmarks should necessarily do or where they should run. It's context in most cases. 

PP: The hope is that we'd be able to piggyback on the current work that people are doing to point them in the right direction, depending on what they want to measure. 

BT: “Advice for the casual benchmarker”: like for example saying here are the things that you should do or shouldn't do. “You’re writing a microbenchmark? Here are some things to watch out for and maybe some reasons you see weird results.”

PP: There was a suite by Siemens (?) I don't have sources anymore. 

AC: Initially we did some latency analysis to look at Wasm in general, then we did some Wasm runtime analysis and then there's another effort to make these benchmarks more generic. 

PP: Can it be put on GitHub?

AC: GitHub not allowed, but it could maybe be shared. I'll check with Chris Woods. The newest effort is more refined and can probably do a presentation  about it. 

SC: for the next meeting, Johnnie, did you want to present wasmscore or do you want to convene with Andrew and Nick first

JB: we can talk about this offline

SC: I will check with you and then we’ll decide

AB: Let me talk with Nick and Johnnie and we will let you know

### Current benchmarking efforts
* JetStream 2 line items: https://browserbench.org/JetStream/in-depth.html 
* Some smaller/individual programs
* Sqlite3 speedtest1: https://www.sqlite.org/testing.html 
* libsodium: https://github.com/jedisct1/libsodium.js 
* Unity benchmark: https://blog.unity.com/engine-platform/webassembly-load-times-and-performance 
* PSPDFKit benchmark: https://pspdfkit.com/webassembly-benchmark/ 
* SPEC CPU / Browsix: https://www.usenix.org/system/files/atc19-jangda.pdf 
* Polybench
* Wish-you-were-fast: https://github.com/composablesys/wish-you-were-fast (titzer)
* Experiments from a couple Wizard papers (titzer)
* Sightglass: https://github.com/bytecodealliance/sightglass
* WasmScore: https://github.com/bytecodealliance/wasm-score 
* Wasm-R3: https://github.com/jakobgetz/wasm-r3
* Siemens benchmarking efforts (Ajay, Chris)
* Selected academic papers and how they benchmark Wasm
* Performance prediction using ML (Tianshu Huang)
* Lessons from benchmarking in other domains
* Java: DaCapo, SPECjbb, jolden, Renaissance
"
gc/2021/GC-11-30.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: November 30, 5pm-6pm UTC (November 30, 9am-11am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
      1. Presentation: Isorecursive types in Wob and Waml (Andreas Rossberg, 30 minutes)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Aske Simon Christensen
- Pierre Chambart
- Zalim Bashorov
- Conrad Watt
- Francis McCabe
- Emanuel Ziegler
- Manos Koukoutos
- Andreas Rossberg
- Alon Zakai
- Lars Hansen
- Adam Klein
- Keith Miller
- Rick Battagline
- Jakob Kummerow
- Deepti Gandluri
- is
- Ryan Hunt
- Luke Wagner
- Asumu Takikawa
- Slava Kuzmich
- Derek Schuff

### Presentation: Isorecursive types in Wob and Waml (Andreas Rossberg, 30 minutes)

[slides](presentations/2021-11-30-rossberg-compiling-for-iso-recursion.pdf)

TL: Can you remind us what the signature information in the custom section for Wob is?

AR: It maps exported module items

FM: As a practical matter you probably wouldn’t want to track order of declarations in the source. For example changing order of declaration in Java should not break anything.

AR: Not sure it’s a practical concern if you have to recompile after reordering things, but you could go with the normalization solution instead.

FM: Common situation is adding more functionality to a module, which would change its recursion group.

AR: In that case, you have to recompile your consumers anyway.

FM: Not in e.g. Java. This is important.

AR: Right, but we have a working assumption that our separate compilation is more similar to C++ where you might need to recompile even if you change private layout information. That’s a limitation I am ok with accepting for now.

TL: We used to have type ordering in Binaryen but it was subtly wrong and we ended up just deleting it. For ordering items in a rec group, did you have to consider supertypes to break ties between otherwise equivalent types?

AR: Supertypes would be part of the syntax that is being ordered in the first place. Another note: multiple supertypes (in the future) would need their order canonicalized.

LW: Why do the SCCs (which form a DAG) need to be ordered?

AR: So that the type indices referring to types in previous SCCs have stable numbers.

PC (chat): Can't you have some kind of equivalent problems of ordering if there are 2 exactly equivalent types but that are exported? Would you also need to canonicalise the orders of exports too?

AR: This implementation does not use type imports and exports. Exports wouldn’t make a difference, but you would have to canonicalize the order of imports, probably based on the name, since you might not have other information. This would depend on all modules using the same import names, which seems reasonable.

FM: 200 lines of change to Wob. What is that as a percentage?

AR: About 5600 lines total for Wob. Waml is 12000 (but might be counting the wrong thing). Definitely on the order of several thousand lines each.

TL: For the question of whether the isorecursive system is powerful enough because of its limited (i.e. non-structural) subtyping, do we think that falling back to a more general/uniform representation would always work?

AR: Yes, in the extreme case you would have to cast on every access, but of course you want to minimize that. Neither Waml nor Wob need recursion+structural+subtyping and I don’t think any language categories I am familiar with would need that, so I think that shouldn’t commonly come up.

FM: Smalltalk?

AR: Wouldn’t be able to depend on the Wasm type system.

AZ: This was very helpful to understand the tools side. Do you have an idea of how it would impact the VM side compared to nominal?

AR: The engine would have to canonicalize everything up front then proceed as with nominal. I don’t think this should be too much work. All the responsibility for dealing with the complexities of recursion are shifted to the producer.

MK (chat): Could you remind me: how do you distinguish two rec groups that happen to be identical if your source language has nominal semantics? Do you still need to implement your own type system on top with type tags?

AR: Wasm type system is not supposed to maintain all the type distinctions of the source language. For example when compiling to linear memory, you lose all distinctions completely. The goal is only to describe data layout to the engine for efficient and safe access, not to enforce variants from the source. If you want to enforce more invariants, you have to encode that information separately.

AR (after meeting):  Btw, I'm not sure I understood the last question about type tags correctly. If the question was referring to runtime types, then yes, rtt.fresh remains the (partial) solution to that.
"
main/2018/CG-03-06.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 6th video call of WebAssembly's Community Group

- **Host**: Google Hangouts
- **Dates**: Tuesday March 6th, 2018
- **Times**: 17:00–18:00 UTC (9AM–10AM Pacific Time)
- **Location**: *same Google Hangouts link as before*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

None required if you've attended before. Email JF Bastien to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Future in-person meeting: [hosted by Fastly in San Francisco in April](https://github.com/WebAssembly/meetings/blob/master/main/2018/CG-04.md)
    1. [webassembly.org maintenance](https://docs.google.com/document/d/1pTG4BtIETf1wkZ5Xq3OHAKadv-hi13p7_CGHfBon9Yw/edit) (Alex Danilo)
    1. Rename memory operations
       * https://github.com/WebAssembly/spec/issues/627
       * https://github.com/WebAssembly/spec/pull/649 (short names)
       * https://github.com/WebAssembly/spec/pull/720 (long names)
    1. Annotation syntax for the text format (Andreas Rossberg)
       * Provide generic notation to represent custom (section) information in text format
       * Gist: https://gist.github.com/rossberg/c0fa2e20d7614b128a9ffb5c5ab50dde
       * POLL: We should create an `annotations` repo
         to hold a Phase 0 proposal to define annotation syntax for the text format.
    1. ES module integration (Lin Clark)
       * https://github.com/WebAssembly/design/issues/1087
       * Discussion with webpack: https://github.com/webpack/webpack/issues/6433#issuecomment-363585102
    1. WebAssembly BigInt integration (Daniel Ehrenberg)
       * https://github.com/WebAssembly/JS-BigInt-integration
       * https://github.com/WebAssembly/spec/pull/707
       * Where should this be in the process?
    1. HTML serialization of WebAssembly.Module objects (Daniel Ehrenberg)
       * https://github.com/WebAssembly/spec/pull/711
       * Where should this be in the process?
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Roll Call

* Arun Purushan
* Ben Smith
* Ben Titzer
* Brad Nelson
* Dan Gohman
* Daniel Ehrenberg
* Deepti Gandluri
* Derek Schuff
* Eric Holk
* Heejin Ahn
* JF Bastien
* Jacob Gravelle
* Keith Miller
* Lars Hansen
* Limin Zhu
* Lin Clark
* Luke Wagner
* Malcolm White
* Marcos Diaz
* Michael Ferris
* Michael Holman
* Paolo Severini
* Pat Hickey
* Richard Winterton
* Robert Hitchcock
* Sam Clegg
* Sean Larkin
* Sergey Rubanov
* Sven Sauleau
* Till Schneidereit
* William Maddox




### Find volunteers for note taking (acting chair to volunteer)

*JF volunteers*

### Adoption of the agenda

*Brad seconds*

### Proposals and discussions

#### Review of action items from prior meeting.

* [webappsec joint meeting](https://github.com/WebAssembly/meetings/issues/175) Brad and Eric sorting out Google’s point of view first.
* [Layer 1 encoding](https://github.com/WebAssembly/meetings/issues/174) Brad talked to tools folks, think it probably layers. No brotli chat yet.

#### Future in-person meeting

[Hosted by Fastly in San Francisco in April](https://github.com/WebAssembly/meetings/blob/master/main/2018/CG-04.md)

#### webassembly.org maintenance

*Alex Danilo*

[webassembly.org maintenance](https://docs.google.com/document/d/1pTG4BtIETf1wkZ5Xq3OHAKadv-hi13p7_CGHfBon9Yw/edit)

Let’s move forward with it.


#### Rename memory operations

*Ben Smith*

       * https://github.com/WebAssembly/spec/issues/627
       * https://github.com/WebAssembly/spec/pull/649 (short names)
       * https://github.com/WebAssembly/spec/pull/720 (long names)

*Postponed*


#### Annotation syntax for the text format

*Andreas Rossberg*

Provide generic notation to represent custom (section) information in text format

[gist](https://gist.github.com/rossberg/c0fa2e20d7614b128a9ffb5c5ab50dde)

**POLL:** We should create an `annotations` repo to hold a Phase 0 proposal to define annotation syntax for the text format.

*Unanimous consent*

*AI:* JF to create repo and tracking issue. Andreas to populate.


#### ES module integration

*Lin Clark*

       * https://github.com/WebAssembly/design/issues/1087
       * Discussion with webpack: https://github.com/webpack/webpack/issues/6433#issuecomment-363585102

[Slides](https://linclark.github.io/wasm-es-modules/slides/2018-03-06/#/0)[Slides with presenter notes](https://linclark.github.io/wasm-es-modules/slides/2018-03-06/#/0?presenter) 

* Brad: how do we cope with deciding how a module is being loaded? MIME type?
* Lin: yes. Byte-sniffing could also work.
* Andreas: why cycling linking?
* Lin: expect very close dependencies between JS and wasm. Acting as a wrapper. Also because ESM allows them, would be a stumbling block.
* Andreas: difference with wasm and JS is types. Might paint us in corner.

*POLL:* create a stage 0 proposal for ESM integration, with Lin as champion.

*Unanimous consent*

*AI:* JF to create repo, link tracking issue. Lin to fill repo.


#### WebAssembly BigInt integration

*Daniel Ehrenberg*

       * https://github.com/WebAssembly/JS-BigInt-integration
       * https://github.com/WebAssembly/spec/pull/707
       * Where should this be in the process?

* JavaScript has BigInt at stage 3. Shipping in Chrome soon. Being implemented for other browsers.
* Have spec text.
* Have some tests.
* Michael: which stage is this in TC39?
* 3.
* JF: I’d be uncomfortable in moving to WebAssembly stable if it weren’t in stage 4 for TC39. I don’t think we’ll be in that position.
* Dan: Note that other specs are making BigInt integrations already, e.g., HTML.

*POLL:* vote to move to [stage 2](https://github.com/WebAssembly/meetings/blob/master/process/phases.md#2-proposed-spec-text-available-community--working-group).

*Unanimous consent*

*AI:* JF to update repo and tracking issue.


#### HTML serialization of WebAssembly.Module objects

*Daniel Ehrenberg*

       * https://github.com/WebAssembly/spec/pull/711
       * Where should this be in the process?

* Only issue encountered was Brad’s PR disallowed posting to other agent clusters, e.g. service workers. Should we lift it?
* Brad: was a restriction for SharedArrayBuffer. Trying to mimic.
* Dan: you can’t serialize SAB though.
* Brad: should be at least available in same places. No objection to having more.
* Dan: previous spec also prevented IDB storage from HTTP, only allowed HTTPS.
* Brad: I think for Chrome we’ll restrict this.
* JF: I’d rather add restrictions in well thought-out manner, not ad-hoc.
* Dan: this proposal was left out of the JS Web API specification by accident.
* JF: not editorial change, so this affects first working draft.
* Michael: we don’t do IDB at all right now.

*Continue next meeting*


#### Closure
"
gc/2022/GC-06-28.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 28 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: June 28, 5pm-6pm UTC (June 28, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: built in type hierarchy ([#307](https://github.com/WebAssembly/gc/issues/307))
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Ben Titzer
- Justin Michaud
- Conrad Watt
- Rick Battagline
- Ilya Rezvov
- Ryan Hunt
- Aske Simon Christensen
- Andreas Rossberg
- Asumu Takikawa
- Manos Koukoutos
- Francis McCabe
- Alon Zakai
- Yulia Startsev
- Jakob Kummerow
- Adam Klein
- Zalim Bashorov


### Discussion: built in type hierarchy ([#307](https://github.com/WebAssembly/gc/issues/307))

[Jamboard](https://jamboard.google.com/d/17kCocIk1uW_W3cW-Nx_sJm1ENirGJD6MuMnqzOYs9OY/edit?usp=sharing)

TL: Describing benefits and issues of top types.

AR: Polymorphism issue is same as module interface choice problem.

BT: Experiment: Should func be separate from any?

TL: Could we do this in Wizard?

BT: Probably not fast enough.

CW: Might make sense to prototype with func <: intern so that at least every reftype that can be created in a Wasm module is under one type.

AR: Lazy conversions are fastest in ""polymorphic"" use case, but have other overheads. No design for externref is strictly better than the others. Want to be careful not to be naive with measurements.

ASC: Boundary representation conversions are not limited to reftypes. Could introduce a new lazy value feature for all types, which would have nothing to do with the type hierarchy.

BT: Are you proposing that extern be a completely separate type that is not related to references?

ASC: Right.

AR: This makes several assumptions about the host, for example that all the types can share a representation.

BT: One problem is that the encoding of externref is ref extern, so if we wanted to do something like that, it would have to be a new type.

CW: Also, if we do that, we would still want extern ref as a subtype of extern to distinguish reference types.

ASC: Good point AR that not all hosts could use the uniform representation.

FM: For JS promise integration we have these opaque suspender objects that we don’t want to be part of any hierarchy. It’s not a JS value but it is a reference. Would be good to pass it as an externref.

BT: Question for Aske: Would type imports with optional subtype constraint fulfil the use case for lazy value?

AR: Two kinds of type imports. Either you have an eager compilation scheme like we have now where you require a uniform representation for the types that can be supplied, or you have a model with type specialization where you compile after the imports are supplied. I believe we want to support both eventually, but the current model can’t support the latter. But I think that’s a whole different discussion.

BT: It’s a long discussion, but we have to make choices for the MVP. I propose to limit the host values to references for now.

CW: +1

TL: Any points of discussion on concrete hierarchy in Jamboard?

CW: Would there only be conversions between extern and intern, or also to other types?

TL: Would want conversions directly to func, i31, etc. to save work.

AR: I would prefer to keep it simple and well-factorized by only converting to intern.

CW: Maybe we could keep it factorized like that and define the semantics in terms of conversion then downcast.

MK: Could also have the engine recognize those patterns and fuse them in codegen.

AR: I would prefer not to have cast or conversion instructions directly from extern or intern to user-defined e.g. struct types since examining which user type something is is a very different operation. Also RTTs will change the signature of casts to user types in the future.

BT: Need to figure out whether we want a top type.

TL: Intern needs to be able to hold all extern even if they are not eq or func?

AR: Yes, otherwise it would be impossible to be polymorphic over both internal and external references.

MK: Think it’s ok if there’s no bijection.

AR: The bijection can have a representation change.

BT, MK: Thought that intern was meant to exclude extern?

CW: I previously thought that, but it seems harmless to let it be any instead, and that would allow the polymorphism Andreas was talking about.

TL: Could we add a top type post-MVP?

CW: This would give you the same expressivity and costs as using extern on the boundary and converting eagerly.

AR: Again, there are situations where lazy conversions would be better.

BT: Would like an engine to not require a new header word to distinguish between extern and intern.

AR: Don’t think that an engine needs to do anything since the types can’t be compared.
"
wasi/README.md,"# WASI meetings

Meetings of the WASI Subgroup of the W3C WebAssembly Community Group (CG) follow
[the process of the CG](https://github.com/WebAssembly/meetings).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform) to receive an invite.

## Meetings

<details open>

<summary>2024</summary>

  * [WASI January 11th video call](2024/WASI-01-11.md)
  * [WASI January 25th video call](2024/WASI-01-25.md)
  * [WASI February 8th video call](2024/WASI-02-08.md)
  * [WASI February 22 video call](2024/WASI-02-22.md)
  * [WASI March 7th video call](2024/WASI-03-07.md)
  * [WASI March 21st video call](2024/WASI-03-21.md)
  * [WASI April 4th video call](2024/WASI-04-04.md)
  * [WASI April 18th video call](2024/WASI-04-18.md)
  * [WASI May 2nd video call](2024/WASI-05-02.md)
  * [WASI May 16th video call](2024/WASI-05-16.md)
  * [WASI May 30th video call](2024/WASI-05-30.md)
  * [WASI June 13th video call](2024/WASI-06-13.md)
  * [WASI June 27th video call](2024/WASI-06-27.md)
  * [WASI July 11th video call](2024/WASI-07-11.md)
  * [WASI July 25th video call](2024/WASI-07-25.md)
  * [WASI August 8th video call](2024/WASI-08-08.md)
  * [WASI August 22nd video call](2024/WASI-08-22.md)
  * [WASI September 5th video call](2024/WASI-09-05.md)
  * [WASI September 19th video call](2024/WASI-09-19.md)
  * [WASI October 3rd video call](2024/WASI-10-03.md)
  * [WASI October 17th video call](2024/WASI-10-17.md)
  * [WASI October 31st video call](2024/WASI-10-31.md)
  * [WASI November 14th video call](2024/WASI-11-14.md)
  * [WASI November 28th video call](2024/WASI-11-28.md)
  * [WASI December 12th video call](2024/WASI-12-12.md)

</details>

<details open>

<summary>2023</summary>

  * [WASI January 12th video call](2023/WASI-01-12.md)
  * [WASI January 26th video call](2023/WASI-01-26.md)
  * [WASI February 9th video call](2023/WASI-02-09.md)
  * [WASI February 23rd video call](2023/WASI-02-23.md)
  * [WASI March 9th video call](2023/WASI-03-09.md)
  * [WASI March 23rd video call](2023/WASI-03-23.md)
  * [WASI April 20th video call](2023/WASI-04-20.md)
  * [WASI May 4th video call](2023/WASI-05-04.md)
  * WASI May 18th video call _Canceled_
  * [WASI June 1st video call](2023/WASI-06-01.md)
  * [WASI June 15th video call](2023/WASI-06-15.md)
  * [WASI June 29th video call](2023/WASI-06-29.md)
  * [WASI July 13th video call](2023/WASI-07-13.md)
  * [WASI July 27th video call](2023/WASI-07-27.md)
  * [WASI August 10th video call](2023/WASI-08-10.md)
  * [WASI August 24th video call](2023/WASI-08-24.md)
  * [WASI September 7th video call](2023/WASI-09-07.md)
  * [WASI September 21nd video call](2023/WASI-09-21.md)
  * [WASI October 5th video call](2023/WASI-10-05.md)
  * [WASI October 19th video call](2023/WASI-10-19.md)
  * [WASI November 2nd video call](2023/WASI-11-02.md)
  * [WASI November 16th video call](2023/WASI-11-16.md)
  * [WASI November 30th video call](2023/WASI-11-30.md)
  * [WASI December 14th video call](2023/WASI-12-14.md)

</details>

<details>
<summary>2022</summary>

  * [WASI January 13th video call](2022/WASI-01-13.md)
  * [WASI January 27th video call](2022/WASI-01-27.md)
  * [WASI February 10th video call](2022/WASI-02-10.md)
  * [WASI February 24th video call](2022/WASI-02-24.md)
  * [WASI March 10th video call](2022/WASI-03-10.md) _Canceled_
  * [WASI March 24th video call](2022/WASI-03-24.md)
  * [WASI April 7th video call](2022/WASI-04-07.md)
  * [WASI April 21st video call](2022/WASI-04-21.md)
  * [WASI May 5th video call](2022/WASI-05-05.md)
  * [WASI May 19th video call](2022/WASI-05-19.md)
  * [WASI June 2nd video call](2022/WASI-06-02.md)
  * [WASI June 16th video call](2022/WASI-06-16.md)
  * [WASI June 30th video call](2022/WASI-06-30.md)
  * [WASI July 14th video call](2022/WASI-07-14.md)
  * [WASI July 28th video call](2022/WASI-07-28.md)
  * [WASI August 11th video call](2022/WASI-08-11.md)
  * [WASI August 25th video call](2022/WASI-08-25.md)
  * [WASI September 8th video call](2022/WASI-09-08.md)
  * [WASI September 22nd video call](2022/WASI-09-22.md)
  * [WASI October 6th video call](2022/WASI-10-06.md)
  * [WASI October 20th video call](2022/WASI-10-20.md)
  * [WASI November 3rd video call](2022/WASI-11-03.md)
  * WASI November 17th video call _Canceled_
  * [WASI December 1st video call](2022/WASI-12-01.md)
  * [WASI December 15th video call](2022/WASI-12-15.md)
  
</details>

<details>
<summary>2021</summary>

  * [WASI January 14th video call](2021/WASI-01-14.md)
  * [WASI January 28th video call](2021/WASI-01-28.md)
  * [WASI February 11th video call](2021/WASI-02-11.md)
  * [WASI February 25th video call](2021/WASI-02-25.md)
  * [WASI March 11th video call](2021/WASI-03-11.md)
  * [WASI March 25th video call](2021/WASI-03-25.md)
  * [WASI April 8th video call](2021/WASI-04-08.md)
  * [WASI April 22nd video call](2021/WASI-04-22.md)
  * [WASI May 6th video call](2021/WASI-05-06.md)
  * [WASI May 20th video call](2021/WASI-05-20.md)
  * [WASI June 3rd video call](2021/WASI-06-03.md)
  * [WASI June 17th video call](2021/WASI-06-17.md)
  * [WASI July 1st video call](2021/WASI-07-01.md) _Canceled_
  * [WASI July 15th video call](2021/WASI-07-15.md) _Canceled_
  * [WASI July 29th video call](2021/WASI-07-29.md)
  * [WASI August 12th video call](2021/WASI-08-12.md)
  * [WASI August 26th video call](2021/WASI-08-26.md)
  * [WASI September 9th video call](2021/WASI-09-09.md)
  * [WASI September 23rd video call](2021/WASI-09-23.md) _Canceled_
  * [WASI October 7th video call](2021/WASI-10-07.md)
  * [WASI October 21st video call](2021/WASI-10-21.md)
  * [WASI November 4th video call](2021/WASI-11-04.md)
  * [WASI November 18th video call](2021/WASI-11-18.md)
  * [WASI December 2nd video call](2021/WASI-12-02.md) _Canceled_
  * [WASI December 16th video call](2021/WASI-12-16.md) _Canceled_
</details>

<details>
<summary>2020</summary>

  * [WASI January 16th video call](2020/WASI-01-16.md)
  * [WASI February 27th video call](2020/WASI-02-27.md)
  * [WASI March 12th video call](2020/WASI-03-12.md)
  * [WASI March 26th video call](2020/WASI-03-26.md)
  * [WASI April 9th video call](2020/WASI-04-09.md)
  * [WASI May 7th video call](2020/WASI-05-07.md)
  * [WASI May 21st video call](2020/WASI-05-21.md)
  * [WASI June 4th video call](2020/WASI-06-04.md)
  * [WASI July 2nd video call](2020/WASI-07-02.md)
  * [WASI July 16th video call](2020/WASI-07-16.md)
  * [WASI July 30th video call](2020/WASI-07-30.md)
  * [WASI August 27th video call](2020/WASI-08-27.md)
  * [WASI September 10th video call](2020/WASI-09-10.md)
  * [WASI September 21st video call](2020/WASI-09-21.md)
  * [WASI October 8th video call](2020/WASI-10-08.md)
  * [WASI October 22nd video call](2020/WASI-10-22.md)
  * [WASI November 19th video call](2020/WASI-11-19.md)
  * [WASI December 3rd video call](2020/WASI-12-03.md)

</details>

<details>
<summary>2019</summary>

  * [WASI May 2nd video call](2019/WASI-05-02.md)
  * [WASI May 16th video call](2019/WASI-05-16.md)
  * [WASI May 30th video call](2019/WASI-05-30.md)
  * no meeting on 06-13 due to overlap with the [CG meeting](https://github.com/WebAssembly/meetings/blob/master/2019/CG-06.md)
  * [WASI June 27th video call](2019/WASI-06-27.md)
  * [WASI July 18th video call](2019/WASI-07-18.md)
  * [WASI August 15th video call](2019/WASI-08-15.md)
  * [WASI August 30th video call](2019/WASI-08-30.md)
  * [WASI September 12th video call](2019/WASI-09-12.md)
  * [WASI September 26th video call](2019/WASI-09-26.md)
  * [WASI October 15th in-person meeting](2019/WASI-10-15.md)
  * [WASI October 24th video call](2019/WASI-10-24.md)
  * [WASI November 7th video call](2019/WASI-11-07.md)
  * [WASI November 21st video call](2019/WASI-11-21.md)
  * [WASI December 5th video call](2019/WASI-12-05.md)
  * [WASI December 19th video call](2019/WASI-12-19.md)

</details>"
simd/2024/SIMD-06-21.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 21 video call of WebAssembly's SIMD Subgroup

- **Dates**: 2024-06-21
- **Times**:
    - 3pm-4pm UTC (8am-9am PDT)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Petr Penzin
    - Email: penzin.dev@gmail.com


### Registration

Fill out [sign-up form](https://forms.gle/bscWhsD9U4hZEsUV9) to attend.

### Logistics

This meeting will be a Google Meet video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking
1. Adoption of the agenda
1. Proposals and discussions
    1. Update and discussion on FP16
1. Closure

## Meeting notes

### Attendees

- Andrew Brown
- Anton Kirilov
- Deepti Gandluri
- Ilya Rezvov
- Petr Penzin
- Yury Delendik

### Update and discussion on FP16
AB: I am curious about instruction lowering and when hardware support for it would be available across the board

IR: (Shares link to [Lowering](https://github.com/WebAssembly/half-precision/blob/main/proposals/half-precision/Lowering.md))
This works at the moment with AVX512 and will work with AVX10.2, which is officially published.

AB: Hardware for this feature (AVX10.2) is not going to be available for some time.

IR: As a standard I think we can count on this being available, and we can do emulation for now. 

AB: Emulation is going to be very slow on current hardware.

DG: We need to better define what emulation means. FP16 capabilities are important on all hardware, and what we have today in wasm is not sufficient. Andrew, I am curious what your position is, as we are working with other groups at Intel on AVX10 enablement.

AB: There are a few conflicting directions here: AVX10 is one aspect, competitiveness is a different one.

DG: We are looking for compute performance specifically on ML workloads. There are different directions on what different participants want from the standard, which is a difficult problem to solve evenly for everyone.

AB: I feel we are playing whack-a-mole with hardware features, as we have lots of conflicting ways to extend this.

DG: That is a good point, but the question is how to solve it? I.e. not adding instructions can be a disservice to our users.

AB: Maybe we can do more in engines, for example how revectorization project was implemented.

DG: The concern for such implementations is adoption, and we do more and more we might affect that. Spec has to be useful for the users.

PP: The issue with revectorization is that pattern detection is fragile, users need have to produce kernel code that matches expected. There was a different approach floated around a few times, about defining standard fallbacks, i.e. defining extensions in terms of existing wasm instruction - user would either get hardware acceleration or a valid wasm alternative.

AK: I am curious about revectorization and what handshake is needed to detect it.

DG: It is kernel pattern detection, and some kernels might need to be compiled with that detection in mind.

AK: That means that instead of 128-bit optimized kernels you need to produce 256-bit optimized kernels?

DG: In a way, you might need to use a different vector length in the compiler.

PP: XNNPACK is also detecting x86 vs Arm, if you want to extend revec to both platform you probably have to disable that check.

IR: I feel people prefer to have predictable performance, and probably emulation needs to be detected somehow. Please join discussions in FP16 repo.

AB: I am advocating for a more high level approach, and maybe we should investigate standard fallbacks that were mentioned. For example encryption/decryption functionality that can benefit from commonly available encryption instruction.

DG: We are looking for better developer story, just having one API for something is very restrictive, while needing to take all possible hardware features into account is a lot of overhead.

AK: Andrew, what you mention sounds like wasi-nn, right?


AB: I think it would subsume wasi-nn, as there are even more features, like AMX, and the problem is performance portability. I think in many of these cases we can’t reach exact consensus for these but we need to figure out a way to run common functions for important use case in a way that is optimized for underlying hardware. What if we can create a list of these specific functions and, say, hashing these functions to specific machine-optimized implementations.

DG: We thought about this, and it raises compatibility concerns as in what is optimized where.

AB: Developers don’t have to necessarily match hardware.

DG: This would definitely work for new code, but with existing applications users often want to just swap the existing header file with new one.

PP: How would this work, would this list of functions be public? How would a user reference them in the code - compile from source or drop in from a wasm library.

AB: Yes, I think we definitely collect possible use cases for these.

IR: I can’t see how we can use this for FP16 since it is a different data type

<<< Discussion of specifics of pattern matching note taker missed >>>

IR: shared link to [discussion thread](https://github.com/WebAssembly/half-precision/issues/4)

DG: prototyping is still in progress, might not be all available in dev Chromium builds, we can follow up offline if you want to try it.
"
wasi/2024/WASI-04-18.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: April 18 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: April 18 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. New proposal: `wasi-usb`
        - Proposal repo: https://github.com/Wadu436/wasi-usb
        - Vote: Approve for Phase 1

## Notes

### Attendees

- Bailey Hayes
- Yage Hu
- Pat Hickey
- Jeff Charles
- Wouter Hennen
- Timmy Silesmo
- Sam Clegg
- Joel Dice
- Alex Crichton
- Thomas Trenner
- Colin Murphy
- Chris Woods
- Hung-Ying Tai
- Merlijn Sebrechts
- Zalim Bashorov
- Warre Dujardin
- David Bryant
- Kate Goldenring
- Wouter Hennen
- Taylor Thomas
- Yong He
- Till Schneidereit
- Dan Phillips
- Robin Brown

### New proposal: wasi-usb

https://github.com/Wadu436/wasi-usb

**Wouter Hennen** The proposal is to add wasi-usb to interact with USB devices on a low level, think libusb. For example webusb is implemented using libusb. It is universal - works on lots of platforms. The proposal would like to add something similar to libusb. I have been working on it with (missed name). We have a small but incomplete wit interface ready in our repo. Here is a function for enumerating available USB devices. One thing we’d like to add here is access control, so the program doesn’t have access to all devices by default.

**Bailey Hayes** Who are the champions?

**Wouter** Merlijn Sebrechts at imec is the champion

**Bailey Hayes** Here is the criteria for phase 1. There is general interest within the subgroup for this api, and the subgroup believes the api is in-scope and plausibly workable. Since this is similar to proposals such as WASI-I2C, I think we should do a unanimous consent vote to make this a phase 1 proposal. Does anyone feel this is not in scope for WASI?

#### Vote: Approve for Phase 1 wasi-usb

Unanimous consent vote

**Bailey** The unanimous consent vote has passed, since nobody has objections. I have other questions that are unrelated to phase 1 vote.

**Bailey** Have you considered the webusb proposal?

**Wouter** Webusb is more of an abstraction over libusb and our conclusion was that its preferable to be more like libusb because programs ported to WASI are likely to use libusb as a base for something similar

**Bailey** It looks like we can use the interface definitions you have and map them to webusb.

**Bailey** One of the key things you’ll need to do in phase 1 is define your portability criteria. One of those criteria might be whether it can be implemented using webusb in a web context.

**Merlijn** Asks for clarification - what do you mean by mapping to a web api?

**Bailey** Look at what Guy Bedford did in JCO - theres an example there where the WASI Filesystem interfaces are implemented using Node.js’s filesystem. There is JS glue that provides the mapping to the native Web api

**Merlijn** I wonder if we are making the abstraction too low level to make that happen. We wanted existing native applications able to use the api. But theres also the web side.

**Bailey** We can link you up with people that have worked with usb at the lower level and higher level

**Luke Wagner** re Webusb - we may find ourselves in a different security situation. Webusb wants to prevent drive-by attacks on user browsers. This is why Mozilla has taken a negative (no and never) position on. So Webusb is exposing usb to random web pages. In the WASI context for example If you are looking to implement a driver, you may have a totally different security posture. So it might be ok if WASI USB finds itself at a lower level of abstraction than Webusb.

**Bailey** Any other questions or comments before meeting ends

**Taylor Thomas** There are two WASI Cloud proposals we are getting ready to move to phase 2. WASI Runtime Config, and WASI Key-value.

- https://github.com/WebAssembly/wasi-runtime-config
- https://github.com/WebAssembly/wasi-keyvalue

**Chris Woods** reminder that there is an ongoing discussion for an embedded SIG and its charter. There is a google doc for the charter. Ask me for the link to this document.

**Till Schneidereit** For clarity, I'm excited for this proposal and SIG but this is a Bytecode Alliance SIG, not a WASI SIG. It would be meant to feed into WASI activities as input but its not an official WASI activity, so that's just an announcement as an FYI to this group.

**Chris Woods** Good point, well made. Thank you Till. Link now in the chat, and added shortly to the notes.
https://docs.google.com/document/d/1MRzG9CWrYSDEBCCxF0adi3rxm2jjyUojO1Gt0K9IOR4/edit?usp=sharing
"
main/2022/CG-06-21.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 21st video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: June 21st, 4pm-5pm UTC (June 21st, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: backward-incompatible tweak to text format lexing (https://github.com/WebAssembly/spec/pull/1490) (Thomas Lively, 5 minutes)
1. Closure


## Meeting Notes

### Attendees

* Alex Crichton
* Andreas Rossberg
* Ashley Nelson
* Asumu Takiwaka
* Andrew Brown
* Bailey Hayes
* Chris Fallin
* Deepti Gandluri
* Derek Schuff
* George Kulakowski
* Jacob Abraham
* Jakob Kummerow
* Jeff Charles
* Luke Wagner
* Nick Fitzgerald
* Paolo Severini
* Petr Penzin
* Richard Winterton
* Ryan Hunt
* Sabine Schmaltz
* Thomas Lively
* Zalim Bashorov

### Discussion: backward-incompatible tweak to text format lexing (https://github.com/WebAssembly/spec/pull/1490) (Thomas Lively, 5 minutes)

TL: I've been working on new parser in Binaryen and noticed an inconsistency.
There is a non-normative note saying that tokens in the grammar must be separated by whitespace or parentheses. But in the normative grammar, they can also be separated by double quotes with no space. I was going to add a note about this but Andreas said that it was the intended behavior that you’d need whitespace or parentheses there. So maybe we should update the grammar instead of the note. The reason this might matter is for consistency, e.g. if you have 2 float numbers or identifiers next to each other with no space (e.g. with a $ prefix) they would parse as one (invalid) token. But not if one of them is a string. It would be nice to require a space between them. Technically this is a backward-incompatible change, there could be programs with identifiers next to strings with no space, and this would break them. But it seems pretty unlikely. Does anyone here have a text parser and know what would happen there, or anyone have other opinions?

AR: I could draw an example if that helps. One thing to note that we already had similar decision with numbers in the past, possibly Dan Gohman who pointed out that we would parse 0$x as two tokens, we fixed that we would pass it as one token. Similarly the thing we would need to fix for strings are:

```
0”a”
“A”0
“A””b”
```

Do we want to fix that to be consistent, but it would technically be backwards incompatible. Tested this in the Spec format, but didn’t bring up anything.

PP: What was the use case for the first one?

AR: it was really just meant for clarity. We allow lots of characters in keywords and tokens, even special characters, but e.g. 0a0.52\*xx4 would parse as two tokens 0 and a0.52\*xx4 before, which was rather surprising.

PP: So it’s not about the “$”

AR: No, nothing special there. The only thing we allow without spaces are brackets/parens. Other than we always have to separate with white space, an oversight was that we don’t do that with strings

PP: Right now, we would have two buckets, instead of a single string we would have a token?

AR: Currently “a”0 would be 2 tokens, but if we make this change it would be rejected.

PP: Unless someone was passing a string and a number, and they forgot to put the space in were expecting the parser to put the space in which would no longer work.

AR: in the webassembly syntax, you can’t really pass things to parse as input. You could e.g. have multiple strings  in data, e.g
`(data _ “a””b”)`

TL: Data grammar already concatenates multiple elements so shouldn’t matter?

AR: This change would make that example illegal. You’d need a space.

AR: Even single quotes are allowed in identifiers, but double quotes are not. 

TL: Does anybody care if we make this backwards incompatible change to the text format? <no responses>

DS: We should just turn this into a unanimous consensus vote. Does anyone have objections to changing the text format to disallow strings without spaces around them?

PP: Maybe we should post it somewhere to notify people?, but I have no objections

TL: There’s a PR on the spec repo that’s been up for a while and there’s been no discussion. Probably nobody cares that much.

AR: Text format is a secondary concern to most people. One thing I have to figure out is how easy that change actually is, we could add double quotes to reserved category but not possible because strings also can contain unicode characters, so we have to allow every string elements except white space, e.g. to cover `(import “aä””b”)`

TL: We can work out the details. I don’t hear any objections to the proposal though.
"
simd/2022/SIMD-09-30.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 30th video call of WebAssembly's SIMD Subgroup

- **Dates**: 2022-09-30
- **Times**:
    - 4pm-5pm UTC (9am-10am PDT)
- **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this [form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking
1. Adoption of the agenda
1. Proposals and discussions
    1. 
1. Closure

## Meeting notes

### Attendees

- Andrew Brown
- Anton Kirilov
- Conrad Watt
- Deepti Gandluri
- Evan Nemerson
- Johnnie Birch
- Justin Michaud
- Marat Dukhan
- Petr Penzin
- Richard Zak
- Yuri Delendik

### Finalizing the specification for Phase 4 vote

CW: want to discuss non-determinism, float idea of deterministic FMA

DG, MD: we would have to discuss that later, Zhi is out, also sounds he might have addressed it

DG: anything else we need to consider?

MD: Good on my side. I implemented optimizations using relaxed-simd in xnnpack, got very good speedup

DG: looks like FMA speedup is lower than we expected

MD: expect changes in register allocation is causing this, need to check

DG: can you also try it in Firefox nightly, looks like it is implemented

YD: Available in firefox nightly by default. Current status is that FMA and FNMA operands need to be swapped and BFloat16 operations need to be implemented.
Relaxed SIMD preferred on by default in Nightly (off in release)

DG: V8 situation is similar


### Deterministic FMA

Slides: https://docs.google.com/presentation/d/1dJhqnAZOjh8ppCKivDl--niaUgpKV44--IMX1EF1SA0/edit#slide=id.gc6f73a04f_0_0

CW (presenting): happy with 99% of what is in spec, just hoping to make formal semantic simpler to require less spec extension. I think there are two kinds of operations: where we care about the variability and where we only need to avoid it.

MD: the idea is that most of the operations are useful without testing for specific behavior

CW: the point is that some operations can be changed to traditional “range” non-determinism we use in core spec, this would not prevent anyone from still detecting which semantics they get

TL: since there are programs that are dependent on additional detection, this should not break anything

CW: more interesting cases are instructions where we have to encode the options, for example single vs double rounding in FMA, where that would require a different algorithm. The proposal is to add deterministic instructions in addition to non-deterministic ones for just those cases. This way we would not need to add new type of non-determinism to the spec, which also helps with forward compatibility, it is easier to narrow to list non-determinism, than to remove it later. Also helps support potential new architectures in the future.

TL: the programs that would use something like this can be already broken if an engine would make somewhat random choices w.r.t what we have here. Why not just make all instructions use range non-determinism?

CW: we should probably care about cases like FMA, when assumptions are required.

MD: it would be challenging to polyfill a deterministic SIMD FMA, this would be very expensive

CW: in cases like this I would probably prefer list non-determinism

PP: It feels like we just get FMA & QFMA both, is that bad?

CW: Either we introduce a new idea of non-derteminism, or we introduce an instruction that may not have completely predictable performance

MD: In which way does it not have predictable performance?

CW: Emulated FMA may be slower

MD: Wasm doesn’t guarantee performance, see popcount operation

CW: In that sense I think new operation is more palatable

MD: why do we need the new operation?

DG: for the spec to be more flexible in the future

MD: the test for qfma behavior means you can just use qfma in those two different ways

AB: allowing use cases where we might want to move computation to other architectures is more important outside the browser

DG: To distill, what Conrad is proposing would result in less testing.

JM: I like the idea of range non-determinism, it would be useful for web compat. On the other hand I don’t like the “very slow emulation” aspect of the additional proposed instructions. Maybe just leave

TL: in practical terms new FMA would only add an ability to write badly slow programs

PP: I think having list semantics on some operations is better than on all operations, however there is a case for new operations. From practical point of view of having slow programs, we have already enabled this with SIMD popcount.

CW: adding list non-determinism in one spot is pretty much the same as adding in many places.

MD: testing semantics that can change while program is executing is very hard.

PP: from practical point of view they won’t change

TL: runtimes that can move executions that we discussed above 

DG: we are at time, we should continue discussing this offline, given that we won’t have another meeting before Phase 4 vote

CW: one final note: I would prefer adding new instructions, though having lists across the board is my second option, I’d rather not change the semantics to sets and still expect our current qfma tests.

"
gc/2022/GC-11-15.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 15 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: November 15, 5pm-6pm UTC (November 15, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: meeting cadence
    1. Discussion: call_indirect subtyping and final types ([#329](https://github.com/WebAssembly/gc/issues/329))
    1. Discussion: types outside rec groups ([#334](https://github.com/WebAssembly/gc/issues/334))
    1. Discussion: issue triaging
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Asumu Takikawa
- Salva Kuzmich
- Francis McCabe
- Rick Battagline
- Igor Iakovlev
- Zalim Bashorov
- Ilya Rezvov
- Manos Koukoutos
- Justin Michaud
- Ryan Hunt
- Alon Zakai
- Deepti Gandluri
- Conrad Watt
- Andreas Rossberg
- Ben Titzer
- Luke Wagner
- Aske Simon Christensen

### Discussion: meeting cadence

TL: Not now, but soon will have few enough issues that we can change the meeting cadence to once monthly.

(No objections)

### Discussion: call_indirect subtyping and final types ([#329](https://github.com/WebAssembly/gc/issues/329))

MK: Investigated how much binary code size increases after having MVP Wasm modules check subtypes in call_indirect. Checked two real-world benchmarks. 7.5% and 10.2% code size increase in optimized tier. Our implementation has bloated code, so other implementations could be smaller, but would be surprised if it went below a few percent.

AR: Do you have a sense of the average case?

MK: I can run experiments. The experiment showing the minimal increase wasn’t a real world benchmark.

AR: Any performance measurements?

MK: Not yet.

AR: Could be code caching implications, but otherwise we would hope that the fast path is still fast.

RH: I’ve been hoping to provide another data point from SM. The problem is that our downcasting code is absolutely terrible right now. I’ve been working on optimizing that. Hope to have results some time this week.

CW: For determining [runtime] impact, it would be fine for downcasts to be gross and out of line, right?

RH: My hope is that we can have the same downcasting logic for structs, arrays, and functions. The way I’m trying to implement it is so we can have a simple inline path for everything. I think that’s feasible. If so, adding it to call_indirect should have minimal code size impact. I don’t think an out of line fallback path should be necessary at this time.

CW: Was just thinking for initial numbers for MVP Wasm.

RH: Could do something hacky to get numbers sooner.

TL: Not urgent.

RH: Question of what to do if we have disparate impact. Final types would be ok, but would be nice to avoid them.

ASC: I would be interested in seeing measurement of how final types would affect other casts besides in call_indirect. Final types could have the same code size, icache, and compilation speed benefits everywhere.

AR: You mean where you cast from an abstract type to a final concrete type?

ASC: Yes, or from concrete to concrete.

AR: I think a final type with a supertype doesn’t buy you anything.

ASC: If you cast to a final type, then it can just be an address comparison. There are lots of that kind of casts.

BT: It’s worth noting that that will change if we have casts for custom metaobjects in the future, that optimization won’t work anymore.

AR: Would require an extra indirection.

ASC: If we could decide on an encoding for final types to do the experiment, we could start using them in dart2wasm and get WasmGC test data at least.

AR: In terms of the design, it would make sense to add a sub_final rather than duplicating func, array, and struct.

TL: Andreas, can you propose an encoding offline?

AR: Sure, will be tomorrow.

TL: Manos, any path to reducing call_indirect code bloat in the near future?

MK: No, would require extensive refactoring.

JK: Current implementation optimized for speed, not size.

### Discussion: types outside rec groups ([#334](https://github.com/WebAssembly/gc/issues/334))

TL: Any objections to keeping the current semantics of non-rec types being the same as having singleton rec groups?

CW: What would be the method for making this work with type parameters in the future?

AR: Would require different kinds of type parameters.

TL: No further comments. Resolved to keep the current semantics.

### Discussion: issue triaging

TL: (Sharing screen to show GitHub issue labels)

TL: Mapping Java null-ptointer exceptions is a clear candidate for post-MVP

AR: Doesn’t our redesign of casts solve this?

TL: Language implementers want instructions that throw exceptions directly on nulls.

ZB (chat): It would be nice to have this.

FM: Could use GitHub discussions for some of these usage notes issues.

TL: Good idea.
"
wasi/2022/WASI-08-25.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: August 25 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: August 25, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. [SpiderLightning](https://github.com/deislabs/spiderlightning): a set of Wasm component interfaces for the cloud - Jiaxiao (Joe) Zhou & Danilo Chiarlone

### Attendees:
- Richard Zak (Profian/Enarx)
- George Kulakowski
- Lin Clark
- Mossaka / Jiaxiao Zhou
- Bailey Hayes
- Chris Suszynski
- Dan Gohman
- danbugs
- David Justice
- flaki
- jlbirch
- Joel Dice
- Kevin Hoffman
- Kyle B
- Melanie Riise
- Mincolas Devillard
- Petr Penzin
- Piotr Sikora
- Ralph Squillace
- Richard Zak
- Saúl Cabrera
- Steve S
- Valery Antopol
- Yong
- Andrew Brown
- Ashley Nelson

## SpiderLightning: https://github.com/deislabs/spiderlightning

[slides](https://docs.google.com/presentation/d/e/2PACX-1vQAt5BbFRqpS5tLFx0gegpGZ4TFLuSGRIP3kc5BIV6IPtwd6PwjjTsrmND6xqZFlRTXk-lyCwYazSW6/pub)

### presentation

- Jiaxiao Zhou
  - new cloud system with webassembly
  - engineering distributed apps is hard
    - best practices like 12-factor apps exist, but still too much toil and distraction from the core business logic
    - platform specific
    - problems like scalability
  - our solution: SpiderLightning
    - experiment with capabilities that extend WASI
    - vendor agnostic WIT interfaces for distributed applications
    - `slight` is an experimental CLI host implementing those capabilities
    - loads a configuration and provides resources corresponding to those capabilities
    - other host implementations could be built on the SpiderLightning interfaces
- Dan Chiarlone
  - DEMO!!
    - rust app using wit-bindgen generated interfaces from the SpiderLightning wit files
    - therefore backend implementation agnostic
  - big list of capabilities SpiderLighting and slight can bind to
- Jiaxiao
  - alternatives
    - Dapr is a distributed application runtime
      - provides services like service discovery, secret management, …
      - IPC to the sidecar container runtime providing the service, which also abstracts out the provider
      - by comparison, slight provides capabilities in-app
  - what’s next
    - SpiderLightning is very aligned, is it possible for it to become part of the WASI spec? especially with preview2 and stream I/O imminent
    - improving wit-based tooling like wit-bindgen
      - for example, supporting languages other than rust and C

### discussion and questions

- Ralph Squillace
  - this feels at a slightly different level than other discussions, which have been very constrained and highly typed
  - this approach tries to go a different way, with more abstract and high-level, application level interfaces rather than low level interfaces
- Dan Gohman
  - trying to understand this via the event mechanism. is it correct that those event payloads don’t have a type associated?
- Ralph Squillace
  - that’s an example
  - see the lower levels trying to be more precise about typing, eg getting away from stringly typed payloads
  - wanting to see if there’s a benefit to having less precise types to be able to abstract as we get closer to app-level capabilities
- Dan Gohman
  - I see this having some middleground capabilities compared to something like WASI filesystem, which also has a place within WASI. but it’s not going to be the center of everything.
  - see a good role for SpiderMonkey and think this makes a lot of sense
  - excited to talk about individual APIs
- Mossaka
  - is the next step making a proposal? where?
- Dan Gohman
  - I definitely think this makes sense to do within the WASI umbrella. there’s a template
- Lin Clark
  - can poll to advance without the template, which could happen next week
- Andrew Brown
  - what about optional parts of the WASI interface?
  - suppose some application doesn’t want to provide a part of the SpiderMonkey interface
  - WASI is still in the process of figuring out how to describe that
- Dan Gohman
  - profiles will be part of the answer to this. they’ll be part of the platform we build on
  - component model answering a lot of these questions but not yet fleshed out
  - I again want to draw the parallel to WASI filesystem, which also isn’t something that’s appropriate to provide in a lot of environments that people here are working in. so this isn’t a new problem
- Andrew Brown
  - so if a user wrote code that uses e.g. wasi filesystem file open in such an environment. where does it fail?
- Dan Gohman
  - instantiation time
  - more nuance in the future, like with weak imports
- Andrew Brown
  - is there a need to describe whether APIs will be optional?
- Dan Gohman
  - I think we will need that
  - instantiation time will continue to be the ultimate place where decisions about availability are made
"
wasi/2022/WASI-04-07.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: April 7 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: April 7, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Pre-proposal (phase 0) for a WASI interface for URLs (@kulakowski-wasm)
    2. _Sumbit a PR to add your agenda item here_

## Notes

### Attendees

- Lin Clark
- Sergey Rubanov
- Alexandru Ene
- Yong He
- Dave Bakker
- Saúl Cabrera
- Piotr Sikora
- Luke Wagner
- Ralph squillace
- Mingqiu Sun
- Arne Vogel
- Till Schneidereit
- Andrew Brown
- Bailey Hayes
- Dan Gohman
- Jeff Charles
- Johnnie Birch
- Klas Segeljakt
- Syrus Akbary
- Peter Huene
- David Piepgrass
- George Kulakowski

### wasi-url proposal

**George Kulakowski:** Going to put up the design more next time. Just introducing this time. Wanted to talk about why URLs at all. First reason, ubiquitous. So many APIs that people will want to express will require. They are already standardized so a lot of design work we don’t need to do. And an opportunity to do better than “just” strings. In an interface, easy to default to just strings.

With types, design decision is port u32 or string, or some stricter invariants. Do you get a string from IPv4 or more structured data type. How fine grained do we break things down. To force invariants is one thing.

Bounds are creating and manipulating URLs and accessing components, like query fragment. This is following WHATWG working spec for URLs. 

Given that, there are some concerns that the WHATWG doc addresses that WASI doesn’t need to, like rendering concerns. E.g. a browser rendering a URL as a string in a URL bar. Those aren’t in scope. Also includes reasoning about bidirectional characters in URL fragments. Secondarlity, many URL schemes that have their own constraints. Telephone, etc. 

**Syrus Akbary:** Trying to use URLs everywhere?

**George Kulakowski:** Goal is to have an API that can be used by other APIs. Not advocating for any particular use of URL

**Dave Bakker:** Proposal to add to component model interface types?

**Luke Wagner:** It wouldn’t become a primitive. Would provide an API using other interface types 

**George Kulakowski:** Goal is to define this using existing technologies

**Bailey Hayes:** Would it be part of wasi-common or its own component?

**Dan Gohman:** wasi-common in particular is part of wasmtime’s implementation. We don’t have a distinction between different WASI APIs

**Syrus Akbary:** How does this differ from W3C

**George Kulakowski:** Yes, that’s another document, WHATWG has a similar one which I mentioned. There’s not much design room. We may want to use stronger types.

**Dave Bakker:** How do you expect this to be used. Many languages have their own URL parsing and logic and libraries. How do they play together? Is this a replacement for them.

**George Kulakowski:** Good question in general. I expect it might vary a little bit across languages. I expect different bindings to define the point at which your standard URL type is able to be converted into this at the appropriate place.

**Piotr Sikora:** Would it expose ABI to parse URLs (e,g. Host, port etc)?

**George Kulakowski:** yes

**Dave Bakker:** Is it in scope for WASI?

**Dan Gohman:** There is no fundamental constraint that we have to follow here. First thing we’re talking about that’s outside of POSIX scope. I think it’s useful to have so that others can build on.

**Syrus Akbary:** Can you follow up where you think URL would be use

**Dan Gohman:** lots of places

**Luke Wagner:** wasi-http

**Syrus Akbary:** does wasi have an http interface?

**Lin Clark:** Yes, it’s in proposals list

**George Kulakowski:** There are several other proposals in phase 1 or 2 that mention internet standards. You could imagine a DNS api, and it would be good to use URL for something like that. I’d hope to see other proposals use this.

**Dan Gohman:** One of the great strengths of WASI is virtualization. That’s served by having a higher level API. We want hosts to have knowledge that they can make use of. 

**Dave Bakker:** How will the URL be represented in interface types. Will they be resources?

**Lin Clark:** Might be better to tackle after George has put up design doc

**George Kulakowski:** You have put your finger on a good issue. Suspect that the thing I’ll write up in the next few days will suggest not a resource, but looking forward to figuring this out. 

**Lin Clark:** FYI, those details aren't a blocker for Phase 1

**George Kulakowski:** Thanks, good to know
"
wasi/2023/WASI-09-07.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: September 7 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: September 7, 16:00-17:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. _Submit a PR to add your announcement here_
    1. Vote: Rebase the Phase Process on CG's process, as presented on 07-27
    1. Vote: Preview 2 definition, as presented on 07-27

## Notes
### Attendees
Dan Gohman
Conrad Watt
Colin Murphy
Marcin Kolny
Luke Wagner
Pat Hickey
Petr Penzin
Chris Woods
Syrus Akbary
Jeff Charles
Frank Schaffa
Ben Green

Pat: A lot of people are at WasmCon today. Since this is a consensus vote, it’s not urgent for people who want to vote yes to be present, because it’s mainly about seeing if anyone wishes to vote no. And since the PRs were posted, we’ve had the opportunity to have a lot of discussions with the people who have raised questions and concerns.

Pat: We don’t believe there will be significant performance regressions on real workloads.

Pat: There are some small overheads today, such as calling malloc in some places where we didn’t before. It’s some small overhead, but we have plans for how we’ll optimize it out.

Pat: Also, I wrote a program that uses WASI to copy files, to read files into memory and write it back out. It’s just one window on WASI performance, but it shows an interesting result. We turned up some interesting low-hanging fruit, but we fixed it, and now it’s close to the same performance as preview1.

Pat: Luke wrote up some great summary comments of the discussion in the PRs.

Chris: We know there will be some issues with the new implementations that we have. It’ll be important to address it, and we added a plan to the PR to measure and address performance within preview3.

Chris: On the Wamr side, there is a workitem to implement a Wit to Witx tool, which is an important piece of the story.

Pat: Wit to Witx tooling is an implementation strategy. It’s not a requirement for Preview 2, we can’t mandate it, but it is worth talking about here. It’s technically possible. We have had a contributor do some Wit to Witx by hand, showing that it can be done, and it’s fairly mechanical. People who chose to go that route will likely wish to automate it with a tool.

Marcin: As of now, the requirement for new WASI proposals is Wit?

Pat: Yes. 

Pat: One way to get started on a Wit to Witx translator tool would be to take the existing markdown generator in wit-bindgen and evolve it to emit Witx instead.

Chris: The fact that that tool exists gives us an idea of how much work would be needed. It doesn’t seem like a particularly onerous task.

Marcin: Will wasi-libc need a Canonical ABI interface as well?

Pat: Yes, wit-bindgen has a C header ABI, which is also similar.

Marcin: Perhaps Wamr would want to use that instead of Witx.

Dan: That would work, though that’s for the guest side; generating a C header for the host side would be some additional work, but it’s doable.

Chris: There’s a lot of learning on the Wasmtime side about how to implement the component model; perhaps we should sit down with the Wamr folks to share insights.

Pat: Yes, let’s do that.

Petr: The two features we ran into as we looked into this, threads and component model, don’t seem to have browser buy in. To what extent is this a problem? If someone wants to use WASI on the Web, how could that work?

Pat: That’s a good discussion to have. Rather than dive into that now, let’s table that, and keep talking. We’ll keep talking with browser implementers.

Marcin: My concerns are mitigated, from our perspective. There is a way to stick to our current approach, just updating some APIs. It looks like the performance concerns will be taken into account.

Chris: Likewise, I’m good.

Pat: Let’s do the vote.

<vote>

Pat: PR549 has passed by unanimous consent.

Pat: PR550 is a follow-on PR. This describes what Preview 2 is.

Pat: Are there any questions or discussions people would like to bring up?

Pat: Seeing none, let’s do the vote.

<vote>

Pat: PR550 has passed by unanimous consent.

Syrus: For the record, I don’t agree that the component model should be the way forward for WASI, but I don’t want to hold up the vote.

Pat: Ok, we’ll include that in the notes.



"
main/2017/CG-09-05.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 5th video call of WebAssembly's Community Group

- **Host**: Google Hangouts
- **Dates**: Tuesday September 5th, 2017
- **Times**: 9:00am–10:00am Pacific Time
- **Location**: *same Google Hangouts link as before*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

None required if you've attended before. Email JF Bastien to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Bulk Memory Instructions (Ben Smith)
       1. [WIP proposal](https://gist.github.com/binji/acc43b94c0a747e51dfafa1b5b099c9a)
       1. Some initial performance numbers
    1. Option to skip data segment initialization (Ben Smith)
       1. [Discussion](https://github.com/WebAssembly/threads/issues/62)
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Dates and locations of future meetings

| Dates                    | Location          | Host       |
|--------------------------|-------------------|------------|
| 2017-11-01 to 2017-11-02 | Santa Clara, CA   | Intel      |
| 2017-11-06 to 2017-11-07 | Burlingame, CA    | TPAC       |

## Meeting notes

### Roll call

* Arun Purushan
* Ben L. Titzer
* Ben Smith
* Bradley Nelson
* Dan Ehrenberg
* Dave Voyles
* Deepti Gandluri
* Yury Delendik
* Derek Schuff
* Edgar Pek
* Heejin Ahn
* JF Bastien
* Jacob Gravelle
* Keith Miller
* Lars Hansen
* Limin Zhu
* Luke Wagner
* Michael Holman
* Peter Jensen
* Sam Clegg
* Sean Jensen-Grey
* Sergey Rubanov
* Thomas Nattestad
* Unbug Lee
* Vincent Belliard
* Mingfei Fan
* Malcom White


### Agenda Adoption

Derek seconds.

### Bulk Memory Instructions

**Ben Smith presenting**

* [WIP proposal](https://gist.github.com/binji/acc43b94c0a747e51dfafa1b5b099c9a)
* Unity demo had these functions consuming lots of cycles. Ben wrote an implementation in V8, and compared to Emscripten’s implementation with various unrolling. Different size operations were benchmarked.
* `memcpy` actually has the `memmove` semantics, overlap is fine.
* Different from other load / store: no memarg, and no offset.
* Have preliminary spec text.
* Used `C5` and `C6` opcodes.
* Wagner: why no mem immediate? For which memory to operate on. Every other operator to memory has it.
* Smith: There’s a byte, I just wasn’t calling it that.
* Bastien: interaction with atomics?
* Smith: we would specify the order in which bytes are being copied depending on overlap or not.
* Bastien: also, do we want to disallow non-temporals? On ARM they’re super weak, and on Intel IIRC you technically need `sfence` and `lfence` and one doesn’t do anything. They’re not always a win.

*Action item*: Smith to sync offline with ARM / x86 folks.

*POLL: should this be a proposal that Ben Smith champions and brings to the CG to move through the process?*

Unanimous consent.

*Action item*: JF to create a [repository for bulk memory operations](https://github.com/WebAssembly/bulk-memory-operations).


### Option to skip data segment initialization

**Ben Smith presenting**

* [Discussion](https://github.com/WebAssembly/threads/issues/62)
* With threading proposal, we want to create multiple instances which share the same linear memory. Right now we initialize memories with the data segment, which leads to data being clobbered. Initially I’d written the spec to force the data segments being in a separate module that would be loaded once only.
* We talked about two mechanisms to do this: either have a flag when instantiating a module preventing data segment initialization (and symmetrical one for tables); or have a new initializer expression on the data segment itself.
* Bastien: steals the bit from memory index to do this?
* Smith: yes, but could use additional bits from that flag to specify this.
* Bastien: have you thought about how this would interact with TLS? Would that be a separate section?
* Nelson: same issue with `start` function too.
* Wagner: could have a branch at the start of `start`.
* Bastien: cost of going through each segment for every thread start.
* Wagner: pure WebAssembly threads would be the right solution here. The instance would be shared, only instantiated once.
* Smith: rest of the proposal talks about table initialization equivalent. There aren’t shared tables for now, but we can make it symmetrical.
* Bastien: unless we do concurrent JavaScript.
* Bastien: this is just a stopgap until we have pure WebAssembly threads? Once we do and everyone has migrated to them, will this be used ever again?
* Smith: not clear.
* Schuff: it’ll take a while for Emscripten to migrate to this.
* Smith: should I just explore solution 2? Sounds like everyone likes it.
* Bastien: implementation ready to go by next meeting? This was guided by Emscripten folks asking for it.
* Smith: I can look into this.
* Schuff: I can look into it too.
* Bastien: my worry is that we can’t really move the proposal more without implementation experience.


## next meeting

Web platform test repository, discussion, and poll (Ben Titzer).


*Adjourn*
"
wasi/2022/WASI-05-05.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: May 5 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: May 5, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1.  Conversational venues for WASI discussion
    2.  Native threads WASI API.
    3. _Sumbit a PR to add your agenda item here_

## Notes

### Attendees:

 * Dan Gohman
 * Kevin Moore
 * Bailey Hayes
 * George Kulakowski
 * Alexandru Ene
 * Arne Vogel
 * Amanieu d’Antras
 * Jeff Charles
 * Mingqiu Sun
 * Yong He
 * Radu Matei
 * Piotr Sikora
 * Sam Clegg
 * Johnnie Birch
 * Nathaniel McCallum
 * Sergey Rubanov
 * David Piepgrass
 * David Justice
 * Andrew Brown
 * Petr Penzin

### Conversational venues for WASI discussion (George Kulakowski)

 * https://github.com/WebAssembly/meetings/pull/1019

**George Kulakowski:** Are there venues other than this meeting where discussions are happening?

**Bailey Hayes:** A lot of WASI discussions occur on the bytecodealliance zulip.

**Dan Gohman:** The WASI-url repo is a good place for posting design docs.

### Native threads WASI API (Alexandru Ene)

 * https://github.com/WebAssembly/meetings/pull/1024

**Alexandru Ene:** (presentation)

**Andrew Brown:** We should have a separate meeting to dive more deeply into the details about instance-per-thread or multiple instances.

**Nathaniel McCallum:** We (Profian) would very much like to see native threads. Many frameworks assume that threads exist on the platform.

**Sam Clegg:** We should be careful not to duplicate spec work in core wasm.

**Dan Gohman:** This is where the instance-per-thread idea comes in. Browsers already have instance-per-thread, so one option is for WASI to just have an API for creating a thread which works in a similar way. That would reuse all the existing specs.

**Luke Wagner:** What’s in browsers right now is not something that anyone is happy with. It was an MVP to get something working. JS is single-threaded; we have to be careful not to let multithreaded wasm call into single-threaded JS. “Weakening WebAssembly” is a paper which describes a design for adding a fork instruction. It would require adding shared annotations to everything in modules, including functions, globals, etc. to make sure that everything that can be affected by threads is prepared for it.

Lots of limitations with instance-per-thread: lots of duplicated state, dlopen doesn’t work. So what we really want is the fork instruction of “Weakening WebAssembly”.

**Alexandru Ene:** Can we make multiple-threads-per-instance an optimization, over instance-per-thread?

**Petr Penzin:** What are the semantics of shared?

**Luke Wagner:** The paper has a proposed semantics.

**Luke Wagner:** For example, if you import a JS func, it would need to be non-shared.

**Nathaniel McCallum:** Is instance-per-thread observable?

**Sam Clegg:** In instance-per-thread, wasm globals are thread-local. If we have multiple threads per instance, they’d share a global.

**Luke Wagner:** It’s possible to have an API which makes a separate instance, which could work in the short term. But it seems unlikely to be something that could be standardized.

**Alexandru Ene:** Why did it get standardized in the browser?

**Luke Wagner:** In the browser, Web Workers already existed.

**Luke Wagner:** I’d propose someone add core-wasm support for the proposed fork instruction.

**Alexandru Ene:** I’ll take a look at that.

**Andrew Brown:** Before we dive too deeply into this, let’s give people a chance to study the paper.

**Andrew Brown:** It doesn’t seem like browsers are motivated to implement this right now.

**Luke Wagner:** I believe no one’s against this, it’s just not a high enough priority.

**Alexandru Ene:** Could people interested in having a meeting file issues: github.com/AlexEne/wasi-native-threads/

**Andrew Brown:** Sam Clegg, would native threads help Emscripten?

**Sam Clegg:** Yes, Emscripten has lots of magic hacks for threads currently, especially around keeping the tables in sync, and native threads would improve it.

**Nathaniel McCallum:** If we do instance-per-thread, it’s a half measure, which adds a cost: we have to support these pseudo-processes forever.

**Sam Clegg:** It may be fine to do a two-prong solution, with a stop-gap instance-per-thread for now, and doing the real thing at the wasm level.

**Nathaniel McCallum:** Would it make sense to have multiple memories?

**Amanieu d’Antras:** Would it be possible to have an instance-per-thread which would be forward-compatible to threads-per-instance model?

**Sam Clegg:** It depends on wasm standards decisions.

**Petr Penzin:** It seems like we should be able to make this compatible.

**Luke Wagner:** It might be a good idea to require the API to be pollyfillable on the Web.

**Alexandru Ene:** Please comment in https://github.com/AlexEne/wasi-native-threads/issues/1 to register interest in meeting to discuss this further.
"
benchmarking/2024/benchmarking-03-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 22nd of WebAssembly's Benchmarking Subgroup

- **Where**: Google Meet
- **When**: March 22nd, 4pm-4:45pm UTC (8am-8:45am PDT, 11am-11:45am EST)
- **Location**: _Link on calendar invite_
- **Contact**:
    - Name: Petr Penzin, Saúl Cabrera
    - Email: penzin.dev@gmail.com, saul.cabrera@shopify.com


### Registration

If this is your first time attending, please [fill out the registration form](https://forms.gle/QCmhyM4QwvWvZR9b8) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

### Logistics

This meeting will be a Google Meet video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes
    1. Please help take notes.
1. Announcements
1. Proposals and discussions
    1. wish-you-were-fast presentation, Ben Titzer
1. Closure

## Attendees

* Ajay Chhokra
* Andrew Brown
* Benjamin Titzer
* Daniel Lehmann
* Johnnie Birch
* Nick Fitzgerald
* Marco Rudilosso
* Petr Penzin
* Saúl Cabrera

## Meeting notes

###  Wish you were fast (Ben L. Titzer)

Slides: https://docs.google.com/presentation/d/18avQJS6ZUt-3du53dF8AeHlQ0SKPyRHncVQ7PRbc-ho/edit?usp=sharing_eil_se_dm&ts=65fd9e57

NF: What kind of ABI are required to drop in a Wasm to the service?

BT: Almost nothing, mostly command arguments. For the Web engines, I wrote a JS wrapper to get the environment setup to be able to run them in the Web engines. 

AC: Do you impose any kind of restrictions on the Wasm? Can you talk a little bit about how to integrate this into a CI pipeline?

BT: Through bash scripts, mostly. It's open source but not polished. In the wish-you-were-fast repo, you can take a look at the structure and that would give you an idea of how to integrate this in a CI environment for example. 

AC: How do you display results?

BT: If you just run, it'll just run the program. To display the benchmark results, you need wrappers around them that display the time taken for each benchmark. That wrapper will dump the results and some other script will consume that data and generate a report. Three tier web app and wrapper from JIT paper are in the repo.

NF: You separated out compilation and execution. Did you measure instantiation?

BT: I didn't. Only compilation and execution. Metrics are defined in the DB schema in the repository, it would be possible to add more metrics there.

NF: Most of the work that we've done in Wasmtime, has been on instantiation for horizontal scaling. I think it's worth mentioning that instantiation is important in some scenarios. 

BT: In the repo there is a script to reisntatntiate multiple times. It is possible to measure multiple instantiation within this approach.

DL (in chat): Very cool work! Uploading your own benchmark would be amazing.
Could one also extract benchmark-specific metrics, e.g., coremark outputs some throughput measure (iterations/s or fps or whatever)?

NF: It's also important to consider for non Web engines the instantiation time. Some single core instantiation optimizations make it worse on multiple threads.

AB: We might be running into a problem here in the future. A lot of benchmarks that you can compile and run easily because they rely on a preview1 ABI that's simple to work with might present a roadblock because of WASI versions, right now some people are compiling to preview2, which is more complex to easily compile and benchmark. 

NF: With tools like JCO you can transpile and polyfill preview2 programs for the web. 

AB: Just expressing the worry that it would be hard to compare newer API to older.

PP: The component model has its own memory management story. So the point that Andrew brings up is an excellent question.

BT: Replaying modules that have an interaction with the host might alleviate the worry around preview2. It seems promising in the sense that benchmarks won't need to know too much about the host. But there are overall ecosystem challenges with preview 2 adoption because of the diversity of engines.

BT (responding to DL question in chat) it is good for programs to report their own metrics.

DL (in chat): Right, I saw the coremark-5000 variants, so you fixed the iteration count_
?

BT: people should stop measuring time which adjusting iteration count, because it interacts with garbage collection and other system features, I think we should encourage people to fix the amount of work per iteration

DL (in chat): I think Coremark tries to adjust its iteration count to the execution speed, right?

BT: Yes, that is why we stopped using coremark.

AB: Back to the replay technique: you'd be able to capture any type of host-calls?

BT: Right.

AB: Then we just respond to those host calls similar to what the host responded to, in Wasm?

BT: Yes. 

DL (in chat): Ben, at some point we/you/the collaborators could present the record/repay thing here

AB: In sightglass, everything related to WASI lives outside the measurements. 

BT: We are planning to present the replay technique here soon, but are still working on the paper.
"
stack/2022/3-21-2022.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 21st video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  March 21st, 16:00-17:00 UTC ( March 21st, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants

Francis McCabe
Maciej Pirog
Elle Imhoff
Luke Wagner
Ross Tate
Paul Schoenfelder
Daniel Hillerström
Sam Lindley
Ben Titzer
Andreas Rossberg
Thibaud Michaud
Zalim Bashorov
Michael Knyszek



## Agenda items

1. [Effect handlers in C++](https://github.com/WebAssembly/meetings/blob/1e594b8db8238b851c6afb3e057aeb6d99224323/stack/2022/presentations/wasm-eff-slides.pdf) (Maciej Piróg)

   In this talk, I'll discuss the design of a C++ library for (one-shot) effect handlers built on top of a simple stack-switching mechanism. The library is type-safe, has a readable API, and the performance doesn't seem to be a dealbreaker. While it is *just* a library, I'll focus on the aspects that might be relevant to compilation of native effect handlers, such as memory management and dealing with value types. [Website](https://github.com/maciejpirog/cpp-effects).

## Meeting Notes

This meeting was [recorded](https://us02web.zoom.us/rec/share/QRiZoozn9Ma4b5xKVK9aIKt6mLs5Mhw2GSRqD1WLTK66QafNW4f1Mp6PT1XqDjff.0CqqILEIcTdCvXf7).

MP: Developed in conjunction with Huawei research in Edinburgh and others including Sam LIndley.
MP: C++ library with one shot handlers on top of boost.context
MP: Boost.context is inconvenient to use directly.
MP: Make concurrency easier to use in C++ including type safety and expressiveness.
MP: Needs to be composable
MP: Are effect handlers C++ friendly? How idiomatic are they. How expressive. Can we get needed performance?

MP: Not the first attempt
MP: “Jeff: Objects for effect”, “Effect Handlers for the masses” two previous papers.
MP: C++ different programming model. Value types, no GC, no parametric polymorphism, move semantics. Templates. 
MP: One-shot semantics is a good fit with C++
MP: Handlers in C++ is different to Java and to C. 
MP: Looking for a higher-level abstraction.

MP: Elegant programmer interface
MP: Type safety. Operations are typed.
MP: Performance.

MP: API:
Two commands: Yield & Fork
Functions: yield, fork.

MP: Commands correspond to operations in effect terminology.
MP: Each handler handles a number of commands.
AR: What is the empty struct
MP: That is ugly C++. You have to construct ‘what you inherit from’.

MP: Defining a handler.
MP: You need to define a new class. Handlers look like objects.
MP: Example inherits from FlatHandler because the return clause is trivial.
MP: Overwrite functions that are the Commands. (Implement the operations)
MP: In this library, you override the CommandClause function with different Command arguments.
MP: C++ trivia: if you omit the variable name then that argument is not used (and you can avoid an unused argument warning)

MP: We actually have a scheduler loop in the green threads implementation.
MP: Code is available on github

MP: Object state and behavior. Here they also encapsulate control.
MP: EH are known to be expressive but safety is important.
MP: Type safety of commands and resumptions. 
MP: Effects encapsulated by handlers.
MP: Don’t have to worry about lifetimes. Library takes care of resumptions.
MP: Modern C++ have move semantics for managing resumptions which is very useful for one-shot resumptions.

FM: What happens when you nest handlers.
MP: Innermost handler is the default. You can have labels and you refer to specific handlers when you invoke a command.

MP: Implementation
Stack of metaframes, each references a Boost fiber. 

MP: invoking a command. We use C++ virtual dispatch + multiple inheritance. Dynamic cast is pretty expensive.

MP: Memory management of handlers. 
MP: handlers are created when we handle a computation.
MP: Created when we call OneShot::Handle. 
MP: When should it be deleted?
MP: Deleted after resumptions are deleted and the return clause invoked.
MP: All possible resumptions are preallocated. That leads to a nasty pointer/stack cycle.
MP: No TCO in C++, which can lead to stack overflow. Separate mechanism needed to deal with this.
MP: Programming with handlers and value types: can’t define polymorphic operations needed for exceptions or async/await.

MP: Performance. Depends on Boost performance.
MP: Stack of abstraction is quite tall.
MP: Prefer elegant API.

MP: Benchmark. Traversing a tree. Effect handlers better than C++ native coroutines worse than pure recursive descent.

RT: You are using Boost. What would it take to port to WebAssembly?
MP: Boost has a simple API: suspend and resume fiber. 
MP: It would be good to have a data pipe between fibers: create, resume, checking the state of the fiber. Compare two fibers.
MP: No fancy machinery except for move semantics.

SL: If you had an interface closer to the effect handlers you needed it might have been easier; especially wrt dynamic casting and multiple inheritance.
MP: In many cases, you can use labels to avoid dynamic casts.
MP: I wanted to use the simplest library. Allows for easier portability.

FM: Did you integrate with exception handling?
MP: No, but it should be straightforward with the boost library.
MP: Boost allows you to throw exceptions to fibers.
MP: Not sure what the semantics should be.





### Adoption of the agenda

### Discussion

### Adjourn

"
stack/2024/stack-2024-01-29.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 29th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  January 29th, 17:00-18:00 UTC ( January 29th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Yuri Delendik
Daniel Hillerström
Ross Tate
Alon Zakai
Thibaud Michaud
Frank Emrich
Luke Wagner
Ashley Nelson
Ilya Rezvov
Ryan Hunt
Brendan Dahl
Thomas Lively
Deepti Gandluri
Paul Schoenfelder
Zalim Bashorov
Derek Schuff


## Agenda items

1. Discussion and closing poll on Suspender issue (fgm)

### Adoption of the agenda

This meeting was recorded; the recording can be accessed [here](https://us02web.zoom.us/rec/share/votwcPC2xHChat0iy9jOiSSDiEMUU-MpSIlMcGoE_7gKdNkJM7v0VSBS6qFgI2LN.kULtbnSCPrWfX_H7).

### Discussion

RT: We should have a broader discussion, I have slides

FM: Let’s do that after the Suspender object vote

FM: All those in Favor of removing the suspender object: 

SF: 7
F: 3
N: 1
A: 0
SA: 0

FM: Liable to incur a fair amount of churn, I hope it’ll be over in a couple of months, but it depends on a lot of things being aligned

RH: We can keep a transitional phase if needed, are you going to OT sometime soon? 

FM: Missed this milestone, hopefully the next milestone. There’s a fair amount of consensus within the team that we shouldn’t keep both of them around simultaneously. There’s multiple pieces that need to move. Like I said earlier, this discussion has raised a lot of questions about what kind of guarantees Wasm offers to the developer, in terms of preservation, security, etc. This is not really specific to the stacks subgroup - we could have this discussion in the main CG. We have some time, it would be reasonable to open the discussion here. 

FM: Expressing what I think Wasm does for the developer, there is a security guarantee that is focused on preserving the engine - it doesn’t offer more than that to the end user. This is an important criteria to decide what features should be added to Wasm. This can also pertain to opt-in/opt-out - changing the type system will not fly with the CG. Both EH & Stack switching are examples of this - The shared everything proposal does add some annotations to the type - the rationale is that in the case of sharing, its necessary in order to preserve the integrity of the engine, without it updates to threads can tear long values

RH: For JSPI, was there ever a design written up on this? Hard to know exactly what we’re talking about. I have a hard time understanding how that would work.

FM: The idea was that a non-suspending functions cannot call suspending functions - we discussed this but did not write it up. Similar to async in JS, you end up polluting the type space. If you have an Async function, the majority of your callers will be async. 

RH: JS functions would not be suspendable, and JS function would not be able to call a suspending function?

FM: There would be an escape hatch, it wouldn’t be directly callable by JS.

RT: There’s two answers, one is that suspendable is guaranteed to succeed, the other option is that suspendable is allowed, but not guaranteed to suspend. 

FM: The point about this is that it speaks to this higher level of property that Wasm is offering the developer. For example the JVM aims to have a strong guarantee that a library you will write today will work in the foreseeable future without requiring to recompile it = this property is used quite a bit in the Java space. But this is not the direction that we went in. Personally this is partly a consequence of focusing on C++, being able to see the pointers on the stack.. This isn’t a great situation. IT does eliminate some security guarantees, there are a lot of other security violations that are possible, that are not addressed, we don’t have a clear situation of what we’re offering the current programmer

RH: Different to ensure library compatibility, C++ & Java libraries are different. We assume that an ABI will be built on top of Wasm that provide their own guarantees. There’s only so much we can do in the core spec, because it’s so low level, we can consider providing some guarantees (like read only memory), but hard to go all the way

RT: Issue is harder than that.. There are holes here that we are introducing that do not exist in prior systems

FM: Responding to RH directly, it's true that you can’t make C++ a safe language, this has severely constrained the design of Wasm. My personal objection is that there’s a gap between that reality and the message that people take away. It is what it is, I don’t really think it’s possible to change Webassembly.

<Discussion continues>



### Adjourn

"
wasi/2019/WASI-08-15.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the August 15 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: August 15, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Weak Imports: https://github.com/WebAssembly/WASI/pull/47#issuecomment-521061962
    1. Interface description based on Module types
        - https://github.com/WebAssembly/WASI/pull/74
        - This is a rough sketch, similar to WatIDL, but stripped down, and is
          meant to be just enough to let us start describing API proposals.
    1. Meeting time
        - I received a request from someone who would like to present a proposal to hold a meeting at an APAC-friendly time.
        - We have been following the CG which held some APAC-friendly meeting times for a while but
          [dropped them due to low attendance](https://github.com/WebAssembly/meetings/blob/master/2018/CG-04-03.md#drop-apac-timezone).
        - Assuming this works for the presenter, move the time of the next meeting to 08-30 at 06:00–07:00 UTC? (This is 08-29 at 11:00pm in Pacific Time)?

1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Attendees:

Dan Gohman
Till Schneidereit
Alex Crichton
Luke Wagner
Jacob Gravelle
Sam Clegg
Andrew Scheidecker
Mark S. Miller
Johnnie Birch
Stefan Junker
Andrew Brown

Meeting notes:
Topic: Weak Imports: https://github.com/WebAssembly/WASI/pull/47#issuecomment-521061962
sbc: moved back to custom section design
[please fill in notes here]
MarkM: could a rename be considered—I always think of weak references
Sbc: very strong precedence in C/C++
MarkM: weak/optional imports should be brought up with TC39
Luke: [posts a link https://github.com/guybedford/proposal-weak-imports]
Dan: good question, should we rename?
Stefan: +1 on “optional”
Mark: would “optional” be confusing?
Seems like “no”
Dan: seems like consensus
Sbc: [takes an action item to rename]
Dan: anyone opposed to landing the PR once the rename is done?
[no]
Dan: let’s do it
Topic: Interface description based on Module types (https://github.com/WebAssembly/WASI/pull/74)
Dan: lots of stuff going on around OCap, and that should go on
But in parallel, we need a simple text format
This PR introduces a stripped down text format (see PR description for details)

Mark: should we introduce a term such as “compartment” to describe sets of instances which share memories and tables?
Sam: This relates to the concept of “shared-nothing linking” which we have been introducing.
Luke: In full generality, we won’t need the term compartment, because we’ll just have references and different linking approaches.
Luke: if we want wasi_unstable to become wasi, we need to spec ways to send capabilities between modules. We don’t if we just have references
Till: brings up the question if we need to support wasi_unstable, instead of just breaking it
[discussion]
Mark: This is a useful concept, whether or not it’s something 
[discussion]
Luke: getting back to the proposal, looks good for the transitional role
Dan: idea is, once we have a parser for this, we could land it, and have it be the specification
Could generate header files and documentation from it
Sbc: comments go into some kind of comment syntax?
Dan: double-semicolon
Sbc: need some kind of include mechanism
Dan: yes, good point. Want to really keep this simple
Luke: same requirement came up in conversations with Andreas about defining types in one module and using them in another
Luke: but as long this is all structural, can just agree on structure of types
Dan: 

Dan: We need to factor out types so they can be shared between multiple modules. Maybe something like a #include mechanism?
Mark: #include would be unfortunate in any kind of standards context.
Luke: We could put multiple modules in one file
Dan: Could we design a more declarative form which achieves the same goal but doesn’t have the same problem?
Mark: It’s premature to do a lot of IDL design work
Dan: agree

Timezone discussion
Till, Johnnie: conversations about voting, and people not being able to attend all meetings. Perhaps we can find a way to do votes offline to allow people to vote even if they can’t attend the meeting.
Sam: Another option is to do the vote in the meeting, but hold it open for a week or so after to allow others to vote.
Till: That does change the dynamics.
Johnnie: Would it makes sense to record the meetings?
Dan: What if we ask the CG to record their meetings? We can follow their lead.
Johnnie volunteers to take that to the CG.
"
main/2018/WG-06-06.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 6 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: June 6, 2018 at 3pm-4pm UTC *( June 6, 2018 8am-9am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Brad Nelson
    - Email: bradnelson@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Brad Nelson is planning to leave his role as WebAssembly Working Group chair.
       Brad has recommended Ben Smith as his replacement due to his experience with the
       CG & WG, and his recent experience as CG co-chair.
       
       In this matter, [our charter](https://www.w3.org/2017/08/wasm-charter)
       defers to [W3C Process](https://www.w3.org/2017/Process-20170301/#member-rep)
       which dictates that the role of [chair](https://www.w3.org/Guide/chair/role.html)
       is appointed by the W3C Director. This is typically done in consultation with
       our W3C team member Eric.
       
       Eric has indicate he will likely convey my advice to the director, however,
       in the interest of open decisions, I would like to have an explicit poll.
       * POLL: The Wasm WG should recommend that Ben Smith become our new WG chair.
    1. Discussion on status of the Working Draft.
1. Future meetings
    1. Confirm next meeting date + time.
    1. Handing of agenda for in person meeting.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Opening, welcome and roll call

* Andreas Rossberg
* Conrad Watt
* Limin Zhu
* Luke Wagner
* Mark Robinson
* Peter Jensen
* Bradley Nelson
* Ben Smith
* Arun Purushan
* Keith Miller
* Shiv Kushwaha
* Ulrik Sorber

### Opening of the meeting

### Introduction of attendees

### Find volunteers for note taking (chair to volunteer).

Ben Smith volunteers.

### Adoption of the agenda

Seconded by Luke Wagner.

### Brad Nelson is planning to leave his role as WebAssembly Working Group chair.

Brad has recommended Ben Smith as his replacement due to his experience with the
CG & WG, and his recent experience as CG co-chair.
       
       In this matter, [our charter](https://www.w3.org/2017/08/wasm-charter)
       defers to [W3C Process](https://www.w3.org/2017/Process-20170301/#member-rep)
       which dictates that the role of [chair](https://www.w3.org/Guide/chair/role.html)
       is appointed by the W3C Director. This is typically done in consultation with
       our W3C team member Eric.
       
       Eric has indicate he will likely convey my advice to the director, however,
       in the interest of open decisions, I would like to have an explicit poll.


**POLL: The Wasm WG should recommend that Ben Smith become our new WG chair to the W3C.**

Unanimous consent.

### Discussion on status of the Working Draft.

Brad plans to hand Tab Atkins a 1 page howto doc on the bikeshed plumbing for the spec.

Mutable globals:

We discussed having a poll last time, but forgot to put it on this agenda. Since it was in the previous meeting notes, reasonable to take the poll this time. 

AR: What’s the status of the proposal?

BS: When we passed from CG to WG, the CG had determined that it was ready to go (phase 4).

BN: Doesn’t currently ship in Chrome, but it’s on track to ship

LW: Riding the “rails” in FF, will ship soon

What other proposals need to be integrated? 

Clarify that JSAPI i32 conversions are signed
Limits change from titzer
Serialization if it does end up making the cut

AI(Ben Smith) move these forward until they can be integrated.

BN: May need to run Pub checker again, since it’s been a while

KM: Is there a nice diff view for mutable global proposal against spec?

BN: There may be tooling for this in Bikeshed.

AR: It’s a good point in general, for larger diffs this will be useful.

BN: Will send email to w3c asking about this.

**POLL: We should merge the Mutable Global proposal into v1 of the spec.**

SA|A|N|F|SF
-|-|-|-|-
0|0|0|1|8

A few abstained.

AI: Ben to merge in the proposal.

AR: Technical question; what is the difference between abstaining and neutral? Perhaps if we need a quorum?

BN: Not much of a difference. Mostly just so we don’t look back and wonder why we made decisions.

### Future meetings

KM: Is it necessary to have these every 2 weeks? Maybe just every month.

BN: Perhaps leave it up to the chair.

### Confirm next meeting date + time.

BS: Let's keep it bi-weekly, but cancel aggressively. For cancellation, let’s remove the calendar invite and send out emails.

### Closure
"
stack/2021/sg-7-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 12th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  July 12th, 16:00-17:00 UTC ( July 12th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Alon Zakai
Daniel Hillerström
Ross Tate
Michael Pratt
Michael Knyszek
Zhi An Ng
Zalim Bashorov
Luke Wagner
Thibaud Michaud
Cherry Mui
Ryan Hunt
Thomas Lively
Arjun Guha
Sam Lindley
Jeremy Faller
Elle Imhoff
Ioanna Dimitriou



## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. Go-lang on Wasm (Cherry Mui, Jeremy Faller, Austin Clements, Michael Knyszek, Michael Pratt) [50 Mins]
   1. Next meeting [2 mins].
1. Closure

## Meeting Notes

[Slides](https://github.com/WebAssembly/meetings/blob/12cc98677a80d4143da97ad9e1243e17093801ce/stack/2021/presentations/2021-7-12%20Go%20implementation.pdf)

Short Introduction to Go-lang (Michael Knyszek)

Defer statement (function scope) Defining

Pointers are explicit (like C) (Go is garbage collected which can cause complications)

Slices, bounded reference to underlying array

Built-in map type (hash map)

Function Values (aka closures)

Pointers are crucial to Go semantics

Interfaces (dynamic dispatch)

Goroutines

Go f(x,y,z)
Has its own scheduler
Each has its own stack
Beyond async/await
Lightweight threads

Goroutines communicate through channels

Two kinds of channel: unbuffered & buffered

Select over multiple channel operations
Default makes select non-blocking

SL: Why order of defer execution?
MK: Don’t really know. Feels more intuitive.
MP: Not aware of inspiration. Used for cleanup operations
SL: Well bracketing properties
SL: Can goroutines return a value
MK: Not really currently. Value is discarded.

MP: Go Language Features 

Defer: 
Can close over the return value (result)

Three implementations:
Heap Allocated, Stack Allocated, Open Coded

Compiler statically includes call to the deferred functions

RT: Deferes cant escape, why heap allocate
CM: Dynamic defer (as in array) requires heap allocation.

Panic: 
 Error handling done through return values
 Panic also there. Panics can be recovered from.
 Will execute defers.
 Panic recovery local to function
 Panic not used widely.
 E.g., HTTP server might use it at top-level
RT: Fault tolerant processing
SL: Very exceptional exceptions

MK: Standard Libraries such as JSON parser do use this.
RT: Exceptions (panics) must be handled by the same handler
CM: In gcc-go defer/panic handling handler by two-phase exception handling
ID: Seem similar to Common Lisp exceptions
RT: CL exception handlers don’t do any unwinding. Go is single phase; only during unwinding can you recover

MP: Implementation of scheduler

3 resources (G)oroutine/ (M)achine (thread)/ (P)rocessor (semaphore)

G explicitly blocks
G yields
G can be asynchronously preempted

P limits total amount of parallelism

Can block on system call - thread is blocked but P is ‘taken back’ to allow more G to run

Complicated to decide when to wake another M

Goroutines can share memory

RT: How important is work stealing
MP: Need to conserve amount of work being done. Dont support async preemption on all platforms. Work stealing more important on platforms that don’t support pre-emptive scheduling.
RT: restricted sharing across threads in WebAssembly

CM: Goroutine Stacks

Focus on ‘main implementation platform’

Start small (2kb)
Dynamically sized
May move 
Allocated from heap
Fixed size frame

Each OS thread has a system stack (g0)

Running scheduler, ffi calls,

Object allocation:
Object may be allocated on heap or stack
Stack allocated: escape analysis
Can pass stack allocated objects in functions

Goroutine switch
Preemption check at function entry
Yield voluntary
Asynch preemption by OS signal

Similar to setjmp/longjmp

RT: how important is stack allocation?
CM: important for performance
CM: taking stack addresses pretty important
CM: stack pointer is pretty important to Go.
CM: could cost 5x in performance

Stack growth
Stack bound check at every function entry
Allocate a new stack with doubled size

Segmented stacks are used on other implementations.

Stacks may shrink if small portion is used

GC may shrink during stack scanning

Stack Maps are metadata about live pointers on stack at safe points. 

GC scans stacks precisely if preempted at a safe point
Async preemption scans innermost frame conservatively
Metadata also knows about potentially live data

MK: Go Memory Management
GC language
Concurrent Mark Sweep Collector
One knob: CPU/Memory tradeoff
Goroutines may be asked to help GC

Write barrier enqueues pointers per P-buffer
Objects have no headers
Separate side-table

30% CPU utilization while running
25% as GC worker goroutines
5 user goroutine assist

Goal heap size (1+GOGC/100) *live
GC does not move objects
Interior pointers would make moving difficult

Maps can have pointer keys

RT: what about wide pointers
MK: Not that problematic; except for memory utilization.
RT: racy reasoning wrt wide pointers
MK: Go finalizers will let you revive an object

SL: stacks move?
CM: stacks do move. Means that we are more conservative about stack allocating objects.


### Adoption of the agenda

### Discussion:

### Adjourn

"
main/2018/WG-02-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 12th (Feb 13th UTC) video call of WebAssembly's Working Group

- **Host**: Google Hangouts
- **Date and Time**: February 13th, 2018 at 7am-8am UTC / *February 12th, 2018 at 11pm-12am PT*
- **Time Date Link**: [Link](https://www.timeanddate.com/worldclock/fixedtime.html?msg=WebAssembly+WG+Meeting&iso=20180212T23&p1=224&ah=1)
- **Location**: *Brad will email Google Hangouts link to WG members + registered CG guests prior to the meeting*
- **Contact**:
    - Name: Brad Nelson
    - Email: bradnelson@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Update from chair on First Public Working Draft.
    1. Discussion on assigning spec section reviewers.
    1. Future meetings
       1. Confirm next meeting date + time.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Opening, welcome and roll call

* Alex Danilo
* Brad Nelson
* Heejin Ahn
* JF Bastien
* Conrad Watt
* Limin Zhu
* Andreas Rossberg

### Opening of the meeting

### Introduction of attendees

### Find volunteers for note taking (chair to volunteer).

Brad to take notes.

### Adoption of the agenda

JF seconds.

### Update from chair on First Public Working Draft.

Brad presents status of doc.

The Transition Request for our fPWD was accepted by the W3C, the announcement will likely go out on Thursday.

Caveats with Bikeshed version up on main repo. Something seems to have been lost vs just before commit. Brad will sort it out soon, but see this for now: http://flagxor.github.io/spec/

Discussion on changing tools. Maybe dropping Sphinx in favour of pure Latex.

Rossberg issues with typesetting:
* kerning
* wrong fonts
* type equations too small
* spacing
* links in equations

Discussion on Bikeshed and its limitations.

Brad mentions katex seems to lack the arbitrary limits (vs MathJax).

### Discussion on assigning spec section reviewers.

Discussion on labels (decided don't need a special label for editor review).
Notion of doling out chapters.

Brad will likely create issue for detailed reviewers for each chapter.

Andreas Rossberg - Reviewer for JS + Web specs
JF - Will do a cursory overview of all docs

Rossberg mentions another mechanization of the spec now in Coq.
Fixes from this mostly landed.

One outstanding PR that's not a typo.

Discussion about what happens based on severity level.

Changes can be (added to notes based on AI for after meeting):
* Editorial
  * No changes to text content
  * Corrections that do not affect conformance
* Substantive
  * Corrections that do not add new features
     * Changes conformance of agents.
  * New features

The timeline after fPWD (added to notes based on AI for after meeting):
* First Public Working Draft.
  * Starts a 150 day clock on WG members (present and future) to notify the group of ""essential claims"".
  * After that 150 days, only new claims based on changes to the spec can be excluded (everything else members must license).
* Future Working Drafts.
  * We have to publish a revised draft at least every 6 months. It need not have changes, but needs to explain why.
  * When we revise the spec after this point, we have to carefully capture a list of what ""substantive changes"" have occurred, publishing that in a revised draft. That draft has a shorter clock (60-90 days depending on when someone resigns).
  * If we advance from Working Draft to Candidate Recommendation and then need to change something, the process resets back to 0.
* Candidate Recommendation.
  * We trigger this once we think we have a version that ""done"", i.e. something people should implement.
* There is a process (at W3C) after this that can kick it back to us.
  * [Diagram](https://www.w3.org/2017/Process-20170301/#rec-modify)

Discussion on how to find reviewers for other chapters.
JF mentions we should have more webby folks take a look.

AI: bradnelson - find a webby reviewer.
JF suggest Alex Russell.

### Future meetings

Should do next meeting in 2 weeks.
Will keep the APAC, EMEA, US cadence.
Next do EMEA + US friendly time. 9am.

Two weeks from now.
Tentative April 10-12 meeting.
Andreas not available the week after.

Wording review at in person meeting.
Probably the 12th second half of the day.
Will coordinate with organizers.

### Confirm next meeting date + time.

### Closure
"
main/2017/CG-08-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 22nd video call of WebAssembly's Community Group

- **Host**: Google Hangouts
- **Dates**: Tuesday August 22, 2017
- **Times**: 9:00am–10:00am Pacific Time
- **Location**: *same Google Hangouts link as before*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

None required if you've attended before. Email JF Bastien to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (Luke Wagner to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Upcoming meetings (Luke Wagner)
    1. [Presentation on JS/wasm modules integration](https://docs.google.com/presentation/d/11tHsNh2U9oEJD4lvV7XX2M22JnyeyyCHj1ncmspXjBU/edit?usp=sharing), mostly stage-setting (Domenic Denicola)
    1. State of WebAssembly tooling (Derek Schuff and Alon Zakai)
    1. WebAssembly/JS integration specification (Daniel Ehrenberg) (5 minutes; [early draft of Bikeshed conversion](https://littledan.github.io/spec/document/JS.html))
1. Closure

## Agenda items for future meetings

Ben Smith won't be able to attend this meeting. Delaying his presentation.

1. Bulk Memory Instructions (Ben Smith)
    1. [WIP proposal](https://gist.github.com/binji/acc43b94c0a747e51dfafa1b5b099c9a)
    1. Some initial performance numbers
1. Option to skip data segment initialization (Ben Smith)
    1. [Discussion](https://github.com/WebAssembly/threads/issues/62)

### Schedule constraints

None.

## Dates and locations of future meetings

| Dates                    | Location          | Host       |
|--------------------------|-------------------|------------|
| 2017-11-01 to 2017-11-02 | Santa Clara, CA   | Intel      |
| 2017-11-06 to 2017-11-07 | Burlingame, CA    | TPAC       |

## Meeting notes

### Roll call

* Alon Zakai
* Dan Ehrenberg
* Deepti Gandluri
* Derek Schuff
* Domenic Denicola
* Edgar Pek
* Heejin Ahn
* Jacob Gravelle
* Keith Miller
* Limin Zhu
* Mark Nottingham
* Martin Becze
* Michael Holman
* Patrick Hickey
* Peter Jensen
* Sam Clegg
* Thomas Nattestad
* Tyler McMullen
* Unbug Lee
* Venkat Josyula
* 于 航 (Hang Yu)
* 徐朝逸 (Chao Yi)
* Mingfei Fan
* Sergey Rubanov
* Robert Hitchcock
* Patrick Hickey
* Saam Barati
* Yury Delendik

### Agenda adoption

* Derek Schuff seconds adoption

### Upcoming meetings (Luke Wagner)

* LW: See [2017/CG-11.md](https://github.com/WebAssembly/meetings/blob/master/main/2017/CG-11.md)

### WebAssembly/JS integration specification (Daniel Ehrenberg) (5 minutes)

* DD: Yay!  Excited about use of Web IDL and Bikeshed

### JS/wasm modules integration (Domenic Denicola)

[Slides](https://docs.google.com/presentation/d/11tHsNh2U9oEJD4lvV7XX2M22JnyeyyCHj1ncmspXjBU)

* KM: Toolchain integration?
* DD: Mostly this would be work around establishing toolchain conventions.
* LW: Some work on this already with SystemJS and webpack folks.  More work ongoing.

* MH: Adding new core types for TypedArray in slide example?
* LW: No, these come with the JS Binding Section proposal.  Concrete proposal forthcoming from Brad

### State of WebAssembly tooling (Derek Schuff and Alon Zakai)

#### Updates from Derek
* General status:
* Emscripten MVP support is pretty complete. It also still supports asm.js.
  * Emscripten has JS loader and module interface code, as well as some JS/Wasm interop/marshaling tools (e.g. embind, WebIDL binder). These are just libraries and conventions, it would be good to ensure they work well with proposed module/JS conventions.
  * There's been a big uptick in interest in wasm the last few months, reflected in user interest and discussion on emscripten mailing list, new users trying it out, bugs filed, etc.
  * Rust has experimental wasm support currently via fastcomp (but working on switching to wasm backend). Still plenty of library/runtime stuff left to do.
* Current work/upcoming features:
  * Effort to replace asm2wasm pipeline (which uses asm.js “fastcomp” out-of-tree LLVM backend, and converts the result to wasm) with direct WebAssembly backend in upstream LLVM. Performance and feature support is close, and we (Mozilla and Google) are working to stamp out the remaining bugs and blockers. This is mostly a maintainability thing, and will hopefully be transparent to emscripten users, but good for non-C interoperability and other tool authors.
  * Threads support to go along with wasm atomics proposal.
  * Zerocost C++ exceptions support to go along with wasm exceptions proposal.
  * Wasm object files and linking via lld

* KM: Exception handling work going on in mainline LLVM or Emscripten branch?
* DS: LLVM work is in mainline LLVM. Also some work in Emscripten’s non-LLVM parts (e.g. libcxxabi and the JS module wrapper). Some explanation of Exception Handling.

#### Updates from Alon
* Fuzzing and Reducer tools now available!  They’ve found lots of bugs, if you make a wasm tool, you should try them!
* https://github.com/WebAssembly/binaryen/wiki/Fuzzing

* MH: Does fuzzer work on Windows?
* AZ: Fuzzer does, Reducer doesn’t b/c system call usage.

### Closed

"
main/2024/CG-07-30.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 30th video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: 2024-07-30, 16:00-17:00 UTC (2024-07-30, 9am-10am PDT, 18:00-19:00 CEST)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
   1. Update on and phase 2 vote for the custom-page-sizes proposal (Nick Fitzgerald, 30 minutes)
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

### Attendees
 - Conrad Watt
 - Derek Schuff
 - Thomas Lively
 - Alex Crichton
 - Andreas Rossberg
 - Andrew Brown
 - Bailey Hayes
 - Benjamin Titzer
 - Ben Visness
 - Brendan Dahl
 - Chris Fallin
 - Dan Phillips
 - David Bryant
 - Francis McCabe
 - Garret Gu
 - Heejin Ahn
 - Ilya Rezvov
 - Jake Enget
 - Jakob Kummerow
 - Jeff Charles
 - Johnnie Birch
 - Julien Pages
 - Linwei Shang
 - Manos Koukoutos
 - Michael Ficarra
 - Nick Fitzgerald
 - Nuno Pereira
 - Oscar Spencer
 - Paolo Severini
 - Paul Dennis
 - Petr Penzin
 - Ricky Vetter
 - Robin Freyler
 - Ryan Hunt
 - Sean Jensen-Grey
 - Ty Overby
 - Yury Delendik
 - Zhaoyu Dong

### Proposals and discussions

#### Update on and phase 2 vote for the custom-page-sizes proposal (Nick Fitzgerald, 30 minutes)

Slides: https://docs.google.com/presentation/d/e/2PACX-1vRUhkw44C4ZAXaEUMa7fSo8jcs1hzjWk78ocyu9W69O5zI2Z-7fH7WzZVWBBMOq3aLmTi8loBX1lUfj/pub?start=false&loop=false

NF presenting

FM: Not related to this, but  Is there any similar thought about how to manage maximum sizes of GC memories?

NF: That has not come up in this proposal. From wasmtime perspective I assume this would be a knob for the runtime to expose to the embedder, since all allocation can nondeterministically fail and kill the program, so it’s not really visible to the guest program, since it wouldn’t really know. On the web I guess you can throw an OOM exception

PP: Have you heard any implementation interest from the web?

NF: it would be nice in the fullness of time. There are cool tools that could be built for emulating or virtualizing embedded devices, e.g. emulating a phone, with the same settings as the device. It would be nice, I hope they will do it eventually, but I understand it’s not a priority for them at the moment.

CW: I remember a discussion where web developers on phones were bumping into virtual memory limits. Can anyone here speak to that?

RH: In spider monkey we ran into some virtual memory limitations. We try to detect that early now, and fall back to bounds checking. So we try to address it without any spec changes.

BV: IIUC, before that change we were reserving lots of address space. It wasn’t that big pages were causing issues, it was the reservation strategy.

RH: Yeah it was a memory reservation strategy that we tried to avoid bounds checks. So we avoid that implementation technique if we have to.

PP: I’m open to being the only dissent here, but some of the motivation when this was presented was for extremely constrained devices without virtual memory, but the alternative presented was tabled because we couldn’t support virtual memory, and didn’t serve the purpose well.

CW: I think once we hashed out the technical concerns around the alternative proposals, it didn’t seem like there was much between them, so I went with what I thought was the cleaner language design.

PD: On the size of how many bytes i can choose: is it fixed to 4k or can i say e.g. 100 bytes?

NF: You can do any 32-bit amount of bytes.

PD: So only the page size is fixed.

NF: Right, the page size is fixed but you can specify any number of pages. So you can ask for 8192 pages of 1 byte.

PD: I like that, it would be a useful feature for my use case.

CW: let’s do a full poll:

|SF|F|N|A|SA|
|--|-|-|-|--|
|12|19|6|1|0|

CW: Any final comments PP as the against vote?

PP: I disagree that the consensus was reached, as the alternative to the current design was rejected in order to support virtual memory, while the motivation for the proposal is to support devices without virtual memory. Up to the chairs to determine consensus though.

CW: Given the results of the poll, we’ve achieved consensus for phase 2. PP, if you continue to have concerns about the proposal, please keep raising them and we’ll take them into account as the proposal continues to move through the process

### Closure

"
process/subgroups.md,"# Subgroups

Subgroups of the CG are created when one (or both) of the following apply:

- An area of interest that needs a lot of discussion. Creating a subgroup with regular meetings provides more bandwidth for this discussion.
- An area of interest is only relevant to a small group of participants. In these cases, subgroup meetings give a more focused venue. This way, participants don’t have concerns about wasting the CG’s time with something that the rest of the CG is not engaged in.

To create a subgroup, you should add a poll to a CG meeting agenda with at least 7 days notice. As part of the poll, you should provide information about:
 - The proposed scope, and deliverables of the subgroup.
 - Chairs, or co-chairs of the subgroup.
 - Information on how to join, and contribute to the subgroup.

## Current Subgroups

| Subgroup  | Chair(s)  | Discussion Repo  | Meetings  |
|---|---|---|---|
| Benchmarking | Petr Penzin (@ppenzin), Saúl Cabrera (@saulecabrera)  | [Repo](https://github.com/WebAssembly/benchmarks)  | [Agendas](https://github.com/WebAssembly/meetings/tree/main/benchmarking)  |
| Debugging  | Derek Schuff (@dschuff)  | [Repo](https://github.com/WebAssembly/debugging)  | no meetings currently scheduled, but discussion or agenda suggestions are welcome |
| GC  | Thomas Lively (@tlively)  | [Repo](https://github.com/WebAssembly/gc)  | [Agendas](https://github.com/WebAssembly/meetings/tree/main/gc)  |
| SIMD  | Petr Penzin (@ppenzin), Ng Zhi An (@ngzhian)  | [Flexible Vectors](https://github.com/WebAssembly/flexible-vectors/issues) | [Agendas](https://github.com/WebAssembly/meetings/tree/main/gc)  |
| Stack Switching  | Francis McCabe (@fgmccabe)  | [Repo](https://github.com/WebAssembly/stack-switching)  | [Agendas](https://github.com/WebAssembly/meetings/tree/main/stack)  |
| Threads | Andrew Brown (@abrown), Thomas Lively (@tlively), Conrad Watt (@conrad-watt) | [Repo](https://github.com/webassembly/shared-everything-threads/) | File issues to schedule agenda items |
| WASI  | Bailey Hayes (@ricochet), Pat Hickey (@pchickey)  | [Repo](https://github.com/WebAssembly/WASI)  | [Agendas](https://github.com/WebAssembly/meetings/tree/main/wasi)  |

## Subgroup Leadership Expectations

Subgroups require two kinds of leadership. These roles can be filled by the same person or multiple people:

- Chair(s)—responsible for running the group
- Champion(s)—responsible for driving technical progress on proposals
 
### Chair
A subgroup chair is expected to:

- Organize subgroup meetings:
  - Create agendas in advance so that others can add issues via PRs. These agendas should live in a subgroup-specific folder in the [WebAssembly meetings repo](https://github.com/WebAssembly/meetings). Alternatively, agendas can be organized via issues on a proposal repo for subgroups covering just a single proposal.
  
      Each agenda should have a header that includes meeting details and instructions for how to join. See [this agenda](https://github.com/WebAssembly/meetings/blob/main/wasi/2021/WASI-10-07.md) for an example.
  
      Note: If you use a Google form for registrations, ensure that you turn on email notifications:
      - Go to the ""Responses"" tab in the editing view
      - Click the ""..."" menu button in the top pane
      - Turn on ""Get email notifications for new responses""

  - Add [new participants](https://www.w3.org/community/webassembly/participants) to the Google calendar event. You should ensure the participant is a CG member before adding them by searching for their name in the participant list. If they are not yet listed, explain that registration is free and that they will need to complete that first.

  - While not required, it can be helpful to work 1:1 with champions to ensure they are identifying topics for discussion at meetings and adding them to the agenda.

- Run subgroup meetings:

  - Ensure notes are taken and posted to the meetings repository within one week post-meeting. Public notes are a requirement of the W3C.

  - Facilitate the discussion and step in when disagreements are getting heated or one person is dominating the conversation in an unproductive way.

  - Identify and drive consensus among participants.

  - Identify action items and make note of commitments.

  - Enforce the CoC (see below).

- Maintain the issue queue:
  - Triage new issues as they come in to ensure that relevant issues are responded to appropriately. In subgroups that span multiple proposals, the chair is responsible for triaging group-wide repos, such as the main discussion repo or shared infrastructure repos, while champions are responsible for triaging their own proposal-specific repos.

  - Facilitate discussion and identify and drive consensus, as in subgroup meetings.

  - Enforce the CoC (see below).

- Maintain the list of active proposals:
  - Check in with champions on a quarterly basis to identify the status of the proposal, including any blockers and submit to the CG chairs.

  - Make appropriate updates to the list of active proposals.

- Enforce the code of conduct within the subgroup:
  - To ensure the safety of the community, we recommend that each subgroup have at least one chair that has completed [Otter Tech’s paid CoC training](https://otter.technology/code-of-conduct-training/) or reviewed the [related documents](https://gitlab.com/otter-tech/coc-incident-response-workshop/-/tree/master). If your organization does not have the funding to pay for this training, contact the CG chairs.
"
wasi/2023/WASI-01-26.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: January 26 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: January 26, 17:00-18:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. [WASI SQL Embedding](https://hackmd.io/Q93MXGLYTRSeGw7FVelURg) - Kyle Brown

## Notes
### Attendees
- Lin Clark
- Luke Wagner
- Andrew Brown
- Frank Schaffa
- Wilson Wang
- Krisztian Gascal
- Joe Zhou
- Joel Dice
- Jeff Charles
- Kyle Brown
- Peter Vetere
- Dave Hay
- Bailey Hayes
- Dan Gohman
- Valery Antopol
- Yong He
- Ivan Font
- Johannes Becker
- Chinmay Garde
- David Justice
- Saúl Cabrera
- Till Schneidereit
- Ayako Akasaka
- Colin Murphy
- Piotr Sikora
- Kevin Moore
- Dan Chiarlone
- Sam Clegg
- Mark Christian

#### SQL embedding proposal

**Kyle Brown**: Design doc. Outline of embedding wasm as user objects into a database. Several things that need to be solved. If embed component, have to identify user objects, and these overlap in their type. Could be single col value, could be series of col values. Need a way to disambig. Can emad in URL of different exports. UDF which takes in some num of col vals, as opposed to aggregate that takes in more than 1 row.

I believe URL no longer in wit, so need to figure that out. Need to identify different parts of type. For UD aggregate function, there are typically 4 funcs. Largely this can be done as an interface. Ways to generalize over these different kinds of function shapes. No structured annotations required.

Identifying user objects, identifying the parts of them. Last thing is SQL types the object corresponds to. Need to figure out what the SQL type is. Proposal is that for any default component value types, driver can choose to define map table. An option of an option of a value doesn’t have a high fidelity value in SQL, so would probably not allow you to map out.

Additionally, there’s the option to have some wrapper types, like new pattern in rust. The record type acts as a named alias that maps to SQL type. Much more control over how it gets into SQL context. Could install entire extension without out of band data.

Might want variations of user object, e.g. reduce way. If we present different APIs, they’d be different interfaces.

Interested in moving forward as a proposal

**Lin Clark**: Great, can add a poll to next week

**Dan Gohman**: Option option T

**Kyle Brown**: If you don’t define, driver can pick. When you pass state around. Precise types can vary. If you don’t have a fixed type mapping to your internal database types, you’d simply reject that. We’ll lose at which level the NULL is at. Variant types aren’t in the database. Largely a better idea to not use at the boundary of your UDF. Makes more sense to use what SQL type because you’re largely going to be using this in the database.

**Dan Gohman**: Some backends could support types that others dont

**Kyle Brown**: Any value would allow you to be compliant with the world no matter what the value is. That would be compliant with the world, but you might have additional validation

**Luke Wagner**: Another example: UDF that was incompat with the defined schema.

**Kyle Brown**: In that case, could bring in but then would be SQL error. If an init takes in a type, then other funcs will need to take that type. That would largely be an external validation.

Floated an idea of abstract interface. This interface needs a state type but doesn’t define what it is.

**Luke Wagner**: Thinking about it, if you said typestate = anyval, and use state everywhere, that pins down that you’re using the same type everywhere. That’s coming up in wit.

**Kyle Brown**: Great point. Maybe we’ll give it a go to see if we can get it to validate that way, then can do more in wit.
"
main/2023/CG-01-17.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 17th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: January 17th, 5pm-6pm UTC (January 17th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Tail calls proposal
        1. Poll to phase 4 
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes
### Attendees

 - Luke Wagner
 - Yuri Iozzelli
 - Plh@w3c
 - Ben Titzer
 - Yury Delendik
 - Conrad Watt
 - Slava Kuzmich
 - Keith Winstein
 - Jeff Charles
 - Tom Tartarin
 - Saul Cabrera
 - Zalim Bashorov
 - Paolo Severini
 - Francis McCabe
 - Nick Fitzgen
 - Alex Chrichton
 - Ryan Hunt
 - Daniel Phillips
 - Brendan Dahl
 - Thomas Lively
 - Ilya Rezvov
 - Jakob Kummerow
 - Andreas Rossberg
 - Sam Lindley
 - Sam Clegg
 - Ashley Nelson
 - Shoab Kamil
 - Asumu Takikawa
 - Jlbirch
 - Manos Koukoutos
 - Richard Winterton
 - Dbezhetskov
 - Sergey Rubanov
 - Ioanna Dimitriou
 - Kevin Moore
 - Robin Freyler
 - Thomas Trankler

#### Announcement

Eric Prud'hommeaux will nop longer be the team W3C contact for the Wasm CG/WG, plh@ who is on this call will be the team contact going forward. Welcome Philipe! 

### Discussions

#### Tail calls to phase 4

BT: Talking about an overview of the tail calls proposal

BT: Engines that implement it: V8, JSC, interpreter, this is the last requirement for Phsae 4. Formalism is updates, and toolchain has implemented. 

JSC with the last implementation

CW: Are we going to need a follow-on with return_call_ref? 

TL: Maybe we can include it in the GC proposal

AR: Func types proposal, it’s in the reference interpreter inn that repo, its implemented there and the spec is updated, bunaryen implements it, V8 implements it. 

RH: How does LLVM use this right now? 

TL: LLVM in LLVM IR, you can have calls that have must tail calls, they are required to whatever the target thinks the tail calls are. Otherwise the backend throws a fatal IR, so it’ll error out. There are also …, For C++ in particular the codegen for co-wait/co-yield, in clang produces must-tail calls, so clang will fail to compile down to tail calls <TL to fill in>

RH: Does that just do return call or return call indirect as well? 

TL: Not sure, guess is yes, it can do tail call analysis and then use that not entirely sure. 

AR: Regarding return call_ref, once we’ve landed this whenever we add a call instruction in the future, we can have a companion return call instruction - they should always come in pairs.

FM<in chat>: I am very excited about tail call. But, If I recall, the interaction with EH was not addressed

AR: What interaction specifically?

FM: The wording in the tail calls doesn’t mention EH, and EH doesn’t mention this either, what happens if the last call in the try block is tail called?

AR: We have explicit instructions for tail calls, not a syntactic feature, being last doesn’t matter, but question - is a tail call allowed at all in a try block? Unless there are concrete difficulties with implementation we should allow it

FM: It won’t be caught by the handler in V8

AR: it looks like that would be correct, equivalent to a return followed by a call

FM, Ok, came across it, and wanted to highlight it.

CW: Remaining question: Does the wasm level semantics match what LLVM expects?

TL: No idea, guess is yes

CW: Exception handling should probably handle this, because this is going to phase 4 first. 

AR: Unlikely that any practical codegen would need this, if they do the backend should somehow fix it up

BT: Should we do the poll then? Any other thoughts or concerns? 

**POLL**

|SF|F|N|A|SA|
|--|-|-|-|--|
|23|8|2|0|0|

Only 10 years to get this through! 12, if you count JS. Tail calls to Phase 4! Congratulations to all involved. 

### Closure
"
wasi/2022/WASI-07-28.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: July 28 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: July 28, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Component Model async proposal (part 4: the thrilling, but brief, conclusion) ([slides](https://docs.google.com/presentation/d/1MNVOZ8hdofO3tI0szg_i-Yoy0N2QPU2C--LzVuoGSlE)) (20 min)
    1. Wasi-logging proposal
        1. Poll: Add a wasi-logging proposal, following the ""Stderr"" slide of [the Preview2 presentation](https://github.com/WebAssembly/meetings/blob/main/wasi/2022/presentations/2022-06-30-gohman-wasi-preview2.pdf, at phase 1?

## Notes

### Attendees
- Lin Clark
- George Kulakowski
- Andrew Brown
- Dan Gohman
- danbugs
- flaki
- Jeff Charles
- Joel Dice
- Keith Winstein
- Luke Wagner
- Mingqiu Sun
- Patrick Hickey
- Piotr Sikora
- Richard M
- Saúl Cabrera
- Steve Schoettler
- Yong He
- Shiyu Yuan
- Ghazal
- Josh Triplett
- Adam Mohammed
- Mossaka
- Kyle Brown
- Petr Penzin
- Bailey Hayes

### Wasi-logging proposal

- Dan Gohman
  - presented a bit ago
  - a logging API that will be used by stderr in wasi preview2
- sbc
  - does this mean stderr wouldn’t be a normal fd you could send a byte to at a time?
- Dan Gohman
  - yes but the rest of the posix semantics work (dup and so on)
- sbc
  - so stderr doesn’t depend on stream i/o?
  - can we do the same for stdout?
- Dan Gohman
  - yes. and some people want it for stdout. but looking ahead to that, as different use cases want different things for stdout (async or not, and so on). maybe typed main can let people specify
- sbc
  - maybe wasi-libc can implement the distinction
- Lin Clark
  - any objections? this is a consensus poll for advancing this to phase 1
  - no objections! Dan Gohman and I will figure out offline creating the repository for it and so on

###  Component Model async proposal (part 4: the thrilling, but brief, conclusion)

- Luke Wagner
  - deadlocks!
  - originally had “deadlock avoidance by construction” as a goal
  - but convinced myself it is impossible to avoid if you support tee and zip on streams
  - in general wasm cannot, and does not aim to, avoid resource exhaustion by design
  - instead, we specify that the engine can detect deadlocks, and trap
  - lazily and off the hot path
  - this condition is monotonic: once a deadlock occurs, it will persist
  - rather than hang, we could offer a fallible canon wait to allow callers to opt in to grateful handling
  - recap, some possible post MVP additions
- Mossaka
  - what are your thoughts on actor models?
- Luke Wagner
  - maybe one answer is it goes back to process models, which this is not
- Petr Penzin
  - wondering about tension between coroutine performance and cross-language concurrency
- Luke Wagner
  - a lot of languages that have have coroutines also have streams and futures, or something like them
- sbc
  - thinking of epoll, is there a way to wait on several streams at once?
- Luke Wagner
  - when you call wait, you’re waiting on a task and all its subtasks. so an implementation technique could be making an epoll task which has each thing as a subtask
- Mossaka
  - is this orthogonal to stack switching?
- Luke Wagner
  - I see it as layered on top, and as something that’ll help some implementations. and the proposal is making a lot of progress in the last month
- sbc
  - could use asyncify before stack switching is available
- George Kulakowski
  - questions about the fidelity of epoll emulation
- Luke Wagner
  - probably, and moreso if you accept some runtime cost
- Petr Penzin
  - those edge cases are kind of important, but not possible to enumerate every possible use. and performance degradation can really mess up adoption.
- Luke Wagner
  - for really high concurrency, suspect that’ll move into the host
"
gc/2023/GC-08-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 22 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: August 22, 4pm-5pm UTC (August 22, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Status checks
    1. Discussion: Using `open` instead of `final` in the text format ([#413](https://github.com/WebAssembly/gc/pull/413)) 
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Nick Fitzgerald
- Ashley Nelson
- Jakob Kummerow
- Manos Koukoutos
- Zalim Bashorov
- Slava Kuzmich

### Status Checks

TL: For Binaryen, things are going well, we are implementing new optimizations for WasmGC. We landed a patch that lets you opt in to the final binary encoding at build time. So you define a macro and it uses the final encoding. We have PRs ready to go as soon as we hit Phase 4 to switch to the final encoding by default, at which point you’d still be able to opt into the legacy encoding. Assuming launch is looking good. We have a PR to remove the legacy encoding entirely as well. There is an open issue about br_on_cast where we previously decided to allow br_on_cast to have the output type to be not necessarily related to the output type, but after further discussion with AR, we came to the conclusion it would be nice to restrict it so that br_on_cast is restricted to in fact a downcast, enforced by the validator. Found a very simple way to work around that restriction in Binaryen. No concerns here, but would be interested in other concerns. Already closed the issue as there wasn’t conversation on it. We can talk about the text format next. Any other status?

TL: My impression is V8 is good to go. I know Jakob had a patch for binary encoding for V8 as well.

JK: We haven’t introduced a build time flag because a few people compile on V8 and that doesn’t make sense for us. But we have prepared the patch and are ready to go after the Phase 4 vote. Is on my TODO to run the spec tests again, I haven’t gotten to that yet.

TL: Sync some time and run the Binaryen fuzzer with the updated opcode and V8, see if anything happens. I’ll take an AI for this. Any other status?

TL: RH emailed me (he’s not here). Moving on to the next agenda item, issue about using open instead of final in the text format. RH says that it should be ready to go and is just awaiting review by AR. SGTM. We only have a few days after AR comes back from vacation before the Phase 4 vote, but I think that’s okay and we can make it happen. Just want to make everyone aware of the issue and onboard with the change to the text format. JK, is there a plan to update the disassembler V8 uses?

JK: We’ll have to. Shouldn’t be hard I hope.

TL: Similarly, Binaryen hasn’t updated the text format yet. Still places we’re using the old experimental text format that’s not standard, but that kind of describes all of Binaryen’s text format. Not worried. Will do work to update Binaryen’s text format but it is not the highest priority. Scheduling-wise, we have a Phase 4 vote for Sep 12, 2023, AR is on vacation thru the end of August and then will be at ICFP from September 4 – 9th. So we have 3 days for AR to do spec reviews before the Phase 4 vote but I think it will be okay. If everyone is onboard with the text change, that brings us to the end of our agenda. As expected, rather light. Anything else?

TL: See you in a week for pre-announcing the Phase 4 vote at the CG meeting, then we’ll probably meet again before the Phase 4 vote.
"
main/2018/CG-05-01.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 1 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: May 1, 4pm-5pm UTC (May 1, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

None required if you've attended before. Email JF Bastien to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. [Notes from the in-person meeting](https://github.com/WebAssembly/meetings/blob/master/main/2018/CG-04.md) are now online.
    1. Proposal for a WebAssembly CG co-chair (JF Bastien presenting)
        1. Propose that Ben Smith be co-chair of the WebAssembly CG.
        1. Why have a co-chair?
            1. Frees up some of my time.
            1. Reduces turnaround for procedural CG things.
            1. Enables someone else to act as a clear leader of the CG.
            1. Helpful to have someone else acting as an official facilitator for sub-groups.
            1. Allows me to more cleanly represent a biased point-of-view when I want to by explicitly yielding the role of facilitator to the co-chair when I want to stop being impartial for a bit.
        1. [The CG charter](https://webassembly.github.io/cg-charter/) allows me to unilaterally choose a co-chair. However, I’d rather have the CG take a straw poll.
        1. Why Ben? He’s been involved very early in WebAssembly, has stayed on top of most design / spec work, is leading some new features, he’s a very capable communicator, and he’s level-headed so I think he’d be able to play the role of an impartial facilitator.
        1. POLL: support Ben Smith of Google as co-chair of the WebAssembly CG.
    1. POLL: Change `WebAssembly.Global` constructor to take value as second argument.
        1. i.e. `new WebAssembly.Global({type, mutable}, value);`
        1. This was discussed briefly in the April CG meeting, but there was no official poll taken.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

# Meeting Notes


# Meeting notes

## Roll call

* Ben Smith
* Daniel Ehrenberg
* Eric Holk
* JF Bastien
* Jacob Gravelle
* Jay Phelps
* Limin Zhu
* Lin Clark
* Luis Hsu
* Luke Wagner
* Mike Rourke
* Pat Hickey
* Peter Jensen
* Richard Winterton
* Sven Sauleau
* Yury Delendik



## Adoption of the agenda

*Dan seconds*


## Review of action items from prior meeting.

*skip*


## Fastly meeting wrap-up

[Notes from the in-person meeting](https://github.com/WebAssembly/meetings/blob/master/main/2018/CG-04.md) are now online.


## Proposal for a WebAssembly CG co-chair

*JF Bastien presenting*

1. Propose that Ben Smith be co-chair of the WebAssembly CG.
1. Why have a co-chair?
    1. Frees up some of my time.
    1. Reduces turnaround for procedural CG things.
    1. Enables someone else to act as a clear leader of the CG.
    1. Helpful to have someone else acting as an official facilitator for sub-groups.
    1. Allows me to more cleanly represent a biased point-of-view when I want to by explicitly yielding the role of facilitator to the co-chair when I want to stop being impartial for a bit.
1. [The CG charter](https://webassembly.github.io/cg-charter/) allows me to unilaterally choose a co-chair. However, I’d rather have the CG take a straw poll.
1. Why Ben? He’s been involved very early in WebAssembly, has stayed on top of most design / spec work, is leading some new features, he’s a very capable communicator, and he’s level-headed so I think he’d be able to play the role of an impartial facilitator.

**POLL:** support Ben Smith of Google as co-chair of the WebAssembly CG.

| SF | F | N | A | SA |
|--|--|--|--|--|
| 13 | 0 | 1 | 0  | 0 |


## `WebAssembly.Global` constructor

*Ben Smith presenting*

`WebAssembly.Global` constructor should take value as second argument.

i.e. `new WebAssembly.Global({type, mutable}, value);`

This was discussed briefly in the April CG meeting, but there was no official poll taken.

**POLL:** Change `WebAssembly.Global` constructor to take value as second argument.

| SF | F | N | A | SA |
|--|--|--|--|--|
| 1 | 5 | 4 | 0  | 0 |

"
main/2018/CG-01-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 9th video call of WebAssembly's Community Group

- **Host**: Google Hangouts
- **Dates**: Tuesday January 9th, 2018
- **Times**: 11:00pm–midnight Pacific Time
- **Location**: *same Google Hangouts link as before*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

None required if you've attended before. Email JF Bastien to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Update on [WebAssembly atomics](https://github.com/WebAssembly/threads)
        1. Browsers are disabling SharedArrayBuffer due to Meltdown / Spectre, what does it mean for the WebAssembly equivalent? (@flagxor + @binji)
        1. Split some simpler subspecs out of the threads spec and let them land sooner? (@lars-t-hansen)
            1. Sign extension opcodes
            1. Mutable exportable globals
            1. Programmatic data initialization
    1. Discuss upcoming in-person meetings.
    1. Other items TBD
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting notes

### Roll Call

* Alex Danilo
* Andreas Rossberg
* Anthony Laforge
* Arun Purushan
* Ben Smith
* Ben Titzer
* Brad Nelson
* Daniel Ehrenberg
* David Wrighton
* Deepti Gandluri
* Derek Schuff
* Eric Holk
* JF Bastien
* Keith Miller
* Kevin Cheung
* Lars Hansen
* Marco Trivellato
* Marcos Diaz
* Mark Nottingham
* Michael Holman
* Paolo Severini 
* Pat Hickey
* Sean Westfall
* Sven Sauleau
* Thomas Nattestad
* Ulrik Sorber

### Opening

#### Adoption of the agenda

Pat seconds.

#### Find volunteers for note taking (acting chair to volunteer)

### Review of action items from prior meeting.

* SIMD is in background work. Brad will report. Integer SIMD may be ready by April.
* Tail call: no updates. Can add as option to proposal. Some people oppose this. No discussion since in-person meeting.
* Exception handling: ongoing work.
* CSP: Google talked to Mozilla, trying to move forward. Some CSP experts on the hook. Apple folks like their approach.
* [CSP](https://github.com/WebAssembly/content-security-policy/issues/1) and [associated PR](https://github.com/WebAssembly/content-security-policy/pull/6) 
* JS embedding tests: Dan started.
* WPT: nothing new.
* Browser limits: JSc updated their values to more closely match V8. Lars says Mozilla has a question about number of locals (did sum of params and locals). Ben Titzer will update proposal in spec repo.

Skip other items.

### Discussions

#### Update on [WebAssembly atomics](https://github.com/WebAssembly/threads)

Browsers are disabling SharedArrayBuffer due to Meltdown / Spectre, what does it mean for the WebAssembly equivalent?
[Slides](https://docs.google.com/presentation/d/18rPEUBROVvQUpE9asjWvR__xpskzRgEUq2MnYuUkZBc/edit#slide=id.g2d4d39b8a2_0_72)

*Brad gives summary of attacks*

SAB can be used as a high precision timer (count on one thread, witness updates in another). There are other sources of timing in browsers. Brad presented a very early design that would re-enable SAB with much caveat (extra processes and such). Discussion about what other browsers think, it might be possible to just re-enable as-is.

“Our long-term plan is to make Spectre impossible even in the presence of high fidelity timing; further work is needed to re-enable this path.”

[Proposal](
https://docs.google.com/document/d/1PBdsq1_DfOCCD-AY_Fa3XoEcgSsFCNR4aBX9W7jkiCw/edit#)

WebAssembly atomics are basically tied to SAB at this point. Waiting to figure out Spectre mitigations before talking about enabling.

Split some simpler subspecs out of the threads spec and let them land sooner? 

1. Sign extension opcodes
1. Mutable exportable globals
1. Programmatic data initialization

**POLL** pull each of these 3 items out into their own repo

*unanimous*

Discussion on feature testing of these features once split up. Threads could require all 3, and testing can just be pessimistic.

#### Discuss upcoming in-person meetings

April would be a good time (Andreas would like early).

Fastly might host in San Francisco.

August timeline after that.

Google Munich would be able to host afterwards, in summer.

Igalia could host as well.

Zalando could also host, either Germany or Finland, maybe in November.

*Luke pointed out the following after the CG call endded* If WebAssembly has a presence at [TPAC 2018](https://www.w3.org/wiki/TPAC/2018) (October 22-26, in Lyon, France), we agreed last time we should reuse that as an in-person meeting opportunity.

#### Future VC meetings

Keep meetings bi-weekly, and rotate times.

Send invites in UTC.
"
wasi/2022/WASI-12-15.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: December 15 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: December 15, 17:00-18:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. ""`wasi-messaging` updates"" from [Danilo (Dan) Chiarlone](https://github.com/danbugs).
    1. ""`wasi-sql`"" from [Danilo (Dan) Chiarlone](https://github.com/danbugs), and [Ivan Towlson](https://github.com/itowlson).

## Notes
### Attendees
- Dan Gohman
- Joel Dice
- Dan Chiarlone
- Jeff Charles
- Piotr Sikora
- Johannes Becker
- Kate Goldenring
- Brian Hardock
- Colin Murphy
- Till Schneidereit
- Luke Wagner
- Kyle B
- Andrew Brown
- Ayako Akasaka
- Bailey Hayes
- Liam Randall
- Brooks
- Michelle Dhanani
- Mingqiu Sun
- Mucyo Fred
- Pat Hickey
- Sam Clegg
- Steve S
- Toni
- Yong
- Hung-Ying Tai
- Joe (Mossaka)


### Notes

#### ""wasi-messaging updates"" from Danilo (Dan) Chiarlone.

wasi-messaging update & wasi-sql
 
Joe: It would be good to have comparisons of the different implementations, as there are many subtle differences.
https://github.com/deislabs/spiderlightning/tree/main/crates/messaging/src/implementors
 
Dan: Good idea; we can add those to the documentation.
 
#### ""wasi-sql"" from Danilo (Dan) Chiarlone, and Ivan Towlson.

wasi-messaging update & wasi-sql

Bailey: It would be really great to reach out to more database people.

Dan: Agreed!

Dan G.: Can you talk through the motivation question briefly?

Dan: Having one interface that covers multiple implementations has value

Bailey: We want capability-driven APIs. Hosts want to delineate what types of capabilities we give to guest code; sockets are a wide pipe; wasi-sql is more specific. This gives us better tools for detecting SQL injection attacks, in ways that works over all databases. And it helps us support “weird” languages.

Luke: This solves some problems without trying to solve all problems, and that has value. It’s abstracting over some of the mechanics without fully abstracting over the database semantics. For example, wasi-keyvalue potentially abstract over different implementations, while wasi-sql exposes more of the semantics of the specific implementations.

Websql failed because in browsers, it would be necessary to fully spec the database semantics. (see https://www.w3.org/TR/webdatabase for details). But for this proposal, we can treat the sql query string as just a string.

Joe: Does anyone know why were all implementors of web database proposal use the same Sqlite?
Was it the case that designers of web database found it difficult to standardize a SQL interface that works for most use cases of most sql databases?

Luke: Several (all? I forget, but at least Firefox and Chrome) were already embedding sqlite for browser-internal purposes (e.g., managing 
And the difficulty wasn’t even attempting to abstract over multiple databases, but even just precisely defining the semantics of the subset (b/c you don’t want to expose, e.g., vacuum) to expose to web content

Should we rename wasi-sql to reflect that it isn’t actually limited to SQL databases?

[discussion generally positive, but no specific name was chosen]

Dan: Should we factor out error types into a separate interface?

Luke: We do want to avoid having a one-big-enum-for-everything. Precise error codes help people do case analysis. Perhaps there could be a resource for representing a generic error with a string and backtrace. Though we’ll always want these interface-specific errors

Chris Woods: Is there a component-model plan for a common error code?

Luke: No; the plan is to encourage interface-specific errors.

Chris: It can be very convenient for users of interfaces to have common codes. It’s a tradeoff. And wrapping one component interface in another, forcing all the interfaces to have a shared error code space makes it clear how to map them.

Kyle B: I wonder if wit gives us an opportunity to be more precise.

Luke: Enums can be packaged up as nested arms 

[discussion about factoring out a general-purpose error type, with a string message, backtrac, and maybe other opaque debugging features]

Dan: Maybe I’ll make up a proposal

Wasi-messaging update presentation: https://docs.google.com/presentation/d/1vuqyNAMyCngeSV4CJ7xkhYRfPVMsSL0_dlgkqCMM1qw/edit?usp=sharing
"
main/2018/CG-12-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 11 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: December 11, 5pm-6pm UTC (December 11, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email Ben Smith to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
      1. [Follow-up on utf-8 handling in JS spec](https://github.com/WebAssembly/spec/issues/915) (Sven Sauleau)
    1. [The Future of ChakraCore](https://github.com/Microsoft/ChakraCore/issues/5865) (Limin Zhu)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Andreas Rossberg
* Arun Purushan
* Ben Smith
* Ben Titzer
* Conrad Watt
* Deepti Gandluri
* Francis McCabe
* Heejin Ahn
* Jacob Gravelle
* Jay Phelps
* Keith Miller
* Kevin Smith
* Limin Zhu
* Luke Wagner
* Nick Fitzgerald
* Pat Hickey
* Peter Jensen
* Richard Winterton
* Sergey Rubanov
* Sven Sauleau
* Tyler McMullen
* Ulrik Sorber
* Yury Delendik

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Limin zhu seconds

### Proposals and discussions

#### Review of action items from prior meeting.

#### [Follow-up on utf-8 handling in JS spec](https://github.com/WebAssembly/spec/issues/915) (Sven Sauleau)

SS: two issues. We switched to webidl spec, [inaudible]

The JS API uses the whatwg decoder, which doesn’t behave exactly the same as the wasm decoder. Andreas Rossberg made a PR to fix the surrogate issues. Now I think those two replacement characters are the same. We still have to think about the JS API. It seems that we have something that is compatible.

#### [The Future of ChakraCore](https://github.com/Microsoft/ChakraCore/issues/5865) (Limin Zhu)

LZ: I think you’ve seen the news that Edge plans to use Chromium, but Edge also plans to use v8. So want to talk about what will happen with ChakraCore.

LZ: ChakraCore is not discontinued, still have a ton of users for non-browser use cases. We’ll still continue to work on that. Michael Holman is working on that. Linked to the general messaging on GH.

AR: What are the resources that Microsoft will put on ChakraCore, keeping up with proposals and work?

LZ: We’re still trying to figure out what will happen there. We don’t have a clear answer yet, it depends on how everything goes. Adjustment will come after these discussions. We intend to keep up with proposals.

LZ: One more thing: what does this mean to wasm? For some of our stages, we require implementation to move forward. The understanding of TC39 does not count new Edge as new implementation, but ChakraCore will count. I recommend we do the same thing for wasm.

SS: Looking at the phase doc, it doesn’t look we require implementations.

[others]: I think we do require this for stage 4.

AR: Maybe we should strike the word “web” here and replace with “production”.

[discussion about whether we require “web” engines or other engines for phase advancement]

AI[BS] make a GH issue about rewording phase advancement.

TL: I wonder about the number 2 (engines), is that because we want a significant fraction? If so, maybe we want to change that number.

AR: I think two is OK, it should be more than 1. But it doesn’t need to be the whole world.

BT: We still probably want a web engine, we don’t want two smaller engines to decide this.

BS: Yes, we’ll want to flesh out the wording carefully here.

AR: Are you going to start implementing proposals for v8?

LZ: Maybe, our plan is to contribute back to v8. But we’re not sure what the right first steps are. We want to work more closely with v8 to make sure how to do this best.

BT: We’ve been having discussions about this already, will follow up later.

### Closure
"
process/proposal.md,"# Creating a WebAssembly proposal

The formal process for standardizing a WebAssembly proposal is described in
[phases.md](https://github.com/WebAssembly/meetings/blob/main/process/phases.md),
but this document covers the initial stages in more detail and is meant to be
useful to you if you have an idea for a proposal and want to know how to get
started proposing it.

## Identify a problem

Any proposal to extend WebAssembly should include a clear explanation of the
problem it's trying to solve. In a way, identifying the problem is more
important than the initially proposed solution–it's the problem that will
motivate the community to get involved and help move a proposal forward, not the
details of the proposed solution.

The problem you identify should be in-scope for the WebAssembly community group,
meaning it should be about making WebAssembly faster, more capable, more useful,
or easier to compile to. If you're not sure whether your problem is in-scope,
that's ok! Part of the initial discussions about your proposal will involve
figuring that out as a community.

The most successful proposals also solve concrete problems that people are
already facing. Having real application or toolchain developers asking for your
problem to be fixed is a great motivator for the community to work on it. If
your proposal will solve a performance problem, having an estimate of how much
of a performance improvement the community can expect will also be helpful.

## Come up with a solution

You should view your initially proposed solution as a place to start the
conversation around your proposal. Most proposals go through significant changes
in response to community and user feedback as they move toward standardization,
so you shouldn't get too attached to the details of your original design. Things
like choosing encoding details and drafting formal spec text that are important
in later phases are not as useful at this early stage. That being said, your
solution should be detailed enough that it is clear how it fits in with the rest
of WebAssembly and how it might be implemented in WebAssembly engines and tools.

## Share your proposal

Congratulations! If you've made it this far, you officially have a phase 0
proposal. The next thing to do is share your idea with the community. The best
place to start is by filing a new GitHub issue on the [design
repo](https://github.com/WebAssembly/design). The issue should contain an
explanation of the problem you aim to solve and your proposed solution.

Your design issue will probably get at least a few responses and it might get a
lot of responses. For most phase 0 proposals a single GitHub issue is sufficient
to manage the discussion, but if there is too much feedback for a single issue,
you can request a dedicated GitHub repository for your proposal. A dedicated
repo will allow you to manage feedback via multiple GitHub issues or discussions
and use PRs to update your explainer document.

Once you've addressed any initial feedback it's time to bring your proposal to
the full community to advance to phase 1. Make a PR to the [meetings
repo](https://github.com/WebAssembly/meetings) to add a discussion of your
proposal and a phase 1 vote to an upcoming meeting. At the meeting, you will
present your proposal and the community will discuss it and do a consensus vote
on whether they consider your problem and proposed solution in-scope for the
community group. If consensus is achieved, and it almost always is at this
phase, your proposal will officially enter phase 1.

## Phase 1 and beyond

At phase 1 your proposal receives a dedicated proposal repo if it doesn't
already have one and it is added to the [list of
proposals](https://github.com/WebAssembly/proposals). This is where the real
work of prototyping and iterating on the proposal to achieve consensus really
begins. Unfortunately, just having a phase 1 proposal does not guarantee that
the community will work on it. Part of a proposal champion's job is to actively
solicit feedback on the proposal and to motivate others in the community to help
implement it. It's also possible for the champion to contribute implementations
themselves, but ultimately the proposal needs to be implemented and ready to
ship in two web engines and at least one toolchain before it can be
standardized, so it is typically better to make the proposal a team effort.
"
wasi/2024/WASI-07-25.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: July 25 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: July 25 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. Yosh Wuyts: WASI 0.2.1 release next week Thursday
    1. Yosh Wuyts: `@deprecated` gates have landed in WIT
1. Proposals and discussions
    1. _Submit a PR to add your announcement here_

## Notes

### Attendees

- Bailey Hayes
- Yosh Wuyts
- David Bryant
- Nick Fitzgerald
- Jeff Charles
- Taylor Thomas
- Marshall Meier
- Max Seidler
- Sehyo Chang
- Alex Crichton
- Andrew Brown
- Chris Woods
- Mingqiu Sun
- Pat Hickey
- Kate Goldenring
- Dave Bakker
- Mendy Berger
- Luke Wagner
- Oscar Spencer
- Emily Ruppel
- Hung-Ying, Tai

### WASI 0.2.1

**Yosh Wuyts**: Two small updates to share today. The first is that as it comes for WASI 0.2.1 the release is set for next Thursday. We seem to be on track for that and nothing particularly interesting is still outstanding.

**Yosh Wuyts**: I originally suggested that wasi-clocks timezone support could be part of WASI 0.2.1. We received feedback on wasi-clocks timezone feature and we will have that as unstable going into WASI 0.2.1. The only feature we’re going to have for WASI 0.2.1 is the @since feature gates. We seem to be on schedule for that.

**Colin Murphy**: ECMA. The group that made the spec for JS for clarification. Are we saying we’re going to hold off putting it in wasmtime? No landing of timezones in wasmtime. We also need to add @deprecated.

**Yosh Wuyts**: My understanding of the JS group (ECMA), they have given us feedback for wasi-clocks. We were making assumptions about what UNIX does vs the decisions made for browsers. We need to navigate the existing unstable feature for timezones, and then also need to consider and answer feedback for the current wasi-clocks interface.

**Yosh Wuyts**: For WASI 0.2.1, this is just adding additional annotations for WIT.

**Colin Murphy**: The existing implementation for wasi-clocks and timezone was very chronos/rust specific.

**Yosh Wuyts**: I think it’s really great that we got feedback from world experts on this and that it could make it easy to run in browsers.

**Taylor Thomas (in chat)**: Community feedback ftw

**Pat Hickey**: Are there new features?

**Yosh Wuyts**: Just at @since

**Pat Hickey**: And we also have many updates to documentation. This sounds good to me and this is what we’re meant to be doing.

**Yosh Wuyts**: Also we’re going to be doing this manually for this release to see what it takes to automate.

### @deprecated gates have landed in WIT

**Yosh Wuyts**: We’ve added @since and @unstable. Now we are adding and have landed implementations for a new annotation, @deprecated.

**Yosh Wuyts**: @deprecated takes a required version field. This will enable us in future releases, probably 0.2.2 in wasi-http for a rename that we want to do. For wasi-clocks, we’re getting feedback from experts for renames/replaces that we may want to take. This will allow us to do this in the 0.2.x timeframe to make changes without breaking anything. Then in 0.3.x timeframe, we can remove the deprecated things.

**Yosh Wuyts**: I encourage you to read the WIT documentation for that and ask any questions. https://github.com/WebAssembly/component-model/pull/377

## WebIDL to WIT converter

Mendy Berger: WebIDL to WIT converter. Guy Bedford got first-class support in JCO. Please collaborate and join us if you think it’s interesting. Links to chat and review:

- https://bytecodealliance.zulipchat.com/
- https://github.com/MendyBerger/browser.wit
- [Jco: WebIDL support & browser test suite](https://github.com/bytecodealliance/jco/pull/471)

**Luke Wagner:** This project is really cool. This makes it so that you have the entire browser API available to you.
"
wasi/2020/WASI-03-26.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the March 26 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: March 26, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Proposals and discussions
    1. WASI currently uses a POSIX-like `errno` enum, but that seems
       not well suited for less POSIX-like APIs:
       https://github.com/WebAssembly/WASI-crypto/pull/13#issuecomment-599324384
       Many systems have evolved to having a single error enum shared
       across the whole system. Is it ok if we don't aim for that?
    1. POSIX tries hard not to let syscalls cause segfaults, returning
       things like `EFAULT` instead. There may be some value in this for
       POSIX compatibility, but how valuable is this otherwise? Should
       other WASI APIs be allowed to trap?
    1. Evolving idea: wasi-sdk API for extra emulation:
       1. `-D_WASILIBC_EMULATED_MMAN`
       1. `-D_WASILIBC_EMULATED_PAUSE`
       1. `-D_WASILIBC_EMULATED_RAISE`
       1. ...
       1. `-D_WASILIBC_EMULATED_ALL` ?
       and
       1. `-lwasi-emulated-mman`
       1. `-lwasi-emulated-pause`
       1. `-lwasi-emulated-raise`
       1. ...
       1. `-lwasi-emulated-all` ?
    1. [Proxy-Wasm](https://github.com/proxy-wasm) update.

## Meeting Notes

Attendees:

Dan Gohman
Jan Falkin
Lee Campbell
Till Schneidereit
Alex Crichton
Andrew Brown
Mingqiu Sun
Olaf Tomalka
Piotr Sikora
Pat Hickey
Peter Huene
Sam Clegg
Johnnie Birch
Wouter van Oortmerssen
Luke Wagner
Aaron Turner
Benjamin Brittain
Taylor Thomas
John Plevyak
Ralph Squillace
Brian Hardock

Meeting notes:

WASI currently uses a POSIX-like errno enum, but that seems not well suited for less POSIX-like APIs: https://github.com/WebAssembly/WASI-crypto/pull/13#issuecomment-599324384 Many systems have evolved to having a single error enum shared across the whole system. Is it ok if we don't aim for that?
Lee: we need standardized ways to propagate errors throughout the system which is generic over all kinds of APIs
PH: Design a way to structure and compose errors. We should do this with types, rather than integer ranges.
SBC: Capability system is one of the unifying parts of WASI, there will be errors common to all capability operations.
PCH: Compositional errors might be something like a sum type of different errors.
Bwb: Strings as errors have lots of awkward problems, including internationalization.
PCH: Being able to use any type gives us the power to describe errors.
Jplev: Have a generic error codes, with ways to map to them.
Sbc: Don’t redeclare the same errors as POSIX
Pat: APIs define the things they need now, and we’ll work on factoring things out and composition as we go forward.
Lee: POSIX is a C API and we can map WASI errors to POSIX errno as needed.


POSIX tries hard not to let syscalls cause segfaults, returning things like EFAULT instead. There may be some value in this for POSIX compatibility, but how valuable is this otherwise? Should other WASI APIs be allowed to trap?
Sbc: one of our objectives is to be able to implement WASI as wasm modules.
Lee, sbc: We seem to need core language support for catching traps to really figure this out.
Evolving idea: wasi-sdk API for extra emulation:
```
-D_WASILIBC_EMULATED_MMAN
-D_WASILIBC_EMULATED_PAUSE
-D_WASILIBC_EMULATED_RAISE
...
-D_WASILIBC_EMULATED_ALL ? and
-lwasi-emulated-mman
-lwasi-emulated-pause
-lwasi-emulated-raise
...
-lwasi-emulated-all ?
```
Lee: Do we need the `-l`s? We can just put everythgin in libc.a and it’ll only get linked in 
Proxy-Wasm update.
This is an update from the previous presentation in October.
Consolidated many callbacks from the previous presentationtation.

Sbc: Have you looked at creating a witx description?
Piotr: Not yet; we’re still iterating on the API.
Sbc: Do proxy implementations need to implement all callbacks, or are some of the m optional?
Piotr: Some are optional. If you’re only implementing HTTP, you only need to impelment HTTP callbacks.
PH: This proposal is great, and also very big, can we factor out pieces that can be used in other contexts?
 
Adapting the core CG Phases for WASI.
https://github.com/WebAssembly/proposals/
“Two or more Web VMs”

Reference interpreter, formal semantics

Fitting the existing phases into the process
"
main/2020/WG-03-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 11 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: March 11, 2020 at 3pm-4pm UTC *( March 11, 2020 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. POLL: [standardize phase 4 proposals](https://github.com/webassembly/proposals#phase-4---standardize-the-feature-wg)
       1. [Non-trapping float to int](https://github.com/WebAssembly/nontrapping-float-to-int-conversions)
       1. [Sign-extension operators](https://github.com/WebAssembly/sign-extension-ops)
       1. [Multi-value](https://github.com/WebAssembly/multi-value)
    1. Discussion: new spec document design (Ben Smith + Eric Prud'hommeaux)
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Introduction of attendees

* Ben Smith
* Ms2ger
* Luke Wagner

### POLL: [standardize phase 4 proposals](https://github.com/webassembly/proposals#phase-4---standardize-the-feature-wg)

1. [Non-trapping float to int](https://github.com/WebAssembly/nontrapping-float-to-int-conversions)

1. [Sign-extension operators](https://github.com/WebAssembly/sign-extension-ops)

1. [Multi-value](https://github.com/WebAssembly/multi-value)

We discussed how best to advance from phase 4 to phase 5. Because of the low
attendance of this meeting, we decided to send out an email to the WG mailing
list instead of polling the group.

We discussed that we should probably make a set of PRs for each proposal before
sending the email out, so the group can see what they'd be agreeing to merge,
and if there are any merge issues. It also requires us to linearize the set of
proposals, which may be desirable.

AI(binji): Make a PR against the spec for each proposal.

AI(binji): Send out email to WG asking for approval to merge PRs

### Discussion: new spec document design (Ben Smith + Eric Prud'hommeaux)

Ben presented to the group. The current core spec document is generated in a
convoluted way (Restructured text, to single-page HTML, extracting MathJax and
converting to Katex, python scripts, Bikeshed). This is not a maintainable
solution. Ben Smith, Eric Prud'hommeaux, and Philippe Le Hégaret had a meeting
to discuss improvements to this process a month ago. For the most part this
process was done to ensure that the mathematics snippets in the document were
renderable without JavaScript (which MathJax requires). However, since we can
already produce a PDF from the spec document source, this would fit the
requirement of having a non-JavaScript version of the document. We can then use
the standard multi-page HTML w/ MathJax document as the main spec document.

This would require some changes to both documents to include the required W3C
layout and front matter, but would be significantly less work than we are doing
currently.

In general, the group seemed to think this was a good direction to go, though
Ms2ger did mention that it was annoying that the document reflowed when the
MathJax finally loaded. The group agreed. It also seems that perhaps the
feature detection for MathJax is not quite right, since it doesn't detect that
Firefox can render MathML, and says that MathML is not available if you try to
choose it in the settings.

Ben also mentioned that we were considering moving to using the W3C's new
living document process. It would be a better fit for WebAssembly in many ways,
since it doesn't require going through the entire REC process. However, as far
as we know, no other group has adopted this process yet, so there was some
hesitation from the group. We discussed that perhaps if someone from the W3 was
able to help us through the process, it might make it easier for us to make
this decision.

AI(binji): Follow up on living document

### Discussion: go offline for most meetings

Because of low attendance of this meeting, we discussed having more decisions
made asynchronously over email. We weren't exactly sure the correct email
address for the WG mailing list.

AI(binji): Find email for WG mailing list

## Closure
"
wasi/2023/WASI-12-14.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: December 14 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: December 14, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Discussion, Q&A: WASI Preview 2 vote on 1/11/2024

## Notes
### Attendees

- Bailey Hayes
- Pat Hickey
- Dan Gohman
- Nuno Pereira
- Trevor Sundberg
- Timmy Silesmo
- Piotr Sikora
- Wassim Chegham
- Colin Murphy
- Alex Crichton
- Dave Bakker
- Jeff Charles
- Wouter Hennen
- Luke Wagner
- Oscar Spencer
- Matthew Yacobucci
- Dan Philips
- Johnnie Birch
- Brian Hardock
- Ayako Akasaka
- Robin Brown
- Andrew Brown
- Michael Warres
- Till Schneidereit
- Kate Goldenring

### Notes


### Discussion, Q&A: WASI Preview 2 vote on 1/11/2024

Pat Hickey: WASI Preview 2 criteria we are working on the second reference implementation in JCO.

Guy Bedford: JCO serve basic implementation. Random, io, clocks still at 100%, cli at 100%, fs from 82% to 93%, http outgoing was completed, http incoming now running two out of the three test integrations, 88/99 tests passing. The last bit can also be the hardest so don’t rule out any surprises. We’re expecting to be very close to a conformant implementation next month. There’s still a little bit to go for the fs edge cases and socket work. We’re about 12 test cases away.

Pat Hickey: A proposal must reach phase 3, which we voted on last meeting. 

Pat Hickey: We are expecting the second reference implementation to be complete by the next WASI meeting, January 11th.

### WASI EOY 2023 Thank You


This is an incomplete list of people who have contributed to the WASI and Component Model specifications and implementations in 2023, along with a likely incomplete list of areas they contributed to.

------

Aaron Robinson - WasmImportLinkageAttribute

Adam Foltzer - wasi-http specification and implementation

Alex Crichton - wasm-tools component model implementation, wit-bindgen, wasmtime::component, wasmtime-wasi implementation

Andrew Brown - wasi-nn, threads

Bailey Hayes - subgroup co-chair, many specifications

Brendan Burns - wasi-http specification and implementation

Brett Cannon - wasi python

Brian Hardock - wasm-tools component implementation, wit-bindgen

Calvin Prewitt - warg

Colin Murphy - wasi-clocks

Dan Gohman - wasmtime-wasi implementation, championing many proposals

Daniel Macovei - wasm-tools component implementation, warg

Dave Bakker - wasi-sockets champion

Eduardo Rodrigues - wasmtime-wasi-http implementation, vscode-wit plugin

Guy Bedford - jco, componentize-js, many specifications

Ivan Towlsen - component model docs (https://component-model.bytecodealliance.org/

Joe Mossaka Zhou - wit-bindgen for Go, wit specification and implementation

Joel Dice - wit-bindgen, wasmtime-wasi, componentize-py

Johan Brandhorst-Satzkorn - goarch wasm32 proposal

Lann Martin - wit-bindgen, wasmtime-wasi, wave

Larry Ewing - .NET runtime wasm support

Luke Wagner - component model specification, wasi-http specification

Kate Goldenring - component model docs (https://component-model.bytecodealliance.org/

Marcin Kolny - wasi-threads specification, wasi-testsuite maintainer

Mingqiu Sun - wasi-nn specification

Pat Hickey - wasmtime-wasi, subgroup co-chair, many specifications

Peter Huene - cargo-component, wac, component model specification

Piotr Sikora - wasi-http specification

Robin Brown - wit-bindgen, wasm-tools, language SIGs organizer, warg

Roman Volostavos - wit-bindgen, wasmtime-wasi, and wit-deps tool

Ryan Levick - wit-bindgen and wasmtime-wasi implementation

Scott Waye - wit-bindgen for C#

Steve Sanderson - experimental .NET WasmComponent.SDK

Taylor Thomas - naescent runtime-config proposal, wasm-tools component implementation

Till Schneidereit - many specifications, spidermonkey preview 2 implementation

Timmy Silesmo - wasmtime-wit-bindgen resources

Trevor Elliott - preview 2 implementations, wasi-http specification

Tyler Rockwood - wasmtime::component C API

Victor Adossi - wasm-tools component implementation

Wassim Chegham - jco implementor

Xinzhao Xu - specifications, wasi-libc

Yage Hu - testing and specifications

Yamamoto Takahashi - specification, wasi-libc

Yosh Wuts - wasi design, jco implementor

"
wasi/2019/WASI-10-15.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the October 15 in-person meeting of the WASI Subgroup

- **Where**: 10355 N De Anza Blvd, Cupertino, CA 95014, USA
- **When**: October 15, 1:00pm PDT
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

This meeting is open to WebAssembly CG members only. To register, please
visit the CG participants page:

https://www.w3.org/community/webassembly/participants

Also, the host for this in-person meeting has requested we provide a list
of attendees, so please email Dan Gohman if you plan on attending.

## Agenda items

The topic for this meeting is low-level WebAssembly APIs for
HTTP (servers and clients).

## Meeting Notes

Attendees:

Dan Gohman
Syrus Akbary
John Plevyak
Pitor Sikora
Alon Zakai
Mark Nottingham
Leif Hedstrom
Jorge Lopez Silva
Pat Hickey
Johnnie Birch
Roberto Peon

Meeting Notes:

Presentation: [Proxy-WASM: a “standard” WebAssembly interface for the data plane, Piotr Sikora, John Plevyak](https://docs.google.com/presentation/d/1QMGEuVD9p5iNbzxzgT4p2PXpxg1MjfSbpbJdw6g6Q_Y/edit?usp=sharing)
Resources:
[WebAssembly in Envoy](https://docs.google.com/document/d/1HLV35OZP0A_a8dVjDo4kwTsovDkaycS83ZLKFpG9W8Q/edit)

<Presentation>Described the envoy use case and then reviewed an API (logs, network, http, etc)

Dan: Is there a main function?
Piotr: No, there is no main. The module functions are the entry points

Dan: How is `__post_instantiate` used?
Piotr: It’s an initialization function which is called at Vm startup, which may live across multiple requests.

Dan: Does `proxy_set_effective_context` imply persistent state?
Piotr: That’s an ABI design question, it could work that way or by passing in the context to each call.

Roberto: Is there an api for caching
Piotr: Not at the moment. Not supported by envoy.
Roberto: What about streaming? What if the data you’re receiving is not in order?
Pat: We have a different proposal that addresses this.
Piotr: We don’t have an answer for this yet.

Syrus: Have you thought about using this proxy api on the client-side (browser, [via extensions](https://developer.chrome.com/extensions/webRequest)) as well?
Piotr: Our use case is not focused on that

Roberto: Are you thinking about having a Session abstraction in addition to Connection?
John: We don’t have it yet, but we may add it in the future

Jorge: Version management?
<discussion> limitations of current toolchains mean that the abi version is encoded as numbers in a function symbol name. But this can change as tools and standardization progress.
Pat: optional imports may alleviate some of the versioning problems too


Presentation: [“What HTTP Needs from WebAssembly”](https://github.com/WebAssembly/WASI/blob/main/meetings/2019/What%20HTTP%20Needs%20from%20WebAssembly.pdf), Mark Nottingham

Roberto: What about multiple headers with one name?
Mark: [paraphrase] we probably need to talk about that

Dan: Does this include DNS?
Mark: Yes, the API accepts names, and they are translated implicitly

Discussion of optional imports, which will be important as different use cases will need different parts of these APIs.
Spec: https://github.com/WebAssembly/WASI/blob/main/design/optional-imports.md

(general presentation of the people in the meeting)

Dan: Could you use this for general-purpose HTTP programming?
Mark: Yes, there are some features which are proxy-specific, but this could be used for clients and servers


Presentation: [WASI HTTP proposal](https://github.com/pchickey/wasi_http_strawman), Pat Hickey

John: This concept of futures doesn’t allow you to chain futures, right?
Pat: Yes, this is a difference from JS futures

Pat: This is a low-level API; most customers would be using higher-level libraries on top of this

John: This API allows you to decide what you want to poll for

Pat: The `future_close` function allows you to release resources

Roberto: How much would this API change if you had threads?
Pat: Our goal is mostly to have threads in the background, so that users don’t need to worry about them. But some users may want more threads in the future. We don’t have all the answers here yet.

Alon: The `request_new` function takes a string url; how does this relate to `path_open` which doesn’t support absolute paths?
Dan: That’s a good point; one possibility is to change this API to make URL access more capability-oriented
John: That enables nested sandboxing
Alon: This model entails some overhead. If every WASI API uses OCAP, it could add up

Action items:
Dan to post a skeleton Reactor design document
Dan to finish WASI modularization API
Pat to make a Futures proposal
John, Piotr, Mark. Pat to flesh out their API proposals offline and figure out next steps
"
wasi/2022/WASI-04-21.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: April 21 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: April 21, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. WASI interface for URLs (@kulakowski-wasm)
        1. More design overview
        2. Poll to advance to next phase
    2. _Sumbit a PR to add your agenda item here_

## Notes
### Attendees
- Lin Clark
- Till Schneidereit
- George Kulakowski
- Dave Bakker
- Nathaniel McCallum
- Andrew Brown
- Bailey Hayes
- Brian Hardock
- Dan Gohman
- David Yamnitsky
- Granville Schmidt
- Isabella Tromba
- Johnnie Birch
- Luke Wagner
- Mohamad Jaafar Nehme
- Piotr Sikora
- Radu Matei
- Sebastien Deleuze
- Syrus Akbary
- Yong He
- Sam Clegg

### wasi-url poll
**George Kulakowski:** proposal to implement wasi-url set of interfaces. Parsing given a base url, make a new url, accessors into those. Will follow WHATWG specification for URLs. Motivations are that URLs are a common and ubiq interface. Many components will want to use or provide URLs

Does anyone want to talk about anything before poll? 

**Sam Clegg:** Not really that involved with webby stuff. URL vs URI?

**George Kulakowski:** WHATWG takes position that URI vs URL has caused more confusion so they go with URL. URN is still a part of this spec. 

**Sam Clegg:** Sounds like it’s been decided.

**George Kulakowski:** WHATWG is starting point for this discussion. Would be interested in potential interop issues if they come up in the future, or crossing boundaries… if there’s ever been compat issues with that.

**Sam Clegg:** Prob too early to talk about this kind of stuff, but will you attempt to mirror the JS API?

**George Kulakowski:** Another good question. Right now, this is a starting point for other work. Having an interface at the boundary in WASI makes sense, but then you’d have implementations that go from interface you have to the intermediate representation. This is something we should address, but not in first version of this api.

**Till Schneidereit:** I implemented JS API using Rust’s implementation and there are clearly API differences between these two languages. That holds across different ecosystems. We’ll not be able to generate the expected API surface for all of these ecosystems. Given how URL is constrained, you don’t have much design space. A lot of the differences are cosmetic in nature. The adapter you have to do to go from abstract to lang idiomatic should be small.

One example where JS URL isn’t good general purpose design… there’s an accessor for part. That returns a string instead of a number. JS doesn’t have an option type, so if it isn’t set then would be null, which would coerce to 0. We’d probably go with option, and then to implement in JS you’d need a tiny bit of glue code.

**George Kulakowski:** Yes, I do think I mentioned this would err on the side of typed. Someone was asking about why not more closely hewed to browser. Using strings wouldn’t help because you still have to go to your native implementation.

**Lin Clark:** Any more questions?

Ok, consensus poll. Anyone object? [long awkward silence]

Great, we have a new API!

**Dave Bakker:** Is there a repo?

**Lin Clark:** I’ll be making a repo over the next day and then George will add what he has

**George Kulakowski:** That reminds me—anyway to signal to the group when there’s something that they should look at besides this meeting?

**Lin Clark:** Not right now, but we can look into that as a process improvement.
"
main/2018/CG-03-20v21.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 20/21 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: March 20, 6:00–7:00 UTC (March 20, 11PM–12AM Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

None required if you've attended before. Email JF Bastien to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Future in-person meeting: [hosted by Fastly in San Francisco in April](https://github.com/WebAssembly/meetings/blob/master/main/2018/CG-04.md)
    1. Should we meet at [TPAC](https://www.w3.org/2018/10/TPAC/Overview.html) 22 - 26 October 2018 in Lyon, France
    1. HTML serialization of WebAssembly.Module objects (Daniel Ehrenberg)
       * https://github.com/WebAssembly/spec/pull/711
       * Where should this be in the process?
    1. [Rename memory instructions](https://github.com/WebAssembly/spec/issues/627)
       * Using ""mem"": https://github.com/WebAssembly/spec/pull/649
       * Using ""memory"": https://github.com/WebAssembly/spec/pull/720
    1. [Mutable Globals proposal](https://github.com/WebAssembly/mutable-global) update
       * Implementation status?
       * [Add WebAssembly.Global.toJson](https://github.com/WebAssembly/mutable-global/issues/1#issuecomment-363955362)?
    1. [Sign-extension operators proposal](https://github.com/WebAssembly/sign-extension-ops)
       * Implementations status?
    1. Subcommitees? - Discussion
       * Would CG subcommitees be useful for some topics like:
          * Exceptions
          * ES6 Modules
          * CSP
       * Do we need anything formal or would informal work?
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes


### Opening, welcome and roll call

1. Opening of the meeting
1. Introduction of attendees

#### Roll call

* Arun Purushan
* Ben Smith
* Brad Nelson
* David Jonsson
* Deepti Gandluri
* Derek Schuff
* Eric Holk
* Heejin Ahn
* JF Bastien
* Limin Zhu
* Luke Wagner
* Maher Jendoubi
* Michael Ferris
* Michael Holman
* Oleksandr Skachkov
* Pat Hickey

### Find volunteers for note taking (acting chair to volunteer)

*JF volunteers*

### Adoption of the agenda

*Luke seconds*

### Proposals and discussions

#### Review of action items from prior meeting.

Skip.

#### Future in-person meeting

[hosted by Fastly in San Francisco in April](https://github.com/WebAssembly/meetings/blob/master/main/2018/CG-04.md)

[Register here](https://goo.gl/forms/UKV8HNnXGDbsvHmq2).

#### TPAC

Should we meet at [TPAC](https://www.w3.org/2018/10/TPAC/Overview.html) 22 - 26 October 2018 in Lyon, France

Yes, let’s do one day with the Working Group and invite CG members and other groups.

*AI*: JF to privately reply to [Coralie's email about this](https://lists.w3.org/Archives/Public/public-webassembly/2018Mar/0003.html).

#### HTML serialization of WebAssembly.Module objects

*Daniel Ehrenberg*

* https://github.com/WebAssembly/spec/pull/711
* Where should this be in the process?

*Punt to next meeting*

#### [Rename memory instructions](https://github.com/WebAssembly/spec/issues/627)

*Ben Smith*

* [Using ""mem""](https://github.com/WebAssembly/spec/pull/649)
* [Using ""memory""](https://github.com/WebAssembly/spec/pull/720)

Concern about “mem” versus “memory”, consistency, how descriptive, etc. Not very common opcodes. We might later add fill / zero / copy. Other instructions are already longer, and so are the section names.

Unanimous consensus to go with “memory”.

#### [Mutable Globals proposal](https://github.com/WebAssembly/mutable-global) update

*Ben Smith*

* Implementation status?
* [Add WebAssembly.Global.toJson](https://github.com/WebAssembly/mutable-global/issues/1#issuecomment-363955362)?

Now in beta Firefox, no bug report from users. Some issue with Emscripten with globals not being enumerable, when doing dynamic linking. Could add toJSON in the future.

Ben to work on mutable globals soon.

#### [Sign-extension operators proposal](https://github.com/WebAssembly/sign-extension-ops)

*Ben Smith*

* Implementations status?

Chrome implementation behind a flag. Also in Firefox in Nightly. There are tests in the proposal repo. Would be nice to have Emscripten implementation for just sign-extension (without threads). Could probably move to the next phase.

#### Subcommitees? - Discussion

*Brad Nelson*

* Would CG subcommitees be useful for some topics like:

  * Exceptions
  * ES6 Modules
  * CSP

* Do we need anything formal or would informal work?

We’re getting bigger features. Would it make sense to have optional CG meetings for people interested in these particular topics?

*AI:* JF to check with W3C what the process is, CC Brad and Eric Prud'hommeaux.

Do we want mailing lists? How do we organize? GitHub issues? Video chats? Sub-group chair (should those be the champions)? How do we establish charter for sub-groups? Notes, timing, other requirements?

#### Closure

"
wasi/2020/WASI-05-21.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the May 21 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: May 21, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Proposals and discussions
    1. Update on WASI repository reorganization and new proposal repositories
    1. New proposal: wasi-nn: Neural Network API
        1. https://github.com/WebAssembly/WASI/issues/272
        1. https://github.com/WebAssembly/wasi-nn
        1. Any initial feedback?
        1. Vote: Approve for Phase 1?

## Meeting Notes

Attendees:

Dan Gohman
Lee Campbell
Johnnie Birch
Andrew Brown
Mingqiu Sun
Piotr Sikora
John Plevyak
Mark Miller
Pat Hickey

Meeting notes:

Update on WASI repository reorganization and new proposal repositories

New proposal: wasi-nn: Neural Network API
https://github.com/WebAssembly/WASI/issues/272
https://github.com/WebAssembly/wasi-nn
Any initial feedback?
Vote: Approve for Phase 1?
MS: <presentation on WASI-nn>
MM: What is the intellectual property side of neural networks?
MS: The weights and the model constitute the intellectual property. By keeping the model outside of the primary source programming language and outside of the main wasm program state, intellectual property is better protected.
MS: We’re working closely with WebNN proposal
MS: We expect many different hardware architectures will implement backend support.
MS: Initial POC would target a CPU backend but future devices (GPU, FPGA, TPU) could also be supported.
MM: Intellectual property is a legal term; is there any attempt at legal protection of these weights?
MS: It’s hard to protect a model across a development and deployment workflow. Model authors want to ensure that their specific weights are protected. What this proposal says is, the model can be opaque. 
MM: So you’re not talking about legal protection, just about hiding the information?
MS: Yes, it’s mainly about confidentiality of the model.
MM: So since the questions that wasm would ask of the model through the API would expose information about the model, has there been any analysis?
MS: If you use a programmatic model to define weights it’s a lot harder to protect.
AB: <API presentation> 
AB: Showed the proposal: https://github.com/WebAssembly/WASI/issues/272
DG: Why explicitly expose the target instead of making it an implementation detail
AB/MS: Current thought is that it gives the developer more options.
MM: Could you refactor this to move the target enum into init_execution_context?
What happens if you ask for a target architecture and it isn’t available?
JB: Would it help to say that the target parameter is a hint?
<lots of discussion of the choice of execution strategy vs portability etc.>
AB: I agree; 99% of the time, what you want is just “pick the best one for me”
Open question: Web-nn exposes this target parameter; why do that do it?
AB: I’ll summarize this discussion in an issue.
AB: Let’s look at how we represent tensors next.
AB: Is there a better way to represent multi-dimensional arrays?

PH: You need a dynamic number of dimensions, and it’s hard to do that, especially with witx in its current form. 
DG: Does this definition give everything the implementer need to be efficient .. to change to the format needed?  Agree with Pat multi-dimensional support is a hard problem right now.
AB: We’ll learn more about the implementation concerns as we start prototyping this.
AB: How do we specify how to include dependencies?
DG/LC: The concept of optional imports may be useful here.
PH: Also have a PR for profiles that is a way to specify in witx dependencies.
DG: Have met the requirements for phase 1. Can vote.
LC: What happens if there is a fail?
AB: Have a mechanism to return error.
Vote: WASI-nn advance to phase 1
SF: 7
F: 5
N: 2

Vote succeeds.
"
main/2018/WG-02-28.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 28th video call of WebAssembly's Working Group

- **Host**: Google Hangouts
- **Date and Time**: February 28th, 2018 at 5pm-6pm UTC / *February 28th, 2018 at 9am-10am PT*
- **Time Date Link**: [Link](https://www.timeanddate.com/worldclock/fixedtime.html?msg=WebAssembly+WG+Meeting&iso=20180228T09&p1=224&ah=1)
- **Location**: *Brad will email Google Hangouts link to WG members + registered CG guests prior to the meeting*
- **Contact**:
    - Name: Brad Nelson
    - Email: bradnelson@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion on the process of branching + Working Drafts.
       * Do we accumulate all master changes into the next Working Draft?
       * When do we start new REC trains?
       * Context: https://github.com/WebAssembly/spec/pull/714
    1. Discussion on status of the Working Draft.
       * Appeal for more chapter [reviewers](https://github.com/WebAssembly/spec/issues?q=is%3Aissue+is%3Aopen+%5Bspec+review%5D+label%3Aeditorial)
       * Review of open issue:
          * https://github.com/WebAssembly/spec/issues
    1. Future meetings
       1. Confirm next meeting date + time.
       1. Handing of agenda for in person meeting.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Opening, welcome and roll call

* JF Bastien
* Sam Clegg
* Brad Nelson
* Kenneth Rohde Christiansen
* Jacob Gravelle
* Brad Nelson
* Andreas Rossberg
* Derek Schuff
* Michael Holman
* Eric Holk
* Michael Ferris
* Wouter van Oortmerssen
* Limin Zhu
* Luke Wagner
* Edgar Pek
* Peter Jensen
* Arun Purushan
* Deepti Gandluri

### Opening of the meeting

### Introduction of attendees

### Find volunteers for note taking (chair to volunteer).

Brad Nelson

### Adoption of the agenda

JF Seconds.

### Discussion on the process of branching + Working Drafts.
       * Do we accumulate all master changes into the next Working Draft?
       * When do we start new REC trains?
       * Context: https://github.com/WebAssembly/spec/pull/714

Discussion on versions, keeping several versions in flight.
When to hand the w3c new drafts.
Do we want to take new features?
What about non-trapping conversions?

Andreas: We should not let new features creep in.

Luke: For now we do the cherry-picking, but later it will be more mechanical.

Andreas: I'm not aware of any that are ready to be merged.

*Discussion*

Vague consensus is we treat v1 specially, we only land editorial / mvp fixes.
We'll sort out later when to start a v2 train.

### Discussion on status of the Working Draft.
       * Appeal for more chapter [reviewers](https://github.com/WebAssembly/spec/issues?q=is%3Aissue+is%3Aopen+%5Bspec+review%5D+label%3Aeditorial)

Got a few more owners for various chapters.

Discussion: Useful to have more exhaustive tests.

Luke: Core spec we've been assuming it's fairly good.

JF: Not in the test262 sense. I don't think we want to gate anything on it, not sure we want to block on it.

Andreas: The way the test suite is structured, there's mostly one file for each construct. There's some earlier tests that don't quite fit into that scheme. Within a single file it's hard to tell what any one test tests.

JF: Should we ask Dan?

Luke: Initially Dan is on the hook for JS + Web spec.

AI: bradnelson: open issue on making tests comprehensive.
https://github.com/WebAssembly/spec/issues/739


       * Review of open issue:
          * https://github.com/WebAssembly/spec/issues

Some triage of issues.

### Future meetings

       1. Confirm next meeting date + time.

March 14th - 11pm PST --- Brad to schedule.
[Brad managed to mix up weeks on this, will re-schedule for the following week March 21 at 11pm PT]

Upcoming in-person meeting:

	* Hosted by Fastly in San Francisco, Tuesday-Thursday April 10-12, 2018
* [Details](https://github.com/WebAssembly/meetings/blob/master/main/2018/CG-04.md)
* [Registration](https://docs.google.com/forms/d/e/1FAIpQLSe7o2joyHyjaRkDcDHBZs8Mc9VCMzhCHEKiqm-2xw4dSBRrTw/viewform) 

       1. Handing of agenda for in person meeting.
Tentatively Brad will add agenda items for sections at WG meeting.
Will start a redirect doc for WG part of the meeting.
"
process/inperson-meetings.md,"# In-person WebAssembly meetings

In-person meetings are organized typically 1-2 times per year, and are very
valuable for high-bandwith conversations and informal interactions between
participants.

## Attending in-person meetings

For in-person meetings, we request that attendees register in advance so that 
the host may plan capacity accordingly, and so that the meeting notes may
record who was present. 

The meeting invitation will contain logistics on location, time, address,
parking, nearby hotels, Wi-Fi, and host contact. This invitation will be sent
in advance of the meeting, through a pull request on the
[meetings repository](https://github.com/WebAssembly/meetings) as well as
through an email to the Community Group's mailing list.

All attendees are required to be members of the
[community group](https://www.w3.org/community/webassembly/) prior to attending.
The usual
[WebAssembly code of conduct](https://github.com/WebAssembly/design/blob/master/CodeOfConduct.md)
applies to in-person meetings as well as surrounding events and online
interactions.

## Hosting in-person meetings

Any organization can volunteer to host a WebAssembly meeting. Simply contact
[the chair](https://www.w3.org/community/webassembly/) or bring up the
possibility at a meeting.

It is the intent of this group to hold meetings where participants are located,
not just in the Bay Area. Meetings usually last 2 or 3 days, during working hours.

Locations should have the following characteristics:

* Near an airport, easily accessible from major travel hubs
* Near a hotel
* Meeting room sufficiently large to host 50 people
* A single-layered circle or square layout is ideal
* Telepresence/videoconference system accessible for remote participation
* Whiteboards and markers
* Bathrooms near the meeting room
* Accessible to people with disabilities
* Electricity to all seats
* Wi-Fi
* Presenter's podium with projector
* Area for attendees to step away for phone calls or meetings
* Provide light snacks and beverages throughout the day
* Have lunch options, paid or not, nearby
* Sensitive to dietary requirements, a vegan option is required

The host is expected to:

* Pay for the meeting location as described above (usually a single room,
  either in a company's meeting space, a hotel conference center, or
  academic institution's teaching room), including snacks and beverages.
* Provide travel information for attendees (airport, transportation options,
  hotel list, visa requirements). The host is not expected to pay for any of
  these, but can negotiate group rates.
* Commit to the dates sufficiently far in advance that attendees can secure
  any visas necessary for travel to the site.
* Be available during the meeting to help attendees get in and out of the
  location.
* Not require that an NDA be signed by attendees.

Optionally, the host can sponsor lunches, and/or organize a dinner; these
are sometimes sponsored by the host or a separate sponsor arranged by
the host. An RSVP may be required ahead of time.

A list of attendees will be provided to the host ahead of time.

## Day-of event process

### Agenda

The meeting invitation contains an agenda which will be updated through pull
requests in the days leading up to the meeting. Champions for individual
features are expected to provide details of their proposal in a timely fashion
so that attendees may review the material ahead of time. Champions are also
expected to provide a list of questions on which attendees will be polled for
[consensus](consensus.md). Some meetings may have an overall ""theme"" which
guides which proposals should be discussed in that meeting.

Attendees are expected to familiarize themselves with the proposals before the
meeting. It is not acceptable to stall the meeting due to lack of preparation.

### Notes

Notes are taken throughout the meeting by designated note-takers (who may
change throughout the day). Names of each participants, their affiliated company
/ institution, and what is discussed, are recorded in the notes. This
establishes where ideas came from, and how they came about. Before posting the
notes publicly to the meeting document, the notes are sent out to attendees to
verify correctness and allow clarifications. Notes are subsequently posted to the
meeting document.

[Consensus](consensus.md) is recorded in the notes."
main/2018/WG-01-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 11th video call of WebAssembly's Working Group

- **Host**: Google Hangouts
- **Dates**: Thursday January 11th, 2017
- **Times**: 9:00-10:00am Pacific Time
- **Location**: *Brad will email Google Hangouts link to WG members + registered CG guests prior to the meeting*
- **Contact**:
    - Name: Brad Nelson
    - Email: bradnelson@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Update from chair on First Public Working Draft.
    1. Discussion on tooling for the specification.
    1. Future meetings
       1. Meeting times + collaborators in Asia-Pacific
           * Discussion of meeting time logistics
           * POLL: We should hold every third video call at an APAC friendly time.
       1. Confirm next meeting date + time.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes
### Roll Call
* Brad Nelson
* JF Bastien
* Jacob Gravelle
* Peter Jensen
* Arun Etmr
* Wouter van Oortmerssen
* Heejin Ahn
* Andreas Rossberg
* Thomas Nattestad
* Luke Wagner
* Ben Titzer
* Derek Schuff
* Mark Miller
* Sam Clegg
* Richard Winterton
## Agenda Items
 
### Find volunteers for note taking (chair to volunteer).
Brad to take notes.
### Adoption of the agenda
JF seconds.
### Update from chair on First Public Working Draft.
Brad ran into challenges w.r.t. the W3C-expected format of the draft. They even have a formatting verifier tool. The two portions of the spec in bikeshed are fine, but the core spec using sphinx is not. Brad wrote some scripts to massage some stuff from sphinx to bikeshed. Needs to be a single page. MathML makes things terrible because of MathJax (except in Firefox).
Long-term we could get dispensation from the W3C, or use something other than MathJax, or break the document appart (which bikeshed doesn’t support at the moment).
Brad is asking if members are comfortable moving forward with a somewhat broken document to start the first document publication, and fix it later as an editorial issue. This will look bad as a first impression.
Tab thinks he’ll be able to get the [offline katex](https://github.com/Khan/KaTeX#server-side-rendering-or-rendering-to-a-string) translation by Q1.
Other option is to chop things into sub-parts instead of rendering as a single page. Some specs do this with custom bespoke scripts which are not general and might break our spec at the wrong places.
	
Kenneth Rohde Christiansen	9:14 AM
Finally joined as I didn't notice the spelling mistake in the invite URL (assemly instead of assembly)
Conrad Watt joined group chat.
	
Kenneth Rohde Christiansen	9:21 AM
Why not just render the mathml when it becomes visible?
https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
But in that case you could turn it into web components and set contain: strict via CSS - to avoid reflow or repaint etc
the elements might still resize but setting default sizes can avoid that
info: https://developer.mozilla.org/en-US/docs/Web/CSS/contain
In retrospect Andreas would use straight Latex over markdown (usability, scalability).
### Discussion on tooling for the specification.
See above.
### Future meetings
       1. Meeting times + collaborators in Asia-Pacific
           * Discussion of meeting time logistics
           * POLL: We should hold every third video call at an APAC friendly time.
       1. Confirm next meeting date + time.
Brad suggests a month from now. We could meet at 11PM PST (7AM UTC next day) every third meeting, like the CG does, to be friendly to APAC.
Andreas suggests we could use a half-day of the CG meeting for WG business.
JF suggests splitting up the document in parts, and having groups go over the wording line by line.
1. Closure
"
main/2018/CG-05-29.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 29 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: May 29, 4pm-5pm UTC (May 29, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email JF Bastien or Ben Smith to sign
up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. POLL: move [sign-extension ops proposal](https://github.com/WebAssembly/sign-extension-ops) to phase 4.
       * Implemented in FF and Chrome (others too?)
       * Spec and reference interpreter implementation complete
       * Core tests added
       * Toolchain support (status on separate flag from thread support in emscripten?)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Roll call

* Andreas Rossberg
* Ben Smith
* Ben Titzer
* Dan Ehrenberg
* Dean
* Deepti Gandluri
* Derek Schuff
* Heejin Ahn
* Jacob Gravelle
* JF Bastien
* Lars Hansen
* Limin Zhu
* Lin Clark
* Luke Wagner
* Mark Miller
* Michael Holman
* Mike Rourke
* Sam Clegg
* Sergey Rubanov
* Sven Sauleau
* Tyler McMullen
* Ulrik Sorber
* Yury Delendik

### Opening, welcome and roll call

### Find volunteers for note taking

*JF Bastien volunteers*


### Adoption of the agenda

### Proposals and discussions

#### Review of action items from prior meeting

* TAG issue: secure context for WebAssembly: Dan was waiting to hear from Brad and Luke.

Luke: Still considering whether it... it seems like it should be in the MVP. What’s the future of this feature, is it partially implemented. Still discussing whether to remove. 

Dan: Not sure what to ask TAG since they suggested that group should decide.

Luke: There’s also the secure context blog post statement from Mozilla .... there won’t be a directive from Mozilla on high to slice into different flag bits. I wouldn’t spend time on that issue. We may have zero secure context issues at some point.

JF: It still would be useful to have guidance from TAG.

Dan: Not sure what TAG will say.

JF: If we’re OK with going with that, we can close out the issue.

Dan: I don’t know what to ask them, or what guidance they’ll give.

JF: When I’ve talked to TAG people they felt left out in the past, but now that we ask they’re not giving guidance... I want to avoid a situation like we’ve had in the past where we go in the wrong direction.

AI Dan: I’ll figure out what to do about indexeddb and modules.


* Implementation limits: Ben Titzer updated.

Ben: Posted an issue on GH last week.

Andreas on type reflection for JS API: anyone want to help push it forward? Probably won’t work on it soon.

Luke: at some point in the future, I will be. Not at top of priority list yet.


#### Sign-extension ops


* Implemented in FF and Chrome (others too?)
* Spec and reference interpreter implementation complete
* Core tests added
* Toolchain support (status on separate flag from thread support in emscripten?)

Derek: Flag is in LLVM, not sure it’s in emscripten yet

Ben: probably shouldn’t hold up the proposal. Lars pointed out that we can move it to phase 4 so it can be shipped.

Andreas: still concerned about naming convention

JF: phase 4 is more for VMs than text format

POLL: move [sign-extension ops proposal](https://github.com/WebAssembly/sign-extension-ops) to phase 4.

*Unanimous consent*

"
wasi/2022/WASI-02-24.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: February 24 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: February 24, 17:00-18:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. Poll: Advance wasi-sockets to Phase 1 ([Slides](presentations/2022-02-10-bakker-sockets-and-address-lookup.pdf) were presented at 02-10-22 meeting)
    1. _Sumbit a PR to add your agenda item here_

## Notes
### Attendees
- Lin Clark
- Dave Bakker
- Radu Matei
- Vibhav Pant
- Chris Suszynski
- Steven Prine
- Till Schneidereit
- Dan Gohman
- Granville Schmidt
- David Piepgrass
- Yong He
- Andrew Brown
- Mohamad Jaafar Nehme
- Johnnie Birch
- Mingqiu Sun
- Piotr Sikora
- Syrus Akbary
- Mossaka
- Sdavies
- David Justice
- Luke Wagner
- Bailey Hayes
- Brian Hardock
- Ralph Squillace
 
### Poll: Advance wasi-sockets to Phase 1
**Till Schneidereit:** One question, what are your plans for how to proceed on working on it given that there’s a whole bunch of separate proposals. 

**Lin Clark:** Poll today is just about wasi-sockets

**Chris Suszynski:** Is this proposal including DNS?

**Dan Gohman:** The dns proposal here is a synchronous API designed to line up with the libc

**Dave Bakker:** not direct mapping to libc

**Dan Gohman:** My sense is that this api makes sense accompanying sockets. Doesn’t need to be the only DNS api. DNS has lots of options, dont’ need them for every use case

**Dave Bakker:** The address resolve API is indeed just the basics so it usually only goes to the localhost file or A records, so it’s not really a DNS api. DNS is a separate module

**Chris Suszynski:** Complicated because there are NS switch, so you can have various backends to the file. So there’s a couple of APIs in the system. So I was thinking about it and I think even stripping out the DNS would make it simpler. You could of course connect to DNS by IP and port and resolve what you want to do from there. Even if we just provide the sockets, it’s also satisfactory for most of the applications because the routing should be done by the host. We could provide DNS support in the future.

**Dave Bakker:** Current proposal doesn’t include DNS in scope, can be backed by DNS optionally.

**Lin Clark:** Need to be answered before poll?

**Vibhav Pant:** Let’s say if we do have DNS component in the API and there are other services that resolve, we aren’t mandating that they resolve through that particular component, right? I’m thinking about how Go would provide a network API. So those implementations are free to use anything else to resolve names?

**Dave Bakker:** Yes. There are multiple paths forward. You can imagine a wasi module for DNS resolution itself, or you could just use the sockets API to create your own DNS server.

**Vibhav Pant:** So if an engine were to find ways to limit what domains or networks they could call into, then just 

**Dave Bakker:** Just having access to sockets doesn’t mean you can access the whole world. Even when you have access to sockets, the engine must somehow provide you access to specific endpoints. 

**Vibhav Pant:** So it’s up to the engine to ensure that everything passes through the same point.

**Dave Bakker:** correct

**Lin Clark:** Any other questions? Ok, ready to poll. Will do a consensus poll. Anyone object to wasi-sockets moving to phase 1?

No objections, wasi-sockets moves to phase 1
"
main/2017/CG-12-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 12th video call of WebAssembly's Community Group

- **Host**: Google Hangouts
- **Dates**: Tuesday November 12th, 2017
- **Times**: 9:00am–10:00am Pacific Time
- **Location**: *same Google Hangouts link as before*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

None required if you've attended before. Email JF Bastien to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Require custom sections after all known sections (Ben Smith)
       * See [WebAssembly/design/issues/1153](https://github.com/WebAssembly/design/issues/1153)
       * POLL: Should we specify that custom sections must come after all known sections?
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

1. Mozilla people won't be in attendance due to conflict with Mozilla event.

## Meeting notes

### Roll Call

* Ben Smith
* Ben Titzer
* Brad Nelson
* Daniel Ehrenberg
* Derek Schuff
* Eric Holk
* Heejin Ahn
* JF Bastien
* Jacob Gravelle
* Keith Miller
* Michael Ferris
* Michael Holman
* Paolo Severini
* Pat Hickey
* Richard Winterton
* Sam Clegg
* Sergey Rubanov
* Tomas Nattestad

### Opening

#### Adoption of the agenda

Derek seconds.

#### Find volunteers for note taking (acting chair to volunteer)

### Review of action items from prior meeting.

No meeting until next year.

As voted on last CG video call, the first 2018 meeting will be at APAC friendly
time: 9th January, 11PM Pacific Time. This should also be a decept time for
Europe folks. If this works well we'll keep every third meeting on that pace.

### Discussions

#### Require custom sections after all known sections

*Ben Smith*

See [WebAssembly/design/issues/1153](https://github.com/WebAssembly/design/issues/1153)

We currently can round-trip many things in the text format. One of the things we can’t are custom sections. Not just their order, but their data as well. Similar issue with `$` in text format. Talked about having annotation format, but ultimately not really a nice way to say where custom sections should go. Luke suggested we should just have all of them at the end of the file, which everyone does anyways. Technically a breaking change, but we don’t think anyone generates these sections not at the end.

* Brad: in time I’m worried we’ll use custom sections with hints or something that would be better in the middle. We could experiment with a new type of section this way, and standardize later.
* Dan: I don’t really see contradiction with banning now, and trying to experiment later.
* JF: even with evergreen browsers, changing this to allowing only at end, and then back later to anywhere would be tricky. Some binaries would be invalid.
* Derek: I’m mildly against.
* Ben Titzer: same here.
* Ben: how important is it to round-trip? We’re close.
* Derek: we could specify some ordering in the text format.
* Eric: how do we do custom sections today?
* Ben: we don’t.
* Derek: we could write a counter-proposal.
* Ben: I have a basic proposal in the github issue. “This custom section goes after *this* known section”.
* JF: do we foresee known sections being duplicated?
* Derek: maybe, with say multiple memories we could do multiple data.
* Ben: I think it would be worthwhile to not do that.

**AI Eric Holk** mention “hint” section usecase on github.

**AI Ben Smith** write counter-proposal on github.

**POLL: Should we specify that custom sections must come after all known sections?**

*Postponed to next meeting.*
"
stack/2020/SG-11-30.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 30th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**: November 30th, 17:00-18:00 UTC (November 30th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)

## Participants

    Francis McCabe
    Michal “phoe” Herda (PH)
    Ross Tate
    Zalim Bashorov
    Andreas Rossberg
    Daniel Hillerström
    Alon Zakai
    Derek Schuff
    Ioanna Dimitriou
    Luke Wagner
    Paul Dworzanski
    Thomas Lively
    Heejin Ahn
    Sam Lindley
    KC
Petr Penzin


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. Control Flow in Common Lisp aka Why Lisp Doesn't Need To Throw Exceptions (Michał ""phoe"" Herda) [35 mins]
   
        [PDF](presentations/2020-11-30-herda-control-flow-in-common-lisp.pdf)
        
   1. Call for presentations [10 mins].
1. Closure

### Adoption of the agenda

## Meeting Notes

PH: “We need means of unwinding stack and we need finally blocks”

PH: six primitives for control flow in LISP: if & tagbody/go & block/return from & catch/throw

PH: CL is compiled to byte/native code

PH: CL ANSI standard 1994

FM: What happens when cleanup throws or does a non-local exit?

PH: Clean up code may throw or perform a non-local exit.

RT: Are you planning on illustrating that return-from can do non-local control flow, not just local branches?

PH: Yes.

SL: What happens if bar has already returned and is no longer on the stack?

PH: Signals a CONTROL-ERROR

RT: One more thing: If there were multiple calls to bar on the stack, it doesn’t necessarily go to the most recent one, right?

PH: Each instance on the stack creates a new association between the block and the corresponding return-from, so it may not be the most recent on the stack.

FM: Can return-from take a variable?

PH: No, the return-from target must be a static name.

FM: Question about static target of return-from. How is that typically implemented?

PH: (Explanation on slides 204-209) Compiler generates a variable to track whether the target frame is still on the stack. The implementation of return-from checks that variable before starting the unwind.

RT: confirms understanding

FM: One of the differences between WebAssembly and normal programming languages: if we had something like `%1-phase-unwind-to-tag`, it would be unsafe because we can’t guarantee that the code to guard the unwind is generated correctly.

… discussion …

FM/AR: Wasm has to run in a hostile environment. Have to protect embedder from malicious Wasm.

LW: IIUC, there is a reference that might live longer than its associated block. Are there other use cases you’ve seen for that?

PH: These guard variables are typically allocated on the heap...

LW: One way of doing a search phase we’ve discussed is using stack inspection, but if we had this sort of reference to data on the stack, we could also use that to do the first phase.

RT: There’s another complication: The soundness of the validity tag check depends on the fact that the checking code is on the same stack as the frame it is checking the existence of.

PH: If we create a new stack that just contains CL frame information…

RT: If we had these stack reference values, we would need to reason about what stack they reference in the type system (in a future with multiple Wasm stacks).

AR: This may need ??? because Lisp has closures.

PH: Yes, the Java implementation similarly uses objects to close over things similarly. I don’t know how this would be represented in WebAssembly.

SL: I was hoping you would show resumable exceptions.

PH: We are out of time, but there is information on that in the video I shared.


### Closure

"
debugging/2020/debugging-11-12.md,"# Meeting notes for the November 12 video call of WebAssembly's debugging subgroup

- **Where**: zoom.us
- **When**: November 12, 11am-11:30 Pacific Standard Time (19:00 UTC, 20:00 CET)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Derek Schuff
    - Email: dschuff@google.com
    
## Attendees
Yury Delendik, Luke Imhoff, Philip Pfaffe, Derek Schuff, Paolo Severini, Wouter Van Oortmerssen, Alon Zakai 

## Notes 
(Discussion summary)

We discussed how to handle wasm's memory64 extension in DWARF 
(recent context in LLVM changes https://reviews.llvm.org/D90503 and https://reviews.llvm.org/D91203).
Memory64 in wasm uses 64-bit data/memory indices, but 32-bit table indices and 32-bit values in the
binary for section offsets; and as in wasm32 there is no way for a program to explicitly refer to an 
instruction inside of a function. DWARF however does refer directly to instructions in the code section,
e.g. in `DW_AT_low_pc` attributes describing PC ranges, and some (but not all) other cases which encode
values using the `DW_FORM_addr` form. (And, the wasm64 ABI uses 64-bit function pointers to match data pointers).
In principle, DWARF attributes which refer to instructions in the binary could always use 32-bit values, while
attributes referring to functions or function pointers could match the size of the pointer used to compile
the program (64 when using memory64, 32 otherwise). Alternatively instruction-pointing attributes could always
be 64-bit, or could always match the size of data and function pointer.

This issue also becomes more interesting when considering the possibility of wasm modules having multiple
memories of different sizes. In that case, data pointer sizes would be different in different memories,
even in addition to the other possible mismatches. This is allowed by the wasm standard, and is potentially
useful, so we would probably not want to ban it in the standard. It probably can't currently be
generated by LLVM or linked by lld, but might potentially be in the future (e.g. LLVM currently allows
modules to have multiple address spaces of different sizes, which might transform straightforwardly
into a wasm module with multiple memories; and an extension to the linking convention might allow
lld to link such modules). However it's not clear what DWARF would look like for such modules, (e.g. 
whether or how DWARF could express it), nor how easy it would be to make producers and consumers
use it. Even for use cases that we currently imagine (e.g. tooling such as sanitizers), the memory
uses would be generated by tooling and the secondary memories would not contain user values that
dwarf would describe.

Currently the DW_AT_low_pc attributes are encoded with 32 bits even on wasm64 (the first alternative above).
Aside from matching the structure of the binary encoding most closely, it also has the advantage that
the proposed Binaryen pass for lowering memory64-using modules to MVP modules would not need to modify
the debug info. However there are likely other places in the current encoding
where we are using 32 bits where we should be using 64. More generally, there are likely to be
assumptions in current LLVM-ecosystem components (LLVM codegen, lldb, and lld) that instruction pointer
sizes would match the ABI function pointer size and possibly the data pointer size. Also the DWARF
address size matches the value size of the DWARF expression stack, so using an address size smaller
than the function pointer size could result in expression evaluation errors (e.g. overflows).
Fixing all of that would be an unknown but potentially large amount of work.
So it seems expedient for now to make all the dwarf address sizes match the C ABI pointer size.
In the future we may still face the multiple-memory problem and want to revisit some of these
tradeoffs.
"
benchmarking/2024/benchmarking-06-28.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for June 28th of WebAssembly's Benchmarking Subgroup

- **Where**: Google Meet
- **When**: June 28th, 4pm-4:45pm UTC (8am-8:45am PDT, 11am-11:45am EST)
- **Location**: _Link on calendar invite_
- **Contact**:
    - Name: Petr Penzin, Saúl Cabrera
    - Email: penzin.dev@gmail.com, saul.cabrera@shopify.com


### Registration

If this is your first time attending, please [fill out the registration form](https://forms.gle/QCmhyM4QwvWvZR9b8) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

### Logistics

This meeting will be a Google Meet video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes
    1. Please help take notes.
1. Announcements
1. Proposals and discussions
    1. Wasm R3: Record Reduce and Replay for Realistic and Standalone
       WebAssembly Benchmarks (Doehyun Baek)
1. Closure

## Meeting notes

### Attendees

- Andrew Brown
- Benjamin Titzer
- Daniel Lehmann
- Doehyun Baek
- Johnnie Birch
- Petr Penzin
- Tom An

### Notes

DB presenting {Wasm-R3}(https://docs.google.com/presentation/d/1Ai8R_yZ-_EDE10I_FItXI8ggPQ96U_1Lzve_Jfm5KPU/edit?usp=sharing)

AB: How to understand the slide on replay overhead - is the proportion comparing to original run time

BT & DB: Grey portion is the original application execution, red is the overhead, total wall clock is not necessarily the same

AB: Can I see what is the ratio between original and instrumented runtime from this chart?

DB: No, and it is quite hard to judge that given the set up required

BT: Because there is a whole Web app driving the Wasm execution, it’s not possible to know that level of detail. Keep in mind that the replay functions are simulating the Web event loop and driving Wasm execution frame by frame.

DB Showing a live demo, funkykarts

AB: How large is the trace file?

DB: In this case it is 33 MB, but it can be large, and we can run the same instrumentation on WebKit, Chromium, and Firefox

JB: What are you doing with those files?

DB: Captured replay trace is used to replace interactions with imports, which is added to the unchanged code of the original module.

JB: Can this be used to identify hot spots?

DB: We are preserving original code, it would exhibit original behvior

PP: I think this is useful for debugging in general

JB: How does this work for code that has host dependencies?

DB: We only record changes to observable state of Wasm but not where that is coming from.

BT: Recording detects changes by comparing externally visible state with a private copy, that is the level of detail it captures.

AB: How to tell how much time replay functionality is taking vs original code?

DB: We used Wizard’s functionality for tracking cycles counts and annotated replay functions, this would be engine-specific.

AB: meaning we need to profile running replay?

DB: yes

BT: There is also machine cycles vs wasm instruction count. We are also working on static optimizations to improve replay.

AB: How much standalone engines care about running apps that are recorded on the Web?

BT: This would work on any host environment in terms of both recording and replaying

PP: This would be a good way to check how code that already runs in one environment would behave in another one 

BT: Also useful for applying optimizations to Wasm execution only (in engines)

AB: Still wondering how creating a corpus of these benchmark would work across different environments

PP: For example the video game demo when stripped of all the graphics is just compute, which is basic physics, I think this is useful to run in any engine

DB: code repo: https://github.com/jakobgetz/wasm-r3
"
gc/2021/GC-01-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 12th video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: January 12th, 5pm-6pm UTC (January 12th, 9am-10am Pacific Standard Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Presentation: (Un)decidability of bounded quantification [Ross Tate] (1 hr)
1. Closure

## Meeting Notes

### Introduction of attendees

 - Thomas Lively
 - Francis McCabe
 - Ross Tate
 - Sergey Rubanov
 - Conrad Watt
 - Ben Titzer
 - Tim Seenvoorden
 - Asumu Takikawa
 - Paulo Matos
 - Rick Battagline
 - Daniel Wirtz
 - Adam Klein
 - Emanuel Ziegler
 - Jakob Kummerow
 - Ryan Hunt
 - Wouter van Oortmerssen

### Presentation: (Un)decidability of bounded quantification [Ross Tate] (1 hr)

Slides: [(pdf)](presentations/2021-01-12-tate-un-decidability-of-bounded-quantification.pdf) [(pptx)](presentations/2021-01-12-tate-un-decidability-of-bounded-quantification.pptx)

Non-terminating example

BT: Doesn’t this non-determination mean you’re missing a rule? If you add a new axiom to decide one way or another, then you’re all set, right?

RT: That would require an infinite set of rules that may or may not be computable.

BT: There’s no small set of rules that could fix it?

RT: No. Will show a more complex example shortly.

F<= As a register machine

CW: Is there anything meaningful about nominal / structural types here?

RT: If you have a nominal type, it behaves as a counter that gets smaller on each proof step. So the nominal type bounds how long the proof can go on.

CW: If you plunk nominal types in then everything works out, then?

RT: Will have a slide on that shortly.

Inheritance and generic methods

RT: Does that answer your question?

CW: Not quite but it’s a good example. If you had a language with reified generics, …

RT: You need to validate this kind of inheritance (or insert casts everywhere).

CW: In e.g. Kotlin the types are erased before reaching WebAssembly, this wouldn’t matter. So this would matter more for something like C#?

RT: Right.

FM: Why does erasure matter?

CW: If the types are erased before WebAssembly, then you must be ok using casts everywhere and you’re not encoding these relationships in WebAssembly’s type system.

Writing to Java/C#/Kotlin Arrays

CW: Bartok compiler uses this encoding. Are there other examples?

RT: I believe Bartok is the only one that represents the full language with a typed assembly language.

F<= is too weak

CW: Are these strong rules meant to avoid needing explicit pack/unpack operations?

RT: Pack and unpack operations would not be sufficient to demonstrate the subtyping in this case. Work on representing Java with structural low level types could not support covariant arrays due to these issues.

End

TL: What would you say the biggest takeaway from this is for the GC work?

RT: We will need to stratify the type system between structure and high-level invariant if we want to support cast-free arrays.

TL: Any studies on performance impact of cast-freedom?

RT: Only the ones Jakob has done. Folks haven’t explored the space of having some casts typed and others untyped like we’re doing in WebAssembly. Other systems reason about user casts as well as implicit casts.
"
wasi/2024/WASI-03-21.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: March 21 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: March 21 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Joel Dice: Proposal to add TLS interface to `wasi-sockets`
    2. WASI Embedded Ecosystem Introduction and Requirements - Discussion (15 - 20 mins)

## Notes

### Attendees

- Bailey Hayes
- Luke Wagner
- Colin Murphy
- Friedrich Vandenberghe
- Dave Bakker
- Kevin Moore
- Marcin Kolny
- Hung-Ying Tai
- Stephen Berard
- Yong He
- Merlijn Sebrechts
- Dan Phillips
- Zalim Bashorov

### Proposal to add TLS interface to wasi-sockets

**Joel Dice**: https://docs.google.com/presentation/d/1C55ph_fSTRhb4A4Nlpwvp9JGy8HBL6A1MvgY2jrapyQ/edit?usp=sharing

**Joel Dice**: 
TLS: Transport Layer Security (AKA SSL)
Wasi:sockets is a part of WASI 0.2
TCP and UDP (client and server)
DNS client
Vision: Bring your own DB/RPC/messaging/etc libraries. 
Goal: 80% compatibility with most client libraries
Problem: Most modern libraries and apps that use sockets also use TLS, which WASI does not (yet) support
WASI Python does not include SSL module
Option 1: Compile a TLS lib to Wasm (ex. openssl-wasm)
Pros: works today
Cons:
Vulnerable to side channel attacks
No CT WASI yet
No hardware acceleration
Statically linking TLS/crypto libs is problematic, ie requires labor intensive updates
Option 2: Use wasi-crypto
Pros:
Addresses side channel attacks
Can be hardware accelerated
Cons:
Unlikely to happen
Modifying OpenSSL, etc to use it is impractical
Lots of work, requiring special expertise
Not supported by upstream maintainers -> likely requires forking
Static linking still awkward
Option 3: Define a WASI interface for TLS
Pros:
Addresses side channel attacks
Can be hardware accelerated
No static linking, since host provided
Less work than option 2
Cons:
Libraries using OpenSSL directly would need to be ported (like almost everything in WASI)
More work than option 1
Proposal: wasi:sockets/tls
API modeled after Rust’s native-tls crate
Higher level of abstraction than wasi-crypto
Rationale:
Portable from a host implementation perspective
Nicolas Devillard: MbedTLS might be worth looking at https://github.com/Mbed-TLS/mbedtls


### WASI Embedded Ecosystem Introduction and Requirements

**Chris Woods**:
Requirements:
Continued WASI-Preview 1 Support
WASI-SDK tooling
WIT -> WITx
Threading, Sockets /Networking
Validation of the Component Model for Embedded Systems
Reliable and deterministic
Performance equivalent to P1
Embedded Innovation
I2C /GPIO/ SPI Interface definition
Multiple memories
There are millions of individual devices running WAMR
Amazon, Xiaomi, etc
Hardware -> RTOS -> WAMR -> Wasm applications
All but wasm applications are locked in due to embedded hardware lifecycle, especially for safety critical systems
WASI/WASM sits in a sweet spot between 340kb - 16 mb. Docker dominates above 16mb.
NFRs: Component model raises concerns about:
host to wasm latency
Unnecessary memory copies
Unnecessary data transformations
No embedded runtime for Preview 2.
Need: wit -> witx bindings so that WAMR can be used
Need: backport of preview 2 networking interface

### I2C implementation

**Friedrich Vandenberghe**
https://github.com/Zelzahn/i2c-wasm-components
Running implementations
https://crates.io/crates/wasi-embedded-hal
https://github.com/Zelzahn/wasi-i2c

"
simd/2023/SIMD-11-03.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 3 video call of WebAssembly's SIMD Subgroup

- **Dates**: 2023-11-03
- **Times**:
    - 4pm-5pm UTC (9am-10am PDT)
- **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this [form](https://forms.gle/Ynp2QiF3TN9YBoKz5) to attend.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking
1. Adoption of the agenda
1. Proposals and discussions
    1. Relaxed SIMD phase 4 update
    1. Flexible vectors follow up (https://github.com/WebAssembly/flexible-vectors/issues/60)
        1. Finding home for partial implementation
        1. Update on the longer SIMD performance collection and upcoming presentation
    1. BLAS in Wasm SIMD (if time permits)
1. Closure

## Meeting notes

_Note:_ we had some issues transferring the invite and lost a few people in the process, this will be fixed next time.

### Attendees

Anton Kirilov
Andrew Brown
Richard Winterton
Yury Delendik
Jan Wassenberg
Petr Penzin

### Flexible vectors

PP: presenting [slides](https://docs.google.com/presentation/d/19Rpz0qYJN2Lb5R98SyOQ-q2nVpuvvJUVoa5Ckh8vhOA/edit?usp=sharing)

JW: simpler lowering comparing to what

PP: comparing to using another fixed length, also in terms of virtual instruction set complexity

AK: some workloads might benefit from known length

PP: yes, text processing for example

JW: even in cases that would benefit from fixed length it is possible to get speedup with flexible approach, even if it is a smaller speedup

AB: maybe write a gemm example

AK: even if it is not the most optimal code, it might be better than the alternative

RW: should be careful about claiming that _always_ getting gains

AK: Even the ‘worse’ cases there will be some subcases that would definitely benefit from it. I am in favor of this proposal

#### Sample implementation

AK: we have draft of how most of the operations in flexible vectors can be implemented on AArch64 and are looking for a place to host it

PP: one option is to just put a doc into the repo, but if we want to be able to run it, we can try things like wasm2c or wasmtime, since I remember that someone from Arm started working on a prototype in wasmtime

AK: we stopped working on wasmtime, prefer to work on V8. Now that I think about, maybe some form of documentation would be better at this point

PP: that has been a running theme with SIMD proposals, that we need something like a ‘developer manual’ where these kind of details would be kept

YD: how we are going to measure this?

PP: a bit of chicken and egg problem, phase 2 is not yet full implementation phase. For phase 2 presentation we are mostly exploring benefits of longer simd/vector operations, but for a prototype in an engine we are thinking of creating some simple kernels first

AK: we are just looking at this theoretically, to describe what can be a reasonable lowering

PP: Another aspect is ‘developer manual’: there is basic cost, and different ways to present that, and the optimization aspects, some of that is important for standard SIMD as well

AK: I can think about a class of operations like that would benefit from optimization

YD: on subject of prototyping, we are considering implementing Flexible Vectors instead of re-vectorization

PP: great let’s discuss

AK: note that I’ve opened an issue about shuffles

PP: thank you for raising that, I’ve taken a look, but haven’t responded yet, though the suggestion looks reasonable

### Relaxed SIMD phase 4 update

PP: at in-person meeting it appears that Relaxed SIMD passed to phase 4
"
gc/2020/GC-12-15.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 15th video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: December 15th, 5pm-6pm UTC (December 15th, 9am-10am Pacific Standard Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Presentation: (Un)decidability of Java (Ross Tate) [1 hr]
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Ross Tate
- Wouter van Oortmersson
- Asumu Takikawa
- Pierre Chambart
- Paulo Matos
- Francis McCabe
- Conrad Watt
- Léo Andrès
- Rick Battagline
- Luke Wagner
- Ioanna Dimitriou
- Igor Sheludko
- Zalim Bashorov
- Jakob Kummerow
- Ryan Hunt
- Emanuel Ziegler
- Keith Miller
- Slava Kuzmich

### Presentation: (Un)decidability of Java (Ross Tate) [1 hr]

Slides for Type Recursion and (Un)Decidablity: [(pdf)](presentations/2020-12-15-tate-type-recursion-and-un-decidability.pdf) [(pptx)](presentations/2020-12-15-tate-type-recursion-and-un-decidability.pptx)

[On Decidability of Nominal Subtyping](https://repository.upenn.edu/cgi/viewcontent.cgi?article=1714&context=cis_papers) by Kennedy and Pierce, 2006

<RT presenting>

FM: If you have a disjunction and one of the disjunctions is undecidable, it’s not necessarily undecidable on the whole.

RT: Yes, the paper goes into details.

KM: In the “or”, why does it always start at the first string?

RT: That’s the string that is found so far and we are potentially adding more.

FM: There’s a closed world assumption here that these are all the subtyping relations ships.

RT: Yes. We have multiple instantiation (implementing the same interface multiple times with different type arguments).

PC: This seems to require only one direction of variance?

RT: Yes, only needs contravariance. Covariance and invariance can be implemented in terms of contravariance.

[Java Generics are Turing Complete](https://kar.kent.ac.uk/58183/7/javats.pdf) by Grigore, 2017

CW: Previous result replied on contravariance + multiple instantiation inheritance. Does this second proof refine that result or does it require additional Java mechanisms?

RT: Yes, this only needs contravariance + single instantiation inheritance. Java has other mechanisms that cause additional decidability issues.

CW: Expansive-recursive types are not the same as equi-recursive types?

BT: In nominal subtyping, you can’t have a recursive interface inheritance but in structural subtying you can, so this doesn’t seem to be an if-and-only-if?

RT: Only for those particular structural types that encode the nominal types.

[Getting F-Bounded Polymorphism into Shape](https://www.cs.cornell.edu/~ross/publications/shapes/shapes-pldi14.pdf) by Greenman, Muehlboeck, and Tate, 2014

LW: One aspect of structurality is that no one has to “own” a type. That seems separable (and desirable) from which types are subtypes of other types. Are these separable?

RT: The issue is -- there are lots of notions of isorecursion -- Given two isorecursive systems, you have to figure out whether they correspond to each other. Not sure how decidable that is.

LW: So it is not a priori undecidable!

RT: You don’t want to derive information from the structure.

LW: Yes, I can see that trying to derive information from the structure is where things get undecidable.

RT: There is investigation into this space, but I haven’t seen a convincing proof yet. Even if it is possible, it is certainly complicated. More complications coming next week that make these tricks work less well.


"
gc/2021/GC-04-20.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 20 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: April 20, 4pm-5pm UTC (April 6, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Equirecursive Types in Binaryen [Thomas Lively] (1 hr)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Francis McCabe
- Sergey Rubanov
- Sabine
- Ben Titzer
- Alon Zakai
- Lars Hansen
- Slava Kuzmich
- Derek Schuff
- Igor Sheludko
- Fil Pizlo
- Keith Miller
- Jakob Kummerow
- Zalim Bashorov
- Ross Tate
- Aske Simon Christensen
- Ryan Hunt
- Andreas Rossberg
- Adam Klein
- Conrad Watt
- Deepti Gandluri
- Emanuel Ziegler

### Discussion: Equirecursive Types in Binaryen [Thomas Lively]

[slides](https://docs.google.com/presentation/d/1hHXGNSkm7gCF5UcntnR_w9LlV2ANVpgSoiECTQzLIso/edit?usp=sharing)

TL: <recap of shape and global canonicalization>. LW and AR independently shared a paper for improving this by working incrementally, one strongly connected component at a time.

Action item: tlively to figure out how big / what the source for the mystery test module is.

Action item: Aske to look at Dart2Wasm type graphs for larger Dart programs, create a new issue.

… Discussion missing ...


AR: Will try to present isorecursive types next time. Implemented a new compiler, realized that currying currently requires many casts.

RT: Sabine and I looked at this and found that the call tags proposal has a way to solve this. No casting required in our solution.

CW: Is there something we can look at for how isorecursive folds and unfolds are hidden away?

AR: Formalizations of ML.

FP: Andreas, are you saying that isorecursive types won’t help with languages besides lambda calculus, or are you just saying they don’t show up.

AR: They are low-level types, not typically human-written.

FP: Would Java still be able to lower to them?

AR: The code generator would have to make the recursion groups explicit, so the code generator does some analysis. Will get linear type canonicalization.

RT: Why not use rtt.fresh rather than rtt.canon and avoid the need for type canonicalization entirely?

AR: Comes back to separate compilation.

BT: The separate compilation problem is constantly beset by problems for specific languages.

TL: Only concrete plans for separate compilation I’ve discussed use wasm-ld and C/C++-style object files and relocations rather than the richer native loading/linking semantics. We should design for what tools are actually going to use, not just be maximally flexible as a basic principle if there is going to be a performance cost to that.

AR: I have separate compilation working for the compilers I’ve been working on.

RT: Does it support separate compilation without recompiling dependent units?

AR: No, dependent units need to be recompiled, C++-style.

Two different notions of separate compilation, either the dependent modules also need to be recompiled or not.

RT: Standard techniques for very separate compilation that do not require jitting, e.g. import size of superclass, etc.

BT: Jawa work does require some jitting, but not much.
"
main/2023/WG-01-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 11th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: January 11th, 2023 at 4pm-5pm UTC *( January 11th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
   - Discuss status and next steps for Wasm 2.0
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Attendees

- Luke Wagner
- Eric Prudhommeaux
- Derek Schuff
- Philippe Le Hegaret
- Sergey Rubanov
- Ilya Rezvov
- Ms2ger
- Thomas Lively
- Deepti Gandluri
- Zalim Bashorov

###  Welcome to Philipe Le Hegaret (AKA PLH)

W3C is a new legal entity (split from hosts such as MIT), unable to keep all the staff. Eric is leaving and several groups are falling back to PLH as their rep.
Also make sure that when groups want to move forward with REC track, that things go smoothly. But otherwise, I’m here to help with whatever the group needs.
I’m also trying to get groups on continuous publication or CR snapshots at least every 2 years. It’s less confusing that way, and covers the patent bases.


### Doc publishing
WG publishes “v2” as an evergreen spec, and stays at v2 without a minor version number. The CG has a minor version that increments.

Eric wrote a sphinx-to-TR tool that uses respec for the core spec. The other 2 specs are in Bikeshed. The latter requires manual editing to get the minor version, but the tool is fully automated.
https://github.com/w3c/sphinx-to-t

Currently there are 2 versions published. V1 is a rec and V2 is a first public working draft.
The plan was to migrate to Echidna next time we merge a proposal.

One question: what to do with the V1 spec? Are there implementations that target that specifically? 
Most implementations should converge.
So probably when we go to CR with V2, at minimum we should make V1 point to the new version.
LW: Does CR mean cutting a particular branch, or making the evergreen one live?

PLH: evergreen means to go to CR and stay in that state, and keep updating. Really the difference between that and working draft is that it has the patent policy. The biggest burden when going to CR is getting all the horizontal reviews.

DS: Yes, I think that’s what we want to do now

PLH: We should try to do this through github, track it through issues

LW: probably we can use a tag in the spec repo.

PLH: will create an issue in the spec repo to track what we need to do to go through the process. First will be to republish a working draft to determine exactly what will be reviewed.

EP: Might also be worth trying to get the echidna pipeline working with that too
"
main/2019/CG-02-05.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 5 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: February 5, 5pm-6pm UTC (February 5, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email Ben Smith to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. POLL: Split typed function references from GC into [their own proposal](https://github.com/WebAssembly/gc/blob/funcref/proposals/gc/Funcref.md).
    1. Discuss timing and location of next in-person meeting
        - Current plan: A Coruña, Spain at Igalia office, ~~week of Apr 29 - May 3 (specific dates not certain yet)~~
        - Discussed in meeting: tentatively planning for Wed Apr 24, Thu Apr 25
    1. POLL: to merge wasm-constants.js and wasm-module-builder.js? [WebAssembly/spec#963](https://github.com/WebAssembly/spec/pull/963)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Andreas Rossberg
* Arun Purushan
* Ben Smith
* Ben Titzer
* Conrad Watt
* Daniel Ehrenberg
* Derek Schuff
* Flaki
* Francis McCabe
* Heejin Ahn
* Jacob Gravelle
* Jay Phelps
* Keith Miller
* Luke Wagner
* Mitch Moore
* Pat Hickey
* Paul Schoenfelder
* Peter Jensen
* Richard Winterton
* Sven Sauleau
* Thays Grazia
* Ulrik Sorber
* Wouter van Oortmerssen
* Yury Delendik

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Lars seconds

### Proposals and discussions

#### Review of action items from prior meeting.

None

#### 1. POLL: Split typed function references from GC into [their own proposal](https://github.com/WebAssembly/gc/blob/funcref/proposals/gc/Funcref.md).

[discussion about splitting out typed arrays from gc as well]

LW: Till has intention to include arrays in typed objects proposal, hasn't gotten around to it yet.

DE: Oh, we would have multiple types of typed arrays.

LW: Right, we have TypedArrays and typed arrays.

| SF | F | N | A | SA |
| - | - | - | - | - |
| 0 | 11 | 4 | 0 | 0 |

[Decision: split the proposal]

#### Discuss timing and location of next in-person meeting

- Current plan: A Coruña, Spain at Igalia office, week of Apr 29 - May 3 (specific dates not certain yet)

AR: The holiday is kind of annoying, you have to travel on holiday or before

[discussing]

Planning for April 24th and 25th

AI[BS] add meeting doc for in-person meeting

#### POLL: to merge wasm-constants.js and wasm-module-builder.js? [WebAssembly/spec#963](https://github.com/WebAssembly/spec/pull/963)

SS: Is it OK to split merge these?

BT: I think it's ok, folks shouldn't be depending on it

LH: It's a private import in FF repo

BT: It's a test artifact, if we want we can make it into something more useful
for others. It'd be nice to separate out, but unless we do that I don't think
we should worry about breaking it.

BS: So is everyone OK merging these?

[Unanimous decision]

### Closure
"
stack/2021/sg-12-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 13th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  December 13th, 16:00-17:00 UTC ( December 13th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
- Francis McCabe
- Sam Lindley
- Thibaud Michaud
- Alon Zakai
- Ben Titzer
- Lars Hansen
- Adam Klein
- Luke Wagner
- Sam Clegg
- Michael Knyszek
- Ioanna Dimitriou



## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. [Retrospective on 2021](https://docs.google.com/presentation/d/1sQ3iYAGwxc_6iEe_ygcs_oBax4in_pJ5TQyh5FkdrzQ/edit?usp=sharing) (Francis McCabe)

   2. Next meeting [2 mins].
1. Closure

## Meeting Notes

SL: Typed continuations proposal
Implemented reference interpreter
Andreas/ Daniel/ Sam
Explainer written, planning to raise a PR
Various extensions
Currently trying to prototype in Wasmtime
I want to see Wasmtime prototype done. I want to see experiments.
Talking to Paul Schoenfelder

TM: Halfway through prototype implementation. Long tail of implementation.
Good chance of getting numbers
Competitive with asyncify

AZ: Not much to add. Tiny Go has shipped an implementation of go-routines using asyncify. 
Looking to seeing prototypes.
Implementation of go-routines was simpler/easier than doing it themselves in LLVM. Want to leave it to the tools.

BT: Attendance spotty.
Wizard is predicated on hardware protection for stacks. Looking for scaling to 100s to 1Ks.
Looking forward to a proposal that is complete enough so that I can try it out.
Would like millions of stacks in Wizard.
Virtual threads in Wizard?
Yes, and also real threads.

LH: I have a question. 
JS Promise integration in 2022 continue.

AK: Only occasional attendee. Fly on the wall. Most excited for prototype work. What are the riskiest aspects for multiple stacks. Tooling.

LW: I would add there is a lot of interplay with component. From a cross language perspective, we have been looking at an asynch API look like. A restricted form of effect signature. More limited than 1st class effects. Being prototyped in Rust tool chain.
Excited to see core proposal progress. Pthreads use case very interesting outside of the web because there is already a lot of parallelism; need to manage it.
Design constraints for interlanguage? Stop all effects at a boundary. 

SL: Do you feel that you have all the tools needed? 
LW: I know how to handle the cross language boundary.
The biggest constraint is the asymmetry inherent in the current proposal. You don’t want the callee to not scramble the stack. You need the parent chain - this is important for cross component modularity. 
SL: Catch-all handler or barrier? Possibly re-perform effects. You may have security implementations
LW: The asynch design is friendly to structured concurrency

MK: Looking forward to progress on stack switching. Really needed for go-lang. The giant switch statement looks horrible.
Wasm is tightly integrated in the go-lang tool chain.
Hard to support multiple threads in go-lang.
A lot of special cases in the current code.
AZ: Asyncify can be used as a polyfill for stack switching.
LW: That is promising
MK: Have to look more into asyncify. Not sure what asynicfy actually does. Will catch up with you.

ID: I have not been talking much. Looking at it from a exception handling point of view. Looking forward to more results next year, especially wrt threads.


### Adoption of the agenda

### Discussion:

### Adjourn

"
debugging/2020/debugging-09-17.md,"# Meeting notes for the September 17 video call of WebAssembly's debugging subgroup

- **Where**: zoom.us
- **When**: September 17, 11am-11:30 Pacific Daylight Time (July 23, 6pm UTC, 8pm CEST)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Derek Schuff
    - Email: dschuff@google.com
    
## Attendees
Yury Delendik, Luke Imhoff, Philip Pfaffe, Derek Schuff, Paolo Severini, Wouter Van Oortmerssen, Alon Zakai 

## Notes 


* DS: I'm about to land the first patch for split-dwarf in LLVM. Haven’t tested the contents against any debugger code yet, just checks that it gets the right sections. I also asked for some advice from llvm-dev about the best approach (e.g. old-school gcc dwarf fission vs the dwarf 5 version, etc). Haven’t heard back yet.

* AZ: in emscripten we now don’t run binaryen in O0 and O1 in simple cases (e.g. when using bigint, not using setjmp, etc). Useful for speeding up linking in any case, and also needed for split-dwarf (since binaryen doesn’t support split-dwarf and it would be nice if it didn’t have to).

* PS: have we talked about crash dumps or postmortem debugging?

[the following is DS’s “post-mortem” summary of the discussion]

Currently the VM can give us backtraces with module offsets, which the LLVM tools (e.g. addr2line) are able to turn into line information. We can also get the state of any exported globals and linear memory from JS (e.g. on trap). But we don’t have a way to get information about locals at runtime.
We need a way to get local state from the VM programmatically. In general this is a challenge, as current VMs (V8 and SM at least) track this local information in the baseline but not the optimizing compiler. (And there has been resistance from implementers to doing all this tracking at the top tier). So for general production use (i.e. postmortem debugging of production builds and runs) this is going to be a challenge. Probably for now there’s going to have to be some way for a build/run to “opt-in” to this bookkeeping at some cost.


Since the baseline compilers do keep track of all of the locals, we could have some way to ask the browser to only use the baseline tier (a la the compilation hints proposal idea that was floated in the past), and then also specify some API either in wasm or in the embedder (e.g. JS) to have the VM walk the stack and provide all the local values. You’d probably also still need a way to handle a trap that’s more flexible than the current one (i.e. turning it into a JS exception after the wasm frames have all unwound).  The result could be in the embedding, or it could even have the VM write the information into wasm linear memory to be collected by wasm code.

The stack walking spec proposal might be another way to do this. It allows specifying which variables to make available and a way to walk the stack in wasm and get those values. If we could launch a stack-walk e.g. when a trap or some other event occurs, then we could just opt all locals into being tracked, and we could could write stack-walk to collect their values at crash time. Debugging in general is a use case we should advocate for in the stack-walking discussions in the new stack walking subgroup.
"
wasi/2020/WASI-03-12.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the March 12 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: March 12, 17:00-18:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Proposals and discussions
    1. Crypto API now has its own repository:
        - https://github.com/WebAssembly/WASI-crypto
        - Let's talk about process and expectations.
    1. Merging send/recv into write/read:
        - https://github.com/WebAssembly/WASI/pull/240
        - This is a complex proposal, but the intention is to simplify
          the I/O story as we contemplate new kinds of streams and messages.

## Meeting Notes

Attendees:

Dan Gohman
Jan Falkin
Mike Trinkala
Lee Campbell
Andrew Brown
Ralph Squillace
Johnnie Birch
Benjamin Brittain
Mark McCaskey

Meeting notes:

Crypto API now has its own repository:
https://github.com/WebAssembly/WASI-crypto
Let's talk about process and expectations.

Merging send/recv into write/read:
https://github.com/WebAssembly/WASI/pull/240
This is a complex proposal, but the intention is to simplify the I/O story as we contemplate new kinds of streams and messages.
It’s difficult to comment because it’s a big and fairly abstract PR
Prototype implementation would help people see how this works out in practice
Impromptu questions:
Is it ok to have ambient authorities for debugging facilities such as logging?
BB, Lee: Yes, handles are good
Making it ambient is a decrease in potential power of the system

Impromptu agenda item:

DG: Is it ok if we have ambient authorities producing handles if the handles themselves can’t be used to do any I/O?
Sealed capabilities are a useful concept.
Lee: Avoid ambient authorities.
BB: Capabilities aren’t just security, they also allow compositional design patterns.
Lee: eg. logging. Where does the log output go? If you make it a handle, now you can send different handles that represent different sinks.
Logging for debugging vs logging for production, perhaps are not so different use cases.
Lee: A really powerful feature would be to have move-only semantics for handles, so you can send an instance a handle and it can be sure it’s the only instance with access to it.
DG: Reference types proposal doesn’t have move-only semantics, but it’s something to think about
Lee: Reference-counting can lead to awkward edge cases where references are kept live, or have aliases, in surprising ways. 
In Fuchsia, fd’s are 64-bit numbers and not reused.
WebAssembly/interface-types
BB: Move semantics changes how I’d design WASI APIs
Eg. capabilities for memory regions. What does it look like to transfer a handle for one of these to another instance?
Lee: Let’s have a discussion on rights, what rights look like, do we have a handle hierarchy?
WASI doesn’t predefine __unix__.
RS: GIve people a new engine, and it’s an easier step for people to take to port to. Guide them to doing the thing they want to do. Think of this as a new target. Don’t roll in old metaphors.
Lee: If something doesn’t build, then you know what you have to fix. If it builds but doesn’t work, now you have to debug it.
"
wasi/2024/WASI-08-08.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: August 08 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: August 08 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Yosh: WASI 0.2.1 release retro

## Notes

### Attendees

- Bailey Hayes
- Yosh Wuyts
- Jeff Charles
- Sergey Rubanov
- Marshall Meier
- Andrew Brown
- Marcin Kolny
- Zalim Bashorov
- Sehyo Chang
- Dan Phillips
- Nick Fitzgerald
- Marcin Kolny
- Yong He
- Michael Warres
- Hung-Ying, Tai

### Announcement, BA Plumber Summit Sept 26 & 27, 2024

**Pat Hickey** The Bytecode Alliance is holding a plumber’s summit for the Component Model and WASI collaboration event. This is not a WASI Subgroup event. It is an open invitation for folks who are working on implementations and related projects. 

**Pat Hickey** Look for a formal announcement next week. It will be held on the Microsoft campus in Redmond, Washington. Similar to last fall’s Componentize the World event.

###  WASI 0.2.1 release retro

**Yosh Wuyts**: As planned, we put out a new WASI release last week. Let’s have a little moment of reflection and a brief recap.

**Yosh Wuyts**: Last Thursday, we held a little mini release party. Bumping versions and making sure releases happened. We merged Joel’s unstable feature in wasi-cli. 

**Yosh Wuyts**: On Friday, we published a blog post from the Bytecode Alliance describing the releases and plans. I hope going forward we can keep that practice going forward of having some other venue to write about it.

**Yosh Wuyts**: Nobody burned out. We did a release and we did an OK job managing that. Nothing major and no heroics involved, which is a good thing.

**Yosh Wuyts**: For 0.2.2, I would like to drive and include @deprecated in at least one API. A minor naming change in wasi-http.

**Bailey Hayes**: Let’s walk through the release artifacts and the process we used to create them.

Scratchpad we used for creating a WASI release: https://hackmd.io/@ricochet/Hyc1KzFF0/edit

Yosh wrote this great blog post about the release: https://bytecodealliance.org/articles/WASI-0.2.1

Wasmtime updating to use 0.2.1: https://github.com/bytecodealliance/wasmtime/pull/9063

Related issue: https://github.com/WebAssembly/WASI/issues/608

**Andrew Brown**: The MIME type included in that OCI artifact says it’s Wasm. Is that a component?

**Taylor Thomas**: Yes. Within the CNCF Wasm WG, we came up with a format to standardize the OCI Artifact Layout: https://tag-runtime.cncf.io/wgs/wasm/deliverables/wasm-oci-artifact/

**Bailey Hayes**: These are WIT-only components. To see what I mean, run the following with the latest tools (install wkg from git):
```bash
wkg oci pull ""ghcr.io/webassembly/wasi/io:0.2.1""
wasm-tools component wit webassembly_wasi_io.wasm
```

**Bailey Hayes**: We’ll continue the discussion online for ways to improve the process and automation. I may push for a monorepo for example to make the release process simpler.
"
wasi/2019/WASI-05-30.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the May 30 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: May 30, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
        - Import names
    1. Weak imports
        - https://github.com/WebAssembly/WASI/issues/36
           - Relationship to core wasm feature testing?
              - https://github.com/WebAssembly/design/issues/1280
           - Should we push for weak imports in the core wasm spec?
           - Looking for volunteers to draft a weak-import custom section doc
    1. Where should wasi-sysroot live?
        - https://github.com/WebAssembly/reference-sysroot/pull/11
    1. Identify a module for an MVP.
    1. (Time permitting) Plan iteration on additional modules

1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

2019-05-02 WebAssembly CG WASI Subgroup Video Meeting Notes

Agenda: https://github.com/WebAssembly/WASI/blob/main/meetings/2019/WASI-05-30.md

Attendees:

Dan Gohman
Luke Imhoff
Alex Crichton
Martin Becze
Mark S. Miler
Pat Hickey
Tyler McMullen
Thomas Lively
Dan Gebhardt
Sam Clegg
Mark McCaskey
Nick Hynes
Nathaniel McCallum
Lin Clark
Yury Delendik
Mingqiu Sun


Meeting notes:

Review action items:

Sam has a document about import naming. TODO: insert the link here. We’ll discuss it in the next meeting.

Action item: Sam to send out the import naming document.

Weak imports:

“Weak” in this context is not related to weak GC references.

Desire to avoid depending on GC spec
Depend instead of reference types
Pat and others: push back on depending on reference types which aren’t in wasm MVP and not all tools support yet, causing schedule delays.
Mark Miller: How do capabilities work if we don’t have references?
Discussion of the mechanics of i32 file descriptors, which are forgeable, and which don’t enforce PoLA
Luke Wagner: Multiple tables may help i32-based environments have better granularity.
If you’re using C, you have to trust anyone you share your linear memory with. But other tools and languages and implementation strategies could do better.
Discussion of techniques to achieve various granularities of PoLA.


Action item: Sam to write up a name mangling proposal.

Action item: Mark Miller to write up a vision document for using reference types and reference-counted closures in WASI.

Existing toolchains for C-family and similar languages don’t use references. They typically need bindings tools to interoperate with reference-using APIs

Discussion of how bindings work in various languages.


Action item: Dan to rename wasi-sysroot to wasi-libc

Discussion of the WASI repo structure, pros and cons of using multiple repos, inside and outside the org

Discussion about organizations and repos. Emscripten has its own org. LLVM wasm backend is maintained in a third party repository. Concern about having things in the WebAssembly org might raise the barrier to entry for contributing. Having things in the WebAssembly org may make things easier to find.

Action item: Mark Miller to write up a vision document for using OCAP in WASI.
"
gc/2020/GC-11-17.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 17th video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: November 17th, 5pm-6pm UTC (November 17th, 9am-10am Pacific Standard Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Presentation: Layered runtime systems (@titzer)
1. Closure

## Meeting Notes

### Introduction of attendees

 - Ben Smith
 - Lars Hansen
 - Asumu Takikawa
 - Andreas Rossberg
 - Ben Titzer
 - Ryan Hunt
 - Conrad Watt
 - Zalim Bashorov
 - Manos Koukoutos
 - Adam Klein
 - Keith Miller
 - Ross Tate
 - Francis McCabe
 - Hannes Payer
 - Emanuel Ziegler
 - Tim Steenvoorden
 - Rick
 - Jakob Kummerow
 - Daniel Ehrenberg
 - Igor Sheludko
 - Slava Kuzmich
 - Luke Wagner
 - Tobias Tebbi
 - JP Sugarbroad
 - Thomas Lively

### Presentation: Layered runtime systems (Ben Titzer) [1 hr]

Ben Titzer presenting [slides](https://docs.google.com/presentation/d/1HaxcyHoKle79koLfqhpLKil24w_98GXZGwsZFJo-qxE). ([detailed paper](https://docs.google.com/document/d/14T8RPgQKztURiHmzyP_Ju2S9nrIZWDaAb8eSx3NiiYw))

RT: When do errors (e.g. NoSuchFieldError) happen? Is there flexibility?

BT: There is some flexibility. JVMs have their own compatibility problems. The spec allows throwing these earlier, but some programs depend on catching them at run time.

AR: IIRC, the Java spec allows for doing these any time before the relevant instruction is executed. Could happen at different times in all different engines, eagerly or lazily.

BT: Yes, and you can even generate your own classes and use class loaders at runtime, so this is all observable.

---

RT: To clarify, you’re not handling the Java code itself creating and loading new .class files? That would require a .class-to-wasm compiler in the runtime.

BT: Yes. That doesn’t require a Java bytecode interpreter in the runtime, though. A transpiler is sufficient.

--- 

RT: How do you express covariance of arrays?

BT: Use subtype imports.

RT: Enumerate finite types?

---

FM: AALOAD has a different type argument. Are you going to import it multiple times?

BT: Yes, it will be imported once for each different type it is used with.

---

CW: How does the invoke mechanism work with the `this` object?

BT: The dispatch to the correct type is hidden in the implementation.

CW: What about a method that takes a superclass called on a subclass?

BT: There is a Jawa-level check when a class is defined that all the receivers have the correct type.

RT: This doesn’t say anything about how Wasm can reason about that relationship, though.

BT: Correct.

---

SK: Why is this better than just passing class files?

BT: No need for a class parser.

RT: What about cross-instruction optimization?

BT: Up to the Wasm engine’s JIT optimizations.

RT: But in Wasm GC there won’t be any additional optimizations?

BT: There could be; it’s up to the Wasm engine. This is a problem with any dynamic code generation. The tier below needs to optimize any generated common subexpressions.

"
CODE_OF_CONDUCT.md,"# Code of Ethics and Professional Conduct

WebAssembly operates under the W3C's
[Code of Ethics and Professional Conduct][]:

> W3C is a growing and global community where participants choose to work
> together, and in that process experience differences in language, location,
> nationality, and experience. In such a diverse environment, misunderstandings
> and disagreements happen, which in most cases can be resolved informally. In
> rare cases, however, behavior can intimidate, harass, or otherwise disrupt one
> or more people in the community, which W3C will not tolerate.
>
> A Code of Ethics and Professional Conduct is useful to define accepted and
> acceptable behaviors and to promote high standards of professional
> practice. It also provides a benchmark for self evaluation and acts as a
> vehicle for better identity of the organization.

We hope that our community group act according to these guidelines, and that
participants hold each other to these high standards.

If you are worried that the code isn't being followed, or are witness to a violation
but are uncomfortable speaking up, please contact the Community Group's chairs at
`team-wasm-chairs@w3.org` (note: this list is also visible to W3C staff).

In cases where there is repeated disregard for the CEPC, it is possible to incur disciplinary
action. The points below outline a series of steps that will be taken in case of violations
to ensure a positive work environment in the WebAssembly CG.

 - **Informal warning**
   An informal or verbal warning can be issued in any relevant medium of communication calling
   out inappropriate behavior as a violation of the CEPC
   (examples: responses to github issues or PRs, discord, email, meetings).

 - **Corrective action and/or counseling**
   Informal meetings, or email discussions where problematic behavior is addressed,
   and suggestions for constructive ways forward are offered. A mediation process can also be an
   option if relevant to the situation and both parties agree.

 - **Formal warning**
   An explicit warning issued after repeated incidents. While members of the CG can call out
   inappropriate behavior as needed, warnings will be issued by CG chairs, subgroup chairs, or
   proposal champions depending on the nature of the violation. The warning should be issued
   with consultation from team-wasm-chairs@w3.org.

 - **Optional formal meeting**
   An optional meeting with the chairs and/or a W3C representative to discuss next steps.
   The meeting can be requested by any party, and should serve as a forum for discussion.
   While this is the recommended next step, it is not a blocker for further action, i.e.
   the chairs can request that a meeting take place, and should be available for a
   discussion if requested by others, but further action will not be gated on this meeting.

 - **Temporary suspension**
   The temporary suspension will be issued based on repeat violations,
   with the duration and the reason for the suspension clearly outlined.

 - **Indefinite suspension, revoking membership etc.**

The set of actions above are an edited version of the W3C [disciplinary process][] as
applicable to the Wasm CG, and will be carried out with respect, confidentiality, and fairness.

The W3C also has [procedures][],
allowing you to access its ombuds directly and confidentially, in case other venues of resolution have not resulted in a satisfactory outcome.

  [Code of Ethics and Professional Conduct]: https://www.w3.org/Consortium/cepc
  [procedures]: https://www.w3.org/Consortium/pwe/#Procedures
  [disciplinary process]: https://github.com/w3c/PWETF/blob/main/CEPCdisciplinary-process.md
"
benchmarking/2024/benchmarking-03-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 8th of WebAssembly's Benchmarking Subgroup

- **Where**: Google Meet
- **When**: March 8th, 4pm-4:45pm UTC (8am-8:45am PDT, 11am-11:45am EST)
- **Location**: _Link on calendar invite_
- **Contact**:
    - Name: Petr Penzin, Saúl Cabrera
    - Email: penzin.dev@gmail.com, saul.cabrera@shopify.com


### Registration

If this is your first time attending, please [fill out the registration form](https://forms.gle/QCmhyM4QwvWvZR9b8) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

### Logistics

This meeting will be a Google Meet video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes
    1. Please help take notes.
1. Announcements
    1. WasmScore Presentation (Johnnie Birch)
1. Proposals and discussions
1. Closure

## Attendees

* Ajay Chhokra
* Andrew Brown
* Ashley Nelson
* Daniel Lehmann
* Johnnie Birch
* Marco Rudilosso
* Nick Fitzgerald
* Petr Penzin
* Saúl Cabrera




## Meeting notes

### WasmScore presentation (Johnnie Birch)

JB presenting [slides](./wasm-score-slides.pdf)

AB (In chat): Johnnie, if you're looking for an easy way to capture hashes of various Sightglass things, including benchmarks, you might be interested in: sightglass-cli fingerprint --kind benchmark|engine|machine

PP: Is the time column  in seconds?

JB: The time column is taking the time and producing an average based on geomean.

PP: Is the geomean is suite or test based?

JB: Crypto is a suite, with N benchmarks inside it, and the efficiency is calculated per test, and then an average is calculated for all the calculated efficiencies.

PP: The score is normalized on the maximum time?

JB: There's no maximum.

JB: There are two scores: efficiency, which can't be greater than 1 and execution time which is the inverse of time 1/time (higher is better). This is done to make it consistent. 

PP: What do you mean by 1/time, is time in seconds? Would that mean that time less than 1 second then score is greater than 1 and less than one otherwise?

JB: Moving on for now. Major point: higher means the score is better and to avoid inconsistency issues.

MR (in chat): is it a bit like iterations per second?

AC (in chat): Do you consider AOT and JIT modes?

PP (in chat): There is also an output for instantiation/compilation/execution - I am wondering if that is memory footprint?

MR: Is the score iterations per second, as in how many time it can execute X per second?

JB: Great point, however this benchmark doesn’t take this into account.

JB (re AC question): it only does the default that wasmtime support, it doesn’t take AOT vs JIT into account. You can compare SIMD vs native, there can be multiple ways to provide scores.

AC: how difficult it would be to change underlying runtime?

JB: Sightglass 1.0 supported different engines, Sightglass 2.0 only supports wasmtime. There are different use cases for different engines.

PP: Right now ti only supports wasmtime?

JB: Only what sightglass supports, currently it is wasmtime

PP: Paraphrasing the Ajay’s question one more time, what would it take to get back to using other engines?

JB: I never officially upstreamed that.

AB: This draft PR might provide an idea of what that would take: https://github.com/bytecodealliance/sightglass/pull/166

AB: Johnnie, check out my chat comment about fingerprinting.




"
wasi/2019/WASI-11-07.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the November 07 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: November 07, 17:00-18:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Publishing a first snapshot
         1. https://github.com/WebAssembly/WASI/issues/138
    1. Issues for discussion
         1. Make clocks/random into capabilities
             1. https://github.com/WebAssembly/WASI/issues/118
             1. Should random continue to be `random_get`, or should it become
                `fd_read` from a special stream?
         1. Increase the timestamp range
             1. https://github.com/WebAssembly/WASI/issues/33 
         1. Remove remaining ""process"" dependencies
             1. https://github.com/WebAssembly/WASI/issues/26
             1. Remove `CLOCK_PROCESS_CPUTIME_ID`?

1. Closure

## Meeting Notes

Attendees:

Dan Gohman
Stefan Junker
Mark Bestavros
Nathaniel McCallum
Johnnie Birch Jr.
Mark S. Miller
Alon Zakai
Yury Delendik
Alex Chrichton
Luke Wagner
Mark McCaskey
Pat Hickey
Sam Clegg
Peter Huene
Alon Zakai


Meeting notes:

## Making a first snapshot - call it “snapshot”

AI: Dan to add a note to the phases document about how we make syntax changes to old versions while keeping the ABI compatible

## Make clocks/random into capabilities 

DG: Currently clocks/random are ambient authority in WASI. Can keep compatibility with (C-style) programs out there which expect this to be the case? If so, how?
LW: Would this step mean that the program will always ask for clocks/random with the future option of allowing to not ask for it?
DG: What troubles me about that is that we’d still have to think about the mechanism for asking for it

(discussion about clocks/random as stream vs. datagram)

## Increase the timestamp range 

DG: this would be a good opportunity for someone who just wants to do this for the sake of learning how to change the API. happy to talk about this offline

## Remove remaining ""process"" dependencies 

(discussion about exception handling in JS when interacting with WASM)

DG: proc_raise is going away, proc_exit should ideally be implemented in terms of unwinding, though there are some details to figure out there. Can we remove the process-oriented clock identifiers?

(Discussion, concluding in general approval)

(Discussion of whether a “gas” clock could be defined; see also

https://medium.com/@erights/a-pack-of-watchdogs-is-cheaper-than-gas-7e118edfb4cc

Answer: there are some potentially subtle issues — programs could use this to determine how much time other parts of the program take, which may be undesirable. In any case, WASI itself would have no trouble defining new kinds of clocks in the future.)

NM: Our implementation is able to implement the process-oriented clocks efficiently. If we remove them today, could they be reintroduced in the future if we want them?
DG: Yes, once we have modularity established and optional imports, it would be straightforward to add new features like this.

NM: Is working on a proposal for a high level crypto API
MM: A request would be to not have the keys and algorithms in the same address space.. 
"
wasi/2019/WASI-09-12.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the September 12 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: September 12, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. `witx` API description files:
        - https://github.com/WebAssembly/WASI/pull/74
    1. Phased API development proposal
        - https://github.com/WebAssembly/WASI/pull/88

1. Closure

## Meeting Notes

Attendees:

Dan Gohman
Sam Clegg
Pat Hickey
Yury Delendik
Artur Jamro
Mark McCaskey
Alex Crichton
Jacob Gravelle
Mingqiu Sun
Nathaniel McCallum
Luke Wagner
Johnnie Birch

Meeting notes:

Agenda seconded by Pat

Dan: Last meeting was at a different time than usual. There were only 6 attendees. We are going to resume meetings at the normal time, 1600 UTC.

Dan: Next topic is WITX.

Independent of WASI, there is a new file format called WIT from the interface-types proposal. Its a lot like WAT, but it does not have function bodies.

WITX is WIT with extensions. It has some of the types from interface-types. The idea is that WITX is not a stable format, its going to evolve to align with WIT as interface types evolves.

Fortunately our needs are pretty simple at the moment: we are adding strings, arrays, enums, and structs to the wit file.

We want WITX to be the way we specify WASI apis. It feels like a better place than the C header file we started with.

Pat: lucet-idl tool has a witx parser in development.

Working on hooking up this parser to the C and Rust interface generators.
Goal, be able to feed witx files into lucet-idl and generate C headers and Rust interfaces.

Can be used to generate libc definitions for WASI


Stefan: Does WITX have modules?

Dan: Yes, but the file we have at the moment attempts to be the exact same wasi_unstable module we have right now. Once we land this, we can immediately start factoring that module into multiple modules, and witx should support that.

Sam: Is there a way to use types from a different module?

Dan: Yes, there is a `use` mechanism, and in the PR there’s two witx files, wasi_unstable’s first declaration is to `use “typenames.witx”`

Dan: Next agenda item: Phased API development (PR 88). Apologies for getting this up late.

Stefan: Could there be a standalone parser implementation somewhere?

tdoPat: I’ll make the lucet-idl parser and validator for witx into its own crate, and that crate will live in the WASI repo.

Johnnie: I followed up on whether we can record these meetings, I talked to the W3C and they expressed the same concerns we heard here about privacy, making people feel comfortable speaking up. They suggested I talk to the WASM CG, but given that I’ve heard the same feedback from multiple places, I’m going to just drop the issue.
"
gc/2021/GC-05-04.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 4 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: May 4, 4pm-5pm UTC (April 6, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Canonicalization [Andreas Rossberg]
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Slava Kuzmich
- Tim Steenvoorden
- Léo Andrès
- Luke Wagner
- Conrad Watt
- Rick Battagline
- Francis McCabe
- Igor Sheludko
- Ross Tate
- Aske Simon Christensen
- Zalim Bashorov
- Lars Hansen
- Ben Titzer
- Daniel Wirtz
- Jakob Kummerow
- Andreas Rossberg
- Daniel Ehrenberg
- Adam Klein
- Alon Zakai
- Zhi An Ng
- Emanuel Ziegler
- Sabine
- Ryan Hunt
- Asumu Takikawa

### Discussion: Canonicalization

[slides](presentations/2021-05-04-rossberg-canonicalization.pdf)

RT: Are you ruling out the cross-module type recursion necessary for Java class files? In this case you have mutually recursive types that form new SCCs rather than unfolding to existing SCCs.

AR: No, that would require cyclic linking, which I don’t think we’re going to add.

TL: For warm cache measurements, you wouldn’t expect any runs after the first to be different because all the types are already in the cache.

CW: Time doesn’t look great <missed details>

RT: Cold cache time directly affects page loading time.

AR: Hard to tell what conclusions to draw from this.

RT: Our examples have been small, so 10x the number of types may be reasonable.

AR: Hard to say because J2CL example already includes some JDK, which tends to transitively include much more JDK.

BT: For reference, entire JDK contains over 100k classes.

AR: Yes, but there’s probably some base set that always gets included and most don’t.

FM: Did you plug in Hopcroft’s algorithm to compare?

AR: No, it’s unclear why you would do that. Both algorithms are fairly simple.

TL: Would be interested to figure out how much speedup is due to choice of algorithm and how much due to SCC at a time.

BT: Would it be easy to output the graphs in some format and run standard tools to minimize the graphs and see how it compares to optimized implementations?

AR: Would be easy, but I don’t know of any standard formats or tools.

BT: Could use parser generators like JavaCC. Come up with a grammar that encodes the graph.

AR: Probably easier to compare algorithms directly.

RT: This is only for rtt.canon and the current call indirect formulation. I have a proposal for a version of call indirect that doesn’t need it. We should also step back and consider whether all this work is worth it.

AR: More data would be the most useful thing right now.
"
main/2017/WG-12-06-process.md,"# Discussion of W3C Process
   * NOTE: All of this is based on Brad's understanding of W3C docs.
     Brad is not a lawyer.
   * [Link](https://www.w3.org/2017/Process-20170301/)
   * W3C documents progress thru several steps:
      * [First Public Working Draft](https://www.w3.org/2017/Process-20170301/#first-wd)
      * [Working Draft](https://www.w3.org/2017/Process-20170301/#revised-wd) - Some number of revisions.
      * [Candidate Recommendation](https://www.w3.org/2017/Process-20170301/#last-call)
      * [Proposed Recommendation](https://www.w3.org/2017/Process-20170301/#rec-pr)
   * [Changes can roll back the process](https://www.w3.org/2017/Process-20170301/#rec-modify)
      * During Working Draft this only requires that we document what
        has changed.
      * During later phases this can reset the entire process
        (for substantive changes).
      * [Classes of changes](https://www.w3.org/2017/Process-20170301/#substantive-change):
         * Editorial
            * No changes to text content
            * Corrections that do not affect conformance
         * Substantive
            * Corrections that do not add new features
               * Changes conformance of agents.
            * New features
    * General requirements for advancement
       * MUST record the group's decision to request advancement.
       * MUST obtain Director approval.
       * MUST provide public documentation of all substantive changes to the technical report since the previous publication.
       * MUST formally address all issues raised about the document since the previous maturity level.
       * MUST provide public documentation of any Formal Objections.
       * SHOULD provide public documentation of changes that are not substantive.
       * SHOULD report which, if any, of the Working Group's requirements for this document have changed since the previous step.
       * SHOULD report any changes in dependencies with other groups.
       * SHOULD provide information about implementations known to the Working Group.
       * For a First Public Working Draft there is no ""previous maturity level"", so many requirements do not apply, and approval is normally fairly automatic. For later stages, especially transition to Candidate or Proposed Recommendation, there is usually a formal review meeting to ensure the requirements have been met before Director's approval is given.
    * Requirements for Revised Working Drafts
       * If 6 months elapse without significant changes to a specification
         a Working Group should publish a revised Working Draft,
         whose status section should indicate reasons for the lack
         of change.
       * To publish a revision of a Working draft, a Working Group:
          * MUST record the group's decision to request publication. Consensus is not required, as this is a procedural step,
          * MUST provide public documentation of substantive changes to the technical report since the previous Working Draft,
          * SHOULD provide public documentation of significant editorial changes to the technical report since the previous step,
          * SHOULD report which, if any, of the Working Group's requirements for this document have changed since the previous step,
          * should report any changes in dependencies with other groups,
    * [Patent Policy](https://www.w3.org/Consortium/Patent-Policy-20170801/#sec-Exclusion)
       * ""First Public Working Draft"" triggers a ""Call for Exclusions"".
       * Working group members must disclose that they have
         patents for ""essential claims"" with 150 days
         after ""First Public Working Draft"".
       * New members joining after ""First Public Working Draft"" have
         90 days after they join or 150 days after fPWD, which ever is
         shorter to declare their claims.
       * If a member resigns, they are obligated to license all claims
         contained in the latest Working Draft.
          * Resigning members have 60 days to exclude additional material
            in the latest draft. However, only if such material wasn't
            present in the latest working draft published 90 days after
"
main/2021/CG-05-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 11th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: May 11th, 4pm-5pm UTC (May 11th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Present and discuss [Interval Primitives](https://github.com/WebAssembly/design/issues/1384) (Kloud Koder)[40 mins]
    1. Present and discuss [Multiprecision Primitives](https://github.com/WebAssembly/design/issues/1386) (Kloud Koder)[10 mins]
    1. Present, discuss and poll [Wasm CSP recommendation to WebAppSec WG](https://docs.google.com/presentation/d/1JYyYsnENblAin1gAgBobzoBUu-wIIOrf5-9N9McR_oE/edit?usp=sharing) (Francis McCabe)[10 mins] 
1. Closure

## Meeting Notes


### Attendees:

- Thomas Trankler
- Derek Schuff
- Francis McCabe
- Ben Titzer
- Chris Fallin
- Paul Dworzanski
- Luke Imhoff
- Arun Purushan
- Lars Hansen 
- Alex Crichton
- Dan Gohman
- Rick Battagline
- Mingqiu Sun
- Alon Zakai
- Paolo Severini
- Keith Miller
- Sam Clegg
- Zalim Bashorov
- Jacob Abraham
- Daniel Miller
- Yury Delendik
- Jakob Kummerow
- RYan Hunt
- Daniel Wirtz
- Deepti Gandluri
- Thomas Lively
- Nick Fitzgerald
- Jlbirch
- Manos Koukoutos
- Sabine
- Flaki
- Emanuel Ziegler
- Rich Winterton
- Ross Tate
- Slava Kuzmich
- David Piepgrass
- Heejin Ahn
- Petr Penzin
- Garret Gu




### Proposals and Discussions

####
1. Present and discuss [Interval Primitives](https://github.com/WebAssembly/design/issues/1384) (Kloud Koder)[40 mins]
1. Present and discuss [Multiprecision Primitives](https://github.com/WebAssembly/design/issues/1386) (Kloud Koder)[10 mins]

These presentations were postponed to a future meeting due to technical issues.


#### Present, discuss and poll [Wasm CSP recommendation to WebAppSec WG](https://docs.google.com/presentation/d/1JYyYsnENblAin1gAgBobzoBUu-wIIOrf5-9N9McR_oE/edit?usp=sharing) (Francis McCabe)[10 mins] 


DS: the previously-agreed thing, is that the same but with a different name?

FM: yes. I prefer the one without unsafe-eval


DG: I’m curious to hear from the other vendors?

LH: I don’t think we have any concerns about the proposal as written

KM: I agree with Lars, I think we want to have this capability

FM: In the absence of a formal vote, I’ll propose we rename this wasm-unsafe-eval and propose to web-app-sec on May 18, a week from today.

<no objections>

Naming?
    
DP: I for one prefer wasm-eval
 
FM: I do too; but I also don't want to delay this for the ultimate bikeshed

RT: “Unsafe” seems like bad branding?

FM: W3C TAG design principles #104 document recommends prefixing particularly dangerous operations with “unsafe”. Maybe JS itself should be marked unsafe, by the same logic.

ZB: Replace “eval” with “exec”?

RT: or ""compile"" - it seems the unsafe aspect is that the code can by dynamically determined


BT: Many long conversations with web platform people about the “wasm-unsafe-eval” vs “Wasm-eval”
We settled here to make progress.

Connotations from JavaScript unfortunately carried over. Probably not worth bike shedding, thus here we are
    


"
stack/2021/sg-4-5.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 5th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  April 5th, 16:00-17:00 UTC ( April 5th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Daan Leijen 
Sam Lindley
Luke Wagner
Arjun Guha
Daniel Hillerström
Alon Zakai
Rick Battagline
Paul Schoenfelder
Derek Schuff
Thomas Lively
Zalim Bashorov
Ross Tate
Luke Imhoff
Adam Klein
KC


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. Lightweight threads, actors, async/await, ..., in a minimal extension of the
WebAssembly reference interpreter (Sam Lindley) [45 mins]
   1. Next meeting [2 mins].
1. Closure

## Meeting Notes

### Adoption of the agenda

### Discussion:

1. Daan Leijen shares libmprompt link: https://github.com/koka-lang/libmprompt

2. Lightweight threads, actors, async/await, ..., in a minimal extension of the
WebAssembly reference interpreter (Sam Lindley)

TODO(Sam Lindley): add slides

Examples: https://github.com/effect-handlers/wasm-spec/tree/examples/proposals/effect-handlers/examples

FM: We’ve seen a few different styles of continuation structure so far. For example last time Daan shared a shift-reset-style approach. What’s the difference between that approach and this approach.

SL: Not much of a difference.

FM: This one has events, though.

SL: The multi-pronged control flow approach is an implementation strategy for implementing this universal kind of event that takes a continuation. The way people program with delimited control is exactly how people program with effect handlers (although Wasm is of course a target language) and any deviation from that makes programs hard to reason about.

DL: [on static-lwt.wast] missed this…

FM: Does this mean that when an event yields, the block will be exited?

SL: Yes, exactly.

LW: This is exactly like Wasm’s other control flow using blocks as labeled breaks.

FM: Normally a block has a block signature, i.e. arguments and returns. This one seems different?

SL: Note the ref $proc is also part of the results of the block, so it’s provided by the `resume` that jumps out of the block.

[looking at actor.wast]

SL: Looking at `apply`, it looks like some form of partial function application will be necessary for lifting functions back up to continuations. This might be a performance issue for implementations.

FM: Where does the resume with no labels go? How do the types work out?

SL: All events will be caught further up in the stack because no events are handled by that resume.

DL: There is the possibility that a resume will fail because the event is never handled. The types assume that there will be a handler.

FM: There has to be this dynamic matching of labels to events.

SL: Yes, just like for exceptions.

PS: In library code, you might have a scheduler and you don’t know what the continuations will return.

SL: Yes, you’d have to track the types around.

RT: What about dynamic event systems, where you have to inspect the events to figure out whether to handle them? In this system, it looks like there will need to be a stack switch per handler, even for handlers that don’t ultimately do anything.

### Adjourn

"
wasi/2023/WASI-10-05.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: October 5 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: October 5, 16:00-17:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Updates on implementations
       - Dan Gohman: Resources and wasio-poll refactor landed in implementations
       - Bailey Hayes: WIT syntax changes
    1. Vote: Advance [wasi-cli](https://github.com/WebAssembly/wasi-cli) to phase 2
       - All upstream proposals are at phase 2.
       - Portability criteria are the same as the other WASI proposals.

## Notes

### Attendees

- Dan Gohman
- Bailey Hayes
- Colin Murphy
- Kyle Brown
- Chris Woods
- Joel Dice
- Piotr Sikora
- Ivan Font
- Chris Suszynsk
- Dave Bakkeri
- Zalim Bashorov
- Sam Clegg
- Mingqiu Sun
- Johnnie Birch
- Yong He

#### Updates on implementations

**Bailey Hayes**: <https://github.com/orgs/bytecodealliance/projects/10/views/1>
Wit syntax iterations. Semicolons will be required.
Alex has proposed a gradual roll out, to mitigate the disruption.
<https://bytecodealliance.zulipchat.com/#narrow/stream/223391-wasm/topic/WIT.20and.20semicolons>
<https://github.com/bytecodealliance/wasm-tools/pull/1212>

##### Resources

**Dan Gohman**: Resources and Handles
Resources: represent arbitrary external objects
Handles: References to Resources.
Owned Handles and Borrowed Handles, similar to Rust but done at runtime.
Handles are like file descriptors, but different in a few key ways. Handles are typed and have a set of methods. The IDL declares what things are owned and what things are borrowed.
HTTP, Sockets (including UDP), have been changed to use resources and handles.

#### Vote: Advance wasi-cli to phase 2

**Bailey Hayes** Approval signifies that the portability criteria have been defined.
**Dan Gohman** This pulls in things that are not already defined, such as CLI worlds.
**Chris Woods** So, we voted to use WIT in its pre-semi-colon state. Now we are changing WIT ? - Am I getting that right ?
**Chris Woods** Changing the WIT spec prior to preview2 seems to detract from stability
**Bailey Hayes** Open issues for component model that are potentially incoming:
- <https://github.com/WebAssembly/component-model/issues/256>
- <https://github.com/WebAssembly/component-model/issues/253>
- <https://github.com/WebAssembly/component-model/issues/238>
**Bailey Hayes** We don’t want to change the syntax after preview 2.

**SBC** Handles are i32. Are they forgeable?
**Dan Gohman** Handles are unforgeable, since they have no meaning outside of their module context.

**Bailey Hayes** Consensus vote
**Bailey Hayes** Vote passes

#### WASI-NN Subgroup

**Andrew Brown** We started a WebAssembly ML working group. Aimed at advancing the WASI-NN spec and implementations to where it needs to be. Lots of companies are interested in using WASI-NN, but they need changes.

<https://github.com/bytecodealliance/wasm-ml-meetings/blob/main/2023/ML-10-03.md>

WASI-NN world will need to be modified as well. That falls to this subgroup.

**Bailey Hayes** Meeting notes should be moved to bytecode alliance meetings repo
"
main/2019/CG-12-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 10th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: December 10th, 5pm-6pm UTC (December 10th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Update on dates / venue / etc for face-to-face meetings requested.
        1. CG Meeting to be held on February 11th, 12th 2020. Please fill out the [registration form](https://forms.gle/AkFcWeiVn9QqHJte7).
    1. [WebAssembly contributor summit](https://webassembly-summit.org/) on February 10th, applications to attent/speak close soon.
    1. Working group updates
    1. Solicit interest in video meeting on GC MVP next week.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees
Ms2ger

Derek Schuff

Jay Phelps

Ryan Hunt

Kieth Miller

Barbara Nichols

Rick

Lars Hansen

Francis McCabe

Thomas Lively

Adam Klein

Andreas Rossberg

Sabine

Arun Purushan

Matt Garnett

Deepti Gandluri

Zhin

Azakai

Rick

Paul Dworzanski

Ross Tate

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

Keith Miller seconds.

### Proposals and discussions

#### Review of action items from prior meeting.

None.

#### Update on dates / venue / etc for face-to-face meetings requested.

Updates from Deepti

Next face to face to be hosted by Google in San Francisco Feb 11. Please fill [registration form](https://forms.gle/AkFcWeiVn9QqHJte7) to attend.
We also have a WebAssembly contributors summit Feb 10. Participants and speakers need to register (free event) but the registration is only open for a few more days.

WG update: our current charter expires in 2020. We have to choose what kind of standard we want going forward (living standard or with discrete versions). If you are interested in participating in the discussions about that, let us know.

KM: are CG members more likely to get into the contributors summit?

DG: don’t know, this is more of a developer focused event. But we also want to be able to mix between users and developers of the standard.

Update from Ross Tate on research efforts around GC

RT: We’ve been working on the GC proposal, it would be useful to have more discussion with the broader group, focused on use cases. There’s the existing proposal, and we would have to decide what we want to do going forward, or resolve existing discussion. We wanted everyone interested to know that this was going on, 

We’ve set up a link to find a time that works for everyone (http://whenisgood.net/wasm-gc-mvp-intro).

https://github.com/soil-initiative/gc/pull/1


### Closure
"
main/2018/WG-05-23.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 23 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: May 23, 2018 at 3pm-4pm UTC *( May 23, 2018 8am-9am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Brad Nelson
    - Email: bradnelson@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion on status of the Working Draft.
    1. Update on Brad Nelson.
1. Future meetings
    1. Confirm next meeting date + time.
    1. Handing of agenda for in person meeting.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Opening, welcome and roll call

Anekc
Brad Nelson
Ben Smith
Jacob Gravelle
Conrad Watt
JF Bastien
Luke Wagner
John Hall
Shiva Kushwa
Deepti Gandluri

### Opening of the meeting

### Introduction of attendees

### Find volunteers for note taking (chair to volunteer).

Brad Nelson to take notes.

### Adoption of the agenda

JF Seconds.

### Discussion on status of the Working Draft.

#### Status of exclusion periods

Timing on patent exclusions in First Public Working Draft
150 day window.
It's currently 97 days since Feb 15. 53 to go.
New items start separate 90 days clocks on the diff.
We are obligated to publish a new draft or explain why every 6 months.

#### Including Mutable Global

It has come up that we shouldn't knowingly publish something that's going to be incompatible.

JF in the CG I'd heard some objection about not having things not in the MVP.

JF: I'm swayed by Luke's argument.

AI: Let's have a poll on the agenda.

AI: Next time let's poll on Mutable globals begin ship worthy.

AI: Add a standing item to the agenda on general ship worthiness.

### Update on Brad Nelson

Brad Nelson is leaving work on the Chrome team, as such we probably should select a new chair who will be directly involved going forward.

Brad would like to propose Ben Smith, but we didn't give notice on this agenda.

Also Brad needs to investigate the process around a proper hand-off.

### Future meetings

### Confirm next meeting date + time.

In the interest of accelerating the hand-off, Brad might like to have a meeting in a week for the transition. On the other hand it might take longer to sort out. Brad asks the group for his discretion on scheduling next meeting (1 week or 2 week). It is suggested we could have a one-off *special* meeting so as not to break the cadence we have.

Luke thanks Brad for his service as chair.

### Closure
"
debugging/2020/debugging-07-23.md,"# Meeting notes for the July 23 video call of WebAssembly's debugging subgroup

- **Where**: zoom.us
- **When**: July 23, 11am-11:30 Pacific Daylight Time (July 23, 6pm UTC, 8pm CEST)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Derek Schuff
    - Email: dschuff@google.com
    
## Notes 

* (these are summaries from memory rather than direct transcription: errors are solely Derek's fault)

* Luke Imhoff: There's been some discussion in the broader CG about 2-phase unwinding, for which debugging is a major motivator.
There's also been some discussion about how toolchains might represent the unwinding information (which is related to the debug info).
Those folks didn't seem very aware of the stuff we are discussing here. Should we maybe make some kind of presentation in the CG or some
other way to update them?

* Derek Schuff: Seems like a good idea. There are definitely 2 competing visions for how the platform capability for 2-phase unwinding
and related capabilities will work. I think either one of those could work with what we've done for the DWARF ecosystem so far. 

* Yury Delendik: Our flavor of DWARF is only concerned with describing source-level constructs.

* DS: Right, in ELF, some of that same unwind-table data is used by libunwind to actually drive the stack unwinding, but we don't
use that in wasm. So our DWARF is less tightly-coupled than it is in ELF. I agree that most of the stuff under disagreement is pretty
orthogonal to what we have.

* LI: I'm a bit concerned about the disagreement more generally since these overall schemes seem to be a blocker for the thing we really want
for Erlang, which is stack switching.

* DS: Yeah, that's definitely part of the different visions, and it would work differently in each.
I guess one interesting difference is that Ross's version also includes a way for frames to opt-in to expose locals to a stack walker.
We've been assuming the debugger gets special APIs out-of-band to expose locals, but using marking could allow implementing a debugger
in user code.

* Wouter Van Oortmerssen: Yes, or you could even imagine not using a heavyweight interactive debugger, but just having a library that
walks the stack and formats and dumps all the information about the stack and its contents, and saves it somewhere, to allow manual inspection.

* DS: Yeah, that's similar to what you might want for more comprehensive crash dumping as well. So that might be an advantage of that kind of
scheme.

* DS: Unrelated: we've gotten reports of missing debug info in optimized builds. It would be good to get some reproducers for that so we can
find out if it's happening in LLVM IR, or in the wasm backend, or in Binaryen

* Paolo Severini: I saw it at least once where it was before Binaryen.


* DS -> Action item to prepare some kind of summary of how we are doing 
* PS (and/or Philip Pfaffe?) -> Action item to (eventually) send a reproducer of missing debuginfo.
"
gc/2022/GC-09-06.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 6 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: September 6, 5pm-6pm UTC (September 6, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion: Cast operations (https://github.com/WebAssembly/gc/issues/274)
1. Closure

## Meeting Notes

### Introduction of attendees

- Thomas Lively
- Conrad Watt
- Rick Battagline
- Justin Michaud
- Alon Zakai
- Francis McCabe
- Slava Kuzmich
- Yulia Startsev
- Matthias Liedtke
- Adam Klein
- Asumu Takikawa
- Luke Wagner
- Zalim Bashorov

### Discussion: Cast operations (https://github.com/WebAssembly/gc/issues/274)

TL: Recap GitHub discussion so far. Three sub-discussions: Casting directly from any, factoring opcodes to be future, nullability. Manos, would rolling control of non-nullability into the casting instructions have any performance benefits in the code sequence emitted by the engine?

MK: Don’t think so, but would have to look deeper.

(No opposition to being able to cast directly from any)

(No opposition to having a single cast instruction targeting any abstract or user-defined type, even if it did not correspond 1:1 to a future cast instruction using RTTs.)

ZB (chat): Can internalized externref interfere with casting from anyref to any user's type?

TL: No, the most specific type of an internalized externref is `any`, so all downcasts would fail.

CW: We also might want a subtype of any specifically for internalized extern. But might be weird when roundtripping a Wasm value via a Wasm function that takes “internalized externref” as a parameter.

TL: If we had such a type, the roundtripping should probably trap on the implicit downcast.

CW: Agree, but thinking about this I realize it’s too weird and I am against adding such a type.

#### A concrete example motivating explicit RTTs

CW: Could have self-type quantifier on struct definitions so that method receivers could be specially marked as method receivers and “unwrapped” via a new cast-like operation that would use explicit RTTs to recover the specific type of the method receiver.

RH: Don’t quite understand the use of existential types for method receivers. Would be good to have a concrete write-up in Wasm terms.

CW: Can see if Andreas is interested in writing that up.

### Progress toward phase 3

FM: How far away are we from phase 3?

TL: We’ve made good progress since phase 2. About four large issues left to settle (casting, JS API, making array.new_data and array.new_elem constant, and possibly pushing i31 to post-MVP). If we keep up our velocity, maybe we can be ready for phase 3 around November?
"
wasi/2020/WASI-02-27.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the February 27 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: February 27, 17:00-18:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Proposals and discussions
    1. Whole-program LTO coming:
        - https://github.com/WebAssembly/tool-conventions/pull/134
    1. Frame-buffer API:
        - https://github.com/WebAssembly/WASI/pull/229
        - The process for designing and submitting new API proposals is still being
          figured out, so in addition to the proposal, let's also talk about what we can
          do to make the process easier.
    1. Crypto API!
        - https://github.com/WebAssembly/WASI/pull/231
        - What criteria should we apply?
        - We can also talk about process.

## Meeting Notes

Attendees:

Dan Gohman
Mark McCaskey
Eric Rosenberg
Mark S. Miller
Peter Huene
Yury Delendik
Luke Wagner
Daiki Ueno
Johnnie Birch
Lee Campbell
Benjamin Brittain
Aaron Turner
Pat Hickey
Ralph Squillace
Sam Clegg


Meeting notes:

Whole-program LTO coming:
https://github.com/WebAssembly/tool-conventions/pull/134
Smaller binary size, optimization of combining libraries with Wasm binary (for example libc)
Frame-buffer API:
https://github.com/WebAssembly/WASI/pull/229
The process for designing and submitting new API proposals is still being figured out, so in addition to the proposal, let's also talk about what we can do to make the process easier.
Aaron: Idea: add a short and sweet markdown document laying out the steps for a proposal
Aaron: I wouldn’t mind writing this up. It’s already pretty much already in my PR. So it’s just cleaning that up and we would be good to go :)
Josh Triplett’s talk at Wasm SF was helpful, but a bit outdated even though it was only given a few months ago.



Crypto API!
https://github.com/WebAssembly/WASI/pull/231
What criteria should we apply?
We can also talk about process.
Being developed to support running wasm within a trusted execution environment, but intending this crypto API to have broader use cases.
Enarx: https://github.com/enarx/enarx/wiki
Prerequisite for sockets support
Lots of interest in sockets support.
Sockets dependency on merging read/write with send/recv?
Don’t over-rotate on POSIX.
How much appetite should we have for prototyping?
Feature flags are a great way to support this
Declare ahead of time what the process is.
Maybe it’s ok to use alternate names, as long as we document what’s going to happen. And maybe use polyfills to ease transitions.
Action item: Dan to write up a brief README for how to prototype a new feature. Also add things to watch out for.
Separate experimental repo? Directory? Maybe just put features in ephemeral/snapshot 
Back on read/write - we don’t want to over-rotate on POSIX, but we do want a general read/write? We are heavily influenced by POSIX here.
"
wasi/2020/WASI-04-09.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the April 9 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: April 9, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Proposals and discussions
    1. Moving to a CG-style phases process:
       https://github.com/WebAssembly/WASI/pull/252
    1. Proxy-wasm
        1. Vote: approve for Phase 1 (see previous item)?
        1. Discussion: Next steps.

## Meeting Notes

Agenda: https://github.com/WebAssembly/WASI/blob/master/meetings/2020/WASI-04-09.md

Attendees:

Dan Gohman
Lee Campbell
Yury Delendik
Jacob Mischka
Andrew Brown
Mark McCaskey
Matthew Fisher
Radu Matei
Piotr Sikora
Pat Hickey
Benjamin Brittain
Johnnie Birch

Meeting notes:
Moving to a CG-style phases process: https://github.com/WebAssembly/WASI/pull/252
LC: What should be the expectations for wasi-sdk and/or other toolchains when a feature is stabilized?
DG: witx support will help wasi-sdk, Rust, and others adopt to new APIs
PH: witx is written in Rust, we’re happy for people to implement it in other languages as well. Currently it just emits markdown docs. Wasi-libc has a C header generator.
LC: witx becomes the ABI standard, “bytes on the wire”. Clients may have higher-level abstractions. The ABI is where the stability is. Applications may link against different versions of higher-level abstraction layers, but as long as the ABI layer is stable they can run on ABI-conforming implementations.


Proxy-wasm
Vote: approve for Phase 1 (see previous item)?
Result - approved, unanimous

Discussion: Next steps.
Piotr to split out pieces of the spec which can be considered independently.

Discussion: Threads in APIs
https://github.com/WebAssembly/threads/issues/138
LC: It’d be nice to start thinking about thread safety and which APIs are thread-safe.
BB: Function signatures are typically not sufficient to know if something is thread-safe.
LW: The “is shared” predicate needs to be propagated through APIs. Everything is unshared by default. We need a shared attribute for tables, etc., and we’d need to have the shared attribute on functions to make them shared.
Without the shared attribute, functions can only be called from one thread.
The shared attribute for functions would need to be added in the core wasm spec, and then witx, being based on core wasm, would inherit it.
LW: Part of adding threading support sufficient for WASI would require adding a thread-local storage mechanism.

Discussion: mmap
LC: What is the short-term plan for mmap?
DG: On the web, mmap is complicated by web compat. But WASI can pursue this.
LW: FWIW, https://github.com/WebAssembly/design/blob/master/FutureFeatures.md#finer-grained-control-over-memory is a long-standing thing we’ve said we’ve wanted in the wasm CG, but maybe it’s better solved by WASI

LW: I can put together a proposal for a platform-independent mmap interface.
"
main/2019/CG-08-20.md,"
![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 20th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: August 20th, 4pm-5pm UTC (August 20th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    2. Share SIMD 64x2 benchmark results (https://github.com/ngzhian/simd-benchmarks) ([slides](https://docs.google.com/presentation/d/1WNtU2VZuKSAx-RHwsFlZH-rrWiuf4BiAp4GK8CiolkA))
    3. Replacement for ""☃ Bindings"" ([webidl-bindings/#47](https://github.com/WebAssembly/webidl-bindings/issues/47))
       ([slides](https://docs.google.com/presentation/d/1l93PWXlFZOUP6DZouknNM41sVyfPfFYXhqebqiNLdtw))
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
Luke Wagner

Sam Clegg

Sven Sauleau

Derek Schuff

Shravan Narayan

Michael Starzinger

Arun Purushan

Dan Gohman

Bill Ticehurst

Rich Winterton

Flaki

Zhi An Ng

Alex Crichton

Jacob Gravelle

Ryan Hunt

TatWai Chong

Paul Dworzanski

Lilit Darbinyan

Jay Phelps

Ross Tate

Kieth Miller

Francis McCabe

Pat Hickey

Heejin Ahn

David Piepgrass

### Proposals and discussions

#### Share SIMD 64x2 benchmark results ([slides](https://docs.google.com/presentation/d/1WNtU2VZuKSAx-RHwsFlZH-rrWiuf4BiAp4GK8CiolkA))

Zhi An Ng presenting results. 

PP: How can we share benchmarks?

Z: Benchmarks can be shared by creating an issue on the repository. 

PP: Mersenne Twister seems to work out of the box

#### Replacement for ""☃ Bindings"" ([webidl-bindings/#47](https://github.com/WebAssembly/webidl-bindings/issues/47)) ([slides](https://docs.google.com/presentation/d/1l93PWXlFZOUP6DZouknNM41sVyfPfFYXhqebqiNLdtw))

Luke Wagner presenting slides.

LW: Has been discussed on our bindings video chats but we wanted to bring the results to the CG.

Poll: rename the proposal to “Interface types”

FM: is it possible to have a space in the name?

LW: we use a hyphen, for convention on github

RT: Interfaces are between different things. It sounds like this is for interop between wasm and other systems. Would something like “interop type” be more specific?

LW: that was one of the things we discussed.

RT: sounds good, let’s not repeat it.

| SF | F | N | A | SA |
| - | - | - | - | - |
| 7 | 10 | 1 | 0 | 0 |

RT: been talking with our researchers. If we get the CG proposal done, every memory access will be safe. So we’re interested in hardware improvements if we know we have this property. Is anyone exploring this already?
Currently there’s a lot of stuff to guard against bad memory accesses. GC would have the property that every access is guaranteed safe. So you could remove HW protections if you have this guarantee.

RW: I’d be interested in understanding more. I’m not exactly clear on the specifics yet.

RT: We’ll include you

PP: I’m interested too

DP is interested also.

### Closure
"
simd/2024/SIMD-04-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the Apr 12 video call of WebAssembly's SIMD Subgroup

- **Dates**: 2024-04-12
- **Times**:
    - 4pm-5pm UTC (9am-10am PDT)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Petr Penzin
    - Email: penzin.dev@gmail.com


### Registration

Fill out [sign-up form](https://forms.gle/bscWhsD9U4hZEsUV9) to attend.

### Logistics

This meeting will be a Google Meet video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking
1. Adoption of the agenda
1. Proposals and discussions
    1. Update and discussion on fp16 support (Ilya Rezvov, 30 min)
1. Closure

## Meeting notes

Logistics: is this still a good time slot for everybody? Maybe we should file an issue on the meetings repo to solicit feedback (suggestion: DG).

### Attendees

Anton Kirilov
Deepti Gandluri
Ilya Rezvov
Petr Penzin
Shravan Narayan
Thomas Lively
Yury Delendik

### Update and discussion on fp16 support

Ilya Rezvov presenting https://docs.google.com/presentation/d/11Q_DQoy2Cv3kx4s6C-Atk3qcYBfL1YiHLYGMyWc63Ks/edit?usp=sharing

PP: this is IEEE FP16, right?

IR: yes

PP: Loading FP16 would not add any operations on the value?

IR: It is a converting load, it would load f16 and convert it to f32

AK: Did you discover any scalar operation that doesn’t have a vector equivalent? This doesn’t invalidate your main point though

IR: Not sure, I might have missed it, mostly vectors

AK: https://developer.arm.com/documentation/ddi0602/2024-03/SIMD-FP-Instructions/FADD--scalar---Floating-point-Add--scalar--?lang=en

DG: Platforms are moving to supporting FP 16 (AVX10 is coming to x86 too), maybe eventually we can reconsider, but for now limiting it to vector operations makes sense

PP: AVX10 is also going to be a SIMD instruction set, it makes sense to focus on SIMD

DG: Float16Array is going to propose a new rounding mode for FP64->FP16 conversion, we should watch how that plays out

PP: On scalar vs vector, would implementing SIMD emulation also be a pretty large change?

IR: It is pretty complex as well, but it is well worth it because it would enable new workloads and bring performance close to native

(PP, side note: later in the deck there was an estimate for that effort and it is lower than the scalar)

DG: SIMD performance is lower comparing to native than it used to be because native performance increased, often because of new instructions, but Wasm hasn’t kept up

PP: We have some gaps in the toolchain, though that would only help the baseline. We should probably consider standard fallbacks for new operations

DG: I wish the standard fallback existed

PP: There was a proposal to support fallbacks via expressing new virtual instructions in terms of old ones

DG: This might be hard on some platforms because there are less variety of approaches to implement fallback (ex: x86 has multiple SIMD extensions, while Arm has less flexibility)

DG: we encourage people to file issues on the proposal repo for discussions

IR: plan to go to phase 2 once discussions settle down

"
stack/2023/stack-2023-09-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 11th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  September 11th, 16:00-17:00 UTC ( September 11th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Zalim Bashorov
Francis McCabe
Sam Lindley
Ross Tate
Frank Emrich
Luke Wagner
Adam Klein
Benjamin Titzer
Daniel Hillerström
Brendan Dahl
Ilya Rezvov
Thibaud Michaud
Thomas Lively

## Agenda items

This meeting was recorded, recording [here](https://us02web.zoom.us/rec/share/P-HxZvwy3G3F9vZ8uhYCx0hKMABtMEnMFti7niwIjhkXd6Sv8jPomhcENb-y3rIb.0UFV4K2RaFOH_rVN)

1. Stack Switching Coroutines (Francis McCabe) Slides available [here](https://docs.google.com/presentation/d/1jCtYnNrQFD2EseYc0KKaNi6KeLtckeemUZfD_eljStY/edit?usp=sharing) Draft explainer available [here](https://gist.github.com/fgmccabe/afe8bdfdf2ffdc94d69252683f376d15)




### Adoption of the agenda

### Discussion


Raw Chat log:

*	Sam Lindley:	https://docs.google.com/document/d/13raLPzB4vRxnzmjezCIN-AFjsT4rGDK7l7rdHDdi75g/edit
*	Thomas Lively:	""As low level as possible, but no lower""
*	Luke Wagner:	Reacted to """"As low level as pos..."" with 👍
*	Benjamin Titzer:	I found that NANDScript was maybe too low? 🙂
*	Benjamin Titzer:	Thinking more in the background, could this proposal be loosened so that you can only switch to a suspended stack (not a moribund or running one)?
*	Ross Tate:	That’s already its semantics; if you try to switch to a non-suspended stack, you trap.
*	Benjamin Titzer:	I guess my question is, is the cont reference you get from being switched to a unique one or just reused (and passed for convenience)
*	Thomas Lively:	They're one-shot IIUC
*	Ross Tate:	My understanding is that it’s “fresh” and it’s “single shot”.
*	Zalim Bashorov:	https://gist.github.com/fgmccabe/afe8bdfdf2ffdc94d69252683f376d15
*	Thomas Lively:	They are continuations and they are delimited (in some sense) but they may not be ""delimited continuations""
*	Ross Tate:	There are losses: it requires either boxing/gc or closed-world compilation when other proposals would not. This is not due to “delimitation”, but due to its switching model.
*	Thomas Lively:	@Luke, the big trade off for the simplicitly is the extra complexity and no ""automatic"" composability for compilation schemes and ABIs for situations where separate source-level features need to be supported simultaneously via stack switching.
*	Sam Lindley:	technically all continuations are ultimately delimited, but for this delimitation to be useful we need a way of composing such continuations which one cannot have with a bag of stacks approach - think a way of splicing stacks together
*	Daniel Hillerström:	every continuation is delimited, even the undelimited ones (the delimiter is at the top of the program), however, what people mean when they say delimited continuations is really composable continuations. Composable continuations have a particular definition
*	Luke Wagner:	@Thomas Lively yeah, I can see that.  Still, I wonder if this is just “business as usual” when you design the ABI for your language
*	Thomas Lively:	That's definitely a good question. Will want to hear more from language teams to answer it.
*	Daniel Hillerström:	informally, composable continuation means that the invocation of the contiunuation splices the captured context with the current execution context.
*	Thomas Lively:	Reacted to ""informally, compos..."" with 👍

### Adjourn
"
wasi/2023/WASI-02-23.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: February 23 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: February 23, 17:00-18:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. New proposal: wasi-cli: A command-line interface world
        1. https://github.com/WebAssembly/WASI/issues/509
        1. Any initial feedback?
        1. Vote: Approve for Phase 1?
    1. Vote on wasi-sql-embed Phase 1

## Notes
### Attendees
- Lin Clark
- Kyle Brown
- Sam Clegg
- Joel Dice
- Kevin Moore
- Brian Hardock
- Colin Murphy
- Jeff Charles
- Jesse Wellenberg
- Ivan Font
- Kate Goldenring
- Emiel Van Severen
- Carlo Piovesan
- Chinmay Garde
- Ralph Squillace
- Antoni Bofarull
- Chris Suszynski
- Yong He
- Andrew Brown
- Dan Gohman
- Sébastien Deleuze

### wasi-cli proposal to Phase 1

**Dan Gohman**: This is a proposal to vote for Phase 1 for WASI CLI world. Moving to a format where we have a wit file, and then dependencies are vendored in. The deps dir would serve purpose of collecting everything in the cli world.

There’s a sketch in the issue linked in the agenda of what this world will look like. Some things will change, but that’s appropriate for phase 1.

**Lin Clark**: Vote. Any objection? No. Congrats on another proposal!

### wasi-sql-embed proposal to Phase 1

**Kyle Brown**: Compile something to run in database, UDFs, types. Describes how the types map, how you define. Will find links to sketches. Any questions, any one not familiar?

**Lin Clark**: Vote. Any objections? No. Congrats on your new proposal!

**Carlo Piovesan**: Question. One very minor bit of feedback: I’m not sure whether layering a bit more would allow to move faster. Seems that the scope is very wide.

**Kyle Brown**: Yes, scope of it is large. A number of different types we’re interested in. Might phase it within the proposal. May do more piece by picee. Original proposal has a sketch for all of it to demonstrate the scope.

**Carlo Piovesan**: SEems to be lots of material. Perhaps a subset coule be shipped earlier.

**Kyle Brown**: Definitely reasonable and can address the meta concerns.

### Open questions/announcements

**Andrew Brown**: WASI threads blog post

**Antoni Bofarull**: Hi! Is anyone planning to design a wasi interface for image processing?

**Lin Clark**: None in progress on proposals page. Any one in the room working on one? Looks like no
"
wasi/2024/WASI-06-27.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: June 27 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: June 27 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Yosh Wuyts: Releasing non-breaking WASI versions (vote on release cadence)

## Notes

### Attendees

- Bailey Hayes
- Sean Isom
- Nick Fitzgerald
- Colin Murphy
- Sehyo Chang
- Marcin Kolny
- Alex Crichton
- Hung-Ying Tai
- Maximilian Seidler
- Dave Bakker
- Fedor Smirnov
- Andrew Brown
- Kate Goldenring
- Emily Ruppel
- Mike Warres
- Stephen Berard

###  Releasing non-breaking WASI versions (vote on release cadence)

**Bailey Hayes** Yosh Wuyts has given a series of presentations to this subgroup on how we can release non-breaking WASI versions for 0.2. He is not able to be here today so I will be presenting. This is something Yosh has collaborated with several folks to find the right balance of features proposal champions are seeking to make as well as facilitate consensus with the right amount of process. Thank you Alex, Dan, Pat, Luke, and likely others that Yosh collaborated with to create this proposal today.

 **Bailey Hayes** Last meeting, Yosh proposed that amendments to existing proposals begin at phase 2 behind an @unstable gate.

**Bailey Hayes** For past presentations, see: https://github.com/WebAssembly/meetings/blob/main/wasi/2024/presentations/2024-05-30-yosh-wuyts-leveraging-since-unstable-gates-in-wasi.pdf and https://github.com/WebAssembly/meetings/blob/main/wasi/2024/presentations/2024-06-13-yosh-wuyts-progressing-proposal-changes-through-the-phase-process.pdf

Purpose:
Fixing bugs
Adding new worlds
Evolving existing worlds
Updating documentation

A new WASI patch should be released every 2 months, targeting Aug 1 for the first.
WASI 0.3.0 is intentionally out of this scope. This applies only to additive, non-breaking changes.

Proposed cadence example:
8/1/2024 WASI 0.2.1 is released
9/5/2024 Timezones is voted to progress to phase 3
10/1/2024 WASI 0.2.2 is released with timezones.

If there are patch releases with no features, they will still be released, but that may indicate we should release less often.

This is an alternative to feature-based releases which are individually voted on and released. This is not recommended because it introduces negative incentives to delay votes in order to add features.

This is the establishment of an incremental process, where there wasn’t one before. 

This proposal was passed by a consensus vote.

SF: 15
F: 9
N: 1
A: 0
SA: 0
"
wasi/2024/WASI-04-04.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: April 04 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: April 04 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Vote: Advance `wasi-i2c` proposal to Phase 2
    3. _Submit a PR to add your announcement here_

### Attendees

- Bailey Hayes
- Luke Wagner
- Colin Murphy
- Friedrich Vandenberghe
- Dave Bakker
- Kevin Moore
- Marcin Kolny
- Joel Dice
- Hung-Ying Tai
- Stephen Berard
- Yong He
- Merlijn Sebrechts
- Dan Phillips
- Zalim Bashorov
- Slava Kuzmich
- Nuno Pereira
- Ralph Squillace
- Warre Dujardin
- Johnnie Birch
- Till Schneidereit
- Jorge Prendes
- Ashok Kumar Krishnamoorthy
- Taylor Thomas
- Wouter Hennen
- Fedor Smirnov
- Robin Brown

### I2C implementation 

**Friedrich Vandenberghe**
https://github.com/Zelzahn/i2c-wasm-components
Running implementations
https://crates.io/crates/wasi-embedded-hal
https://github.com/Zelzahn/wasi-i2c

**Bailey Hayes**: Microcontroller might be a bit vague in the proposal

**Chris Woods**: Let’s have a definition of this

**Friedrich Vandenberghe**: Raspberry Pi Pico

**Robin Brown**: ESP32

**Till Schneidereit**: is a Cortex M0+ too big?

**Emily Ruppel**: M0+ is one of the smallest ARM configuration. Which microcontroller might not be the right way to frame, instead we could focus on which OS. Perhaps WAMR or Zephyr

**Thomas Trenner**: Zephyr is reasonable.

**Stephen Berard**: I think we should likely select a few reference platforms and agree on OS/board/HW config. We should agree on a Dev board, OS, and HW configuration. Should be something small, much smaller than Cortex A53.

**Friedrich Vandenberghe**: Will file Github issue. Define portability criteria. See https://github.com/WebAssembly/wasi-i2c/pull/5

**Bailey Hayes**: Is there a use case proposal?

**Thomas Trenner**: UART and similar spaces

**Bailey Hayes**: Let’s keep the discussion going in the Github issue.

**Till Schneidereit**: Since at least some of these microcontrollers have the option to run without one: would people see it as a requirement to run without an MPU as well?

**Ralph Squillace**: Matrix of platforms, OSes, and configurations would be useful.

**Robin Brown**: Github discussions might be better suited than an issue.

**Bailey Hayes**: The proposal champions will decide if they will use discussions or issues. Decision to delay the vote until portability criteria is defined. 
    
"
stack/2022/12-19-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 19th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  December 19th, 17:00-18:00 UTC ( December 19th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Ross Tate
Thomas Lively
Adam Klein
Brendan Dahl
Sam Lindley
Ilya Rezvov


## Agenda items

1. Retrospective 2022 [Slides](https://docs.google.com/presentation/d/1d4nxBZDz3zjnuoHfXkLb-cwiBTsWQ4Ynktbn7KaIW1k/edit?usp=sharing)


## Meeting Notes

SL: Also looking forward to Daniel and Luna’s work on an implementation in Wasmtime and getting performance feedback from them.

FM: I don’t disagree. Luna is presenting next month. We do need to go fast because Kotlin and Dart are making business decisions about whether to use core stack switching maybe within the next 6 months. Don’t want to spend too much time experimenting.

TL: I’m looking forward to getting the production JSPI implementation in V8 so we can experiment with different core stack switching “front ends” on top of that in a real production environment. Demonstrating progress is almost as important as actually finishing.

FM: What kind of presentations do we want next year?

TL: I’d like to see more design space explorations like we had at the F2F meeting. It would be good to get everyone to understand all the pros and cons of different designs to understand where each other is coming from, even if we don’t agree.

BT: I’d like to zoom in and see implementation-level details for different designs.

SL: Will you be able to implement it in Wizard?

BT: Yes, probably this summer.

TL: I’d also like to get a Binaryen implementation in place so Dart and Kotlin can experiment with it.

SL: Do Dart and Kotlin depend on Binaryen?

TL: For their optimizations, yes.

FM: Dart is using JSPI for generators and async functions. Would be good to get them using a Wasm-only library that “implements” JSPI without promises.

SL: OCaml 5 has full stack switching with no new language constructs, just an API. It’s a little clunky to use, but that’s deliberate to allow future flexibility to design new language primitives for it. Not sure how that translates to WebAssembly. Could we spec an API? Not sure how to think about the trade off between new instructions and new APIs.

TL: Downside of specifying instructions is that it takes forever and requires consensus, etc. Downside of specifying an API is that it’s not possible because there’s no process for that. The closest thing is WASI, which doesn’t exist in browsers.

BT: Also, new control flow needs new instructions because you can’t pass labels via APIs.

SL: Sounds like the API isn’t worth exploring.

BT: Implementing an API doesn’t require anything new in the engine, so it’s not useful for learning anything.

FM: On the other hand, JSPI does require changes in the engine.


### Adoption of the agenda

### Adjourn

"
wasi/2024/WASI-05-16.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: May 16 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: May 16 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Discussion and Vote: Advance `wasi-i2c` proposal to Phase 2
    1. _Submit a PR to add your announcement here_
## Notes
### Attendees

- Bailey Hayes
- Colin Murphy
- Pat Hickey
- Nick Fitzgerald
- Michael Warres
- Marcin Kolny
- Mendy Berger
- Chris Woods
- Jeff Charles
- Zalim Bashorov
- Hung-ying Tai
- Wouter Hennen
- Luke Wagner
- Yong He
- Radu Matei
- Robin
- Dan Gohman
- Oscar Spencer
- Dave Bakker
- Marcin Kolny
- Merlijn Sebrechts
- Frank Denis
- Chris Woods
- Stephen Berard
- Thomas Trenner
- Emily Ruppel
- Yage Hu
- Joe Zhou
- Nuno Pereira
- Taylor Thomas
- Merlijn Sebrechts
- Trevor Elliott

## Discussion and Vote: Advance wasi-i2c proposal to Phase 2

**Friedrich** Presentation on wasi-i2c vote for phase 2. It's the second time we are here. We took feedback on our portability criteria last time - it was too vague. We came up with a more specific set of criteria. We have three operating systems, architectures, and reference hardwares - an exact device. We also added some constraints on how much RAM on the board we are allowing implementations to use, to make sure there is some available for applications. With these changes I believe all our feedback had been answered sufficiently for a vote.

**Bailey** You’ve already created one implementation, correct?

**Friedrich** I have created an implementation for Rasphery Pi 3 Model B. Maximilian from Siemens has created an implementation for Nucleo F412ZG that is not public, but hes working on it.

**Bailey** Implementations are not required for this phase but its good to see they are underway.

**Bailey** I saw discussion on github about the wit interface. That doesn’t have to be finalized for this phase, that should continue taking implementation feedback.

**Pat**: We are going to hold a unanimous consent vote. Please register your dissent now.

**Pat**: No dissent

**Pat**: wasi-i2c passes to phase 2. 
"
main/2024/CG-01-16.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 16th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: January 16th, 5pm-6pm UTC (January 16th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Announcement: Ben Visness as co-chapion for [memory-control proposal](https://github.com/WebAssembly/memory-control/tree/main) (Deepti Gandluri, 5 minutes)
    1. Announcement: Next Hybrid CG meeting in June 2024, post comments or constraints on [isssue](https://github.com/WebAssembly/meetings/issues/1463)
    1. Update and phase 2 poll for js-string-builtins (Ryan Hunt, 20 minutes)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees
 - Deepti Gandluri
 - Derek Schuff
 - Ashley Nelson
 - Heejin Ahn
 - Ryan Hunt
 - Nick Fitzgerald
 - Zalim Bashorov
 - Paolo Severini
 - Michael Ficarra
 - Fedor Smirnov
 - Robin Freyler
 - Nuno Pereira
 - Adam Klein
 - Manos Koukoutos
 - Alex Crichton
 - Yury Delendik
 - Jeff Charles
 - Kevin Moore
 - Emanuel Ziegler
 - Andrew Brown
 - Dan Phillips
 - Bailey Hayes
 - Johnnie Birch
 - Dan Gohman
 - Slava Kuzmich
 - Brendan Dahl
 - Mingqui Sun
 - Ben Visness
 - Richard Winterton
 - Mattias Liedtke
 - Oscar Spencer
 - Daniel Lehmann
 - Aura Munoz
 - Ilya Rezvov
 - Chris Woods
 - Francis McCabe
 - Yuri Iozzelli

### Proposals and Discussions

#### Announcement: Ben Visness as co-champion for [memory-control proposal](https://github.com/WebAssembly/memory-control/tree/main) 

#### Announcement: Next Hybrid CG meeting in June 2024, post comments or constraints on [issue](https://github.com/WebAssembly/meetings/issues/1463)

#### Update and phase 2 poll for js-string-builtins (Ryan Hunt, 20 minutes)

RH Presenting [slides](https://docs.google.com/presentation/d/1gbyQz0nbLJJ07lbi8iuLHSchQ2-fH29UXS5ebLnG0ZU/edit#slide=id.g1ef40614c6f_0_21)

AK: on WTF-8: It's unclear whether this is something we’ll need in the medium/longterm,but agree it makes sense not to have wasm be the place where we define this, so from spec maintenance perspective it makes sense, and based on talking to users, there doesn’t seem to be immediate need, but we’d like to hear from anyone who does know of a particular need.

RH: If we needed to add it at a later point, in terms of other proposals we’ve done non-trivial changes before. We have consensus on the core parts of the proposal

DG: Can pause to see if anyone has concerns about moving forward to phase 2?

<none>

DG: since phase 2 requirements are higher, we can do a full poll

|SF|F|N|A|SA|
|--|-|-|-|--|
|17|11|4|0|0|

Consensus is reached to move to phase 2.

### Closure
"
main/2018/WG-08-15.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 15 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: August 15, 2018 at 3pm-4pm UTC *( August 15, 2018 8am-9am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Should we push a new Working Draft? (binji@)
       * It's been ~5 months since the FPWD.
       * [Changes since then](https://gist.github.com/binji/147ffc9e1a0f575024d087b91f7abf91)
       * We need to update the WD before we can push to CR.
       * What spec issues do we need to resolve?
1. Future meetings
    1. Confirm next meeting date + time.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Ben Smith
* Conrad Watt
* Jacob Gravelle
* Keith Miller
* Luke Wagner

### Find volunteers for note taking (chair to volunteer).

Ben takes notes

### Adoption of the agenda

### Proposals and discussions

#### Should we push a new Working Draft? (binji@)

  * It's been ~5 months since the FPWD.
  * [Changes since then](https://gist.github.com/binji/147ffc9e1a0f575024d087b91f7abf91)
  * We need to update the WD before we can push to CR.
  * What spec issues do we need to resolve?

Discussing working on a working draft.

Ben: We should put out a Working Draft. We need to include substantive changes and a public record of the WG recommending a new WD. I’ve included the changes for the core spec in this gist (above).

Luke: How did you compile the diffs?

Ben: The w3c has a html diff tool, I looked through manually to find the diffs. Mostly typographical and small bug fixes. Big change was adding mutable globals.

Ben: We also are supposed to put out a new draft every 6 months, so this would be good timing for that. Do we have unanimous consent to put out a new WD?

[unanimous consent]

Keith Miller: Any opposition to moving this meeting to 9am PST? It would be better for me, but perhaps it’s better for Europeans at this time?

Ben: It would be better for me too. I’ll send out an email to the announce mailing list with the new time, asking whether it works for others too.

### Closure
"
main/2018/CG-11-27.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 27 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: November 27, 5pm-6pm UTC (November 27, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email Ben Smith to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Ben Smith
* Ben Titzer
* Deepti Gandluri
* Derek Schuff
* Francis McCabe
* Jacob Gravelle
* Limin Zhu
* Michael Holladay
* Nick Fitzgerald
* Pat Hickey
* Sam Clegg
* Sergey Rubanov
* Sven Sauleau
* Tyler McMullen
* Ulrik Sorber
* Yury Delendik

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

### Proposals and discussions

#### Review of action items from prior meeting.

SS: I opened an issue that I'd like to discuss. https://github.com/WebAssembly/spec/issues/915

SS: There is WebAssembly.Module.customSections it returns the custom sections
with those bytes. The names are encoded in utf8, which is specified in the wasm
spec. There is an API that uses a separate decoder. It looks like that whatwg
decoder has special rules. I found some tests that are linked in to the issue.
From the wasm point of view it is one section, from the JS point of view it is
two sections.

BS: It has to do with how to handle the replacement character?

SS: Yes.

BS: So the question is how to resolve?

SS: It's inconsistent. You have to add special rules.

BT: What you're saying that the decoding of wasm is different than the JS one?
Or all others?

SS: Just the JS one.

BS: So the WhatWG decoder converts 0xdc01 to 0xfffd?

SS: They are both way higher than the upper bounds, so they should be equal.

BT: Do you know if the implementations don't match this?

SS: Yes, v8 doesn't pass.

BT: We can do the same thing to match JS and wasm interpretation.

BS: I think this may be a JS thing vs a web thing.

BT: Ok I think this may require follow-up offline.

AI(SS): follow up on the GH issue.

Closure

### Closure
"
debugging/2020/debugging-10-01.md,"# Meeting notes for the October 1 video call of WebAssembly's debugging subgroup

- **Where**: zoom.us
- **When**: October 1, 11am-11:30 Pacific Daylight Time (July 23, 6pm UTC, 8pm CEST)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Derek Schuff
    - Email: dschuff@google.com
    
## Attendees
Luke Imhoff, Philip Pfaffe, Derek Schuff, Paolo Severini, Wouter Van Oortmerssen, Alon Zakai 

## Notes 

DS: Zoom now requires either a password or a waiting room (or both) on all meetings (currently we use neither). 
Going without a waiting room is convenient because people can join before the host (or meet without the host),
so it might be better to add a password, and update the calendar invite to use a URL which embeds the password
(that way people won't actually have to type it). **I'll update the invitation with a new meeting URL**, please let me know if you don't
get a notification.

DS: Update on debug info in LLVM. The initial patch for split-dwarf (aka dwarf fission, aka -gsplit-dwarf)
is landed in LLVM. Based on initial basic testing, it seems to work, and is hopefully ready to experiment
with in a debugger. I also found out about Type Units (aka [debug types sections](https://fedoraproject.org/wiki/Features/DebugTypesSections),
aka -fdebug-types-section), which moves type information from .debug_info into an ELF COMDAT, allowing
the linker to deduplicate it. I experimented with a Linux build of Clang and found it reduced debug
info size by ~40%, so it seemed worth investigating. Since wasm comdats work like ELF, we could try it
for wasm. I uploaded a [patch](https://reviews.llvm.org/D88603) to enable it for wasm.
Question: do we know whether lldb supports it out-of-the-box?

PS: I can check on that

DS: I'm also curious why it's not just the default on Linux. Maybe because it slows down linking?
(the above link does seem to indicate that Fedora enabled it for all of their debuginfo packages)

Other discussion:
LI: Is anyone attending the virtual LLVM developer meeting? (DS is). I'm interested in the tutorials.
Mostly for Elixir when we use LLVM we end up jsut looking for prior solutions 
to the partiucular problem we're looking to solve, but sometimes we find e.g. a completely different
API that we didn't know about, or violate some assumption about the IR further down the pipeline and
don't always know how to deal with it.

DS: are you using the C or C++ API?

LI: we were using a Rust wrapper, but the maintainer had trouble keeping up with LLVM's API churn.
Now we mostly use the C++ APIj.

DS: Yeah, the C++ API makes no attempt to be stable, but always has full functionality, whereas
the C API has sort of best-effort stability but sometimes lags behind.
"
stack/2020/SG-11-02.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 2nd video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**: November 2nd, 17:00-18:00 UTC (November 2nd, 9am-10am Pacific Standard Time)
- **Location**: *link on calendar invite*


## Participants
Francis McCabe
Ioanna Dimitriou
Alon Zakai
Derek Schuff
Ross Tate
Rick Battagline
Sam Lindley
Emanuel Ziegler
Luke Imhoff
Luke Wagner
Sam Clegg
Daniel Hillerström
Paul Dworzanski
Asumu Takikawa
Zalim Bashorov
Petr Penzin


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. [Stack Mechanisms]() (Ross Tate) [27 mins]
   1. [Stack Policies]() (Ross Tate) [27 mins]
   1. Call for presentations [3 mins].
1. Closure

## Meeting Notes

Note: Luke Wagner is presenting an interface types update at the next SOIL seminar

RT's slides on Stack Mechanisms: [(pdf)](presentations/2020-11-02-tate-stack-policies.pdf) [(pptx)](presentations/2020-11-02-tate-stack-policies.pptx)

RT: Dynamically scoped variables as a gateway to looking at stack mechanisms
RT: Implementation strategy #1: global variable
RT: Strategy #2: pass mutable dictionary of variables
RT: Strategy #3: Pass immutable dictionary
RT: WebAssembly challenges
RT: Interop with host
RT: Extensions for algebraic effects
RT: Stack marking
RT: Strategy #4: Use code ranges to find marks on stacks. Lazy
RT: Strategy #5: Use a dictionary with each stacklet. Eager
RT: Dynamic scoping is not a low-level primitive (too many choices for implementation)
RT: Stack walking is a primitive
RT: Red Flag: policy
AZ: Can’t you use a shadow stack instead of adding a special feature for stack walking
LW: Arbitrary stack switching may get scrambled when you are crossing ABI boundaries
SL: What happens if dynamic scoping is already implemented using another feature? E.g., dynamic scoping can be implemented using effect handlers or other control operators. What is your primary concern?
RT: Efficiency is a concern: there are 5 identified strategies for dynamic scoping

RT: Stack Policies presentation
RT: Policies for interop across Wasm ecosystem
RT: Stack unwinding policies
RT: Sandboxing vs Unwinding
RT: Trap causes required unwinders to be skipped as well as untrusted unwinders
RT: Can we infer privilege
RT: Basic questions about policies

LW: If the sandboxing goes wrong, what about the non-stack state. What about the mutable state? 
Use a larger unit - component/store.
Concept of a ‘blast zone’ to predefine sandboxing.
RT: Looking for privilege concepts
LW: Firefox added a hard blast zone to avoid leaks of information
SL: Do you want a blast zone for each green thread? How expensive are they?
LW: Web workers are expensive
RT: Need to access all GC roots 
LW: Some thinking about managing TLS memory.
LI: Stack based security has some attack scenarios
LW: 

### Adoption of the agenda

### Discussion:


### Closure

"
benchmarking/2024/benchmarking-02-23.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 23rd of WebAssembly's Benchmarking Subgroup

- **Where**: Google Meet
- **When**: February 23rd, 4pm-4:45pm UTC (8am-8:45am PDT, 11am-11:45am EST)
- **Location**: _Link on calendar invite_
- **Contact**:
    - Name: Petr Penzin, Saúl Cabrera
    - Email: penzin.dev@gmail.com, saul.cabrera@shopify.com


### Registration

If this is your first time attending, please [fill out the registration form](https://forms.gle/QCmhyM4QwvWvZR9b8) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

### Logistics

This meeting will be a Google Meet video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes
    1. Please help take notes.
1. Announcements
    1. Sightglass Presentation (Andrew Brown + Nick Fitzgerald)
1. Proposals and discussions
1. Closure

## Attendees
* Andrew Brown
* Saúl Cabrera
* Ben L. Titzer
* Nick Fitzgerald
* Ashley Nelson
* Ajay Chhokra
* Johnnie Birch
* Rahul 



## Meeting notes


### Sightglass Presentation

Slides: https://docs.google.com/presentation/d/1NCBCZB1YfUnXtXwYQKXeoVf5_KkYhKBMbOXD1WCHVlU/edit	

AC: Do you consider different compilation flags? The compilation optimization makes a difference.

JB: Try to use consistent flags, but also try to consider all flags. Generally an open question. There hasn't been a deep study to determine the upper bound.

AC: This is what we (Siemens) did. Compare the fastest Wasm code. Having the best or the fastest as the upper bound makes sense. 

AB: Would love to hear more details from Siemens. No special care is taken to hyper-optimize the Wasm for benchmarks.

JB: WasmScore. Built on top of Sightglass. Not try to compare to other runtimes, but to compare Wasm <> Native; to understand how good the Wasm is.

AC: (Analyzing benchmarks) Do you use a real time kernel to minimize jitter?

NF: These are intended to be run on regular developer machines. That's why statistical rigor is important. 

BT: Great presentation. Might be able to repeat calls to `bench_{start, end}`.

NF: That would be nice. More boring/dev x could be how do you configure most of the options from the CLI (sightglass). How to keep Sightglass usable with good defaults vs surfacing multiple options that are overwhelming. 

AB: There are many knobs currently.

NF: If users are trying to compare multiple engines via Sightglass then caring about those knobs becomes more relevant.

BT: Have you thought about engines that do dynamic compilation (lazy compilation)? 

NF: Sightglass is not oriented for JITs that have complex tiers. Might not be impossible, but would require a different design. V8/SpiderMonkey were included in Sightglass, through some settings around forcing eager compilation. 

AB: V8, using turbofan directly without going through the baseline tier.

BT: Reasonable if you're interested in the cost of moving between tiers.


"
main/2022/CG-02-15.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 15th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: February 15th, 5pm-6pm UTC (February 15th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Poll: Advance GC to phase 2 (Thomas Lively, 30 minutes)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees

* Derek Schuff
* Deepti Gandluri
* Saúl Cabrera
* Keith Winstein
* Jeff Charles
* Zalim Bashorov
* Nick
* Mingqui Sun
* Slava Kuzmich
* Ryan Nunt
* Rick Battagline
* Sam Clegg
* Alex Crichton
* Bailey Hayes
* Lars Hansen
* Yury Delendik
* Conrad Watt
* Alon Zakai
* Heejin Ahn
* Radu Matei
* Keith Miller
* Adam Klein
* Paolo Severini
* Richard Winterton 
* Manos Koukoutos
* Yuri Iozzelli
* Ioanna Dimitriou
* Emanuel Ziegler
* Johnnie Birch
* Jakob Kummerow
* Andreas Rossberg
* Shravan Narayan
* Francis McCabe
* Asumu Takikawa
* David Piepgrass
* Andrew Brown
* Oran Collins
* Sean Jensen-Grey
* Sam Lindley
* Sergey Rubanov




### Proposals and discussions

#### Advance GC to phase 2 (Thomas Lively)

TL Presenting [slides](https://docs.google.com/presentation/d/1RgdF3_QPV8jcZXl4PIl0HRlG38mzhdM_cFWKZDJyN8Y/edit?usp=sharing)

TL: Agreement on the type system is the one that’s inspired a year of debate and prototyping. It’s by far the biggest issue we’ve tackled. For this proposal, agreement on the type system should be the bar for the definition of phase 2 requirement

AK: What systems were those numbers from? In what codebase?

TL: J2CL module, on the left the optimized version of the module, on the right same module without optimization measurements come from doing canonicalization/ type building and validation in Binaryen

OC: <in chat> where does the 24k types number comes from?

TL: The optimized Java module, not sure what it does but it is a real world Java program that was compiled. optimized module was 10Mb 

AZ: the module was mostly runtime code required for a bunch of different benchmarks.



**POLL** GC proposal to Phase 2:

* SF: 21
* F: 11
* N: 5
* A: 0
* SA: 0



"
main/2018/WG-08-29.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 29 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: August 29, 2018 at 3pm-4pm UTC *( August 29, 2018 8am-9am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
1. Future meetings
    1. Confirm next meeting date + time.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Opening, welcome and roll call

####  Opening of the meeting

#### Introduction of attendees

* Ben Smith
* Ben Titzer
* Conrad Watt
* Gordon Aplin
* Ulrik Sorber

### Find volunteers for note taking (chair to volunteer).

### Adoption of the agenda

No agenda today, so just brief updates.

###  Proposals and discussions

BS: Brief description of current status of Working Draft. The proposed document
is available as a PR against the spec repo. Includes fine-grained changes,
found by diffing HTML between editor's drafts and previous working draft. In
the future we'll want to provide more coarse-grained changes for proposals, but
this is fine for now.

BT: Are there any deadlines to be aware of?

BS: No, the only real deadline is that we are required to put out a draft at
least every 6 months, or say why we didn't. But we still have a month or so.
There is no deadline for the CR, since we're already long over the time were
""resetting the clock"" would make a difference.

BS: Putting out the new WD is the path the next CR. The only real constraint
there is making sure that our implementations pass the testsuite. We currently
do, but if there are tests that are added in the meantime that are
non-compliant, we'll have to redo the CR.

BT: Yeah, there are some issues with the implementation limits in some engines.

BS: Are those in the document?

BT: I handed that off to Dan Ehrenberg, not sure if he's landed it yet.

BS: OK, we may want to wait until that is landed before we push for CR.

### Closure
"
main/2017/CG-10-03.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 3rd video call of WebAssembly's Community Group

- **Host**: Google Hangouts
- **Dates**: Tuesday October 3rd, 2017
- **Times**: 9:00am–10:00am Pacific Time
- **Location**: *same Google Hangouts link as before*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

None required if you've attended before. Email JF Bastien to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. None 
1. Closure

## Agenda items for future meetings

   1. [Versioning of external standard dependencies](https://github.com/WebAssembly/spec/issues/566) (Andreas Rossberg).
   1. Web platform test repository, discussion, and poll (Ben Titzer).

### Schedule constraints

German holiday, folks in the Munich V8 team won't be calling in.

## Dates and locations of future meetings

| Dates                    | Location          | Host       |
|--------------------------|-------------------|------------|
| 2017-11-01 to 2017-11-02 | Santa Clara, CA   | Intel      |
| 2017-11-06 to 2017-11-07 | Burlingame, CA    | TPAC       |

## Meeting notes

### Roll Call

* Arun Purushan
* Benjamin Bouvier
* Brad Nelson
* Daniel Ehrenberg
* Deepti Gandluri
* Derek Schuff
* Eric Holk
* Heejin Ahn
* JF Bastien
* Jacob Gravelle
* Keith Miller
* Kyle Buzby
* Limin Zhu
* Luke Wagner
* Malcolm White
* Marcos Diaz
* Michael Holman
* Mike Holman
* Paolo Severini
* Pat Hickey
* Richard Winterton
* Sean Jensen-Grey
* Sergey Rubanov
* Yury Delendik

### Opening

Find volunteers for note taking: chair volunteers.

### Adoption of the agenda

Empty agenda (Munich folks are on holiday), seconded by Brad.

### Proposals and discussions

Upcoming meetings:

* [Hosted by Intel](https://github.com/WebAssembly/meetings/blob/master/main/2017/CG-11.md) November 1-2. Richard and Peter finalizing schedule, and will reserve restaurant. Map and location set up, will send PR this week. Please send agenda items. Also, please [register](https://goo.gl/forms/4xKG3kJ6IpBYwPKD2).
* [TPAC](https://github.com/WebAssembly/meetings/blob/master/main/2017/TPAC.md). W3C big annual meeting, opportunity to meet with other W3C groups outside of WebAssembly as well as W3C staff. Good venue to present work done with WebAssembly as well as non-Web embeddings. Brad [sent an email about it](https://lists.w3.org/Archives/Public/public-webassembly-announce/2017Oct/0000.html), and sent [a form to suggest topics](https://goo.gl/forms/Vcxp1FVakHRBMrar2
). You should [register with the W3C](https://www.w3.org/2017/11/TPAC/
). We have a room for WebAssembly. WebGPU group interested in talking to WebAssembly folks (they only have a CG, so don’t have a room). There will be a WG meeting as well.

### Closure

*Adjourned*
"
process/github.md,"# Overview
GitHub is the primary location for the development of WebAssembly, along with
the Community Group meetings. The CG has a GitHub
[organization](https://github.com/WebAssembly) which any CG member can join.
Several different types of repositories are hosted there. Examples
(non-exhaustive) include:

- [spec](https://github.com/WebAssembly/spec): WebAssembly specification documents, reference interpreter, and test suite.
- [design](https://github.com/WebAssembly/design): Design documents and general design discussion
- [meetings](https://github.com/WebAssembly/meetings): WebAssembly meetings (VC or in-person), agendas, and notes
- [proposals](https://github.com/WebAssembly/proposals): A tracking list of WebAssembly proposals
- [website](https://github.com/WebAssembly/website): The sources of [webassembly.org](https://webassembly.org)
- [tool-conventions](https://github.com/WebAssembly/tool-conventions): Documents for conventions supporting interoperability between tools working with WebAssembly.
- A repository for each proposal. For general spec proposals, these are forks of the spec repository with the proposed changes applied. 
  WASI API proposals have a separate [template](https://github.com/WebAssembly/wasi-proposal-template). For example:
    - [gc](https://github.com/WebAssembly/gc): Integration with host garbage collection facilities
    - [memory64](https://github.com/WebAssembly/memory64): 64-bit memory support
    - [js-promise-integration](https://github.com/WebAssembly/js-promise-integration): Integration with JavaScript promises
    - And many others (see the proposals repo for a full list)
- A few repositories with shared code projects
    - [binaryen](https://github.com/WebAssembly/binaryen): Optimizer and toolchain library
    - [wabt](https://github.com/WebAssembly/wabt): Low-level wasm binary toolkit
    - [wasi-libc](https://github.com/WebAssembly/wasi-libc): C library implementation on WASI
    - And a few other projects and test suites
  
# Administration
The GitHub organization is managed by the CG and subject to the same
decision-making processes as proposals or other CG activity.  It has several
organization owners (for redundancy and to cover several time zones): these are
usually the CG/WG chairs and spec editor.

Any CG member can be a Member of the organization. Being a member allows you to
be selected as a reviewer for PRs, easily @-mentioned in discussions, and a few
other practical conveniences, but otherwise doesn't confer any special
permissions or status.  Members will be added on request (contact
webassembly-cg-chair@chromium.org with your name and GitHub ID).

Repository ownership and committer status are determined for each repo
individually, depending on the nature of the repo.  Proposal repos are owned by
the proposal champions; the spec repo is owned by the spec editor; the meetings
repo by the CG and subgroup chairs; software projects by their respective
maintainers; other repos default to the CG chairs.  Commit permissions on
repositories can be given by the owner to any CG member based on a history of
contributions and/or expectation of future contributions. Again, this is a
practical consideration and not a special designation for decision-making
purposes.  Contributors may have permissions revoked (e.g. if they are inactive
for a long period of time) as a matter of routine security practice, but can be
restored as needed.
"
main/2018/WG-04-04.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 4 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: April 4, 2018 at 3pm-4pm UTC *( April 4, 2018 8am-9am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Brad Nelson
    - Email: bradnelson@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion on status of the Working Draft.
    1. Discussion: Should we drop the APAC timezone video meetings? (Brad
       Nelson)
       * POLL: We should drop the APAC timezone meeting.
    1. Discussion: Could we simplify the meeting signup process? (Brad Nelson)
    1. Future meetings
       1. Confirm next meeting date + time.
       1. Handing of agenda for in person meeting.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Roll Call
* Derek Schuff
* Conrad Watt
* Eric Holk
* Daniel Ehrenberg
* Luke Wagner
* Michael Ferris 
* Peter Jensen
* Wouter van Oortmerssen
* Anekc
* Heejin Ahn

## Find volunteers for note taking (chair to volunteer).

Brad will take notes.

## Adoption of the agenda

* Derek seconds.

## Discussion on status of the Working Draft.

Talked about in person meeting at Fastly.


## Discussion: Should we drop the APAC timezone video meetings? (Brad Nelson)
       * POLL: We should drop the APAC timezone meeting.


Eric: Is a little odd to pull the meeting at a non-APAC meeting.

Brad: We brought it up at the last APAC meeting and no one objected there, we waited until this one to have a vote.

Eric: We could do one off ones if folks suggest it.

Conclusion: Chair will drop the APAC meetings for now unless someone that feels strongly contacts him.

## Discussion: Could we simplify the meeting signup process? (Brad Nelson)

Eric: Link at the end of the form sounds fine.

## Future meetings
       1. Confirm next meeting date + time.
In two weeks at 8am timeslot.

AI: Brad to add an agenda item for testing video conferencing at the in person meeting.

       1. Handing of agenda for in person meeting.

"
main/2017/CG-11-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 14th video call of WebAssembly's Community Group

- **Host**: Google Hangouts
- **Dates**: Tuesday November 14th, 2017
- **Times**: 9:00am–10:00am Pacific Time
- **Location**: *same Google Hangouts link as before*
- **Contact**:
    - Name: JF Bastien
    - Email: jfbastien@apple.com

### Registration

None required if you've attended before. Email JF Bastien to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
        1. Summary of happennings at TPAC (Brad Nelson, others in attendence)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting notes

### Roll Call

* Bradley Nelson
* JF Bastien
* Yury Delendik
* Alon Zakai
* Andreas Rossberg
* Luke Wagner
* Michael Ferris
* Paolo Severini
* Maher Jendoubi
* Ben Smith
* Keith Miller
* Ben Titzer
* Benjamin Bouvier
* Sam Clegg
* Michael Holman
* Mark Miller
* Richard Winterton
* Jacob Gravelle
* Derek Schuff
* Thomas Nattestad
* Sergey Rubanov


### Opening

### Adoption of the agenda

Seconded by Brad.

### Proposals and discussions

#### Summary of happennings at TPAC

* Feedback from W3C folks present. Encouragement to release first spec draft.
* Lots of background presentations on WebAssembly on first day.
* Repeat of some CG presentations.
* Lifetime API in Web Performance room. Bitcoin mining discussion, but nothing in-depth.
* WebGPU folks came to WebAssembly room. Host bindings discussion. What they need to be fast. Eager to have memory mapping constructs (but issues on Windows). Maybe copy-in / copy-out. Multiple memories: what would this look like? Would it work for single-pointer expectations? [Notes from the WebGPU group](https://lists.w3.org/Archives/Public/public-gpu/2017Nov/0001.html).
* WebAudio presented a synthesizer using WebAssembly. Reasonably content with host bindings. They also assume an external buffer, would require copying. Something more efficient could be done if WebAssembly provided the buffer. Eager to freeze their API.
* Demo session, was mostly advertising for demos.
* Impression from W3C folks is that our group is surprisingly effective (yay!).
* Can start prototyping host bindings proposal, toolchain can generate extra code as a polyfill, and then brower-side can ignore it.
* Might be useful to do a full-on meeting next year, not just outreach.
"
main/2018/WG-09-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 12 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: September 12, 2018 at 3pm-4pm UTC *( September 12, 2018 8am-9am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
1. Future meetings
    1. Confirm next meeting date + time.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Introduction of attendees

* Ben Smith
* Ben Titzer
* Conrad Watt
* Gordon Aplin
* Ulrik Sorber

### Proposals and discussions

BS: Brief description of current status of Working Draft. The proposed document
is available as a PR against the spec repo. Includes fine-grained changes,
found by diffing HTML between editor's drafts and previous working draft. In
the future we'll want to provide more coarse-grained changes for proposals, but
this is fine for now.

BT: Are there any deadlines to be aware of?

BS: No, the only real deadline is that we are required to put out a draft at
least every 6 months, or say why we didn't. But we still have a month or so.
There is no deadline for the CR, since we're already long over the time were
""resetting the clock"" would make a difference.

BS: Putting out the new WD is the path the next CR. The only real constraint
there is making sure that our implementations pass the testsuite. We currently
do, but if there are tests that are added in the meantime that are
non-compliant, we'll have to redo the CR.

BT: Yeah, there are some issues with the implementation limits in some engines.

BS: Are those in the document?

BT: I handed that off to Dan Ehrenberg, not sure if he's landed it yet.

BS: OK, we may want to wait until that is landed before we push for CR.

### Closure
"
main/2018/WG-10-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 10 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: October 10, 2018 at 3pm-4pm UTC *( October 10, 2018 8am-9am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
1. Future meetings
    1. Confirm next meeting date + time.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Opening, welcome and roll call

### Opening of the meeting

#### Introduction of attendees

* Andreas Rossberg
* Ben Smith
* Ben Titzer
* Limin Zhu
* Luke Wagner

### Find volunteers for note taking (acting chair to volunteer)

Ben takes notes.

### Proposals and discussions

BS: We have a number of new changes to the spec repo which are preventing us from moving forward with the process. In particular, the text changes, updates to tests, and some PRs that have yet to land like [Permit work in parallel during instantiation](https://github.com/WebAssembly/spec/pull/745).

BS: AFAIK the changes to test suites will prevent advancement as well.

LW: That seems strange, since many RECs don't have any implementations.

AR: If we keep adding tests will that prevent us from reaching REC?

BS: Good point, I'll follow up w/ Eric about this.

AI(BS): Find out what are requirements are for spec test conformance.

AR: It seems like the [text format changes](https://github.com/WebAssembly/spec/issues/884) are the most substantial changes that we'll make to the spec. Is there any plan for applying these?

BS: I think we just have to decide that we're satisfied with the new names and decide to do it all at once -- change the spec and all tools to use the new names. We already decided at the CG that we were OK with moving forward.

AR: It seems that we should do this sooner rather than later.

### Closure
"
main/2019/CG-04-30.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 30 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: April 30, 4pm-5pm UTC (April 30, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email Ben Smith to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Ben Smith
* Dan Gohman
* Luke Imhoff
* ...

### Find volunteers for note taking (acting chair to volunteer)

### Adoption of the agenda

### Proposals and discussions

#### Review of action items from prior meeting.

BS: Follow up on License for wasi-sysroot. I spoke w/ Eric, our W3 coordinator.
He has looped in some lawyers and others who can answer the question, but we
haven't heard back from the lawyers yet. When I last talked to Dan he said we
may move a different direction, not having to land this under the wasm repo in
the first place.

DG: We're fine doing that, if it makes things simpler.

BS: We'll still want to get this figured out with legal.

DG: It kind of puts it in the same camp as binaryen or wabt.

LI: If we keep the code in the repo by itself. The GH UI will use the musl
stuff that was merged by itself. This might help since it shows MIT.

DG: Not all of it is MIT, there are other licenses too.

LI: How does GitHub UI show the license?

DG: Doesn't show a particular license, just links to the text file.

LI: We could bring this up at GH office hours, to display the other licenses.

BS: That would help, but I think there are other concerns here too.

### Closure
"
debugging/2020/debugging-01-09.md,"# Agenda for the January 9 video call of WebAssembly's debugging subgroup

- **Where**: zoom.us
- **When**: January 9, 11am-12pm Pacific Standard Time (January 9, 7pm-8pm UTC, 8pm-9pm CET)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Derek Schuff
    - Email: dschuff@google.com

### Registration

None required if you've attended a wasm CG meeting before. Email Derek Schuff to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.

Installation is required, see the calendar invite.

## Agenda items

1. Opening


## Meeting Notes
### Attendees:

* Barbara Nichols
* Alon Zakai
* Derek Schuff
* Bill Ticehurst
* Paolo Severini
* Yury Delendik
* Philip Pfaffe
* Z Nguyen-Huu

## Notes:

DS: Update on LLVM: with Yury's recently landed patch and https://reviews.llvm.org/D71681, LLVM's upstream output should be
at parity with the out-of-tree patches we've been using (actually better, since the frame base info is correct more often.

AZ: For emscripten, the .debug_line info should be correct with a PR that should land today. There will be a few
follow-ups to handle ranges and a few other places PCs need to be fixed up, but the infrastructure is all there.

BT: the wasm summit and CG meeting are a month away. Should we put something on the agenda?

DS: It's a good idea. I think we had someone raise an issue on that, which I haven't merged yet because I haven't
talked to Ben since he's been back. But we should put something on the agenda. At least an update on debug info.
Maybe the Chrome dev people can say something about what they've been doing too.

PS: there was a recent proposal for UUID/build-id custom section in wasm. That would be useful for
debugging/symbol servers, etc. should we pick that back up?

DS: yes, I think so

BT: there was a good conversation on the github issue, we should probably pick it up again there.

BT: Unrelated question: Is there a text format for DWARF that we use for testing or round-tripping?

PS: Dwarf is only a binary format.

DS: If you use LLVM assembly output in clang, it prints section-switch and numerical directives that represent
the encoded info, but it's still encoded. Otherwise we just use e.g. llvm-dwarfdump for testing but it doesn't round-trip.

"
main/2017/WG-11-15.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 15th video call of WebAssembly's Working Group

- **Host**: Google Hangouts
- **Dates**: Wednesday November 15th, 2017
- **Times**: 9:00-10:00am Pacific Time
- **Location**: *Brad will email Google Hangouts link to WG members + registered CG guests prior to the meeting*
- **Contact**:
    - Name: Brad Nelson
    - Email: bradnelson@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be a Google Hangouts call.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Adoption of CG specification
       1. Discussion of state of the core specification + JS & Web embedding.
       1. POLL: We should adopt the current WebAssembly core + JS & Web spec as
          a ""First Public Working Draft"" for WebAssembly Specification v.1.
    1. Future meetings
       1. Confirm next meeting date + time.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

###  Roll call

* Eric Holk
* JF Bastien
* Luke Wagner
* Kenneth Rohde Christiansen
* Heejin Ahn
* Deepti Gandluri
* Brad Nelson
* Derek Schuff
* Sam Clegg
* Maher Jendoubi
* Gordon Aplin
* Jacob Gravelle

### Find volunteers for note taking (chair to volunteer).

*Brad Nelson*

### Adoption of the agenda

*Kenneth Christiansen* seconds.

### Proposals and discussions

#### Discussion of state of the core specification + JS & Web embedding.

JF: We should have links to what we’re voting on. W3C docs. The poll should be more clear. Timeline. We should clarify whether the spec is past the point where the “first draft” process wouldn’t get reset.

BN: Sounds good.

BN: Any objections to tabling this agenda item?

*Tabled*

POLL: We should adopt the current WebAssembly core + JS & Web spec as a ""First Public Working Draft"" for WebAssembly Specification v.1.


### Future meetings

Confirm next meeting date + time.

Nov 30, 2017 (Pending confirmation both Andreas Rossberg + Dan Ehrenberg can attend).

NOTE: Dan + Andreas later indicated this date would not work and we decided on Jan 6th at 8am PT.

### Closure

*Adjourned*
"
stack/2020/SG-10-05.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 5th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**: October 5th, 4pm-5pm UTC (October 5th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*


## Participants
Alon Zakai
Andreas Rossberg
Francis McCabe
Heejin Ahn
Sam Lindley
Luke Imhoff
Ross Tate
Zalim Bashorov
Paul Dworzanki
Petr Penzin
Matija Pretnar
Thomas Lively
KC


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. [Presentation of effect handler oriented programming](presentations/2020-10-05-lindley-effect-handler-oriented-programming.pdf) (Sam Lindley) [35 mins]
   1. Call for presentations [3 mins].
1. Closure

## Meeting Notes

### Adoption of the agenda

### Discussion:

SL: General introduction to effect handlers as a programming formalism

SL: Programs must interact typically using ad hoc features

SL: Effect Handlers generalize 

SL: Invented by Gordon Plotkin & Matija Pretnar

SL: Composable and customizable

SL: github semantic library based on EFH. 

SL: Underlying React

SL: EFH as composable user-defined operating systems

SL: EFH generalize Exception Handling

LI: How expensive is this. Can you do a counting yield as we do in Lumen/Erlang?

SL: Current example only has one handler. 

SL: Cooperative concurrency

LI: Every process in Erlang has a monitor process. Has a exception handler.

SL: One wants exceptions to be handled within the process

LI: The scheduler handles the exception by propagating to linked processes.
SL: Lynx has a similar model to Erlang
RT: We did not permit arbitrary stack copying because its an attack vector
SL: Can model pipes & pipes
LI: Yield is ubiquitous in Erlang. We dont use CPS directly.
LI: If we use EFH for implementation do we have to tell browsers to implement a stack switch? We dont use CPS directly
SL: We dont do everything at once. We should be trying simpler aspects such as async/await & green threads first. Don’t necessarily use EFH everywhere.
LI: We are most concerned about stack switching. 
RT: Does erlang always use a trampoline for switching threads?
LI: Yes, but it is not important.
LI: GOing back to the scheduler is important to be able to go back to the browser event loop.
TL: LLVM assembler will support low level features.



### Closure

"
stack/2022/9-26-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 26th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  September 26th, 16:00-17:00 UTC ( September 26th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Thomas Lively
Justin Michaud
Zalim Bashorov
Brendan Dahl
Thibaud Michaud
Sam Lindley
Luke wagner
Ilya Rezvov
Rick Batagline
Derek Schuff
Daniel Hillerström
Deepti Gandluri
Petr Penzin


## Agenda items

1. [JSPI proposal](https://docs.google.com/presentation/d/1jpjX-Yw1GsCcdf2I1LSTtPGPY27Qaj2RWiL557M7BMY) (Thibaud Michaud)

## Meeting Notes

This meeting was recorded. The recording can be found [here](https://us02web.zoom.us/rec/share/fDqOGJl25PTEgafr-FudtF-8EMCwEpIy2Sqygz1fM1VSB98magAqIrD0oaIUN78q.HDxLRAeMcqKgoTLv).

### Adoption of the agenda

### Discussion

TM Presenting ([slides](TODO))

TL (chat): Are there any valid values for “promising” other than “first”?

BD (chat): ‘last’ and ‘none’, but i think we only support ‘first’ right now.

TL: For the promise rejection demo, does the exception propagating through the Wasm stack have an exception tag or can it only be caught with catch_all?

TM: It is a normal JS exception, so there is no exception tag.

TL: To clarify, JSPI will switch before stack switching, so Prompt2 won’t be able to exist and JSPI will always return to Prompt1 back at JS?

FM: Don’t know shipping order precisely, but essentially yes. Also looking to possibly refactor the JS interface to disentangle from the type reflection proposal.

SL: Past performance concerns?

FM: We were previously not measuring the right thing. Haven’t redone performance measurements with the current version, but we don’t anticipate any difference. Function call is about 6ns, calling into JS is 12-15ns, with a promise is 20ns. Constant with depth of computation. (Numbers from memory)

TM: In most cases there are no regressions for existing code. Exception is going from Wasm to JS. Need to check for existence of JS frames on stack.

FM: Supporting large numbers of stacks may come with additional overhead, for example to take an additional mutex. Also still trying to figure out whether we can call Web APIs on the arbitrary current stack and we may have to change that. We don’t want to have to switch to a main stack, but there are large engineering challenges.

TL: What would force us to not call Web APIs on the arbitrary current stack?

FM: There’s no stack checking.

TL: Does the browser currently do stack checking on the main stack?

FM: No.

### Adjourn

"
stack/2024/stack-2024-03-25.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 25th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  March 25th, 16:00-17:00 UTC ( March 25th, 9am-10am Pacific Daylight Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants

Sam Lindley
Deepti Gandluri
Brendan Dahl
Thibaud Michaud
Frank Emrich
Francis McCabe
Thomas Lively
Luke Wagner
Ryan Hunt
Zalim Basharov
Yury Delendik
Andreas Rossberg
Adam Klein
Ilya Rezvov
Ross Tate
Jérôme Vouillon
Benjamin Titzer
Derek Schuff

## Agenda items

Presentation: Supporting Dynamic Scoping in WebAssembly (Francis McCabe & Thomas Lively).

Slides [here](https://docs.google.com/presentation/d/10zDN0hg29Woc6r0GoAn9yHofJ8rTeF6yO2akynBGlx0/edit?usp=sharing)

This meeting was recorded, video can be seen [here](https://us02web.zoom.us/rec/share/SS2Y5Dtd5SI03IUh-ZbAvmXf5YcSNi41mPLwsM1S1WXJ_T_tK2fALNlRYEbq_e51.DVZif1CpkRCaoUJM?startTime=1711382614000)


### Adoption of the agenda

### Discussion

RT: The reason they do the list thing is that the thing you just described is inefficient. If you have to eagerly construct the list every time you add a stack trace frame, that's inefficient.

FM: Agree. Will address later.

BT: Would the list be allocated on the heap?

FM: Many ways to do it. Could have an array.

BT: Languages expect stack traces to be zero-cost.

FM: Right, I wouldn't recommend one actually do this, but they could.


BT: I've been thinking about how to implement dynamic scope quickly. It seems you would want a head for each tag, so switching stacks would have cost linear in the number of tags.

TL: If you use an indirection like storing all the heads in a list, then you can just switch a single pointer to the list when switching stacks.

BT: Would want to have a list with only the modified tags to avoid having grow with number of tags in the system.

TL: No way to statically know what tags will be modified.

RT: Do we need switch-with-unlink?

FM: No, that's normal switching.

…

FM: Oh, you're right, we need switch.unlink.

AR: You would also have to walk the stack on a normal switch.

FM: Maybe, yeah.

BT: Mutability of dynamic scopes is helpful. I wonder if that makes anything easier with the internal bookkeeping. Would be good to be able to support mutability in the future.

SL: Daniel Hillerström pointed out to me immediately before this meeting that an ICFP 2006 paper on Delimited Dynamic Binding: https://okmij.org/ftp/papers/DDBinding.pdf is likely very relevant to the kind of discussion we had here (particularly the part presented by TL)


### Adjourn


"
main/2019/WG-01-16.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 16 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: January 16, 2019 at 4pm-5pm UTC *( January 16, 2019 8am-9am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
1. Future meetings
    1. Confirm next meeting date + time.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Ben Smith
* Ben Titzer
* Gus Caplan
* Ludovic Henry
* Luke Wagner
* Sergey Rubanov

### Find volunteers for note taking (chair to volunteer).

### Adoption of the agenda

### Proposals and discussions

### Future meetings

- Status of CR

BS: Not much work done here because of holidays. Plan to work on it this month.
We need to go over the issues in the spec repo and resolve, probably mostly
formatting issues.

- Connecting your GH and W3C accounts.

BS: I sent an email to regular spec repo contributors to connect their w3c
accounts with their github accounts, so we can add a bot for checking whether
contributors are community group members. Most folks have done so now, so I
believe Dominique will set up the bot soon.

LW: Status of the text format changes?

BS: There was a lot of discussion about how we should rename everything, but
that died down. Since then, we've pushed the new names to the spec repo,
binaryen, wabt, and LLVM. Possibly other tools as well. The general change has
been to remove `/` from the names, as well as to group some instructions
together (e.g. `local.get` and `local.set`).

#### Confirm next meeting date + time.

### Closure
"
process/discussion.md,"# Constructive CG Discussions

The intent of this document is to encourage positive, and constructive discussions
in the WebAssembly CG. This document contains a non-exhaustive list of guidelines
to nudge discussions towards positive outcomes.

## Tone

- **Keep discussions factual and non-judgemental**

- **Avoid passive-aggressive language**  
  It can be helpful to identify sources of frustration, but it is often best
  not to post while actively frustrated to avoid letting that frustration turn
  into passive aggression.

- **Avoid patronizing language**  
  For example, implying someone is ignorant (e.g. ""This is common knowledge in
  <technical community>; I’m surprised I have to explain this"") or feigning ignorance.

- **Avoid asking rhetorical questions**  
  Phrase questions in a way that advances the discussion. For example,
  Instead of asking “Have you considered X?” When you know X has not been considered,
  write up an analysis of X yourself or to ask ""What happens when you consider X?""

## Content

- **Acknowledge the validity of different use cases and priorities**  
  This makes conversations more inclusive and avoids unnecessary arguments about
  differences in points of view that fundamentally cannot be resolved.

- **Ask clarifying questions**  
  When someone's comment is unclear, it's better to ask for clarification or
  confirmation of your understanding than to make assumptions about what they meant.

- **Provide constructive, actionable feedback**  
  When providing feedback on an idea, avoid broad generalizations, and provide
  concrete examples where possible.

## Conversation management

- **Take conversations one step at a time**  
  It can be reasonable to provide a full chain of reasoning in a single comment,
  but don't ask others to respond to the conclusion without giving them a chance
  to respond to the steps that led to the conclusion first.

- **Keep conversations focused**  
  Threads have different purposes such as brainstorming, bikeshedding,
  consensus seeking, etc. Create new threads for new topics or new purposes
  of discussion.
  
## Conflict resolution

- **Resolution through vote at a meeting**  
  In case of prolonged disagreement, consider bringing the issue up at a relevant
  subgroup meeting where applicable, or to the CG meeting so the issue can be
  put to a vote.

- **Resolution through implementer feedback**  
  In cases where progress is blocked, and consensus looks unlikely, feedback from
  compiler, tool, and engine implementers can be a useful resource to
  provide actionable next steps.
"
stack/2021/sg-1-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 11th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**: January 11th, 17:00-18:00 UTC (January 11th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe 
Luke Imhoff
Thibaud Michaud
Alon Zakai
Thomas Lively
Daniel Hillerström
Michal Phoe Herda
Arjun Guha
Ross Tate
Derek Schuff
Rick Battagline
Zalim Bashorov
Sam Lindley


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. [Requirements for stack switching](https://docs.google.com/presentation/d/1iDomt9mJdocJporD2PvsuOpjqemV_DyK8FRTK0QD9KY/edit?usp=sharing) (Francis McCabe) [35 mins]
   1. [Async/Await in JavaScript](https://docs.google.com/presentation/d/1qx1L_X5qa8TkpWt6VBlSR47BB1lreFxXQKpIlbDs-I4/edit#slide=id.gb5160c6941_0_140) (Shu-yu Guo)
   1. Call for presentations [2 mins].
   1. Next meeting [2 mins].
1. Closure

## Meeting Notes

### Adoption of the agenda

### Discussion:

1. [Requirements for stack switching](https://docs.google.com/presentation/d/1iDomt9mJdocJporD2PvsuOpjqemV_DyK8FRTK0QD9KY/edit?usp=sharing) (Francis McCabe) [35 mins]


<Discussion of whether iterator use case is critical>

RT: No requests for that functionality

TL: Any languages that could hypothetically take advantage of iterator support?

LI: Ruby.

RT: Many languages restrict generators to be implementable with state machines.

LI: Are Ruby and Python slow because of this missing functionality?

Consensus that this doesn’t qualify as a critical use case.

<Discussion of Async/Await>

RT/FM: Need to be able to await on Wasm from JS.

LI/TL: What about awaiting on JS from inside Wasm?

FM: That tight of an integration would over-constrain our design.

<General discussion>

FM: Is anything missing from this list of critical success factors?

LI: Do we need something for yielding to the event loop, even on engines that don’t have event loops? Do we want to be generic over all Wasm implementations? On the web you would return a JS Promise, but what about on embeddings without JS?

RT: You would be exporting an externref, so on the Web that would be a Promise and on non-Web embeddings this would be something else. So this seems like a library/import design problem.

LI: What if the asyncness is in the signature? Do we need a wrapping function or will the engine take care of that automatically?

FM: This is veering away from requirements and toward design.

RT: The underlying requirement here is portability of the design to different embedders.


### Adjourn



"
main/2019/WG-02-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 13 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: February 13, 2019 at 4pm-5pm UTC *( February 13, 2019 8am-9am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    - Request that we move forward with a [candidate recommendation](https://www.w3.org/2018/Process-20180201/#candidate-rec) (CR)
1. Future meetings
    1. Confirm next meeting date + time.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Opening, welcome and roll call

#### Opening of the meeting

#### Introduction of attendees

* Alon Zakai
* Andreas Rossberg
* Ben Smith
* Conrad Watt
* Eric P
* Heejin Ahn
* Ludovic Henry
* Luke Wagner
* Sergey Rubanov
* Thays Grazia

### Find volunteers for note taking (chair to volunteer).

### Adoption of the agenda

### Proposals and discussions

#### - Request that we move forward with a [candidate recommendation](https://www.w3.org/2018/Process-20180201/#candidate-rec) (CR)

Eric: If you think things may change ... prepare some things that ...

BS: No

Eric: Issues?

CW: exporting mutable globals?

BS: Yes merged in

Eric: test repo and state ... test suite and implementation report is nice to have.

We have URL... identifier for test, whether we pass or fail. Software that
generates implementation reports from that.

BS: core tests no

LW: any restrictions on WD? cutting branches

EP: No issues.

BS: errors in the doc?

EP: Have to talk to implementers.

BS: just big endian

AR: Only a spec bug

BS: Move forward with CR?

EP: seconds to move forward with CR

No objections

### Future meetings

#### Confirm next meeting date + time.

### Closure
"
simd/2021/SIMD-12-03.md,"# WebAssembly SIMD subgroup meeting on 2012-12-03

Attendees:

- Andrew Brown
- Anton Kirilov
- Deepti Gandluri
- Petr Penzin
- Richard Winterton
- Yuri Delendik

## Presentation on implemeting FP min and max using AVX512

Floating-point min and max operations in WebAssembly have the following
constraints:

- Signed zero handling (ex.: `min(0.0, -0.0) == -0.0`)
- `NaN` propagation (if either input is `NaN` output is `NaN`)
- `NaN` canonicalization

This makes x86-based implementations somewhat complicated, because SSE and AVX
instructions don't honor these properties. Solutions usually include:

- `cmpunordps` to detect `NaN` inputs
- `and` or `or` to handle signed zeros
- Performing operation twice to detect asymmetry
- Various forms of blending to put the result back together

The problem is that mitigations for the constraints above interact with each
other, making overall sequence more complicated. Removing even one of the
constraints will make the sequence much simpler. Using more registers may help
as well.

With AVX512:

- `vrange` has the desired behavior v.r.t signed zeros
- `vfixupimm` detects and corrects special values, but requires extra `mov`s
  and registers to set up fixup table
- Masked operations

We have tried `vrange` and `vrange` with conditional lane operations, on a
MobileNet demo:

- Both get close to theoretical maxiumum performance
- `vrange` combined with conditional ops wins

Implementation challenges:

- AVX512 detection and assembler changes
  - `cpuid`, encoding, tests, etc
- For conditional operations, mask register representation
  - Possible to hardcode if this is the only use

## Discussion

We have lost some notes here, below is the summary.

One of the questions for AVX512 implementation is its availability. It is
available in some client hardware, but is not very common. This makes finer
points, like mask register support even less important.

DG: AVX512 support isn't priority for V8 till it's more commonly available
in consumer hardware, work in progress for 256-bit registers/instructions

AB: What about Node.js and usage on the server?

DG: Node.js can serve as motivation, but we need to see benefits, the bar is
higher.

AB: Anton Kirilov, what is the current SVE availability?

AK: Both Qualcomm and MediaTek announced they will ship SoCs with SVE support.
"
main/2024/CG-02-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 13th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: February 13th, 5pm-6pm UTC (February 13th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. Discussion of proposed June CMU in-person CG meeting (20 mins; Ben Titzer)
        1. Issue: https://github.com/WebAssembly/meetings/issues/1463
1. Closure

## Agenda items for future meetings

*None*


## Meeting Notes


### Attendees

 - Michael Ficarra
 - Chris Fallin
 - Ben Titzer
 - Daniel Hillerstrom
 - Fedor Smirnov
 - Keith Winstien
 - Nick Fitzgerald
 - Yuri Iozelli
 - Jeff Charles
 - Manos Koukoutos
 - Kevin Moore
 - Brendan Dahl
 - Paolo Severini
 - Dan Gohman
 - ILya Rezvov
 - Thomas Lively
 - Yury Delendik
 - Ashley Nelson
 - Luke Wagner
 - Ryan Hunt
 - Justin Michaud
 - Chris Woods
 - Richard Winterton
 - Robin Freyler
 - Emanuel Zigler
 - Sam Clegg
 - Jakob Kummerow
 - Deepti Gandluri
 - Heejin Ahn
 - Bailey Hayes
 - Shravan Narayan


### Proposals and discussions
#### Discussion of proposed June CMU in-person CG meeting (20 mins; Ben Titzer)


BT: presenting

TC39 is an important constraint for discussion of shared everything (important to get input from some relevant JS experts).
The Web Engines hackfest is 3-5 not 5-7

June 4-6 can be made to work for most people but not everyone.
It’s the last week of the academic year for some, and there is a hard constraint for one person. Ben will investigate on the CMU side whether other months would work. Previously it was indicated that June would be good (being immediately after the end of the semester, students would be around but done with classes). 

"
main/2018/WG-05-02.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 2 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: May 2, 2018 at 3pm-4pm UTC *( May 2, 2018 8am-9am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Brad Nelson
    - Email: bradnelson@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion on status of the Working Draft.
    1. TBD
1. Future meetings
    1. Confirm next meeting date + time.
    1. Handing of agenda for in person meeting.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Opening, welcome and roll call

Peter Jensen
Sam Clegg
Shiv Kushwaha
Ben Titzer
Conrad Watt
Nurullah
Anexc

### Opening of the meeting

### Introduction of attendees

### Find volunteers for note taking (chair to volunteer).

Brad Nelson to take notes.

### Adoption of the agenda

Ben seconds.

### Discussion on status of the Working Draft.

Brad report progress on bikeshed.
Worked with Tab a little on math inline syntax for bikeshed.
Only inline syntax working, but kicking the tires using in rst.

Andreas has been travelling so hasn't made many of the fixes.

Ben inquires about limits affecting patent clocks etc.
Brad explains that the clock resets when new working drafts are issued, but only for the material cover

### Future meetings

### Confirm next meeting date + time.

Andreas proposes changing the cadence so the CG + WG alternate weeks.
Proposes having the next WG meeting in 3 weeks.

Andreas calls for objections (none).

Next meeting will be in 3 weeks.
AI: Brad to adjust the calendar item accordingly.

### Closure
"
wasi/2021/WASI-01-14.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the January 14 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: January 14, 17:00-18:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Lin Clark
    - Email: lclark@fastly.com

### Registration

None required if you've attended before. Email Lin Clark to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcement
    1. Pat will be changing branch name from `master` to `main`
1. Review of action items from previous meeting(s).
    1. Lin update on repository organization progress
1. Proposals and discussions
    1. Discussion: Testing guidelines for proposals
    1. _Sumbit a PR to add your agenda item here_

## Meeting Notes
### Attendees
Lin Clark
Josh Dolitsky
Dan Gohman
Pat Hickey
Sam Clegg
Casper Beyer
Mark McCaskey
Johnnie Birch
Andrew Brown
Yong He
Peter Engelbert
Peter Huene
Martin Duke
Till Schneidereit
Bogus Wolf

For people taking notes, just type names; we’ll replace them with abbreviations before posting them publicly.

**Pat Hickey:** Github is now rolling out features to allow for renaming git branches from “master” to “main”, including blob url redirection. It’s mostly automatic, but it does require people to do some changes locally to update. We’ll put the steps in the WASI github issue tracking this.

Main topic: Testing.

**Lin Clark:** <slides>

The context here is WASI modularization -- breaking up the core WASI module into separate modules.

Pat and Dan are working on a new witx mechanism for expressing dependencies between witx files, allowing modules to depend on each other.

The main WASI repo will be the source of truth for stage-5 (standardized) proposals.

Tests should include both the source, in high-level languages, and compiled wasm binaries.

Things we still need to build:
A test runner
Tests. We’ll start with some tests from Wasmtime, and everyone can add tests.



"
stack/2021/sg-11-29.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 29th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  November 29th, 16:00-17:00 UTC ( November 29th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
- Francis McCabe
- Lars Hansen
- Daniel Hillerström
- Andreas Rossberg
- Arjun Guha
- Thibaud Michaud
- Zalim Bashorov
- Luke Wagner
- Sam Lindley
- KC Sivaramakrishnan
- Ross Tate
- Oscar Spencer
- Alon Zakai
- Sam Clegg


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. A Deep Dive into Multi-Core OCAML Effect Implementation (Ross Tate)

   2. Next meeting [2 mins].
1. Closure

## Meeting Notes

RT presents an overview of effect handlers in multi-core OCAML

FM: When the stack parent is cleared, are the intermediate stack segments parent pointers kept?
RT: yes

FM: When you suspend and find that the ‘current handler dictionary’ does not have the right handler; you have to suspend again. How do you ensure that the original continuation is properly extended.

KC: In multi-core OCAML there is a special operator: reperform that packages up the current continuation and tries the parent handler.

SL: Why cant you compile ocaml handlers into separate tags?

RT: because handlers are first class in OCAML

AR: The original proposal had the equivalent of reperform and catchall but got dropped.

RT: starting to look at using first class stacks proposal

FM: Confused about stack.mount

RT: explains 

FM: What are the abuse patterns?

RT: If you don't have a stack type, or the wrong stack type then you can’t switch out of the current stack. You can use stack.mount to enable stack switching below the current point. 

SL: I’m afraid I didn’t really follow what the semantics of your proposed instructions is intended to be. Have you written up the specification somewhere?

RT: Just a sketch.

RT: Design sketch is [written up](https://github.com/WebAssembly/stack-switching/issues/5).

### Adoption of the agenda

### Discussion:

### Adjourn

"
main/2018/WG-03-21v22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 21/22 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: March 22, 2018 at 6am-7am UTC *( March 21, 2018 at 11pm-12am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Brad Nelson
    - Email: bradnelson@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion on status of the Working Draft.
    1. Future meetings
       1. Confirm next meeting date + time.
       1. Handing of agenda for in person meeting.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes
### Roll Call
* Brad Nelson
* JF Bastien
* Derek Schuff
* Maher Jendoubi
* Alex Danilo
* Deepti Gandluri
* Heejin Ahn
* Limin Zhu
* Michael Ferris


### Find volunteers for note taking (chair to volunteer)
Brad Nelson
### Adoption of the agenda
JF seconds.
### Discussion on status of the Working Draft.

Limin will do a few pull requests.

Derek & Brad haven't looked in detail.

### Confirm next meeting date + time.

Brad will put an item on next time's agenda to propose dropping the APAC time.

Next meeting is April 3, 9am PST.

### Handing of agenda for in person meeting.

Brad added spec sections + people's names on the area they're expected to moderate.

JF talked to block chain folks who will present.

Brad spoke today to Rodrigo from Mono who will present on their GC/managed objects needs.

AI: Brad Nelson to ping Rust folks (maybe bug Luke / Dan)

AI: Brad Nelson to ping Tom Dale on Rust.

*Adjourn*
"
benchmarking/2024/benchmarking-05-17.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 17th of WebAssembly's Benchmarking Subgroup

- **Where**: Google Meet
- **When**: May 17th, 4pm-4:45pm UTC (8am-8:45am PDT, 11am-11:45am EST)
- **Location**: _Link on calendar invite_
- **Contact**:
    - Name: Petr Penzin, Saúl Cabrera
    - Email: penzin.dev@gmail.com, saul.cabrera@shopify.com


### Registration

If this is your first time attending, please [fill out the registration form](https://forms.gle/QCmhyM4QwvWvZR9b8) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

### Logistics

This meeting will be a Google Meet video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes
    1. Please help take notes.
1. Announcements
1. Proposals and discussions
    1. PERFWUME: A model based toolchain for evaluating performance of wasm runtimes, Ajay Chhokra (Siemens)
1. Closure

## Attendees
* Ajay Chokkra
* Andrew Brown
* Ayako Akasaka
* Doehyun Baek
* Jhonnie Birch
* Saúl Cabrera

## Meeting notes

###  PERFWUME: A model based toolchain for evaluating performance of wasm runtimes

[slides](./perfwume.pdf)


JB: What contributes to jitter? Is it latency or performance?

AC: Context switching was contributing to jitter. 

JB: Is there any difference if you were running native?

AC: The jitter observed was very similar in both native and Wasm.

JB: Are there any plans on open sourcing the work done as part of this
toolchain?

AC: Study A is already open source. It doesn't exist in a GitHub repository, it's a zip file. Other studies are not open and need approval.

AB: Each experiment is a complex row. One of the slides is using a very specific WASI-SDK and a different version of wasm-opt. All those variables matter and make the benchmarking more complex. 

AC: The last study is taking care of ensuring that the toolchains versions are controlled.

DB: Different wasm-opt versions might impact performance, as pointed by Adrew. Has anyone experienced performance differences between wasm-opt versions?

AB: Hasn't experienced performance differences, but sometimes in different versions different sizes are observed.
"
process/champion.md,"# Responsibilities of a Champion

Champions are authors and editors of proposals. The champion is responsible for
the evolution of the proposal from Phase 0 through Phase 5; at Phase 4
maintenance transfers to the WebAssembly Working Group (WG). Champions have
admin permissions in the proposal repository. Periodically, champions may bring
their proposal to the [Community Group (CG)
meetings](https://github.com/WebAssembly/meetings/) to ask for consensus on
phase advancement.

When asking for advancement, the champion is expected to make the whole
proposal accessible for review by the CG, by explaining its contents, providing
supporting documentation, etc. Material changes should be presented explicitly.

It is often beneficial for champions to keep the CG updated with periodic
status updates outlining major changes in the regular [CG
meetings](https://github.com/WebAssembly/meetings/). While minor changes can be
made through discussions within the repository or the relevant subgroup,
substantial design changes may require a vote from the CG so that the CG has a
chance to review the proposal and possibly re-evaluate if the proposal is in
the appropriate stage. Examples include a change to the fundamental assumptions
or structure of a proposal, a decision that has a substantial impact on the
future direction, or a resolution to a contentious issue that is hard to
resolve.

It is not necessary that champions are knowledgeable about every component of
the spec or its implementation, but they are responsible for the general
management of the proposal repository, which includes:
- Keeping track of issues in the proposal repository and mediating them when
  necessary. When discussions are contentious and hard to resolve, champions
  are expected to wrap them up and suggest the next steps.
- Responding to issues or PRs in the repository, or letting other people with
  expertise take care of them, ensuring that all important issues are
  appropriately addressed.
These responsibilities may be shared with subgroup chairs in cases where there
is a relevant subgroup.

Note: First two paragraphs are adapted from the “Scope of Responsibility for
Champions” section in https://tc39.es/process-document/.
"
main/2018/WG-07-18.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 18 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: July 18, 2018 at 3pm-4pm UTC *( July 18, 2018 8am-9am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion on status of the Working Draft.
1. Future meetings
    1. Confirm next meeting date + time.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

### Opening of the meeting

### Roll call

* Arun Purushan
* Ben Smith
* Conrad Watt
* Heejin Ahn
* JF Bastien
* Keith Miller
* Ulrik Sorber

### Adoption of the agenda

JF seconds

### Discussion on status of the Working Draft.

BS: Discussed timeline for working draft w/ Eric, our w3c rep. Haven’t seen many
change to the spec since the April review, aside from mutable globals and
removal of indexeddb serialization, so CR and PR will be mostly the same. PR is
typically the time for implementation feedback.

KM: So MVP feature list or v1 feature list?

BS: w3c PR requires two implementations, which we will have for v1 (Chrome +
FF). Some small formatting changes. Will work with Tab + Andreas to get CR
ready in August. Given a candidate recommendation at August 14, the proposed
recommendation is September 25 and w3c recommendation would be October 30,
which aligns nicely with TPAC.

### Adjourn
"
main/2019/CG-01-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 8 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: January 8, 5pm-6pm UTC (January 8, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email Ben Smith to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

* Adam Klein
* Andreas Rossberg
* Ben Smith
* Ben Titzer
* Conrad Watt
* Deepti Gandluri
* Lars Hansen
* Limin Zhu
* Luke Wagner
* Nick Fitzgerald
* Peter Jensen
* Richard Winterton
* Sergey Rubanov
* Yury Delendik

BS: No agenda today. Any comments?

SR: (chat) Is it still possible to attend the WG meetings as a CG member?

BS: Yes, please contact me and I'll add you to the calendar invitation.

BS: Just a FYI, Dan Ehrenberg mentioned that Igalia would like to host the next
in-person meeting in Barcelona. Nothing finalized yet, so if you have any
concerns please contact me.

RW: What's the status of host bindings?

LW: Is it in terms of WebIDL types... Adam K is checking on things and will
respond to me.

AK: Yeah, still need to look into some stuff. I'll get back to you on that.

LW: In the meantime, landing reference type stuff. A prereq for this.

BT: We're also working on ref types, hoping to be done this month.
"
stack/2020/SG-09-25.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 25th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**: September 25th, 4pm-5pm UTC (September 25th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*


## Participants

Alon Zakai
Daniel Hillerström
Emanuel Ziegler
Francis McCabe
Heejin Ahn
Jakob Kummerow
Lars Hansen
Luke Imhoff
Luke Wagner
Paul Dworzanski
Petr Penzn
Ryan Hunt
Sam Lindley
Thomas Lively
Zalim Bashorov

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. Scope of sub-group [30 mins]
   1. Potential deliverables of sub-group [10 mins].
   1. Frequency and time slot of meetings [10 mins].
   1. Call for presentations [5 mins].
1. Closure

## Meeting Notes


### Introduction of attendees

### Adoption of the agenda

### Discussion: 

TL: We should be making decisions
PS: Agreed. Would like to follow this.
HA: Stack Switching should not be connected to EH. Hoping the EH is independent of other stack switching proposals.
LI: It would be nice if stack switching is more important than stack inspection
PS: We cant target WASM at the moment.
SL: Our proposal is intended to be minimal. Incremental approach is best

LI: We need stack switching for async/await too.
SL: We propose generalize to cover more use cases. 
PS: We are interested in multiple use cases.
LI: Does implementation need to infer special cases to obtain optimization. 
SL: GHC does support efficient implementations of effect handlers; through aggressive inlining.

FM: In summary, topics include exception handling, async/await, coroutining as use cases.

FM: Meeting on friday is not good for Europeans. Suggest meeting every two weeks on Mondays, starting October 5th.

FM: We have volunteers for two presentations in coming weeks: from SL (a backgrounder on effects handling) and PS/LI (on what it takes to implement Erlang)


### Closure

"
stack/2023/stack-2023-07-31.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 31st video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  July 31st, 16:00-17:00 UTC (July 31st, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants

Brendan Dahl
Sam Lindley
Francis McCabe
Ilya Rezvov
Zalim Bashorov
Thibaud Michaud
Ross Tate
Ryan Hunt
Thomas Lively
Luke Wagner
Frank Emrich
Deepti Gandluri
Paul Schoenfelder


## Agenda items

1. Update on stack switching in V8 (Ilya Rezvov) [slides](https://docs.google.com/presentation/d/1m6i_UYf_jYpGk4qlJUa7s1zDpk5_CGr91npVJZTQJH8/edit#slide=id.g23800cfaea5_0_0)

The recording of this meeting can be seen [here](https://us02web.zoom.us/rec/share/VYSsPpaS-iUUYchV4-vkYOb9aJYqrwgESNT_kDeM06vFB5ZSoyQN7v1yp7EHFm-6.ybSp2972VUpv2v3S).

## Meeting Notes

SL: Will we still need core stack switching for core stack switching?

IR: Safe to stay on secondary stacks as long as it's Wasm-to-Wasm. Runtime calls will still still switch to central stack.

SL: Any radical differences between what we need to do for core stack switching and JSPI?
IR: No, it will be very similar. Most of the extra work for core stack switching will be API interface work.

TL (chat): (re: Wasm-to-Wasm wrappers) It would be really surprising if a Wasm-Wasm boundary became observable for any reason.

RT (chat): I believe he’s talking about where the suspender-wrapping functions are applied to a wasm function and the resulting wrapped function is used as a wasm function.

IR: For example SQLite wants to provide a sync API for users. They would want full control at the boundary of their library to ensure that sync API.

FM: You could either call the wrapped import or you could call the unwrapped import and propagate the suspended object. We haven't implemented removing the wrappers when a wrapped import is hooked up to a wrapped export, and we may never do that.

TL: Thanks, it makes sense for the boundary to be observable when there is an explicit wrapper between the import and the export.

### Adoption of the agenda

### Adjourn


"
wasi/2019/WASI-11-21.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the November 21 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: November 21, 17:00-18:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. `wasi_snapshot_preview1` update: now live!
         1. wasi-libc update here: https://github.com/CraneStation/wasi-libc/pull/136
         1. Other toolchains should start moving to it as well.
    1. `wasi-sdk` and `wasi-libc` will be moving into the `WebAssembly org
         1. Discussed here: https://github.com/WebAssembly/meetings/blob/master/2019/CG-11-12.md
    1. Modularization update.
         1. Link to be posted soon.
    1. Calling for volunteers.

1. Closure

## Meeting Notes

Attendees:

Pat Hickey
Jan Falkin
Alex crichton
Jay Phelps
Andrew brown
Luke Wagner
Alon Zakai
Dan Gohman
Mark McCaskey

Meeting notes:

DG: WASI Snapshot 1 is out.

DG: WASI-SDK and WASI-libc. Currently in Cranestation orginization. They will move under the WebAssembly orginization, that was approved at the last CG meeting. We just have to work out some minor licensing issues for that to move forward.

DG: Modularization update. I don’t have an update, haven’t had enough time. The current PR shows the shape of it, but it needs to be updated to the current set of APIs and witx.

DG: Call for volunteers. I want to emphasize that WASI is a big opportunity, and now is the time to make changes. Please make PRs against the ephemeral directory
"
stack/2022/12-5-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 5th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  December 5th, 17:00-18:00 UTC ( December 5th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Ilya Rezvov
Brendan Dahl
Zalim Bashorov
Daniel Hillerström
Ross Tate
Andreas Rossberg
Adam Klein
Petr Penzin
Deepti Gandluri

## Agenda items

1. Brainstorm: examine [racket](https://docs.racket-lang.org/guide/parameterize.html) as a use case for dynamic scoping


## Meeting Notes

Ross presenting slides on racket
Brainstorm ..

Summary: Racket heavily uses multiple forms of dynamic scoping. If racket implemented its features on top of typed continuations there is a risk of some inefficiency. They particularly would need the 1st class label extension.

There are two known ways of implementing conventional dynamic scoping: managing a global dictionary or passing an extra dynamic doctionary variable in every function. Both approaches have trade offs, but neither requires anything from wasm itself.
Other, more advanced, forms of dynamic scoping imply supporting agressive stack walking in some form. This would require some changes to wasm.

AR: Maintaining dynamic scope by managing a global dictionary is complicated, brittle, and costly. The parameter solution is simpler but induces a global extra cost for every function call, so is not pay-as-you-go.

For the same reasons, there is no ""zero-cost"" implementation of dynamic scoping in the presence of non-local control. Even as an extra Wasm feature it would generally be linear.

The only way to achieve zero overhead for dynamic scoping in the context of the control abstractions we are interested in for this proposal is by making the dynamic scoping already inherent in stack switching accessible to the program, which at least avoids paying two costs.

### Adoption of the agenda

### Adjourn

"
wasi/2020/WASI-05-07.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the May 7 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: May 07, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Proposals and discussions
    1. Heads up: Meetings agendas and notes will be moving:
        1. https://github.com/WebAssembly/meetings/issues/549
    1. Proposal organization
        1. New proposal repositories prototypes:
            1. https://github.com/WebAssembly/WASI-http-proxy/tree/master/phases/ephemeral/witx
            1. https://github.com/WebAssembly/WASI-classic-command/tree/master/phases/ephemeral/witx
            1. https://github.com/WebAssembly/WASI-poll/tree/master/phases/ephemeral/witx
            1. https://github.com/WebAssembly/WASI-handle-index/tree/master/phases/ephemeral/witx
            1. https://github.com/WebAssembly/WASI-clocks/tree/master/phases/ephemeral/witx
            1. https://github.com/WebAssembly/WASI-random/tree/master/phases/ephemeral/witx
            1. https://github.com/WebAssembly/WASI-filesystem/tree/master/phases/ephemeral/witx
            1. https://github.com/WebAssembly/WASI-streams/tree/master/phases/ephemeral/witx
        1. Goal is to have them be forks of the WASI repo.
        1. How should the witx tooling work?
    1. Update on the module-types linking proposal:
        1. https://github.com/WebAssembly/module-types/pull/3

## Meeting Notes

Attendees:

Dan Gohman
Mark S. Miller
Andrew Brown
Benjamin Brittain
Daiki
Johnnie Birch
Jplevyak
Lee Campbell
Luke Wager
Mingqiu Sun
Peter Heune
Yury
Sam Clegg

Meeting notes:

Heads up: Meetings agendas and notes will be moving:
https://github.com/WebAssembly/meetings/issues/549

Proposal organization
New proposal repositories prototypes:
https://github.com/WebAssembly/WASI-http-proxy/tree/master/phases/ephemeral/witx
https://github.com/WebAssembly/WASI-classic-command/tree/master/phases/ephemeral/witx
https://github.com/WebAssembly/WASI-poll/tree/master/phases/ephemeral/witx
https://github.com/WebAssembly/WASI-handle-index/tree/master/phases/ephemeral/witx
https://github.com/WebAssembly/WASI-clocks/tree/master/phases/ephemeral/witx
https://github.com/WebAssembly/WASI-random/tree/master/phases/ephemeral/witx
https://github.com/WebAssembly/WASI-filesystem/tree/master/phases/ephemeral/witx
https://github.com/WebAssembly/WASI-streams/tree/master/phases/ephemeral/witx

Goal is to have them be forks of the WASI repo.

How should the witx tooling work?
https://github.com/WebAssembly/testsuite
https://github.com/WebAssembly/WASI/blob/master/docs/Proposals.md
SBC: Have the proposals repos repo link to the docs from individual proposal repos.
https://github.com/WebAssembly/WASI/blob/master/docs/Process.md
Update on the module-types linking proposal:
https://github.com/WebAssembly/module-types/pull/3
LW: This also starts to address link-time virtualization.
"
benchmarking/README.md,"# WebAssembly Benchmarking Subgroup Charter

The Benchmarking Subgroup is a sub-organization of the [WebAssembly Community
Group](https://www.w3.org/community/webassembly/) of the W3C. As such, it is
intended that its charter align with that of the CG. In particular, the sections
of the [CG charter](https://webassembly.github.io/cg-charter/) relating to
[Community and Business Group
Process](https://webassembly.github.io/cg-charter/#process), [Contribution
Mechanics](https://webassembly.github.io/cg-charter/#contrib),
[Transparency](https://webassembly.github.io/cg-charter/#transparency), and
[Decision Process](https://webassembly.github.io/cg-charter/#decision) also
apply to the Subgroup.

## Goals

The mission of this subgroup is to provide a forum for collaboration on
benchmarking efforts for WebAssembly programs, sharing best practices, tools,
and knowledge related to benchmarking.

## Scope

The Subgroup will consider topics related to benchmarking of WebAssembly, including:

- Best practices for benchmarking WebAssembly
- Development and sharing of benchmarking tools
- Knowledge sharing about existing benchmarks, systems, and projects
- Public, high-level, recommendations about best practices, frameworks, suites, metrics, for WebAssembly benchmarking

## Deliverables

### Non-normative reports

The Subgroup may produce non-normative material such as requirements documents,
recommendations, and use cases related to benchmarking.

### Software

The Subgroup may produce software related to benchmarking of WebAssembly, including but not limited to:

- Benchmarking tools specifically designed for WebAssembly
- Libraries or frameworks to aid in the benchmarking of WebAssembly applications
- Distilling and collating WebAssembly benchmarking suites. 

### Specifications

The Subgroup may produce amendments and extensions to existing WebAssembly
proposals or propose the creation of new proposals leading to better
instrospection (e.g profiling/tracing) for WebAssembly. 

## Amendments to this Charter and Chair Selection

This charter may be amended, and Subgroup Chairs may be selected by vote of the full WebAssembly Community Group.
"
stack/2021/sg-10-4.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 4th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  October 4th, 16:00-17:00 UTC ( October 4th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
- Francis McCabe
- Lars Hansen
- Ross Tate
- Arjun Guha
- Ben Titzer
- Alon Zakai
- Thibaud Michaud
- Rick Battagline
- Ioanna Dimitriou
- Daan Leijen
- Thomas Lively
- Daniel Hillerström
- Sam Lindley
- Zalim
- Luke Wagner
- Paul Schoenfelder
- Andreas Rossberg
- Michael Knyszek
- Deepti Gandluri
- Heejin Ahn



## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. Review of scope of JS Promise integration API (Francis McCabe)

   2. Next meeting [2 mins].
1. Closure

## Meeting Notes

FM introduced the question of ‘whether the JS Promise integration’ is enough.
JS Promise integration allows traditional C++ sync code to work but does not convert that code into responsive code.

Meta: there was a lot of discussion about how to augment C++ to handle asynchronous code; but that was not the main point here.

LW: Suggested that posix threads would represent an opportunity for extended wasm to enhance C++ (along the lines of Virtual threads in Java Loom)

Gestalt: exposing stack switching through p-threads may be a useful opening for C++ applications in WebAssembly.


### Adoption of the agenda

### Discussion:

### Adjourn

"
wasi/2019/WASI-09-26.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the September 26 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: September 26, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Initial WASI modularization draft
        - https://github.com/WebAssembly/WASI/pull/98

1. Closure

## Meeting Notes

Attendees:

Dan Gohman
Andrew Brown
Mark Bestavros
Leon Wang
Alex Crichton
Peter Huene
Luke Wagner
Yury Delendik
Pat Hickey
Artur Jamro

Meeting notes:

DG: WASI modularization draft PR is up, comments are welcome

Also, this makes the start of the point where we can start taking PRs for new API proposals, in the form of PRs which add and modify witx files.

Pat: We’re working on an HTTP API proposal.

Dan: There are also people working on Berkeley sockets APIs. Note that though there is a potential for overlap here, it makes sense to develop both.

Pat: In cases of overlap like this, the higher-level APIs may even by polyfillable on top of the lower-level APIs.
"
main/2019/WG-08-28.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 28 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: August 28, 2019 at 4pm-5pm UTC *( August 28, 2019 8am-9am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Acting Chairs**:
    - Derek Schuff
    - Deepti Gandluri

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. PR transition

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes
## Disposition Comments/PRs since CR fork 18 July

### Merges

- The [latest js-api change](https://github.com/WebAssembly/spec/commit/666dc4cb8d4a81d386a7a716000bb85fbbbd06a2) is present in the CR document
- The [Upgrade to IEEE 754-2019 (#1050)](https://github.com/WebAssembly/spec/commit/a221f2574d7106e92cf8abaf05d5bb1131b19d76) just updates the IEE754 reference to the most recent spec -- doesn't change implementation

The rest of the PRs are typographic or for the interpreter, which is not a CR-related product.


### Issues 

- [Published jsapi spec is out of date](https://github.com/WebAssembly/spec/issues/1059) -- no textual change; related to github pages.
- [OCaml Dependency is Problematic for Windows](https://github.com/WebAssembly/spec/issues/1048) -- interpreter

### Wide Review

CR followed a wide, in-depth section-by-section review from CG members, as reflected in spec [GitHub issues](https://github.com/WebAssembly/spec/issues?utf8=%E2%9C%93&q=label%3Awasm-core-1+)

PROPOSAL: advance spec to PR

* Eric Prud'hommeaux: +1
* Derek Schuff +1
* Luke Wagner +1
* Deepti Gandluri +1
* Ben Smith: +1
"
stack/2022/6-27-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 27th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  June 27th, 16:00-17:00 UTC ( June 27th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Daniel Hillerström
Ross Tate
Rick Battagline
Luke Wagner
Maciej Pirog
Ilya Rezvov
Thibaud Michaud
Ryan Hunt
Deepti Gandluri
Paul Schoenfelder
Petr Penzin


## Agenda items

1. Continued discussion on task-based stack switching. (AMA)

## Meeting Notes

Fgm gave a rerun of previous presentation on task based stack switching.
There was some discussion about how erlang would integrate. PS expressed a concern that, since there is no stack walking in this proposal, Erlang implementations would still need to use a shadow stack to enable support for GC.

PP: I was asking how they manage shadow stack for many threads, and the answer was something along the lines of making and estimate how much each would need and then allocating shadow stack entries for them, as opposed to classic Erlang when it attempts to allocate absolute minimum and then grow the areas.

PP: The exact style of shadow stack support seems to be orthogonal to this proposal.

PP: I am also in favor of this proposal as it seems simple enough and takes important details into account (I said something along those lines, but can't remember what anymore).

### Adoption of the agenda

### Discussion

### Adjourn
"
stack/2022/6-6-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 6th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  June 6th, 16:00-17:00 UTC ( June 6th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
 * Francis McCabe
 * Luke Wagner
 * Thibaud Michaud
 * Sam Lindley
 * Ben Titzer
 * Adam Klein
 * Ryan Hunt
 * Derek schuff
 * Ilya Rezvov
 * Maciej Pirog
 * Ross Tate
 * Thomas Lively
 * Deepti Gandluri
 * Daniel Hillerström
 * Daan Leijen


## Agenda items

1. [Task-based Stack Switching](https://docs.google.com/presentation/d/1veLRa4d4B0dM3BU_8A39A1uu1bBFH_05GaWphF_4otQ) (Francis McCabe)

## Meeting Notes

The meeting was recorded. The recording can be seen [here](https://us02web.zoom.us/rec/share/N_XRZZxfO-8iMYXcgkXKwFDiztmksHgztZxJx4SaVkyVC15Qw9X4j4l4EnkBtdn-.8JerSK6uwuUnzoaR?startTime=1654531459000)

### Adoption of the agenda

### Discussion

#### [Task-based Stack Switching](https://docs.google.com/presentation/d/1veLRa4d4B0dM3BU_8A39A1uu1bBFH_05GaWphF_4otQ) (Francis McCabe)

SL: an important difference between these events and those used by typed continuations is that they do not have result types

FM: Yes

RT: retire is a bit like a dynamically typed version of returning

RT: For the task.retire, you can also use it for dynamically typed returning to the parent

FM: Yes, it will be everytime you want to finish

RT: Reference to SL, it’s a dynamically typed return instead of a static one 

FM: The event is statically typed

RT: <>

SL<in chat>:People may find it helpful to refer to Francis' PR here: https://github.com/WebAssembly/stack-switching/blob/fgmccabe-patch-2/proposals/tasks/Explainer.md

SL: Compared to the typed continuations proposal, you always specify who is going to handle the event


### Adjourn

"
main/2019/CG-05-28.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 28 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: May 28, 4pm-5pm UTC (May 28, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email Ben Smith to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Agenda items left over from prior meeting.
      1. [Passive element segment binary format](https://github.com/WebAssembly/reference-types/issues/31)
         - [Slides](https://docs.google.com/presentation/d/13F46ycthgp-0a8HP03lVU7QzEBTPJC_A8JGj739THis/edit?usp=sharing)
         - The current format is more general, but larger (~3 bytes for function reference, allows heterogeneous segments)
         - A suggested format is smaller, but less expressive (~1 byte for function reference, only homogeneous segments)
    1. Should proposals have a formatted diff of changes to the spec?
	1. Settle or at least prioritize agenda for f2f in Spain in mid-June
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Posted after meeting.
"
stack/2021/readme.md,"# Presentations given in 2021

This list is convenience only. 

* [Async/Await in Javascript](https://docs.google.com/presentation/d/1qx1L_X5qa8TkpWt6VBlSR47BB1lreFxXQKpIlbDs-I4/edit#slide=id.gb5160c6941_0_140) (Shu-yu Guo)
  Meeting: [1-11-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-1-11.md)

* [The Design of User-Mode Threads in Java](https://github.com/WebAssembly/meetings/blob/master/stack/2021/W3C%20Loom.pdf) (Ron Pressler)
  Meeting: [1-25-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-1-25.md)
  
* [Control Flow Integrity & Stack Switching](https://docs.google.com/presentation/d/1IBN24Dqe-sRm6xhSE4al0l2CVevmblCimroWL9aDNAE/edit?usp=sharing&resourcekey=0-6foTTNWlBegJ8vYBRr_big) (Thibaud Michaud)
  Meeting: [2-8-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-2-8.md)
  
* [JavaScript integration](https://docs.google.com/presentation/d/1B0ib04vTEzdrtgrACwjo3Zj2LSwLSXHIKl_5rnLq-Ww) (Luke Wagner)
  Meeting: [3-8-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-3-8.md)

* [Erlang Promises](https://docs.google.com/presentation/d/1zueIL_COgMoNNjDEpBjVlyVv09_VHeNmyBj70Zrt-aw) (Luke Imhoff)
  Meeting: [3-8-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-3-8.md)
  
* [Effect Handlers in C/C++](https://github.com/WebAssembly/meetings/blob/main/stack/2021/presentations/wasm-libh.html) (Daan Leijen)
  Meeting: [3-22-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-3-22.md)

* [Lightweight threads, actors, async/await, ..., in a minimal extension of the WebAssembly reference interpreter](https://github.com/WebAssembly/meetings/blob/main/stack/2021/presentations/2021-04-19-lindley-continuation-examples.pdf) (Sam Lindley)
  Meeting: [4-5-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-4-5.md)
  
* [A Two-pronged roadmap](https://github.com/WebAssembly/meetings/blob/main/stack/2021/presentations/2021-05-03-tate-two-pronged-plan.pdf) (Ross Tate)
  Meeting: [5-3-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-5-3.md)

* [A Risk analysis for implementing Stack Switching in V8](https://docs.google.com/presentation/d/114dMzeEdPKC3PeV8_EIo93UP3McfAFxZAQHMTQdBhJQ/edit?usp=sharing) (Francis McCabe)
  Meeting: [5-3-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-5-3.md)

* [Support for Coroutining in Racket/Chez Scheme](https://github.com/WebAssembly/meetings/blob/master/stack/2021/presentations/2021-5-17-flatt-racket-intermediate-language-control.pdf) (Matthew Flatt)
  Meeting: [5-17-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-5-17.md)

* [Effective Programming in OCaml](https://kcsrk.info/papers/retro-concurrency_pldi_21.pdf) (KC Sivaramakrishnan) 
  Meeting: [6-4-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-6-14.md)

* [Progress on JS API for stack switching](https://github.com/WebAssembly/meetings/blob/main/stack/2021/presentations/2021-06-28-tate-async-await-js-api.pdf) (Ross Tate & Luke Wagner)
  Meeting: [6-28-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-6-28.md)

* [Go-lang on Wasm](https://github.com/WebAssembly/meetings/blob/12cc98677a80d4143da97ad9e1243e17093801ce/stack/2021/presentations/2021-7-12%20Go%20implementation.pdf) (Cherry Mui, Jeremy Faller, Austin Clements, Michael Knyszek, Michael Pratt) 
  Meeting: [7-12-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-7-12.md)

* [Switchable Stacks & V8](https://docs.google.com/presentation/d/1oYzhndtUQXLRe28FGu7JkhMCe4j_yDvo8x-60sdJ-_4/edit?usp=sharing) (Francis McCabe)
  Meeting: [8-23-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-8-23.md)

* [Typed continuations as the basis for stack switching](https://github.com/WebAssembly/meetings/blob/main/stack/2021/presentations/2021-9-20-TypedContinuations.pdf) (Daniel Hillerström)
  Meeting: [9-20-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-9-20.md)

* [TinyGo](https://docs.google.com/presentation/d/11n3xICqxy1oqgEl3wv4k7E2DgHf_vVsMKyDffPycU-A/edit?usp=sharing) (Ayke van Laethem)
  Meeting: [10-18-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-10-18.md)

* [Wasm with typed continuations continued](https://github.com/WebAssembly/meetings/blob/78cfd1b3f3c1e7419319a309433b446fbe3fca8d/stack/2021/presentations/wasmfx.pdf) (Sam Lindley)
  Meeting: [11-1-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-11-1.md)

* [Concurrency Models for Swift]() (John McCall)
  Meeting: [11-15-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-11-15.md)

* [A Deep Dive into Multi-Core OCAML Effect Implementation]() (Ross Tate)
  Meeting: [11-29-2021](https://github.com/WebAssembly/meetings/blob/ad81cdb9b99135d7dd4c23281c8da3bdbce28603/stack/2021/sg-11-29.md)
  
* [Retrospective on 2021](https://docs.google.com/presentation/d/1sQ3iYAGwxc_6iEe_ygcs_oBax4in_pJ5TQyh5FkdrzQ/edit?usp=sharing) (Francis McCabe)
  Meeting: [12-13-2021](https://github.com/WebAssembly/meetings/blob/4ee4b8597d2fc8018b18d9b081d7384d652bcd34/stack/2021/sg-12-13.md)
  
"
stack/2020/SG-11-16.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 16th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**: November 16th, 17:00-18:00 UTC (November 16th, 9am-10am Pacific Standard Time)
- **Location**: *link on calendar invite*


## Participants

Francis McCabe
Donald Pinckney
Luke Imhoff
Alon Zakai
Daniel Hillerström
Zalim Bashorov
Paul Schoenfelder
Arjun Guha
Andreas Rossberg
Luke Wagner
Sam Lindley
Ioanna Dimitriou
Asumu Takikawa
Ross Tate
KC Sivaramakrishnan
Rick Battagline
Michał ""phoe"" Herda
Derek Schuff
Thomas Lively


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. [Wasm/k: Delimited Continuations for WebAssembly](https://github.com/donald-pinckney/WasmContinuations/blob/master/DLS%20Talk%20Short.pdf) (Donald Pinckney) [35 mins]
    Video link of similar [presentation](https://www.youtube.com/watch?v=2xp1gfYrmi0).
   1. Call for presentations [2 mins].
1. Closure

## Meeting Notes

### Adoption of the agenda

### Discussion:

Donald Pinckney presentation on Wasm/k

DP: C vs Go performance on Wasm
DP: Go’s performance on Wasm not so great
DP: Two sources of inefficiency: green threads and GC
DP: Go needs to spill all locals onto shadow stack
DP: Developed C/k as a simple extension to C that has stack manipulation primitives
DP: C/K adds control(), restore(), continuation_copy(), continuation_delete() and prompt()
DP: Wasm/k semantics in terms of small steps
DP: Use stacks of continuation tables to enforce delimited continuation copies



### Closure
"
main/2021/CG-01-19.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 19th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: January 19th, 5pm-6pm UTC (January 19th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Announce rescheduled SOIL Seminar on Mon Feb 1 at 9am PT: ""Compiling Project Everest to WebAssembly"" by Jonathan Protzenko (Ross Tate) [2 min]
    1. [Extended Constant Expressions](https://github.com/WebAssembly/design/issues/1392) (10 - 15 min)
       1. Poll for phase 1
    1. [SIMD](https://github.com/WebAssembly/simd) updates (15 - 20 min)
    1. [Proposal: Fp IEEE compliance levels](https://github.com/WebAssembly/design/issues/1393) (20 min)
       1. Poll for phase 0 or 1
    1. [Waiting on main thread behaviour](https://github.com/WebAssembly/threads/issues/174) (5 min)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Added after the meeting.
"
wasi/2019/WASI-08-30.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the August 30 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: August 30, 06:00–07:00 UTC -- Note the time change!
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. WASI for Embedded, by Wang, Xin
    1. Update on the Interface description based on Module types:
        - https://github.com/WebAssembly/WASI/pull/74

1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Attendees:

Dan Gohman
Xin Wang
Leon Wang
Arun Purushan
Till Schneidereit
Tyler McMullen
Sam Clegg

Meeting notes:

Time zone: 
XW: Seems like we can move to the previous time.
DG: We can be flexible in the future too.

XW: Presentation on WASI for Embedded

DG: Update on https://github.com/WebAssembly/WASI/pull/74
"
stack/2021/sg-11-15.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 15th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  November 15th, 16:00-17:00 UTC ( November 15th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
- Francis McCabe
- Ryan Hunt
- Rick Battagline
- Keith Miller
- Arnold Schwaighofer
- Thibaud Michaud
- Sam Lindley
- Alon Zakai
- Zalim Bashorov
- Ben Titzer
- Andreas Rossberg
- Luke Wagner
- John McCall
- Adam Klein
- Ross Tate
- Paul Schoenfelder
- Derek Schuff
- Ioanna Dimitriou
- Michael Knyszek



## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. Concurrency Models for Swift (Apple)

   2. Next meeting [2 mins].
1. Closure

## Meeting Notes

John McCall [JM]
First half of a presentation planned for LLVM
John gives a presentation outlining some aspects of the implementation of asynchronous functions in Swift.
Relationship between tasks maintained by caller allocated frames.

There was a lot of discussion about many individual topics:
Arm CFI
Whether the concept of first class continuations is present in Swift



### Adoption of the agenda

### Discussion:

### Adjourn

"
stack/2023/stack-2023-07-17.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 17th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  July 17th, 16:00-17:00 UTC ( July 17th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants

- Francis McCabe
- Andreas Rossberg
- Frank Emrich
- Daniel Hillerström
- Ilya Rzvov
- Ross Tate
- Zalim Bashorov
- Jérome Vouillon
- Brendan Dahl
- Thibaud Michaud
- Ryan Hunt
- Ashley Nelson
- Justin Michaud
- Thomas Lively
- Ben Titzer
- Adam Klein
- Deepti Gandluri
- Paul Schoenfelder

## Agenda items
1. [Typed Continuations, the Wasmtime Perspective](https://github.com/WebAssembly/meetings/blob/04f1668b83b79d5552e3c29328e450642c29b3c4/stack/2023/presentations/wasmfx-stacks2023-07.pdf)
 (Daniel Hillerström)



### Adoption of the agenda


### Discussion: Typed Continuations, the Wasmtime Perspective (Daniel Hillerström)

This presentation is recorded, available [here](https://us02web.zoom.us/rec/share/33Kb2vZmcvb-Q8HvuTXiPtpBzyTZGyjvXXTQW85IzoHoK2rOImiy1zgGyoApQXb6.RnbFwMi_hPwVD7YP).

DH presenting slides.

FM: Implementing growable stacks?

DH: Not yet, unlikely to do growable stacks. The plan is to move into codegen so we don’t involve things outside of wasm.

RT: Purpose of return in suspend trait?

DH: No purpose, maybe something in the function interface uses return. I could remove it.

FM: What do you mean by microbenchmarks? IMO, they are important but should be focused on specific metrics: e.g., the ratio of a function call to a switch.


### Adjourn

"
stack/2023/stack-2023-11-20.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 20th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  November 20th, 17:00-18:00 UTC ( November 20th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
* Francis McCabe
* Ross Tate
* Yuri Delendik
* Sam Lindley
* Ilya Rezvov
* Daniel Hilleström
* Brendan Dahl
* Zalim Bashorov
* Thibaud Michaud
* Thomas Lively
* Luke Wagner
* Deepti Gandluri
* Adam Klein
* Frank Emrich


## Agenda items

1. Review outstanding JSPI [issues](https://github.com/WebAssembly/js-promise-integration/issues) 

### Adoption of the agenda



### Discussion

Slides are [here](https://docs.google.com/presentation/d/1eZrOPWdxhBkU-wm-HQujsLLOKoarriAoXnkUcN1FHN0/)

This meeting was recorded, recording is [here](https://us02web.zoom.us/rec/share/OWpQlTnI5holkpHZQIs7wIpEeevsbEkHrL-pBB1wbB7jp8vG0zfL5mF_qUYsZbFC._GbmquC9jQz5AsKi)

* Are suspenders necessary?

  This discussion was tabled until the next discussion.

* Should wrapped imports resolve their inputs?

  After discussing the special scenario involving Atomics.awaitAsync, it was decided that we should follow the TAG guidelines and enforce inputs of wrapped imports to be Promises (with the net effect that invoking a wrapped import will always result in suspending the application).

* How to implement feature detection?

  If the Suspender object is not available, then this can be done using WebAssembly.function with a 'suspending' option (this results in an exception if JSPI is not available).

### Adjourn

"
main/2021/CG-07-20.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 20th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: July 20th, 4pm-5pm UTC (July 20th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. [Update + Discussion on Constant-Time Proposal](https://github.com/WebAssembly/constant-time) [20 mins]
        1. Poll for phase 1
    1. [Update on Instrument Tracing Proposal](https://github.com/WebAssembly/instrument-tracing) [20 mins] (view [slides](presentations/2021-07-20-abraham-winterton-trace-proposal.pdf))
        1. Poll for phase 2
    1. [Update on Exception Handling Proposal](https://github.com/WebAssembly/exception-handling) [20 mins] (view [slides](presentations/2021-07-20-ahn-exception-handling.pdf))
        1. Poll for phase 3
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

To be added after the meeting.
"
template.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the TBD meeting of WebAssembly's Community Group

- **Host**: TBD
- **Dates**: TBD
- **Times**:
    - 10:00 to 17:00 PDT on TBD
    - 10:00 to 16:00 PDT on TBD
- **Location**: TBD
- **Wifi**: TBD
- **Dinner**: TBD
- **Contact**:
    - Name: TBD
    - Phone: TBD
    - Email: TBD

## Logistics

* Where to park
* How to access the building
* Technical presentation requirements (adapters, google hangouts/other accounts required, etc.)
* Any other logistics required to participate in the meeting

### Registration

TBD

### Hotels

TBD Hotels nearby (optional)

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
    1. Host facilities, local logistics
1. Find volunteers for note taking
1. Adoption of the agenda
1. Approval of the minutes from last meeting
1. Proposals and discussions
    1. Agenda item goes here
    1. Agenda item goes here
    1. Agenda item goes here
    1. Agenda item goes here
1. Closure

### Schedule constraints

## Dates and locations of future meetings

TBD (Copy the table from the previous agenda)

## Meeting notes

Notes added here after the meeting.
"
main/2019/CG-09-17.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 17th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: September 17th, 4pm-5pm UTC (September 17th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Status update on Feature Detection proposal (Thomas Lively)
        1. Poll: Should we change the name from ""Feature Detection"" to ""Conditional Compilation"" or similar?
    1. Proposal for enabling multiple memories (Andreas Rossberg)
    1. Renaming the start function? (Andreas Rossberg)
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes
"
wasi/2019/WASI-12-19.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the December 19 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: December 19, 17:00-18:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Stack trace API
       1. https://github.com/WebAssembly/WASI/issues/159
       1. Whare are the next steps here?
    1. Windowing and Framebuffer APIs
       1. https://github.com/WebAssembly/WASI/issues/171
       1. https://github.com/WebAssembly/WASI/issues/174
       1. What guidance can we give to folks interested in working on these?
1. Closure

## Meeting Notes

Windowing and Framebuffer APIs:

There's an early demo out, and it's gotten some feedback. Aarron Turner is
working on incorporating the feedback and putting together a proposal.
"
wasi/2021/WASI-10-07.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: October 07 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: October 7, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. Pointing out [component-model/#1](https://github.com/WebAssembly/component-model/pull/1) in case WASI folks have feedback (as many participants' use cases have been incorporated).  Discussion during the meeting is also welcome if there is free time.
    3. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. Demo of `async` support in `witx-bindgen` (@alexcrichton, 15min)
    1. Walk and talk through some example WASI component scenarios (@lukewagner, flexible time, this can go at the end) ([slides](https://docs.google.com/presentation/d/11lY9GBghZJ5nCFrf4MKWVrecQude0xy_buE--tnO9kQ))
    1. _Sumbit a PR to add your agenda item here_
"
debugging/2020/debugging-04-30.md,"# Meeting notes for the April 30 video call of WebAssembly's debugging subgroup

- **Where**: zoom.us
- **When**: April 30, 11am-11:10 Pacific Standard Time (April 30, 6pm UTC, 8pm CET)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Derek Schuff
    - Email: dschuff@google.com
    
## Notes:

* Paolo is working on finishing support in LLDB to debug wasm modules over the gdb-remote protocol (https://reviews.llvm.org/D78801)
There was some pushback on the architecture of the patch from the LLDB maintainers, Paolo is refactoring it a bit.

* Philip has landed the first iteration of the wasm symbol server in Chrome devtools (https://chromium-review.googlesource.com/c/devtools/devtools-frontend/+/2157027)
It has support for breakpoints, listing variables, stepping. The dynamic parts like variable evauluation are still ongoing.

* Wouter is working on LLVM support for emitting debug info for stackified values. He made a prototype to update the debug_value
operands in the RegisterStackify pass, but that's brittle because other passes also sometimes create stackified values. Instead
we will try it just before WebAssemblyMCInstLower (it can't be done in MCInstLower directly because the AsmPrinter removes
things before MCInstLower gets to see them).
"
main/2021/CG-08-17.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 17th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: August 17th, 4pm-5pm UTC (August 17th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Update on [Branch Hinting](https://github.com/WebAssembly/branch-hinting) [30 min].
        1. Presentation: a framework for code annotations
        1. Discussion
    1. Discussion on [Wasm signatures proposal](https://github.com/wasm-signatures/design) [20 min]. 
        1. Poll for phase 1
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

To be added after the meeting.
"
main/2023/WG-11-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 8th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: November 8th, 2023 at 4pm-5pm UTC *( November 8th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Next steps for releasing Wasm 2.0
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

Meeting cancelled due to lack of agenda.
"
wasi/2020/WASI-06-04.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the June 4 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: June 4, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Proposals and discussions
    1. wasi-sdk release 11
        1. https://github.com/WebAssembly/wasi-sdk/issues/139
    1. Commands and Reactors:
        1. Heads-up: -mexec-model=reactor on clang trunk, use with wasi-libc trunk
    1. Update on repositories: wasi-nn, wasi-http-proxy, etc.
    1. WASI-http-proxy next steps
        1. https://github.com/WebAssembly/WASI-http-proxy
        1. Feedback given earlier is that it'd be good to look
           at splitting out some of the parts. How can we help?
    1. Multi-call commands (Dan)
        1. https://github.com/WebAssembly/WASI/pull/281
    1. Async
        1. https://github.com/WebAssembly/WASI/issues/276

## Meeting Notes
"
main/2020/CG-11-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 10th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: November 10th, 5pm-6pm UTC (November 10th, 9am-10am Pacific Standard Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. POLL: [relaxed dead code validation](https://github.com/WebAssembly/relaxed-dead-code-validation) to Phase 2 (Conrad Watt and Ross Tate) [30 min]
    1. POLL: [branch hinting](https://github.com/yuri91/branch-hinting) to Phase 1 (Yuri Iozzelli) [10 min]
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Added after meeting.
"
stack/2022/5-9-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 9th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  May 9th, 16:00-17:00 UTC ( May 9th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Elle Imhoff
Ross Tate
Luke Wagner
Zalim Bashorov
Thibaud Michaud
Lucy Amidon
Daniel Hillerström
Ilya Rezvov
Andreas Rossberg
Sam Lindley
Ryan Hunt
Deepti Gandluri
Derek Schuff
Arjun Guha


## Agenda items

1. [Component Model Async support](https://docs.google.com/presentation/d/1MNVOZ8hdofO3tI0szg_i-Yoy0N2QPU2C--LzVuoGSlE) (Luke Wagner)

## Meeting Notes

### Adoption of the agenda

### Discussion

[Meeting recording](https://us02web.zoom.us/rec/share/IE-YHBX66B7u-hWD8Omjrp7bkrjFhlM03UVZzq0Qt11BV9gVBvt9hr7fHFE2s0K4.2CBqNwEwAmKXCkt5) available.

SL: Who does the fusing of the lifting & lowering adapters
LW: This code would be generated during an additional compilation step, which can be seen as part of module linking.

AR: Future<String> did not have an explicit length param in the canonical ABI
LW: The resizing of the string is done automatically using realloc.

AR: All the core signatures use i32 which is a kind of void pointer. Do you imagine some better annotations?
LW: The documentation is primarily coming from the interface type layers.



### Adjourn

"
main/2020/CG-04-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 14th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: April 14th, 4pm-5pm UTC (April 14th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
    1. Discuss [low-level stack and control primitives](https://github.com/WebAssembly/exception-handling/issues/105)
       - No decisions, just review and collective brainstorming
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Ross Tate presenting slides for Stack and Control Primitives [(pdf)](presentations/2020-04-14-tate-stack-primitives.pdf) [(pptx)](presentations/2020-04-14-tate-stack-primitives.pptx)
"
main/2023/WG-10-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 11th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: October 11th, 2023 at 3pm-4pm UTC *( October 11th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

Meeting cancelled due to lack of agenda.
"
wasi/2020/WASI-07-02.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the July 2 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: July 2, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Proposals and discussions
    1. Update on action items.
        1. proxy-wasm repo
    1. Discussion topic: WASI and POSIX
        1. https://github.com/WebAssembly/WASI/issues/292
        1. What should we do on `lseek` past the end of a file?
        1. Should POSIX be a normative reference for the filesystem etc. APIs?
        1. Documentation philosophy.
    1. Heads-up: Module-linking-based dynamic linking:
        1. https://github.com/WebAssembly/module-linking/blob/master/proposals/module-linking/Example-SharedEverythingDynamicLinking.md
    1. Tooling for new-style commands:
        1. https://reviews.llvm.org/D81689

## Meeting Notes
"
main/2023/WG-05-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 10 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: May 10, 2023 at 3pm-4pm UTC *( May 10, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

To be added after the meeting.
"
main/2019/WG-04-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 10 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: April 10, 2019 at 3pm-4pm UTC *( April 10, 2019 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
1. Future meetings
    1. Confirm next meeting date + time.
    1. Discuss plans for [2019 TPAC meeting in Fukuoka, Japan](https://www.w3.org/2019/09/TPAC/)
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

Posted after meeting.
"
main/2024/WG-05-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the 2024-05-08 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: 2024-05-08 at 15:00-16:00 UTC *( May 8th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

Meeting canceled due to lack of agenda.
"
stack/2021/sg-2-8.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 8th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**: February 8th, 17:00-18:00 UTC (February 8th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe 
Luke Imhoff
Ross Tate
Thibaud Michaud
Andreas Rossberg
Adam Klein
Paul Schoenfelder
Sam Lindley
Arjun Guha
Thomas Lively
Zalim Bashorov
Derek Schuff
Alon Zakai
Luke Wagner
Heejin Ahn


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. Proposal for [mini-workshop](https://docs.google.com/presentation/d/1_3iPRQPpJ6-4ZQj0mUNqaDqDSnGRz1tH0nKcQXUFX_s/edit?usp=sharing) (Francis McCabe) [10 mins]
   1. [Control Flow Integrity & Stack Switching](https://docs.google.com/presentation/d/1IBN24Dqe-sRm6xhSE4al0l2CVevmblCimroWL9aDNAE/edit?usp=sharing&resourcekey=0-6foTTNWlBegJ8vYBRr_big) (Thibaud Michaud) [45 mins]
   1. Call for presentations [1 min].
   1. Next meeting [2 mins].
1. Closure

## Meeting Notes
Fgm introduced scenario for next meeting: a discussion on how to prevent foreign frames in delimited continuations.
Asked for volunteers (Arjun, Ross & Sam volunteered)

Thibaud introduced hardware assisted CFI.

### Adoption of the agenda

### Discussion:

### Adjourn

"
main/2024/WG-09-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the 2024-09-11 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: 2024-09-11 at 15:00-16:00 UTC *( September 11th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

**Meeting cancelled due to empty agenda.**
"
wasi/2020/WASI-07-16.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the July 16 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: July 16, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Proposals and discussions
    1. WASI testsuite activities
        1. https://github.com/WebAssembly/WASI/issues/9
        1. What kinds of tests should be in an official testsuite?
        1. Where should we collect them?
    1. Discussion topic: Threads
        1. https://github.com/WebAssembly/threads/issues/8
        1. https://github.com/WebAssembly/threads/issues/95
        1. https://github.com/WebAssembly/threads/issues/138
    1. Discussion topic: `fd_seek` past the end of a file on Windows
        1. https://github.com/WebAssembly/WASI/issues/292
    1. Discussion topic: Symbolic links and Windows

## Meeting Notes
"
wasi/2020/WASI-10-08.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the October 8 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: October 8, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: hello@sunfishcode.online

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Add items here!
    1. wasi-sdk update waiting for LLVM 11.0 release
        1. https://llvm.org/
    1. Interface Types update:
        1. https://github.com/WebAssembly/interface-types/pull/122
    1. WASI is being mentioned a lot in the GC repo:
        1. eg. https://github.com/WebAssembly/gc/issues/143
    1. WASI testsuite
        1. https://github.com/WebAssembly/WASI/issues/9
        1. What do we want to build towards?
    1. WASI sockets
        1. https://github.com/WebAssembly/WASI/pull/312
        1. Merge soon, and iterate?

## Meeting Notes
"
main/2022/WG-09-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 14th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: September 14th, 2022 at 3pm-4pm UTC *( September 14th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

**Meeting was canceled due to empty agenda**

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

None.

"
main/2018/WG-09-26.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 26 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: September 26, 2018 at 3pm-4pm UTC *( September 26, 2018 8am-9am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
1. Future meetings
    1. Confirm next meeting date + time.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

Meeting cancelled due to lack of agenda.
"
main/2024/WG-10-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the 2024-10-09 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: 2024-10-09 at 15:00-16:00 UTC *( October 9th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes
"
main/2024/WG-11-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the 2024-11-13 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: 2024-11-13 at 16:00-17:00 UTC *( November 13th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes
"
main/2024/WG-12-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the 2024-12-11 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: 2024-12-11 at 16:00-17:00 UTC *( December 11th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes
"
main/2019/WG-05-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 22 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: May 22, 2019 at 3pm-4pm UTC *( May 22, 2019 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
1. Future meetings
    1. Confirm next meeting date + time.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

Posted after meeting.
"
main/2019/WG-07-17.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 17 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: July 17, 2019 at 3pm-4pm UTC *( July 17, 2019 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
1. Future meetings
    1. Confirm next meeting date + time.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

Posted after meeting.
"
main/2018/WG-11-7.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 7 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: November 7, 2018 at 3pm-4pm UTC *( November 7, 2018 8am-9am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
1. Future meetings
    1. Confirm next meeting date + time.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

Meeting canceled.
"
main/2018/WG-12-05.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 5 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: December 5, 2018 at 4pm-5pm UTC *( December 5, 2018 8am-9am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (chair to volunteer).
1. Adoption of the agenda
1. Proposals and discussions
1. Future meetings
    1. Confirm next meeting date + time.
1. Closure

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

Meeting canceled.
"
wasi/2024/WASI-01-11.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: January 11 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: January 11 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. Guy Bedford: JCO progress update
    1. Open Q&A: launching WASI Preview 2, vote to follow on 01/25
"
main/2022/CG-04-26.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 26 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: April 26, 4pm-5pm UTC (April 12, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Initial proposal for [stringrefs](https://github.com/wingo/stringrefs) (Andy Wingo) [15 min]
        1. Possible poll to phase 1
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

To be added after the meeting.
"
wasi/2020/WASI-08-27.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the Aug 27 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: August 27, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: hello@sunfishcode.online

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Proposals and discussions
    1. WASI Status
        1. Update from Dan
        1. WASI moving forward
    1. Sockets API
        1. https://github.com/WebAssembly/WASI/pull/312
            1. API discussion
            1. Process discussion
    1. Testsuite
        1. https://github.com/WebAssembly/WASI/issues/9
        1. https://github.com/khronosproject/wasi-test/
        1. Should we work to make this an official testsuite?
            1. Where should it live?

## Meeting Notes
"
main/2022/CG-07-19.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 19th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: July 19th, 4pm-5pm UTC (July 19th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Update on [testing Custom Sections and Annotations](https://github.com/WebAssembly/design/issues/1445) (Yuri Iozzelli) [15 min]
3. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

To be added after the meeting.
"
main/2020/CG-02-04.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 4th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: February 4th, 5pm-6pm UTC (February 4th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Cancelled due to F2F meeting the following week.
"
main/2022/CG-03-29.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 29th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: March 29th, 4pm-5pm UTC (March 29th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Update on Relaxed SIMD postposned until next meeting
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Meeting was cancelled due to lack of agenda
"
main/2019/CG-07-23.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 23 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: July 23, 4pm-5pm UTC (July 23, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

None required if you've attended before. Email Ben Smith to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Posted after meeting.
"
main/2020/CG-01-07.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 7th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: January 7th, 5pm-6pm UTC (January 7th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Cancelled due to lack of agenda.
"
main/2021/CG-07-06.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 6th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: July 6th, 4pm-5pm UTC (July 6th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

To be added after the meeting.
"
wasi/2020/WASI-07-30.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the July 30 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: July 30, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: sunfish@mozilla.com

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Proposals and discussions
    1. Documentation for WASI APIs
        1. https://github.com/WebAssembly/WASI/issues/292
    1. WASI committee processes
        1. Proposal repos
        1. Further harmonizing the spec process with the core CG
        1. What work needs to be done, and who wants to do it?

## Meeting Notes
"
main/2020/CG-02-18.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 18th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: February 18th, 5pm-6pm UTC (February 18th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

No notes, meeting cancelled. 
"
main/2020/CG-03-17.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 17th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: March 17th, 5pm-6pm UTC (March 17th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

No notes, meeting cancelled.
"
stack/2022/sg-2-7.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 7th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  February 7th, 17:00-18:00 UTC ( February 7th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants

 - Anil Madhavapeddy
 - Andreas Rossberg
 - Ben Titzer
 - Daniel Hilerström
 - Deepti Gandluri
 - Sam Lindley
 - Francis McCabe
 - Ross Tate
 - Thibaud Michaud
 - Thomas Leonard
 - Paul Schoenfelder
 - Luke Wagner
 - Derek Schuff
 - Ioanna Dimitriou
 - Michael Knyszek


## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. [Multicore OCaml in practice](https://github.com/ocaml-multicore/multicore-talks/blob/master/wasm-wg2022-stack-switching/slides.pdf) (Anil Madhavapeddy)

   2. Next meeting [2 mins].
1. Closure

## Meeting Notes
This meeting was recorded. The recording is [available](https://us02web.zoom.us/rec/share/T5yl3zZxFy8RVvwt4wMHS6UarXLIU-WyoZmh-EuOby_EaYU3-DgiHaBUMoRmzvdb.Gu0QW8rPUa1390SR).


### Adoption of the agenda

### Discussion:

#### Multicore OCaml in practice 

### Adjourn

"
wasi/2024/WASI-09-19.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: September 19 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: September 19 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. _Submit a PR to add your announcement here_
"
wasi/2024/WASI-10-03.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: October 03 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: October 03 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. _Submit a PR to add your announcement here_
"
wasi/2024/WASI-10-17.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: October 17 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: October 17 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. _Submit a PR to add your announcement here_
"
wasi/2024/WASI-10-31.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: October 31 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: October 31 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. _Submit a PR to add your announcement here_
"
wasi/2024/WASI-11-14.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: November 14 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: November 14 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. _Submit a PR to add your announcement here_
"
wasi/2024/WASI-11-28.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: November 28 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: November 28 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. _Submit a PR to add your announcement here_
"
wasi/2024/WASI-12-12.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: December 12 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: December 12 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. _Submit a PR to add your announcement here_
"
wasi/TEMPLATE.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: {month} {day} WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: {month} {day} 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: phickey@fastly.com and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. _Submit a PR to add your announcement here_
"
main/2019/CG-09-03.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 3rd video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: September 3rd, 4pm-5pm UTC (September 3rd, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Posted after meeting.
"
main/2021/CG-02-02.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 2nd video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: February 2nd, 5pm-6pm UTC (February 2nd, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Meeting cancelled.
"
main/2021/CG-08-31.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 31st video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: August 31st, 4pm-5pm UTC (August 31st, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Meeting cancelled.
"
main/2021/CG-09-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 14th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: September 14th, 4pm-5pm UTC (Spetember 14th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Meeting cancelled.
"
stack/2021/sg-1-25.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 25th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**: January 25th, 17:00-18:00 UTC (January 25th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants

Francis McCabe 
Zalim Bashorov
Paul Dworzanski
Ron Pressler
Luke Imhoff
Ioanna Dimitriou
Sam Lindley
Derek Schuff
Paul Schoenfelder
Alan Bateman
Asumu Takikawa
Rick Battagline
Biran Goetz
Andreas Rossberg
Luke Wagner
Arjun Guha
Ross Tate
Thibaud Michaud

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Discussions
   1. [The Design of User-Mode Threads in Java](https://github.com/WebAssembly/meetings/blob/master/stack/2021/W3C%20Loom.pdf) (Ron Pressler) [35 mins]
   1. Call for presentations [1 mins].
   1. Next meeting [1 mins].
1. Closure

## Meeting Notes

Ron Pressler gives a presentation on Java’s Loom project.


### Adoption of the agenda

### Discussion:

### Adjourn
"
main/2019/CG-10-15.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 15th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: October 15th, 4pm-5pm UTC (October 15th, 9am-10am Pacific Daylight Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Review of action items from prior meeting.
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes
"
main/2022/CG-12-06.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 6th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: December 6th, 5pm-6pm UTC (December 6th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
    1. [Coredump for post-mortem debugging](https://github.com/xtuc/wasm-coredump-format): [slides](https://docs.google.com/presentation/d/1WYCXg7HqUrRFKNvln4V--sTmMn2KsTAnNJCgP6nN5y4/edit?usp=sharing) [15 min]
3. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

To be added after the meeting.
"
main/2021/CG-12-07.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 7th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: December 7th, 5pm-6pm UTC (December 7th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Meeting cancelled due to lack of agenda items.
"
main/2021/WG-05-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 12th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: May 12, 2021 at 4pm-5pm UTC *( May 12th, 9am-10am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

** Meeting was canceled due to empty agenda **

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

To be added after the meeting.
"
main/2021/WG-06-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 9th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: June 9, 2021 at 4pm-5pm UTC *( June 9th, 9am-10am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

** Meeting was canceled due to empty agenda **

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

To be added after the meeting.
"
main/2021/WG-08-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 9th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: August 11, 2021 at 3pm-4pm UTC *( August 11th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

** Meeting was canceled due to empty agenda **

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

To be added after the meeting.
"
main/2021/WG-09-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 9th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: September 8, 2021 at 3pm-4pm UTC *( September 8th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

** Meeting was canceled due to empty agenda **

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

To be added after the meeting.
"
main/2022/CG-01-04.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 4th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: January 4th, 5pm-6pm UTC (January 4th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Meeting cancelled due to lack of agenda.
"
main/2022/CG-02-01.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 1st video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: February 1st, 5pm-6pm UTC (February 1st, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

To be added after the meeting.
"
main/2022/CG-09-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 13th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: September 13th, 4pm-5pm UTC (September 13th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

To be added after the meeting.
"
main/2021/WG-10-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 9th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: October 13, 2021 at 3pm-4pm UTC *( October 13th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

**Meeting was canceled due to empty agenda**

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

To be added after the meeting.
"
main/2021/WG-11-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 9th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: November 10, 2021 at 4pm-5pm UTC *( November 10th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

**Meeting was canceled due to empty agenda**

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

To be added after the meeting.
"
main/2021/WG-12-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 9th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: December 8, 2021 at 4pm-5pm UTC *( December 8th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

**Meeting was canceled due to empty agenda**

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

To be added after the meeting.
"
main/2022/WG-01-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 12th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: January 12th, 2022 at 4pm-5pm UTC *( January 12th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

**Meeting was canceled due to empty agenda**

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

To be added after the meeting.
"
main/2022/WG-02-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 9th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: February 9th, 2022 at 4pm-5pm UTC *( February 9th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

**Meeting was canceled due to empty agenda**

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

To be added after the meeting.
"
main/2022/WG-03-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 9th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: March 9th, 2022 at 4pm-5pm UTC *( March 9th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

**Meeting was canceled due to empty agenda**

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

To be added after the meeting.
"
main/2022/WG-05-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 11th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: May 11th, 2022 at 3pm-4pm UTC *( May 11th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

**Meeting was canceled due to empty agenda**

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

To be added after the meeting.
"
main/2023/WG-02-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 8th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: February 8th, 2023 at 4pm-5pm UTC *( February 8th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

**Meeting cancelled due to empty agenda**

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

To be added after the meeting.
"
main/2023/WG-06-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 14th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: June 14th, 2023 at 3pm-4pm UTC *( June 14th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

**Meeting cancelled due to empty agenda**

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

To be added after the meeting.
"
main/2023/WG-07-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 12th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: July 12th, 2023 at 3pm-4pm UTC *( July 12th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

**Meeting cancelled due to empty agenda**

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

To be added after the meeting.
"
main/2021/CG-12-21.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 21st video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: December 21st, 5pm-6pm UTC (December 21st, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Meeting cancelled.
"
main/2022/CG-05-24.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 24 video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: May 24, 4pm-5pm UTC (April 12, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Meeting Cancelled.
"
main/2022/CG-06-07.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 7th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: June 7th, 4pm-5pm UTC (June 7th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

Meeting cancelled.
"
stack/2024/stack-2024-02-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 12th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  February 12th, 17:00-18:00 UTC ( February 12th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Sam Lindley
Yury Delendik
Ilya Rezvov
Daniel Hillerström
Thibaud Michaud
Frank Emrich
Ashley Nelson
Ryan Hunt
Luke Wagner
Ben Titzer
Thomas Lively
Zalim Bashorov
Paul Schoenfelder
Brendan Dahl
Derek Schuff

## Agenda items

1. Discussion about the future of the JSPI API design, given that we are dropping the Suspender object. (Ilya Rezvov).

Slides [here](https://docs.google.com/presentation/d/1mSfKS5KqaEBvUrZJ8hqcFXVtdlAB11MHi57Lf71iQS4/edit#slide=id.p)

This meeting was recorded; the recording is available [here](https://us02web.zoom.us/rec/share/-gaDO3uSaSkL7CPnXtMLXyW-Ac67iyc2O6ja7L9ZZqKY168PvZhkj0knQSBBTPvm.sTlTflYix6MF_Fi0)

### Adoption of the agenda

Vote on whether to change the API of JSPI following the proposal in the slides adopting Option 1 for imports.

SF: 6
F: 6
N: 1

### Discussion

### Adjourn

"
main/2022/WG-12-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 14th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: December 14th, 2022 at 4pm-5pm UTC *( December 14th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

## Agenda items

** Meeting cancelled due to empty agenda **

## Agenda items for future meetings

None.

"
wasi/2022/WASI-10-20.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: October 20 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: October 20, 16:00-17:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. WASI certification tests - Marcin Kolny
    1. Removing `_initialize` from the reactor definition - Dan Gohman
       1. https://github.com/WebAssembly/WASI/pull/497
"
main/2022/WG-06-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the June 8th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: June 8th, 2022 at 3pm-4pm UTC *( June 8th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

## Agenda items

**Meeting was canceled due to empty agenda**


## Agenda items for future meetings

None.

"
main/2022/WG-07-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 13th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: July 13th, 2022 at 3pm-4pm UTC *( July 13th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

## Agenda items

**Meeting was canceled due to empty agenda**


## Agenda items for future meetings

None.

"
main/2022/WG-08-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 10th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: August 10th, 2022 at 3pm-4pm UTC *( August 10th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

## Agenda items

**Meeting was canceled due to empty agenda**

## Agenda items for future meetings

None.
"
main/2022/WG-11-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 9th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: November 9th, 2022 at 4pm-5pm UTC *( November 9th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

## Agenda items

**Meeting was canceled due to empty agenda**

## Agenda items for future meetings

None.

"
benchmarking/template.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the {Date} video call of WebAssembly's Benchmarking Subgroup

- **Where**: Google Meet
- **When**: {Date}, 4pm-4:45pm UTC (8am-8:45am PDT, 11am-11:45am EST)
- **Location**: _Link on calendar invite_
- **Contact**:
    - Name: Petr Penzin, Saúl Cabrera
    - Email: penzin.dev@gmail.com, saul.cabrera@shopify.com


### Registration

If this is your first time attending, please [fill out the registration form](https://forms.gle/QCmhyM4QwvWvZR9b8) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

### Logistics

This meeting will be a Google Meet video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes
    1. Please help take notes.
1. Announcements
1. Proposals and discussions
1. Closure

## Meeting notes

Notes added here after the meeting.
"
main/2023/CG-05-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 9th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: May 9th, 4pm-5pm UTC (May 9th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
1. Closure

## Meeting Notes

*Meeting cancelled due to lack of agenda*
"
main/2023/CG-10-24.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 9th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: October 24th, 4pm-5pm UTC (October 24th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
1. Closure

## Meeting Notes

*Meeting cancelled due to lack of agenda*
"
main/2023/WG-04-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 12 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: April 12, 2023 at 3pm-4pm UTC *( April 12, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

**Meeting cancelled due to empty agenda**

## Agenda items for future meetings

None.

"
main/2024/CG-01-02.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 2nd video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: January 2nd, 5pm-6pm UTC (January 2nd, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Proposals and discussions
1. Closure

## Meeting Notes

Meeting canceled due to lack of agenda.
"
stack/2023/stack-2023-11-06.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 6th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  November 6th, 17:00-18:00 UTC ( November 6th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants

Francis McCabe
Jerome Vouillon
Sam Lindley
Andreas Rossberg
Ross Tate
Frank Emrich
Ilya Rezvov
Zalim Bashorov
Thibaud Michaud
Luke Wagner
Brendan Dahl
Thomas Lively

## Agenda items

1. Two implementations of OCaml effect handlers in WebAssembly (Jérôme Vouillon, Tarides) [slides](https://docs.google.com/presentation/d/1uX0jBBWWYgN6waq67bO9n2mSe-uCIoO8KudyWrF2Bho/edit#slide=id.p)

### Adoption of the agenda

### Discussion

Due to technical issues, there is no recording of this session.

Some discussion about the potential reason for the significant performance penalty of using JSPI vs CPS transform:
FM: possible cause is the fact that with JSPI every suspend goes through the event loop.



### Adjourn

"
main/2021/WG-04-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 14th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: April 14, 2021 at 4pm-5pm UTC *( April 14th, 9am-10am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Agenda items

**Meeting was canceled due to empty agenda 24 hours before.**
"
main/2018/WG-06-20.md,"![WebAssembly logo](/images/WebAssembly.png)

## Canceled -- Agenda for the June 20 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: June 20, 2018 at 3pm-4pm UTC *( June 20, 2018 8am-9am PT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Ben Smith
    - Email: binji@google.com

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register
here:
https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Canceled for lack of agenda items

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

Posted after meeting.
"
wasi/2022/WASI-01-27.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: January 27 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: January 27, 17:00-18:00 UTC
- **Contact**:
  - Name: Lin Clark
  - Email: lclark@fastly.com

### Registration

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite.

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Sumbit a PR to add your announcement here_
1. Proposals and discussions
    1. _Sumbit a PR to add your agenda item here_
"
main/2024/CG-08-27.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 27th video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: 2024-08-27, 16:00-17:00 UTC (2024-08-27, 9am-10am PDT, 18:00-19:00 CEST)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
   1. Unified approach to stack switching (Sam Lindley & Francis McCabe, 45 minutes)
        1. Vote for phase 2
   1. JS String Builtins: vote for Phase 4 (Ryan Hunt & Adam Klein, 15 minutes)
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

To be filled in after the meeting.

### Attendees

### Proposals and discussions

### Closure
"
main/2023/WG-08-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 9th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: August 9th, 2023 at 3pm-4pm UTC *( August 9th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**Meeting cancelled due to empty agenda**

## Agenda items

**None**

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

To be added after the meeting.
"
main/2023/WG-12-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 13th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: December 13th, 2023 at 4pm-5pm UTC *( December 13th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**Meeting cancelled due to empty agenda.**

## Agenda items

None.

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes

To be added after the meeting.
"
wasi/2020/WASI-09-10.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the September 10 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: September 10, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: hello@sunfishcode.online

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Proposals and discussions
    1. Sockets API
        1. https://github.com/WebAssembly/WASI/pull/312
            1. API discussion

## Meeting Notes
"
main/2022/WG-10-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 12th video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: October 12th, 2022 at 3pm-4pm UTC *( October 12th, 8am-9am PDT )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**If no agenda items are added (after ""Review of action items from prior meeting""),
the meeting will be automatically canceled.**

## Meeting Cancelled due to lack of agenda

"
stack/2022/4-25-2022.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 25th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  April 25th, 17:00-18:00 UTC ( April 25th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
 - Francis McCabe
 - Thibaud Michaud
 - Ben Titzer
 - Derek Schuff
 - Lars Hansen
 - Paul Schoenfelder
 - Deepti Ganduri
 - Luke Wagner
 - Sam Lindley
 - Arjun Guha
 - Zalim Bashorov
 - Adam Klein

## Agenda items

1. [Progress on experimental implementation of JS Promise integration](https://docs.google.com/presentation/d/12ATn54HQ8iv-rVG11K0ZwuEjLWw66YhsP3UD3_0KYm8) (Thibaud Michaud & Francis McCabe)

## Meeting Notes

TB & FM presented progress results on the JS Promise integration effort, especially implementation experiments within V8.

### Adoption of the agenda

### Discussion

TM: 
### Adjourn

"
main/2023/CG-01-03.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 3rd video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: January 3rd, 5pm-6pm UTC (January 3rd, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

*Meeting cancelled due to lack of agenda*

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

To be added after the meeting.
"
main/2024/CG-08-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 13th video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: 2024-08-13, 16:00-17:00 UTC (2024-08-13, 9am-10am PDT, 18:00-19:00 CEST)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
   1. Update on the ESM integration (Guy Bedford, 25 minutes)
   2. New stage 1 proposal: [128-bit arithmetic](https://github.com/WebAssembly/design/issues/1522) (Alex Crichton / Jamey Sharp, 35 minutes)
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

To be filled in after the meeting.

### Attendees

### Proposals and discussions

### Closure
"
wasi/2020/WASI-09-24.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda for the September 24 video call of WASI Subgroup

- **Where**: zoom.us
- **When**: September 24, 16:00-17:00 UTC
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Dan Gohman
    - Email: hello@sunfishcode.online

### Registration

None required if you've attended before. Email Dan Gohman to sign up if it's
your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Add items here!

## Meeting Notes
"
main/2024/WG-08-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the 2024-08-14 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: 2024-08-14 at 15:00-16:00 UTC *( August 14th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

The meeting will be on a zoom.us video conference.
See the calendar invite for link.

**Meeting cancelled due to empty agenda.**

## Agenda items

None.

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes
"
process/vc-meetings.md,"# Virtual WebAssembly Meetings

The full group meets in video conferences biweekly. The usual schedule
(as well as information for joining the VC) can be found on the offical
[W3C Calendar](https://www.w3.org/groups/cg/webassembly/calendar)
but there is also a Google Calendar event that is kept up-to-date
e.g. in the event of cancellation. Contact the chairs to be added to it.
The agenda and notes are kept on GitHub in the 
[meetings](https://github.com/WebAssembly/meetings/tree/main/main) repository.

There are also several subgroups that maintain their own meeting
schedule and agenda. A 
[list](https://github.com/WebAssembly/meetings/blob/main/process/subgroups.md)
is maintained and their minutes are kept in top-level directories in the meetings
repository.

All attendees are required to be members of the
[community group](https://www.w3.org/community/webassembly/) prior to attending."
wasi/2024/WASI-07-11.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: July 11 WASI video call

Cancelled. No agenda items.

- **Where**: zoom.us (see Registration below)
- **When**: July 11 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

Cancelled. No agenda items.
"
wasi/2024/WASI-09-05.md,"![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/WASI.png)

## Agenda: September 05 WASI video call

- **Where**: zoom.us (see Registration below)
- **When**: September 05 2024, 17:00-18:00 UTC
- **Contact**:
  - Name: Pat Hickey and Bailey Hayes
  - Email: pat@moreproductive.org and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

If this is your first time attending, please [fill out the registration form](https://docs.google.com/forms/d/e/1FAIpQLSdpO6Lp2L_dZ2_oiDgzjKx7pb7s2YYHjeSIyfHWZZGSKoZKWQ/viewform?usp=sf_link) to receive an invite. Please make sure you have joined the CG as above, and that your name appears on the [membership page](https://www.w3.org/community/webassembly/participants), before registering.


## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

> **_NOTE:_**  Cancelled, no agenda items.
"
stack/2022/5-23-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 16th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  May 23rd, 16:00-17:00 UTC ( May 23rd, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
* Francis McCabe
* Luke Wagner
* Ilya Rezvov
* Ioanna Dimitriou
* Ross Tate
* Thibaud Michaud
* Zalim Bashorov
* Derek Schuff
* Paul Schoenfelder
* Ryan Hunt
* Peter Penzin
* Andreas Rossberg
* Sam Clegg
* Deepti Glanduri

## Agenda items

1. [Component Model, Async Support](https://docs.google.com/presentation/d/1MNVOZ8hdofO3tI0szg_i-Yoy0N2QPU2C--LzVuoGSlE/edit#slide=id.g11b88b15c38_0_530) cont. (Luke Wagner)

## Meeting Notes

### Adoption of the agenda

### Discussion

There is a [recording](https://us02web.zoom.us/rec/share/gV9wlNsXHaO73bWgw7bwo4dILP5CiOaiook7Nca3mQmb9yMc06RQyVDnRAnxKemf.pOZb45y2uimyoADM?startTime=1653321870000) of this meeting.

### Adjourn

"
stack/2022/readme.md,"# Presentations given in 2022

This list is for convenience only. 

* [Towards an ontology of stack switching]() (Francis McCabe)
  Meeting: [1-10-2022](https://github.com/WebAssembly/meetings/blob/e4c422b75348fb553580a9efb3fe1cd0dd30e8b7/stack/2022/sg-1-10.md)

* [Asyncify in Practice](https://kripken.github.io/talks/2022/asyncify.html#/) (Alon Zakai)
  Meeting: [1-24-2022](https://github.com/WebAssembly/meetings/blob/main/stack/2022/sg-1-24.md)

*  [Multicore OCaml in practice](https://github.com/ocaml-multicore/multicore-talks/blob/master/wasm-wg2022-stack-switching/slides.pdf) (Anil Madhavapeddy)
  Meeting: [2-7-2022](https://github.com/WebAssembly/meetings/blob/ff088ff603fd9322b8e987ad051a5c7844a07e56/stack/2022/sg-2-7.md)
  
* [Effect handlers in C++](https://github.com/WebAssembly/meetings/blob/1e594b8db8238b851c6afb3e057aeb6d99224323/stack/2022/presentations/wasm-eff-slides.pdf) (Maciej Piróg)
  Meeting: [3-21-22](https://github.com/WebAssembly/meetings/blob/d11333215704144f5c2b4a09e05ce69934ac9732/stack/2022/3-21-2022.md)

* [Opting in to Stack Switching](https://docs.google.com/presentation/d/1fjnB5zOSCAURZI-mQ44Wpbbsr3yToVICL94oIg4zmSU) (Francis McCabe)
  Meeting: [4-4-22](https://github.com/WebAssembly/meetings/blob/d2d342d2ed369705a4f56fbd7a89ce924c17ea95/stack/2022/4-4-2022.md)
  
* [Component Model Async support](https://docs.google.com/presentation/d/1MNVOZ8hdofO3tI0szg_i-Yoy0N2QPU2C--LzVuoGSlE) (Luke Wagner)
 Meeting: [5-9-22](https://github.com/WebAssembly/meetings/blob/ab2bfaead83e0597a4ab0c669e842ca5874299b8/stack/2022/5-9-22.md)

* [Task-based stack Switching](https://docs.google.com/presentation/d/1veLRa4d4B0dM3BU_8A39A1uu1bBFH_05GaWphF_4otQ) (Francis McCabe)
 Meeting: [6-6-22](https://github.com/WebAssembly/meetings/blob/103f3c1fe70aaf248b357c662ccb257c89d212dd/stack/2022/6-6-22.md)

* ['Event-less' Task-Based Stack Switching](https://docs.google.com/presentation/d/1fGOCWa-OCi9duGq7EqVPHLLZbRpxh35PiWTrN74_UWM) (Francis McCabe)
 Meeting: [7-18-22](https://github.com/WebAssembly/meetings/blob/6aa9b5e2ec3f9177e940c0519b5e992ed788c163/stack/2022/7-18-22.md)
 
* [Fibers scenarios](https://docs.google.com/presentation/d/1EPAj8IXWokPFSqCwOvEhdtF6pUhzXOaBiWoriSrT01A) (Francis McCabe)
 Meeting: [9-12-22](https://github.com/WebAssembly/meetings/blob/6aa9b5e2ec3f9177e940c0519b5e992ed788c163/stack/2022/9-12-22.md)
 
* [JSPI proposal](https://docs.google.com/presentation/d/1jpjX-Yw1GsCcdf2I1LSTtPGPY27Qaj2RWiL557M7BMY) (Thibaud Michaud)
 Meeting: [9-26-22](https://github.com/WebAssembly/meetings/blob/6aa9b5e2ec3f9177e940c0519b5e992ed788c163/stack/2022/9-26-22.md)
 
* [Greenlets brainstorm](https://github.com/WebAssembly/meetings/blob/main/stack/2022/presentations/2022-11-21-tate-python-greenlets.pdf) (Ross Tate)
 Meeting: [11-21-22](https://github.com/WebAssembly/meetings/blob/6aa9b5e2ec3f9177e940c0519b5e992ed788c163/stack/2022/11-21-22.md)
 

"
stack/2024/stack-2024-03-11.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 11th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  March 11th, 16:00-17:00 UTC ( March 11th, 9am-10am Pacific Daylight Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants

Francis McCabe
Yury Delendik
Zalim Bashorov
Thomas Lively
Thibaud Michaud
Brendan Dahl
Ilya Rezvov
Ben Titzer
Ross Tate
Sam Lindley


## Agenda items

Presentation: High-level effect handlers for C (Mario Alvarez Picallo).

Canceled due to illness of speaker.

Note that we are in Pacific Daylight Time, the time in Europe (and Asia) will be one hour earlier than usual.

### Adoption of the agenda

### Discussion

### Adjourn

"
stack/2024/stack-2024-04-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 8th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  April 8th, 16:00-17:00 UTC ( April 8th, 9am-10am Pacific Daylight Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)

## Participants
Francis McCabe
Sam Lindley
Mario Alvarez Picallo
Yury Delendik
Brendan Dahl
Ilya Rezvov
Thibaud Michaud
Andreas Rossberg
Daniel Hillerström
Deepti Gandluri
Thomas Lively
Teodoro Freund

## Agenda items

Presentation: High-level effect handlers for C (Mario Alvarez Picallo).

Slides are available [here](https://github.com/WebAssembly/meetings/blob/fdb4bbe89f9da85d0796c5d3cf711c9b192bb920/stack/2024/presentations/libseff.pdf)

The recording for this meeting can be accessed [here](https://us02web.zoom.us/rec/share/zXmGSLUxrnUXM0wbkHbtnWAR7dqGEpqJS4G6WSFxy23SByzA0E6iOwwLyB-K7i0-.gqAPS_LV2jh-wFh1).

Link to libseff library: https://gitee.com/marioalvarezpicallo/libseff

Mario’s email address: mario.alvarez.picallo@huawei.com

### Adoption of the agenda

### Discussion

### Adjourn

"
simd/2024/SIMD-07-19.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 19 video call of WebAssembly's SIMD Subgroup

- **Dates**: 2024-07-19
- **Times**:
    - 3pm-4pm UTC (8am-9am PDT)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Petr Penzin
    - Email: penzin.dev@gmail.com


### Registration

Fill out [sign-up form](https://forms.gle/bscWhsD9U4hZEsUV9) to attend.

### Logistics

This meeting will be a Google Meet video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking
1. Adoption of the agenda
1. Proposals and discussions
    1. Discussion of horizontal operations (https://github.com/WebAssembly/flexible-vectors/issues/65)
1. Closure

## Meeting notes

TBD

"
stack/2022/8-15-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 15th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  August 15th, 16:00-17:00 UTC ( August 15th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Daniel Hillerström
Francis McCabe
Ross Tate
Ioanna Dimitriou
Ilya Rezvov
Ben Titzer
Sam Lindley
Luke Wagner
Derek Schuff
Adam Klein
Deepti


## Agenda items

1. Feedback from language implementers&mdash;a report (Francis McCabe)
2. Possible responses to feedback (Ross Tate)

## Meeting Notes

This meeting was [recorded](https://us02web.zoom.us/rec/share/TZRf8uzQOhJABgF4sRLIFBO6LF_Rv5Iz9JWXEI9yxWv9xTMRuKF8IBMWFcQ5zaer.JTsTbWVFGD8h8KRf?startTime=1660579451000).

A written summary of the collected feedback can be seen [here](https://docs.google.com/document/d/1XrKV122KXtkPbn7DJoQ5M-f5fT6g7W5JVtwNv99WHeg).


### Adoption of the agenda

### Discussion

### Adjourn

"
main/2023/CG-04-25.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 11th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: April 25th, 4pm-5pm UTC (April 25th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

**Meeting cancelled due to empty agenda**

## Agenda items for future meetings

*None*
"
main/2024/WG-03-12.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the 2024-03-12 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: 2024-03-12 at 16:00-17:00 UTC *( March 12th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

**Meeting cancelled due to empty agenda.**

## Agenda items

None.

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes
"
main/2024/WG-04-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the 2024-04-10 video call of WebAssembly's Working Group

- **Where**: zoom.us
- **When**: 2024-04-10 at 15:00-16:00 UTC *( April 10th, 8am-9am PST )*
- **Location**: *on calendar invite to registered attendees*
- **Contact**:
    - Name: Derek Schuff, Luke Wagner

### Registration

If you are a Working Group member no registration is required.

If you are a Community Group member who would like to observe, please register here: https://goo.gl/forms/HD2kLCM0iSKk7AVl1

## Logistics

**Meeting cancelled due to empty agenda.**

## Agenda items

None.

## Agenda items for future meetings

None.

### Schedule constraints

None.

## Meeting Notes
"
stack/2023/stack-2023-12-04.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 4th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  December 4th, 17:00-18:00 UTC ( December 4th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Daniel Hillerström
Andreas Rossberg
Yury Delendik
Ilya Rezvov
Sam Lindley
Frank Emrich
Ryan Hunt
Brendan Dahl
Thibaud Michaud
Thomas Lively
Deepti Gandluri
Sam Clegg
Luke Wagner
Zalim Bashorov


## Agenda items

1. Update on implementation of stack-switching in Wasmtime (Frank Emrich)
[Slides](https://wasmfx.dev/_static/talks/stacks-meeting-12-2023.pdf)

There is a partial recording of the meeting [here](https://us02web.zoom.us/rec/share/NKq-IQYwDoNDm-vVQFYVBdtEdvTpebWuYSDkcsuare_rcOlbazLto1nxSc1vbfKm.8EJpJCKJd4M-cmSz).

### Adoption of the agenda

### Discussion

### Adjourn

"
stack/2022/9-12-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 12th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  September 12th, 16:00-17:00 UTC ( September 12th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
* Francis McCabe
* Thomas Lively
* Derek Schuff
* Ioanna Dimitriou
* Michael Knyszek
* Luke Wagner
* Deepti Gandluri
* Ross Tate
* Thibaud Michaud
* Paul Schoenfelder

## Agenda items

1. [Fibers scenarios](https://docs.google.com/presentation/d/1EPAj8IXWokPFSqCwOvEhdtF6pUhzXOaBiWoriSrT01A) (Francis McCabe)

## Meeting Notes

This meeting was recorded. The recording can be accessed [here](https://us02web.zoom.us/rec/share/A1utaZwPfJao9ec1Mc_xQ3NJ4Cxp17WgUOkOIrPqhmxhXGAj99KIeklKIldPzR6D.LUvwB5UW-35-cOFS)

### Adoption of the agenda

### Discussion

### Adjourn

"
main/2022/CG-08-02.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 2nd video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: August 2nd, 4pm-5pm UTC (August 2nd, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

Meeting cancelled due to lack of agenda.
"
gc/2022/GC-08-09.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 9 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: August 9, 5pm-6pm UTC (August 9, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

- Meeting cancelled due to lack of agenda
"
main/2022/CG-07-05.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 5th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: July 5th, 4pm-5pm UTC (July 5th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

Cancelled due to US holiday.
"
gc/2023/GC-02-21.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 21 video call of WebAssembly's Garbage Collection Subgroup

- **Where**: zoom.us
- **When**: February 21, 5pm-6pm UTC (February 21, 9am-11am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Fill out the form here to sign up if
it's your first time: https://forms.gle/JehrAB4gWbtHjybt9. The meeting is open
to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

_Meeting canceled for lack of agenda_
"
main/2024/CG-09-24.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 24th video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: 2024-09-24, 16:00-17:00 UTC (2024-09-24, 9am-10am PDT, 18:00-19:00 CEST)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

To be filled in after the meeting.

### Attendees

### Proposals and discussions

### Closure
"
main/2024/CG-10-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 8th video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: 2024-10-08, 16:00-17:00 UTC (2024-10-08, 9am-10am PDT, 18:00-19:00 CEST)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

To be filled in after the meeting.

### Attendees

### Proposals and discussions

### Closure
"
main/2024/CG-10-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 22 video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: 2024-10-22, 16:00-17:00 UTC (2024-10-22, 9am-10am PDT, 18:00-19:00 CEST)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

To be filled in after the meeting.

### Attendees

### Proposals and discussions

### Closure
"
main/2024/CG-11-05.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 5th video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: 2024-11-05, 17:00-18:00 UTC (2024-11-05, 9am-10am PST, 18:00-19:00 CET)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

To be filled in after the meeting.

### Attendees

### Proposals and discussions

### Closure
"
main/2024/CG-11-19.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 19th video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: 2024-11-19, 17:00-18:00 UTC (2024-11-19, 9am-10am PST, 18:00-19:00 CET)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

To be filled in after the meeting.

### Attendees

### Proposals and discussions

### Closure
"
main/2024/CG-12-03.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 3rd video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: 2024-12-03, 17:00-18:00 UTC (2024-12-03, 9am-10am PST, 18:00-19:00 CET)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

To be filled in after the meeting.

### Attendees

### Proposals and discussions

### Closure
"
main/2024/CG-12-17.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 17th video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: 2024-12-17, 17:00-18:00 UTC (2024-12-17, 9am-10am PST, 18:00-19:00 CET)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

To be filled in after the meeting.

### Attendees

### Proposals and discussions

### Closure
"
main/CG-template.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the {FULLDATE} video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: {FULLDATE}, 16:00-17:00 UTC ({FULLDATE}, 9am-10am PDT, 18:00-19:00 CEST)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

To be filled in after the meeting.

### Attendees

### Proposals and discussions

### Closure
"
stack/2024/stack-2024-05-20.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 20th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  May 20th, 16:00-17:00 UTC (May 20th, 9am-10am Pacific Daylight Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)

## Participants

Francis McCabe
Daniel Hillerström
Sam Lindley
Ben Titzer
Yury Delendik
Brendan Dahl
Adam Klein
Andreas Rossberg
Frank Emrich
Thomas Lively
Derek Schuff
Zalim Basharov

## Agenda items

Presentation: WasmFX benchmarking update (Daniel Hillerström).

This meeting was recorded, recording can be accessed [here](https://us02web.zoom.us/rec/share/k4oQiyObLpvxf5L9ID-Tltnmju_s8D9h4TyGjVNqi8TtzGe8BbURKnacOZmi3rzi.LRy3SpdE-n8T9p6c).

Slides are available [here](https://github.com/WebAssembly/meetings/blob/1d1492595c81f01ed9fc95a333fb4d91c168c111/stack/2024/presentations/wasmfx.pdf).

### Adoption of the agenda

### Discussion

### Adjourn

"
simd/2022/SIMD-04-15.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 15th video call of WebAssembly's SIMD Subgroup

-   **Dates**: 2022-04-15
-   **Times**:
    -   4pm-5pm UTC (9am-10am PDT)
-   **Location**: *link on calendar invite*

### Registration

You are a new attendee, please fill out this
[form](https://forms.gle/9eB2ZYaziPEcTJabA) to attend.

## Agenda items

1.  Opening, welcome and roll call
    1.  Opening of the meeting
    1.  Introduction of attendees
1.  Find volunteers for note taking
1.  Adoption of the agenda
1.  Proposals and discussions
    1.  *add agenda items here*
1.  Closure

## Meeting notes

Meeting cancelled.
"
stack/2022/7-18-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 18th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  July 18th, 16:00-17:00 UTC ( July 18th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants
Francis McCabe
Sam Lindley
Ross Tate
Ryan Hunt
Sam Clegg
Ben Titzer
Justin Michaud
Thibaud Michaud
Adam Klein
Zalim Bashorov




## Agenda items

1. ['Event-less' Task-Based Stack Switching](https://docs.google.com/presentation/d/1fGOCWa-OCi9duGq7EqVPHLLZbRpxh35PiWTrN74_UWM) (Francis McCabe)

## Meeting Notes

The recording of this meeting can be found [here](https://us02web.zoom.us/rec/share/CdV33a4QP80F1m1S20QblLaX183ie7YdZaJRJNTBRZxomHqah9iIAJIv3ZxwcM70.5YXXedbaLNHIXwm4)


### Adoption of the agenda

### Discussion

### Adjourn
"
stack/2020/readme.md,"# Presentations given in 2020

This list is convenience only. 

* [Presentation of effect handler oriented programming](https://github.com/WebAssembly/meetings/blob/8dd18e6962cdc97393cbf049952586f658b0d97f/stack/2020/presentations/2020-10-05-lindley-effect-handler-oriented-programming.pdf) (Sam Lindley)
  Meeting: [10-05-2020](https://github.com/WebAssembly/meetings/blob/8dd18e6962cdc97393cbf049952586f658b0d97f/stack/2020/SG-10-05.md)
  
* [Challenges in implementing Erlang processing in WASM ]() (Paul Schonfelder)
  Meeting: [10-19-2020](https://github.com/WebAssembly/meetings/blob/8dd18e6962cdc97393cbf049952586f658b0d97f/stack/2020/SG-10-19.md)

* [Stack Mechanisms](https://github.com/WebAssembly/meetings/blob/main/stack/2020/presentations/2020-11-02-tate-stack-mechanisms.pdf) (Ross Tate)
  Meeting: [11-2-2020](https://github.com/WebAssembly/meetings/blob/8dd18e6962cdc97393cbf049952586f658b0d97f/stack/2020/SG-11-02.md)

* [Stack Policies](https://github.com/WebAssembly/meetings/blob/main/stack/2020/presentations/2020-11-02-tate-stack-policies.pdf) (Ross Tate)
  Meeting: [11-2-2020](https://github.com/WebAssembly/meetings/blob/8dd18e6962cdc97393cbf049952586f658b0d97f/stack/2020/SG-11-02.md)
  
* [Wasm/k: Delimited Continuations for WebAssembly](https://github.com/donald-pinckney/WasmContinuations/blob/master/DLS%20Talk%20Short.pdf) (Donald Pinckney)
  Meeting: [11-16-2020](https://github.com/WebAssembly/meetings/blob/8dd18e6962cdc97393cbf049952586f658b0d97f/stack/2020/SG-11-16.md)
  
* [Control Flow in Common Lisp aka Why Lisp Doesn't Need To Throw Exceptions](https://github.com/WebAssembly/meetings/blob/main/stack/2020/presentations/2020-11-30-herda-control-flow-in-common-lisp.pdf) (Michał ""phoe"" Herda) 
  Meeting: [11-30-2020](https://github.com/WebAssembly/meetings/blob/8dd18e6962cdc97393cbf049952586f658b0d97f/stack/2020/SG-11-30.md)
  
* [Requirements for stack switching](https://docs.google.com/presentation/d/1iDomt9mJdocJporD2PvsuOpjqemV_DyK8FRTK0QD9KY/edit?usp=sharing) (Francis McCabe)
  Meeting: [12-14-2020](https://github.com/WebAssembly/meetings/blob/8dd18e6962cdc97393cbf049952586f658b0d97f/stack/2020/SG-12-14.md)
  
"
main/2024/CG-09-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the September 10th video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: 2024-09-10, 16:00-17:00 UTC (2024-09-10, 9am-10am PDT, 18:00-19:00 CEST)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

**Meeting cancelled due to empty agenda.**

### Closure
"
main/2023/CG-03-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 14th video call of WebAssembly's Community Group


### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

*Meeting cancelled due to lack of agenda*

## Agenda items for future meetings

*None*
"
stack/2022/sg-10-24-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the October 24th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  October 24th, 17:00-18:00 UTC ( October 24th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants


## Agenda items

1. There is no meeting today - canceled in favor of the general CG F2F later in the week.

## Meeting Notes

### Adoption of the agenda

### Discussion:

#### Multicore OCaml in practice 

### Adjourn
"
stack/2022/2-21-no-mtg.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 21st video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  February 21st, 17:00-18:00 UTC ( February 21st, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants


## Agenda items

1. There is no meeting today - it is a US holiday.

## Meeting Notes

### Adoption of the agenda

### Discussion:

#### Multicore OCaml in practice 

### Adjourn
"
stack/2024/stack-2024-08-26.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 26th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  August 26th, 16:00-17:00 UTC (August 26th, 9am-10am Pacific Daylight Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)

## Participants


## Agenda items

1. Present new explainer for stack switching (Sam Lindley)
2. Informal vote for phase 2

### Adoption of the agenda

### Discussion

### Adjourn
"
stack/2024/stack-2024-05-06.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 6th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  May 6th, 16:00-17:00 UTC (May 6th, 9am-10am Pacific Daylight Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)

## Participants

## Agenda items

~~Presentation: WasmFX benchmarking update (Daniel Hillerström).~~ (postponed as the speaker is sick)

### Adoption of the agenda

### Discussion

### Adjourn
"
stack/2024/stack-2024-07-29.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 29th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  July 29th, 16:00-17:00 UTC (July 29th, 9am-10am Pacific Daylight Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)

## Participants


## Agenda items

1. A Combined wasmfx/bag-o-stacks design
2. Moving forward to phase 2

### Adoption of the agenda

### Discussion

### Adjourn
"
stack/2024/stack-2024-04-22.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 22nd video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  April 22nd, 17:00-18:00 UTC ( February 26th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants


## Agenda items

This meeting is canceled due to lack of agenda.

### Adoption of the agenda

### Discussion

### Adjourn
"
stack/2023/stack-2023-02-27.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 27th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  February 27th, 17:00-18:00 UTC ( February 27th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants


## Agenda items

This meeting is canceled due to a lack of agenda

### Adoption of the agenda

### Adjourn


"
stack/2023/stack-2023-03-13.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 13th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  March 13th, 17:00-18:00 UTC ( March 13th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants


## Agenda items

This meeting is canceled due to a lack of agenda

### Adoption of the agenda

### Adjourn


"
stack/2023/stack-2023-03-27.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 27th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  March 27th, 17:00-18:00 UTC ( March 27th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants


## Agenda items

This meeting is canceled due to a lack of agenda

### Adoption of the agenda

### Adjourn

"
stack/2023/stack-2023-04-10.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 10th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  April 10th, 17:00-18:00 UTC ( April 10th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants


## Agenda items

This meeting is canceled due to public holiday (Easter Monday)

### Adoption of the agenda

### Adjourn

"
stack/2023/stack-2023-04-24.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the April 24th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  April 24th, 17:00-18:00 UTC ( April 24th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants


## Agenda items

This meeting is canceled due to lack of agenda

### Adoption of the agenda

### Adjourn
"
stack/2023/stack-2023-05-08.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 8th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  May 8th, 17:00-18:00 UTC ( May 8th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants


## Agenda items

This meeting is canceled due to lack of agenda

### Adoption of the agenda

### Adjourn
"
stack/2023/stack-2023-08-14.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 14th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  August 14th, 17:00-18:00 UTC ( August 14th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants


## Agenda items

This meeting is canceled due to lack of agenda

### Adoption of the agenda

### Adjourn
"
stack/2023/stack-2023-08-28.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the August 28th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  August 28th, 17:00-18:00 UTC ( August 28th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants


## Agenda items

This meeting is canceled due to lack of agenda

### Adoption of the agenda

### Adjourn
"
stack/2024/stack-2024-02-26.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the February 26th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  February 26th, 17:00-18:00 UTC ( February 26th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants


## Agenda items

This meeting is canceled due to conflicts.

### Adoption of the agenda

### Discussion

### Adjourn
"
stack/2022/3-7-2022.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the March 7th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  March 7th, 17:00-18:00 UTC ( March 7th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants


## Agenda items

1. TBD

## Meeting Notes

### Adoption of the agenda

### Discussion

### Adjourn
"
stack/2023/stack-2023-12-18.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the December 18th video call of WebAssembly's Stack Subgroup

- **Where**: zoom.us
- **When**:  December 18th, 17:00-18:00 UTC ( December 18th, 9am-10am Pacific Standard Time)
- **Location**: [Zoom call](https://zoom.us/j/91846860726?pwd=NVVNVmpvRVVFQkZTVzZ1dTFEcXgrdz09)


## Participants


## Agenda items

1. Review outstanding JSPI [issues](https://github.com/WebAssembly/js-promise-integration/issues) 

### Adoption of the agenda

### Discussion

### Adjourn
"
gc/README.md,"Notes for past GC subgroup meetings. Create a pull request to add items to future agendas or correct past notes.
"
gc/2023/GC-05-30.md,"![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the May 30 video call of WebAssembly's Garbage Collection Subgroup

_This meeting is canceled_
"
