Path,Content,Summary
i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/nodejs.md,"---
sidebar_position: 5
---

# Node.js support

Many existing JavaScript apps use Node.js built-in APIs. To support and reuse these JavaScript apps, we are implementing many Node.JS APIs for WasmEdge QuickJS. The goal is to have unmodified Node.js programs running in WasmEdge QuickJS.

To use Node.js APIs in WasmEdge, you must make the `modules` directory from [wasmedge-quickjs](https://github.com/second-state/wasmedge-quickjs) accessible to the WasmEdge Runtime. The most straightforward approach is to clone the [wasmedge-quickjs](https://github.com/second-state/wasmedge-quickjs) repo and run the Node.js app from the repo's top directory.

```bash
# Clone the wasmedge-quickjs
git clone https://github.com/second-state/wasmedge-quickjs
# Use the wasmedge-quickjs directory as the working directory for modules access
cd wasmedge-quickjs
# Download a released WasmEdge QuickJS runtime
curl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm
# Copy the nodejs project to the current working directory and run the nodejs app
cp -r /path/to/my_node_app .
wasmedge --dir .:. wasmedge_quickjs.wasm my_node_app/index.js
```

<!-- prettier-ignore -->
:::note
If you want to run `wasmedge` from a directory outside the repo, you will need to tell it where to find the `modules` directory using the `--dir` option. A typical command will look like this: `wasmedge --dir .:. --dir ./modules:/path/to/modules wasmedge_quickjs.wasm app.js`
:::

The progress of Node.js support in WasmEdge QuickJS is **[tracked in this issue](https://github.com/WasmEdge/WasmEdge/issues/1535).** There are two approaches for supporting Node.js APIs in WasmEdge QuickJS.

## The JavaScript modules

Some Node.js functions can be implemented in pure JavaScript using the [modules](modules) approach. For example,

- The [querystring](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/querystring.js) functions just perform string manipulations.
- The [buffer](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/buffer.js) functions manage and encode arrays and memory structures.
- The [encoding](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/encoding.js) and [http](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/http.js) functions support corresponding Node.js APIs by wrapping around [Rust internal modules](rust).

## The Rust internal modules

Other Node.js functions must be implemented using the [internal_module](rust) approach in Rust. There are two reasons for that. First, some Node.js API functions are CPU intensive (e.g., encoding) and is most efficiently implemented in Rust. Second, some Node.js API functions require access to the underlying system (e.g., networking and file system) through native host functions.

- The [core](https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/core.rs) module provides OS-level functions such as `timeout`.
- The [encoding](https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/encoding.rs) module provides high-performance encoding and decoding functions, which are in turn [wrapped into Node.js encoding APIs](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/encoding.js).
- The [wasi_net_module](https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/wasi_net_module.rs) provides JavaScript networking functions implemented via the Rust-based WasmEdge WASI socket API. It is then wrapped into the [Node.js http module](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/http.js).

Node.js compatibility support in WasmEdge QuickJS is a work in progress. It is an excellent way for new developers to get familiar with WasmEdge QuickJS. Join us!
","**Summary**

This documentation provides guidance on how to use Node.js APIs within the WasmEdge QuickJS runtime. The goal is to allow unmodified Node.js programs to run in WasmEdge QuickJS without modifications.

To achieve this, two approaches are being implemented:

1. **JavaScript modules**: Pure JavaScript implementation of some Node.js functions using the `modules` approach.
2. **Rust internal modules**: Implementation of CPU-intensive and system-accessing Node.js functions using the `internal_module` approach in Rust.

**Key Components**

* `wasmedge-quickjs` repository: Provides the necessary modules for WasmEdge QuickJS to access Node.js APIs.
* `modules` directory: Contains pure JavaScript implementations of some Node.js functions.
* `Rust internal modules`: Implements CPU-intensive and system-accessing Node.js functions using Rust.

**Potential Issues or Areas for Improvement**

* The documentation assumes a basic understanding of WasmEdge QuickJS, Node.js, and Rust. Users may require additional guidance on these topics to successfully implement Node.js APIs in WasmEdge QuickJS.
* The implementation of Node.js APIs in Rust may not be optimal due to the use of `internal_module` approach, which may lead to performance issues.
* The documentation does not provide clear instructions for users who want to contribute to the project or report issues.
* The project tracking issue (WasmEdge/WasmEdge#1535) should be regularly updated with the progress and status of Node.js compatibility support in WasmEdge QuickJS."
i18n/zh/docusaurus-plugin-content-docs/current/start/build-and-run/aot.md,"---
sidebar_position: 3
---

# AoT 编译器

安装完成后（请参阅[安装指南](../install.md#install)），用户可以执行 `wasmedge compile` 命令。

`wasmedge compile` 命令的用法如下：

```bash
$ wasmedge compile -h
USAGE
   wasmedge compile [OPTIONS] [--] WASM WASM_SO

...
```

`wasmedge compile` 命令可将 WebAssembly 编译为本机机器码（即，AOT 编译器）。对于纯 WebAssembly，`wasmedge` 工具将以解释器模式执行 WASM。通过 `wasmedge compile` AOT 编译器编译后，`wasmedge` 工具可以以 AOT 模式执行 WASM，速度要快得多。

## 选项

`wasmedge compile` 命令的选项如下。

1. `-h|--help`：显示帮助信息。将忽略下面的其他参数。
2. （可选）`--dump`：将 LLVM IR 转储到 `wasm.ll` 和 `wasm-opt.ll`。
3. （可选）`--interruptible`：生成支持可中断执行的二进制文件。
   - 默认情况下，AOT 编译的 WASM 不支持[异步执行中的中断](../../embed/c/reference/0.12.x#async)。
4. （可选）统计信息：
   - 默认情况下，即使在运行 `wasmedge` 工具时打开选项，AOT 编译的 WASM 也不支持所有统计信息。
   - 使用 `--enable-time-measuring` 生成用于启用执行时间测量统计的代码。
   - 使用 `--enable-gas-measuring` 生成用于启用执行中的 gas 测量统计的代码。
   - 使用 `--enable-instruction-count` 生成用于启用 WebAssembly 指令计数统计的代码。
5. （可选）`--generic-binary`：生成通用二进制文件。
6. （可选）WebAssembly 提案：
   - 使用 `--disable-import-export-mut-globals` 禁用[可变全局变量的导入/导出](https://github.com/WebAssembly/mutable-global) 提案（默认为 `ON`）。
   - 使用 `--disable-non-trap-float-to-int` 禁用[非陷阱浮点到整数转换](https://github.com/WebAssembly/nontrapping-float-to-int-conversions) 提案（默认为 `ON`）。
   - 使用 `--disable-sign-extension-operators` 禁用[符号扩展运算符](https://github.com/WebAssembly/sign-extension-ops) 提案（默认为 `ON`）。
   - 使用 `--disable-multi-value` 禁用[多值](https://github.com/WebAssembly/multi-value) 提案（默认为 `ON`）。
   - 使用 `--disable-bulk-memory` 禁用[批量内存操作](https://github.com/WebAssembly/bulk-memory-operations) 提案（默认为 `ON`）。
   - 使用 `--disable-reference-types` 禁用[引用类型](https://github.com/WebAssembly/reference-types) 提案（默认为 `ON`）。
   - 使用 `--disable-simd` 禁用[固定宽度 SIMD](https://github.com/webassembly/simd) 提案（默认为 `ON`）。
   - 使用 `--enable-multi-memory` 启用[多内存](https://github.com/WebAssembly/multi-memory) 提案（默认为 `OFF`）。
   - 使用 `--enable-tail-call` 启用[尾调用](https://github.com/WebAssembly/tail-call) 提案（默认为 `OFF`）。
   - 使用 `--enable-extended-const` 启用[扩展常量表达式](https://github.com/WebAssembly/extended-const) 提案（默认为 `OFF`）。
   - 使用 `--enable-threads` 启用[线程](https://github.com/webassembly/threads) 提案（默认为 `OFF`）。
   - 使用 `--enable-all` 启用上述所有提案。
7. （可选）`--optimize`：选择 LLVM 优化级别。
   - 使用 `--optimize LEVEL` 来设置优化级别。`LEVEL` 应为 `0`、`1`、`2`、`3`、`s` 或 `z` 中的一个。
   - 默认值为 `2`，即 `O2`。
8. 输入的 WASM 文件（`/path/to/wasm/file`）。
9. 输出路径（`/path/to/output/file`）。
   - 默认情况下，`wasmedge compile` 命令将输出[通用的 WASM 格式](#output-format-universal-wasm)。
   - 如果在输出路径中指定了特定的文件扩展名（在 Linux 上为 `.so`，在 MacOS 上为 `.dylib`，在 Windows 上为 `.dll`），`wasmedge compile` 命令将输出[共享库格式](#output-format-shared-library)。

## 示例

我们创建了纯手工编写的 [fibonacci.wat](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wat) 并使用 [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) 工具将其转换为 `fibonacci.wasm` WebAssembly 程序。以此为例，将它导出为一个接收单个 `i32` 整数作为输入参数的 `fib()` 函数。

你可以执行：

```bash
wasmedge compile fibonacci.wasm fibonacci_aot.wasm
```

或者：

```bash
wasmedge compile fibonacci.wasm fibonacci_aot.so # 在 Linux 上
```

输出将会是：

```bash
[2022-09-09 14:22:10.540] [info] compile start
[2022-09-09 14:22:10.541] [info] verify start
[2022-09-09 14:22:10.542] [info] optimize start
[2022-09-09 14:22:10.547] [info] codegen start
[2022-09-09 14:22:10.552] [info] output start
[2022-09-09 14:22:10.600] [info] compile done
```

然后，你可以使用 `wasmedge` 执行输出文件并测量执行时间：

```bash
time wasmedge --reactor fibonacci_aot.wasm fib 30
```

输出将会是：

```bash
1346269

real    0m0.029s
user    0m0.012s
sys     0m0.014s
```

接着，你可以与解释器模式进行比较：

```bash
time wasmedge --reactor fibonacci.wasm fib 30
```

输出显示，AOT 编译的 WASM 比解释器模式快得多：

```bash
1346269

real    0m0.442s
user    0m0.427s
sys     0m0.012s
```

## 输出格式：通用 WASM

默认情况下，`wasmedge compile` AOT 编译器工具可以将 AOT 编译的本机二进制文件包装为原始 WASM 文件中的自定义部分。我们称其为通用 WASM 二进制格式。

这个 AOT 编译的 WASM 文件与所有的 WebAssembly runtime 兼容。但是，当 WasmEdge runtime 执行此 WASM 文件时，WasmEdge 将从自定义部分提取本机二进制并以 AOT 模式执行它。

<!-- prettier-ignore -->
:::note
在 MacOS 平台上，通用 WASM 格式在执行时会产生 `bus error`。默认情况下，`wasmedge compile` 工具会以 `O2` 级别优化 WASM。我们正在尝试解决此问题。请使用共享库输出格式以暂时解决此问题。
:::

```bash
wasmedge compile app.wasm app_aot.wasm
wasmedge app_aot.wasm
```

## 输出格式：共享库

用户可以为输出文件指定共享库扩展名（在 Linux 上为 `.so`，在 MacOS 上为 `.dylib`，在 Windows 上为 `.dll`），以生成共享库格式的输出。

这个 AOT 编译的 WASM 文件仅供 WasmEdge 使用，其他 WebAssembly runtime 无法使用。

```bash
wasmedge compile app.wasm app_aot.so
wasmedge app_aot.so
```
","此文档描述了如何使用 `wasmedge compile` 命令将 WebAssembly (WASM) 编译为本机机器码（AOT编译）。这是 WasmEdge 运行时环境中一种高效的方式，允许执行 WASM 应用程序。 

以下是关键功能和选项：

1.  **安装和使用 `wasmedge compile` 命令**:文档提供了 `wasmedge compile` 命令的语法、可用的参数以及一些示例。
2.  **AOT 编译优化级别：**用户可以选择不同的优化级别（0、1、2、3、s 或 z），以控制生成的二进制文件的大小和执行效率。
3.  **输出格式**:文档提到了两个可能的输出格式：通用 WASM 格式（默认）和共享库格式（指定扩展名）。用户可以根据需要选择其中一个。

总的来说，`wasmedge compile` 命令为开发人员提供了一种快速有效地将 WebAssembly 应用程序编译为本机机器码的方式，从而实现更好的性能。"
docs/contribute/source/plugin/wasi_crypto.md,"---
sidebar_position: 1
---

# Build with WASI-Crypto Plug-in

WebAssembly System Interface (WASI) Crypto is a proposal for a set of APIs that provide cryptographic operations for WebAssembly modules. It aims to provide a consistent, portable, and secure interface for cryptographic operations across different platforms. The WasmEdge WASI-Crypto plug-in is an implementation of this proposal, providing cryptographic functionalities to WebAssembly applications running on the WasmEdge runtime.

## Prerequisites

Currently, WasmEdge used `OpenSSL 1.1` or `3.0` for the WASI-Crypto implementation.

For installing `OpenSSL 1.1` development package on `Ubuntu 20.04`, we recommend the following commands:

```bash
sudo apt update
sudo apt install -y libssl-dev
```

For legacy systems such as `CensOS 7.6`, or if you want to build `OpenSSL 1.1` from source, you can refer to the following commands:

```bash
# Download and extract the OpenSSL source to the current directory.
curl -s -L -O --remote-name-all https://www.openssl.org/source/openssl-1.1.1n.tar.gz
echo ""40dceb51a4f6a5275bde0e6bf20ef4b91bfc32ed57c0552e2e8e15463372b17a openssl-1.1.1n.tar.gz"" | sha256sum -c
tar -xf openssl-1.1.1n.tar.gz
cd ./openssl-1.1.1n
# OpenSSL configure need newer perl.
curl -s -L -O --remote-name-all https://www.cpan.org/src/5.0/perl-5.34.0.tar.gz
tar -xf perl-5.34.0.tar.gz
cd perl-5.34.0
mkdir localperl
./Configure -des -Dprefix=$(pwd)/localperl/
make -j
make install
export PATH=""$(pwd)/localperl/bin/:$PATH""
cd ..
# Configure by previous perl.
mkdir openssl
./perl-5.34.0/localperl/bin/perl ./config --prefix=$(pwd)/openssl --openssldir=$(pwd)/openssl
make -j
make test
make install
cd ..
# The OpenSSL installation directory is at `$(pwd)/openssl-1.1.1n/openssl`.
# Then you can use the `-DOPENSSL_ROOT_DIR=` option of cmake to assign the directory.
```

For MacOS platforms, you should install the `openssl`:

```bash
brew install openssl
```

<!-- prettier-ignore -->
:::note
We'll soon update this chapter to use `OpenSSL 3.0`.
:::

## Build WasmEdge with WASI-Crypto Plug-in

To enable the WasmEdge WASI-Crypto, developers need to [building the WasmEdge from source](../os/linux.md) with the cmake option `-DWASMEDGE_PLUGIN_WASI_CRYPTO=ON`.

```bash
cd <path/to/your/wasmedge/source/folder>
# For using self-get OpenSSL, you can assign the cmake option `-DOPENSSL_ROOT_DIR=<path/to/openssl>`.
# On MacOS, it may be: `-DOPENSSL_ROOT_DIR=$(brew --prefix)/opt/openssl`
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_CRYPTO=On
cmake --build build
# For the WASI-Crypto plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-Crypto plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_crypto/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-Crypto plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiCrypto.so` after installation.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasi_crypto).
","**Summary**

The provided code is a set of instructions on how to build and use the WasmEdge WASI-Crypto plug-in, which provides cryptographic functionalities for WebAssembly applications running on the WasmEdge runtime. The plug-in relies on OpenSSL 1.1 or 3.0 for its implementation.

**Key Components**

1. **Prerequisites**: The code requires users to install OpenSSL 1.1 or 3.0, depending on their operating system (Ubuntu, CentOS, MacOS).
2. **Building WasmEdge with WASI-Crypto Plug-in**: Developers need to build the WasmEdge runtime from source using CMake, specifying the `-DWASMEDGE_PLUGIN_WASI_CRYPTO=ON` option to enable the plug-in.
3. **Installation**: After building, users can install the WasmEdge runtime and the WASI-Crypto plug-in.

**Potential Issues/Improvement Areas**

1. **Outdated instructions**: The code mentions that OpenSSL 3.0 will soon replace OpenSSL 1.1, but the instructions for installing OpenSSL 3.0 are not provided.
2. **Platform-specific installation commands**: The code provides platform-specific installation commands (e.g., `apt install` on Ubuntu) which may not be applicable to other platforms or users with different package managers.
3. **CMake options**: The `-DWASMEDGE_PLUGIN_WASI_CRYPTO=On` option is specified as a string (with a capital ""O"") in the code, but it should be an integer value (`1`) for CMake.

**Recommendations**

To improve the code:

1. Update instructions to use OpenSSL 3.0.
2. Provide platform-agnostic installation commands using package managers or other methods that work across different platforms.
3. Correct the CMake option value to an integer (`1`)."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_crypto.md,"---
sidebar_position: 1
---

# Build with WASI-Crypto Plug-in

WebAssembly System Interface (WASI) Crypto is a proposal for a set of APIs that provide cryptographic operations for WebAssembly modules. It aims to provide a consistent, portable, and secure interface for cryptographic operations across different platforms. The WasmEdge WASI-Crypto plug-in is an implementation of this proposal, providing cryptographic functionalities to WebAssembly applications running on the WasmEdge runtime.

## Prerequisites

Currently, WasmEdge used `OpenSSL 1.1` or `3.0` for the WASI-Crypto implementation.

For installing `OpenSSL 1.1` development package on `Ubuntu 20.04`, we recommend the following commands:

```bash
sudo apt update
sudo apt install -y libssl-dev
```

For legacy systems such as `CensOS 7.6`, or if you want to build `OpenSSL 1.1` from source, you can refer to the following commands:

```bash
# Download and extract the OpenSSL source to the current directory.
curl -s -L -O --remote-name-all https://www.openssl.org/source/openssl-1.1.1n.tar.gz
echo ""40dceb51a4f6a5275bde0e6bf20ef4b91bfc32ed57c0552e2e8e15463372b17a openssl-1.1.1n.tar.gz"" | sha256sum -c
tar -xf openssl-1.1.1n.tar.gz
cd ./openssl-1.1.1n
# OpenSSL configure need newer perl.
curl -s -L -O --remote-name-all https://www.cpan.org/src/5.0/perl-5.34.0.tar.gz
tar -xf perl-5.34.0.tar.gz
cd perl-5.34.0
mkdir localperl
./Configure -des -Dprefix=$(pwd)/localperl/
make -j
make install
export PATH=""$(pwd)/localperl/bin/:$PATH""
cd ..
# Configure by previous perl.
mkdir openssl
./perl-5.34.0/localperl/bin/perl ./config --prefix=$(pwd)/openssl --openssldir=$(pwd)/openssl
make -j
make test
make install
cd ..
# The OpenSSL installation directory is at `$(pwd)/openssl-1.1.1n/openssl`.
# Then you can use the `-DOPENSSL_ROOT_DIR=` option of cmake to assign the directory.
```

For MacOS platforms, you should install the `openssl`:

```bash
brew install openssl
```

<!-- prettier-ignore -->
:::note
We'll soon update this chapter to use `OpenSSL 3.0`.
:::

## Build WasmEdge with WASI-Crypto Plug-in

To enable the WasmEdge WASI-Crypto, developers need to [building the WasmEdge from source](../os/linux.md) with the cmake option `-DWASMEDGE_PLUGIN_WASI_CRYPTO=ON`.

```bash
cd <path/to/your/wasmedge/source/folder>
# For using self-get OpenSSL, you can assign the cmake option `-DOPENSSL_ROOT_DIR=<path/to/openssl>`.
# On MacOS, it may be: `-DOPENSSL_ROOT_DIR=$(brew --prefix)/opt/openssl`
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_CRYPTO=On
cmake --build build
# For the WASI-Crypto plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-Crypto plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_crypto/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-Crypto plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiCrypto.so` after installation.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasi_crypto).
","**Summary**

The provided code is a documentation of the WasmEdge WASI-Crypto plug-in, which provides cryptographic functionalities to WebAssembly applications running on the WasmEdge runtime. The document outlines the prerequisites for installing OpenSSL 1.1 or 3.0 and provides instructions for building the WasmEdge from source with the WASI-Crypto plug-in enabled.

**Key Components**

*   **WASMEdge**: A runtime environment for WebAssembly applications.
*   **WASI-Crypto**: A set of APIs for cryptographic operations in WebAssembly modules.
*   **OpenSSL**: A library used for cryptographic functions in WasmEdge.
*   **cmake**: A build system used to configure and build WasmEdge from source.

**Functionality**

The document guides developers through the process of:

1.  Installing OpenSSL 1.1 or 3.0 on different platforms (Ubuntu, MacOS).
2.  Building WasmEdge from source with the WASI-Crypto plug-in enabled.
3.  Configuring the build system to include the WASI-Crypto plug-in.

**Potential Issues**

*   The document assumes that developers have a basic understanding of WebAssembly and the WasmEdge runtime environment.
*   The instructions for building WasmEdge from source may be complex and require significant time and effort.
*   The use of OpenSSL 1.1 or 3.0 may lead to compatibility issues with certain systems or applications.

**Areas for Improvement**

*   Provide more detailed instructions for building WasmEdge from source, including troubleshooting guides for common issues.
*   Consider adding a section on testing the WASI-Crypto plug-in and providing example use cases.
*   Update the documentation to reflect any changes in the WasmEdge API or WASI-Crypto implementation."
docs/contribute/source/plugin/tensorflow.md,"---
sidebar_position: 5
---

# Build WasmEdge With WasmEdge-Tensorflow Plug-in

The WasmEdge-TensorFlow plug-in is a software component that extends the functionality of the WasmEdge runtime. It allows developers to perform TensorFlow model inference with similar APIs to Python. The plug-in is designed for Rust to WebAssembly applications and depends on the TensorFlow C library for its operations.

## Prerequisites

The prerequisites of the WasmEdge-Tensorflow plug-in is the same as the WasmEdge building environment on the [Linux platforms](../os/linux.md) or [MacOS platforms](../os/macos.md).

## Build WasmEdge with WasmEdge-Tensorflow Plug-in

To enable the WasmEdge WasmEdge-Tensorflow, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_TENSORFLOW=On`.

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_TENSORFLOW=On
cmake --build build
# For the WasmEdge-Tensorflow plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WasmEdge-Tensorflow plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_tensorflow/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-Tensorflow plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeTensorflow.so` after installation.

## Install the TensorFlow Dependency

Installing the necessary `libtensorflow_cc.so` and `libtensorflow_framework.so` on both `Linux` and `MacOS` platforms, we recommend the following commands:

```bash
curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
# For the Linux aarch64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_aarch64.tar.gz`.
# For the MacOS x86_64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-darwin_x86_64.tar.gz`.
# For the MacOS arm64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-darwin_arm64.tar.gz`.
tar -zxf WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
rm -f WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
```

The shared library will be extracted in the current directory `./libtensorflow_cc.so.2.12.0` and `./libtensorflow_framework.so.2.12.0` on `Linux` platforms, or `./libtensorflow_cc.2.12.0.dylib` and `./libtensorflow_framework.2.12.0.dylib` on `MacOS` platforms.

<!-- prettier-ignore -->
:::note
After building the plug-in, you can also find these shared libraries under the `build/_deps/wasmedge_tensorflow_lib_tf-src/` directory.
:::

Then you can move the library to the installation path and create the symbolic link:

```bash
mv libtensorflow_cc.so.2.12.0 /usr/local/lib
mv libtensorflow_framework.so.2.12.0 /usr/local/lib
ln -s libtensorflow_cc.so.2.12.0 /usr/local/lib/libtensorflow_cc.so.2
ln -s libtensorflow_cc.so.2 /usr/local/lib/libtensorflow_cc.so
ln -s libtensorflow_framework.so.2.12.0 /usr/local/lib/libtensorflow_framework.so.2
ln -s libtensorflow_framework.so.2 /usr/local/lib/libtensorflow_framework.so
```

If on `MacOS` platforms:

```bash
mv libtensorflow_cc.2.12.0.dylib /usr/local/lib
mv libtensorflow_framework.2.12.0.dylib /usr/local/lib
ln -s libtensorflow_cc.2.12.0.dylib /usr/local/lib/libtensorflow_cc.2.dylib
ln -s libtensorflow_cc.2.dylib /usr/local/lib/libtensorflow_cc.dylib
ln -s libtensorflow_framework.2.12.0.dylib /usr/local/lib/libtensorflow_framework.2.dylib
ln -s libtensorflow_framework.2.dylib /usr/local/lib/libtensorflow_framework.dylib
```

Or create the symbolic link in the current directory and set the environment variable `export LD_LIBRARY_PATH=$(pwd):${LD_LIBRARY_PATH}`.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_tensorflow).
","**Summary**

The provided code is a guide on how to build and install the WasmEdge-TensorFlow plug-in, which allows developers to perform TensorFlow model inference with similar APIs to Python. The plug-in depends on the TensorFlow C library for its operations.

**Key Components**

1. Building WasmEdge with WasmEdge-TensorFlow plug-in: This involves running cmake with specific options to enable the plug-in.
2. Installing the plug-in: After building, the plug-in can be installed using cmake's `--install` option.
3. Installing TensorFlow dependency: The necessary libraries (libtensorflow_cc.so and libtensorflow_framework.so) need to be downloaded and extracted manually.
4. Setting up environment variables: To use the plug-in, environment variables such as `WASMEDGE_PLUGIN_PATH` and `LD_LIBRARY_PATH` need to be set.

**Potential Issues or Areas for Improvement**

1. Manual extraction of libraries: The current process requires manual extraction and installation of TensorFlow dependencies, which may lead to version conflicts or other issues.
2. Complex build process: The build process involves multiple steps, including building WasmEdge and installing the plug-in, which may be confusing for new users.
3. Limited documentation: While there is a GitHub repository available, more detailed documentation on the plug-in's functionality, usage examples, and troubleshooting might be beneficial.

**Recommendations**

1. Simplify the build process: Consider using a tool like CMake or Meson to simplify the build process and make it more user-friendly.
2. Automate library installation: Instead of manual extraction and installation of TensorFlow dependencies, consider integrating this into the build process.
3. Improve documentation: Add more detailed documentation on the plug-in's functionality, usage examples, and troubleshooting to help new users get started."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/tensorflow.md,"---
sidebar_position: 5
---

# Build WasmEdge With WasmEdge-Tensorflow Plug-in

The WasmEdge-TensorFlow plug-in is a software component that extends the functionality of the WasmEdge runtime. It allows developers to perform TensorFlow model inference with similar APIs to Python. The plug-in is designed for Rust to WebAssembly applications and depends on the TensorFlow C library for its operations.

## Prerequisites

The prerequisites of the WasmEdge-Tensorflow plug-in is the same as the WasmEdge building environment on the [Linux platforms](../os/linux.md) or [MacOS platforms](../os/macos.md).

## Build WasmEdge with WasmEdge-Tensorflow Plug-in

To enable the WasmEdge WasmEdge-Tensorflow, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_TENSORFLOW=On`.

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_TENSORFLOW=On
cmake --build build
# For the WasmEdge-Tensorflow plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WasmEdge-Tensorflow plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_tensorflow/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-Tensorflow plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeTensorflow.so` after installation.

## Install the TensorFlow Dependency

Installing the necessary `libtensorflow_cc.so` and `libtensorflow_framework.so` on both `Linux` and `MacOS` platforms, we recommend the following commands:

```bash
curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
# For the Linux aarch64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_aarch64.tar.gz`.
# For the MacOS x86_64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-darwin_x86_64.tar.gz`.
# For the MacOS arm64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-darwin_arm64.tar.gz`.
tar -zxf WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
rm -f WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
```

The shared library will be extracted in the current directory `./libtensorflow_cc.so.2.12.0` and `./libtensorflow_framework.so.2.12.0` on `Linux` platforms, or `./libtensorflow_cc.2.12.0.dylib` and `./libtensorflow_framework.2.12.0.dylib` on `MacOS` platforms.

<!-- prettier-ignore -->
:::note
After building the plug-in, you can also find these shared libraries under the `build/_deps/wasmedge_tensorflow_lib_tf-src/` directory.
:::

Then you can move the library to the installation path and create the symbolic link:

```bash
mv libtensorflow_cc.so.2.12.0 /usr/local/lib
mv libtensorflow_framework.so.2.12.0 /usr/local/lib
ln -s libtensorflow_cc.so.2.12.0 /usr/local/lib/libtensorflow_cc.so.2
ln -s libtensorflow_cc.so.2 /usr/local/lib/libtensorflow_cc.so
ln -s libtensorflow_framework.so.2.12.0 /usr/local/lib/libtensorflow_framework.so.2
ln -s libtensorflow_framework.so.2 /usr/local/lib/libtensorflow_framework.so
```

If on `MacOS` platforms:

```bash
mv libtensorflow_cc.2.12.0.dylib /usr/local/lib
mv libtensorflow_framework.2.12.0.dylib /usr/local/lib
ln -s libtensorflow_cc.2.12.0.dylib /usr/local/lib/libtensorflow_cc.2.dylib
ln -s libtensorflow_cc.2.dylib /usr/local/lib/libtensorflow_cc.dylib
ln -s libtensorflow_framework.2.12.0.dylib /usr/local/lib/libtensorflow_framework.2.dylib
ln -s libtensorflow_framework.2.dylib /usr/local/lib/libtensorflow_framework.dylib
```

Or create the symbolic link in the current directory and set the environment variable `export LD_LIBRARY_PATH=$(pwd):${LD_LIBRARY_PATH}`.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_tensorflow).
","**Summary:**

The provided code is a documentation for building the WasmEdge runtime with the TensorFlow plug-in. It includes instructions on setting up the prerequisites, building the WasmEdge source code with the required CMake options, and installing the necessary libraries for TensorFlow.

**Key Components:**

1. **Prerequisites:** The code lists the prerequisites for building the WasmEdge-TensorFlow plug-in, which are the same as those for the WasmEdge building environment.
2. **Building WasmEdge with WasmEdge-TensorFlow Plug-in:** This section provides instructions on how to build the WasmEdge source code with the required CMake options and install the WasmEdge-TensorFlow plug-in.
3. **Installing TensorFlow Dependency:** The code includes steps for installing the necessary libraries for TensorFlow, including `libtensorflow_cc.so` and `libtensorflow_framework.so`, on Linux and MacOS platforms.

**Potential Issues or Areas for Improvement:**

1. **Platform-specific instructions:** The code has platform-specific instructions for building and installing the WasmEdge-TensorFlow plug-in. This may lead to confusion for users who are not familiar with the specific platform they are working on.
2. **Complexity of installation process:** The installation process involves multiple steps, including building the WasmEdge source code, installing the WasmEdge-TensorFlow plug-in, and setting up the TensorFlow libraries. This may be overwhelming for users without prior experience in building and installing complex software systems.
3. **Documentation quality:** While the provided documentation is detailed, it could benefit from more clear and concise language to make it easier for users to follow the instructions.
4. **Lack of error handling:** The code does not include any error handling mechanisms, which may lead to difficulties in troubleshooting issues that arise during the installation process.

**Suggestions for Improvement:**

1. **Simplify platform-specific instructions:** Consider providing a single set of instructions that can be applied across multiple platforms.
2. **Improve documentation quality:** Use clear and concise language to make the documentation more accessible to users.
3. **Add error handling mechanisms:** Incorporate checks and error messages to help users troubleshoot issues during the installation process.
4. **Provide additional resources:** Consider providing links to external resources, such as tutorials or forums, to assist users who are new to building and installing complex software systems."
docs/contribute/source/os/windows.md,"---
sidebar_position: 3
---

# Build on Windows 10

You can also find the details [here](https://github.com/WasmEdge/WasmEdge/blob/master/.github/workflows/reusable-build-on-windows.yml#L37-L48).

## Get Source Code

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
```

## Requirements and Dependencies

WasmEdge requires LLVM 16 and you may need to install these following dependencies by yourself.

- [Chocolatey](https://chocolatey.org/install), we use it to install `cmake`, `ninja`, and `vswhere`.
- [Windows SDK 19041](https://blogs.windows.com/windowsdeveloper/2020/05/12/start-developing-on-windows-10-version-2004-today/)
- LLVM 16.0.6, download the pre-built files [here](https://github.com/WasmEdge/llvm-windows/releases) or you can just follow the `instructions/commands` to download automatically.

<!-- prettier-ignore -->
:::note
If you use the community version of Visual Studio, you may encounter errors like: `ninja: error: 'C:/Program Files/Microsoft Visual Studio/2022/Enterprise/DIA SDK/lib/amd64/diaguids.lib', needed by 'test/aot/wasmedgeAOTCoreTests.exe', missing and no known rule to make it`. You need to manually open the file `LLVM-16.0.6-win64/lib/cmake/llvm/LLVMExports.cmake`, search for the only occurrence of `Enterprise` and change it to `Community`. See [this issue](https://github.com/WasmEdge/WasmEdge/issues/1290#issuecomment-1056784554) for details.
:::

```powershell
# Install the required tools
choco install cmake ninja vswhere

$vsPath = (vswhere -latest -property installationPath)
# If vswhere.exe is not in PATH, try the following instead.
# $vsPath = (&""C:\Program Files (x86)\Microsoft Visual Studio\Installer\vswhere.exe"" -latest -property installationPath)

Import-Module (Join-Path $vsPath ""Common7\Tools\Microsoft.VisualStudio.DevShell.dll"")
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments ""-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0""

# Download our pre-built LLVM 16 binary
$llvm = ""LLVM-16.0.6-win64-MultiThreadedDLL.zip""
curl -sLO https://github.com/WasmEdge/llvm-windows/releases/download/llvmorg-16.0.6/LLVM-16.0.6-win64-MultiThreadedDLL.zip -o $llvm
Expand-Archive -Path $llvm

# Set LLVM environment
$llvm_dir = ""$pwd\LLVM-16.0.6-win64-MultiThreadedDLL\LLVM-16.0.6-win64\lib\cmake\llvm""
```

## Build WasmEdge

On Windows, either Clang-cl or MSVC can be used to build WasmEdge. To use MSVC, simply comment out the two lines that set the environment variables `CC` and `CXX`.

```powershell
$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath ""Common7\Tools\Microsoft.VisualStudio.DevShell.dll"")
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments ""-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0""
# If you would like to use MSVC, and want to use a specific version of MSVC, set the arg `vcvars_ver` like the following.
# Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments ""-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0 -vcvars_ver=14.34.31933""

# Set LLVM path according to the download location
$llvm_dir = ""$pwd\LLVM-16.0.6-win64-MultiThreadedDLL\LLVM-16.0.6-win64\lib\cmake\llvm""

# Use clang-cl as the compiler.
# Comment out the following two lines to use MSVC.
$Env:CC = ""clang-cl""
$Env:CXX = ""clang-cl""

cmake -Bbuild -GNinja -DCMAKE_SYSTEM_VERSION=10.0.19041.0 -DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreadedDLL ""-DLLVM_DIR=$llvm_dir"" -DWASMEDGE_BUILD_TESTS=ON -DWASMEDGE_BUILD_PACKAGE=""ZIP"" .
cmake --build build
```

## Run Tests

The following tests are available only when the build option `WASMEDGE_BUILD_TESTS` was set to `ON`.

Users can use these tests to verify the correctness of WasmEdge binaries.

```powershell
$Env:PATH += "";$pwd\build\lib\api""
cd build
ctest --output-on-failure
cd -
```
","**Summary**

This documentation provides a step-by-step guide for building WasmEdge on Windows 10. The process involves cloning the WasmEdge source code, installing required dependencies and tools, setting up the LLVM environment, and finally building WasmEdge using either Clang-cl or MSVC.

**Key Components**

1. **Getting Source Code**: Clone the WasmEdge repository from GitHub using `git clone`.
2. **Requirements and Dependencies**: Install Chocolatey, Windows SDK 19041, and LLVM 16.0.6 (either by downloading pre-built files or following installation instructions).
3. **Building WasmEdge**:
	* Set up the LLVM environment by importing the DevShell module and entering the VsDevShell.
	* Choose either Clang-cl or MSVC as the compiler by setting the `CC` and `CXX` environment variables.
4. **Running Tests**: Run tests using the `ctest` command to verify the correctness of WasmEdge binaries.

**Potential Issues**

1. **Community Edition of Visual Studio**: If using the community edition, modify the `LLVMExports.cmake` file to resolve an error related to missing rules for building `diaguids.lib`.
2. **Path and Environment Variables**: Ensure that path variables are correctly set for tools like `vswhere`, `choco`, and `cmake`.

**Improvement Suggestions**

1. **Simplify the Build Process**: Consider streamlining the build process by providing pre-built binaries or using a more robust build system.
2. **Improve Error Handling**: Enhance error handling and reporting to help users diagnose issues with the build process.
3. **Documentations Updates**: Regularly update documentation to reflect changes in dependencies, tools, or build processes."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/windows.md,"---
sidebar_position: 3
---

# Build on Windows 10

You can also find the details [here](https://github.com/WasmEdge/WasmEdge/blob/master/.github/workflows/reusable-build-on-windows.yml#L37-L48).

## Get Source Code

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
```

## Requirements and Dependencies

WasmEdge requires LLVM 16 and you may need to install these following dependencies by yourself.

- [Chocolatey](https://chocolatey.org/install), we use it to install `cmake`, `ninja`, and `vswhere`.
- [Windows SDK 19041](https://blogs.windows.com/windowsdeveloper/2020/05/12/start-developing-on-windows-10-version-2004-today/)
- LLVM 16.0.6, download the pre-built files [here](https://github.com/WasmEdge/llvm-windows/releases) or you can just follow the `instructions/commands` to download automatically.

<!-- prettier-ignore -->
:::note
If you use the community version of Visual Studio, you may encounter errors like: `ninja: error: 'C:/Program Files/Microsoft Visual Studio/2022/Enterprise/DIA SDK/lib/amd64/diaguids.lib', needed by 'test/aot/wasmedgeAOTCoreTests.exe', missing and no known rule to make it`. You need to manually open the file `LLVM-16.0.6-win64/lib/cmake/llvm/LLVMExports.cmake`, search for the only occurrence of `Enterprise` and change it to `Community`. See [this issue](https://github.com/WasmEdge/WasmEdge/issues/1290#issuecomment-1056784554) for details.
:::

```powershell
# Install the required tools
choco install cmake ninja vswhere

$vsPath = (vswhere -latest -property installationPath)
# If vswhere.exe is not in PATH, try the following instead.
# $vsPath = (&""C:\Program Files (x86)\Microsoft Visual Studio\Installer\vswhere.exe"" -latest -property installationPath)

Import-Module (Join-Path $vsPath ""Common7\Tools\Microsoft.VisualStudio.DevShell.dll"")
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments ""-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0""

# Download our pre-built LLVM 16 binary
$llvm = ""LLVM-16.0.6-win64-MultiThreadedDLL.zip""
curl -sLO https://github.com/WasmEdge/llvm-windows/releases/download/llvmorg-16.0.6/LLVM-16.0.6-win64-MultiThreadedDLL.zip -o $llvm
Expand-Archive -Path $llvm

# Set LLVM environment
$llvm_dir = ""$pwd\LLVM-16.0.6-win64-MultiThreadedDLL\LLVM-16.0.6-win64\lib\cmake\llvm""
```

## Build WasmEdge

On Windows, either Clang-cl or MSVC can be used to build WasmEdge. To use MSVC, simply comment out the two lines that set the environment variables `CC` and `CXX`.

```powershell
$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath ""Common7\Tools\Microsoft.VisualStudio.DevShell.dll"")
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments ""-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0""
# If you would like to use MSVC, and want to use a specific version of MSVC, set the arg `vcvars_ver` like the following.
# Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments ""-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0 -vcvars_ver=14.34.31933""

# Set LLVM path according to the download location
$llvm_dir = ""$pwd\LLVM-16.0.6-win64-MultiThreadedDLL\LLVM-16.0.6-win64\lib\cmake\llvm""

# Use clang-cl as the compiler.
# Comment out the following two lines to use MSVC.
$Env:CC = ""clang-cl""
$Env:CXX = ""clang-cl""

cmake -Bbuild -GNinja -DCMAKE_SYSTEM_VERSION=10.0.19041.0 -DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreadedDLL ""-DLLVM_DIR=$llvm_dir"" -DWASMEDGE_BUILD_TESTS=ON -DWASMEDGE_BUILD_PACKAGE=""ZIP"" .
cmake --build build
```

## Run Tests

The following tests are available only when the build option `WASMEDGE_BUILD_TESTS` was set to `ON`.

Users can use these tests to verify the correctness of WasmEdge binaries.

```powershell
$Env:PATH += "";$pwd\build\lib\api""
cd build
ctest --output-on-failure
cd -
```
","**Summary**

This code is a step-by-step guide for building and running WasmEdge on Windows 10. It requires the user to clone the WasmEdge repository, install dependencies (LLVM 16, Chocolatey, Windows SDK 19041), and then use PowerShell scripts to download pre-built LLVM binaries and build WasmEdge using either Clang-cl or MSVC.

**Key Components**

1. **Prerequisites**: The guide assumes that the user has:
	* Git installed on their system.
	* Chocolatey package manager installed on their system.
	* Windows 10 (version 19041) installed on their system.
2. **Downloading Dependencies**:
	* LLVM 16 binary is downloaded from a pre-built location and extracted to a folder.
3. **Building WasmEdge**:
	* The user can choose between Clang-cl or MSVC as the compiler.
	* The build process uses CMake to generate build files and Ninja to perform the actual build.
4. **Running Tests**: After building WasmEdge, the user can run tests using CTest.

**Potential Issues**

1. **Clash of Dependencies**: If multiple versions of dependencies (e.g., LLVM, Chocolatey) are installed on the system, conflicts may arise.
2. **Incorrect Environment Variables**: Incorrectly set environment variables (e.g., $llvm_dir, $vsPath) can prevent the build process from working correctly.

**Areas for Improvement**

1. **Simplifying Build Process**: Consider using a simpler build tool (e.g., Meson) or providing a pre-built binary package.
2. **Error Handling**: Improve error handling in the scripts to make it easier for users to identify and resolve issues.
3. **Documentation**: Provide more detailed documentation on how to use WasmEdge and troubleshoot common errors."
docs/develop/javascript/modules.md,"---
sidebar_position: 7
---

# Built-in modules

The WasmEdge QuickJS runtime supports [ES6](es6) and [NPM](npm) modules for application developers. However, those approaches could be more convenient for system developers. They need an easier way to add multiple JavaScript modules and APIs into the runtime without using build tools like rollup.js. The WasmEdge QuickJS modules system allows developers to drop JavaScript files into a `modules` folder and have the JavaScript functions defined in the files immediately available to all JavaScript programs in the runtime. A good use case for this module's system is to support [Node.js](nodejs) APIs in WasmEdge.

In this article, we will use the [wasmedge-quickjs/modules](https://github.com/second-state/wasmedge-quickjs/tree/main/modules) as an example to showcase how to import NodeJS API or a third-party module.

## Prerequisites

[See here](./hello_world#prerequisites)

## The modules system

The modules system collects JavaScript files in the `modules` directory in the WasmEdge QuickJS distribution. To use the JavaScript functions and APIs defined in those modules, you need to map this directory to the `/modules` directory inside the WasmEdge Runtime instance. The following example shows how to do this on the WasmEdge CLI. You can do this with any of the host language SDKs that support the embedded use of WasmEdge.

```bash
wasmedge --dir /modules:/host/os/path/to/modules wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime
```

## Add your own JavaScript modules

The [module_demo](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/module_demo) shows how you can use the modules system to add your own JavaScript APIs. To run the demo, first copy the two files in the demo's [modules](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/module_demo/modules) directory to your WasmEdge QuickJS's `modules` directory.

```bash
cp example_js/module_demo/modules/* modules/
```

The two JavaScript files in the `modules` directory provide two simple functions. Below is the [modules/my_mod_1.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/modules/my_mod_1.js) file.

```javascript
export function hello_mod_1() {
  console.log('hello from ""my_mod_1.js""');
}
```

And the [modules/my_mod_2.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/modules/my_mod_2.js) file.

```javascript
export function hello_mod_2() {
  console.log('hello from ""my_mod_2.js""');
}
```

Then, just run the [demo.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/demo.js) file to call the two exported functions from the modules.

```javascript
import { hello_mod_1 } from 'my_mod_1';
import { hello_mod_2 } from 'my_mod_2';

hello_mod_1();
hello_mod_2();
```

Here is the command to run the demo and the output.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/module_demo/demo.js
hello from ""my_mod_1.js""
hello from ""my_mod_2.js""
```

Following the above tutorials, you can easily add third-party JavaScript functions and APIs to your WasmEdge QuickJS runtime.

We included JavaScript files to support [Node.js APIs](nodejs) for the official distribution. You can use [those files](https://github.com/second-state/wasmedge-quickjs/tree/main/modules) as further examples.
","**Summary**

The WasmEdge QuickJS runtime supports ES6 and NPM modules for application developers, but provides an easier way for system developers to add multiple JavaScript modules and APIs without using build tools. The WasmEdge QuickJS module system allows developers to drop JavaScript files into a `modules` folder, making them available to all JavaScript programs in the runtime.

**Key Components**

1. **Modules Folder**: A directory that contains JavaScript files, which can be mapped to the `/modules` directory inside the WasmEdge Runtime instance.
2. **Module Mapping**: The process of mapping the `modules` folder to the `/modules` directory using the `--dir` flag in the WasmEdge CLI.
3. **JavaScript Modules**: Files that contain functions and APIs, which can be imported and used by other JavaScript programs in the runtime.

**Use Cases**

1. Adding third-party JavaScript functions and APIs to the WasmEdge QuickJS runtime.
2. Supporting Node.js APIs in the WasmEdge runtime.

**Example Code**

The example code demonstrates how to add custom JavaScript modules to the WasmEdge QuickJS runtime, using a simple `hello_mod_1` function and a `hello_mod_2` function. The code shows how to import these functions from the module using ES6 imports.

**Potential Issues or Areas for Improvement**

1. **Error Handling**: The current implementation does not handle errors that may occur when loading or executing JavaScript modules.
2. **Security**: The use of JavaScript modules in a sandboxed environment like WasmEdge QuickJS requires careful consideration of security risks, such as injection attacks.
3. **Performance**: The performance impact of loading and executing multiple JavaScript modules needs to be evaluated and optimized for production environments.

**Future Development**

The development of the WasmEdge QuickJS module system is ongoing, with plans to include additional features, such as support for WebAssembly (WASM) modules and improved error handling mechanisms."
docs/embed/use-case/plugin/rust_sdk.md,"---
sidebar_position: 2
---

# Using Plug-ins to Extend the Runtime in Rust

The WasmEdge plug-ins are the shared libraries to provide the WasmEdge runtime to load and create host module instances. With the plug-ins, the WasmEdge runtime can be extended more easily.

## Loading Plug-ins from Paths

Developers can start using WasmEdge plug-ins by loading them from specific paths. To load plug-ins from the default paths, the following API can be used:

```rust
impl PluginManager
pub fn load(path: Option<&Path>) -> WasmEdgeResult<()>
```

- The default plug-in paths will be used if the path is not given.

  - The path specified in the `WASMEDGE_PLUGIN_PATH` environment variable.
  - The `../plugin/` directory relative to the WasmEdge installation path.
  - The `./wasmedge/` directory under the library path if WasmEdge is installed in the `/usr` directory.

- If the path is given, then

  - If the path is pointing at a file, then it indicates that a single plug-in will be loaded from the file.
  - If the path is pointing at a directory, then the method will load plug-ins from the files.

To get the names of all loaded plug-ins as returns -

```rust
pub fn names() -> Vec<String>
```

<!-- prettier-ignore -->
:::note
`path` - A path to a plug-in file or a directory holding plug-in files. If `None`, then the default plug-in path will be used.
:::

## Listing Loaded Plug-ins

Once plug-ins are loaded, developers can list the loaded plug-in names using the following approach:

```rust
pub fn names() -> Vec<String>
```

## Getting Plug-in Context by Name

Developers can get the plug-in context by its name using the following method:

```rust
pub fn find(name: impl AsRef<str>) -> Option<Plugin>
```

Here `name` is the name of the target plug-in.

## Getting Module Instances from Plug-ins

With the plug-in context, developers can get module instances by providing the module name:

```rust
pub fn mod_names(&self) -> Vec<String>
```

There may be several plug-ins in the default plug-in paths if users [installed WasmEdge plug-ins by the installer](/contribute/installer.md#plugins).

Before using the plug-ins, developers should [Loading Plug-ins from Paths](#loading-plug-ins-from-paths).

## Plug-in Module Instance

To initialize the `wasmedge_process` plug-in module instance with the parameters -

```rust
pub fn init_wasmedge_process(allowed_cmds: Option<Vec<&str>>, allowed: bool)
```

Here, `allowed_cmds` is A white list of commands and `allowed` determines if wasmedge_process is allowed to execute all commands on the white list.
","**Summary**

The provided code is part of the WasmEdge runtime in Rust, which allows developers to extend the runtime by loading shared libraries called plug-ins. The `PluginManager` API enables loading plug-ins from specific paths, listing loaded plug-in names, getting plug-in contexts by name, and retrieving module instances.

**Key Components**

1. **Loading Plug-ins**: The `load` method takes an optional path parameter, which can be used to load plug-ins from default paths (environment variable, installation directory, or library path) or a specific file/directory.
2. **Listing Loaded Plug-ins**: The `names` method returns a vector of strings containing the names of all loaded plug-ins.
3. **Getting Plug-in Context by Name**: The `find` method takes a string parameter and returns an optional `Plugin` context if found.
4. **Getting Module Instances from Plug-ins**: With a plug-in context, the `mod_names` method returns a vector of strings containing the module names.

**Potential Issues/Improvement Areas**

1. **Error Handling**: The provided code does not handle errors explicitly. Consider adding try-catch blocks to handle potential errors when loading plug-ins or retrieving module instances.
2. **Plugin Management**: Currently, there is no mechanism for managing plug-in dependencies or versioning. This could lead to issues if multiple versions of the same plugin are loaded concurrently.
3. **Security**: Be cautious when allowing arbitrary command execution (e.g., `allowed_cmds` parameter in `init_wasmedge_process`). Ensure proper input validation and sanitization to prevent security vulnerabilities.

**Best Practices**

1. Follow Rust's standard library and coding conventions for consistency and maintainability.
2. Use explicit error handling mechanisms, such as `Result` or `Error`, to handle potential errors.
3. Keep the code modular, reusable, and well-documented to facilitate future development and maintenance."
docs/start/wasmedge/extensions/unique_extensions.md,"---
sidebar_position: 3
---

# Other Extensions

A challenge for running WASM apps on the server side is the lack of support for Linux APIs and common application libraries. WasmEdge fixes this by adding support for many platform APIs for WASM apps. Developers can often simply compile their Linux apps to WASM and expect it run in WasmEdge. WasmEdge provides an easy extension mechanism for the community to add these APIs. For example,

Through its support for networking socket and related APIs, WasmEdge can run Rust applications that

- [provide HTTP services](https://github.com/WasmEdge/wasmedge_hyper_demo)
- [access external web services](https://github.com/WasmEdge/wasmedge_reqwest_demo)
- [connect to databases](https://github.com/WasmEdge/wasmedge-db-examples)
- [connect to messging queues](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql)
- [support database driven microservices](https://github.com/second-state/microservice-rust-mysql)
- [support microservices with Dapr sidecars](https://github.com/second-state/dapr-wasm)

Furthermore, the networking socket APIs also allow us to support the node.js API, including both the `server` and `fetch()`, in WasmEdge's JavaScript runtime.

Through its support for WASI-NN APIs, WasmEdge can support Rust and JavaScript applications for AI inference. Models from popular AI frameworks such as Tensorflow, PyTorch and OpenVINO [are all supported](https://github.com/second-state/WasmEdge-WASINN-examples).

## Available extensions

The extensions can be easily installed by the WasmEdge installer. They can also be included in WASM container images for Docker, Podman, and Kubernetes applications.

| Name | Description | Platform Support | Language support | Note |
| --- | --- | --- | --- | --- |
| Networking sockets | Supports async (non-blocking) POSIX networking sockets | Linux | Rust, JavaScript, C | Supports popular libraries such as tokio (Rust) and node (JavaScript) |
| DNS | Supports DNS domain names in networking sockets | Linux | Rust, JavaScript, C | Supports popular libraries such as tokio (Rust) and node (JavaScript) |
| Domain sockets | Supports high-performance data exchange between processes | Linux | Rust, JavaScript, C |  |
| TLS | Supports TLS and HTTPS connections from the networking sockets | Linux | Rust, JavaScript, C |  |
| KV Storage | Allows WebAssembly programs to read and write a key value store | Linux | Rust |  |
| [Ethereum](https://github.com/second-state/wasmedge-evmc) | supports Ethereum smart contracts compiled to WebAssembly. | Linux | none | It is a leading implementation for Ethereum flavored WebAssembly (Ewasm). |
| [Substrate](https://github.com/second-state/substrate-ssvm-node) | The [Pallet](https://github.com/second-state/pallet-ssvm) allows WasmEdge to act as an Ethereum smart contract execution engine on any Substrate based blockchains. | Linux | none |  |
","**Summary**

The code snippet describes the features and capabilities of WasmEdge, a WebAssembly runtime that provides an extension mechanism for adding platform APIs to WASM applications. The extensions allow developers to run Linux apps on WasmEdge, leveraging networking socket and related APIs to support various use cases such as HTTP services, database connections, messaging queues, and more.

**Key Components**

1. **Networking Sockets**: Supports async (non-blocking) POSIX networking sockets for Linux.
2. **DNS**: Supports DNS domain names in networking sockets for Linux.
3. **Domain Sockets**: Supports high-performance data exchange between processes for Linux.
4. **TLS**: Supports TLS and HTTPS connections from the networking sockets for Linux.
5. **KV Storage**: Allows WebAssembly programs to read and write a key-value store for Linux.
6. **Ethereum**: Supports Ethereum smart contracts compiled to WebAssembly for Linux.
7. **Substrate**: Enables WasmEdge to act as an Ethereum smart contract execution engine on any Substrate-based blockchains.

**Platform Support**

1. **Linux**: Most of the extensions are supported on Linux platforms.
2. **Rust**: Many extensions support Rust programming language.
3. **JavaScript**: Some extensions support JavaScript programming language, including node.js API.

**Potential Issues or Areas for Improvement**

1. **Limited platform support**: Although most extensions are supported on Linux platforms, there may be limitations for other operating systems.
2. **Language support**: While some extensions support multiple languages (e.g., Rust and JavaScript), others might only support one language.
3. **Performance optimization**: Some extensions, like Domain Sockets, aim to provide high-performance data exchange between processes but might require further optimization.

Overall, the code snippet highlights the features and capabilities of WasmEdge extensions, which enable developers to run Linux apps on this WebAssembly runtime and leverage various platform APIs for their applications."
i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/modules.md,"---
sidebar_position: 7
---

# Built-in modules

The WasmEdge QuickJS runtime supports [ES6](es6) and [NPM](npm) modules for application developers. However, those approaches could be more convenient for system developers. They need an easier way to add multiple JavaScript modules and APIs into the runtime without using build tools like rollup.js. The WasmEdge QuickJS modules system allows developers to drop JavaScript files into a `modules` folder and have the JavaScript functions defined in the files immediately available to all JavaScript programs in the runtime. A good use case for this module's system is to support [Node.js](nodejs) APIs in WasmEdge.

In this article, we will use the [wasmedge-quickjs/modules](https://github.com/second-state/wasmedge-quickjs/tree/main/modules) as an example to showcase how to import NodeJS API or a third-party module.

## Prerequisites

[See here](./hello_world#prerequisites)

## The modules system

The modules system collects JavaScript files in the `modules` directory in the WasmEdge QuickJS distribution. To use the JavaScript functions and APIs defined in those modules, you need to map this directory to the `/modules` directory inside the WasmEdge Runtime instance. The following example shows how to do this on the WasmEdge CLI. You can do this with any of the host language SDKs that support the embedded use of WasmEdge.

```bash
wasmedge --dir /modules:/host/os/path/to/modules wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime
```

## Add your own JavaScript modules

The [module_demo](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/module_demo) shows how you can use the modules system to add your own JavaScript APIs. To run the demo, first copy the two files in the demo's [modules](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/module_demo/modules) directory to your WasmEdge QuickJS's `modules` directory.

```bash
cp example_js/module_demo/modules/* modules/
```

The two JavaScript files in the `modules` directory provide two simple functions. Below is the [modules/my_mod_1.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/modules/my_mod_1.js) file.

```javascript
export function hello_mod_1() {
  console.log('hello from ""my_mod_1.js""');
}
```

And the [modules/my_mod_2.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/modules/my_mod_2.js) file.

```javascript
export function hello_mod_2() {
  console.log('hello from ""my_mod_2.js""');
}
```

Then, just run the [demo.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/demo.js) file to call the two exported functions from the modules.

```javascript
import { hello_mod_1 } from 'my_mod_1';
import { hello_mod_2 } from 'my_mod_2';

hello_mod_1();
hello_mod_2();
```

Here is the command to run the demo and the output.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/module_demo/demo.js
hello from ""my_mod_1.js""
hello from ""my_mod_2.js""
```

Following the above tutorials, you can easily add third-party JavaScript functions and APIs to your WasmEdge QuickJS runtime.

We included JavaScript files to support [Node.js APIs](nodejs) for the official distribution. You can use [those files](https://github.com/second-state/wasmedge-quickjs/tree/main/modules) as further examples.
","**Summary**

The provided code is a documentation of the WasmEdge QuickJS modules system, which allows developers to add multiple JavaScript modules and APIs into the runtime without using build tools like rollup.js. The modules system collects JavaScript files in the `modules` directory and maps this directory to the `/modules` directory inside the WasmEdge Runtime instance.

**Key Components**

1. **Modules Directory**: The `modules` directory is where developers can place their own JavaScript files.
2. **Mapping Directory**: The `--dir` flag is used to map the `modules` directory to the `/modules` directory inside the WasmEdge Runtime instance.
3. **JavaScript Files**: Example JavaScript files (`my_mod_1.js`, `my_mod_2.js`) are provided in the repository, which can be used as a reference for adding custom modules.

**Functionality**

The WasmEdge QuickJS modules system allows developers to:

1. Add their own JavaScript modules and APIs.
2. Use third-party JavaScript functions and APIs.
3. Run example demos that showcase how to use the modules system.

**Potential Issues or Areas for Improvement**

1. **Documentation**: The documentation could be improved by providing more detailed explanations of each step, including error handling and troubleshooting tips.
2. **Example Code**: The example code (`my_mod_1.js`, `my_mod_2.js`) is minimal and lacks comments. Adding more complex examples with comments would help developers understand how to use the modules system in real-world scenarios.
3. **Security**: The modules system allows developers to add custom JavaScript files, which could potentially introduce security vulnerabilities if not properly sanitized.
4. **Scalability**: The documentation does not mention any limitations or considerations for large-scale deployments of the WasmEdge QuickJS runtime with multiple modules.

Overall, the WasmEdge QuickJS modules system provides a convenient way for developers to add custom JavaScript modules and APIs without using build tools like rollup.js. However, additional documentation, example code, and security considerations are needed to fully utilize this feature."
i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/rust_sdk.md,"---
sidebar_position: 2
---

# Using Plug-ins to Extend the Runtime in Rust

The WasmEdge plug-ins are the shared libraries to provide the WasmEdge runtime to load and create host module instances. With the plug-ins, the WasmEdge runtime can be extended more easily.

## Loading Plug-ins from Paths

Developers can start using WasmEdge plug-ins by loading them from specific paths. To load plug-ins from the default paths, the following API can be used:

```rust
impl PluginManager
pub fn load(path: Option<&Path>) -> WasmEdgeResult<()>
```

- The default plug-in paths will be used if the path is not given.

  - The path specified in the `WASMEDGE_PLUGIN_PATH` environment variable.
  - The `../plugin/` directory relative to the WasmEdge installation path.
  - The `./wasmedge/` directory under the library path if WasmEdge is installed in the `/usr` directory.

- If the path is given, then

  - If the path is pointing at a file, then it indicates that a single plug-in will be loaded from the file.
  - If the path is pointing at a directory, then the method will load plug-ins from the files.

To get the names of all loaded plug-ins as returns -

```rust
pub fn names() -> Vec<String>
```

<!-- prettier-ignore -->
:::note
`path` - A path to a plug-in file or a directory holding plug-in files. If `None`, then the default plug-in path will be used.
:::

## Listing Loaded Plug-ins

Once plug-ins are loaded, developers can list the loaded plug-in names using the following approach:

```rust
pub fn names() -> Vec<String>
```

## Getting Plug-in Context by Name

Developers can get the plug-in context by its name using the following method:

```rust
pub fn find(name: impl AsRef<str>) -> Option<Plugin>
```

Here `name` is the name of the target plug-in.

## Getting Module Instances from Plug-ins

With the plug-in context, developers can get module instances by providing the module name:

```rust
pub fn mod_names(&self) -> Vec<String>
```

There may be several plug-ins in the default plug-in paths if users [installed WasmEdge plug-ins by the installer](/contribute/installer.md#plugins).

Before using the plug-ins, developers should [Loading Plug-ins from Paths](#loading-plug-ins-from-paths).

## Plug-in Module Instance

To initialize the `wasmedge_process` plug-in module instance with the parameters -

```rust
pub fn init_wasmedge_process(allowed_cmds: Option<Vec<&str>>, allowed: bool)
```

Here, `allowed_cmds` is A white list of commands and `allowed` determines if wasmedge_process is allowed to execute all commands on the white list.
","**Summary:**

The code snippet is a part of the Rust SDK documentation for the WasmEdge plugin. It describes how to extend the WasmEdge runtime by loading plugins from specific paths, listing loaded plugins, and getting plug-in contexts by name.

**Key Components:**

1. `load`: A method to load plugins from default or custom paths.
2. `names`: A method to get the names of all loaded plugins.
3. `find`: A method to retrieve a plugin context by its name.
4. `mod_names`: A method to get module instances from a plug-in context.

**Potential Issues:**

1. The code does not handle cases where the specified path is invalid or non-existent.
2. There is no error handling for cases where multiple plugins with the same name are loaded.
3. The documentation could be improved by including more detailed examples and use cases.

**Areas for Improvement:**

1. Add input validation and error handling for the `load` method to ensure that the provided path is valid and exists.
2. Consider implementing a mechanism to handle conflicts between plugins with the same name.
3. Enhance the documentation to include additional examples, use cases, and code snippets to make it more comprehensive and user-friendly.

**Code Quality:**

The code appears to be well-structured and follows good coding practices. However, some improvements could be made in terms of error handling and input validation. Overall, the code is easy to understand and navigate, making it suitable for a technical audience."
docs/develop/rust/bindgen.md,"---
sidebar_position: 10
---

# Bindgen of Rust Functions

If your Rust program has a `main()` function, you could compile it into WebAssembly, and run it using the `wasmedge` CLI tool as a standalone application. However, a far more common use case is to compile a Rust function into WebAssembly, and then call it from a host application. That is known as an embedded WASM function. The host application uses WasmEdge language SDKs (e.g., [Go](/category/go-sdk-for-embedding-wasmedge), [Rust](/category/rust-sdk-for-embedding-wasmedge), [C](/category/c-sdk-for-embedding-wasmedge), Python (WIP) and Java (WIP)) to call those WASM functions compiled from Rust source code. In this chapter, we will cover a little about WasmEdge-bindgen, and you can find more information [here](/category/passing-complex-data)

All the WasmEdge host language SDKs support simple function calls. However, the WASM spec only supports simple data types as call parameters and return values, such as `i32`, `i64`, `f32`, `f64`, and `v128`. The `wasmedge-bindgen` crate would transform parameters and return values of Rust functions into simple integer types when the Rust function is compiled into WASM. For example, a string is automatically converted into two integers, a memory address and a length, which the standard WASM spec can handle. It is very easy to do this in Rust source code. Just annotate your function with the `#[wasmedge-bindgen]` macro. You can compile the annotated Rust code using the standard Rust compiler toolchain (e.g., the latest `Cargo`).

```rust
use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;

#[wasmedge_bindgen]
pub fn say(s: String) -> Result<Vec<u8>, String> {
  let r = String::from(""hello "");
  return Ok((r + s.as_str()).as_bytes().to_vec());
}
```

Of course, once the above Rust code is compiled into WASM, the function `say()` no longer takes the `String` parameter nor returns the `Vec<u8>`. So, the caller (i.e., the host application) must also deconstruct the call parameter into the memory pointer first before the call and assemble the return value from the memory pointer after the call. These actions can be handled automatically by the WasmEdge language SDKs. To see a complete example, including the Rust WASM function and the Go host application, check out our tutorial in the Go SDK documentation.

[A complete wasmedge-bindgen example in Rust (WASM) and Go (host)](../../embed/go/function.md)

Of course, the developer could do `wasmedge-bindgen`'s work by hand and pass a memory pointer directly. If you are interested in this approach to call Rust compiled WASM functions, check out our [examples in the Go SDK](../../embed/go/passing_data.md).
","**Summary**

This document describes how to use the `wasmedge-bindgen` crate to generate WebAssembly (WASM) functions from Rust code. The `wasmedge-bindgen` crate is a tool that allows Rust developers to compile their Rust functions into WASM, which can then be called from a host application written in various languages, including Go, Rust, C, and Python.

**Key Components**

1. **Rust Function**: A Rust function annotated with the `#[wasmedge_bindgen]` macro is compiled into WASM.
2. **WASM Function**: The annotated Rust function is transformed into a WASM function that can be called from a host application.
3. **Host Application**: A host application written in a supported language (e.g., Go, Rust, C) calls the WASM function using the WasmEdge language SDK.

**Functionality**

The `wasmedge-bindgen` crate performs two key functions:

1. **Parameter Conversion**: It converts complex data types (e.g., strings, vectors) into simple integer types that can be handled by the WASM specification.
2. **Return Value Transformation**: It transforms return values from the Rust function into a format that can be understood by the host application.

**Potential Issues**

1. **Complex Data Types**: If a function takes or returns complex data types (e.g., structs, custom classes), additional work may be required to handle their conversion and transformation.
2. **Function Signature Changes**: After compiling with `wasmedge-bindgen`, the function signature changes, which may require updates to the host application code.

**Best Practices**

1. **Use the `#[wasmedge_bindgen]` macro**: Annotate Rust functions with this macro to enable WASM compilation.
2. **Understand WASM specification limitations**: Familiarize yourself with the limitations of the WASM specification and how they impact data type conversion and return value transformation.

Overall, using the `wasmedge-bindgen` crate provides a convenient way to compile Rust code into WebAssembly functions that can be easily called from host applications."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/bindgen.md,"---
sidebar_position: 10
---

# Bindgen of Rust Functions

If your Rust program has a `main()` function, you could compile it into WebAssembly, and run it using the `wasmedge` CLI tool as a standalone application. However, a far more common use case is to compile a Rust function into WebAssembly, and then call it from a host application. That is known as an embedded WASM function. The host application uses WasmEdge language SDKs (e.g., [Go](/category/go-sdk-for-embedding-wasmedge), [Rust](/category/rust-sdk-for-embedding-wasmedge), [C](/category/c-sdk-for-embedding-wasmedge), Python (WIP) and Java (WIP)) to call those WASM functions compiled from Rust source code. In this chapter, we will cover a little about WasmEdge-bindgen, and you can find more information [here](/category/passing-complex-data)

All the WasmEdge host language SDKs support simple function calls. However, the WASM spec only supports simple data types as call parameters and return values, such as `i32`, `i64`, `f32`, `f64`, and `v128`. The `wasmedge-bindgen` crate would transform parameters and return values of Rust functions into simple integer types when the Rust function is compiled into WASM. For example, a string is automatically converted into two integers, a memory address and a length, which the standard WASM spec can handle. It is very easy to do this in Rust source code. Just annotate your function with the `#[wasmedge-bindgen]` macro. You can compile the annotated Rust code using the standard Rust compiler toolchain (e.g., the latest `Cargo`).

```rust
use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;

#[wasmedge_bindgen]
pub fn say(s: String) -> Result<Vec<u8>, String> {
  let r = String::from(""hello "");
  return Ok((r + s.as_str()).as_bytes().to_vec());
}
```

Of course, once the above Rust code is compiled into WASM, the function `say()` no longer takes the `String` parameter nor returns the `Vec<u8>`. So, the caller (i.e., the host application) must also deconstruct the call parameter into the memory pointer first before the call and assemble the return value from the memory pointer after the call. These actions can be handled automatically by the WasmEdge language SDKs. To see a complete example, including the Rust WASM function and the Go host application, check out our tutorial in the Go SDK documentation.

[A complete wasmedge-bindgen example in Rust (WASM) and Go (host)](../../embed/go/function.md)

Of course, the developer could do `wasmedge-bindgen`'s work by hand and pass a memory pointer directly. If you are interested in this approach to call Rust compiled WASM functions, check out our [examples in the Go SDK](../../embed/go/passing_data.md).
","**Summary**

The code provided is a documentation for the `wasmedge-bindgen` crate, which is a tool to generate WebAssembly (WASM) bindings for Rust functions. The purpose of this crate is to allow calling WASM functions compiled from Rust source code from host applications written in various languages such as Go, Rust, C, and Python. The documentation explains how the `wasmedge-bindgen` crate works, its limitations, and provides an example of using it to compile a Rust function into WASM.

**Key Components**

1. **`#[wasmedge_bindgen]` macro**: This is a Rust macro that annotates functions to be compiled into WASM.
2. **WASM specification**: The documentation explains the limitations of the WASM specification, which only supports simple data types as call parameters and return values.
3. **Parameter conversion**: The `wasmedge-bindgen` crate automatically converts Rust function parameters and return values into simple integer types when compiling to WASM.
4. **Host language SDKs**: The documentation mentions various host language SDKs (e.g., Go, Rust, C) that can call WASM functions compiled from Rust source code.

**Potential Issues or Areas for Improvement**

1. **Limited support for complex data types**: The WASM specification only supports simple data types, which may limit the functionality of the generated bindings.
2. **Manual parameter conversion**: As mentioned in the documentation, developers could manually handle parameter conversion by passing memory pointers directly to the WASM function. This approach requires more effort and may lead to errors if not done correctly.
3. **Limited support for Rust features**: The `wasmedge-bindgen` crate may not fully support all Rust features, which may limit its usefulness in certain situations.

**Conclusion**

The `wasmedge-bindgen` crate is a useful tool for generating WebAssembly bindings for Rust functions. While it has some limitations, it provides an easy way to call WASM functions from host applications written in various languages. The documentation provided is comprehensive and well-written, making it easier for developers to understand how to use the crate effectively."
docs/develop/rust/hello_world.md,"---
sidebar_position: 2
---

# Hello world

Before we start, ensure [you have Rust and WasmEdge installed](setup.md).

## A simple main app

The Hello World example is a standalone Rust application that can be executed by the [WasmEdge CLI](../../start/build-and-run/cli.md). The full source code for the Rust [main.rs](https://github.com/second-state/rust-examples/tree/main/hello) file is as follows. It echoes the command line arguments passed to this program at runtime.

```rust
fn main() {
  let s : &str = ""Hello WasmEdge!"";
  println!(""{}"", s);
}
```

Build the WASM bytecode:

```bash
cargo build --target wasm32-wasi --release
```

We will use the `wasmedge` command to run the program.

```bash
$ wasmedge target/wasm32-wasi/release/hello.wasm
Hello WasmEdge
```

## A simple function

### The code

The [add example](https://github.com/second-state/wasm-learning/tree/master/cli/add) is a Rust library function that can be executed by the [WasmEdge CLI](../../start/build-and-run/cli.md) in the reactor mode.

The full source code for the Rust [lib.rs](https://github.com/second-state/wasm-learning/blob/master/cli/add/src/lib.rs) file is as follows. It provides a simple `add()` function.

```rust
#[no_mangle]
pub fn add(a: i32, b: i32) -> i32 {
  return a + b;
}
```

### Build the WASM bytecode

```bash
cargo build --target wasm32-wasi --release
```

### Run the application from command line

We will use `wasmedge` in reactor mode to run the program. We pass the function name and its input parameters as command line arguments.

```bash
$ wasmedge --reactor target/wasm32-wasi/release/add.wasm add 2 2
4
```

## Pass parameters with complex data types

Of course, in most cases, you will not call functions using CLI arguments. Instead, you will probably need to use a [language SDK from WasmEdge] to call the function, pass call parameters, and receive return values. Below are some SDK examples for complex call parameters and return values.

- [Use wasmedge-bindgen in a Go host app](../../embed/go/bindgen.md)
- [Use direct memory passing in a Go host app](../../embed/go/passing_data.md)

## Improve the performance

If we don't have extra notes for AoT, all the WASM file will be executed in the interpreter mode, which is much slower. To achieve native Rust performance for those applications, you could use the `wasmedge compile` command to AOT compile the `wasm` program and then run it with the `wasmedge` command.

```bash
$ wasmedge compile hello.wasm hello_aot.wasm

$ wasmedge hello_aot.wasm second state
hello
second
state
```

For the `--reactor` mode,

```bash
$ wasmedge compile add.wasm add_aot.wasm

$ wasmedge --reactor add_aot.wasm add 2 2
4
```
","**Summary**

This code provides examples of creating standalone Rust applications that can be executed by the WasmEdge CLI. The first example is a simple ""Hello World"" application that echoes command-line arguments, and the second example is a library function called `add` that adds two integers.

**Key Components**

1. **Rust Code**: The code consists of two files: `main.rs` for the ""Hello World"" example and `lib.rs` for the `add` library function.
2. **Cargo Build Script**: A script using Cargo, Rust's package manager, is used to build the WASM bytecode for both examples.
3. **WasmEdge CLI**: The WasmEdge CLI is used to run the compiled WASM code.

**Functionality**

1. **Hello World Example**: This example demonstrates how to create a simple ""Hello World"" application that echoes command-line arguments.
2. **Add Library Function**: This example demonstrates how to create a library function called `add` that adds two integers.
3. **AOT Compilation**: The code also demonstrates how to use the `wasmedge compile` command to AOT (Ahead-of-Time) compile the WASM program for improved performance.

**Potential Issues**

1. **Error Handling**: The code does not handle errors that may occur during compilation or execution, which could lead to unexpected behavior.
2. **Dependency Management**: The code uses Cargo, but it's unclear if there are any dependencies that need to be managed.
3. **Performance Optimization**: While AOT compilation is demonstrated, it's unclear if other performance optimization techniques can be applied.

**Improvement Suggestions**

1. **Error Handling**: Add error handling mechanisms to handle potential errors during compilation and execution.
2. **Dependency Management**: Document dependencies and their management in the code.
3. **Performance Optimization**: Explore additional performance optimization techniques beyond AOT compilation, such as loop unrolling or function inlining.
4. **Code Organization**: Consider organizing the code into separate modules or crates to improve maintainability and reusability."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/hello_world.md,"---
sidebar_position: 2
---

# Hello world

Before we start, ensure [you have Rust and WasmEdge installed](setup.md).

## A simple main app

The Hello World example is a standalone Rust application that can be executed by the [WasmEdge CLI](../../start/build-and-run/cli.md). The full source code for the Rust [main.rs](https://github.com/second-state/rust-examples/tree/main/hello) file is as follows. It echoes the command line arguments passed to this program at runtime.

```rust
fn main() {
  let s : &str = ""Hello WasmEdge!"";
  println!(""{}"", s);
}
```

Build the WASM bytecode:

```bash
cargo build --target wasm32-wasi --release
```

We will use the `wasmedge` command to run the program.

```bash
$ wasmedge target/wasm32-wasi/release/hello.wasm
Hello WasmEdge
```

## A simple function

### The code

The [add example](https://github.com/second-state/wasm-learning/tree/master/cli/add) is a Rust library function that can be executed by the [WasmEdge CLI](../../start/build-and-run/cli.md) in the reactor mode.

The full source code for the Rust [lib.rs](https://github.com/second-state/wasm-learning/blob/master/cli/add/src/lib.rs) file is as follows. It provides a simple `add()` function.

```rust
#[no_mangle]
pub fn add(a: i32, b: i32) -> i32 {
  return a + b;
}
```

### Build the WASM bytecode

```bash
cargo build --target wasm32-wasi --release
```

### Run the application from command line

We will use `wasmedge` in reactor mode to run the program. We pass the function name and its input parameters as command line arguments.

```bash
$ wasmedge --reactor target/wasm32-wasi/release/add.wasm add 2 2
4
```

## Pass parameters with complex data types

Of course, in most cases, you will not call functions using CLI arguments. Instead, you will probably need to use a [language SDK from WasmEdge] to call the function, pass call parameters, and receive return values. Below are some SDK examples for complex call parameters and return values.

- [Use wasmedge-bindgen in a Go host app](../../embed/go/bindgen.md)
- [Use direct memory passing in a Go host app](../../embed/go/passing_data.md)

## Improve the performance

If we don't have extra notes for AoT, all the WASM file will be executed in the interpreter mode, which is much slower. To achieve native Rust performance for those applications, you could use the `wasmedge compile` command to AOT compile the `wasm` program and then run it with the `wasmedge` command.

```bash
$ wasmedge compile hello.wasm hello_aot.wasm

$ wasmedge hello_aot.wasm second state
hello
second
state
```

For the `--reactor` mode,

```bash
$ wasmedge compile add.wasm add_aot.wasm

$ wasmedge --reactor add_aot.wasm add 2 2
4
```
","**Summary**

The code provided is a tutorial on how to create and run Rust applications using the WasmEdge CLI. The tutorial covers three main topics:

1. Creating a standalone Rust application that can be executed by the WasmEdge CLI.
2. Creating a Rust library function that can be executed by the WasmEdge CLI in reactor mode.
3. Passing parameters with complex data types and improving performance through Ahead-of-Time (AOT) compilation.

**Key Components**

* `main.rs` file: The full source code for the standalone Rust application that echoes command-line arguments passed to this program at runtime.
* `lib.rs` file: The full source code for the Rust library function that provides a simple `add()` function.
* `wasmedge` command: Used to run the WASM bytecode and execute the functions.
* AOT compilation: Used to achieve native Rust performance by compiling the WASM program beforehand.

**Potential Issues or Areas for Improvement**

* The tutorial assumes that readers have already installed Rust and WasmEdge, which may not be the case for some users.
* There is no explanation on how to handle errors or exceptions in the Rust code.
* The `wasmedge` command options and usage are not thoroughly documented, making it difficult for users to understand its behavior.
* The tutorial could benefit from more examples of passing complex data types and return values using language SDKs.

Overall, the code provided is a good starting point for beginners interested in learning how to create and run Rust applications with WasmEdge. However, additional documentation and explanations are needed to make it more comprehensive and user-friendly."
docs/start/wasmedge/integrations.md,"---
sidebar_position: 2
---

# WasmEdge Integrations

WasmEdge is a ""serverless"" runtime for cloud-native and edge computing applications. It allows developers safely embed third-party or ""native"" functions into a host application or a distributed computing framework.

## Embed WasmEdge Into A Host Application

A major use case of WasmEdge is to start a VM instance from a host application. Depending on your host application's programming language, you can use WasmEdge SDKs to start and invoke WasmEdge functions.

- Embed WasmEdge functions into a `C`-based application using the [WasmEdge C API](/category/c-sdk-for-embedding-wasmedge). Checkout the [quick start guide](../../embed/c/intro.md).
- Embed WasmEdge functions into a `Go` application using the [WasmEdge Go API](/category/go-sdk-for-embedding-wasmedge). Here is a [tutorial](https://www.secondstate.io/articles/extend-golang-app-with-webassembly-rust/) and are some [examples](https://github.com/second-state/WasmEdge-go-examples)!
- Embed WasmEdge functions into a `Rust` application using the [WasmEdge Rust crate](https://crates.io/crates/wasmedge-sdk).
- Embed WasmEdge functions into a `Node.js` application using the `NAPI`. Here is a [tutorial](https://www.secondstate.io/articles/getting-started-with-rust-function/).
- Embed WasmEdge functions into any application by spawning a new process. See examples for [Vercel Serverless Functions](https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/) and [AWS Lambda](https://www.cncf.io/blog/2021/08/25/webassembly-serverless-functions-in-aws-lambda/).

However, the WebAssembly spec only supports very limited data types as input parameters and return values for the WebAssembly bytecode functions. To pass complex data types, such as a string of an array, as call arguments into WebAssembly compiled from Rust, you should use the `bindgen` solution provided by the [`wasmedge-bindgen`](https://crates.io/crates/wasmedge-bindgen). We currently support the `wasmedge-bindgen` in the [Rust](../../develop/rust/bindgen.md) and in [Go](../../embed/go/bindgen.md).

## Use WasmEdge As A Docker-Like Container

WasmEdge provides an OCI-compliant interface. You can use container tools like CRI-O, Docker Hub, and Kubernetes to orchestrate and manage WasmEdge runtimes.

- [Manage WasmEdge with CRI-O and Docker Hub](https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/).

## Call Native Host Functions From WasmEdge

A key feature of WasmEdge is its extensibility. WasmEdge APIs allow developers to register ""host functions"" from the host programming languages into a WasmEdge instance and invoke these functions from the WebAssembly program.

- The WasmEdge C API supports the [C host functions](../../embed/c/host_function.md).
- The WasmEdge Go API supports the [Go host functions](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_HostFunc#wasmedge-go-host-function-example).
- The WasmEdge Rust API supports the [Rust host functions](https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#host-functions).

[Here is an example](https://www.secondstate.io/articles/call-native-functions-from-javascript/) of a JavaScript program in WasmEdge calling a C-based host function in the underlying OS.

The host functions break the WASM sandbox to access the underly OS or hardware. But the sandbox breaking is done with explicit permission from the system’s operator.
","**Summary**

WasmEdge is a ""serverless"" runtime for cloud-native and edge computing applications that allows developers to safely embed third-party or ""native"" functions into a host application or distributed computing framework. It provides APIs for various programming languages, including C, Go, Rust, and Node.js, enabling the embedding of WasmEdge functions into a host application.

**Key Components**

1. **WasmEdge Integrations**: Provide SDKs and APIs for various programming languages to embed WasmEdge functions into a host application.
2. **Embedding WasmEdge Functions**: Enables developers to start a VM instance from a host application using the provided APIs.
3. **Host Functions**: Allow developers to register ""host functions"" from the host programming language into a WasmEdge instance and invoke these functions from the WebAssembly program.

**Potential Issues or Areas for Improvement**

1. **Complex Data Types Support**: The WebAssembly spec only supports limited data types as input parameters and return values for the WebAssembly bytecode functions, making it challenging to pass complex data types.
2. **Bindgen Solution**: The `bindgen` solution provided by the `wasmedge-bindgen` crate is currently supported in Rust and Go, which may limit its availability for other languages.
3. **Containerization Support**: WasmEdge provides an OCI-compliant interface but may require additional support for container tools like CRI-O, Docker Hub, and Kubernetes to orchestrate and manage WasmEdge runtimes.

**Additional Recommendations**

1. **Expand Bindgen Support**: Consider expanding bindgen support to more programming languages to improve the ease of use for developers.
2. **Improve Containerization Support**: Provide additional resources or documentation to help users integrate WasmEdge with container tools like CRI-O, Docker Hub, and Kubernetes.
3. **Enhance Host Function Support**: Continue to enhance host function support across various programming languages to increase the extensibility of WasmEdge."
i18n/zh/docusaurus-plugin-content-docs/current/start/getting-started/quick_start.md,"---
sidebar_position: 1
---

# Linux 下的快速入门

在本指南中，我们将介绍如何快速地在常规 Linux 发行版（例如 Ubuntu、Debian、Raspberry OS 或 Windows 上的 WSL）上安装和运行 WasmEdge 运行时。你可以在[此处](../install.md#install)找到更全面和其他特定操作系统的安装说明。

<!-- prettier-ignore -->
:::note
如果你使用 Docker Desktop 4.15 及以上版本，则可以跳过这一部分，可以[在此开始](quick_start_docker.md)。对于 Fedora Linux / Red Hat Linux / OpenShift / Podman 用户，可以[在此开始](quick_start_redhat.md)。
:::

我们将涵盖以下示例：

- [如何运行一个独立的 WASM 应用](#how-to-run-a-standalone-wasm-app)
- [如何运行一个 HTTP 服务器](#how-to-run-an-http-server)
- [如何运行一个 JavaScript 服务器 (node.js)](#how-to-run-a-javascript-based-server)

## 使用一行指令安装 WasmEdge

安装 WasmEdge 的最简单方式是运行以下命令。你应该具有 root 或至少 `sudo` 权限。在运行此命令之前，你的系统应该已经安装了 `git` 和 `curl`。

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | sudo bash -s -- -p /usr/local
```

如果你没有 root 或 `sudo` 权限，则可以使用以下命令在 `$HOME/.wasmedge` 目录中安装 WasmEdge：

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
```

## 如何运行一个独立的 WASM 应用

Hello World 示例是一个独立的 Rust 应用程序，可由[WasmEdge CLI](../build-and-run/cli.md)执行。其源代码和构建说明可在[此处](https://github.com/second-state/rust-examples/tree/main/hello)找到。

在[此处](https://github.com/second-state/rust-examples/releases/latest/download/hello.wasm)下载 hello.wasm 文件，或运行以下命令：

```bash
wget https://github.com/second-state/rust-examples/releases/latest/download/hello.wasm
```

使用 `wasmedge` 命令来运行程序。

```bash
$ wasmedge hello.wasm
Hello WasmEdge!
```

使用 AoT 编译器 `wasmedgec` 可获得更好的性能。

```bash
$ wasmedgec hello.wasm hello_aot.wasm
$ wasmedge hello_aot.wasm
Hello WasmEdge!
```

了解更多如何在 Rust 中创建 WASM 应用

- [WasmEdge 的基本 Rust 示例](https://github.com/second-state/rust-examples)
- [Rust 开发指南](/category/develop-wasm-apps-in-rust)
  - 使用 [PyTorch](../../develop/rust/wasinn/pytorch.md), [OpenVINO](../../develop/rust/wasinn/openvino.md) 或 [Tensorflow Lite](../../develop/rust/wasinn/tensorflow_lite.md) 后端的 WASI-NN
  - [HTTP 和 HTTPS 客户端](../../develop/rust/http_service/client.md)
  - [MySQL 数据库客户端](../../develop/rust/database/my_sql_driver.md)
  - Redis 客户端
  - Kafka 客户端

## 如何运行一个 HTTP 服务器

此示例是一个使用 Rust 编写的独立 HTTP 服务器。它展示了将 Rust + WasmEdge 作为微服务的轻量级技术栈。其源代码和构建说明可在[此处](https://github.com/second-state/rust-examples/tree/main/server)找到。

在[此处](https://github.com/second-state/rust-examples/releases/latest/download/server.wasm)下载 server.wasm 文件，或运行以下命令：

```bash
wget https://github.com/second-state/rust-examples/releases/latest/download/server.wasm
```

使用 `wasmedge` 命令来运行该程序。

```bash
$ wasmedge server.wasm
Listening on http://0.0.0.0:8080
```

从另一个终端窗口执行以下步骤。

```bash
$ curl http://localhost:8080/
Try POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`

$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

了解如何在 Rust 中创建 WASM 服务

- [Rust 开发指南](/category/develop-wasm-apps-in-rust)
- [HTTP 应用程序示例](https://github.com/WasmEdge/wasmedge_hyper_demo)
- [数据库应用程序示例](https://github.com/WasmEdge/wasmedge-db-examples)
- Rust 和 WasmEdge 中的轻量级微服务
  - [WasmEdge + Nginx + MySQL](https://github.com/second-state/microservice-rust-mysql)
  - [WasmEdge + Kafka + MySQL](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql)
  - [Dapr + WasmEdge](https://github.com/second-state/dapr-wasm)

## 如何运行基于 JavaScript 的服务器

该示例是基于 Node.js API 并使用 JavaScript 编写的独立 HTTP 服务器。它展示了如何将 WasmEdge 作为 Node.js 应用程序的轻量级运行时。其源代码可在[此处](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/docker_wasm/server)找到。

- 在[此处](https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm)下载 wasmedge_quickjs.wasm 文件，或运行以下命令：

```bash
wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm
```

- 在[此处](https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip)下载 modules.zip 文件，或运行以下命令：

```bash
wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip
```

将 modules.zip 文件解压到当前文件夹，保存为 `./modules/`。

```bash
unzip modules.zip
```

- 在[此处](https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/docker_wasm/server/server.js)下载 server.js 文件。

```bash
wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/docker_wasm/server/server.js
```

使用 `wasmedge` 命令来运行该程序。

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm server.js
Listening on 8080 ...
```

从另一个终端窗口执行以下步骤。

```bash
$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

了解如何在 WasmEdge 中运行 JavaScript 应用程序。

- [WasmEdge QuickJS runtime](https://github.com/second-state/wasmedge-quickjs)
- [AI 推理应用示例](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo)
- [使用 fetch() 的 Web 服务客户端示例](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js)

## 下一步

- 查看所有可用的[WasmEdge CLI选项](../build-and-run/cli.md)以探索 WasmEdge 的功能。
- 用你喜欢的语言编写 WASM 应用，如 [Rust](/category/develop-wasm-apps-in-rust)、[C/C++](/category/develop-wasm-apps-in-cc)、[JavaScript](/category/develop-wasm-apps-in-javascript)、[Go](/category/develop-wasm-apps-in-go) 等其他语言。
","**Summary:**

The provided code is a Markdown file for a Docusaurus documentation page, specifically designed to guide users through the quick start process of running WasmEdge on Linux. The document covers three main examples:

1. Running an independent WASM application
2. Running an HTTP server using Rust and WasmEdge
3. Running a JavaScript-based server using Node.js and WasmEdge

**Key Components:**

* Installation of WasmEdge using a single command or an alternative method for non-root users
* Example 1: Running an independent WASM application in Rust, using the `wasmedge` CLI to execute the program
* Example 2: Running an HTTP server using Rust and WasmEdge, demonstrating how to create a microservice using WasmEdge as a lightweight runtime
* Example 3: Running a JavaScript-based server using Node.js and WasmEdge, showing how to use QuickJS as a runtime for Node.js applications

**Potential Issues or Areas for Improvement:**

1. The code assumes users have root or sudo privileges to install WasmEdge, which may not be the case for all users.
2. The examples are based on specific versions of Rust and Node.js, which may need to be updated to match newer versions.
3. The documentation could benefit from more detailed explanations and additional examples to make it easier for users to follow along.

**Suggestions for Future Development:**

1. Add more examples and tutorials to the documentation to cater to a broader range of users and use cases.
2. Provide more detailed instructions and troubleshooting guides for common issues that users may encounter during installation and usage.
3. Consider adding interactive components, such as quizzes or hands-on exercises, to make the learning experience more engaging and effective."
docs/contribute/source/plugin/tensorflowlite.md,"---
sidebar_position: 6
---

# Build WasmEdge With WasmEdge-TensorflowLite Plug-in

The WasmEdge-TensorflowLite plug-in is a software component that extends the functionality of the WasmEdge runtime to perform TensorFlow-Lite model inference. It allows WebAssembly applications to access TensorFlow-Lite functionality when executed on the WasmEdge runtime. The plugin provides a bridge between the WasmEdge runtime and the TensorFlow-Lite backend, allowing developers to execute machine learning models within WebAssembly applications.

## Prerequisites

The prerequisites of the WasmEdge-TensorflowLite plug-in is the same as the WasmEdge building environment on the [Linux platforms](../os/linux.md) or [MacOS platforms](../os/macos.md).

## Build WasmEdge with WasmEdge-TensorflowLite Plug-in

To enable the WasmEdge WasmEdge-TensorflowLite, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_TENSORFLOWLITE=On`.

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_TENSORFLOWLITE=On
cmake --build build
# For the WasmEdge-TensorflowLite plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WasmEdge-TensorflowLite plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_tensorflowlite/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-TensorflowLite plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeTensorflowLite.so` after installation.

## Install the TensorFlowLite Dependency

Installing the necessary `libtensorflowlite_c.so` and `libtensorflowlite_flex.so` on both `Linux` and `MacOS` platforms, we recommend the following commands:

```bash
curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
# For the Linux aarch64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_aarch64.tar.gz`.
# For the MacOS x86_64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-darwin_x86_64.tar.gz`.
# For the MacOS arm64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-darwin_arm64.tar.gz`.
tar -zxf WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
rm -f WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
```

The shared library will be extracted in the current directory `./libtensorflowlite_c.so` and `./libtensorflowlite_flex.so` on `Linux` platforms, or `./libtensorflowlite_c.dylib` and `./libtensorflowlite_flex.dylib` on `MacOS` platforms.

<!-- prettier-ignore -->
:::note
After building the plug-in, you can also find these shared libraries under the `build/_deps/wasmedge_tensorflow_lib_tflite-src/` directory.
:::

Then you can move the library to the installation path:

```bash
mv libtensorflowlite_c.so /usr/local/lib
mv libtensorflowlite_flex.so /usr/local/lib
```

If on `MacOS` platforms:

```bash
mv libtensorflowlite_c.dylib /usr/local/lib
mv libtensorflowlite_flex.dylib /usr/local/lib
```

Or set the environment variable `export LD_LIBRARY_PATH=$(pwd):${LD_LIBRARY_PATH}`.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_tensorflowlite).
","**Summary**

The provided code is a tutorial on building the WasmEdge runtime with the WasmEdge-TensorFlow Lite (TFLite) plugin. The TFLite plugin allows WebAssembly applications to access TensorFlow-Lite model inference functionality when executed on the WasmEdge runtime.

**Key Components**

1. **Prerequisites**: The build environment for WasmEdge is required, which can be found on Linux and MacOS platforms.
2. **Building WasmEdge with TFLite Plugin**: Developers need to build WasmEdge from source using CMake with the option `-DWASMEDGE_PLUGIN_TENSORFLOWLITE=On`.
3. **Installing TensorFlowLite Dependency**: The necessary `libtensorflowlite_c.so` and `libtensorflowlite_flex.so` libraries are required, which can be downloaded and installed manually.
4. **Configuring Environment Variables**: The `WASMEDGE_PLUGIN_PATH` environment variable needs to be set to the installation path of the TFLite plugin.

**Potential Issues/Improvements**

1. **Manual Installation**: The process of installing the TensorFlowLite dependency requires manual intervention, which can be error-prone and time-consuming.
2. **Environment Variable Configuration**: Setting up the `WASMEDGE_PLUGIN_PATH` environment variable may require additional configuration steps.
3. **Build and Install Process**: The build and installation process for WasmEdge with the TFLite plugin is complex and may require additional troubleshooting.

**Recommendations**

1. **Automate Installation**: Automate the installation of the TensorFlowLite dependency using a script or tool to simplify the process.
2. **Simplify Environment Variable Configuration**: Provide clear instructions on how to configure the `WASMEDGE_PLUGIN_PATH` environment variable, or consider making it automatic through CMake or another build tool.
3. **Refine Build and Install Process**: Refine the build and installation process for WasmEdge with the TFLite plugin to reduce complexity and make it more user-friendly."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/tensorflowlite.md,"---
sidebar_position: 6
---

# Build WasmEdge With WasmEdge-TensorflowLite Plug-in

The WasmEdge-TensorflowLite plug-in is a software component that extends the functionality of the WasmEdge runtime to perform TensorFlow-Lite model inference. It allows WebAssembly applications to access TensorFlow-Lite functionality when executed on the WasmEdge runtime. The plugin provides a bridge between the WasmEdge runtime and the TensorFlow-Lite backend, allowing developers to execute machine learning models within WebAssembly applications.

## Prerequisites

The prerequisites of the WasmEdge-TensorflowLite plug-in is the same as the WasmEdge building environment on the [Linux platforms](../os/linux.md) or [MacOS platforms](../os/macos.md).

## Build WasmEdge with WasmEdge-TensorflowLite Plug-in

To enable the WasmEdge WasmEdge-TensorflowLite, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_TENSORFLOWLITE=On`.

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_TENSORFLOWLITE=On
cmake --build build
# For the WasmEdge-TensorflowLite plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WasmEdge-TensorflowLite plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_tensorflowlite/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-TensorflowLite plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeTensorflowLite.so` after installation.

## Install the TensorFlowLite Dependency

Installing the necessary `libtensorflowlite_c.so` and `libtensorflowlite_flex.so` on both `Linux` and `MacOS` platforms, we recommend the following commands:

```bash
curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
# For the Linux aarch64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_aarch64.tar.gz`.
# For the MacOS x86_64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-darwin_x86_64.tar.gz`.
# For the MacOS arm64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-darwin_arm64.tar.gz`.
tar -zxf WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
rm -f WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
```

The shared library will be extracted in the current directory `./libtensorflowlite_c.so` and `./libtensorflowlite_flex.so` on `Linux` platforms, or `./libtensorflowlite_c.dylib` and `./libtensorflowlite_flex.dylib` on `MacOS` platforms.

<!-- prettier-ignore -->
:::note
After building the plug-in, you can also find these shared libraries under the `build/_deps/wasmedge_tensorflow_lib_tflite-src/` directory.
:::

Then you can move the library to the installation path:

```bash
mv libtensorflowlite_c.so /usr/local/lib
mv libtensorflowlite_flex.so /usr/local/lib
```

If on `MacOS` platforms:

```bash
mv libtensorflowlite_c.dylib /usr/local/lib
mv libtensorflowlite_flex.dylib /usr/local/lib
```

Or set the environment variable `export LD_LIBRARY_PATH=$(pwd):${LD_LIBRARY_PATH}`.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_tensorflowlite).
","**Summary**

The code provides a guide on how to build WasmEdge with the TensorFlow Lite plug-in, which enables WebAssembly applications to access TensorFlow-Lite functionality when executed on the WasmEdge runtime. The plug-in provides a bridge between the WasmEdge runtime and the TensorFlow-Lite backend.

**Key Components**

1. **Building WasmEdge**: The code provides instructions on how to build WasmEdge from source with the cmake option `-DWASMEDGE_PLUGIN_TENSORFLOWLITE=On`.
2. **Installing TensorFlowLite Dependency**: The code explains how to install the necessary shared libraries `libtensorflowlite_c.so` and `libtensorflowlite_flex.so` on both Linux and MacOS platforms.
3. **Configuring Environment Variables**: The code provides instructions on how to set environment variables such as `WASMEDGE_PLUGIN_PATH` and `LD_LIBRARY_PATH` to fix potential issues with the built `wasmedge` CLI tool.

**Potential Issues**

1. **Missing Shared Libraries**: If the shared libraries are not installed correctly, the `wasmedge` CLI tool may not be able to find them.
2. **Environment Variable Issues**: If environment variables such as `WASMEDGE_PLUGIN_PATH` and `LD_LIBRARY_PATH` are not set correctly, the plug-in may not work as expected.

**Areas for Improvement**

1. **Automate Building Process**: Consider automating the building process using a CI/CD pipeline to streamline the development and testing process.
2. **Provide More Detailed Instructions**: Provide more detailed instructions on how to configure environment variables and install shared libraries.
3. **Include Example Use Cases**: Include example use cases or demos that showcase the capabilities of the TensorFlow Lite plug-in with WasmEdge."
i18n/zh/docusaurus-plugin-content-docs/current/start/getting-started/quick_start_docker.md,"---
sidebar_position: 2
---

# 使用 Docker 的快速入门

在本指南中，我们将介绍如何在 Docker Desktop 中快速运行 WasmEdge 应用。由于整个开发和运行环境都由 Docker Desktop 管理，因此没有额外的依赖。

<!-- prettier-ignore -->
:::note
如果你没有使用 Docker Desktop，请[从这里开始](quick_start.md)。
:::

我们将介绍以下示例。

- [运行一个独立的 WASM 应用](#run-a-standalone-wasm-app)
- [运行一个 HTTP 服务器](#run-an-http-server)
- [运行一个基于 JavaScript 的服务器 (node.js)](#run-a-javascript-based-server)

在此快速入门指南中，我们将介绍如何使用 Docker 命令运行 WASM 容器应用。如果你对如何从源代码构建、发布和组合 WASM 容器应用感兴趣，请查看[Docker + wasm 章节](../build-and-run/docker_wasm.md)。

## 环境

你必须安装 Docker Desktop 4.15+。确保在 Docker Desktop 中启用了 containerd 镜像存储功能。

![Docker config](docker_config.png)

## 运行独立的 WASM 应用

Hello World 示例是一个独立的 Rust 应用程序。其源代码和构建说明在[此处](https://github.com/second-state/rust-examples/tree/main/hello)。

使用 Docker 来运行容器化的 WASM 应用。WASM 容器镜像存储在 Docker Hub 中，镜像大小仅为 500KB。该镜像可在 Docker 支持的任何 OS 和 CPU 平台上运行。

```bash
$ docker run --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/rust-example-hello:latest
Hello WasmEdge!
```

了解如何在 Rust 中创建 WASM 应用

- [WasmEdge 的基本 Rust 示例](https://github.com/second-state/rust-examples)
- [Rust 开发者指南](/category/develop-wasm-apps-in-rust)
  - 使用 [PyTorch](../../develop/rust/wasinn/pytorch.md)、[OpenVINO](../../develop/rust/wasinn/openvino.md) 或 [Tensorflow Lite](../../develop/rust/wasinn/tensorflow_lite.md) 后端的 WASI-NN
  - [HTTP 和 HTTPS 客户端](../../develop/rust/http_service/client.md)
  - [MySQL 数据库客户端](../../develop/rust/database/my_sql_driver.md)
  - Redis 客户端
  - Kafka 客户端

## 运行 HTTP 服务器

这个示例是一个用 Rust 编写的独立的 HTTP 服务器。它演示了 Rust + WasmEdge 作为轻量级微服务堆栈。其源代码和构建说明在[此处](https://github.com/second-state/rust-examples/tree/main/server)。

使用 Docker 从 Docker Hub 拉取容器镜像（大约 800KB），然后在 WasmEdge 容器中运行它。该容器作为服务器启动。请注意，我们将容器的端口 8080 映射到本地主机的端口 8080，以便从 WASM 容器外部访问服务器。

```bash
$ docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/rust-example-server:latest
Listening on http://0.0.0.0:8080
```

在另一个终端窗口中执行以下操作。

```bash
$ curl http://localhost:8080/
Try POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`

$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

了解如何在 Rust 中创建 WASM 服务

- [Rust 开发者指南](/category/develop-wasm-apps-in-rust)
- [HTTP 应用程序示例](https://github.com/WasmEdge/wasmedge_hyper_demo)
- [数据库应用程序示例](https://github.com/WasmEdge/wasmedge-db-examples)
- Rust 和 WasmEdge 中的轻量级微服务
  - [WasmEdge + Nginx + MySQL](https://github.com/second-state/microservice-rust-mysql)
  - [WasmEdge + Kafka + MySQL](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql)
  - [Dapr + WasmEdge](https://github.com/second-state/dapr-wasm)

## 运行基于 JavaScript 的服务器

这个示例是使用 Node.js API 编写的独立 HTTP 服务器。它演示了将 WasmEdge 作为零依赖和可移植的 Node.js 应用的轻量级运行时。其源代码在[此处](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/docker_wasm/server)。

```bash
$ docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/node-example-server:latest
... ...
```

在另一个终端窗口中执行以下操作。

```bash
$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

了解如何在 WasmEdge 中运行 JavaScript 应用。

- [WasmEdge QuickJS runtime](https://github.com/second-state/wasmedge-quickjs)
- [AI 推理应用示例](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo)
- [使用 fetch() 的 Web 服务客户端示例](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js)

## 下一步

- [了解有关在 Docker 中构建和管理 WASM 容器](../build-and-run/docker_wasm.md)
- [WasmEdge 的基本 Rust 示例](https://github.com/second-state/rust-examples)
- 使用 Docker Compose 构建和 Rust 的微服务
  - [WasmEdge / MySQL / Nginx](https://github.com/docker/awesome-compose/tree/master/wasmedge-mysql-nginx) - 示例使用静态 HTML 前端的 Wasm-based Web 应用，使用 MySQL（MariaDB）数据库。前端连接到使用 WasmEdge runtime 运行的用 Rust 编写的 WASM 微服务。
  - [WasmEdge / Kafka / MySQL](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql) - 示例 Wasm-based 微服务订阅 Kafka（Redpanda）队列主题，并将任何传入的消息转换并保存到 MySQL（MariaDB）数据库中。
- 用你喜欢的语言编写 WASM 应用，比如 [Rust](/category/develop-wasm-apps-in-rust)、[C/C++](/category/develop-wasm-apps-in-cc)、[JavaScript](/category/develop-wasm-apps-in-javascript)、[Go](/category/develop-wasm-apps-in-go) 和许多其他语言。
","This is a tutorial guide for quickly running WasmEdge applications using Docker Desktop. The guide covers three examples: 

1. Running an independent WASM app (a Rust application) 
2. Running an HTTP server (a Rust application)
3. Running a JavaScript-based server (a Node.js application)

**Environment**: To follow this guide, you need to have Docker Desktop 4.15+ installed and containerd image storage enabled.

**Running Independent WASM App**

The ""Hello World"" example is a standalone Rust app. The source code and build instructions are available on GitHub.

```bash
$ docker run --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/rust-example-hello:latest
Hello WasmEdge!
```

**Running HTTP Server**

The ""Rust-based server"" example is a standalone Rust app that demonstrates the use of Rust + WasmEdge as a lightweight microservices stack. 

```bash
$ docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/rust-example-server:latest
```

**Running JavaScript-based Server**

The ""Node.js server"" example is a standalone HTTP server written in Node.js. 

```bash
$ docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/node-example-server:latest
```

Potential issues and areas for improvement:

1. **Container size**: The containers used in the examples have a relatively large size, which might be an issue for users with limited storage space.
2. **Networking**: The guide assumes that the user has basic knowledge of Docker networking concepts and can map ports correctly.
3. **Security**: The guide does not provide information on security best practices when using WasmEdge and Docker containers in a production environment.

Overall, this is a well-structured tutorial that provides a clear introduction to using Docker with WasmEdge applications."
docs/start/usage/use-cases.md,"---
sidebar_position: 1
---

# Use Cases

Featuring AOT compiler optimization, WasmEdge is one of the fastest WebAssembly runtimes on the market today. Therefore WasmEdge is widely used in edge computing, automotive, Jamstack, serverless, SaaS, service mesh, and even blockchain applications.

- Modern web apps feature rich UIs that are rendered in the browser and/or on the edge cloud. WasmEdge works with popular web UI frameworks, such as React, Vue, Yew, and Percy, to support isomorphic [server-side rendering (SSR)](../../embed/use-case/ssr-modern-ui.md) functions on edge servers. It could also support server-side rendering of Unity3D animations and AI-generated interactive videos for web applications on the edge cloud.

- WasmEdge provides a lightweight, secure and high-performance runtime for microservices. It is fully compatible with application service frameworks such as Dapr, and service orchestrators like Kubernetes. WasmEdge microservices can run on edge servers, and have access to distributed cache, to support both stateless and stateful business logic functions for modern web apps. Also related: Serverless function-as-a-service in public clouds.

- [Serverless SaaS (Software-as-a-Service)](/category/serverless-platforms) functions enables users to extend and customize their SaaS experience without operating their own API callback servers. The serverless functions can be embedded into the SaaS or reside on edge servers next to the SaaS servers. Developers simply upload functions to respond to SaaS events or to connect SaaS APIs.

- [Smart device apps](./wasm-smart-devices.md) could embed WasmEdge as a middleware runtime to render interactive content on the UI, connect to native device drivers, and access specialized hardware features (i.e, the GPU for AI inference). The benefits of the WasmEdge runtime over native-compiled machine code include security, safety, portability, manageability, and developer productivity. WasmEdge runs on Android, OpenHarmony, and seL4 RTOS devices.

- WasmEdge could support high performance DSLs (Domain Specific Languages) or act as a cloud-native JavaScript runtime by embedding a JS execution engine or interpreter.

- Developers can leverage container tools such as [Kubernetes](../../develop/deploy/kubernetes/kubernetes-containerd-crun.md), Docker and CRI-O to deploy, manage, and run lightweight WebAssembly applications.

- WasmEdge applications can be plugged into existing application frameworks or platforms.

If you have any great ideas on WasmEdge, don't hesitate to open a GitHub issue to discuss together.
","**Summary**

The provided code is not a programming code but rather a documentation file describing use cases for the WasmEdge WebAssembly runtime. The document highlights various applications and use cases where WasmEdge can be employed, including:

1. Edge computing and automotive
2. Jamstack and serverless environments
3. Service mesh and blockchain applications
4. Modern web apps with rich UIs
5. Microservices and distributed cache
6. Serverless SaaS functions
7. Smart device apps (e.g., Android, OpenHarmony)
8. High-performance DSLs or cloud-native JavaScript runtime
9. Container deployment with Kubernetes, Docker, and CRI-O

**Key Components**

The key components of WasmEdge highlighted in the documentation are:

1. AOT (Ahead-of-Time) compiler optimization for performance
2. Lightweight and secure runtime environment
3. Compatibility with various frameworks and platforms (e.g., React, Vue, Yew, Dapr, Kubernetes)
4. Support for server-side rendering (SSR), isomorphic functions, and microservices

**Potential Issues or Areas for Improvement**

1. **Documentation organization**: The document could be organized into sections with clear headings and subheadings to improve readability.
2. **Code examples**: While the documentation provides use cases, it would be beneficial to include code snippets or examples to illustrate how WasmEdge can be used in each scenario.
3. **Technical details**: Some of the concepts mentioned (e.g., AOT compiler optimization, isomorphic functions) might require more detailed explanations for developers who are not familiar with these topics.
4. **Comparison with other solutions**: The documentation could benefit from comparisons with other WebAssembly runtimes or solutions to help users understand the advantages and disadvantages of WasmEdge.

Overall, the documentation provides a good overview of the use cases and capabilities of WasmEdge, but some areas for improvement remain."
docs/develop/javascript/hello_world.md,"---
sidebar_position: 2
---

# Quickstart for JavaScript

## Prerequisites

[Install WasmEdge](../../start/install.md#install)

Clone the [wasmedge-quickjs](https://github.com/second-state/wasmedge-quickjs) repo and use it as the current directory.

```bash
git clone https://github.com/second-state/wasmedge-quickjs
cd wasmedge-quickjs
```

Then download the pre-built WasmEdge QuickJS Runtime program, and optionally, AOT compile it for better performance.

```bash
curl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm
wasmedge compile wasmedge_quickjs.wasm wasmedge_quickjs.wasm
```

<!-- prettier-ignore -->
:::note
The reason to use `wasmedge-quickjs` as the current working directory is that `modules` in the repo are required for the QuickJS runtime.
:::

## Quick start

You can try a simple ""hello world"" JavaScript program ([example_js/hello.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/hello.js)), which prints out the command line arguments to the console.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime
Hello WasmEdge Runtime
```

<!-- prettier-ignore -->
:::note
The `--dir .:.` on the command line is to give `wasmedge` permission to read the local directory in the file system for the `hello.js` file.
:::

The JavaScript source code for the `hello.js` program is as follows.

```javascript
import * as os from 'os';
import * as std from 'std';

args = args.slice(1);
print('Hello', ...args);
setTimeout(() => {
  print('timeout 2s');
}, 2000);
```

## Build it yourself

This section is optional. Read on if you are interested in [adding custom built-in JavaScript APIs](rust) to the runtime.

Following the instructions, you can build a JavaScript interpreter for WasmEdge. Make sure you have installed GCC. If you don't, run the following command line.

```bash
# Install GCC
sudo apt update
sudo apt install build-essential
```

Then, we could build the WasmEdge-Quickjs runtime.

Fork or clone [the wasmedge-quickjs Github repository](https://github.com/second-state/wasmedge-quickjs).

```bash
# get the source code
git clone https://github.com/second-state/wasmedge-quickjs
cd wasmedge-quickjs

# Build the QuickJS JavaScript interpreter
cargo build --target wasm32-wasi --release
```

The WebAssembly-based JavaScript interpreter program is located in the build `target` directory.

WasmEdge provides a `wasmedgec` utility to compile and add a native machine code section to the `wasm` file. You can use `wasmedge` to run the natively instrumented `wasm` file to get a much faster performance.

```bash
wasmedge compile target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs.wasm
wasmedge --dir .:. wasmedge_quickjs.wasm example_js/hello.js
```

Next, we will discuss more advanced use cases for JavaScript in WasmEdge.
","**Summary**

The provided code is a quickstart guide for running JavaScript on the WasmEdge WebAssembly runtime. It provides instructions for installing and setting up WasmEdge, downloading the pre-built QuickJS Runtime program, and optionally AOT compiling it for better performance.

**Key Components**

1. Prerequisites:
	* Installing WasmEdge
	* Cloning the `wasmedge-quickjs` repository
2. Quick Start:
	* Downloading the pre-built QuickJS Runtime program
	* Running a simple ""hello world"" JavaScript program (`example_js/hello.js`)
3. Building it yourself (optional):
	* Installing GCC
	* Building the WasmEdge-Quickjs runtime using Cargo

**Functionality**

The code demonstrates how to run JavaScript on WasmEdge by:

1. Importing modules (`os` and `std`) in a JavaScript file (`hello.js`)
2. Defining a simple function that prints ""Hello"" followed by command-line arguments
3. Using the `setTimeout` function to print a message after 2 seconds

**Potential Issues or Areas for Improvement**

1. The code assumes that the user has installed GCC, which may not be the case on all systems.
2. The instructions for building the WasmEdge-Quickjs runtime are specific to the WASM32-WASI target and may need modifications for other targets.
3. The `wasmedge` command is used to run the natively instrumented `wasm` file, but this step can be skipped if the user only wants to run the uninstrumented `wasm` file.

**Code Quality**

The code is well-structured and easy to follow. However, there are some areas where the code could benefit from additional comments or documentation:

1. The instructions for installing GCC and building the WasmEdge-Quickjs runtime are not thoroughly documented.
2. The `hello.js` example script does not have any comments or explanations about its purpose or how it works.

Overall, the code is a good starting point for exploring JavaScript on WasmEdge, but may benefit from additional documentation and testing to make it more accessible to users."
docs/embed/use-case/libsql.md,"---
sidebar_position: 1
---

# UDF in the libSQL database

[libSQL](https://github.com/libsql/libsql) is a fork of the popular [SQLite](https://www.sqlite.org/) database. One of the key enhancements libSQL brings is UDF (User Defined Functions) support. Through Wasm-based UDFs, users can add their own processing logic to the database, and then process the data in and out of the database on the fly. libSQL uses WasmEdge to run these UDFs. In this article, I will show you how.

## Prerequisites

First, you will need to [install WasmEdge runtime](../../start/install.md#install).

Next, install the latest libSQL or build it from source.

```bash
git clone https://github.com/libsql/libsql
cd libsql
./configure --enable-wasm-runtime-wasmedge
make
```

## The encrypt and decrypt example

Build the encrypt and decrypt example into wasm. Since WasmEdge supports WASI functions here, we will use the `wasm32-wasi` target.

```bash
git clone https://github.com/libsql/libsql_bindgen
cd libsql_bindgen/examples/encrypt_decrypt
cargo build --target wasm32-wasi --release
```

Then, we can build a SQL file for creating the `encrypt` function in a libSQL database.

```bash
export FUNC_NAME='encrypt'
echo ""DROP FUNCTION IF EXISTS ${FUNC_NAME};"" >> create_${FUNC_NAME}_udf.sql
echo -n ""CREATE FUNCTION ${FUNC_NAME} LANGUAGE wasm AS X'"" >> create_${FUNC_NAME}_udf.sql
xxd -p  ../../target/wasm32-wasi/release/libsql_encrypt_decrypt.wasm | tr -d ""\n"" >> create_${FUNC_NAME}_udf.sql
echo ""';"" >> create_${FUNC_NAME}_udf.sql
```

Create another SQL file for the `decrypt` function.

```bash
export FUNC_NAME='decrypt'
echo ""DROP FUNCTION IF EXISTS ${FUNC_NAME};"" >> create_${FUNC_NAME}_udf.sql
echo -n ""CREATE FUNCTION ${FUNC_NAME} LANGUAGE wasm AS X'"" >> create_${FUNC_NAME}_udf.sql
xxd -p  ../../target/wasm32-wasi/release/libsql_encrypt_decrypt.wasm | tr -d ""\n"" >> create_${FUNC_NAME}_udf.sql
echo ""';"" >> create_${FUNC_NAME}_udf.sql
```

Now, you can add those UDFs to a libSQL instance.

```bash
./libsql
libsql> .init_wasm_func_table
libsql> .read create_encrypt_udf.sql
libsql> .read create_decrypt_udf.sql
```

Finally, you can create a table and test it.

```bash
libsql>

CREATE TABLE secrets(secret);
INSERT INTO secrets (secret) VALUES (encrypt('my secret value: 1', 's3cretp4ss'));
INSERT INTO secrets (secret) VALUES (encrypt('my even more secret value: 2', 's3cretp4ss'));
INSERT INTO secrets (secret) VALUES (encrypt('classified value: 3', 's3cretp4ss'));

SELECT secret, decrypt(secret, 'wrong-pass') from secrets;
secret                                        decrypt(secret, 'wrong-pass')
--------------------------------------------  -----------------------------
IyTvoTEnh9a/f6+pac3rLPToP9DkWqS7CEW8tan3mbQ=  [ACCESS DENIED]
bUQ4fEe6hPnsMx8ABOZO97CMr/wouGTByfUCEmFVZTs=  [ACCESS DENIED]
o+m1w7UdoxBZxLumNW0VoMKSMFaC4o8N5uknAQZ/yFY=  [ACCESS DENIED]

SELECT secret, decrypt(secret, 's3cretp4ss') from secrets;
secret                                        decrypt(secret, 's3cretp4ss')
--------------------------------------------  -----------------------------
IyTvoTEnh9a/f6+pac3rLPToP9DkWqS7CEW8tan3mbQ=  my secret value: 1
bUQ4fEe6hPnsMx8ABOZO97CMr/wouGTByfUCEmFVZTs=  my even more secret value: 2
o+m1w7UdoxBZxLumNW0VoMKSMFaC4o8N5uknAQZ/yFY=  classified value: 3
```
","**Summary**

This document describes how to use User Defined Functions (UDFs) in the libSQL database, a fork of SQLite. libSQL supports Wasm-based UDFs that can be used to add custom processing logic to the database. The example demonstrates how to create and use two UDFs: `encrypt` and `decrypt`, using the WASI target.

**Key Components**

1. **libSQL**: A fork of SQLite with support for Wasm-based UDFs.
2. **WasmEdge**: A runtime environment used to execute Wasm-based UDFs.
3. **libsql_bindgen**: A library used to build and manage libSQL UDFs.
4. **create_*_udf.sql**: SQL scripts used to create the `encrypt` and `decrypt` functions.

**Prerequisites**

1. Install the WasmEdge runtime.
2. Clone and build the latest libSQL or build it from source.

**Steps**

1. Build the encrypt and decrypt example into wasm using Cargo.
2. Create SQL files for creating the `encrypt` and `decrypt` functions.
3. Run the libSQL instance and initialize the WASM function table.
4. Read the create_*_udf.sql scripts to add the UDFs to the libSQL instance.
5. Test the UDFs by creating a table, inserting data, and decrypting the encrypted values.

**Potential Issues**

1. **Security**: The example uses a hardcoded password for decryption, which is insecure in production environments.
2. **Performance**: The performance of Wasm-based UDFs may be lower compared to native code implementations.
3. **Dependencies**: The example requires libsql_bindgen and WasmEdge runtime, which may require additional dependencies and setup.

**Areas for Improvement**

1. **Error handling**: Improve error handling in the UDFs and the SQL scripts.
2. **Performance optimization**: Optimize performance by using more efficient algorithms or data structures.
3. **Security enhancements**: Implement secure password storage and authentication mechanisms."
i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/hello_world.md,"---
sidebar_position: 2
---

# Quickstart for JavaScript

## Prerequisites

[Install WasmEdge](../../start/install.md#install)

Clone the [wasmedge-quickjs](https://github.com/second-state/wasmedge-quickjs) repo and use it as the current directory.

```bash
git clone https://github.com/second-state/wasmedge-quickjs
cd wasmedge-quickjs
```

Then download the pre-built WasmEdge QuickJS Runtime program, and optionally, AOT compile it for better performance.

```bash
curl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm
wasmedge compile wasmedge_quickjs.wasm wasmedge_quickjs.wasm
```

<!-- prettier-ignore -->
:::note
The reason to use `wasmedge-quickjs` as the current working directory is that `modules` in the repo are required for the QuickJS runtime.
:::

## Quick start

You can try a simple ""hello world"" JavaScript program ([example_js/hello.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/hello.js)), which prints out the command line arguments to the console.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime
Hello WasmEdge Runtime
```

<!-- prettier-ignore -->
:::note
The `--dir .:.` on the command line is to give `wasmedge` permission to read the local directory in the file system for the `hello.js` file.
:::

The JavaScript source code for the `hello.js` program is as follows.

```javascript
import * as os from 'os';
import * as std from 'std';

args = args.slice(1);
print('Hello', ...args);
setTimeout(() => {
  print('timeout 2s');
}, 2000);
```

## Build it yourself

This section is optional. Read on if you are interested in [adding custom built-in JavaScript APIs](rust) to the runtime.

Following the instructions, you can build a JavaScript interpreter for WasmEdge. Make sure you have installed GCC. If you don't, run the following command line.

```bash
# Install GCC
sudo apt update
sudo apt install build-essential
```

Then, we could build the WasmEdge-Quickjs runtime.

Fork or clone [the wasmedge-quickjs Github repository](https://github.com/second-state/wasmedge-quickjs).

```bash
# get the source code
git clone https://github.com/second-state/wasmedge-quickjs
cd wasmedge-quickjs

# Build the QuickJS JavaScript interpreter
cargo build --target wasm32-wasi --release
```

The WebAssembly-based JavaScript interpreter program is located in the build `target` directory.

WasmEdge provides a `wasmedgec` utility to compile and add a native machine code section to the `wasm` file. You can use `wasmedge` to run the natively instrumented `wasm` file to get a much faster performance.

```bash
wasmedge compile target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs.wasm
wasmedge --dir .:. wasmedge_quickjs.wasm example_js/hello.js
```

Next, we will discuss more advanced use cases for JavaScript in WasmEdge.
","**Summary:**

This is a Markdown documentation for the Quickstart guide of WasmEdge, a WebAssembly runtime. The guide provides step-by-step instructions on how to set up and use WasmEdge with JavaScript. It covers installing WasmEdge, cloning a repository, downloading pre-built binaries, and running a simple ""hello world"" JavaScript program.

**Key Components:**

1. **Prerequisites:** Install WasmEdge and clone the `wasmedge-quickjs` repository.
2. **Quick start:** Run a simple JavaScript program (`hello.js`) using WasmEdge.
3. **Build it yourself:** Build a custom WasmEdge runtime with a built-in JavaScript API.

**Code:**

The guide includes code snippets for:

1. Installing WasmEdge and cloning the repository
2. Running a simple ""hello world"" JavaScript program
3. Building a custom WasmEdge runtime

**Potential Issues or Areas for Improvement:**

1. **Assumes prior knowledge:** The guide assumes the reader has basic knowledge of WebAssembly, Rust, and C++.
2. **Lack of error handling:** The code snippets do not include error handling, which may make it difficult to diagnose issues.
3. **Complexity:** The build process for a custom WasmEdge runtime is complex and requires advanced knowledge of Rust and Cargo.

**Recommendations:**

1. **Simplify the installation process:** Provide more detailed instructions on installing WasmEdge and its dependencies.
2. **Add error handling:** Include try-catch blocks in code snippets to handle potential errors.
3. **Break down complex tasks:** Divide the build process into smaller, more manageable steps for easier understanding."
i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/libsql.md,"---
sidebar_position: 1
---

# UDF in the libSQL database

[libSQL](https://github.com/libsql/libsql) is a fork of the popular [SQLite](https://www.sqlite.org/) database. One of the key enhancements libSQL brings is UDF (User Defined Functions) support. Through Wasm-based UDFs, users can add their own processing logic to the database, and then process the data in and out of the database on the fly. libSQL uses WasmEdge to run these UDFs. In this article, I will show you how.

## Prerequisites

First, you will need to [install WasmEdge runtime](../../start/install.md#install).

Next, install the latest libSQL or build it from source.

```bash
git clone https://github.com/libsql/libsql
cd libsql
./configure --enable-wasm-runtime-wasmedge
make
```

## The encrypt and decrypt example

Build the encrypt and decrypt example into wasm. Since WasmEdge supports WASI functions here, we will use the `wasm32-wasi` target.

```bash
git clone https://github.com/libsql/libsql_bindgen
cd libsql_bindgen/examples/encrypt_decrypt
cargo build --target wasm32-wasi --release
```

Then, we can build a SQL file for creating the `encrypt` function in a libSQL database.

```bash
export FUNC_NAME='encrypt'
echo ""DROP FUNCTION IF EXISTS ${FUNC_NAME};"" >> create_${FUNC_NAME}_udf.sql
echo -n ""CREATE FUNCTION ${FUNC_NAME} LANGUAGE wasm AS X'"" >> create_${FUNC_NAME}_udf.sql
xxd -p  ../../target/wasm32-wasi/release/libsql_encrypt_decrypt.wasm | tr -d ""\n"" >> create_${FUNC_NAME}_udf.sql
echo ""';"" >> create_${FUNC_NAME}_udf.sql
```

Create another SQL file for the `decrypt` function.

```bash
export FUNC_NAME='decrypt'
echo ""DROP FUNCTION IF EXISTS ${FUNC_NAME};"" >> create_${FUNC_NAME}_udf.sql
echo -n ""CREATE FUNCTION ${FUNC_NAME} LANGUAGE wasm AS X'"" >> create_${FUNC_NAME}_udf.sql
xxd -p  ../../target/wasm32-wasi/release/libsql_encrypt_decrypt.wasm | tr -d ""\n"" >> create_${FUNC_NAME}_udf.sql
echo ""';"" >> create_${FUNC_NAME}_udf.sql
```

Now, you can add those UDFs to a libSQL instance.

```bash
./libsql
libsql> .init_wasm_func_table
libsql> .read create_encrypt_udf.sql
libsql> .read create_decrypt_udf.sql
```

Finally, you can create a table and test it.

```bash
libsql>

CREATE TABLE secrets(secret);
INSERT INTO secrets (secret) VALUES (encrypt('my secret value: 1', 's3cretp4ss'));
INSERT INTO secrets (secret) VALUES (encrypt('my even more secret value: 2', 's3cretp4ss'));
INSERT INTO secrets (secret) VALUES (encrypt('classified value: 3', 's3cretp4ss'));

SELECT secret, decrypt(secret, 'wrong-pass') from secrets;
secret                                        decrypt(secret, 'wrong-pass')
--------------------------------------------  -----------------------------
IyTvoTEnh9a/f6+pac3rLPToP9DkWqS7CEW8tan3mbQ=  [ACCESS DENIED]
bUQ4fEe6hPnsMx8ABOZO97CMr/wouGTByfUCEmFVZTs=  [ACCESS DENIED]
o+m1w7UdoxBZxLumNW0VoMKSMFaC4o8N5uknAQZ/yFY=  [ACCESS DENIED]

SELECT secret, decrypt(secret, 's3cretp4ss') from secrets;
secret                                        decrypt(secret, 's3cretp4ss')
--------------------------------------------  -----------------------------
IyTvoTEnh9a/f6+pac3rLPToP9DkWqS7CEW8tan3mbQ=  my secret value: 1
bUQ4fEe6hPnsMx8ABOZO97CMr/wouGTByfUCEmFVZTs=  my even more secret value: 2
o+m1w7UdoxBZxLumNW0VoMKSMFaC4o8N5uknAQZ/yFY=  classified value: 3
```
","**Summary**

This code provides a step-by-step guide on how to create and use User Defined Functions (UDFs) in the libSQL database, which is a fork of SQLite. The UDFs are written in WebAssembly (Wasm) and run using WasmEdge runtime. The example demonstrates how to encrypt and decrypt data using custom functions.

**Key Components**

1. **libsql**: A fork of SQLite database with support for UDFs.
2. **WasmEdge**: A WebAssembly runtime used to execute UDFs.
3. **UDFs**: User Defined Functions written in Wasm, which can be added to the libSQL instance.
4. **create_encrypt_udf.sql** and **create_decrypt_udf.sql**: SQL files used to create the UDFs in the libSQL database.

**Step-by-Step Process**

1. Install the latest version of libSQL or build it from source.
2. Clone the `libsql_bindgen` repository and build the example Wasm module for encryption/decryption.
3. Create two SQL files, one for creating the encrypt function (`create_encrypt_udf.sql`) and another for creating the decrypt function (`create_decrypt_udf.sql`).
4. Build a libSQL instance and load the UDFs using the `init_wasm_func_table`, `read` commands.

**Potential Issues**

1. **Wasm compilation issues**: The Wasm module may not compile correctly due to errors in the code or dependencies.
2. **libsql compatibility issues**: There might be compatibility issues between libSQL and the UDF implementation.
3. **Performance overhead**: Executing UDFs using WasmEdge may introduce performance overhead compared to native functions.

**Areas for Improvement**

1. **Simplifying the example**: The example code can be simplified by reducing the number of steps or removing unnecessary files.
2. **Improving documentation**: Additional comments and documentation should be added to explain the code, UDFs, and libSQL features.
3. **Error handling**: Error handling mechanisms should be implemented to handle unexpected errors during UDF execution."
docs/develop/javascript/npm.md,"---
sidebar_position: 8
---

# NodeJS and NPM modules

With [rollup.js](https://rollupjs.org/guide/en/), we can run CommonJS (CJS) and NodeJS (NPM) modules in WasmEdge too.

## Prerequisites

[See here](./hello_world#prerequisites)

## Run the example

The [simple_common_js_demo/npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) demo shows how it works.

First, you will need to use the NPM command to roll up the dependency modules into a single JavaScript file.

```bash
cd example_js/simple_common_js_demo
npm install
npm run build
# Go back to the working directory
cd ../../
```

NPM generates a new JavaScript file at `example_js/simple_common_js_demo/dist/npm_main.mjs`, which is the file you can execute with the WasmEdge QuickJS runtime.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/simple_common_js_demo/dist/npm_main.mjs
md5(message)= 78e731027d8fd50ed642340b7c9a63b3
sqrt(-4)= 2i
```

## Code explanation

The [simple_common_js_demo/npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) utilizes the third-party `md5` and `mathjs` modules.

```javascript
const md5 = require('md5');
console.log('md5(message)=', md5('message'));

const { sqrt } = require('mathjs');
console.log('sqrt(-4)=', sqrt(-4).toString());
```

To run it, we must first use the [rollup.js](https://rollupjs.org/guide/en/) tool to build all dependencies into a single file. In the process, `rollup.js` converts CommonJS modules into [WasmEdge-compatible ES6 modules](es6). The build script is [rollup.config.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/rollup.config.js).

```javascript
const { babel } = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const builtins = require('rollup-plugin-node-builtins');
const plugin_async = require('rollup-plugin-async');

const babelOptions = {
  presets: ['@babel/preset-react'],
};

module.exports = [
  {
    input: './npm_main.js',
    output: {
      inlineDynamicImports: true,
      file: 'dist/npm_main.mjs',
      format: 'esm',
    },
    external: ['process', 'wasi_net', 'std'],
    plugins: [
      plugin_async(),
      nodeResolve(),
      commonjs({ ignoreDynamicRequires: false }),
      babel(babelOptions),
      globals(),
      builtins(),
      replace({
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];
```

The [package.json](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/package.json) file specifies the `rollup.js` dependencies and the command to build the [npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) demo program into a single bundle.

```json
{
  ""dependencies"": {
    ""mathjs"": ""^9.5.1"",
    ""md5"": ""^2.3.0""
  },
  ""devDependencies"": {
    ""@babel/core"": ""^7.16.5"",
    ""@babel/preset-env"": ""^7.16.5"",
    ""@babel/preset-react"": ""^7.16.5"",
    ""@rollup/plugin-babel"": ""^5.3.0"",
    ""@rollup/plugin-commonjs"": ""^21.0.1"",
    ""@rollup/plugin-node-resolve"": ""^7.1.3"",
    ""@rollup/plugin-replace"": ""^3.0.0"",
    ""rollup"": ""^2.60.1"",
    ""rollup-plugin-babel"": ""^4.4.0"",
    ""rollup-plugin-node-builtins"": ""^2.1.2"",
    ""rollup-plugin-node-globals"": ""^1.4.0"",
    ""rollup-plugin-async"": ""^1.2.0""
  },
  ""scripts"": {
    ""build"": ""rollup -c rollup.config.js""
  }
}
```

Run the following NPM commands to build [npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) demo program into `dist/npm_main.mjs`.

```bash
npm install
npm run build
```

You can import and run any NPM packages in WasmEdge this way.
","**Summary**

The code provided demonstrates how to use Rollup.js to bundle CommonJS (CJS) and Node.js (NPM) modules for execution in WasmEdge. The example uses the `md5` and `mathjs` third-party libraries, which are installed via NPM. The Rollup configuration file (`rollup.config.js`) is used to build the dependencies into a single file, converting CJS modules to ES6 modules compatible with WasmEdge.

**Key Components**

1. **Rollup Configuration File**: `rollup.config.js` specifies the input file (`npm_main.js`), output file format (ESM), and plugins for building the dependencies.
2. **NPM Packages**: `mathjs` and `md5` are used in the example, and their installation is specified in `package.json`.
3. **Build Script**: The `build` script in `package.json` runs Rollup using the configuration file to build the `npm_main.js` demo program into a single bundle (`dist/npm_main.mjs`).
4. **WasmEdge Execution**: The generated `dist/npm_main.mjs` file is executed using WasmEdge, along with the QuickJS runtime.

**Potential Issues or Areas for Improvement**

1. **Dependency Management**: As the number of dependencies grows, managing their versions and compatibility with WasmEdge may become more complex.
2. **Optimization**: The Rollup configuration can be optimized to reduce bundle size and improve performance.
3. **Error Handling**: Implementing robust error handling mechanisms in the demo program and during build process would make it more reliable.
4. **Security**: Ensure that third-party libraries used are secure and up-to-date, as outdated or vulnerable libraries can compromise WasmEdge's security.

Overall, this code demonstrates a practical approach to using Rollup.js for bundling NPM packages for execution in WasmEdge. However, as with any complex software system, ongoing maintenance, optimization, and security considerations are essential to ensure its reliability and effectiveness."
i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/npm.md,"---
sidebar_position: 8
---

# NodeJS and NPM modules

With [rollup.js](https://rollupjs.org/guide/en/), we can run CommonJS (CJS) and NodeJS (NPM) modules in WasmEdge too.

## Prerequisites

[See here](./hello_world#prerequisites)

## Run the example

The [simple_common_js_demo/npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) demo shows how it works.

First, you will need to use the NPM command to roll up the dependency modules into a single JavaScript file.

```bash
cd example_js/simple_common_js_demo
npm install
npm run build
# Go back to the working directory
cd ../../
```

NPM generates a new JavaScript file at `example_js/simple_common_js_demo/dist/npm_main.mjs`, which is the file you can execute with the WasmEdge QuickJS runtime.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/simple_common_js_demo/dist/npm_main.mjs
md5(message)= 78e731027d8fd50ed642340b7c9a63b3
sqrt(-4)= 2i
```

## Code explanation

The [simple_common_js_demo/npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) utilizes the third-party `md5` and `mathjs` modules.

```javascript
const md5 = require('md5');
console.log('md5(message)=', md5('message'));

const { sqrt } = require('mathjs');
console.log('sqrt(-4)=', sqrt(-4).toString());
```

To run it, we must first use the [rollup.js](https://rollupjs.org/guide/en/) tool to build all dependencies into a single file. In the process, `rollup.js` converts CommonJS modules into [WasmEdge-compatible ES6 modules](es6). The build script is [rollup.config.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/rollup.config.js).

```javascript
const { babel } = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const builtins = require('rollup-plugin-node-builtins');
const plugin_async = require('rollup-plugin-async');

const babelOptions = {
  presets: ['@babel/preset-react'],
};

module.exports = [
  {
    input: './npm_main.js',
    output: {
      inlineDynamicImports: true,
      file: 'dist/npm_main.mjs',
      format: 'esm',
    },
    external: ['process', 'wasi_net', 'std'],
    plugins: [
      plugin_async(),
      nodeResolve(),
      commonjs({ ignoreDynamicRequires: false }),
      babel(babelOptions),
      globals(),
      builtins(),
      replace({
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];
```

The [package.json](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/package.json) file specifies the `rollup.js` dependencies and the command to build the [npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) demo program into a single bundle.

```json
{
  ""dependencies"": {
    ""mathjs"": ""^9.5.1"",
    ""md5"": ""^2.3.0""
  },
  ""devDependencies"": {
    ""@babel/core"": ""^7.16.5"",
    ""@babel/preset-env"": ""^7.16.5"",
    ""@babel/preset-react"": ""^7.16.5"",
    ""@rollup/plugin-babel"": ""^5.3.0"",
    ""@rollup/plugin-commonjs"": ""^21.0.1"",
    ""@rollup/plugin-node-resolve"": ""^7.1.3"",
    ""@rollup/plugin-replace"": ""^3.0.0"",
    ""rollup"": ""^2.60.1"",
    ""rollup-plugin-babel"": ""^4.4.0"",
    ""rollup-plugin-node-builtins"": ""^2.1.2"",
    ""rollup-plugin-node-globals"": ""^1.4.0"",
    ""rollup-plugin-async"": ""^1.2.0""
  },
  ""scripts"": {
    ""build"": ""rollup -c rollup.config.js""
  }
}
```

Run the following NPM commands to build [npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) demo program into `dist/npm_main.mjs`.

```bash
npm install
npm run build
```

You can import and run any NPM packages in WasmEdge this way.
","**Summary:**

This document provides a guide on how to run Node.js and NPM modules in WasmEdge using Rollup.js. The example demonstrates how to use the `md5` and `mathjs` libraries with WasmEdge.

**Key Components:**

1. **Rollup.js**: A tool used to build all dependencies into a single file.
2. **npm_main.js**: The demo program that utilizes third-party modules (`md5` and `mathjs`).
3. **rollup.config.js**: The configuration file for Rollup.js, specifying plugins and settings.
4. **package.json**: The package file specifying dependencies and build scripts.

**Functionality:**

1. Install dependencies using NPM.
2. Run the Rollup.js build script to create a single bundle `dist/npm_main.mjs`.
3. Execute `npm_main.mjs` with WasmEdge QuickJS runtime.

**Potential Issues and Areas for Improvement:**

1. **Dependency Management**: Managing multiple dependencies (e.g., `md5`, `mathjs`) can be complex.
2. **Compatibility**: Ensuring compatibility between Rollup.js, NPM, and WasmEdge versions.
3. **Performance**: Optimizing build times and runtime performance.
4. **Documentation**: Improving documentation for developers to create and run NPM modules in WasmEdge.

**Recommendations:**

1. Use a more efficient dependency manager (e.g., yarn) for easier dependency management.
2. Test the example with different NPM packages and libraries.
3. Optimize the build process by using more efficient plugins or configuration options.
4. Improve documentation to make it easier for developers to create and run their own NPM modules in WasmEdge."
docs/embed/use-case/ssr-modern-ui.md,"---
sidebar_position: 6
---

# Server Side Rendering Modern Web UI

Traditional web applications follow the client-server model. In the past era of application servers, the entire UI is dynamically generated from the server. The browser is a thin client that displays the rendered web pages in real-time. However, as the browser becomes more capable and sophisticated, the client can take on more workload to improve application UX, performance, and security.

That gave rise to the era of Jamstack. There is now a clear separation between frontend and backend services. The frontend is a static website (HTML + JavaScript + WebAssembly) generated from UI frameworks such as React.js, Vue.js, Yew, or Percy, and the backend consists of microservices. Yet, as Jamstack gains popularity, the diversity of clients (browsers and apps) makes it difficult to achieve great performance across all use cases.

The solution is server-side rendering (SSR). That is to have edge servers run the ""client side"" UI code (i.e., the React-generated JavaScript OR Percy-generated WebAssembly) and send back the rendered HTML DOM objects to the browser. In this case, the edge server must execute the same code (i.e., [JavaScript](../../develop/javascript/hello_world.md) and WebAssembly) as the browser to render the UI. That is called isomorphic Jamstack applications. The WasmEdge runtime provides a lightweight, high-performance, OCI complaint, and polyglot container to run all SSR functions on edge servers.

- [React JS SSR function](../../develop/javascript/ssr.md)
- Vue JS SSR function (coming soon)
- Yew Rust compiled to WebAssembly SSR function (coming soon)
- [Percy Rust compiled to WebAssembly SSR function](../../develop/rust/ssr.md)

We also exploring ways to render more complex UI and interactions on WasmEdge-based edge servers and then stream the rendered results to the client application. Potential examples include

- Render Unity3D animations on the edge server (based on [WebAssembly rendering of Unity3D](https://docs.unity3d.com/2020.1/Documentation/Manual/webgl-gettingstarted.html))
- Render interactive video (generated from AI) on the edge server

Of course, the edge cloud could grow well beyond SSR for UI components. It could also host high-performance microservices for business logic and serverless functions. Read on to the next chapter.
","**Summary**

This code documentation describes the concept of Server-Side Rendering (SSR) for modern web UI, particularly in the context of Jamstack applications. The author argues that as browsers become more capable and sophisticated, the traditional client-server model may not be optimal for all use cases. To address this issue, SSR involves running ""client-side"" UI code on edge servers to generate rendered HTML DOM objects, which are then sent back to the browser.

**Key Components**

1. **Jamstack**: A modern web application architecture that separates frontend and backend services.
2. **Server-Side Rendering (SSR)**: The process of generating rendered HTML DOM objects on edge servers using client-side UI code.
3. **Isomorphic Jamstack Applications**: Applications that execute the same code on both client and server sides to render UI components.
4. **WasmEdge Runtime**: A lightweight, high-performance, and polyglot container for running SSR functions on edge servers.

**Potential Issues or Areas for Improvement**

1. **Scalability**: Edge servers may need to handle a large number of requests, which could impact performance.
2. **Security**: Running client-side code on edge servers may introduce security risks if not properly secured.
3. **Complexity**: Implementing SSR for complex UI components and interactions may require significant development effort.
4. **Standardization**: The use of WebAssembly as a runtime environment may not be universally adopted, which could create compatibility issues.

**Future Directions**

The author mentions exploring ways to render more complex UI and interactions on WasmEdge-based edge servers, such as:

1. **Unity3D Animations**: Rendering Unity3D animations on the edge server using WebAssembly.
2. **Interactive Video**: Rendering interactive video generated from AI on the edge server.

Overall, this documentation provides a comprehensive overview of SSR for modern web UI and its potential applications in Jamstack architectures."
i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/ssr-modern-ui.md,"---
sidebar_position: 6
---

# Server Side Rendering Modern Web UI

Traditional web applications follow the client-server model. In the past era of application servers, the entire UI is dynamically generated from the server. The browser is a thin client that displays the rendered web pages in real-time. However, as the browser becomes more capable and sophisticated, the client can take on more workload to improve application UX, performance, and security.

That gave rise to the era of Jamstack. There is now a clear separation between frontend and backend services. The frontend is a static website (HTML + JavaScript + WebAssembly) generated from UI frameworks such as React.js, Vue.js, Yew, or Percy, and the backend consists of microservices. Yet, as Jamstack gains popularity, the diversity of clients (browsers and apps) makes it difficult to achieve great performance across all use cases.

The solution is server-side rendering (SSR). That is to have edge servers run the ""client side"" UI code (i.e., the React-generated JavaScript OR Percy-generated WebAssembly) and send back the rendered HTML DOM objects to the browser. In this case, the edge server must execute the same code (i.e., [JavaScript](../../develop/javascript/hello_world.md) and WebAssembly) as the browser to render the UI. That is called isomorphic Jamstack applications. The WasmEdge runtime provides a lightweight, high-performance, OCI complaint, and polyglot container to run all SSR functions on edge servers.

- [React JS SSR function](../../develop/javascript/ssr.md)
- Vue JS SSR function (coming soon)
- Yew Rust compiled to WebAssembly SSR function (coming soon)
- [Percy Rust compiled to WebAssembly SSR function](../../develop/rust/ssr.md)

We also exploring ways to render more complex UI and interactions on WasmEdge-based edge servers and then stream the rendered results to the client application. Potential examples include

- Render Unity3D animations on the edge server (based on [WebAssembly rendering of Unity3D](https://docs.unity3d.com/2020.1/Documentation/Manual/webgl-gettingstarted.html))
- Render interactive video (generated from AI) on the edge server

Of course, the edge cloud could grow well beyond SSR for UI components. It could also host high-performance microservices for business logic and serverless functions. Read on to the next chapter.
","**Summary:**

This document describes the concept of Server-Side Rendering (SSR) in modern web UI development, specifically for isomorphic Jamstack applications. The goal is to improve application performance and UX by offloading workload from the client browser to edge servers. WasmEdge, a lightweight runtime, enables execution of JavaScript and WebAssembly code on edge servers to render UI components.

**Key Components:**

1. **Server-Side Rendering (SSR):** Edge servers execute ""client side"" UI code (JavaScript or WebAssembly) to render HTML DOM objects.
2. **Isomorphic Jamstack Applications:** Edge server executes same code as browser to render UI.
3. **WasmEdge Runtime:** Provides lightweight, high-performance container for running SSR functions on edge servers.

**Potential Issues/Improvement Areas:**

1. **Complex UI Rendering:** Exploring ways to render more complex UI interactions and animations on WasmEdge-based edge servers.
2. **Microservices Hosting:** Edge cloud could host high-performance microservices for business logic and serverless functions, expanding beyond SSR for UI components.

**Recommendations:**

1. Further development of Vue JS and Yew Rust compiled to WebAssembly SSR functions.
2. Exploration of more advanced use cases for WasmEdge-based edge servers.
3. Investigation into hosting high-performance microservices on the edge cloud."
i18n/zh/docusaurus-plugin-content-docs/current/start/getting-started/quick_start_redhat.md,"---
sidebar_position: 3
---

# 在 Red Hat 下的快速入门

在本指南中，我们将指导你如何在 Fedora / CentOS / Red Hat Linux / OpenShift 系统中快速运行 WasmEdge 应用程序。整个开发和运行环境由 OpenSift / Podman 管理，因此不需要额外的依赖。

<!-- prettier-ignore -->
:::note
如果你不使用 OpenShift / Podman，请[从这里开始](quick_start.md)。
:::

我们将涵盖以下示例。

- [运行独立的 WASM 应用](#运行独立的-wasm-应用)
- [运行 HTTP 服务器](#运行一个 HTTP 服务器)
- [运行基于 JavaScript 的服务器 (node.js)](#运行一个基于 JavaScript 的服务器)

## 安装

你可以使用一行 `dnf` 命令在 Fedora / CentOS / Red Hat Linux 系统上安装 WasmEdge，[crun](https://github.com/containers/crun) 和 [Podman](https://www.redhat.com/en/topics/containers/what-is-podman)。WasmEdge 运行时是 Fedora 37 和 Red Hat REPL 8、9 的[官方维护上游包](https://packages.fedoraproject.org/pkgs/wasmedge/wasmedge/index.html)。

```bash
dnf install wasmedge crun-wasm podman
```

## 运行独立的 WASM 应用程序

Hello world 示例是一个独立的 Rust 应用程序。其源代码和构建说明可在[此处](https://github.com/second-state/rust-examples/tree/main/hello)找到。

使用 Podman 运行容器化的 WASM 应用。WASM 容器镜像存储在 Docker Hub 中，其镜像大小仅为 500KB。该镜像可在 Red Hat 支持的任何 OS 和 CPU 平台上运行。

```bash
$ podman --runtime /usr/bin/crun-wasm run --platform=wasi/wasm -t --rm docker.io/secondstate/rust-example-hello:latest
Hello WasmEdge!
```

了解如何在 Rust 中创建 WASM 应用的更多信息

- [WasmEdge 的基本 Rust 示例](https://github.com/second-state/rust-examples)
- [Rust 开发人员指南](/category/develop-wasm-apps-in-rust)
  - 使用 [PyTorch](../../develop/rust/wasinn/pytorch.md)、[OpenVINO](../../develop/rust/wasinn/openvino.md) 或 [Tensorflow Lite](../../develop/rust/wasinn/tensorflow_lite.md) 后端的 WASI-NN
  - [HTTP 和 HTTPS 客户端](../../develop/rust/http_service/client.md)
  - [MySQL 数据库客户端](../../develop/rust/database/my_sql_driver.md)
  - Redis 客户端
  - Kafka 客户端

## 运行 HTTP 服务器

该示例是一个独立的用 Rust 编写的 HTTP 服务器。它演示了 Rust + WasmEdge 作为微服务的轻量级技术栈。其源代码和构建说明可在[此处](https://github.com/second-state/rust-examples/tree/main/server)找到。

使用 Podman 从 Docker Hub 拉取容器镜像（大约 800KB），然后在 WasmEdge 容器中运行它。容器作为服务器启动。请注意，我们将容器的端口 8080 映射到本地主机的端口 8080，以使服务器从 WASM 容器外部访问。

```bash
$ podman --runtime /usr/bin/crun-wasm run -dp 8080:8080 --platform=wasi/wasm -t --rm docker.io/secondstate/rust-example-server:latest
Listening on http://0.0.0.0:8080
```

从另一个终端窗口执行以下命令。

```bash
$ curl http://localhost:8080/
Try POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`

$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

了解如何在 Rust 中创建 WASM 服务的更多信息

- [Rust 开发者指南](/category/develop-wasm-apps-in-rust)
- [HTTP 应用示例](https://github.com/WasmEdge/wasmedge_hyper_demo)
- [数据库应用示例](https://github.com/WasmEdge/wasmedge-db-examples)
- Rust 和 WasmEdge 中的轻量级微服务
  - [WasmEdge + Nginx + MySQL](https://github.com/second-state/microservice-rust-mysql)
  - [WasmEdge + Kafka + MySQL](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql)
  - [Dapr + WasmEdge](https://github.com/second-state/dapr-wasm)

## 运行基于 JavaScript 的服务器

此示例是使用 Node.js API 编写的独立 HTTP 服务器，演示了 WasmEdge 作为零依赖和可移动的 Node.js 应用的轻量级运行时。其源代码可在[此处](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/docker_wasm/server)找到。

```bash
$ podman --runtime /usr/bin/crun-wasm run -dp 8080:8080 --platform=wasi/wasm -t --rm docker.io/secondstate/node-example-server:latest
... ...
```

从另一个终端窗口执行以下命令。

```bash
$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

了解如何在 WasmEdge 中运行 JavaScript 应用的更多信息。

- [WasmEdge QuickJS 运行时](https://github.com/second-state/wasmedge-quickjs)
- [AI 推理应用示例](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo)
- [使用 fetch() 的 Web 服务客户端示例](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js)

## 下一步

- [WasmEdge 的基本 Rust 示例](https://github.com/second-state/rust-examples)
- 用你喜欢的语言编写 WASM 应用，如 [Rust](/category/develop-wasm-apps-in-rust)、[C/C++](/category/develop-wasm-apps-in-cc)、[JavaScript](/category/develop-wasm-apps-in-javascript)、[Go](/category/develop-wasm-apps-in-go) 以及其他许多语言。
","**概述**

该文档旨在指导开发者使用 WasmEdge 在 Red Hat Linux 系统上快速启动应用程序。它提供了三个示例，分别使用 Rust、HTTP 服务器和 JavaScript 运行时来展示如何部署和管理 WASM 应用。

**功能性组件**

*   **安装**:文档提供了一条 `dnf` 命令来在 Fedora/CentOS/Red Hat Linux 系统上安装 WasmEdge 和必要的依赖项。
*   **WASM 应用示例**
    *   **独立的Rust应用**：使用 Podman 从 Docker Hub 拉取容器镜像，然后在 WASM 容器中运行它。
    *   **HTTP服务器**：使用 Podman 从 Docker Hub 拉取容器镜像然后在 WasmEdge 容器中运行它，并映射本地主机的端口 8080 到容器内部的端口 8080，确保从 WASM 容器外部可以访问服务器。
    *   **基于JavaScript的服务**：使用 Podman 从 Docker Hub 拉取容器镜像然后在 WasmEdge 容器中运行它。

**潜在问题**

*   如果您不使用 OpenShift/Podman，请参考[此文档](quick_start.md)继续。
*   文档中提供的命令和操作假设用户已经安装并配置了必要的依赖项和软件包。
*   使用 WASM 应用示例可能需要修改容器镜像来适应特定应用需求。

**改进区域**

*   提供更多关于 WasmEdge 和其依赖项的信息，例如使用方法、最佳实践以及常见问题解决方案。
*   为不同的应用场景提供更具体的指导，例如 web 应用、移动应用或微服务。
*   在示例中使用更现代的容器运行时和 Docker 仓库镜像。"
docs/embed/c/reference/upgrade_to_0.13.0.md,"---
sidebar_position: 4
---

# Upgrade to WasmEdge 0.13.0

Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the `0.12.1` to the `0.13.0` version.

In this version, there are only new features. Developers can build their original source with this WasmEdge version directly.

## Concepts

1. Introduced new API for setting data and its finalizer into module instances when creation.

   Developers can use the `WasmEdge_ModuleInstanceCreateWithData()` API to set the host data and its finalizer into the module instance.

2. Asynchronously invoking WASM function by executor.

   Developers can use the `WasmEdge_ExecutorAsyncInvoke()` API to execute a WASM function asynchronously.

3. Unified WasmEdge CLI.

   Developers can use the `WasmEdge_Driver_UniTool()` API to trigger the unified WasmEdge CLI.

## Set data and its finalizer into a module instance when creation

Besides setting host data into a host function, developers can set and move ownership of host data into a `Module` instance context with its finalizer. This may be useful when implementing the plug-ins.

```c
/* Struct definition. */
typedef struct Point {
  int X;
  int Y;
} Point;

/* Host function body definition. */
WasmEdge_Result Print(void *Data,
                      const WasmEdge_CallingFrameContext *CallFrameCxt,
                      const WasmEdge_Value *In, WasmEdge_Value *Out) {
  Point *P = (Point *)In;
  printf(""Point: (%d, %d)\n"", P->X, P->Y);
  return WasmEdge_Result_Success;
}

/* Finalizer definition. */
void PointFinalizer(void *Data) {
  if (Data) {
    free((Point *)Data);
  }
}

/* Create a module instance with host data and its finalizer. */
WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");
Point *Data = (Point *)malloc(sizeof(Point));
Data->X = 5;
Data->Y = -5;
WasmEdge_ModuleInstanceContext *HostModCxt =
    WasmEdge_ModuleInstanceCreateWithData(ExportName, Data, PointFinalizer);
/*
 * When the `HostModCxt` being destroyed, the finalizer will be invoked and the
 * `Data` will be its argument.
 */
WasmEdge_StringDelete(ExportName);
```

## Unified WasmEdge CLI

The `WasmEdge_Driver_UniTool()` API presents the same function as running the [`wasmedge` tool](../../../start/build-and-run/cli.md).

```c
#include <wasmedge/wasmedge.h>
#include <stdio.h>
int main(int argc, const char *argv[]) {
  /* Run the WasmEdge unified tool. */
  /* (Within both runtime and AOT compiler) */
  return WasmEdge_Driver_UniTool(argc, argv);
}
```
","**Summary**

The provided code is a reference guide for upgrading to WasmEdge 0.13.0, which includes breaking changes in the C API. The document outlines new features and APIs introduced in version 0.13.0.

**Key Components**

1. **New API for setting data and its finalizer into module instances**: `WasmEdge_ModuleInstanceCreateWithData()` allows developers to set host data and its finalizer into a module instance.
2. **Asynchronous invocation of WASM functions using executor**: `WasmEdge_ExecutorAsyncInvoke()` enables executing WASM functions asynchronously.
3. **Unified WasmEdge CLI**: `WasmEdge_Driver_UniTool()` provides a unified command-line interface.

**Example Use Cases**

1. **Setting data and its finalizer into a module instance**: Demonstrates how to create a module instance with host data and its finalizer using `WasmEdge_ModuleInstanceCreateWithData()`.
2. **Unified WasmEdge CLI**: Shows an example of running the unified WasmEdge CLI using `WasmEdge_Driver_UniTool()`.

**Potential Issues or Areas for Improvement**

1. **Breaking changes in C API**: The introduction of new APIs and breaking changes may require significant updates to existing codebases.
2. **Complexity of asynchronous execution**: The use of asynchronous execution may introduce additional complexity, especially for developers without prior experience with async programming.
3. **Limited documentation on unified CLI**: While the example provided demonstrates the usage of `WasmEdge_Driver_UniTool()`, further documentation and examples would be beneficial to ensure a smooth transition.

Overall, the code provides a clear guide for upgrading to WasmEdge 0.13.0, with well-documented examples and API references. However, developers should carefully review the breaking changes and potential areas of complexity before adopting this version."
i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.13.0.md,"---
sidebar_position: 4
---

# Upgrade to WasmEdge 0.13.0

Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the `0.12.1` to the `0.13.0` version.

In this version, there are only new features. Developers can build their original source with this WasmEdge version directly.

## Concepts

1. Introduced new API for setting data and its finalizer into module instances when creation.

   Developers can use the `WasmEdge_ModuleInstanceCreateWithData()` API to set the host data and its finalizer into the module instance.

2. Asynchronously invoking WASM function by executor.

   Developers can use the `WasmEdge_ExecutorAsyncInvoke()` API to execute a WASM function asynchronously.

3. Unified WasmEdge CLI.

   Developers can use the `WasmEdge_Driver_UniTool()` API to trigger the unified WasmEdge CLI.

## Set data and its finalizer into a module instance when creation

Besides setting host data into a host function, developers can set and move ownership of host data into a `Module` instance context with its finalizer. This may be useful when implementing the plug-ins.

```c
/* Struct definition. */
typedef struct Point {
  int X;
  int Y;
} Point;

/* Host function body definition. */
WasmEdge_Result Print(void *Data,
                      const WasmEdge_CallingFrameContext *CallFrameCxt,
                      const WasmEdge_Value *In, WasmEdge_Value *Out) {
  Point *P = (Point *)In;
  printf(""Point: (%d, %d)\n"", P->X, P->Y);
  return WasmEdge_Result_Success;
}

/* Finalizer definition. */
void PointFinalizer(void *Data) {
  if (Data) {
    free((Point *)Data);
  }
}

/* Create a module instance with host data and its finalizer. */
WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");
Point *Data = (Point *)malloc(sizeof(Point));
Data->X = 5;
Data->Y = -5;
WasmEdge_ModuleInstanceContext *HostModCxt =
    WasmEdge_ModuleInstanceCreateWithData(ExportName, Data, PointFinalizer);
/*
 * When the `HostModCxt` being destroyed, the finalizer will be invoked and the
 * `Data` will be its argument.
 */
WasmEdge_StringDelete(ExportName);
```

## Unified WasmEdge CLI

The `WasmEdge_Driver_UniTool()` API presents the same function as running the [`wasmedge` tool](../../../start/build-and-run/cli.md).

```c
#include <wasmedge/wasmedge.h>
#include <stdio.h>
int main(int argc, const char *argv[]) {
  /* Run the WasmEdge unified tool. */
  /* (Within both runtime and AOT compiler) */
  return WasmEdge_Driver_UniTool(argc, argv);
}
```
","**Summary**

This is a documentation for upgrading from WasmEdge version 0.12.1 to 0.13.0, which includes new features and breaking changes in the C API. The document provides guidelines for developers on how to use the new APIs and tools.

**Key Components**

1. **Setting data and its finalizer into a module instance**: Developers can use the `WasmEdge_ModuleInstanceCreateWithData()` API to set host data and its finalizer into a module instance.
2. **Asynchronously invoking WASM functions**: Developers can use the `WasmEdge_ExecutorAsyncInvoke()` API to execute WASM functions asynchronously.
3. **Unified WasmEdge CLI**: Developers can use the `WasmEdge_Driver_UniTool()` API to trigger the unified WasmEdge CLI, which presents the same function as running the `wasmedge` tool.

**Code Examples**

1. Setting data and its finalizer into a module instance: A code example demonstrates how to set host data into a host function and move ownership of the host data into a `Module` instance context with its finalizer.
2. Unified WasmEdge CLI: An example shows how to use the `WasmEdge_Driver_UniTool()` API to run the unified WasmEdge CLI.

**Potential Issues**

1. Breaking changes in C API: The new version of WasmEdge includes breaking changes in the C API, which may require developers to update their code.
2. New APIs and tools: Developers need to familiarize themselves with the new APIs and tools provided in WasmEdge 0.13.0.

Overall, this documentation provides a clear guide for upgrading from WasmEdge version 0.12.1 to 0.13.0, including key components, code examples, and potential issues to consider."
i18n/zh/docusaurus-plugin-content-docs/current/start/wasmedge/extensions/proposals.md,"---
sidebar_position: 1
---

# WebAssembly 提案

## 标准的 WebAssembly 功能

WasmEdge 支持以下 [WebAssembly 提案](https://github.com/WebAssembly/proposals)。这些提案可能成为未来的官方 WebAssembly 规范。

| 提案 | WasmEdge CLI 标志 | WasmEdge C API 枚举 | 默认开启 | 解释器模式 | AOT 模式 |
| --- | --- | --- | --- | --- | --- |
| [可变全局变量的导入/导出][] | `--disable-import-export-mut-globals` | `WasmEdge_Proposal_ImportExportMutGlobals` | ✓（自`0.8.2`） | ✓ | ✓ |
| [非陷阱浮点数到整数转换][] | `--disable-non-trap-float-to-int` | `WasmEdge_Proposal_NonTrapFloatToIntConversions` | ✓（自`0.8.2`） | ✓ | ✓ |
| [符号扩展操作][] | `--disable-sign-extension-operators` | `WasmEdge_Proposal_SignExtensionOperators` | ✓（自`0.8.2`） | ✓ | ✓ |
| [多值返回][] | `--disable-multi-value` | `WasmEdge_Proposal_MultiValue` | ✓（自`0.8.2`） | ✓ | ✓ |
| [引用类型][] | `--disable-reference-types` | `WasmEdge_Proposal_ReferenceTypes` | ✓（自`0.8.2`） | ✓ | ✓ |
| [批量内存操作][] | `--disable-bulk-memory` | `WasmEdge_Proposal_BulkMemoryOperations` | ✓（自`0.8.2`） | ✓ | ✓ |
| [固定宽度 SIMD][] | `--disable-simd` | `WasmEdge_Proposal_SIMD` | ✓（自`0.9.0`） | ✓（自`0.8.2`） | ✓（自`0.8.2`） |
| [尾调用][] | `--enable-tail-call` | `WasmEdge_Proposal_TailCall` |  | ✓（自`0.10.0`） | ✓（自`0.10.0`） |
| [多内存][] | `--enable-multi-memory` | `WasmEdge_Proposal_MultiMemories` |  | ✓（自`0.9.1`） | ✓（自`0.9.1`） |
| [扩展常量表达式][] | `--enable-extended-const` | `WasmEdge_Proposal_ExtendedConst` |  | ✓（自`0.10.0`） | ✓（自`0.10.0`） |
| [线程][] | `--enable-threads` | `WasmEdge_Proposal_Threads` |  | ✓（自`0.10.1`） | ✓（自`0.10.1`） |

以下提案正在开发中，可能在将来得到支持：

- [组件模型][]
- [异常处理][]
- [垃圾回收][]
- [WebAssembly C 和 C++ API][]

[Import/Export of Mutable Globals]: https://github.com/WebAssembly/mutable-global
[Non-trapping float-to-int conversions]: https://github.com/WebAssembly/nontrapping-float-to-int-conversions
[Sign-extension operators]: https://github.com/WebAssembly/sign-extension-ops
[Multi-value]: https://github.com/WebAssembly/multi-value
[Reference Types]: https://github.com/WebAssembly/reference-types
[Bulk memory operations]: https://github.com/WebAssembly/bulk-memory-operations
[Fixed-width SIMD]: https://github.com/webassembly/simd
[Tail call]: https://github.com/WebAssembly/tail-call
[Multiple memories]: https://github.com/WebAssembly/multi-memory
[Extended Constant Expressions]: https://github.com/WebAssembly/extended-const
[Threads]: https://github.com/webassembly/threads
[Component Model]: https://github.com/WebAssembly/component-model
[Exception handling]: https://github.com/WebAssembly/exception-handling
[Garbage collection]: https://github.com/WebAssembly/gc
[WebAssembly C and C++ API]: https://github.com/WebAssembly/wasm-c-api

## WASI 提案

WasmEdge 实现了以下 [WASI 提案](https://github.com/WebAssembly/WASI/blob/main/Proposals.md)：

| 提案 | 平台支持 |
| --- | --- |
| [Sockets][] | `x86_64 Linux`, `aarch64 Linux` (自 `0.10.0` 起) |
| [Crypto][] | `x86_64 Linux`, `aarch64 Linux` (自 `0.10.1` 起) |
| [机器学习（wasi-nn）][] | `x86_64 Linux`, OpenVINO (自 `0.10.1` 起), PyTorch (自 `0.11.1` 起), 以及 TensorFlow-Lite (自 `0.11.2` 起) 后端 |
| [proxy-wasm][] | `x86_64 Linux（仅解释器）` (自 `0.8.2` 起) |

以下提案正在开发中，将来可能会得到支持：

- WASI-NN 的 TensorFlow 后端

[Sockets]: https://github.com/WebAssembly/wasi-sockets
[Crypto]: https://github.com/WebAssembly/wasi-crypto
[机器学习（wasi-nn）]: https://github.com/WebAssembly/wasi-nn
[proxy-wasm]: https://github.com/proxy-wasm/spec
","**Summary**

This document outlines the features and proposals supported by WasmEdge, a WebAssembly runtime. It includes information on enabled and disabled features, as well as proposals that are in development.

**Key Components**

1. **WebAssembly Proposals**: A table listing WebAssembly proposals implemented in WasmEdge, including their corresponding CLI flags, C API enumerations, and default settings.
2. **WASI (WebAssembly System Interface) Proposals**: A table listing WASI proposals implemented in WasmEdge, including their corresponding platform support.

**Functionality**

The document provides information on the following features:

* WebAssembly proposals supported by WasmEdge, including:
	+ Mutable global variables
	+ Non-trapping float-to-int conversions
	+ Sign extension operators
	+ Multi-value returns
	+ Reference types
	+ Bulk memory operations
	+ Fixed-width SIMD
	+ Tail calls
	+ Multiple memories
	+ Extended constant expressions
	+ Threads
* WASI proposals supported by WasmEdge, including:
	+ Sockets
	+ Crypto
	+ Machine learning (wasi-nn)

**Areas for Improvement**

1. **Platform Support**: The document does not provide information on platform support for all features and proposals.
2. **Development Status**: Some proposals are marked as ""in development,"" but it is unclear when they will be implemented or released.

Overall, the document provides a good overview of WasmEdge's features and supported WebAssembly proposals, but may benefit from additional details and clarity on development status."
docs/contribute/overview.md,"---
sidebar_position: 1
displayed_sidebar: contributeSidebar
---

# Contribute and Extend WasmEdge

Contribution is always welcome! The WebAssembly ecosystem is still in its early days. Hosted by CNCF, WasmEdge aims to become an open source “reference implementation” of WebAssembly and its edge-related extensions. WasmEdge is developed in the open, and is constantly being improved by our users, contributors, and maintainers. It is because of you that we can bring great software to the community.We are looking forward to working together with you!

To help new contributors understand WasmEdge development workflow, this guide will include

- [Build WasmEdge and WasmEdge plug-in from source on different platforms](/category/build-wasmedge-from-source)
- [WasmEdge Plug-in system introduction](/category/wasmedge-plugin-system)
- [Test WasmEdge](test.md)
- [WasmEdge Fuzzing](fuzzing.md)
- [WasmEdge internal explanation](internal.md)
- [WasmEdge installer system explanation](installer.md)
- [contributing steps](contribute.md)
- [WasmEdge release process](release.md)
- [Join WasmEdge community](community.md)

## Ideas for contributions

If you're looking for something to contribute, we have issues

- labeled with [`good first issue`](https://github.com/WasmEdge/WasmEdge/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22), which are recommendations for developers to contribute to WasmEdge by working on some easy tasks. These tasks will help contributors to learn the WasmEdge development workflow.

- labeled with [`help wanted`](https://github.com/WasmEdge/WasmEdge/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22), for which are we need suggestions and opinions from the community.

- [Roadmap](https://github.com/WasmEdge/WasmEdge/blob/master/docs/ROADMAP.md) for every year, which elaborates the new features in the coming days. You are also welcome to pick one.

If you find something is missing, don't hesitate to create an issue and let us know. Again, WasmEdge is open in development.

## Mentoring

WasmEdge maintainers can provide mentoring for WasmEdge, WebAssembly, C++, Rust, compiler, etc. If you are interested in fixing one open issue, just let us know by commenting under the issue. WasmEdge maintainers will reply to your question in time.

Besides the regular GitHub issues, the WasmEdge project will participate in some open source mentoring projects like [Google Summer of Code (GSoC)](https://summerofcode.withgoogle.com/), [Google Season of Docs (GSoD)](https://developers.google.com/season-of-docs), [LFX Mentorship](https://mentorship.lfx.linuxfoundation.org/#projects_all), and [Open Source Promotion Plan (OSPP)](https://summer-ospp.ac.cn/). Join our [Discord server](https://discord.gg/U4B5sFTkFc) or follow [@realwasmedge](https://twitter.com/realwasmedge) on Twitter to get alerts on the application details.
","**Summary**

This documentation serves as an overview of the WasmEdge contribution guide, outlining the steps to contribute and extend the open-source ""reference implementation"" of WebAssembly. It covers topics such as building WasmEdge from source, plugin system introduction, testing, fuzzing, internal explanation, installer system explanation, contributing steps, release process, and joining the community.

**Key Components**

1. **Contributing Steps**: A guide for new contributors to understand the development workflow.
2. **Ideas for Contributions**: Suggestions for issues to work on, labeled as ""good first issue"" or ""help wanted"".
3. **Roadmap**: An outline of new features in the coming days.
4. **Mentoring**: WasmEdge maintainers offer mentoring for contributors interested in fixing open issues.

**Potential Issues or Areas for Improvement**

1. **Complexity**: The documentation covers a wide range of topics, which may be overwhelming for new contributors.
2. **Organization**: Some sections seem disconnected; better organization and categorization could improve the flow of information.
3. **Technical Details**: Some technical aspects might benefit from additional explanations or examples to help non-experts understand the concepts.
4. **Community Engagement**: While there are suggestions for contributing, it's unclear how contributors can engage with the community beyond reporting issues.

**Recommendations**

1. **Simplify the structure**: Break down complex topics into smaller sections and provide clear headings and summaries.
2. **Add more examples and explanations**: Provide additional technical details to help non-experts understand the concepts.
3. **Emphasize community engagement**: Highlight ways contributors can interact with the community, such as participating in discussions or attending meetups.
4. **Regularly update the roadmap**: Keep the roadmap up-to-date with new features and changes in priorities."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/overview.md,"---
sidebar_position: 1
displayed_sidebar: contributeSidebar
---

# Contribute and Extend WasmEdge

Contribution is always welcome! The WebAssembly ecosystem is still in its early days. Hosted by CNCF, WasmEdge aims to become an open source “reference implementation” of WebAssembly and its edge-related extensions. WasmEdge is developed in the open, and is constantly being improved by our users, contributors, and maintainers. It is because of you that we can bring great software to the community.We are looking forward to working together with you!

To help new contributors understand WasmEdge development workflow, this guide will include

- [Build WasmEdge and WasmEdge plug-in from source on different platforms](/category/build-wasmedge-from-source)
- [WasmEdge Plug-in system introduction](/category/wasmedge-plugin-system)
- [Test WasmEdge](test.md)
- [WasmEdge Fuzzing](fuzzing.md)
- [WasmEdge internal explanation](internal.md)
- [WasmEdge installer system explanation](installer.md)
- [contributing steps](contribute.md)
- [WasmEdge release process](release.md)
- [Join WasmEdge community](community.md)

## Ideas for contributions

If you're looking for something to contribute, we have issues

- labeled with [`good first issue`](https://github.com/WasmEdge/WasmEdge/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22), which are recommendations for developers to contribute to WasmEdge by working on some easy tasks. These tasks will help contributors to learn the WasmEdge development workflow.

- labeled with [`help wanted`](https://github.com/WasmEdge/WasmEdge/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22), for which are we need suggestions and opinions from the community.

- [Roadmap](https://github.com/WasmEdge/WasmEdge/blob/master/docs/ROADMAP.md) for every year, which elaborates the new features in the coming days. You are also welcome to pick one.

If you find something is missing, don't hesitate to create an issue and let us know. Again, WasmEdge is open in development.

## Mentoring

WasmEdge maintainers can provide mentoring for WasmEdge, WebAssembly, C++, Rust, compiler, etc. If you are interested in fixing one open issue, just let us know by commenting under the issue. WasmEdge maintainers will reply to your question in time.

Besides the regular GitHub issues, the WasmEdge project will participate in some open source mentoring projects like [Google Summer of Code (GSoC)](https://summerofcode.withgoogle.com/), [Google Season of Docs (GSoD)](https://developers.google.com/season-of-docs), [LFX Mentorship](https://mentorship.lfx.linuxfoundation.org/#projects_all), and [Open Source Promotion Plan (OSPP)](https://summer-ospp.ac.cn/). Join our [Discord server](https://discord.gg/U4B5sFTkFc) or follow [@realwasmedge](https://twitter.com/realwasmedge) on Twitter to get alerts on the application details.
","**Summary**

This markdown file is part of the Docusaurus plugin for WasmEdge, a WebAssembly runtime developed by CNCF. It serves as an overview guide for contributing to and extending WasmEdge. The document provides information on how to get started with contributing, including building from source, understanding the development workflow, and participating in various projects. It also highlights potential areas for contributions and introduces mentoring opportunities.

**Key Components**

1. **Guidance for new contributors**: The document includes a list of resources to help new contributors understand WasmEdge's development workflow.
2. **Ideas for contributions**: A section listing issues labeled with `good first issue` or `help wanted`, which are suitable for beginners or require community input.
3. **Mentoring opportunities**: WasmEdge maintainers can provide guidance on specific areas, such as WebAssembly, C++, Rust, and compiler development.

**Potential Issues/Improvements**

1. **Organization**: The document is well-structured, but it might be beneficial to add more visual organization (e.g., headings, sections) to facilitate navigation.
2. **Link management**: Some links are internal, while others are external; a consistent approach would make the content more accessible and easier to maintain.
3. **Versioning**: The document mentions specific versions of resources (e.g., GitHub issues, ROADMAP); consider adding version information to avoid potential inconsistencies.
4. **Community engagement**: While there's an invitation to join the WasmEdge community, it might be beneficial to include more explicit calls-to-action or direct links to engage with the project.

**Overall Assessment**

The provided markdown file is well-written and effectively communicates its purpose. With minor adjustments and improvements, this guide can serve as a valuable resource for new contributors and potential collaborators in the WasmEdge ecosystem."
i18n/zh/docusaurus-plugin-content-docs/current/start/wasmedge/extensions/plugins.md,"---
sidebar_position: 2
---

# WasmEdge 插件

对于那些过于重而难以编译成 WebAssembly的工作负载，将它们构建成本机主机函数是更好的选择。为了满足 WebAssembly 运行时的可移植性，WasmEdge 引入了插件机制，使主机函数可以加载和传输。

WasmEdge 的插件机制是一种扩展主机模块的简便方法，用户可以通过插件从由 WasmEdge 官方发布或其他开发人员发布的共享库中加载和实例化主机函数。

## 官方插件

下面列出了 WasmEdge 官方发布的插件。用户可以通过安装程序轻松安装它们。

| 插件 | 描述 | 平台支持 | 语言支持 |
| --- | --- | --- | --- |
| [WasmEdge-Process](../../../contribute/source/plugin/process.md) | 允许 WebAssembly 程序在主机操作系统中执行本机命令。它支持传递参数、环境变量、`STDIN`/`STDOUT` 管道以及主机访问的安全策略。 | `manylinux2014 x86_64`，`manylinux2014 aarch64` 和 `ubuntu 20.04 x86_64`（自`0.10.0`） | [Rust](https://crates.io/crates/wasmedge_process_interface) |
| [WASI-Crypto](https://github.com/WebAssembly/wasi-crypto) | 用于运行时向 WebAssembly 模块公开的 API，以执行加密操作和密钥管理。 | `manylinux2014 x86_64`，`manylinux2014 aarch64` 和 `ubuntu 20.04 x86_64`（自`0.10.1`） | [Rust](https://crates.io/crates/wasi-crypto) |
| [WASI-NN](https://github.com/WebAssembly/wasi-nn)[（OpenVINO 后端）](../../../develop/rust/wasinn/openvino.md) | 使用 OpenVINO 模型进行 AI 推理。 | `ubuntu 20.04 x86_64`（自`0.10.1`） | [Rust](https://crates.io/crates/wasi-nn)，JavaScript |
| [WASI-NN](https://github.com/WebAssembly/wasi-nn)[（Pytorch 后端）](../../../develop/rust/wasinn/pytorch.md)   | 使用 Pytorch 模型进行 AI 推理。 | `manylinux2014 x86_64` 和 `ubuntu 20.04 x86_64`（自`0.11.1`） | [Rust](https://crates.io/crates/wasi-nn)，JavaScript |
| [WASI-NN](https://github.com/WebAssembly/wasi-nn)[（TensorFlow-Lite 后端）](../../../develop/rust/wasinn/tensorflow_lite.md)  | 使用 TensorFlow-Lite 模型进行 AI 推理。 | `manylinux2014 x86_64`，`manylinux2014 aarch64` 和 `ubuntu 20.04 x86_64`（自`0.11.2`） | [Rust](https://crates.io/crates/wasi-nn)，JavaScript |
| [WasmEdge-Image](../../../contribute/source/plugin/image.md) | 用于 AI 推理任务中处理图像的本机库。 | `manylinux2014 x86_64`，`manylinux2014 aarch64`，`ubuntu 20.04 x86_64`，`darwin x86_64` 和 `darwin arm64`（自`0.13.0`） | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface)（0.3.0） |
| [WasmEdge-Tensorflow](../../../contribute/source/plugin/tensorflow.md) | 用于推理 TensorFlow 模型的本机库。 | `manylinux2014 x86_64`，`manylinux2014 aarch64`，`ubuntu 20.04 x86_64`，`darwin x86_64` 和 `darwin arm64`（自`0.13.0`） | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface)（0.3.0） |
| [WasmEdge-TensorflowLite](../../../contribute/source/plugin/tensorflowlite.md)  | 用于推理 TensorFlow-Lite 模型的本机库。 | `manylinux2014 x86_64`，`manylinux2014 aarch64`，`ubuntu 20.04 x86_64`，`darwin x86_64` 和 `darwin arm64`（自`0.13.0`） | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface) |
| WasmEdge-OpenCV  | 一个非常流行的常用于处理图像和视频以供 AI 输入/输出函数库。      | 未发布                                       | Rust |
| WasmEdge-eBPF    | 一个用于进行 eBPF 应用推理的原生库                           | `manylinux2014 x86_64`, `manylinux2014 aarch64`, `ubuntu 20.04 x86_64`, `darwin x86_64`, and `darwin arm64` (since `0.13.0`) | Rust                                                                   |
| WasmEdge-rustls | 一个用于进行 Rust 和 TLS 推理的原生库                        | `manylinux2014 x86_64`, `manylinux2014 aarch64`, `ubuntu 20.04 x86_64`, `darwin x86_64`, and `darwin arm64` (since `0.13.0`) | [Rust](https://crates.io/crates/wasmedge_rustls_api)                   |

## （过去的）WasmEdge 拓展

除了插件，WasmEdge 在 `0.13.0` 版本之前还提供了扩展功能。请注意，在 `0.13.0` 版本之后，这些扩展已经被相应的插件所取代。

支持这些扩展的最新版本是 `0.12.1`。当 WasmEdge 安装程序不再支持安装 `0.12.x` 版本时，本段将被废弃。

| 扩展 | 描述 | 平台支持 | 语言支持 |
| --- | --- | --- | --- |
| [图像处理](https://github.com/second-state/WasmEdge-image) | 用于处理人工智能推推理任务中的图像的本地库。在 WasmEdge `0.13.0` 版本后迁移到插件中。 | `manylinux2014 x86_64`，`manylinux2014 aarch64`，`android aarch64`，`ubuntu 20.04 x86_64` 和 `darwin x86_64` | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface) (0.2.2) |
| [TensorFlow 和 Tensorflow-Lite](https://github.com/second-state/WasmEdge-tensorflow) | 用于 TensorFlow 和 TensorFlow-Lite 模型推理的本地库。在 WasmEdge `0.13.0` 版本后迁移到插件中。 | `manylinux2014 x86_64`，`manylinux2014 aarch64`（仅限TensorFlow-Lite），`android aarch64`（仅限TensorFlow-Lite），`ubuntu 20.04 x86_64` 和 `darwin x86_64` | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface) (0.2.2) |
","**Summary**

This document describes the WasmEdge plugin system, which allows users to load and instantiate host functions from shared libraries published by WasmEdge or other developers. The plugins enable webAssembly runtime portability and are a convenient method for extending the host module.

**Key Components**

1. **Official Plugins**: These are plugins officially released by WasmEdge, listed in a table format with their description, platform support, and language support.
2. **Legacy Extensions**: These are extensions that were provided by WasmEdge before version 0.13.0, which have been replaced by corresponding plugins.

**Functionality**

The plugins enable users to:

* Execute native commands from webAssembly programs
* Perform encryption operations and key management using WASI-Crypto
* Use OpenVINO, PyTorch, or TensorFlow-Lite models for AI inference
* Process images for AI inference tasks
* Use TensorFlow, TensorFlow-Lite, or other libraries for machine learning

**Potential Issues**

1. **Legacy Extensions**: The legacy extensions are deprecated and will be removed in future versions of WasmEdge.
2. **Plugin Compatibility**: Some plugins may not be compatible with all platforms or languages, so users should check the compatibility before using a plugin.

Overall, the WasmEdge plugin system provides a convenient method for extending the host module and enables webAssembly runtime portability."
docs/develop/rust/database/redis_driver.md,"---
sidebar_position: 3
---

# Redis driver

WasmEdge provides a Redis driver for Rust developers, enabling developers to build database applications in Rust and then running in WasmEdge.

<!-- prettier-ignore -->
:::note
Before we start, [you need to have Rust and WasmEdge installed](../setup.md).
Make sure that you read the [special notes on networking apps](../setup#special-notes-for-networking-apps) especially if you are compiling Rust programs on a Mac.
:::

## Run the example

The [wasmedge-db-example/redis](https://github.com/WasmEdge/wasmedge-db-examples/tree/main/redis) is a Redis connector example written in Rust.

```bash
git clone https://github.com/WasmEdge/wasmedge-db-examples
cd wasmedge-db-examples/redis

# Compile the rust code into WASM
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release

# Execute Redis command against a Redis instance at redis://localhost/
wasmedge --env ""REDIS_URL=redis://localhost/"" target/wasm32-wasi/release/wasmedge-redis-client-examples.wasm
```

## Configuration

In order to compile the `redis` and `tokio` crates, we will need to apply patches to add WasmEdge-specific socket APIs to those crates in `Cargo.toml`.

```rust
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }

[dependencies]
anyhow = ""1.0""
chrono = { version = ""0.4"", features = [""serde""] }
tokio = { version = ""1"", features = [""full""] }
redis = { version = ""0.25.4"", default-features = false, features = [
    ""tokio-comp"",
] }
```

## Code explanation

The following program uses the `redis` crate to access a Redis server through its connection URL.
It gets the current time, saves the timestamp object to the Redis server, and then reads it back for
display on the console.

```rust
#[tokio::main(flavor = ""current_thread"")]
async fn main() -> Result<()> {
    // connect to redis
    let client = redis::Client::open(&*get_url()).unwrap();
    let mut con = client.get_multiplexed_async_connection().await.unwrap();

    let time = format!(""{}"", chrono::Utc::now());
    // throw away the result, just make sure it does not fail
    let _: () = con.set(""current_time"", time).await.unwrap();

    // read back the key and return it.  Because the return value
    // from the function is a result for String, this will automatically
    // convert into one.
    let value: String = con.get(""current_time"").await.unwrap();
    println!(""Successfully GET `time`: {}"", value);

    Ok(())
}
```

","**Summary**

The provided code is a Redis driver example written in Rust, designed to be executed within the WasmEdge environment. It utilizes the `redis` crate to interact with a Redis server and performs basic operations such as setting and getting values from the server.

**Key Components**

1. **Redis Connection**: The code establishes a connection to a Redis server using the `Client::open` method.
2. **Setting Values**: It uses the `set` method to store a timestamp value in the Redis server under the key ""current_time"".
3. **Getting Values**: The code retrieves the stored value from the Redis server using the `get` method and prints it to the console.

**Potential Issues or Areas for Improvement**

1. **Error Handling**: While the code uses `unwrap()` to handle potential errors, this is generally discouraged in production code. Consider using proper error handling techniques such as `Result` and `Error` types.
2. **Code Organization**: The example mixes Redis-specific operations with general-purpose Rust programming concepts (e.g., string formatting). Consider separating these concerns into different modules or functions for better modularity.
3. **Dependency Management**: As mentioned in the code, certain dependencies need to be patched to work with WasmEdge. This could lead to maintenance and compatibility issues over time."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/redis_driver.md,"---
sidebar_position: 3
---

# Redis driver

WasmEdge provides a Redis driver for Rust developers, enabling developers to build database applications in Rust and then running in WasmEdge.

<!-- prettier-ignore -->
:::note
Before we start, [you need to have Rust and WasmEdge installed](../setup.md).
Make sure that you read the [special notes on networking apps](../setup#special-notes) especially if you are compiling Rust programs on a Mac.
:::

## Run the example

The [wasmedge-db-example/redis](https://github.com/WasmEdge/wasmedge-db-examples/tree/main/redis) is a Redis connector example written in Rust.

```bash
git clone https://github.com/WasmEdge/wasmedge-db-examples
cd wasmedge-db-examples/redis

# Compile the rust code into WASM
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release

# Execute Redis command against a Redis instance at redis://localhost/
wasmedge --env ""REDIS_URL=redis://localhost/"" target/wasm32-wasi/release/wasmedge-redis-client-examples.wasm
```

## Configuration

In order to compile the `redis` and `tokio` crates, we will need to apply patches to add WasmEdge-specific socket APIs to those crates in `Cargo.toml`.

```rust
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }

[dependencies]
anyhow = ""1.0""
chrono = { version = ""0.4"", features = [""serde""] }
tokio = { version = ""1"", features = [""full""] }
redis = { version = ""0.25.4"", default-features = false, features = [
    ""tokio-comp"",
] }
```

## Code explanation

The following program uses the `redis` crate to access a Redis server through its connection URL.
It gets the current time, saves the timestamp object to the Redis server, and then reads it back for
display on the console.

```rust
#[tokio::main(flavor = ""current_thread"")]
async fn main() -> Result<()> {
    // connect to redis
    let client = redis::Client::open(&*get_url()).unwrap();
    let mut con = client.get_multiplexed_async_connection().await.unwrap();

    let time = format!(""{}"", chrono::Utc::now());
    // throw away the result, just make sure it does not fail
    let _: () = con.set(""current_time"", time).await.unwrap();

    // read back the key and return it.  Because the return value
    // from the function is a result for String, this will automatically
    // convert into one.
    let value: String = con.get(""current_time"").await.unwrap();
    println!(""Successfully GET `time`: {}"", value);

    Ok(())
}
```

","**Summary**

This code is a Redis driver for Rust developers, enabling them to build database applications in Rust and then run it on WasmEdge. The provided example demonstrates how to compile a Rust program that interacts with a Redis instance using the `redis` crate.

**Key Components**

1. **Redis Driver**: A Redis driver is a library or module that allows Rust programs to interact with a Redis instance.
2. **WasmEdge**: WasmEdge is an execution environment for WebAssembly (WASM) modules, allowing Rust code to run on different platforms.
3. **Rust Code Example**: The provided example is a simple Rust program that connects to a Redis instance, sets a key-value pair, and then reads the value back.

**Potential Issues**

1. **Networking Requirements**: The code requires the `redis` crate and WasmEdge installed on the system, as well as the ability to compile Rust programs.
2. **Special Notes for Networking Apps**: If compiling Rust programs on a Mac, special notes regarding networking applications should be followed.
3. **Patched Crates**: To compile the `redis` and `tokio` crates, patches need to be applied to add WasmEdge-specific socket APIs.

**Areas for Improvement**

1. **Error Handling**: The code does not handle errors robustly; in a production environment, error handling mechanisms should be implemented.
2. **Code Optimization**: The provided example is a simple demonstration of how to use the `redis` crate with WasmEdge. Optimizing the code for performance and readability would make it more suitable for a production environment.
3. **Documentation**: While the documentation provided is helpful, additional explanations or examples might be necessary to fully understand how to use the Redis driver with WasmEdge."
docs/contribute/source/os/riscv64.md,"---
sidebar_position: 6
---

# Build on RISC-V 64

## Prepare the Environment

This tutorial is based on Ubuntu 22.04 host, and WasmEdge uses the [RISCV-Lab](https://gitee.com/tinylab/riscv-lab), which provides Ubuntu 22.04 system with riscv64 architecture. Here users can use their riscv64 environment.

### Install and run RISCV-Lab

```bash
git clone https://gitee.com/tinylab/cloud-lab.git
cd cloud-lab
LOGIN=bash tools/docker/run riscv-lab
```

Note that it will take a long time to pull the image here.

## Build WasmEdge

### Get Source code

```bash
ubuntu@riscv-lab:/labs/riscv-lab$ git clone https://github.com/WasmEdge/WasmEdge.git
ubuntu@riscv-lab:/labs/riscv-lab$ cd WasmEdge
```

### Dependencies

WasmEdge requires LLVM 12 at least and you may need to install the following dependencies yourself.

```bash
ubuntu@riscv-lab:/labs/riscv-lab$ sudo apt-get update
ubuntu@riscv-lab:/labs/riscv-lab$ sudo apt install -y software-properties-common cmake
ubuntu@riscv-lab:/labs/riscv-lab$ sudo apt install -y llvm-12-dev liblld-12-dev
```

### Compile

Please refer to [here](../build_from_src.md#cmake-building-options) for the descriptions of all CMake options.

```bash
ubuntu@riscv-lab:/labs/riscv-lab$ cd WasmEdge
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge$ mkdir -p build && cd build
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ cmake -DCMAKE_BUILD_TYPE=Release .. && make -j
```

## Test

### Execute the wasmedge tool

For the pure WebAssembly, the `wasmedge` CLI tool will execute it in interpreter mode.

```bash
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ sudo make install
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ cd ../examples/wasm
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge -v
wasmedge version 0.12.0-alpha.1-13-g610cc21f
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge --reactor fibonacci.wasm fib 10
89
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge --reactor add.wasm add 2 2
4
```

### Execute wasmedge compile

To improve the performance, the `wasmedge compile` can compile WebAssembly into native machine code. After compiling with the `wasmedge compile` AOT compiler, the wasmedge tool can execute the WASM in AOT mode, which is much faster.

```bash
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge compile fibonacci.wasm fibonacci_aot.wasm
[2023-02-01 22:39:15.807] [info] compile start
[2023-02-01 22:39:15.857] [info] verify start
[2023-02-01 22:39:15.866] [info] optimize start
[2023-02-01 22:39:16.188] [info] codegen start
[2023-02-01 22:39:16.403] [info] output start
[2023-02-01 22:39:16.559] [info] compile done
[2023-02-01 22:39:16.565] [info] output start
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ time wasmedge --reactor fibonacci_aot.wasm fib 30
1346269
real    0m0.284s
user    0m0.282s
sys     0m0.005s
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ time wasmedge --reactor fibonacci.wasm fib 30
1346269
real    0m1.814s
user    0m1.776s
sys     0m0.016s
```
","**Summary**

This document provides instructions on how to build and run WasmEdge, a WebAssembly runtime, on RISC-V 64 architecture. The process involves:

1. Preparing the environment using RISCV-Lab
2. Cloning the WasmEdge repository
3. Installing dependencies (LLVM 12, CMake)
4. Building WasmEdge using CMake and Make
5. Testing the built binary

**Key Components**

* RISCV-Lab: A Ubuntu 22.04 system with riscv64 architecture provided by Gitee.
* WasmEdge: A WebAssembly runtime.
* LLVM 12: A compiler infrastructure for building and optimizing WasmEdge.
* CMake: A build system generator.
* Make: A build automation tool.

**Potential Issues or Areas for Improvement**

1. **Slow build process**: The build process involves cloning the repository, installing dependencies, and building WasmEdge. This can take a significant amount of time.
2. **Lack of detailed instructions**: Some steps are not explicitly mentioned, such as how to configure CMake options.
3. **Inadequate error handling**: If errors occur during the build or run process, they may be difficult to diagnose.
4. **Missing documentation on dependencies**: The document assumes familiarity with LLVM and CMake, but does not provide detailed information on these dependencies.

**Suggestions for Improvement**

1. Provide more detailed instructions for each step, including any specific configurations required.
2. Consider using a build tool like `bazel` or `meson` which can automate the build process and reduce the risk of errors.
3. Add error handling mechanisms to ensure that errors are caught and reported in a useful way.
4. Provide additional documentation on dependencies, such as LLVM and CMake, to help users understand their role in building WasmEdge.
5. Consider providing pre-built binaries for different platforms to simplify the build process."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/riscv64.md,"---
sidebar_position: 6
---

# Build on RISC-V 64

## Prepare the Environment

This tutorial is based on Ubuntu 22.04 host, and WasmEdge uses the [RISCV-Lab](https://gitee.com/tinylab/riscv-lab), which provides Ubuntu 22.04 system with riscv64 architecture. Here users can use their riscv64 environment.

### Install and run RISCV-Lab

```bash
git clone https://gitee.com/tinylab/cloud-lab.git
cd cloud-lab
LOGIN=bash tools/docker/run riscv-lab
```

Note that it will take a long time to pull the image here.

## Build WasmEdge

### Get Source code

```bash
ubuntu@riscv-lab:/labs/riscv-lab$ git clone https://github.com/WasmEdge/WasmEdge.git
ubuntu@riscv-lab:/labs/riscv-lab$ cd WasmEdge
```

### Dependencies

WasmEdge requires LLVM 12 at least and you may need to install the following dependencies yourself.

```bash
ubuntu@riscv-lab:/labs/riscv-lab$ sudo apt-get update
ubuntu@riscv-lab:/labs/riscv-lab$ sudo apt install -y software-properties-common cmake
ubuntu@riscv-lab:/labs/riscv-lab$ sudo apt install -y llvm-12-dev liblld-12-dev
```

### Compile

Please refer to [here](../build_from_src.md#cmake-building-options) for the descriptions of all CMake options.

```bash
ubuntu@riscv-lab:/labs/riscv-lab$ cd WasmEdge
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge$ mkdir -p build && cd build
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ cmake -DCMAKE_BUILD_TYPE=Release .. && make -j
```

## Test

### Execute the wasmedge tool

For the pure WebAssembly, the `wasmedge` CLI tool will execute it in interpreter mode.

```bash
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ sudo make install
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ cd ../examples/wasm
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge -v
wasmedge version 0.12.0-alpha.1-13-g610cc21f
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge --reactor fibonacci.wasm fib 10
89
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge --reactor add.wasm add 2 2
4
```

### Execute wasmedge compile

To improve the performance, the `wasmedge compile` can compile WebAssembly into native machine code. After compiling with the `wasmedge compile` AOT compiler, the wasmedge tool can execute the WASM in AOT mode, which is much faster.

```bash
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge compile fibonacci.wasm fibonacci_aot.wasm
[2023-02-01 22:39:15.807] [info] compile start
[2023-02-01 22:39:15.857] [info] verify start
[2023-02-01 22:39:15.866] [info] optimize start
[2023-02-01 22:39:16.188] [info] codegen start
[2023-02-01 22:39:16.403] [info] output start
[2023-02-01 22:39:16.559] [info] compile done
[2023-02-01 22:39:16.565] [info] output start
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ time wasmedge --reactor fibonacci_aot.wasm fib 30
1346269
real    0m0.284s
user    0m0.282s
sys     0m0.005s
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ time wasmedge --reactor fibonacci.wasm fib 30
1346269
real    0m1.814s
user    0m1.776s
sys     0m0.016s
```
","**Summary**

The provided code is a tutorial on how to build and run WasmEdge, a WebAssembly runtime engine, on a RISC-V 64 architecture. The tutorial assumes an Ubuntu 22.04 host environment and uses the RISCV-Lab system, which provides a pre-configured Ubuntu 22.04 system with riscv64 architecture.

**Key Components**

1. **Preparation**: The tutorial starts by cloning the WasmEdge repository and preparing the build environment.
2. **Build WasmEdge**: The user is instructed to install dependencies (LLVM 12, CMake) and compile WasmEdge using CMake.
3. **Test**: The tutorial provides examples on how to execute WebAssembly programs with the `wasmedge` CLI tool in interpreter mode and AOT (Ahead-of-Time) compilation mode.

**Potential Issues**

1. **Time-consuming build process**: The compilation process can take a long time, especially for large projects like WasmEdge.
2. **Dependency management**: The tutorial assumes that users have already installed LLVM 12, CMake, and other dependencies. In practice, managing dependencies can be challenging, and users may encounter issues if these dependencies are not installed correctly.
3. **CMake build options**: The tutorial mentions CMake build options but does not provide detailed explanations or examples. This might make it difficult for users to customize the build process.

**Areas for Improvement**

1. **Provide more detailed instructions**: The tutorial could benefit from more detailed instructions, especially when it comes to installing dependencies and managing them.
2. **Improve documentation**: The CMake build options section should include explanations of each option and examples of how to use them.
3. **Test cases**: Adding more test cases to verify the correctness of the built WasmEdge runtime engine would help ensure that users can rely on the instructions provided.

**Additional Recommendations**

1. **Consider using a Docker image**: Using a pre-configured Docker image for building WasmEdge could simplify the build process and reduce dependencies.
2. **Provide troubleshooting guides**: A dedicated section on troubleshooting common issues, such as dependency conflicts or build errors, would be helpful in case users encounter problems during the build process."
docs/contribute/source/plugin/rusttls.md,"---
sidebar_position: 8
---

# (DEPRECATED after `0.14.0`) Build with Rustls Plug-in

<!-- prettier-ignore -->
:::note
This plug-in has been deprecated after WasmEdge `0.14.0` because the `rustls` is replaced by [`reqwest`](../../../develop/rust/http_service/client.md#the-reqwest-api).
:::

The WasmEdge Rustls plug-in is a replacement for the OpenSSL plug-in in WasmEdge. It provides a Rust-friendly interface to the Rustls library, which is a modern, fast, and more secure alternative to OpenSSL.

Here's a step-by-step guide on how to build the WasmEdge Rustls plug-in:

## Prerequisites

Ensure the following dependencies are installed on your system:

- Rust: You can install it from the [official website](https://www.rust-lang.org/tools/install).
- CMake: Minimum version 3.12. Install it from the [official website](https://cmake.org/download/).

## Clone the WasmEdge Repository

First, clone the WasmEdge repository from GitHub:

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
```

## Navigate to the Rustls Plug-in Directory

Navigate to the `wasmedge_rustls` directory within the cloned repository:

```bash
cd WasmEdge/plugins/wasmedge_rustls
```

## Build the Plug-in

Now you can build the Rustls plug-in. Run the following command:

```bash
cargo build --release
```

This command builds the plug-in in release mode. The compiled binary will be located in the `target/release` directory.

## Install the Plug-in

To install the plug-in, you can use the `cargo install` command:

```bash
cargo install --path .
```

This command will install the built plug-in into your Rust binary directory.

## Usage

To use the plug-in with WasmEdge, you need to specify it when starting the WasmEdge runtime:

```bash
wasmedge --dir .:. --reactor --rustls_plugin target/release/libwasmedge_rustls.so your_wasm_file.wasm
```

Replace `your_wasm_file.wasm` with the path to your WebAssembly file. The `--rustls_plugin` flag specifies the path to the Rustls plug-in.

That's it! You have successfully built and installed the WasmEdge Rustls plug-in. Please ensure to replace the OpenSSL plug-in with the Rustls plug-in in your WasmEdge runtime configuration if you were previously using OpenSSL.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_rustls).
","**Summary**

The provided code is a guide on how to build and install the WasmEdge Rustls plug-in, which provides a modern and secure alternative to OpenSSL for use with the WasmEdge runtime. The plug-in has been deprecated after version 0.14.0 of WasmEdge in favor of the reqwest library.

**Key Components**

1. **Prerequisites**: The guide requires the installation of Rust and CMake on the system.
2. **Cloning the WasmEdge Repository**: The user is instructed to clone the WasmEdge repository from GitHub.
3. **Navigating to the Rustls Plug-in Directory**: The user navigates to the `wasmedge_rustls` directory within the cloned repository.
4. **Building the Plug-in**: The user builds the plug-in using the `cargo build --release` command.
5. **Installing the Plug-in**: The user installs the built plug-in using the `cargo install --path .` command.
6. **Usage**: The user specifies the Rustls plug-in when starting the WasmEdge runtime.

**Potential Issues or Areas for Improvement**

1. **Deprecation Warning**: The guide should be updated to reflect that the Rustls plug-in has been deprecated after version 0.14.0 of WasmEdge.
2. **Outdated Instructions**: Some steps in the guide may be outdated, and it's recommended to update them to match the current version of WasmEdge.
3. **Lack of Error Handling**: The guide does not provide instructions on how to handle errors that may occur during the build or installation process.
4. **Missing Information on reqwest Library**: Since reqwest has replaced Rustls, additional information should be provided on how to use the reqwest library with WasmEdge runtime.

**Code Quality**

The provided code is a guide and not actual code. However, if we were to translate this guide into a set of instructions, here are some suggestions:

1. **Use clear and concise language**: Avoid using technical jargon or overly complex sentences that may confuse the user.
2. **Provide step-by-step instructions**: Break down each step into smaller, manageable tasks that users can follow easily.
3. **Use proper formatting**: Use headings, bullet points, and whitespace to make the guide easy to read and understand.
4. **Include error handling and troubleshooting tips**: Provide users with guidance on how to handle errors or troubleshoot common issues."
docs/contribute/source/docker.md,"---
sidebar_position: 2
---

# Docker Images for Building WasmEdge

WasmEdge supports a wide range of Linux distributions dated back to 2014. The official release contains statically linked binaries and libraries for older Linux systems.

The table below shows build targets in WasmEdge's official release packages.

Developers can use the `docker pull wasmedge/wasmedge:{tag_name}` command to pull the docker image for WasmEdge building.

| tag name | arch | based operating system | LLVM version | ENVs | compatibility | comments |
| --- | --- | --- | --- | --- | --- | --- |
| `latest` | x86_64 | Ubuntu 22.04 LTS | 15.0.7 | CC=clang, CXX=clang++ | Ubuntu 22.04+ | This is for CI, will always use the latest Ubuntu LTS release |
| `ubuntu-build-gcc` | x86_64 | Ubuntu 22.04 LTS | 15.0.7 | CC=gcc, CXX=g++ | Ubuntu 22.04+ | This is for CI, will always use the latest Ubuntu LTS release |
| `ubuntu-build-clang` | x86_64 | Ubuntu 22.04 LTS | 15.0.7 | CC=clang, CXX=clang++ | Ubuntu 22.04+ | This is for CI, will always use the latest Ubuntu LTS release |
| `ubuntu2004_x86_64` | x86_64 | Ubuntu 20.04 LTS | 10.0.0 | CC=gcc, CXX=g++ | Ubuntu 20.04+ | This is for developers who familiar with Ubuntu 20.04 LTS release |
| `ubuntu2104_armv7l` | armhf | Ubuntu 21.04 | 12.0.0 | CC=gcc, CXX=g++ | Ubuntu 21.04+ | This is for armhf release |
| `manylinux2014_x86_64` | x86_64 | CentOS 7, 7.9.2009 | 16.0.5 | CC=gcc, CXX=g++ | Ubuntu 16.04+, CentOS 7+ | This is for developers who familiar with CentOS on x86_64 architecture |
| `manylinux2014_aarch64` | aarch64 | CentOS 7, 7.9.2009 | 16.0.5 | CC=gcc, CXX=g++ | Ubuntu 16.04+, CentOS 7+ | This is for developers who familiar with CentOS on aarch64 architecture |
","**Summary**

The provided code snippet is from a Markdown file named `docker.md` located in the `docs/contribute/source` directory. It describes Docker images for building WasmEdge, a WebAssembly runtime engine. The document outlines various Docker tags that can be used to pull and build WasmEdge images with different configurations.

**Purpose**

The purpose of this code is to provide developers with a list of available Docker images for building WasmEdge, along with their respective characteristics such as architecture, based operating system, LLVM version, environment variables, compatibility, and comments.

**Key Components**

1. **Docker Tags**: The table lists various Docker tags that can be used to pull the corresponding WasmEdge images.
2. **Architectures**: Each tag specifies a specific architecture (e.g., x86_64, armhf, aarch64).
3. **Based Operating Systems**: The table shows the base operating system for each image (e.g., Ubuntu 22.04 LTS, CentOS 7).
4. **LLVM Versions**: Each image has an associated LLVM version.
5. **Environment Variables**: Some images specify environment variables (e.g., `CC=clang`, `CXX=clang++`).
6. **Compatibility**: The table indicates the minimum compatible operating system versions for each image.

**Potential Issues or Areas for Improvement**

1. **Readability**: The table layout and formatting could be improved for better readability.
2. **Consistency**: The formatting of comments in the last two rows of the table seems inconsistent with the rest of the table.
3. **Error Handling**: It is unclear how developers should handle errors when pulling or building images using these tags.
4. **Documentation**: Additional documentation on each tag's specific requirements and configurations could be beneficial.

Overall, this code snippet provides a useful reference for developers interested in building WasmEdge with specific configurations. However, it could benefit from some improvements to enhance readability and usability."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/docker.md,"---
sidebar_position: 2
---

# Docker Images for Building WasmEdge

WasmEdge supports a wide range of Linux distributions dated back to 2014. The official release contains statically linked binaries and libraries for older Linux systems.

The table below shows build targets in WasmEdge's official release packages.

Developers can use the `docker pull wasmedge/wasmedge:{tag_name}` command to pull the docker image for WasmEdge building.

| tag name | arch | based operating system | LLVM version | ENVs | compatibility | comments |
| --- | --- | --- | --- | --- | --- | --- |
| `latest` | x86_64 | Ubuntu 22.04 LTS | 15.0.7 | CC=clang, CXX=clang++ | Ubuntu 22.04+ | This is for CI, will always use the latest Ubuntu LTS release |
| `ubuntu-build-gcc` | x86_64 | Ubuntu 22.04 LTS | 15.0.7 | CC=gcc, CXX=g++ | Ubuntu 22.04+ | This is for CI, will always use the latest Ubuntu LTS release |
| `ubuntu-build-clang` | x86_64 | Ubuntu 22.04 LTS | 15.0.7 | CC=clang, CXX=clang++ | Ubuntu 22.04+ | This is for CI, will always use the latest Ubuntu LTS release |
| `ubuntu2004_x86_64` | x86_64 | Ubuntu 20.04 LTS | 10.0.0 | CC=gcc, CXX=g++ | Ubuntu 20.04+ | This is for developers who familiar with Ubuntu 20.04 LTS release |
| `ubuntu2104_armv7l` | armhf | Ubuntu 21.04 | 12.0.0 | CC=gcc, CXX=g++ | Ubuntu 21.04+ | This is for armhf release |
| `manylinux2014_x86_64` | x86_64 | CentOS 7, 7.9.2009 | 16.0.5 | CC=gcc, CXX=g++ | Ubuntu 16.04+, CentOS 7+ | This is for developers who familiar with CentOS on x86_64 architecture |
| `manylinux2014_aarch64` | aarch64 | CentOS 7, 7.9.2009 | 16.0.5 | CC=gcc, CXX=g++ | Ubuntu 16.04+, CentOS 7+ | This is for developers who familiar with CentOS on aarch64 architecture |
","**Summary**

The code appears to be a Markdown document that describes the available Docker images for building WasmEdge, a web assembly runtime. The document provides a table of various Docker images, each with its own configuration and compatibility details.

**Key Components**

1. **Table**: A table showing the available Docker images, including their tag names, architecture, base operating system, LLVM version, environment variables (ENVs), compatibility, and comments.
2. **Tag Names**: The unique identifier for each Docker image, such as `latest`, `ubuntu-build-gcc`, or `manylinux2014_x86_64`.
3. **Architecture**: The CPU architecture supported by each Docker image, such as x86_64 or aarch64.
4. **Base Operating System**: The Linux distribution used as the base for each Docker image, such as Ubuntu 22.04 LTS or CentOS 7.

**Functionality**

Developers can use the `docker pull` command to download and install the desired Docker image. For example, they can run `docker pull wasmedge/wasmedge:latest` to obtain the latest WasmEdge Docker image.

**Potential Issues/ Areas for Improvement**

1. **Table formatting**: The table is quite long and may not be easily readable on smaller screens.
2. **Image description**: Some of the tag names are quite generic, making it difficult to understand their purpose without reading the comments.
3. **Versioning**: The document does not explicitly mention how often the Docker images are updated or which versions of WasmEdge they support.

Overall, this document provides a useful summary of the available WasmEdge Docker images and their characteristics. However, some minor improvements could make it even more readable and maintainable."
docs/contribute/source/plugin/wasi_logging.md,"---
sidebar_position: 1
---

# Build WasmEdge With WASI-Logging Plug-in

WASI-Logging allows WebAssembly applications to log messages in a standardized way. This becomes particularly helpful when debugging applications or understanding the flow of execution within them. The WASI-Logging plug-in is designed to be straightforward to use, enabling developers to focus more on their application logic and less on logging mechanics.

## Prerequisites

The prerequisite of the Wasi-Logging plug-in is the same as the WasmEdge building environment on the [Linux](../os/linux.md) and [MacOS](../os/macos.md) platforms.

## Build WasmEdge with WASI-Logging Plug-in

To enable the WASI-Logging Plug-in, developers need to build the WasmEdge from source with the cmake option `-DWASMEDGE_PLUGIN_WASI_LOGGING=ON`.

```bash
cd <path/to/your/wasmedge/source/folder>
mkdir -p build && cd build
cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_LOGGING=ON .. && make -j
# For the WASI-Logging plug-in, you should install this project.
cmake --install .
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-Logging plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (`/usr/local/lib/wasmedge`, or the built plug-in path `build/plugins/wasi_logging`) to try to fix this issue. You should find `libwasmedgePluginWasiLogging.so` in your `WASMEDGE_PLUGIN_PATH`
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-Logging plugin under `/usr/local/lib/wasmedge/libwasmedgePluginWasiLogging.so` after installation.

## Loading WASI-Logging Plug-in

If the built `wasmedge` CLI tool cannot find the WASI-Logging plug-in, set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_logging/`) to resolve this issue 1.

After installation, the `wasmedge` runtime will be located under `/usr/local/bin` and the WASI-Logging plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiLogging.so`.

## Using WASI-Logging in Your Applications

You can use the WASI-Logging plug-in in your WebAssembly applications to log messages in a standardized way.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/examples/plugin/wasi-logging).
","**Summary**

This document outlines the steps to build WasmEdge with the WASI-Logging plug-in, which enables WebAssembly applications to log messages in a standardized way. The WASI-Logging plug-in is designed to be easy to use and helps developers focus on application logic rather than logging mechanics.

**Key Components**

1. **Prerequisites**: The same as the WasmEdge building environment on Linux and MacOS platforms.
2. **Build WasmEdge with WASI-Logging Plug-in**:
	* Create a build folder and navigate into it.
	* Run `cmake` with `-DWASMEDGE_PLUGIN_WASI_LOGGING=ON` option to enable the plug-in.
	* Run `make -j` to build WasmEdge with the plug-in.
3. **Loading WASI-Logging Plug-in**:
	* Set `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path if the built `wasmedge` CLI tool cannot find the plug-in.
4. **Using WASI-Logging in Your Applications**:
	* Use the WASI-Logging plug-in in your WebAssembly applications to log messages in a standardized way.

**Potential Issues or Areas for Improvement**

1. The document assumes a Linux or MacOS platform, but it's not clear if the WASI-Logging plug-in works on other platforms.
2. The `WASMEDGE_PLUGIN_PATH` environment variable is set to resolve an issue with the built `wasmedge` CLI tool not finding the WASI-Logging plug-in, but this could be a problem for users who don't know how to set environment variables.
3. The document doesn't provide clear instructions on how to use the WASI-Logging plug-in in WebAssembly applications.
4. There is no information on how to debug issues with the WASI-Logging plug-in or where to find more resources if needed.

**Recommendations**

1. Add more information on platform support and troubleshooting steps for issues with the built `wasmedge` CLI tool.
2. Provide clear instructions on how to use the WASI-Logging plug-in in WebAssembly applications, including examples.
3. Consider adding a FAQ section or links to resources that can help users resolve common issues with the WASI-Logging plug-in."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_logging.md,"---
sidebar_position: 1
---

# Build WasmEdge With WASI-Logging Plug-in

WASI-Logging allows WebAssembly applications to log messages in a standardized way. This becomes particularly helpful when debugging applications or understanding the flow of execution within them. The WASI-Logging plug-in is designed to be straightforward to use, enabling developers to focus more on their application logic and less on logging mechanics.

## Prerequisites

The prerequisite of the Wasi-Logging plug-in is the same as the WasmEdge building environment on the [Linux](../os/linux.md) and [MacOS](../os/macos.md) platforms.

## Build WasmEdge with WASI-Logging Plug-in

To enable the WASI-Logging Plug-in, developers need to build the WasmEdge from source with the cmake option `-DWASMEDGE_PLUGIN_WASI_LOGGING=ON`.

```bash
cd <path/to/your/wasmedge/source/folder>
mkdir -p build && cd build
cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_LOGGING=ON .. && make -j
# For the WASI-Logging plug-in, you should install this project.
cmake --install .
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-Logging plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (`/usr/local/lib/wasmedge`, or the built plug-in path `build/plugins/wasi_logging`) to try to fix this issue. You should find `libwasmedgePluginWasiLogging.so` in your `WASMEDGE_PLUGIN_PATH`
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-Logging plugin under `/usr/local/lib/wasmedge/libwasmedgePluginWasiLogging.so` after installation.

## Loading WASI-Logging Plug-in

If the built `wasmedge` CLI tool cannot find the WASI-Logging plug-in, set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_logging/`) to resolve this issue 1.

After installation, the `wasmedge` runtime will be located under `/usr/local/bin` and the WASI-Logging plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiLogging.so`.

## Using WASI-Logging in Your Applications

You can use the WASI-Logging plug-in in your WebAssembly applications to log messages in a standardized way.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/examples/plugin/wasi-logging).
","**Summary**

The code document describes how to build WasmEdge with the WASI-Logging plug-in, a standardized way for WebAssembly applications to log messages. The prerequisites are the same as building WasmEdge on Linux or MacOS platforms. To enable the plug-in, developers need to build WasmEdge from source using CMake with the `-DWASMEDGE_PLUGIN_WASI_LOGGING=ON` option.

**Key Components**

1. **WASI-Logging Plug-in**: A standardized way for WebAssembly applications to log messages.
2. **CMake Option**: `-DWASMEDGE_PLUGIN_WASI_LOGGING=ON` used to enable the plug-in during WasmEdge build process.
3. **Build Process**: The code document describes how to build WasmEdge with the WASI-Logging plug-in using CMake and the `make` command.
4. **Installation**: After building, the code document explains how to install the plug-in and set environment variables (`WASMEDGE_PLUGIN_PATH`) for correct functioning.

**Potential Issues or Areas for Improvement**

1. **Complexity of Build Process**: The build process described may be complex for developers without prior experience with CMake and WasmEdge.
2. **Lack of Error Handling**: The document does not provide information on how to handle errors during the build or installation process.
3. **Inconsistent Formatting**: The code document uses inconsistent formatting styles, making it harder to read and understand.
4. **Limited Information on Troubleshooting**: The document provides limited information on troubleshooting common issues related to building and installing the WASI-Logging plug-in.

**Suggestions for Improvement**

1. **Simplify Build Process Documentation**: Break down the build process into smaller, more manageable steps with clear explanations.
2. **Provide Error Handling Guidance**: Offer guidance on how to handle errors during the build or installation process.
3. **Standardize Formatting Styles**: Use consistent formatting styles throughout the document to improve readability.
4. **Enhance Troubleshooting Information**: Provide more detailed information on common issues and solutions related to building and installing the WASI-Logging plug-in."
src/pages/talks.md,"import ReactPlayer from 'react-player/lazy'

# WasmEdge Talks

## 2023


### December 6th

####  Optimizing Microservices with WebAssembly and Linux Containers: Exploring Hybrid Container Architectures — Miley Fu, WasmEdge

<ReactPlayer url='https://youtu.be/YJWOpNsULiA?si=8UcWubtgcvHgMNdY' />

---

### December 5th

#### Lightweight and High-Performance Microservices with Dapr and WasmEdge — Michael Yuan, WasmEdge

<ReactPlayer url='https://youtu.be/RkEaz-MPR8k?si=QgbduonqUhZu3Tc_' />

---

### December 5th

#### Efficient and Cross-Platform AI Inference Apps Using Rust and Wasm — Michael Yuan, WasmEdge

<ReactPlayer url='https://youtu.be/HI2w_Qw06YE?si=tZcJX9GYUpn7Qeet' />

---

### September 

#### Develop Wasm Applications with Docker - Angel M De Miguel Meana, VMware & Justin Cormack, Docker

<ReactPlayer url='https://youtu.be/xPO3-TOZxW0?si=A-G3DP-ejMxJflwm' />

---

### May 10th

#### Exotic Runtime Targets: Ruby and Wasm on Kubernetes and GitOps Delivery Pipelines by Kingdon Barrett, Weaveworks

<ReactPlayer url='https://youtu.be/EsAuJmHYWgI?si=KPR96Lo-FyvSaumz' />

---

### May 11th

#### Microservices and WASM, Are We There Yet? by Will Christensen, Defense Unicorns and Kingdon Barrett, Weaveworks

<ReactPlayer url='https://youtu.be/2eTjGFbOz5E?si=Qg7EHyK-vknCpLPm' />

---

### April 21st

#### Create and Deploy a Lightweight Microservice in WebAssembly - Tai Hung-Ying & Vivian Hu, Second State

<ReactPlayer url='https://youtu.be/bBZf23f_sVg?si=2Jsao0ynI5dEitZs' />

---

### March 16th

#### Introduction to WebAssembly (WASM) with Rust and WASMEdge

<ReactPlayer url='https://www.youtube.com/live/shy9DYpoHtQ' />

---

### January 24th

#### Running WebAssembly Applications on Kubernetes with WasmEdge | Mirantis Labs - Tech Talks

<ReactPlayer url='https://youtu.be/--T-JFFNGlE' />

---

## 2022

#### JavaScript in WebAssembly? Why and How - Michael Yuan, WasmEdge

<ReactPlayer url='https://youtu.be/UogNdp-0Bgs' />

---

#### Lightning Talk: Lightweight Dapr Microservices In WebAssembly - Vivian Hu, Second State

<ReactPlayer url='https://youtu.be/RQYDCEF9c8c' />

---

#### With WasmEdge to New Shores - Max Körbächer, Liquid Reply

<ReactPlayer url='https://youtu.be/LgZIPzc_IeQ' />

---

#### Running JavaScript, Python, and Ruby in WebAssembly - Michael Yuan, Second State/WasmEdge

<ReactPlayer url='https://youtu.be/TBs0MYmtgGI' />

---

## 2021

#### Introduction to WasmEdge, A Cloud-native WebAssembly Runtime - Michael Yuan, WasmEdge

<ReactPlayer url='https://youtu.be/9LpvgWaG_T0' />
","**Summary:**

This is an HTML file named `talks.md` located in the `src/pages` directory. It contains a list of talks related to WebAssembly (WASM) and WasmEdge, a cloud-native WASM runtime. The talks are categorized by year, with each talk having a title, speaker(s), and a link to a YouTube video using the `<ReactPlayer>` component.

**Key Components:**

1. **Talks List:** A list of talks is presented in chronological order by year.
2. **Talk Card:** Each talk card consists of:
	* Title
	* Speaker(s)
	* Link to YouTube video using `ReactPlayer` component
3. **ReactPlayer Component:** Used to embed YouTube videos into the page.

**Potential Issues or Areas for Improvement:**

1. **Code organization:** The talks list could be extracted into a separate component for better reusability.
2. **Error handling:** If any of the YouTube URLs are invalid, the ReactPlayer component will throw an error.
3. **SEO optimization:** While the page is generated by a markdown file, it's essential to optimize it for search engines (e.g., add meta tags, descriptions).
4. **Accessibility:** Consider adding ARIA attributes and ensuring that the page follows Web Content Accessibility Guidelines (WCAG).

**Code Suggestions:**

To improve maintainability and scalability, consider extracting talks data into a separate JSON file or database and then rendering them dynamically using JavaScript.

```javascript
// Extract talks list from talks.json (example)
import talksData from '../data/talks.json';

const TalksList = () => {
  return (
    <div>
      {talksData.map((talk) => (
        <TalkCard key={talk.id} {...talk} />
      ))}
    </div>
  );
};

// Render a single TalkCard component
const TalkCard = ({ title, speaker, url }) => (
  <div>
    <h2>{title}</h2>
    <p>Speaker: {speaker}</p>
    <ReactPlayer url={url} />
  </div>
);
```

This code snippet demonstrates how to separate the talks list and talk card components for better reusability."
docs/develop/deploy/podman.md,"---
sidebar_position: 3
---

# Podman

## Fedora Platform

Fedora is the easiest platform to run the WASM app with container because the crun fedora package has supported WasmEdge as the default runtime. We don't need to make any changes to run WasmEdge apps on fedora platform. If you use other Linux distributions, go to [next section](#other-linux-distributions).

### Install podman and WasmEdge

```bash
sudo dnf -y install podman
sudo dnf -y install wasmedge
```

### Run A simple WASI app on Fedora

Now, we could run wasm apps.

```bash
podman run --rm --annotation module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest /wasi_example_main.wasm 50000000
```

That's it.

## Other Linux distributions

### Prerequisites

1. Install and configure Podman

   Use the following commands to install podman on your system. Here I use Ubuntu as an example. For more different types of podman, please refer to [Podman's installation instruction](https://podman.io/getting-started/installation).

   ```bash
   sudo apt-get -y update
   sudo apt-get -y install podman
   ```

2. [Install WasmEdge](../../start/install.md#install)

3. Build and configure crun with WasmEdge support

   Next, configure and build a `crun` binary with WasmEdge support.

   ```bash
   git clone https://github.com/containers/crun
   cd crun
   ./autogen.sh
   ./configure --with-wasmedge
   make
   sudo make install
   # replace crun (be careful, you may want to do a backup first)
   mv crun $(which crun)
   ```

   Then, you can use `crun -v` to check if crun is installed successfully.

   ```bash
   crun --version
   # Output
   crun version 1.7.2.0.0.0.26-51af
   commit: 51af1448f60b69326cf26e726e14b38fcb253943
   rundir: /run/user/0/crun
   spec: 1.0.0
   +SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +WASM:wasmedge +YAJL
   ```

### Run A simple WASI app

Now, we could run wasm apps.

```bash
podman run --rm --annotation module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest /wasi_example_main.wasm 50000000
```

For more information, you could refer to [crun](../deploy/oci-runtime/crun) chapter.

A great open-source project introduces podman and WASM from a community called [Kwasm](https://github.com/KWasm/podman-wasm). Check it out!
","**Summary**

The provided code is a documentation for deploying and running WebAssembly (WASM) applications using Podman on Fedora and other Linux distributions. It covers the installation of Podman, WasmEdge, and crun with WASM support, as well as how to run a simple WASI app.

**Key Components**

1. **Fedora Platform**: The code provides instructions for installing and running WASM apps on Fedora using the `dnf` package manager.
2. **Other Linux Distributions**: For other Linux distributions (e.g., Ubuntu), the code outlines the installation of Podman, WasmEdge, and crun with WASM support.
3. **Installation Commands**: The code includes shell commands for installing packages, building and configuring crun, and running a simple WASI app.

**Potential Issues or Areas for Improvement**

1. **Dependency Management**: The code assumes that dependencies (e.g., `crun`) are installed manually. Consider using package managers or automation tools to simplify dependency management.
2. **Error Handling**: The code does not handle errors or exceptions, which can lead to unexpected behavior or crashes. Add try-except blocks and error handling mechanisms to improve robustness.
3. **Documentation Organization**: The documentation is fragmented across multiple sections. Consider reorganizing it into a more cohesive structure, such as a tutorial-style guide with step-by-step instructions.
4. **Community Contributions**: The code references the Kwasm community project, which is a great resource for community involvement and collaboration.

**Additional Suggestions**

1. **Use Containerization Tools**: Podman is containerization tool that can be used to run WebAssembly applications in a isolated environment.
2. **Explore Other Runtimes**: Consider using other WASM runtimes (e.g., `wasmtime`) to provide more flexibility and options for developers.
3. **Improve Documentation Style**: Follow consistent documentation style guidelines, such as Markdown or Asciidoc, to improve readability and maintainability.

Overall, the provided code provides a good starting point for deploying and running WASM applications using Podman on various Linux distributions. However, some improvements can be made to enhance its robustness, maintainability, and user experience."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/podman.md,"---
sidebar_position: 3
---

# Podman

## Fedora Platform

Fedora is the easiest platform to run the WASM app with container because the crun fedora package has supported WasmEdge as the default runtime. We don't need to make any changes to run WasmEdge apps on fedora platform. If you use other Linux distributions, go to [next section](#other-linux-distributions).

### Install podman and WasmEdge

```bash
sudo dnf -y install podman
sudo dnf -y install wasmedge
```

### Run A simple WASI app on Fedora

Now, we could run wasm apps.

```bash
podman run --rm --annotation module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest /wasi_example_main.wasm 50000000
```

That's it.

## Other Linux distributions

### Prerequisites

1. Install and configure Podman

   Use the following commands to install podman on your system. Here I use Ubuntu as an example. For more different types of podman, please refer to [Podman's installation instruction](https://podman.io/getting-started/installation).

   ```bash
   sudo apt-get -y update
   sudo apt-get -y install podman
   ```

2. [Install WasmEdge](../../start/install.md#install)

3. Build and configure crun with WasmEdge support

   Next, configure and build a `crun` binary with WasmEdge support.

   ```bash
   git clone https://github.com/containers/crun
   cd crun
   ./autogen.sh
   ./configure --with-wasmedge
   make
   sudo make install
   # replace crun (be careful, you may want to do a backup first)
   mv crun $(which crun)
   ```

   Then, you can use `crun -v` to check if crun is installed successfully.

   ```bash
   crun --version
   # Output
   crun version 1.7.2.0.0.0.26-51af
   commit: 51af1448f60b69326cf26e726e14b38fcb253943
   rundir: /run/user/0/crun
   spec: 1.0.0
   +SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +WASM:wasmedge +YAJL
   ```

### Run A simple WASI app

Now, we could run wasm apps.

```bash
podman run --rm --annotation module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest /wasi_example_main.wasm 50000000
```

For more information, you could refer to [crun](../deploy/oci-runtime/crun) chapter.

A great open-source project introduces podman and WASM from a community called [Kwasm](https://github.com/KWasm/podman-wasm). Check it out!
","**Summary**

The provided code is a Markdown file that documents the process of deploying and running WebAssembly (WASM) apps using Podman on various Linux distributions. The document is divided into two main sections: Fedora Platform and Other Linux Distributions.

**Key Components**

1. **Fedora Platform**: This section provides instructions for installing Podman and WASMEdge, the runtime environment required to run WASM apps.
2. **Other Linux Distributions**: This section outlines the prerequisites and steps to install and configure Podman, WASMEdge, and crun on other Linux distributions (e.g., Ubuntu).
3. **Running a Simple WASI App**: The code snippet at the end of both sections demonstrates how to run a simple WebAssembly app using Podman.

**Potential Issues or Areas for Improvement**

1. **Complexity**: The instructions for installing and configuring crun with WasmEdge support may be overwhelming for users without prior experience.
2. **Distribution-Specific Instructions**: The document assumes the reader is familiar with specific Linux distributions (e.g., Ubuntu, Fedora). Consider adding more general instructions or links to distribution-specific documentation.
3. **Error Handling**: The code snippet for running a simple WASI app does not handle potential errors that may occur during execution.

**Suggestions**

1. **Simplify Installation Instructions**: Break down the installation process into smaller, more manageable steps and provide additional guidance on troubleshooting common issues.
2. **Use Distribution-Agnostic Language**: Where possible, use language that is applicable to multiple Linux distributions (e.g., ""use a package manager like `apt-get` or `dnf`"").
3. **Add Error Handling Mechanisms**: Modify the code snippet to handle potential errors and provide more robust instructions for users who encounter issues while running their WASI apps.

By addressing these areas for improvement, the document can be made more user-friendly and easier to follow for readers without prior experience with Podman or WebAssembly development."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/rusttls.md,"---
sidebar_position: 8
---

# Build with Rustls Plug-in

The WasmEdge Rustls plug-in is a replacement for the OpenSSL plug-in in WasmEdge. It provides a Rust-friendly interface to the Rustls library, which is a modern, fast, and more secure alternative to OpenSSL.

Here's a step-by-step guide on how to build the WasmEdge Rustls plug-in:

## Prerequisites

Ensure the following dependencies are installed on your system:

- Rust: You can install it from the [official website](https://www.rust-lang.org/tools/install).
- CMake: Minimum version 3.12. Install it from the [official website](https://cmake.org/download/).

## Clone the WasmEdge Repository

First, clone the WasmEdge repository from GitHub:

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
```

## Navigate to the Rustls Plug-in Directory

Navigate to the `wasmedge_rustls` directory within the cloned repository:

```bash
cd WasmEdge/plugins/wasmedge_rustls
```

## Build the Plug-in

Now you can build the Rustls plug-in. Run the following command:

```bash
cargo build --release
```

This command builds the plug-in in release mode. The compiled binary will be located in the `target/release` directory.

## Install the Plug-in

To install the plug-in, you can use the `cargo install` command:

```bash
cargo install --path .
```

This command will install the built plug-in into your Rust binary directory.

## Usage

To use the plug-in with WasmEdge, you need to specify it when starting the WasmEdge runtime:

```bash
wasmedge --dir .:. --reactor --rustls_plugin target/release/libwasmedge_rustls.so your_wasm_file.wasm
```

Replace `your_wasm_file.wasm` with the path to your WebAssembly file. The `--rustls_plugin` flag specifies the path to the Rustls plug-in.

That's it! You have successfully built and installed the WasmEdge Rustls plug-in. Please ensure to replace the OpenSSL plug-in with the Rustls plug-in in your WasmEdge runtime configuration if you were previously using OpenSSL.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_rustls).
","**Summary**

The provided code is a step-by-step guide on building and installing the WasmEdge Rustls plug-in, which replaces the OpenSSL plug-in in WasmEdge. The Rustls plug-in provides a modern, fast, and secure alternative to OpenSSL.

**Key Components**

1. **Prerequisites**: Install Rust and CMake, minimum version 3.12.
2. **Clone Repository**: Clone the WasmEdge repository from GitHub using `git clone https://github.com/WasmEdge/WasmEdge.git`.
3. **Navigate to Plug-in Directory**: Navigate to the `wasmedge_rustls` directory within the cloned repository using `cd WasmEdge/plugins/wasmedge_rustls`.
4. **Build Plug-in**: Build the Rustls plug-in in release mode using `cargo build --release`.
5. **Install Plug-in**: Install the built plug-in using `cargo install --path .`.
6. **Usage**: Use the plug-in with WasmEdge by specifying it when starting the runtime.

**Potential Issues**

1. **Rust and CMake versions**: Ensure that Rust and CMake are installed at the required versions (Rust 1.x, CMake 3.12).
2. **Build failures**: If `cargo build` or `cargo install` fails, check for errors in the terminal output.
3. **WasmEdge configuration**: Replace the OpenSSL plug-in with the Rustls plug-in in WasmEdge runtime configuration if previously using OpenSSL.

**Areas for Improvement**

1. **Error handling**: Improve error handling in `cargo build` and `cargo install` commands to provide more informative error messages.
2. **Code organization**: Consider refactoring the guide into separate sections or chapters for easier navigation.
3. **Example use cases**: Provide additional examples of using the Rustls plug-in with WasmEdge to demonstrate its capabilities."
docs/develop/deploy/oci-runtime/crun.md,"---
sidebar_position: 2
---

# Deploy with crun

The [crun project](https://github.com/containers/crun) has WasmEdge support baked in. This chapter will walk you through deploying WASM images with crun.

## Fedora Platform

The crun fedora package has WasmEdge as the default WebAssembly Runtime. So the easiest way to deploy WasmEdge with crun is on the Fedora Linux distribution. Please refer to the [next section](#other-linux-platforms) for the other Linux distributions.

First, install crun and WasmEdge on your fedora machine.

```bash
sudo dnf -y install wasmedge
sudo dnf -y install crun
```

Next, run `crun -v` to check if you installed successfully.

```bash
crun -v
# Output
crun version 1.7.2
commit: 0356bf4aff9a133d655dc13b1d9ac9424706cac4
rundir: /run/user/501/crun
spec: 1.0.0
+SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +CRIU +LIBKRUN +WASM:wasmedge +YAJL
```

You can see that crun has WasmEdge package already.

Next, you can run WASM apps on your [fedora machine](../../../start/getting-started/quick_start_redhat.md).

## Other Linux Platforms

### Quick start

The [GitHub repo](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on CRI-O.

- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio.yml)
- HTTP service example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio-server.yml)

### Prerequisites

1. Make sure you have installed [WasmEdge](../../../start/install.md#install)

2. Build and configure crun with WasmEdge support

For now, the easiest approach is just built it yourself from source. First, let's ensure that `crun` dependencies are installed on your Ubuntu 20.04. For other Linux distributions, please [see here](https://github.com/containers/crun#readme).

```bash
sudo apt update
sudo apt install -y make git gcc build-essential pkgconf libtool \
    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
    go-md2man libtool autoconf python3 automake
```

Next, configure, build, and install a `crun` binary with WasmEdge support.

```bash
git clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
```
","**Summary**

This document guides the reader on how to deploy WebAssembly (WASM) images using the `crun` project, which has built-in support for WASMEdge. The steps are divided into two sections:

1. **Fedora Platform**: Installing `crun` and WASMEdge on a Fedora Linux distribution, where crun has WasmEdge as its default WebAssembly Runtime.
2. **Other Linux Platforms**: Building and configuring crun with WASMEdge support on non-Fedora platforms.

**Key Components**

* `crun`: A lightweight container runtime for Linux
* WASMEdge: The default WebAssembly Runtime for crun (on Fedora) or a build dependency for custom builds
* Git: Used for cloning the crun repository and building it from source

**Potential Issues/Improvement Areas**

1. **Platform-specific dependencies**: The instructions for installing `crun` dependencies vary across Linux distributions. Providing more comprehensive documentation or tools to simplify this process would be helpful.
2. **Building from source**: For non-Fedora platforms, users need to build crun with WASMEdge support from source. This can be a complex and error-prone process, especially for those without experience in building and configuring container runtimes.
3. **Documentation updates**: The document mentions that the GitHub repository contains scripts and GitHub Actions for running example apps on CRI-O. However, these links are not clickable or directly accessible within the provided documentation.

**Recommendations**

1. **Improve platform-agnostic instructions**: Provide more detailed instructions or tools to simplify the process of installing `crun` dependencies across Linux distributions.
2. **Simplify building from source**: Consider providing a pre-built binary for non-Fedora platforms or improving the build process to reduce complexity and errors.
3. **Update documentation links**: Ensure that all provided links are clickable, up-to-date, and accessible within the document."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime/crun.md,"---
sidebar_position: 2
---

# Deploy with crun

The [crun project](https://github.com/containers/crun) has WasmEdge support baked in. This chapter will walk you through deploying WASM images with crun.

## Fedora Platform

The crun fedora package has WasmEdge as the default WebAssembly Runtime. So the easiest way to deploy WasmEdge with crun is on the Fedora Linux distribution. Please refer to the [next section](#other-linux-platforms) for the other Linux distributions.

First, install crun and WasmEdge on your fedora machine.

```bash
sudo dnf -y install wasmedge
sudo dnf -y install crun
```

Next, run `crun -v` to check if you installed successfully.

```bash
crun -v
# Output
crun version 1.7.2
commit: 0356bf4aff9a133d655dc13b1d9ac9424706cac4
rundir: /run/user/501/crun
spec: 1.0.0
+SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +CRIU +LIBKRUN +WASM:wasmedge +YAJL
```

You can see that crun has WasmEdge package already.

Next, you can run WASM apps on your [fedora machine](../../../start/getting-started/quick_start_redhat.md).

## Other Linux Platforms

### Quick start

The [GitHub repo](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on CRI-O.

- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio.yml)
- HTTP service example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio-server.yml)

### Prerequisites

1. Make sure you have installed [WasmEdge](../../../start/install.md#install)

2. Build and configure crun with WasmEdge support

For now, the easiest approach is just built it yourself from source. First, let's ensure that `crun` dependencies are installed on your Ubuntu 20.04. For other Linux distributions, please [see here](https://github.com/containers/crun#readme).

```bash
sudo apt update
sudo apt install -y make git gcc build-essential pkgconf libtool \
    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
    go-md2man libtool autoconf python3 automake
```

Next, configure, build, and install a `crun` binary with WasmEdge support.

```bash
git clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
```
","**Summary**

This code is a documentation chapter on deploying WASM (WebAssembly) images with crun, a container runtime project. The chapter provides step-by-step instructions for installing crun and WasmEdge on Fedora Linux, as well as other Linux platforms.

**Key Components**

1. **Fedora Platform**: The chapter explains that the crun package on Fedora Linux has WasmEdge as its default WebAssembly Runtime.
2. **Installation Instructions**: The code provides shell commands to install crun and WasmEdge on a Fedora machine using dnf.
3. **Verification**: The code includes an example of verifying the installation by running `crun -v`.
4. **Other Linux Platforms**: The chapter outlines the steps for installing crun with WasmEdge support on other Linux platforms, including Ubuntu 20.04.
5. **Prerequisites**: The code lists the dependencies required to build and configure crun with WasmEdge support.

**Potential Issues or Areas for Improvement**

1. **Platform-Specific Instructions**: The chapter provides platform-specific instructions, which may become outdated or need updates as new versions of operating systems are released.
2. **Assumptions**: The code assumes that the reader has a basic understanding of shell commands and Linux environments.
3. **Error Handling**: There is no explicit error handling in case something goes wrong during installation or verification.

**Code Quality**

The code is well-structured, with clear headings and concise instructions. However, there are some minor formatting issues and typos that should be addressed for better readability."
docs/develop/deploy/oci-runtime/youki.md,"---
sidebar_position: 3
---

# Deploy with youki

youki is an OCI container runtime written in Rust. youki has WasmEdge baked in. This chapter will walk you through deploying WASM images with youki.

## Prerequisites

1. Build and configure youki with WasmEdge support

   We will use Ubuntu 20.04 as an example. For other OS, please [see here](https://containers.github.io/youki/user/basic_setup.html).

   Run the following command line to build and install youki on your machine.

   ```bash
   $ sudo apt-get install \
      curl                \
      git                 \
      pkg-config          \
      libsystemd-dev      \
      libdbus-glib-1-dev  \
      build-essential     \
      libelf-dev          \
      libzstd-dev         \
      libseccomp-dev      \
      libclang-dev

   # If you don't have the rust toolchain installed run:
   $ curl https://sh.rustup.rs -sSf | sudo sh -s -- -y
   ```

   Next, configure, build, and install a `youki` binary with WasmEdge support.

   ```bash
   git clone --recurse-submodules https://github.com/containers/youki.git
   cd youki
   ./scripts/build.sh -o . -r -f wasm-wasmedge
   ./youki -h
   export LD_LIBRARY_PATH=$HOME/.wasmedge/lib
   ```

2. [Install WasmEdge](../../../start/install.md#install)

3. Configure the `config.json` from youki to run WASM modules.

   To run a webassembly module with youki, the `config.json` has to include either runc.oci.handler or module.wasm.image/variant=compat"". It also needs you to specify a valid .wasm (webassembly binary) or .wat (webassembly test) module as an entrypoint for the container.

   ```json
   ""ociVersion"": ""1.0.2-dev"",
   ""annotations"": {
       ""run.oci.handler"": ""wasm""
   },
   ""process"": {
       ""args"": [
           ""wasi_example_main.wasm"",
           ],
   ```

## Run a simple WebAssembly app

Now we can run a simple WebAssembly app. [A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md) explains how to compile, package, and publish the WebAssembly program as a container image to Docker hub.

```bash
sudo ctr i pull docker.io/wasmedge/example-wasi:latest
```

Run the example with Youki and Podman.

```bash
sudo podman --runtime /PATH/WHARE/YOU/BUILT/WITH/WASM-WASMEDGE/youki run /wasi_example_main.wasm 50000000
```

That's it.
","**Summary**

The code in this document provides a step-by-step guide to deploying WebAssembly (WASM) images using the OCI container runtime ""youki"". Youki is written in Rust and includes WasmEdge baked in. The guide assumes you have Ubuntu 20.04 as your operating system.

**Key Components**

1. **Prerequisites**: The user needs to build and configure youki with WasmEdge support, which involves installing dependencies and building the `youki` binary.
2. **Configuring config.json**: The `config.json` file needs to be configured to run WASM modules using either `runc.oci.handler` or `module.wasm.image/variant=compat`.
3. **Running a simple WebAssembly app**: Once youki and WasmEdge are set up, the user can run a simple WebAssembly app using `podman --runtime /path/to/youki`.

**Potential Issues**

1. **Dependencies**: The guide assumes that the necessary dependencies (e.g., Rust toolchain) are already installed on the system.
2. **WasmEdge installation**: WasmEdge needs to be installed separately, and its installation process is not included in the guide.
3. **Path issues**: The path to the `youki` binary may need to be adjusted depending on the user's system configuration.

**Recommendations**

1. **Improve error handling**: Add more explicit error messages or logging statements to help users diagnose any issues that may arise during the installation and setup process.
2. **Update dependencies**: Regularly update the list of required dependencies to ensure that the guide remains accurate and relevant.
3. **Add more examples**: Include additional examples of how to use youki and WasmEdge to deploy different types of WASM applications."
i18n/zh/docusaurus-plugin-content-docs/current/start/wasmedge/features.md,"---
sidebar_position: 1
---

# WasmEdge 功能

WasmEdge（[CNCF 旗下的沙盒项目](https://www.cncf.io/projects/wasmedge/)）是一个安全、快速、轻量、可移植且可扩展的 WebAssembly 运行时。

## 高性能

利用[基于 LLVM 的 AoT 编译器](../build-and-run/aot)，WasmEdge 是市场上速度最快的 WebAssembly 运行时。

- [高性能轻量设计用于无服务器计算](https://arxiv.org/abs/2010.07115)，发表于 2021 年 1 月 IEEE 软件。[https://arxiv.org/abs/2010.07115](https://arxiv.org/abs/2010.07115)
- [云端性能分析：Arm 与 x86 CPU 的比较](https://www.infoq.com/articles/arm-vs-x86-cloud-performance/)，发表于 2021 年 1 月的 infoQ.com。[https://www.infoq.com/articles/arm-vs-x86-cloud-performance/](https://www.infoq.com/articles/arm-vs-x86-cloud-performance/)
- [WasmEdge 在 Suborbital Reactr 测试套件中是最快的 WebAssembly 运行时](https://blog.suborbital.dev/suborbital-wasmedge)，2021 年 12 月

## 云原生扩展

除了 WASI 和标准的 WebAssembly 提案，WasmEdge 还有一些云原生扩展。

- 使用 Rust、C 和 JavaScript SDK 实现的非阻塞网络套接字和 Web 服务
- 基于 MySQL 的数据库驱动程序
- 键值存储
- 用于资源限制的 Gas 计量器
- 用于复杂参数传递的 WasmEdge-bindgen
- 使用 TensorFlow、TensorFlow Lite、PyTorch 和 OpenVINO 进行 AI 推理

## JavaScript 支持

通过 [WasmEdge-Quickjs](https://github.com/second-state/wasmedge-quickjs) 项目，WasmEdge 可以运行 JavaScript 程序，降低开发 WASM 应用的门槛。

- ES6 模块和 std API 支持
- NPM 模块支持
- Rust 中的原生 JS API
- Node.js API 支持
- 异步网络
- Fetch API
- React SSR

## 云原生编排

WasmEdge 可以与现有的云原生基础设施无缝集成。

要将 WasmEdge 与你现有的云原生基础架构集成，有几种管理 WASM 应用程序作为 Kubernetes 下的“容器”的选项。这些选项使你能够在 Kubernetes 集群中同时运行 Linux 容器和 WASM 容器。

**选项 #1：**[使用 OCI 运行时 crun](../../develop/deploy/oci-runtime/crun.md)（runc 的 C 版本，主要由 Red Hat 支持）。crun 根据镜像注释决定 OCI 镜像是 WASM 还是基于 Linux 的。如果镜像被注释为 wasm32，则 crun 将绕过 Linux 容器设置，直接使用 WasmEdge 运行镜像。通过使用 crun，你可以让整个 Kubernetes 栈（包括 CRI-O、containerd、Podman、kind、micro k8s 和 k8s）与 WASM 镜像一起工作。

选项 #2：[使用 containerd-shim 通过 runwasi 启动 WASM“容器”](../../develop/deploy/cri-runtime/containerd.md)。基本上，containerd 可以查看镜像的目标平台。如果镜像是 wasm32，则使用 runwasi；如果是 x86 / arm，则使用 runc。这是 Docker + Wasm 使用的方法。

## 跨平台

WASM 具有可移植性。编译后的 wasm 文件可以在不同的硬件和平台上运行，而无需任何更改。

WasmEdge 支持多种操作系统和硬件平台。它允许 WebAssembly 应用程序在各个平台上实现真正的可移植性。它可以在类似 Linux 的系统和微内核（例如实时系统 `seL4`）上运行。

WasmEdge 目前支持：

- [Linux（x86_64 和 aarch64）](../../contribute/source/os/linux.md)
- [MacOS（x86_64 和 M1）](../../contribute/source/os/macos.md)
- [Windows 10](../../contribute/source/os/windows.md)
- [Android](/category/build-and-run-wasmedge-on-android)
- [seL4 RTOS](../../contribute/source/os/sel4.md)
- [OpenWrt](../../contribute/source/os/openwrt.md)
- [OpenHarmony](../../contribute/source/os/openharmony.md)
- [Raspberry Pi](../../contribute/source/os/raspberrypi.md)
- [RISC-V(WIP)](../../contribute/source/os/riscv64.md)

## 易于扩展

使用 C、Go 和 Rust 中的原生宿主函数很容易构建自定义的 WasmEdge 运行时。

或者，你可以为 WasmEdge 构建自己的插件，

- [Rust](../../contribute/plugin/develop_plugin_rustsdk)
- [C](../../contribute/plugin/develop_plugin_c)
- [C++](../../contribute/plugin/develop_plugin_cpp)

## 易于嵌入到主机应用程序中

嵌入式运行时是 WasmEdge 的经典用例。你可以将 WasmEdge 函数嵌入到 C、Go、Rust、Node.js、Java(WIP) 和 Python(WIP) 主机应用程序中。
","**Code Analysis Summary**

This code is a feature description for WasmEdge, a WebAssembly runtime that provides high-performance, lightweight, and portable execution of WebAssembly modules. The document highlights the following key features:

1. **High-Performance**: WasmEdge is built using LLVM's Ahead-of-Time (AOT) compiler, making it one of the fastest WebAssembly runtimes available.
2. **Cloud-Native Extensions**: WasmEdge provides extensions for cloud-native applications, including non-blocking network sockets, web services, database drivers, and AI inference with TensorFlow, TensorFlow Lite, PyTorch, and OpenVINO.
3. **JavaScript Support**: WasmEdge can execute JavaScript programs using the Quickjs engine, making it easier to develop WASM applications.
4. **Cloud-Native Orchestration**: WasmEdge can be integrated with existing cloud-native infrastructure, allowing for seamless deployment of WASM applications as Kubernetes ""containers.""
5. **Cross-Platform Compatibility**: WasmEdge is designed to be highly portable and can run on various operating systems and hardware platforms, including Linux, MacOS, Windows 10, Android, seL4 RTOS, OpenWrt, OpenHarmony, Raspberry Pi, and RISC-V.
6. **Easy Extension and Embedding**: WasmEdge provides a simple way to extend its functionality using C, Go, or Rust native host functions and allows for easy embedding into host applications written in C, Go, Rust, Node.js, Java, and Python.

**Potential Issues and Areas for Improvement**

1. **Code organization**: The document could benefit from a more structured organization, with clear headings and subheadings to facilitate easier navigation.
2. **Consistency**: Some sections may have inconsistent formatting or styles, which can make it difficult to read and understand the content.
3. **Depth of information**: While the document provides an overview of WasmEdge's features, some sections could be expanded upon or provide more in-depth information for users who want to delve deeper into specific topics.

Overall, this code analysis reveals a well-structured document that effectively communicates the key features and benefits of WasmEdge. With minor adjustments to organization and formatting, it can become an even more effective resource for users looking to learn about this powerful WebAssembly runtime."
docs/contribute/source/os/macos.md,"---
sidebar_position: 2
---

# Build on macOS

Currently, WasmEdge project on MacOS supports both Intel and M1 models. However, we only test and develop on `Catalina`, `Big Sur`, and `Monterey`.

- Model:
  - Intel (x86_64)
  - M1, M2 (arm64)
- Operating System
  - Ventura
  - Monterey
  - Big Sur
  - Catalina

If you want to develop WasmEdge on MacOS, please follow this guide to build and test from source code.

## Get Source Code

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
```

## Requirements and Dependencies

WasmEdge will try to use the latest LLVM release to create our nightly build. If you want to build from source, you may need to install these dependencies yourself.

- LLVM 16.0.4 (>= 10.0.0)

```bash
# Tools and libraries
brew install cmake ninja llvm
export LLVM_DIR=""$(brew --prefix)/opt/llvm/lib/cmake""
export CC=clang
export CXX=clang++
```

## Build WasmEdge

Please refer to [here](../build_from_src.md#cmake-building-options) for the descriptions of all CMake options.

```bash
cmake -Bbuild -GNinja -DWASMEDGE_BUILD_TESTS=ON .
cmake --build build
```

If you don't want to link LLVM on MacOS dynamically, you can set the option `WASMEDGE_LINK_LLVM_STATIC` to `ON`.

## Run Tests

The following tests are available only when the build option `WASMEDGE_BUILD_TESTS` is set to `ON`.

Users can use these tests to verify the correctness of WasmEdge binaries.

```bash
cd build
DYLD_LIBRARY_PATH=$(pwd)/lib/api ctest
```

## Known issues

The following tests can not pass on Macos, we are investigating these issues:

- wasmedgeWasiSocketTests

But we have an open issue working on it. Don't hesitate to leave your feedback for [this issue](https://github.com/WasmEdge/WasmEdge/issues/2438).
","**Summary**

This document provides a guide for building the WasmEdge project on macOS. It covers the requirements and dependencies, including LLVM 16.0.4 or later, and how to install them using Homebrew. The guide also explains how to build WasmEdge from source code, including setting up CMake options, building the project, and running tests.

**Key Components**

1. **Get Source Code**: Clone the WasmEdge repository using Git.
2. **Requirements and Dependencies**: Install LLVM 16.0.4 or later using Homebrew, along with other tools and libraries such as CMake and Ninja.
3. **Build WasmEdge**: Use CMake to build the project in a separate directory (`build`), specifying the necessary options (e.g., `WASMEDGE_BUILD_TESTS=ON`).
4. **Run Tests**: Run tests using the `ctest` command, setting the `DYLD_LIBRARY_PATH` environment variable to the location of the built WasmEdge libraries.

**Potential Issues and Areas for Improvement**

1. **Incompatibility with macOS versions**: The guide only mentions testing on Catalina, Big Sur, and Monterey, but Ventura is also supported. It would be good to clarify this in the documentation.
2. **Dynamic linking issue**: The guide mentions a known issue where dynamic linking of LLVM can cause problems. It suggests setting `WASMEDGE_LINK_LLVM_STATIC` to `ON` as a workaround.
3. **Insufficient testing on M1 and M2 models**: While the guide mentions support for Intel, M1, and M2 (arm64) architectures, it would be good to clarify whether tests have been run successfully on these platforms.

Overall, this is a clear and concise guide that provides a step-by-step approach to building WasmEdge from source code on macOS. However, some minor improvements could be made to address potential issues and provide additional context for users."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/macos.md,"---
sidebar_position: 2
---

# Build on macOS

Currently, WasmEdge project on MacOS supports both Intel and M1 models. However, we only test and develop on `Catalina`, `Big Sur`, and `Monterey`.

- Model:
  - Intel (x86_64)
  - M1, M2 (arm64)
- Operating System
  - Ventura
  - Monterey
  - Big Sur
  - Catalina

If you want to develop WasmEdge on MacOS, please follow this guide to build and test from source code.

## Get Source Code

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
```

## Requirements and Dependencies

WasmEdge will try to use the latest LLVM release to create our nightly build. If you want to build from source, you may need to install these dependencies yourself.

- LLVM 16.0.4 (>= 10.0.0)

```bash
# Tools and libraries
brew install cmake ninja llvm
export LLVM_DIR=""$(brew --prefix)/opt/llvm/lib/cmake""
export CC=clang
export CXX=clang++
```

## Build WasmEdge

Please refer to [here](../build_from_src.md#cmake-building-options) for the descriptions of all CMake options.

```bash
cmake -Bbuild -GNinja -DWASMEDGE_BUILD_TESTS=ON .
cmake --build build
```

If you don't want to link LLVM on MacOS dynamically, you can set the option `WASMEDGE_LINK_LLVM_STATIC` to `ON`.

## Run Tests

The following tests are available only when the build option `WASMEDGE_BUILD_TESTS` is set to `ON`.

Users can use these tests to verify the correctness of WasmEdge binaries.

```bash
cd build
DYLD_LIBRARY_PATH=$(pwd)/lib/api ctest
```

## Known issues

The following tests can not pass on Macos, we are investigating these issues:

- wasmedgeWasiSocketTests

But we have an open issue working on it. Don't hesitate to leave your feedback for [this issue](https://github.com/WasmEdge/WasmEdge/issues/2438).
","**Code Summary**

This is a documentation file for building the WasmEdge project on macOS. The document provides instructions and requirements for developing WasmEdge from source code.

**Key Components**

1. **Requirements**: The document lists the dependencies required to build WasmEdge, including LLVM 16.0.4 (>=10.0.0).
2. **Getting Source Code**: The user is instructed to clone the WasmEdge repository and navigate to the project directory.
3. **Building WasmEdge**: The user is provided with CMake commands to build WasmEdge with various options, including enabling tests and linking LLVM statically.
4. **Running Tests**: Instructions are given on how to run the available tests using the `ctest` command.

**Potential Issues or Areas for Improvement**

1. **Known issues**: The document mentions an open issue with the `wasmedgeWasiSocketTests` test that cannot pass on macOS. It would be beneficial to provide a workaround or temporary solution until the issue is resolved.
2. **Version requirements**: While LLVM 16.0.4 is specified, it's not clear if this version will always be compatible with future WasmEdge releases. A more flexible versioning strategy or recommendation for users to install the latest stable LLVM release might be beneficial.
3. **Dependency installation**: The document assumes that users have Homebrew installed and can use `brew` commands to install dependencies. Adding a note about alternative package managers (e.g., MacPorts, apt-get) or providing instructions on how to manually download and install dependencies would improve usability.

**Best Practices**

1. **Use clear headings and sectioning**: The document's structure and organization are clear, making it easy to follow along.
2. **Provide concise and specific instructions**: Each step has a clear and concise description, reducing the likelihood of users getting lost or confused.
3. **Link to external resources**: Providing links to related issues or documentation can help users dive deeper into specific topics and collaborate with others who may be experiencing similar challenges."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime/youki.md,"---
sidebar_position: 3
---

# Deploy with youki

youki is an OCI container runtime written in Rust. youki has WasmEdge baked in. This chapter will walk you through deploying WASM images with youki.

## Prerequisites

1. Build and configure youki with WasmEdge support

   We will use Ubuntu 20.04 as an example. For other OS, please [see here](https://containers.github.io/youki/user/basic_setup.html).

   Run the following command line to build and install youki on your machine.

   ```bash
   $ sudo apt-get install   \
       pkg-config         \
       libsystemd-dev     \
       libdbus-glib-1-dev \
       build-essential    \
       libelf-dev \
       libseccomp-dev \
       libclang-dev
   ```

   Next, configure, build, and install a `youki` binary with WasmEdge support.

   ```bash
   git clone https://github.com/containers/youki.git
   go into the cloned directory
   cd youki
   make youki-dev
   ./youki -h
   ./scripts/build.sh -o . -r -f wasm-wasmedge
   export LD_LIBRARY_PATH=$HOME/.wasmedge/lib
   ```

2. [Install WasmEdge](../../../start/install.md#install)

3. Configure the `config.json` from youki to run WASM modules.

   To run a webassembly module with youki, the `config.json` has to include either runc.oci.handler or module.wasm.image/variant=compat"". It also needs you to specify a valid .wasm (webassembly binary) or .wat (webassembly test) module as an entrypoint for the container.

   ```json
   ""ociVersion"": ""1.0.2-dev"",
   ""annotations"": {
       ""run.oci.handler"": ""wasm""
   },
   ""process"": {
       ""args"": [
           ""wasi_example_main.wasm"",
           ],
   ```

## Run a simple WebAssembly app

Now we can run a simple WebAssembly app. [A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md) explains how to compile, package, and publish the WebAssembly program as a container image to Docker hub.

```bash
sudo ctr i pull docker.io/wasmedge/example-wasi:latest
```

Run the example with Youki and Podman.

```bash
sudo podman --runtime /PATH/WHARE/YOU/BUILT/WITH/WASM-WASMEDGE/youki run /wasi_example_main.wasm 50000000
```

That's it.
","**Summary**

The code provided is a documentation chapter for deploying WebAssembly (WASM) images with the Youki container runtime. It assumes that the reader has already built and configured Youki with WasmEdge support on an Ubuntu 20.04 system. The chapter walks through the process of setting up and running a simple WASM app using Youki and Podman.

**Key Components**

1. **Prerequisites**: Building and configuring Youki with WasmEdge support.
2. **Installing WasmEdge**: Installing WasmEdge, a Rust implementation of the WebAssembly runtime environment.
3. **Configuring `config.json`**: Configuring the `config.json` file to run WASM modules using Youki.
4. **Running a simple WebAssembly app**: Compiling, packaging, and publishing a WASM program as a container image on Docker Hub, then running it with Youki and Podman.

**Potential Issues or Areas for Improvement**

1. **Code Organization**: The documentation chapter seems to be a mix of installation instructions, configuration examples, and usage guides. Consider breaking down the content into separate sections or chapters.
2. **Assumptions**: Some steps assume that the reader has already built and configured Youki with WasmEdge support. Provide more explicit guidance for users who are new to Youki or WasmEdge.
3. **Code Snippets**: The code snippets in the `config.json` file are not formatted consistently, which may make them harder to read. Consider using a consistent formatting style throughout the documentation.
4. **Links**: Some links (e.g., `[see here](https://containers.github.io/youki/user/basic_setup.html)`) seem to be broken or outdated. Update these links to ensure that they point to valid resources.

Overall, the code provided is well-structured and provides a clear guide for deploying WASM images with Youki. With some minor improvements in organization, assumptions, and formatting, it can become an even more effective resource for users."
docs/develop/c/simd.md,"---
sidebar_position: 4
---

# WebAssembly SIMD Example in C

[128-bit packed Single Instruction Multiple Data (SIMD)](https://webassembly.github.io/simd/core/syntax/instructions.html#simd-instructions) instructions provide simultaneous computations over packed data in just one instruction. It's commonly used to improve performance for multimedia applications. With the SIMD proposal, the modules can benefit from using these commonly used instructions in modern hardware to gain more speedup.

If you are interested in enabling the SIMD proposal will improve how much performance of the applications, please refer to our [wasm32-wasi benchmark](https://github.com/second-state/wasm32-wasi-benchmark) for more information. The Mandelbrot Set application can have a **2.65x** speedup in our benchmark.

We modified the Mandelbrot Set example from our [wasm32-wasi benchmark project](https://github.com/second-state/wasm32-wasi-benchmark/blob/master/src/mandelbrot.c). We will use this as an example in this article.

## Prerequisites

Before we start, make sure you have installed the following software:

1. [Install WasmEdge](../../start/install.md#install)

2. Emscripten, a toolchain for compiling C/C++ to WebAssembly. Please refer to the [emcc official repository](https://github.com/emscripten-core/emsdk) for detailed instructions.

```bash
git clone --depth 1 https://github.com/emscripten-core/emsdk.git
cd emsdk
./emsdk install latest
./emsdk activate latest
source ./emsdk_env.sh
```

## Compile the C-SIMD application to Wasm-SIMD binary with emcc

```bash
emcc -g -Oz --llvm-lto 1 -s STANDALONE_WASM -s INITIAL_MEMORY=32MB -s MAXIMUM_MEMORY=4GB \
  -mmutable-globals \
  -mnontrapping-fptoint \
  -msign-ext \
  mandelbrot-simd.c -o mandelbrot-simd.wasm
```

## Run with WasmEdge

```bash
wasmedge mandelbrot-simd.wasm 15000
```

## Ahead-of-Time mode

With WasmEdge's AoT compiler, you will get higher performance.

```bash
# Compile wasm-simd with wasmedge aot compiler
$ wasmedge compile mandelbrot-simd.wasm mandelbrot-simd-out.wasm
# Run the native binary with wasmedge
$ wasmedge mandelbrot-simd-out.wasm 15000
```
","**Summary**

This code provides a WebAssembly SIMD (Single Instruction Multiple Data) example in C, using the SIMD proposal to improve performance. The example uses the Mandelbrot Set application and demonstrates how to compile and run it with WasmEdge and Emscripten.

**Key Components**

1. **Prerequisites**: Installation of WasmEdge and Emscripten toolchain.
2. **Compilation**: Compilation of C-SIMD source code `mandelbrot-simd.c` using Emscripten's `emcc` compiler to generate a Wasm-SIMD binary.
3. **Run with WasmEdge**: Running the generated Wasm-SIMD binary with WasmEdge.
4. **Ahead-of-Time (AoT) compilation**: Compiling the Wasm-SIMD binary with WasmEdge's AoT compiler for higher performance.

**Potential Issues**

1. **Complexity**: The code requires knowledge of Emscripten, WebAssembly SIMD, and WasmEdge, which may be challenging to grasp for beginners.
2. **Performance variability**: Performance improvements due to SIMD instructions may not be consistent across different hardware platforms or use cases.
3. **Toolchain compatibility**: Compatibility issues between Emscripten and WasmEdge versions may arise.

**Areas for Improvement**

1. **Simplified compilation process**: Streamlining the compilation process using scripts or automated build tools.
2. **Optimized performance settings**: Experimenting with different compiler flags to achieve better performance results.
3. **Multi-threading support**: Enhancing the code to utilize multiple cores and improve parallel processing capabilities."
i18n/zh/docusaurus-plugin-content-docs/current/develop/c/simd.md,"---
sidebar_position: 4
---

# WebAssembly SIMD Example in C

[128-bit packed Single Instruction Multiple Data (SIMD)](https://webassembly.github.io/simd/core/syntax/instructions.html#simd-instructions) instructions provide simultaneous computations over packed data in just one instruction. It's commonly used to improve performance for multimedia applications. With the SIMD proposal, the modules can benefit from using these commonly used instructions in modern hardware to gain more speedup.

If you are interested in enabling the SIMD proposal will improve how much performance of the applications, please refer to our [wasm32-wasi benchmark](https://github.com/second-state/wasm32-wasi-benchmark) for more information. The Mandelbrot Set application can have a **2.65x** speedup in our benchmark.

We modified the Mandelbrot Set example from our [wasm32-wasi benchmark project](https://github.com/second-state/wasm32-wasi-benchmark/blob/master/src/mandelbrot.c). We will use this as an example in this article.

## Prerequisites

Before we start, make sure you have installed the following software:

1. [Install WasmEdge](../../start/install.md#install)

2. Emscripten, a toolchain for compiling C/C++ to WebAssembly. Please refer to the [emcc official repository](https://github.com/emscripten-core/emsdk) for detailed instructions.

```bash
git clone --depth 1 https://github.com/emscripten-core/emsdk.git
cd emsdk
./emsdk install latest
./emsdk activate latest
source ./emsdk_env.sh
```

## Compile the C-SIMD application to Wasm-SIMD binary with emcc

```bash
emcc -g -Oz --llvm-lto 1 -s STANDALONE_WASM -s INITIAL_MEMORY=32MB -s MAXIMUM_MEMORY=4GB \
  -mmutable-globals \
  -mnontrapping-fptoint \
  -msign-ext \
  mandelbrot-simd.c -o mandelbrot-simd.wasm
```

## Run with WasmEdge

```bash
wasmedge mandelbrot-simd.wasm 15000
```

## Ahead-of-Time mode

With WasmEdge's AoT compiler, you will get higher performance.

```bash
# Compile wasm-simd with wasmedge aot compiler
$ wasmedge compile mandelbrot-simd.wasm mandelbrot-simd-out.wasm
# Run the native binary with wasmedge
$ wasmedge mandelbrot-simd-out.wasm 15000
```
","**Code Summary**

This code is a tutorial on using WebAssembly SIMD (Single Instruction Multiple Data) instructions in C to improve performance for multimedia applications. The tutorial provides an example of modifying the Mandelbrot Set application to use SIMD instructions, resulting in a significant speedup.

**Key Components**

1. **Prerequisites**: The code requires WasmEdge and Emscripten to be installed.
2. **Compilation**: The C-SIMD application is compiled using emcc (Emscripten compiler) with various flags to enable SIMD instructions.
3. **Run**: The resulting Wasm-SIMD binary is run using WasmEdge.
4. **Ahead-of-Time (AoT) mode**: An optional step that uses the WasmEdge AoT compiler for further performance optimization.

**Potential Issues**

1. **Dependence on specific toolchains**: The code depends on Emscripten and WasmEdge, which might require additional setup or installation.
2. **Compilation flags complexity**: The emcc compilation flags are complex and may be difficult to understand or modify.
3. **Limited platform support**: WebAssembly SIMD instructions and the required toolchain might have limited platform support.

**Improvement Areas**

1. **Simplify compilation flags**: Provide a more concise explanation of the emcc compilation flags and possibly suggest alternative approaches.
2. **Provide more detailed setup instructions**: Offer step-by-step setup instructions for Emscripten and WasmEdge to make it easier for users to get started.
3. **Explore alternative toolchains**: Investigate other toolchains or alternatives that can simplify the process of compiling C-SIMD applications to WebAssembly SIMD binaries."
docs/start/overview.md,"---
sidebar_position: 1
displayed_sidebar: startSidebar
---

# Getting Started with WasmEdge

WasmEdge is a lightweight, high-performance, and extensible WebAssembly runtime for cloud-native, edge, and decentralized applications. It powers serverless apps, embedded functions, microservices, udf, smart contracts, and IoT devices. WasmEdge is currently a CNCF (Cloud Native Computing Foundation) Sandbox project.

The WasmEdge Runtime provides a well-defined execution sandbox for its contained WebAssembly bytecode program. The runtime offers isolation and protection for operating system resources (e.g., file system, sockets, environment variables, processes) and memory space. The most important use case for WasmEdge is to safely execute user-defined or community-contributed code as plug-ins in a software product (e.g., SaaS, database, edge nodes, or even blockchain nodes). It enables third-party developers, vendors, suppliers, and community members to extend and customize the software product.

This chapter will introduce how to install and get started with WasmEdge.

We will cover the following content:

- [Install and Uninstall WasmEdge](install.md)
- [Getting Started](/category/getting-started-with-wasmEdge)
- Introduce the [WasmEdge Runtime](/category/what-is-wasmedge)
- Usages of [Running WasmEdge](/category/running-with-wasmedge)
- [Frequently Asked Question](faq.md)
- [Style Guide](style_guide.md) for new contributors 
- [Troubleshooting Guide](troubleshooting_guide.md)

For advanced programming with WasmEdge, please refer to the guides for [developing WASM apps](../develop/overview.md), [Embedding WasmEdge in your apps](../embed/overview.md), or [contributing](../contribute/overview.md) to WasmEdge.

If you find any issues or have any feedback, please reach out to us via the following ways.

- [Discord Chat](https://discord.gg/U4B5sFTkFc)
- [Create a GitHub issue for technical support](https://github.com/WasmEdge/WasmEdge/issues)
- [Submit a GitHub discussion](https://github.com/WasmEdge/WasmEdge/discussions)
- [Follow @realwasmedge on Twitter](https://twitter.com/realwasmedge)
","**Summary**

The provided code is a markdown file (`overview.md`) that serves as an introduction to WasmEdge, a lightweight WebAssembly runtime. The file explains the purpose and functionality of WasmEdge, highlighting its use cases, features, and benefits. It also provides information on how to get started with WasmEdge, including installation, usage, and troubleshooting guides.

**Key Components**

1. **Introduction**: A brief overview of WasmEdge, its history, and its position as a CNCF (Cloud Native Computing Foundation) Sandbox project.
2. **Purpose**: Explanation of the runtime's purpose, providing isolation and protection for operating system resources and memory space.
3. **Use Cases**: Discussion of various use cases where WasmEdge is applicable, including serverless apps, embedded functions, microservices, smart contracts, and IoT devices.
4. **Getting Started**: Information on how to install and get started with WasmEdge, including links to relevant guides.
5. **Advanced Topics**: References to advanced programming topics, such as developing WASM apps, embedding WasmEdge in your apps, or contributing to WasmEdge.

**Potential Issues or Areas for Improvement**

1. **Length**: The file is quite long and may be overwhelming for new users. Breaking it up into smaller sections or using tables of contents could improve readability.
2. **Links**: Some links may become outdated over time. Regular updates and maintenance are necessary to ensure that links remain valid.
3. **Depth of information**: While the file provides a good introduction, some topics, such as advanced programming with WasmEdge, could benefit from more detailed explanations or examples.
4. **Organization**: The use case section feels a bit disorganized, with multiple points listed without clear connections between them.

Overall, the code is well-structured and provides valuable information on getting started with WasmEdge. However, some improvements in organization, links, and depth of information could enhance its usability and effectiveness."
docs/contribute/source/plugin/image.md,"---
sidebar_position: 4
---

# Build WasmEdge With WasmEdge-Image Plug-in

The WasmEdge Image plug-in is a software component that extends the functionality of the WasmEdge runtime, enabling it to load and decode JPEG and PNG images and convert them into tensors. This plug-in is useful for developers who need to process image data within their WebAssembly applications.

## Prerequisites

The prerequisites of the WasmEdge-Image plug-in is the same as the WasmEdge building environment on the [Linux platforms](../os/linux.md) or [MacOS platforms](../os/macos.md).

If developers build with their own environment, please ensure the `zlib` and `libboost-all-dev` are installed.

```bash
sudo apt update
sudo apt install zlib1g-dev libboost-all-dev
```

On MacOS platforms, the `libjpeg` and `libpng` are required.

```bash
brew install jpeg-turbo libpng
```

## Build WasmEdge with WasmEdge-Image Plug-in

To enable the WasmEdge WasmEdge-Image, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_IMAGE=On`.

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_IMAGE=On
cmake --build build
# For the WasmEdge-Image plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WasmEdge-Image plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_image/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-Image plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeImage.so` after installation.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_image).
","**Summary**

This code is a documentation for building WasmEdge with the WasmEdge-Image plug-in, which enables loading and decoding of JPEG and PNG images. The plug-in requires zlib and libboost-all-dev to be installed on Linux platforms or libjpeg and libpng to be installed on MacOS platforms.

**Functionality**

The functionality of this code is to provide instructions for building WasmEdge with the WasmEdge-Image plug-in, including:

1. Installing prerequisites (zlib and libboost-all-dev on Linux, or libjpeg and libpng on MacOS)
2. Building WasmEdge from source with the cmake option `-DWASMEDGE_PLUGIN_IMAGE=On`
3. Installing the built plug-in

**Key Components**

* `cmake`: a build system that generates a build configuration file
* `Ninja`: a fast build tool used by CMake
* `WASMEDGE_PLUGIN_IMAGE`: a CMake option to enable the WasmEdge-Image plug-in
* `zlib` and `libboost-all-dev`: prerequisites for Linux platforms
* `libjpeg` and `libpng`: prerequisites for MacOS platforms

**Potential Issues**

1. The installation of prerequisites may not be straightforward, especially on Linux platforms.
2. The CMake option `-DWASMEDGE_PLUGIN_IMAGE=On` must be used to enable the WasmEdge-Image plug-in during build time.
3. If the built `wasmedge` CLI tool cannot find the WasmEdge-Image plug-in, setting the `WASMEDGE_PLUGIN_PATH` environment variable may resolve the issue.

Overall, this code provides a clear and concise guide for building WasmEdge with the WasmEdge-Image plug-in, which is useful for developers who need to process image data within their WebAssembly applications."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/image.md,"---
sidebar_position: 4
---

# Build WasmEdge With WasmEdge-Image Plug-in

The WasmEdge Image plug-in is a software component that extends the functionality of the WasmEdge runtime, enabling it to load and decode JPEG and PNG images and convert them into tensors. This plug-in is useful for developers who need to process image data within their WebAssembly applications.

## Prerequisites

The prerequisites of the WasmEdge-Image plug-in is the same as the WasmEdge building environment on the [Linux platforms](../os/linux.md) or [MacOS platforms](../os/macos.md).

If developers build with their own environment, please ensure the `zlib` and `libboost-all-dev` are installed.

```bash
sudo apt update
sudo apt install zlib1g-dev libboost-all-dev
```

On MacOS platforms, the `libjpeg` and `libpng` are required.

```bash
brew install jpeg-turbo libpng
```

## Build WasmEdge with WasmEdge-Image Plug-in

To enable the WasmEdge WasmEdge-Image, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_IMAGE=On`.

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_IMAGE=On
cmake --build build
# For the WasmEdge-Image plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WasmEdge-Image plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_image/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-Image plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeImage.so` after installation.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_image).
","**Summary**

The provided code is a documentation for building WasmEdge, a WebAssembly runtime, with the WasmEdge-Image plug-in. The plug-in enables WasmEdge to load and decode JPEG and PNG images into tensors. The documentation outlines the prerequisites for building WasmEdge with the plug-in, which includes installing `zlib` and `libboost-all-dev` on Linux or MacOS platforms.

**Key Components**

1. **Prerequisites**: The prerequisites for building WasmEdge with the WasmEdge-Image plug-in.
2. **Building WasmEdge with WasmEdge-Image Plug-in**: The steps to build WasmEdge from source with the plug-in enabled.
3. **Troubleshooting**: A note about setting the `WASMEDGE_PLUGIN_PATH` environment variable if the built `wasmedge` CLI tool cannot find the WasmEdge-Image plug-in.

**Potential Issues**

1. **Outdated instructions**: The documentation assumes a specific version of WasmEdge and may not be applicable to newer versions.
2. **Missing dependencies**: If the reader misses installing `zlib` or `libboost-all-dev`, they may encounter issues building WasmEdge with the plug-in.

**Areas for Improvement**

1. **Versioning**: The documentation should include specific version numbers for WasmEdge and its dependencies to ensure compatibility.
2. **Clearer instructions**: Some steps, such as setting environment variables, could be made clearer with more explicit instructions.
3. **Additional troubleshooting information**: Providing additional tips or resources for resolving common issues would make the documentation more helpful to readers."
docs/contribute/source/plugin/process.md,"---
sidebar_position: 3
---

# Build WasmEdge With WasmEdge-Process Plug-in

The WasmEdge Process plug-in provides a sandboxed environment to execute system processes in a secured manner. This guide will walk you through the steps to build the WasmEdge Process plug-in.

## Prerequisites

The prerequisites of the WasmEdge-Process plug-in is the same as the [WasmEdge building environment on the Linux platforms](../os/linux.md).

## Build WasmEdge with WasmEdge-Process Plug-in

To enable the WasmEdge WasmEdge-Process, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_PROCESS=On`.

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_PROCESS=On
cmake --build build
# For the WasmEdge-Process plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WasmEdge-Process plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_process/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-Process plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeProcess.so` after installation.

## Usage

To use the plug-in with WasmEdge, you need to specify it when starting the WasmEdge runtime:

```bash
wasmedge --dir .:. --reactor --process_plugin target/release/libwasmedge_process.so your_wasm_file.wasm
```

Replace `your_wasm_file.wasm` with the path to your WebAssembly file. The `--process_plugin`flag specifies the path to the Process plug-in.

That's it! You have successfully built and installed the WasmEdge Process plug-in.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_process).
","**Summary**

The provided code is a guide to building the WasmEdge Process plug-in, which provides a sandboxed environment to execute system processes in a secured manner. The plug-in can be built and installed using CMake and Ninja build tools.

**Key Components**

1. **Prerequisites**: The prerequisites for building the WasmEdge-Process plug-in are the same as building WasmEdge from source on Linux platforms.
2. **Building WasmEdge with WasmEdge-Process Plug-in**: To enable the WasmEdge Process plug-in, developers need to build WasmEdge from source using CMake and Ninja, specifying the `-DWASMEDGE_PLUGIN_PROCESS=On` option.
3. **Installation**: After building, the plug-in can be installed using `cmake --install build`.
4. **Usage**: To use the plug-in with WasmEdge, developers need to specify it when starting the WasmEdge runtime using the `--process_plugin` flag.

**Potential Issues or Areas for Improvement**

1. **Error handling**: The provided code does not handle errors that may occur during building and installation.
2. **Plugin path**: The code assumes that the plug-in will be installed in `/usr/local/lib/wasmedge/`, but this might not be the case on all systems.
3. **Environment variable**: The code suggests setting the `WASMEDGE_PLUGIN_PATH` environment variable to fix issues with finding the WasmEdge-Process plug-in, but this is not a reliable solution.
4. **Documentation**: While the provided code is well-documented, it would be beneficial to include more information about the plug-in's functionality and use cases.

Overall, the provided code provides a clear guide to building and installing the WasmEdge Process plug-in, but some minor improvements could make it even more robust and user-friendly."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/process.md,"---
sidebar_position: 3
---

# Build WasmEdge With WasmEdge-Process Plug-in

The WasmEdge Process plug-in provides a sandboxed environment to execute system processes in a secured manner. This guide will walk you through the steps to build the WasmEdge Process plug-in.

## Prerequisites

The prerequisites of the WasmEdge-Process plug-in is the same as the [WasmEdge building environment on the Linux platforms](../os/linux.md).

## Build WasmEdge with WasmEdge-Process Plug-in

To enable the WasmEdge WasmEdge-Process, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_PROCESS=On`.

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_PROCESS=On
cmake --build build
# For the WasmEdge-Process plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WasmEdge-Process plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_process/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-Process plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeProcess.so` after installation.

## Usage

To use the plug-in with WasmEdge, you need to specify it when starting the WasmEdge runtime:

```bash
wasmedge --dir .:. --reactor --process_plugin target/release/libwasmedge_process.so your_wasm_file.wasm
```

Replace `your_wasm_file.wasm` with the path to your WebAssembly file. The `--process_plugin`flag specifies the path to the Process plug-in.

That's it! You have successfully built and installed the WasmEdge Process plug-in.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_process).
","**Summary**

The provided code is a guide on building and using the WasmEdge Process plug-in for WebAssembly (WASM) development. The plug-in provides a sandboxed environment to execute system processes in a secured manner.

**Key Components**

1. **Prerequisites**: Building the WasmEdge Process plug-in requires the same environment as building WasmEdge from source on Linux platforms.
2. **Building WasmEdge with WasmEdge-Process Plug-in**: The guide explains how to build WasmEdge from source with the cmake option `-DWASMEDGE_PLUGIN_PROCESS=On`.
3. **Usage**: The plug-in is used by specifying it when starting the WasmEdge runtime, using the `--process_plugin` flag and providing the path to the Process plug-in.

**Potential Issues or Areas for Improvement**

1. **Error Handling**: The guide does not provide any information on error handling when building or using the WasmEdge Process plug-in.
2. **Debugging**: There is no mention of how to debug issues related to the plug-in or WasmEdge.
3. **Plugin Installation**: The guide assumes that the plug-in will be installed in a specific location (`/usr/local/lib/wasmedge/`), but it does not provide information on how to install the plug-in manually if this is not possible.
4. **Environment Variable**: The use of environment variable `WASMEDGE_PLUGIN_PATH` is mentioned as a potential solution for fixing issues with finding the WasmEdge-Process plug-in, but its usage and implications are not fully explained.

Overall, while the guide provides a good overview of building and using the WasmEdge Process plug-in, there are areas that could be improved to make it more comprehensive and user-friendly."
docs/start/wasmedge/comparison.md,"---
sidebar_position: 5
---

# Comparison

## What's the relationship between WebAssembly and Docker?

Check out our infographic [WebAssembly vs. Docker](https://wasmedge.org/wasm_linux_container/). WebAssembly runs side by side with Docker in cloud native and edge native applications.

## What's the difference for Native clients (NaCl), Application runtimes, and WebAssembly?

We created a handy table for the comparison.

|  | NaCl | Application runtimes (eg Node &amp; Python) | Docker-like container | WebAssembly |
| --- | --- | --- | --- | --- |
| Performance | Great | Poor | OK | Great |
| Resource footprint | Great | Poor | Poor | Great |
| Isolation | Poor | OK | OK | Great |
| Safety | Poor | OK | OK | Great |
| Portability | Poor | Great | OK | Great |
| Security | Poor | OK | OK | Great |
| Language and framework choice | N/A | N/A | Great | OK |
| Ease of use | OK | Great | Great | OK |
| Manageability | Poor | Poor | Great | Great |

## What's the difference between WebAssembly and eBPF?

`eBPF` is the bytecode format for a Linux kernel space VM that is suitable for network or security related tasks. WebAssembly is the bytecode format for a user space VM that is suited for business applications. [See details here](https://medium.com/codex/ebpf-and-webassembly-whose-vm-reigns-supreme-c2861ce08f89).
","**Summary**

The provided code is a Markdown document that serves as a comparison guide between various technologies, including WebAssembly, Docker, NaCl (Native clients), application runtimes (e.g., Node and Python), and eBPF. The document aims to provide an overview of the differences and similarities among these technologies in terms of performance, resource footprint, isolation, safety, portability, security, language and framework choice, ease of use, and manageability.

**Key Components**

1. **WebAssembly**: A binary format that runs code on web browsers or native environments with great performance, small footprint, excellent isolation, and high level of safety.
2. **Docker-like container**: A technology for running multiple isolated applications in a single environment with OK performance, poor resource footprint, good isolation, and decent security features.
3. **Application runtimes (e.g., Node & Python)**: Interpreted languages that have poor performance, large resource footprint, moderate isolation, and decent safety features.
4. **NaCl (Native clients)**: A technology for running native code in web browsers with great performance, small resource footprint, poor isolation, and low level of safety.
5. **eBPF**: A bytecode format for a Linux kernel space VM with poor performance, large resource footprint, excellent isolation, and high level of safety.

**Potential Issues or Areas for Improvement**

1. The table-based comparison might be overwhelming for readers unfamiliar with the technologies.
2. Some of the categories (e.g., language and framework choice) are not clearly defined or explained.
3. There is a lack of concrete examples or use cases to illustrate the differences between these technologies.

**Recommendations**

1. Consider adding more concise and focused sections to break up the content and make it easier to read.
2. Provide additional explanations or resources for readers who want to learn more about the underlying technologies.
3. Incorporate concrete examples or case studies to demonstrate the benefits and trade-offs of each technology."
docs/develop/javascript/es6.md,"---
sidebar_position: 6
---

# ES6 Modules

The WasmEdge QuickJS runtime supports ES6 modules. The roll-up commands we used in the [React SSR](ssr) examples convert and bundle CommonJS and NPM modules into ES6 modules to execute in WasmEdge QuickJS. This article will show you how to use the ES6 module in WasmEdge.

## Prerequisites

[See here](./hello_world#prerequisites)

## Run the example

We will take the example in [example_js/es6_module_demo](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/es6_module_demo) folder as an example. To run the example, you can do the following on the CLI.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/es6_module_demo/demo.js
hello from module_def.js
hello from module_def_async.js
./module_def_async.js `something` is  async thing
```

<!-- prettier-ignore -->
:::note
Make sure that you run those commands from the `wasmedge-quickjs` directory. [Here is why](./hello_world#prerequisites)
:::

## Code Explanation

The [module_def.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def.js) file defines and exports a simple JS function.

```javascript
function hello() {
  console.log('hello from module_def.js');
}

export { hello };
```

The [module_def_async.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def_async.js) file defines and exports an async function and a variable.

```javascript
export async function hello() {
  console.log('hello from module_def_async.js');
  return 'module_def_async.js : return value';
}

export var something = 'async thing';
```

The [demo.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/demo.js) file imports functions and variables from those modules and executes them.

```javascript
import { hello as module_def_hello } from './module_def.js';

module_def_hello();

var f = async () => {
  let { hello, something } = await import('./module_def_async.js');
  await hello();
  console.log('./module_def_async.js `something` is ', something);
};

f();
```
","**Summary**

This documentation provides an overview of using ES6 modules with the WasmEdge QuickJS runtime. The article explains how to convert and bundle CommonJS and NPM modules into ES6 modules to execute in WasmEdge QuickJS, using the example code from `example_js/es6_module_demo`.

**Key Components**

*   The example uses two ES6 modules: `module_def.js` and `module_def_async.js`.
*   `module_def.js` exports a simple JavaScript function `hello()` that logs a message to the console.
*   `module_def_async.js` exports an asynchronous function `hello()` and a variable `something`, both of which are used in the demo code.
*   The `demo.js` file imports functions and variables from these modules, executes them, and demonstrates how to use ES6 module imports.

**Potential Issues or Areas for Improvement**

1.  **Code Organization**: While the example code is organized into separate files for each module, it would be beneficial to include more documentation on how to structure larger projects using this approach.
2.  **Error Handling**: The demo code does not handle any errors that may occur during import or execution of the modules. Consider adding try-catch blocks to demonstrate error handling and provide a better user experience.
3.  **Security**: As with any JavaScript code, ensure proper input validation and sanitization when importing and executing ES6 modules from external sources.
4.  **Performance Optimization**: The example code is not optimized for performance. Consider exploring techniques like lazy loading or caching to improve the execution time of large projects.

Overall, this documentation provides a solid introduction to using ES6 modules with WasmEdge QuickJS, and the example code serves as a good starting point for building more complex applications."
i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/es6.md,"---
sidebar_position: 6
---

# ES6 Modules

The WasmEdge QuickJS runtime supports ES6 modules. The roll-up commands we used in the [React SSR](ssr) examples convert and bundle CommonJS and NPM modules into ES6 modules to execute in WasmEdge QuickJS. This article will show you how to use the ES6 module in WasmEdge.

## Prerequisites

[See here](./hello_world#prerequisites)

## Run the example

We will take the example in [example_js/es6_module_demo](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/es6_module_demo) folder as an example. To run the example, you can do the following on the CLI.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/es6_module_demo/demo.js
hello from module_def.js
hello from module_def_async.js
./module_def_async.js `something` is  async thing
```

<!-- prettier-ignore -->
:::note
Make sure that you run those commands from the `wasmedge-quickjs` directory. [Here is why](./hello_world#prerequisites)
:::

## Code Explanation

The [module_def.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def.js) file defines and exports a simple JS function.

```javascript
function hello() {
  console.log('hello from module_def.js');
}

export { hello };
```

The [module_def_async.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def_async.js) file defines and exports an async function and a variable.

```javascript
export async function hello() {
  console.log('hello from module_def_async.js');
  return 'module_def_async.js : return value';
}

export var something = 'async thing';
```

The [demo.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/demo.js) file imports functions and variables from those modules and executes them.

```javascript
import { hello as module_def_hello } from './module_def.js';

module_def_hello();

var f = async () => {
  let { hello, something } = await import('./module_def_async.js');
  await hello();
  console.log('./module_def_async.js `something` is ', something);
};

f();
```
","**Summary**

This code is a documentation page for using ES6 modules in the WasmEdge QuickJS runtime. It provides a step-by-step guide on how to use ES6 modules, including setting up prerequisites, running examples, and explaining the code behind it.

**Key Components**

1. **ES6 Module Support**: The WasmEdge QuickJS runtime supports ES6 modules.
2. **Prerequisites**: A link to another documentation page that outlines the necessary setup for using WasmEdge QuickJS.
3. **Run Example**: A command to run an example using the `wasmedge` CLI, demonstrating how to execute ES6 module code in WasmEdge QuickJS.
4. **Code Explanation**: An explanation of three JavaScript files: `module_def.js`, `module_def_async.js`, and `demo.js`. Each file is linked to a GitHub repository and includes code examples.

**Potential Issues or Areas for Improvement**

1. **Inconsistent Formatting**: The code snippets in the documentation have different formatting styles, which may make them harder to read.
2. **Lack of Context**: Some explanations assume prior knowledge of WasmEdge QuickJS and its ecosystem, making it challenging for readers without this context to understand the example code.
3. **No Error Handling**: The `demo.js` file does not include error handling mechanisms, which may lead to unexpected behavior or crashes if the imports or executions fail.
4. **Code Duplication**: The `module_def.js` and `module_def_async.js` files have similar export structures, which could be refactored for better maintainability.

**Recommendations**

1. Standardize code formatting throughout the documentation.
2. Provide more context and explanations for readers new to WasmEdge QuickJS.
3. Include error handling mechanisms in the example code (e.g., try-catch blocks).
4. Consider refactoring the code structure to minimize duplication and improve maintainability."
docs/develop/rust/command.md,"---
sidebar_position: 11
---

# Command interface

WASI enables WebAssembly programs to call standard library functions in the host operating system. It does so through a fine-grained security model known as “capability-based security”. The WebAssembly VM owner can grant access to host system resources when the VM starts. The program cannot access resources (e.g., file folders) that are not explicitly allowed.

Now, why limit ourselves to standard library functions? The same approach can call just any host function from WebAssembly. WasmEdge provides a WASI-like extension to access command line programs in the host operating system.

The command line program can

- Take input via command line arguments and the `STDIN` stream.
- Return value and data via the `STDOUT` stream.

Application developers for WasmEdge can use our Rust interface crate to access this functionality. In `Cargo.toml`, ensure you have this dependency.

```toml
[dependencies]
wasmedge_process_interface = ""0.2.1""
```

In the Rust application, you can now use the API methods to start a new process for the operating system command program, pass in arguments via the `arg()` method as well as via the `STDIN`, and receives the return values via the `STDOUT`.

```rust
let mut cmd = Command::new(""http_proxy"");

cmd.arg(""post"")
   .arg(""https://api.sendgrid.com/v3/mail/send"")
   .arg(auth_header);
cmd.stdin_u8vec(payload.to_string().as_bytes());

let out = cmd.output();
```

The Rust function is then compiled into WebAssembly and can run in the WasmEdge like the [hello world](hello_world.md) chapter.
","**Summary**

The code provides a Rust interface for interacting with command-line programs on the host operating system using WasmEdge's WASI-like extension. This allows WebAssembly programs to call any host function, not just standard library functions.

**Key Components**

1. The `wasmedge_process_interface` crate is used as a dependency in `Cargo.toml`.
2. The `Command` struct provides methods for creating and configuring a new process.
3. Methods include:
	* `arg()`: passing command-line arguments to the process.
	* `stdin_u8vec()`: sending input data (in this case, bytes) to the process via STDIN.
4. The `output()` method is used to receive the return values from the process via STDOUT.

**Purpose**

The purpose of this code is to enable WebAssembly programs running on WasmEdge to interact with command-line programs on the host operating system. This can be useful for applications that need to perform system-level tasks, such as sending emails or making HTTP requests.

**Potential Issues/Improvements**

1. **Error handling**: The example does not demonstrate error handling. In a real-world scenario, it's essential to handle potential errors when interacting with external processes.
2. **Security**: As with any external process interaction, there are security implications to consider. Ensure that the process being executed is trusted and validated.
3. **Performance**: If the command-line program is resource-intensive or has long-running operations, it may impact the performance of the WebAssembly application.
4. **Documentation**: The example code could benefit from additional comments and documentation to help users understand how to use the `Command` struct effectively.

Overall, this code provides a useful interface for interacting with command-line programs on WasmEdge, but careful consideration should be given to error handling, security, performance, and documentation."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/command.md,"---
sidebar_position: 11
---

# Command interface

WASI enables WebAssembly programs to call standard library functions in the host operating system. It does so through a fine-grained security model known as “capability-based security”. The WebAssembly VM owner can grant access to host system resources when the VM starts. The program cannot access resources (e.g., file folders) that are not explicitly allowed.

Now, why limit ourselves to standard library functions? The same approach can call just any host function from WebAssembly. WasmEdge provides a WASI-like extension to access command line programs in the host operating system.

The command line program can

- Take input via command line arguments and the `STDIN` stream.
- Return value and data via the `STDOUT` stream.

Application developers for WasmEdge can use our Rust interface crate to access this functionality. In `Cargo.toml`, ensure you have this dependency.

```toml
[dependencies]
wasmedge_process_interface = ""0.2.1""
```

In the Rust application, you can now use the API methods to start a new process for the operating system command program, pass in arguments via the `arg()` method as well as via the `STDIN`, and receives the return values via the `STDOUT`.

```rust
let mut cmd = Command::new(""http_proxy"");

cmd.arg(""post"")
   .arg(""https://api.sendgrid.com/v3/mail/send"")
   .arg(auth_header);
cmd.stdin_u8vec(payload.to_string().as_bytes());

let out = cmd.output();
```

The Rust function is then compiled into WebAssembly and can run in the WasmEdge like the [hello world](hello_world.md) chapter.
","**Summary**

This code is a part of the Docusaurus documentation for the WasmEdge project, specifically detailing how to use the `wasmedge_process_interface` Rust crate to interact with command-line programs on the host operating system from within WebAssembly (WASM) applications.

**Key Components**

1. The WASM interface allows developers to run host OS commands as part of a WASM application.
2. The code uses the `wasmedge_process_interface` Rust crate to access this functionality.
3. Developers can use API methods to start new processes for command-line programs, passing arguments and receiving output.

**Functionality**

1. **Command creation**: Create a new process for running a command using the `Command::new()` method.
2. **Argument passing**: Pass arguments to the command using the `arg()` method.
3. **Input/output handling**: Use `stdin_u8vec()` to pass input data and `output()` to receive the return value of the command.

**Potential Issues or Areas for Improvement**

1. Error handling: The code does not demonstrate error handling mechanisms, which is crucial when interacting with external processes and OS resources.
2. Security considerations: As this allows execution of arbitrary host commands from within WASM, additional security measures might be necessary to prevent potential exploits.
3. Documentation completeness: While the provided code snippet is self-explanatory, it would be beneficial to provide more detailed documentation on how to use the `wasmedge_process_interface` crate and its API methods.

**Notes**

This summary is based on the provided Markdown file. The actual code might be located elsewhere in the project repository."
docs/develop/deploy/kubernetes/docker-slim.md,"---
sidebar_position: 11
---

# WasmEdge DockerSlim

The `wasmedge/slim:{version}` Docker images provide slim WasmEdge images built with [DockerSlim](https://dockersl.im) every release.

- Image `wasmedge/slim-runtime:{version}` includes only WasmEdge runtime with `wasmedge` command.
- Image `wasmedge/slim:{version}` includes the following command line utilities:
  - `wasmedge`
  - `wasmedge compile`
- Image `wasmedge/slim-tf:{version}` includes the following command line utilities:
  - `wasmedge`
  - `wasmedge compile`
  - `wasmedge-tensorflow-lite`
  - `wasmedge-tensorflow`
  - `show-tflite-tensor`
- The working directory of the release docker image is `/app`.

<!-- prettier-ignore -->
:::note
The usage of `wasmedgec` is equal to `wasmedge compile`. We decide to deprecate `wasmedgec` in the future.
:::

## Examples

Use `wasmedge compile` and `wasmedge` ([link](https://github.com/WasmEdge/WasmEdge/tree/master/examples/wasm)):

```bash
$ docker pull wasmedge/slim:{{ wasmedge_version }}

$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge compile hello.wasm hello.aot.wasm
[2022-07-07 08:15:49.154] [info] compile start
[2022-07-07 08:15:49.163] [info] verify start
[2022-07-07 08:15:49.169] [info] optimize start
[2022-07-07 08:15:49.808] [info] codegen start
[2022-07-07 08:15:50.419] [info] output start
[2022-07-07 08:15:50.421] [info] compile done
[2022-07-07 08:15:50.422] [info] output start

$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge hello.aot.wasm world
hello
world
```

Use `wasmedge-tensorflow-lite` ([link](https://github.com/WasmEdge/WasmEdge/tree/master/examples/js)):

```bash
$ docker pull wasmedge/slim-tf:{{ wasmedge_version }}
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js

$ docker run -it --rm -v $PWD:/app wasmedge/slim-tf:{{ wasmedge_version }} wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js
label:
Hot dog
confidence:
0.8941176470588236
```
","**Summary**

The provided code documents the usage of `wasmedge/slim:{version}` Docker images, which are slim WasmEdge images built with DockerSlim. These images include various command-line utilities for compiling and running WebAssembly (WASM) code.

**Key Components**

1. **Docker Images**: Three types of Docker images are available:
	* `wasmedge/slim-runtime:{version}`: includes only the WasmEdge runtime with the `wasmedge` command.
	* `wasmedge/slim:{version}`: includes `wasmedge`, `wasmedge compile` utilities.
	* `wasmedge/slim-tf:{version}`: includes all the above utilities plus `wasmedge-tensorflow-lite`, `wasmedge-tensorflow`, and `show-tflite-tensor`.
2. **Working Directory**: The working directory of the release Docker image is `/app`.

**Examples**

Two examples are provided:

1. Compiling a WASM file using `wasmedge compile`:
```bash
$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge compile hello.wasm hello.aot.wasm
```
2. Running a TensorFlow Lite model using `wasmedge-tensorflow-lite`:
```bash
$ docker run -it --rm -v $PWD:/app wasmedge/slim-tf:{{ wasmedge_version }} wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js
```
**Notes**

* The usage of `wasmedgec` is deprecated in favor of `wasmedge compile`.
* The examples use Docker to run the WASM code and demonstrate how to compile and run a simple WASM program.
* The `wasmedge-tensorflow-lite` example requires additional dependencies, such as a TensorFlow Lite model and some JavaScript code.

**Potential Issues or Areas for Improvement**

1. **Docker Image Size**: The DockerSlim images are slim, but their size might still be larger than expected. Consider using other image optimization tools.
2. **Deprecation of `wasmedgec`**: Although deprecated, it's essential to ensure that users are aware of the replacement and don't rely on the old command.
3. **Additional Dependencies**: The TensorFlow Lite example requires additional dependencies, which might not be immediately apparent from the documentation.
4. **Documentation Updates**: Ensure that the documentation is up-to-date and reflects any changes or improvements made to the Docker images or examples."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/docker-slim.md,"---
sidebar_position: 11
---

# WasmEdge DockerSlim

The `wasmedge/slim:{version}` Docker images provide slim WasmEdge images built with [DockerSlim](https://dockersl.im) every release.

- Image `wasmedge/slim-runtime:{version}` includes only WasmEdge runtime with `wasmedge` command.
- Image `wasmedge/slim:{version}` includes the following command line utilities:
  - `wasmedge`
  - `wasmedge compile`
- Image `wasmedge/slim-tf:{version}` includes the following command line utilities:
  - `wasmedge`
  - `wasmedge compile`
  - `wasmedge-tensorflow-lite`
  - `wasmedge-tensorflow`
  - `show-tflite-tensor`
- The working directory of the release docker image is `/app`.

<!-- prettier-ignore -->
:::note
The usage of `wasmedgec` is equal to `wasmedge compile`. We decide to deprecate `wasmedgec` in the future.
:::

## Examples

Use `wasmedge compile` and `wasmedge` ([link](https://github.com/WasmEdge/WasmEdge/tree/master/examples/wasm)):

```bash
$ docker pull wasmedge/slim:{{ wasmedge_version }}

$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge compile hello.wasm hello.aot.wasm
[2022-07-07 08:15:49.154] [info] compile start
[2022-07-07 08:15:49.163] [info] verify start
[2022-07-07 08:15:49.169] [info] optimize start
[2022-07-07 08:15:49.808] [info] codegen start
[2022-07-07 08:15:50.419] [info] output start
[2022-07-07 08:15:50.421] [info] compile done
[2022-07-07 08:15:50.422] [info] output start

$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge hello.aot.wasm world
hello
world
```

Use `wasmedge-tensorflow-lite` ([link](https://github.com/WasmEdge/WasmEdge/tree/master/examples/js)):

```bash
$ docker pull wasmedge/slim-tf:{{ wasmedge_version }}
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js

$ docker run -it --rm -v $PWD:/app wasmedge/slim-tf:{{ wasmedge_version }} wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js
label:
Hot dog
confidence:
0.8941176470588236
```
","**Summary**

The provided code is a documentation for WasmEdge DockerSlim images. It explains the purpose and functionality of three different images:

1. `wasmedge/slim-runtime:{version}`: A slim WasmEdge image with only the runtime and `wasmedge` command.
2. `wasmedge/slim:{version}`: A slim WasmEdge image with additional command line utilities, including `wasmedge`, `wasmedge compile`, and possibly others in the future.
3. `wasmedge/slim-tf:{version}`: A slim WasmEdge image with TensorFlow Lite and TensorFlow support.

The documentation provides examples of using these images to run WasmEdge commands and demonstrates how to use specific features, such as compiling and running Wasm files and running TensorFlow Lite models.

**Key Components**

1. **Images**: The three Docker images are the primary focus of this documentation.
2. **Commands**: Various `wasmedge` commands are used throughout the examples, including `wasmedge compile`, `wasmedge`, `wasmedge-tensorflow-lite`, and others.
3. **Examples**: Real-world usage scenarios are provided to demonstrate how to use these images and commands.

**Potential Issues or Areas for Improvement**

1. **Lack of explicit dependencies**: While the examples rely on specific versions of Docker, WasmEdge, and other tools, the documentation does not explicitly list these dependencies.
2. **Assumed familiarity with Docker**: The examples assume a basic understanding of Docker and how to work with images, which may be a barrier for some readers.
3. **Missing context**: Some sections, such as the deprecation note about `wasmedgec`, feel disconnected from the rest of the documentation without additional context.

**Suggestions**

1. **Add explicit dependencies**: List the specific versions of Docker, WasmEdge, and other tools required to run these examples.
2. **Improve example clarity**: Consider breaking down complex examples into smaller, more manageable chunks or providing additional explanations for readers who may be new to Docker or WasmEdge.
3. **Provide additional context**: Connect related sections or add a brief introduction to explain the purpose of each image and its relationship to other WasmEdge features."
docs/embed/overview.md,"---
sidebar_position: 1
displayed_sidebar: embedSidebar
---

# Embed WasmEdge in Your Apps

As we mentioned before, the most important use case for WasmEdge is to safely execute user-defined or community-contributed code as plug-ins in a software product. It enables third-party developers, vendors, suppliers, and community members to extend and customize the software product.

We could use WasmEdge as a standalone container and deploy WasmEdge using the existing containers tools. The other way is to use WasmEdge as an embedded runtime and manage WasmEdge using the host applications.

WasmEdge provides SDKs for various programming languages. The WasmEdge library allows developers to embed the WasmEdge into their host applications, so that the WebAssembly applications can be executed in the WasmEdge sandbox safely. Furthermore, developers can implement the host functions for the extensions with the WasmEdge library.

![Embeded architecture](embed_arch.png)

In this section, we will walk you through how to embed WasmEdge in different languages. We will cover the following content:

- [Quick Start](/category/quick-start)
- [Passing complex data](/category/passing-complex-data)
- [Developing components using witc](witc.md)
- [Embed WasmEdge in C/C++](/category/c-sdk-for-embedding-wasmedge)
- [Embed WasmEdge in Rust](/category/rust-sdk-for-embedding-wasmedge)
- [Embed WasmEdge in Go](/category/go-sdk-for-embedding-wasmedge)
- [Embed WasmEdge in Java](/category/java-sdk-for-embedding-wasmedge)
- [Embed WasmEdge in Python](/category/python-sdk-for-embedding-wasmedge)
- [Use cases](/category/use-cases)

Besides this, we also have two more guides for [developing WASM apps](../develop/overview.md) and [contributing to WasmEdge](../contribute/overview.md).
","**Summary**

The provided code is a documentation section titled ""Embed WasmEdge in Your Apps"" from the docs/embed/overview.md file. It explains the purpose and functionality of embedding WasmEdge, a WebAssembly runtime, into various applications.

**Key Components**

1. **WasmEdge**: A WebAssembly runtime that allows for safe execution of user-defined or community-contributed code as plug-ins.
2. **Embedded Architecture**: An illustration showing how to embed WasmEdge in host applications.
3. **SDKs for Various Programming Languages**: Pre-built libraries for embedding WasmEdge into applications written in C/C++, Rust, Go, Java, and Python.

**Purpose**

The main goal of this documentation section is to guide developers through the process of embedding WasmEdge into their applications, providing SDKs and examples for various programming languages. It aims to enable developers to safely execute WebAssembly applications within their host applications.

**Potential Issues or Areas for Improvement**

1. **Lack of Code Examples**: While the documentation provides an overview of the process, it would be beneficial to include code examples for each programming language to help developers understand how to implement WasmEdge in their projects.
2. **SDKs and Libraries**: Although mentioned as being available, there is no information on where to download or access these SDKs and libraries, which may cause confusion for developers looking to integrate WasmEdge into their applications.
3. **Documentation Organization**: The documentation seems to be organized around different programming languages, but it would be more user-friendly if it were organized by use case or application type instead.

Overall, the provided code is a solid foundation for documenting how to embed WasmEdge in various applications. However, adding code examples and improving SDK accessibility will make this documentation more comprehensive and helpful for developers seeking to integrate WasmEdge into their projects."
i18n/zh/docusaurus-plugin-content-docs/current/embed/overview.md,"---
sidebar_position: 1
displayed_sidebar: embedSidebar
---

# Embed WasmEdge in Your Apps

As we mentioned before, the most important use case for WasmEdge is to safely execute user-defined or community-contributed code as plug-ins in a software product. It enables third-party developers, vendors, suppliers, and community members to extend and customize the software product.

We could use WasmEdge as a standalone container and deploy WasmEdge using the existing containers tools. The other way is to use WasmEdge as an embedded runtime and manage WasmEdge using the host applications.

WasmEdge provides SDKs for various programming languages. The WasmEdge library allows developers to embed the WasmEdge into their host applications, so that the WebAssembly applications can be executed in the WasmEdge sandbox safely. Furthermore, developers can implement the host functions for the extensions with the WasmEdge library.

![Embeded architecture](embed_arch.png)

In this section, we will walk you through how to embed WasmEdge in different languages. We will cover the following content:

- [Quick Start](/category/quick-start)
- [Passing complex data](/category/passing-complex-data)
- [Developing components using witc](witc.md)
- [Embed WasmEdge in C/C++](/category/c-sdk-for-embedding-wasmedge)
- [Embed WasmEdge in Rust](/category/rust-sdk-for-embedding-wasmedge)
- [Embed WasmEdge in Go](/category/go-sdk-for-embedding-wasmedge)
- [Embed WasmEdge in Java](/category/java-sdk-for-embedding-wasmedge)
- [Embed WasmEdge in Python](/category/python-sdk-for-embedding-wasmedge)
- [Use cases](/category/use-cases)

Besides this, we also have two more guides for [developing WASM apps](../develop/overview.md) and [contributing to WasmEdge](../contribute/overview.md).
","**Summary**

The provided code is a Markdown document that serves as an overview of embedding WasmEdge, a WebAssembly runtime, into various host applications. The document outlines the benefits of using WasmEdge, its architecture, and provides links to guides for embedding it in different programming languages (C/C++, Rust, Go, Java, Python). Additionally, it mentions use cases and points readers to more resources on developing WASM apps and contributing to WasmEdge.

**Key Components**

1. **Overview**: The document introduces the purpose of embedding WasmEdge into host applications.
2. **Benefits**: It highlights the advantages of using WasmEdge as a sandboxed runtime for executing user-defined code.
3. **Architecture**: A diagram illustrates how WasmEdge can be embedded into host applications, providing a secure execution environment for WebAssembly apps.
4. **Guides**: The document links to guides for embedding WasmEdge in different languages (C/C++, Rust, Go, Java, Python).
5. **Use Cases**: It mentions various use cases where WasmEdge can be applied.

**Potential Issues or Areas for Improvement**

1. **Outdated information**: The content might not reflect the current state of WasmEdge or its SDKs.
2. **Lack of code examples**: While links to guides are provided, actual code examples in this document would make it more helpful for readers.
3. **Typos and formatting issues**: Minor errors in formatting or grammar could be present.
4. **Incomplete information**: Some sections might not provide sufficient detail or context.

Overall, the document is well-structured and provides a clear overview of embedding WasmEdge into host applications. However, it would benefit from more detailed code examples, up-to-date information, and additional resources to enhance its value for readers."
docs/develop/python/hello_world.md,"---
sidebar_position: 1
---

# Python

Several different language implementations of the Python runtime exist, and some of them support WebAssembly. This document will describe how to run [RustPython](https://github.com/RustPython/RustPython) on WasmEdge to execute Python programs.

## Compile RustPython

To compile RustPython, you should install the Rust toolchain on your machine. And `wasm32-wasi` platform support should be enabled.

```bash
rustup target add wasm32-wasi
```

Then you could use the following command to clone and compile RustPython:

```bash
git clone https://github.com/RustPython/RustPython.git
cd RustPython
cargo build --release --target wasm32-wasi --features=""freeze-stdlib""
```

`freeze-stdlib` feature is enabled for including Python standard library inside the binary file. The output file should be at `target/wasm32-wasi/release/rustpython.wasm`.

## AOT Compile

WasmEdge supports compiling WebAssembly bytecode programs into native machine code for better performance. It is highly recommended to compile the RustPython to native machine code before running.

```bash
wasmedge compile ./target/wasm32-wasi/release/rustpython.wasm ./target/wasm32-wasi/release/rustpython.wasm
```

## Run

```bash
wasmedge ./target/wasm32-wasi/release/rustpython.wasm
```

Then you could get a Python shell in WebAssembly!

## Grant file system access

You can pre-open directories to let WASI programs have permission to read and write files stored on the real machine. The following command mounted the current working directory to the WASI virtual file system.

```bash
wasmedge --dir .:. ./target/wasm32-wasi/release/rustpython.wasm
```
","**Summary**

This document provides a step-by-step guide on how to run RustPython, a language implementation of Python in WebAssembly (Wasm), using the WasmEdge runtime. The guide covers compiling RustPython from source, AOT compiling the resulting Wasm file for better performance, and running the compiled RustPython.

**Key Components**

1. **Rustup**: A toolchain installer used to add the `wasm32-wasi` platform support.
2. **Cargo**: A package manager used to build RustPython from source.
3. **WasmEdge**: A WebAssembly runtime that supports compiling Wasm bytecode into native machine code and providing file system access.
4. **RustPython**: A language implementation of Python in Rust, compiled to Wasm.

**Functionality**

The guide enables users to:

1. Compile RustPython from source using Cargo.
2. AOT compile the resulting Wasm file for better performance.
3. Run the compiled RustPython using WasmEdge, which provides a Python shell in WebAssembly.

**Potential Issues or Areas for Improvement**

1. **Dependencies**: The document assumes that the reader has the necessary dependencies (Rust toolchain and WasmEdge) installed on their machine. Providing installation instructions or links to resources may be helpful.
2. **Error Handling**: While the guide provides basic error handling, it does not cover potential issues that may arise during compilation or execution of RustPython. Adding more robust error handling mechanisms may be beneficial.
3. **Performance Optimization**: The document suggests AOT compiling the Wasm file for better performance but does not provide additional optimization techniques. Exploring other performance enhancement methods (e.g., Just-In-Time compilation) may be worth investigating."
i18n/zh/docusaurus-plugin-content-docs/current/develop/python/hello_world.md,"---
sidebar_position: 1
---

# Python

Several different language implementations of the Python runtime exist, and some of them support WebAssembly. This document will describe how to run [RustPython](https://github.com/RustPython/RustPython) on WasmEdge to execute Python programs.

## Compile RustPython

To compile RustPython, you should install the Rust toolchain on your machine. And `wasm32-wasi` platform support should be enabled.

```bash
rustup target add wasm32-wasi
```

Then you could use the following command to clone and compile RustPython:

```bash
git clone https://github.com/RustPython/RustPython.git
cd RustPython
cargo build --release --target wasm32-wasi --features=""freeze-stdlib""
```

`freeze-stdlib` feature is enabled for including Python standard library inside the binary file. The output file should be at `target/wasm32-wasi/release/rustpython.wasm`.

## AOT Compile

WasmEdge supports compiling WebAssembly bytecode programs into native machine code for better performance. It is highly recommended to compile the RustPython to native machine code before running.

```bash
wasmedge compile ./target/wasm32-wasi/release/rustpython.wasm ./target/wasm32-wasi/release/rustpython.wasm
```

## Run

```bash
wasmedge ./target/wasm32-wasi/release/rustpython.wasm
```

Then you could get a Python shell in WebAssembly!

## Grant file system access

You can pre-open directories to let WASI programs have permission to read and write files stored on the real machine. The following command mounted the current working directory to the WASI virtual file system.

```bash
wasmedge --dir .:. ./target/wasm32-wasi/release/rustpython.wasm
```
","**Summary**

This code provides a guide on how to run RustPython, a Rust implementation of Python, on WasmEdge, a WebAssembly runtime. The process involves compiling RustPython using the `cargo build` command with specific flags and features, AOT (Ahead-of-Time) compiling the resulting WASM bytecode using `wasmedge compile`, and finally running the compiled RustPython binary.

**Key Components**

1. **Compile RustPython**: This section explains how to install the Rust toolchain, enable `wasm32-wasi` platform support, clone and compile RustPython using `cargo build`.
2. **AOT Compile**: This step shows how to AOT compile the RustPython WASM bytecode into native machine code for better performance.
3. **Run**: The final section explains how to run the compiled RustPython binary using `wasmedge`.
4. **Grant file system access**: This optional step demonstrates how to pre-open directories to grant RustPython permission to read and write files on the real machine.

**Potential Issues or Areas for Improvement**

1. **Compilation flags**: The guide assumes that the reader knows which compilation flags to use (e.g., `--release` and `--features=""freeze-stdlib""`). It may be helpful to explain these options in more detail.
2. **Error handling**: The guide does not mention how to handle potential compilation errors or issues with AOT compilation.
3. **Performance considerations**: While the guide recommends AOT compiling for performance, it does not provide any guidance on optimizing RustPython for WasmEdge or measuring its performance.
4. **Security**: As with any system that executes arbitrary code, there may be security concerns when running RustPython on WasmEdge. The guide should acknowledge these risks and provide guidance on mitigating them.

Overall, the code provides a clear guide to setting up and running RustPython on WasmEdge. However, it would benefit from additional explanations and considerations to make it more accessible and robust for users."
i18n/zh/docusaurus-plugin-content-docs/current/start/wasmedge/extensions/unique_extensions.md,"---
sidebar_position: 3
---

# 其他扩展

在服务器端运行 WASM 应用的挑战之一是缺乏对 Linux API 和常用应用程序库的支持。WasmEdge 通过为 WASM 应用程序添加许多平台 API 的支持来解决这个问题。开发人员通常可以简单地将他们的 Linux 应用编译成 WASM，并期望在 WasmEdge 中运行。WasmEdge 为社区提供了一种简单的扩展机制来添加这些 API。例如，

通过其对网络套接字和相关 API 的支持，WasmEdge 可以运行 Rust 应用程序，实现以下功能：

- [提供HTTP服务](https://github.com/WasmEdge/wasmedge_hyper_demo)
- [访问外部网络服务](https://github.com/WasmEdge/wasmedge_reqwest_demo)
- [连接到数据库](https://github.com/WasmEdge/wasmedge-db-examples)
- [连接到消息队列](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql)
- [支持基于数据库的微服务](https://github.com/second-state/microservice-rust-mysql)
- [支持具有Dapr边车的微服务](https://github.com/second-state/dapr-wasm)

此外，网络套接字 API 还允许我们在 WasmEdge 的 JavaScript 运行时中支持 Node.js API，包括 `server` 和 `fetch()`。

通过其对 WASI-NN API 的支持，WasmEdge 可以支持用于 AI 推理的 Rust 和 JavaScript 应用程序。来自流行 AI 框架（如 Tensorflow、PyTorch 和 OpenVINO）的模型[都已经得到了支持](https://github.com/second-state/WasmEdge-WASINN-examples)。

## 可用扩展

这些扩展可以通过 WasmEdge 安装程序轻松安装。它们也可以包含在用于 Docker、Podman 和 Kubernetes 应用程序的 WASM 容器映像中。

| 名称 | 描述 | 平台支持 | 语言支持 | 备注 |
| --- | --- | --- | --- | --- |
| 网络套接字 | 支持异步（非阻塞）的 POSIX 网络套接字 | Linux | Rust、JavaScript、C | 支持诸如 tokio（Rust）和 node（JavaScript）等流行库 |
| DNS | 支持网络套接字中的 DNS 域名 | Linux | Rust、JavaScript、C | 支持诸如 tokio（Rust）和 node（JavaScript）等流行库 |
| 域套接字 | 支持进程之间的高性能数据交换 | Linux | Rust、JavaScript、C |  |
| TLS | 支持从网络套接字进行 TLS 和 HTTPS 连接 | Linux | Rust、JavaScript、C |  |
| KV 存储 | 允许 WebAssembly 程序读写键值存储 | Linux | Rust |  |
| [以太坊](https://github.com/second-state/wasmedge-evmc) | 支持编译为 WebAssembly 的以太坊智能合约。 | Linux | 无 | 它是以太坊风格的 WebAssembly（Ewasm）的主要实现。 |
| [Substrate](https://github.com/second-state/substrate-ssvm-node) | [Pallet](https://github.com/second-state/pallet-ssvm) 允许 WasmEdge 在任何基于 Substrate 的区块链上作为以太坊智能合约执行引擎。 | Linux | 无 |  |
","**Summary:**

The code is a Markdown document that explains the unique extensions supported by WasmEdge, a WebAssembly runtime. These extensions aim to bridge the gap between WebAssembly and Linux APIs, enabling developers to run their WASM applications on servers with ease. The extensions include support for network sockets, DNS, domain sockets, TLS, key-value storage, and Ethereum smart contracts.

**Key Components:**

1. **Network Sockets**: Enables asynchronous (non-blocking) POSIX network sockets.
2. **DNS**: Supports DNS resolution within network sockets.
3. **Domain Sockets**: Allows high-performance data exchange between processes.
4. **TLS**: Supports TLS and HTTPS connections from network sockets.
5. **KV Storage**: Enables WebAssembly programs to read and write key-value storage.
6. **Ethereum**: Supports compiled Ethereum smart contracts.
7. **Substrate**: Pallet allows WasmEdge to execute as an Ethereum virtual machine on any Substrate-based blockchain.

**Potential Issues or Areas for Improvement:**

1. **Platform Support**: The document primarily focuses on Linux, which might limit its applicability to other platforms.
2. **Language Support**: Although the document mentions Rust and JavaScript support, it would be beneficial to expand language support to include more languages, such as C++ or Python.
3. **Documentation Quality**: While the document provides a good overview of WasmEdge's unique extensions, some sections could benefit from more detailed explanations and examples.

**Recommendations:**

1. Expand platform support to include Windows and macOS.
2. Enhance language support to include more languages.
3. Improve documentation quality by providing more detailed explanations, examples, and code snippets."
README.md,"# WasmEdge Docs

![WasmEdge Logo](https://github.com/WasmEdge/.github/raw/main/profile/wasmedge-runtime-logo.png)

This repo contains technical documentation for the [WasmEdge Runtime](https://github.com/WasmEdge/WasmEdge) project. The documentation website built from this repo is published <https://wasmedge.org/docs/>, check it out!

## Setting up the Docs Locally

To set up the WasmEdge Docs locally, you will need to follow these general steps:

1. **Clone the project:** Go to the GitHub repository page of the WasmEdge Docs project and click on the ""Code"" button to get the URL of the repository. Then, open a terminal or command prompt and type the following command:

   ```bash
   git clone https://github.com/WasmEdge/docs.git
   ```

2. **Install dependencies:** Navigate to the project directory in the terminal and run the following command to install the necessary dependencies:

   ```bash
   npm install
   ```

3. **Start the development server:** Once the dependencies are installed, you can start the development server by running the following command:

   ```bash
   npm start
   ```

This should start the development server on port 3000. You can access the running application by opening a web browser and navigating to <http://localhost:3000/docs/>.

That's it! You should now have a local instance of the WasmEdge Docs running on your machine.
","**Summary:**

This is a README file for the WasmEdge Docs project, which contains technical documentation for the WasmEdge Runtime. The project provides instructions on how to set up and run the documentation website locally using Git and npm.

**Key Components:**

1. Clone the project repository from GitHub
2. Install dependencies using `npm install`
3. Start the development server using `npm start`

**Functionality:**

The code sets up a local instance of the WasmEdge Docs, allowing developers to view and contribute to the documentation.

**Potential Issues or Areas for Improvement:**

1. **Error handling**: The instructions do not provide guidance on how to handle errors that may occur during the setup process.
2. **Dependency management**: The use of `npm install` implies that the dependencies are managed using npm, but it would be more robust to specify exact versions or use a tool like yarn.
3. **Development server configuration**: The instructions do not provide any information on how to configure the development server (e.g., setting environment variables).
4. **Security considerations**: Running a development server on port 3000 may pose security risks, and it would be better to specify a more secure port or use a reverse proxy.

**Recommendations:**

1. Add error handling mechanisms to the instructions.
2. Specify exact dependency versions or recommend using yarn for dependency management.
3. Provide configuration options for the development server.
4. Consider specifying alternative ports or using a reverse proxy for enhanced security."
docs/embed/use-case/serverless-saas.md,"---
sidebar_position: 5
---

# Serverless Software-As-A-Service Functions

WasmEdge can support customized SaaS extensions or applications using serverless functions instead of traditional network APIs. That dramatically improves SaaS users' and developers' productivity.

- WasmEdge could be embedded into SaaS products to execute user-defined functions. In this scenario, the WasmEdge function API replaces the SaaS web API. The embedded WasmEdge functions are much faster, safer, and easier to use than RPC functions over the web.
- Edge servers could provide WasmEdge-based containers to interact with existing SaaS or PaaS APIs without requiring the user to run his servers (e.g., callback servers). The serverless API services can be co-located in the same networks as the SaaS to provide optimal performance and security.

The examples below showcase how WasmEdge-based serverless functions connect SaaS APIs from different services and process data flows across those SaaS APIs according to each user's business logic.

## Slack

- [Build a serverless chatbot for Slack](http://reactor.secondstate.info/en/docs/user_guideline.html)

## Lark

It is also known as `飞书`, aka the Chinese Slack. Byte Dance, the parent company of Tiktok, creates it.

- [Build a serverless chatbot for Lark](http://reactor.secondstate.info/en/docs/user_guideline.html)
","**Summary**

The provided code is a documentation snippet that describes how WasmEdge can be used to build customized Software-As-A-Service (SaaS) extensions or applications using serverless functions. The goal is to improve users' and developers' productivity by replacing traditional network APIs with faster, safer, and easier-to-use WasmEdge function APIs.

**Key Components**

1. **WasmEdge**: A cloud-native, high-performance WebAssembly runtime that can be embedded into SaaS products.
2. **Serverless functions**: Customized code executed on demand, without the need for server management.
3. **Embedded WasmEdge functions**: Replace traditional web APIs, providing faster and safer interactions with SaaS services.
4. **Edge servers**: Provide WasmEdge-based containers to interact with existing SaaS or Platform-as-a-Service (PaaS) APIs.

**Functionality**

1. **WasmEdge embedded into SaaS products**: Execute user-defined functions directly within the SaaS product, reducing latency and improving performance.
2. **Edge servers provide WasmEdge-based containers**: Allow users to interact with existing SaaS or PaaS APIs without running their own callback servers.

**Potential Issues or Areas for Improvement**

1. **Security risks**: As with any serverless architecture, there is a risk of security vulnerabilities if not properly managed and secured.
2. **Scalability limitations**: Serverless functions may not be suitable for large-scale applications or high-traffic scenarios, requiring additional infrastructure scaling.
3. **Developer complexity**: The adoption of WasmEdge-based serverless functions may require significant development efforts to ensure smooth integration with existing SaaS services.

Overall, this documentation provides a good overview of the benefits and functionality of using WasmEdge for building customized SaaS extensions or applications with serverless functions."
i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/serverless-saas.md,"---
sidebar_position: 5
---

# Serverless Software-As-A-Service Functions

WasmEdge can support customized SaaS extensions or applications using serverless functions instead of traditional network APIs. That dramatically improves SaaS users' and developers' productivity.

- WasmEdge could be embedded into SaaS products to execute user-defined functions. In this scenario, the WasmEdge function API replaces the SaaS web API. The embedded WasmEdge functions are much faster, safer, and easier to use than RPC functions over the web.
- Edge servers could provide WasmEdge-based containers to interact with existing SaaS or PaaS APIs without requiring the user to run his servers (e.g., callback servers). The serverless API services can be co-located in the same networks as the SaaS to provide optimal performance and security.

The examples below showcase how WasmEdge-based serverless functions connect SaaS APIs from different services and process data flows across those SaaS APIs according to each user's business logic.

## Slack

- [Build a serverless chatbot for Slack](http://reactor.secondstate.info/en/docs/user_guideline.html)

## Lark

It is also known as `飞书`, aka the Chinese Slack. Byte Dance, the parent company of Tiktok, creates it.

- [Build a serverless chatbot for Lark](http://reactor.secondstate.info/en/docs/user_guideline.html)
","**Summary**

This document describes how WasmEdge can be used to create customized SaaS extensions or applications using serverless functions. This approach replaces traditional network APIs, improving productivity for users and developers. The document highlights two main use cases:

1. **Embedded WasmEdge Functions**: WasmEdge is embedded into SaaS products to execute user-defined functions, replacing the traditional SaaS web API.
2. **Serverless Edge Servers**: Edge servers provide WasmEdge-based containers to interact with existing SaaS or PaaS APIs without requiring users to run their own servers.

The document also provides examples of how to connect SaaS APIs from different services and process data flows using WasmEdge-based serverless functions, showcasing its capabilities on two platforms:

1. **Slack**: Building a serverless chatbot for Slack.
2. **Lark (Chinese Slack)**: Building a serverless chatbot for Lark.

**Key Components**

* WasmEdge: A modular webAssembly runtime that enables serverless computing.
* SaaS APIs: Software-as-a-Service APIs used to connect services and process data flows.
* Serverless functions: WasmEdge-based functions that replace traditional network APIs.

**Potential Issues or Areas for Improvement**

* Limited documentation on implementing serverless chatbots for Lark (Chinese Slack).
* No code examples provided in the document, making it harder for developers to implement the use cases described.
* The user guide link is not specific to building a serverless chatbot and appears to be a generic user guideline.

**Recommendations**

* Add more detailed documentation on implementing serverless chatbots for Lark (Chinese Slack).
* Provide code examples or snippets to illustrate the implementation of WasmEdge-based serverless functions.
* Update the user guide link to make it specific to building a serverless chatbot."
i18n/zh/docusaurus-plugin-content-docs/current/start/wasmedge/comparison.md,"---
sidebar_position: 5
---

# 对比

## WebAssembly 与 Docker 之间的关系是什么？

请查看我们的信息图表 [WebAssembly vs. Docker](https://wasmedge.org/wasm_docker/)。在云原生和边缘原生应用中，WebAssembly 与 Docker 并驾齐驱。

## Native clients（NaCl）、应用程序运行时和 WebAssembly 之间有何区别？

我们创建了一个便捷的表格进行对比。

|  | NaCl | Application runtimes (eg Node &amp; Python) | Docker-like container | WebAssembly |
| --- | --- | --- | --- | --- |
| Performance | Great | Poor | OK | Great |
| Resource footprint | Great | Poor | Poor | Great |
| Isolation | Poor | OK | OK | Great |
| Safety | Poor | OK | OK | Great |
| Portability | Poor | Great | OK | Great |
| Security | Poor | OK | OK | Great |
| Language and framework choice | N/A | N/A | Great | OK |
| Ease of use | OK | Great | Great | OK |
| Manageability | Poor | Poor | Great | Great |

## WebAssembly 与 eBPF 有何区别？

`eBPF` 是适用于网络或安全相关任务的 Linux 内核空间虚拟机的字节码格式。而 WebAssembly 是适用于业务应用的用户空间虚拟机的字节码格式。[点击此处查看详细信息](https://medium.com/codex/ebpf-and-webassembly-whose-vm-reigns-supreme-c2861ce08f89)。
","**Summary**

This is a Markdown document comparing WebAssembly (WASM) to other technologies such as Docker, Native clients (NaCl), Application runtimes (e.g. Node & Python), and eBPF (extended Berkeley Packet Filter). The document aims to provide an overview of the differences between these technologies in terms of performance, resource footprint, isolation, safety, portability, security, language and framework choice, ease of use, and manageability.

**Key Components**

* Table comparing NaCl, Application runtimes, Docker-like container, and WebAssembly
	+ Performance: Great for WASM and NaCl, Poor for Application runtimes
	+ Resource footprint: Great for WASM and NaCl, Poor for Docker-like container
	+ Isolation: Poor for NaCl, OK for Application runtimes and Docker-like container, Great for WASM
* Comparison between WebAssembly and eBPF
	+ eBPF is a bytecode format for Linux kernel space virtual machine for networking or security tasks
	+ WebAssembly is a bytecode format for user space virtual machine for business applications

**Potential Issues**

* The table comparing NaCl, Application runtimes, Docker-like container, and WebAssembly may be confusing due to its format and the fact that some values are not clearly defined.
* The comparison between WebAssembly and eBPF seems brief and could benefit from more detailed information and examples.

**Areas for Improvement**

* Consider adding more concrete examples or case studies to illustrate the differences between these technologies.
* Provide more details on how to implement WebAssembly and eBPF in real-world scenarios.
* Consider creating a more organized and easy-to-read table comparing the different technologies."
docs/develop/overview.md,"---
sidebar_position: 1
displayed_sidebar: developSidebar
---

# Develop WASM Apps

A fundamental value proposition of WebAssembly is that it supports multiple programming languages. WebAssembly is a ""managed runtime"" for many programming languages including [C/C++](/category/develop-wasm-apps-in-cc), [Rust](/category/develop-wasm-apps-in-rust), [Go](/category/develop-wasm-apps-in-go), and even [JavaScript](/category/develop-wasm-apps-in-javascript) and [Python](/category/develop-wasm-apps-in-python).

- For compiled languages (e.g., C and Rust), WasmEdge WebAssembly provides a safe, secure, isolated, and containerized runtime as opposed to Native Client (NaCl).
- For interpreted or managed languages (e.g., JavaScript and Python), WasmEdge WebAssembly provides a secure, fast, lightweight, and containerized runtime instead of Docker + guest OS + native interpreter.

This chapter will discuss how to compile sources into WebAssembly in different languages and run them in WasmEdge.

- Develop WebAssembly apps from your programming languages from [Rust](/category/develop-wasm-apps-in-rust), [C/C++](/category/develop-wasm-apps-in-cc), [JavaScript](/category/develop-wasm-apps-in-javascript), [Go](/category/develop-wasm-apps-in-go), and many other languages.
- [Deploy WASM Apps with the existing container toolings](/category/deploy-wasmedge-apps-in-kubernetes)

Besides this, we also have two more guides for [Embedding WASM Functions](../embed/overview.md) and [Contributing](../contribute/overview.md) to WasmEdge.
","**Summary**

This code snippet is part of the documentation for developing WebAssembly (WASM) applications with WasmEdge. It highlights the benefits of using WASM, which supports multiple programming languages and provides a safe, secure, isolated, and containerized runtime environment. The text also outlines the different programming languages supported by WasmEdge, including C/C++, Rust, JavaScript, Python, Go, and many others.

**Key Components**

1. **Multiple language support**: WasmEdge supports development in multiple programming languages.
2. **Runtime benefits**: Provides a safe, secure, isolated, and containerized runtime environment for compiled languages (C and Rust) and a fast, lightweight, and containerized runtime environment for interpreted/managed languages (JavaScript and Python).
3. **Language-specific guides**: Links to documentation for developing WASM apps in specific programming languages.
4. **Deployment guide**: References a guide on deploying WASM apps with existing container toolings.

**Potential Issues or Areas for Improvement**

1. **Outdated links**: Some links may become outdated as the documentation evolves.
2. **Limited scope**: The text focuses primarily on developing and deploying WASM apps, but doesn't address other aspects of WasmEdge development (e.g., embedding WASM functions).
3. **Assumes prior knowledge**: Readers may need prior experience with WebAssembly or specific programming languages to fully understand the content.

**Recommendations**

1. Regularly review and update links to ensure they remain valid.
2. Expand the scope of the documentation to cover additional aspects of WasmEdge development.
3. Consider adding introductory sections to provide a more comprehensive understanding of WebAssembly and its benefits for readers without prior experience in the field."
i18n/zh/docusaurus-plugin-content-docs/current/develop/overview.md,"---
sidebar_position: 1
displayed_sidebar: developSidebar
---

# Develop WASM Apps

A fundamental value proposition of WebAssembly is that it supports multiple programming languages. WebAssembly is a ""managed runtime"" for many programming languages including [C/C++](/category/develop-wasm-apps-in-cc), [Rust](/category/develop-wasm-apps-in-rust), [Go](/category/develop-wasm-apps-in-go), and even [JavaScript](/category/develop-wasm-apps-in-javascript) and [Python](/category/develop-wasm-apps-in-python).

- For compiled languages (e.g., C and Rust), WasmEdge WebAssembly provides a safe, secure, isolated, and containerized runtime as opposed to Native Client (NaCl).
- For interpreted or managed languages (e.g., JavaScript and Python), WasmEdge WebAssembly provides a secure, fast, lightweight, and containerized runtime instead of Docker + guest OS + native interpreter.

This chapter will discuss how to compile sources into WebAssembly in different languages and run them in WasmEdge.

- Develop WebAssembly apps from your programming languages from [Rust](/category/develop-wasm-apps-in-rust), [C/C++](/category/develop-wasm-apps-in-cc), [JavaScript](/category/develop-wasm-apps-in-javascript), [Go](/category/develop-wasm-apps-in-go), and many other languages.
- [Deploy WASM Apps with the existing container toolings](/category/deploy-wasmedge-apps-in-kubernetes)

Besides this, we also have two more guides for [Embedding WASM Functions](../embed/overview.md) and [Contributing](../contribute/overview.md) to WasmEdge.
","**Summary:**

This documentation chapter focuses on developing WebAssembly (WASM) apps using various programming languages. The chapter outlines the benefits of using WasmEdge WebAssembly, which provides a safe, secure, isolated, and containerized runtime for compiled languages like C/C++ and Rust, and a secure, fast, lightweight, and containerized runtime for interpreted or managed languages like JavaScript and Python.

**Key Components:**

1. **Languages Support**: The chapter mentions that WasmEdge supports multiple programming languages, including C/C++, Rust, Go, JavaScript, and Python.
2. **WasmEdge WebAssembly Runtime**: Describes the benefits of using WasmEdge as a runtime environment for WASM apps, particularly for compiled and interpreted languages.
3. **Compilation and Execution**: Outlines how to compile sources into WebAssembly in different languages and run them in WasmEdge.
4. **Guides and Resources**: Provides links to additional guides on embedding WASM functions and contributing to WasmEdge.

**Potential Issues or Areas for Improvement:**

1. **Readability**: The chapter has a good structure, but some sections (e.g., ""For compiled languages..."") are quite long and could be broken down into shorter paragraphs for better readability.
2. **Consistency**: Some links in the chapter seem to point to internal documentation (e.g., `/category/develop-wasm-apps-in-rust`) while others point to external resources (e.g., Docker).
3. **Missing Context**: The chapter assumes some prior knowledge of WebAssembly and WasmEdge, which might make it challenging for readers new to the topic.

Overall, this is a well-structured and informative chapter that provides valuable insights into developing WASM apps using various programming languages with WasmEdge. However, some minor adjustments can be made to improve readability, consistency, and context."
i18n/zh/docusaurus-plugin-content-docs/current/start/wasmedge/integrations.md,"---
sidebar_position: 2
---

# WasmEdge 集成

WasmEdge 是云原生和边缘计算应用的“无服务器”运行时。它允许开发人员安全地将第三方或“本地”函数嵌入主机应用程序或分布式计算框架中。

## 将 WasmEdge 嵌入到主机应用程序中

WasmEdge 的一个主要用例是从主机应用程序启动虚拟机实例。根据你的主机应用程序编程语言，你可以使用 WasmEdge SDK 来启动和调用 WasmEdge 函数。

- 使用 [WasmEdge C API](/category/c-sdk-for-embedding-wasmedge) 将 WasmEdge 函数嵌入到基于 `C` 的应用程序中。查看[快速入门指南](../../embed/c/intro.md)。
- 使用 [WasmEdge Go API](/category/go-sdk-for-embedding-wasmedge) 将 WasmEdge 函数嵌入到 `Go` 应用程序中。这里有一个[教程](https://www.secondstate.io/articles/extend-golang-app-with-webassembly-rust/) 和一些[示例](https://github.com/second-state/WasmEdge-go-examples)！
- 使用 [WasmEdge Rust crate](https://crates.io/crates/wasmedge-sdk) 将 WasmEdge 函数嵌入到 `Rust` 应用程序中。
- 使用 `NAPI` 将 WasmEdge 函数嵌入到 `Node.js` 应用程序中。这里有一个[教程](https://www.secondstate.io/articles/getting-started-with-rust-function/)。
- 通过生成一个新进程将 WasmEdge 函数嵌入到任何应用程序。查看 [Vercel 无服务器函数](https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/) 和 [AWS Lambda](https://www.cncf.io/blog/2021/08/25/webassembly-serverless-functions-in-aws-lambda/) 的示例。

不过，WebAssembly 规范仅支持用于 WebAssembly 字节码函数的非常有限的输入参数和返回值的数据类型。要传递复杂数据类型（例如字符串或数组）作为来自 Rust 编译的 WebAssembly 的调用参数，你应该使用[`wasmedge-bindgen`](https://crates.io/crates/wasmedge-bindgen)提供的 `bindgen` 解决方案。我们目前在 [Rust](../../develop/rust/bindgen.md) 和 [Go](../../embed/go/bindgen.md) 中支持`wasmedge-bindgen`。

## 使用 WasmEdge 作为类似 Docker 的容器

WasmEdge 提供符合 OCI 规范的接口。你可以使用诸如 CRI-O、Docker Hub 和 Kubernetes 之类的容器工具来编排和管理 WasmEdge 运行时。

- [使用 CRI-O 和 Docker Hub 管理 WasmEdge](https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/)。

## 从 WasmEdge 调用原生宿主函数

WasmEdge 的一个关键特性是其可扩展性。WasmEdge API 允许开发人员将来自主机编程语言的“主机函数”注册到 WasmEdge 实例中，并从 WebAssembly 程序中调用这些函数。

- WasmEdge C API 支持 [C 主机函数](../../embed/c/host_function.md)。
- WasmEdge Go API 支持 [Go 主机函数](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_HostFunc#wasmedge-go-host-function-example)。
- WasmEdge Rust API 支持 [Rust 主机函数](https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#host-functions)。

[这是一个示例](https://www.secondstate.io/articles/call-native-functions-from-javascript/)，演示了 WasmEdge 中的 JavaScript 程序调用底层操作系统中基于 C 的主机函数。

主机函数打破了 WASM 沙箱，以便访问底层操作系统或硬件。但这种沙箱破坏是经过系统操作者明确许可的。
","**Code Analysis Summary:**

This document provides an introduction to WasmEdge, a cloud-native and edge computing application ""serverless"" runtime. It explains how to integrate WasmEdge into host applications using various programming languages (C, Go, Rust, Node.js) through APIs or SDKs.

The main use cases for WasmEdge are:

1. **Embedding WasmEdge functions into host applications**: Developers can start a virtual machine instance from their host application and call WasmEdge functions using the provided APIs.
2. **Using WasmEdge as a container**: WasmEdge provides an OCI-compliant interface, allowing developers to manage WasmEdge runtime instances using tools like CRI-O, Docker Hub, or Kubernetes.
3. **Calling native host functions from WasmEdge**: WasmEdge allows developers to register ""host functions"" from their host programming language and call them from WebAssembly programs.

**Key Components:**

1. **WasmEdge APIs**: Provides a set of APIs for integrating WasmEdge into host applications using various programming languages.
2. **WasmEdge SDKs**: Offers software development kits (SDKs) for specific programming languages, making it easier to integrate WasmEdge into host applications.
3. **wasmedge-bindgen**: A tool for generating bindings between Rust or Go code and WebAssembly functions.

**Potential Issues/Areas for Improvement:**

1. **Limited input parameters and return values**: The WebAssembly specification only supports a limited set of data types as input parameters and return values, which may limit the complexity of WasmEdge functions.
2. **Dependence on third-party libraries**: Some WasmEdge features rely on external libraries (e.g., `wasmedge-bindgen`), which may introduce additional dependencies and maintenance burdens.

Overall, this document provides a comprehensive introduction to WasmEdge and its use cases, highlighting the benefits of integrating WasmEdge into host applications and using it as a container. However, further research and development are needed to address potential limitations and improve the overall ecosystem."
src/pages/releases.md,"import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem'; import ReleaseNotes from '@theme/ReleaseNotes';

# Releases

<Tabs lazy>
  <TabItem value ='WasmEdge' label=""WasmEdge"" default>
    <p><a href=""https://github.com/WasmEdge/WasmEdge/releases"">View releases on GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/Changelog.md' />
  </TabItem>
    <TabItem value ='tokio' label=""tokio"">
    <p><a href=""https://github.com/WasmEdge/tokio/releases"">View releases on GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/WasmEdge/tokio/master/tokio/CHANGELOG.md' />
  </TabItem>
  <TabItem value ='mio' label=""mio"">
    <p><a href=""https://github.com/WasmEdge/mio/releases"">View releases on GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/WasmEdge/mio/master/CHANGELOG.md' />
  </TabItem>
  <TabItem value ='sqlx' label=""sqlx"">
    <p><a href=""https://github.com/WasmEdge/sqlx"">GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/WasmEdge/sqlx/main/CHANGELOG.md' />
  </TabItem>
  <TabItem value ='redis-rs' label=""redis-rs"">
    <p><a href=""https://github.com/WasmEdge/redis-rs/releases"">View releases on GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/WasmEdge/redis-rs/main/redis/CHANGELOG.md' />
  </TabItem>
  <TabItem value ='combine' label=""combine"">
    <p><a href=""https://github.com/WasmEdge/combine/releases"">View releases on GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/WasmEdge/combine/master/CHANGELOG.md' />
  </TabItem>
  <TabItem value ='reqwest' label=""reqwest"">
    <p><a href=""https://github.com/WasmEdge/reqwest/releases"">View releases on GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/WasmEdge/reqwest/master/CHANGELOG.md' />
  </TabItem>
  <TabItem value ='rskafka_wasi' label=""rskafka_wasi"">
    <p><a href=""https://github.com/WasmEdge/rskafka_wasi"">View releases on GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/WasmEdge/rskafka_wasi/main/CHANGELOG.md' />
  </TabItem>
  <TabItem value ='WasmEdge-Go-SDK' label=""wasmedge-go"">
    <p><a href=""https://github.com/second-state/WasmEdge-go/releases"">View releases on GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/second-state/WasmEdge-go/master/Changelog.md' />
 </TabItem>
</Tabs>
","**Summary**

This code generates a page with a tabbed interface displaying release notes for various dependencies of the WasmEdge project. The dependencies are listed in separate tabs, each containing links to their respective GitHub releases and changelogs.

**Key Components**

1. **Tabs**: The `Tabs` component from `@theme/Tabs` is used to create a tabbed interface.
2. **TabItem**: Each dependency has its own `TabItem` instance, which contains the link to the dependency's release notes.
3. **ReleaseNotes**: The `ReleaseNotes` component from `@theme/ReleaseNotes` is used to display the changelog for each dependency.

**Functionality**

When a tab is clicked, the corresponding release notes are displayed below the tab header. Each release note section contains a link to the GitHub releases page and a direct link to the changelog file (in Markdown format).

**Potential Issues/ Areas for Improvement**

1. **Error handling**: The code does not handle cases where the changelog URL is invalid or the file is not found.
2. **Code duplication**: Each dependency's configuration (e.g., GitHub repository, changelog file path) is hardcoded in each `TabItem` instance. This makes it difficult to manage changes and updates for multiple dependencies.
3. **Maintainability**: The code is repetitive, which can make it harder to maintain and update in the future.

**Recommendations**

1. **Introduce a data-driven approach**: Instead of hardcoding the dependency configurations, consider using a data file (e.g., JSON or CSV) that contains the metadata for each dependency.
2. **Use a loop or mapping function**: Create a single instance of `TabItem` and use a loop or mapping function to render each dependency's tab based on the data from the data file.
3. **Implement error handling**: Add try-catch blocks to handle cases where the changelog URL is invalid or the file is not found.
4. **Consider using a more robust library for generating release notes**: There are libraries available (e.g., `github-release`) that provide more features and better support for displaying release notes."
.github/PULL_REQUEST_TEMPLATE.md,"## Explanation

<!--
In a couple sentences, explain why this PR is needed and what it addresses. This should be an explanation a non-developer user can understand and covers the ""why"" question. It should also clearly indicate whether this PR represents an addition, a change, or a fix of existing behavior. This explanation will be used to assist in the release note drafting process.

THIS IS MANDATORY.
-->

## Related issue

<!--
Please link the GitHub issue this pull request resolves in the format of `Closes #1234`, `fixes #1234`.
-->

## What type of PR is this

<!--
> /kind bug
> /kind documentation
-->

## Proposed Changes

<!--
Describe the big picture of your changes here to communicate to the maintainers why we should accept this pull request. 
-->
","**Summary**

This is a Pull Request (PR) template, specifically designed for GitHub. The purpose of this template is to provide guidelines and structure for developers to submit PRs in a clear and concise manner.

**Functionality**

The template consists of four sections:

1. **Explanation**: A brief description of the PR, explaining why it's needed, what it addresses, and whether it adds, changes, or fixes existing behavior.
2. **Related issue**: A link to the GitHub issue that this PR resolves.
3. **What type of PR is this**: A categorization of the PR as either a bug fix, documentation update, or other type.
4. **Proposed Changes**: A high-level overview of the changes included in the PR.

**Key Components**

* The template emphasizes the importance of clear and concise communication for non-developer users.
* It provides structure for developers to follow when submitting PRs.
* The sections are designed to facilitate review and understanding of the PR by maintainers.

**Potential Issues or Areas for Improvement**

* While the template provides guidance, it may not cover all scenarios or edge cases. Developers should ensure that their PR explanation and proposed changes are comprehensive and easy to understand.
* Maintainers should regularly review and update this template to reflect changing project requirements and best practices.
* The use of markdown formatting in this template can make it more readable and accessible; however, it may also introduce limitations in certain text editors or platforms."
docs/contribute/internal.md,"---
sidebar_position: 6
---

# WasmEdge Internal

## Overview of WasmEdge Execution Flow

```mermaid
graph TD
    A[WASM] -->|From files or buffers| B(Loader)
    B -->|Create WASM AST| C(Validator)
    C -->|Validate WASM Module| D[Instantiator]
    D -->|Create WASM instances| E{AOT section found?}
    E -->|Yes| F[AOT Engine]
    E -->|No| G[Interpreter Engine]
    F <-->|Execute WASM| H[WasmEdge Engine]
    G <-->|Execute WASM| H[WasmEdge Engine]
    H -->|Host Function Call / Access Runtime Data| H1[WasmEdge Runtime]
    H1 <-->|Call Host Functions| I[Host Functions]
    H1 <-->|Access Runtime Data| J[Runtime Data Manager]
    I <-->|System Call| I1[WASM System Interface, WASI]
    I <-->|AI-related Function Call| I2[WASI-NN]
    I <-->|Crypto-related Function Call| I3[WASI-Crypto]
    I <-->|Socket-related Function Call| I4[WasmEdge-WASI-Socket]
    J <-->|Access Memory| J1[Memory Manager]
    J <-->|Access Stack| J2[Stack Manager]
    J <-->|Access Cross Module| J3[Registered Module/Function Manager]
```
","**Summary**

This code snippet from the `internal.md` file in the WasmEdge repository visualizes the execution flow of a WebAssembly (WASM) module using Mermaid. The flowchart illustrates the various components and processes involved in executing a WASM module within the WasmEdge engine.

**Key Components**

1. **Loader**: Loads the WASM module from files or buffers.
2. **Validator**: Validates the loaded WASM module to ensure it conforms to the WebAssembly specification.
3. **Instantiator**: Creates instances of the validated WASM module.
4. **AOT Engine/Interpreter Engine**: Executes the WASM code, either through Just-In-Time (JIT) compilation using an AOT engine or interpretation using an interpreter engine.
5. **WasmEdge Engine**: The core execution engine that executes the WASM instructions.
6. **Host Function Call/Runtime Data Manager**: Handles host function calls and access to runtime data, such as memory, stack, and registered modules/functions.
7. **Host Functions/WASI Interface**: Provides interfaces for system calls, AI-related functions, crypto-related functions, and socket-related functions.

**Potential Issues/Improvement Areas**

1. **Complexity**: The flowchart may appear overwhelming due to the numerous components involved in executing a WASM module. Consider breaking down the chart into smaller sections or creating an animated version.
2. **Code Documentation**: While the chart provides a high-level overview, it lacks detailed documentation on each component's functionality and implementation details.
3. **Error Handling**: The chart does not illustrate error handling mechanisms for invalid WASM modules, host function calls, or other potential issues that may arise during execution.

By addressing these areas for improvement, the WasmEdge team can make their codebase more accessible, maintainable, and easier to understand, ultimately facilitating contributions from a broader community."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/internal.md,"---
sidebar_position: 6
---

# WasmEdge Internal

## Overview of WasmEdge Execution Flow

```mermaid
graph TD
    A[WASM] -->|From files or buffers| B(Loader)
    B -->|Create WASM AST| C(Validator)
    C -->|Validate WASM Module| D[Instantiator]
    D -->|Create WASM instances| E{AOT section found?}
    E -->|Yes| F[AOT Engine]
    E -->|No| G[Interpreter Engine]
    F <-->|Execute WASM| H[WasmEdge Engine]
    G <-->|Execute WASM| H[WasmEdge Engine]
    H -->|Host Function Call / Access Runtime Data| H1[WasmEdge Runtime]
    H1 <-->|Call Host Functions| I[Host Functions]
    H1 <-->|Access Runtime Data| J[Runtime Data Manager]
    I <-->|System Call| I1[WASM System Interface, WASI]
    I <-->|AI-related Function Call| I2[WASI-NN]
    I <-->|Crypto-related Function Call| I3[WASI-Crypto]
    I <-->|Socket-related Function Call| I4[WasmEdge-WASI-Socket]
    J <-->|Access Memory| J1[Memory Manager]
    J <-->|Access Stack| J2[Stack Manager]
    J <-->|Access Cross Module| J3[Registered Module/Function Manager]
```
","**Code Summary**

The provided code is an internal documentation for the WasmEdge Execution Flow. It uses Mermaid to create a visual graph that illustrates the execution flow of WASM (WebAssembly) modules in the WasmEdge engine.

**Key Components:**

1. **WASM Loader**: responsible for loading WASM files or buffers.
2. **Validator**: validates the loaded WASM module.
3. **Instantiator**: creates WASM instances.
4. **AOT Engine**: executes AOT (Ahead-of-Time) sections of the WASM module.
5. **Interpreter Engine**: executes non-AOT sections of the WASM module.
6. **WasmEdge Engine**: serves as a runtime environment for both AOT and Interpreter Engines.
7. **Host Functions**: provides system calls, AI-related function calls, crypto-related function calls, and socket-related function calls to the WasmEdge Runtime.
8. **Runtime Data Manager**: manages access to runtime data.
9. **Memory Manager**, **Stack Manager**, and **Registered Module/Function Manager**: manage memory, stack, and cross-module functionality respectively.

**Potential Issues/Areas for Improvement:**

1. The graph is complex and may be difficult to understand without a thorough explanation of each component's role.
2. The use of multiple arrows between components can make it hard to follow the execution flow.
3. There is no clear indication of which components are responsible for error handling or exception management.
4. The involvement of multiple engines (AOT, Interpreter) and runtimes (WasmEdge Engine, Host Functions) might lead to complexity in debugging issues.

**Recommendations:**

1. Consider adding additional documentation or explanations to make the graph more accessible to readers unfamiliar with WASM execution flows.
2. Break down complex components into smaller, more manageable pieces to improve readability.
3. Identify and separate error handling and exception management logic from the main execution flow.
4. Consider using a more straightforward notation for representing relationships between components."
docs/embed/go/reference/upgrade_to_0.13.0.md,"---
sidebar_position: 2
---

# Upgrade to WasmEdge-Go v0.13.0

Due to the WasmEdge-Go API breaking changes, this document shows the guideline of programming with WasmEdge-Go API to upgrade from the `v0.12.1` to the `v0.13.0` version.

## Concepts

1. Removed the `TensorFlow`, `TensorFlow-Lite`, and `Image` extension APIs.

   After `v0.13.0`, the WasmEdge extensions are replaced by the corresponding plug-ins. Please refer to our newest [example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_mtcnn).

2. Asynchronously invoking WASM function by executor.

   Developers can use the `(wasmedge.Executor).AsyncInvoke()` API to execute a WASM function asynchronously.

3. Fixed the `(wasmedge.Executor).Invoke()` API to remove the first `wasmedge.Store` parameter.

   It's easy to update. Just drop the first parameter.

4. Unified WasmEdge CLI.

   Developers can use the `wasmedge.RunWasmEdgeUnifiedCLI()` API to trigger the unified WasmEdge CLI.
","**Summary:**

The provided code is a reference guide for upgrading to WasmEdge-Go v0.13.0, which introduces breaking changes to the API. The guide covers key concepts and modifications required for developers to migrate their applications from v0.12.1 to v0.13.0.

**Key Components:**

1. **Removed APIs**: TensorFlow, TensorFlow-Lite, and Image extension APIs have been removed.
2. **Asynchronous Invocation**: `(wasmedge.Executor).AsyncInvoke()` API allows developers to execute WASM functions asynchronously.
3. **Modified `Invoke()` API**: The first `wasmedge.Store` parameter has been removed from the `(wasmedge.Executor).Invoke()` API.
4. **Unified WasmEdge CLI**: Developers can use `wasmedge.RunWasmEdgeUnifiedCLI()` API to trigger the unified WasmEdge CLI.

**Potential Issues or Areas for Improvement:**

1. **API changes may require significant code updates**: The removal of TensorFlow, TensorFlow-Lite, and Image extension APIs will likely require substantial code modifications.
2. **Async invocation may introduce complexity**: Developers should carefully consider when and how to use asynchronous invocation to ensure it does not impact performance or application behavior.
3. **Unified CLI API may have compatibility issues**: Developers using the unified CLI API should test their applications thoroughly to ensure compatibility with the new API.
4. **Documentation and examples may be needed for specific use cases**: The guide does not cover all potential edge cases or scenarios, so additional documentation and examples would be beneficial for developers migrating from v0.12.1 to v0.13.0."
i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.13.0.md,"---
sidebar_position: 2
---

# Upgrade to WasmEdge-Go v0.13.0

Due to the WasmEdge-Go API breaking changes, this document shows the guideline of programming with WasmEdge-Go API to upgrade from the `v0.12.1` to the `v0.13.0` version.

## Concepts

1. Removed the `TensorFlow`, `TensorFlow-Lite`, and `Image` extension APIs.

   After `v0.13.0`, the WasmEdge extensions are replaced by the corresponding plug-ins. Please refer to our newest [example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_mtcnn).

2. Asynchronously invoking WASM function by executor.

   Developers can use the `(wasmedge.Executor).AsyncInvoke()` API to execute a WASM function asynchronously.

3. Fixed the `(wasmedge.Executor).Invoke()` API to remove the first `wasmedge.Store` parameter.

   It's easy to update. Just drop the first parameter.

4. Unified WasmEdge CLI.

   Developers can use the `wasmedge.RunWasmEdgeUnifiedCLI()` API to trigger the unified WasmEdge CLI.
","**Summary:**

This Markdown document outlines the guidelines for upgrading from WasmEdge-Go v0.12.1 to v0.13.0. The document covers four main areas:

1. **API breaking changes**: The `TensorFlow`, `TensorFlow-Lite`, and `Image` extension APIs have been removed. Instead, use corresponding plug-ins.
2. **Asynchronous WASM function invocation**: Use `(wasmedge.Executor).AsyncInvoke()` to execute a WASM function asynchronously.
3. **Invoke API update**: Drop the first parameter when updating from `(wasmedge.Executor).Invoke()`.
4. **Unified WasmEdge CLI**: Use `wasmedge.RunWasmEdgeUnifiedCLI()` to trigger the unified WasmEdge CLI.

**Key Components:**

* The document targets developers upgrading from v0.12.1 to v0.13.0.
* It highlights major API changes and provides simple examples for updating code.
* Key APIs affected are `(wasmedge.Executor).AsyncInvoke()`, `(wasmedge.Executor).Invoke()`, `TensorFlow`/`TensorFlow-Lite`/`Image` extension APIs, and `wasmedge.RunWasmEdgeUnifiedCLI()`.

**Potential Issues or Areas for Improvement:**

* The document assumes a basic understanding of WasmEdge-Go and its API. Providing more context or background information might be helpful for new users.
* The example link provided is external and may change over time. It would be beneficial to include a brief description of the example within the document itself.
* While the update instructions are concise, it's essential to emphasize that developers should review their entire codebase to ensure all changes are applied correctly."
docs/contribute/community.md,"---
sidebar_position: 10
---

# Join WasmEdge Community

Everyone is welcome to join the WasmEdge community.

## Contact

If you have any questions, feel free to open a GitHub issue on a related project or to join the following channels:

- Mailing list: Send an email to [WasmEdge@googlegroups.com](https://groups.google.com/g/wasmedge/)
- Discord: Join the [WasmEdge Discord server](https://discord.gg/h4KDyB8XTt)!
- Slack: Join the #WasmEdge channel on the [CNCF Slack](https://slack.cncf.io/)
- Twitter: Follow @realwasmedge on [Twitter](https://twitter.com/realwasmedge)

## Community Meeting

We host a monthly community meeting to showcase new features, demo new use cases, and a Q&A part. Everyone is welcome!

Time: The first Tuesday of each month at 11PM Hong Kong Time/ 7AM PST.

[Public meeting agenda/notes](https://docs.google.com/document/d/1iFlVl7R97Lze4RDykzElJGDjjWYDlkI8Rhf8g4dQ5Rk/edit#) | [Zoom link](https://us06web.zoom.us/j/88282362606?pwd=UFhOdzlVKyswdW43c21BKy9DdkdyUT09)
","**Summary**

The code snippet appears to be a Markdown document that serves as an introduction to the WasmEdge community. It provides information on how to join and engage with the community, including contact channels (mailing list, Discord, Slack, Twitter) and regular community meetings.

**Key Components**

1. **Community Invitation**: The document welcomes everyone to join the WasmEdge community.
2. **Contact Channels**: A list of communication channels where users can ask questions or get involved:
	* Mailing list: `WasmEdge@googlegroups.com`
	* Discord: `[Join the WasmEdge Discord server](https://discord.gg/h4KDyB8XTt)`
	* Slack: `#WasmEdge channel on the CNCF Slack` (`https://slack.cncf.io/`)
	* Twitter: Follow `@realwasmedge`
3. **Community Meeting**: The document announces a monthly community meeting, including:
	* Time and date (first Tuesday of each month at 11PM Hong Kong Time/ 7AM PST)
	* Links to the public meeting agenda and notes
	* Zoom link for attending the meeting

**Potential Issues or Areas for Improvement**

1. **Outdated Information**: The document mentions a mailing list that appears to be managed by Google Groups, which might not be the most reliable or secure option.
2. **Lack of Clear Instructions**: While the document provides links to join various channels, it would be helpful to include clear instructions on how to use each platform (e.g., Discord vs. Slack).
3. **Inconsistent Formatting**: The Markdown formatting is consistent throughout the document, but there are minor inconsistencies in indentation and spacing.
4. **No Clear Call-to-Action**: While the document invites users to join the community, it would be beneficial to include a clear call-to-action (CTA) or encouragement for users to participate in discussions or contribute to projects.

Overall, the code snippet is well-structured, but it could benefit from some minor adjustments and clarifications to make it more accessible and user-friendly."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/community.md,"---
sidebar_position: 10
---

# Join WasmEdge Community

Everyone is welcome to join the WasmEdge community.

## Contact

If you have any questions, feel free to open a GitHub issue on a related project or to join the following channels:

- Mailing list: Send an email to [WasmEdge@googlegroups.com](https://groups.google.com/g/wasmedge/)
- Discord: Join the [WasmEdge Discord server](https://discord.gg/h4KDyB8XTt)!
- Slack: Join the #WasmEdge channel on the [CNCF Slack](https://slack.cncf.io/)
- Twitter: Follow @realwasmedge on [Twitter](https://twitter.com/realwasmedge)

## Community Meeting

We host a monthly community meeting to showcase new features, demo new use cases, and a Q&A part. Everyone is welcome!

Time: The first Tuesday of each month at 11PM Hong Kong Time/ 7AM PST.

[Public meeting agenda/notes](https://docs.google.com/document/d/1iFlVl7R97Lze4RDykzElJGDjjWYDlkI8Rhf8g4dQ5Rk/edit#) | [Zoom link](https://us06web.zoom.us/j/88282362606?pwd=UFhOdzlVKyswdW43c21BKy9DdkdyUT09)
","**Summary**

The provided code is a Markdown file that serves as a community guide for the WasmEdge project. It outlines how to join and participate in the WasmEdge community, including contact channels, a community meeting schedule, and links to relevant resources.

**Key Components**

1. **Joining the Community**: The document explains how to reach out to the community through various communication channels (mailing list, Discord, Slack, Twitter).
2. **Community Meeting**: The monthly meeting agenda includes showcasing new features, demos of new use cases, and a Q&A session.
3. **Meeting Schedule**: The first Tuesday of each month at 11PM Hong Kong Time/ 7AM PST.
4. **Resources**:
	* Public meeting agenda/notes (Google Doc)
	* Zoom link for the community meeting

**Potential Issues or Areas for Improvement**

1. **Outdated Links**: The code includes links to external resources, which may become outdated over time. Consider implementing a mechanism to update these links automatically.
2. **Meeting Schedule**: Ensure that the meeting schedule is accurately reflected in multiple places (e.g., calendar events, community announcements) and communicated clearly to attendees.
3. **Community Engagement**: While the document encourages participation, consider adding more incentives or activities to foster engagement within the community.

Overall, this code serves as a valuable resource for the WasmEdge community, providing clear guidelines on how to participate and engage with others. By addressing potential issues and areas for improvement, the community can continue to grow and thrive."
docs/start/usage/wasm-smart-devices.md,"---
sidebar_position: 4
---

# WasmEdge On Smart Devices

Smart device apps could embed WasmEdge as a middleware runtime to render interactive content on the UI, connect to native device drivers, and access specialized hardware features (i.e., the GPU for AI inference). The benefits of the WasmEdge runtime over native-compiled machine code include security, safety, portability, manageability, OTA upgradability, and developer productivity. WasmEdge runs on the following device OSes.

- [Android](/category/build-and-run-wasmedge-on-android)
- [OpenHarmony](../../contribute/source/os/openharmony.md)
- [Raspberry Pi](../../contribute/source/os/raspberrypi.md)
- [The seL4 RTOS](../../contribute/source/os/sel4.md)

With WasmEdge on both the device and the edge server, we can support [isomorphic Server-Side Rendering (SSR)](../../develop/rust/ssr.md) and [microservices](../../start/build-and-run/docker_wasm.md#deploy-the-microservice-example) for rich-client mobile applications that are both portable and upgradeable.
","**Summary**

This document describes the use of WasmEdge, a WebAssembly runtime, on smart devices to enable interactive content rendering, native device driver integration, and access to specialized hardware features. The benefits of using WasmEdge include improved security, safety, portability, manageability, OTA upgradability, and developer productivity.

**Key Components**

1. **WasmEdge**: A WebAssembly runtime that enables the execution of WebAssembly modules on smart devices.
2. **Device OS Support**: WasmEdge runs on various device operating systems, including Android, OpenHarmony, Raspberry Pi, and seL4 RTOS.
3. **Interactive Content Rendering**: WasmEdge can render interactive content on the UI of smart devices.
4. **Native Device Driver Integration**: WasmEdge allows access to native device drivers for specialized hardware features.
5. **Isomorphic Server-Side Rendering (SSR)**: WasmEdge enables isomorphic SSR, allowing for rich-client mobile applications that are both portable and upgradeable.
6. **Microservices Support**: WasmEdge supports microservices architecture for building scalable and maintainable applications.

**Potential Issues or Areas for Improvement**

1. **Compatibility Issues**: Ensuring seamless integration with various device OSes and hardware configurations may require additional testing and optimization.
2. **Performance Optimization**: Optimizing performance, especially on resource-constrained devices, might be necessary to ensure smooth rendering of interactive content.
3. **Security Considerations**: Implementing robust security measures, such as sandboxing and memory protection, is crucial for safeguarding sensitive device resources and user data.
4. **Scalability and Maintainability**: As the application base grows, implementing efficient scaling strategies and monitoring tools will be essential to ensure seamless maintenance and updates."
docs/embed/data/intro.md,"---
sidebar_position: 1
---

# WasmEdge-Bindgen Introduction

Passing complex data like a string is difficult for WebAssembly since WASM does not have a string data type. That's why we have the [WasmEdge-Bindgen](https://github.com/second-state/wasmedge-bindgen) project. The Wasmedge-Bindgen project provides Rust macros for functions to accept and return complex data types and then for functions in the host to call such Rust functions running in WasmEdge.

Now WasmEdge-bindgen supports WasmEdge Go SDK and Rust SDK. I will walk you through how to pass complex data from GO and Rust host to an embedded WASM function.

- [Passing complex data from WasmEdge Go SDK](go.md)
- [Passing complex data from WasmEdge Rust SDK](rust.md)
","**Code Summary**

This is a documentation file for the WasmEdge-Bindgen project, which provides Rust macros for functions to accept and return complex data types in WebAssembly (WASM) environments. The code is written in Markdown format and serves as an introduction to the project.

**Purpose and Functionality**

The purpose of WasmEdge-Bindgen is to simplify the process of passing complex data between host languages (GO and Rust) and embedded WASM functions using the WasmEdge runtime environment. Specifically, it enables host programs to call Rust functions running in WasmEdge with complex data types.

**Key Components**

1. **WasmEdge-Bindgen project**: A set of Rust macros that provide a way to accept and return complex data types.
2. **Rust SDK**: A software development kit for building WasmEdge applications using Rust.
3. **Go SDK**: A software development kit for building WasmEdge applications using GO.

**Potential Issues or Areas for Improvement**

1. **Readability**: The Markdown formatting is clear, but the introduction section could benefit from a brief overview of what complex data types are and why they're difficult to work with in WASM.
2. **Navigation**: The document assumes that readers will navigate to the specific guides for passing complex data from GO and Rust hosts. Consider adding more prominent links or anchors to make navigation easier.
3. **Example Code**: While the introduction provides context, it would be helpful to include example code snippets or links to additional resources for a better understanding of how WasmEdge-Bindgen works.

Overall, this documentation is well-organized and easy to follow. With some minor improvements in readability and navigation, it can serve as an excellent resource for developers exploring the WasmEdge-Bindgen project."
i18n/zh/docusaurus-plugin-content-docs/current/embed/data/intro.md,"---
sidebar_position: 1
---

# WasmEdge-Bindgen Introduction

Passing complex data like a string is difficult for WebAssembly since WASM does not have a string data type. That's why we have the [WasmEdge-Bindgen](https://github.com/second-state/wasmedge-bindgen) project. The Wasmedge-Bindgen project provides Rust macros for functions to accept and return complex data types and then for functions in the host to call such Rust functions running in WasmEdge.

Now WasmEdge-bindgen supports WasmEdge Go SDK and Rust SDK. I will walk you through how to pass complex data from GO and Rust host to an embedded WASM function.

- [Passing complex data from WasmEdge Go SDK](go.md)
- [Passing complex data from WasmEdge Rust SDK](rust.md)
","**Code Analysis Summary**

This is a Markdown file (`intro.md`) used as an introduction to the WasmEdge-Bindgen project. It provides an overview of the challenges of passing complex data between WebAssembly and host languages, and introduces the WasmEdge-Bindgen project as a solution.

**Key Components:**

1. **WasmEdge-Bindgen**: The main topic of the document, which is a Rust macro-based project that enables passing complex data types between WebAssembly and host languages.
2. **Sidebar Positioning**: The file uses Markdown syntax to specify the position of this introduction in a sidebar or navigation menu (`sidebar_position: 1`).
3. **Links to Supporting Content**: The document links to two other Markdown files (`go.md` and `rust.md`) that provide step-by-step guides on how to use WasmEdge-Bindgen with Go SDK and Rust SDK, respectively.

**Potential Issues or Areas for Improvement:**

1. **Lack of Context**: While the introduction provides a brief overview of the challenges, it assumes the reader is already familiar with WebAssembly, WasmEdge, and the context in which these technologies are used.
2. **Ambiguity about Host Languages**: The term ""host language"" might be unclear for readers unfamiliar with the concept. Consider adding a definition or explanation for clarity.
3. **Readability**: Some of the sentences are quite long and convoluted, making it harder to follow the text. Break up complex sentences into simpler ones for better readability.
4. **Tone and Audience**: The tone is informative and technical, but might not be engaging enough for a broader audience. Consider adding examples or anecdotes to make the content more accessible and interesting.

Overall, this introduction provides a good starting point for explaining the purpose and functionality of WasmEdge-Bindgen. With some revisions to address the potential issues mentioned above, it can become an even more effective tool for conveying complex technical information."
docs/start/build-and-run/run.md,"---
sidebar_position: 2
---

# `wasmedge run` CLI

After [installation](../install.md#install), users can execute the `wasmedge run` command.

`wasmedge run` is an alias of `wasmedge` without `-v|--version` option. The usage of the `wasmedge run` tool will be:

```bash
$ wasmedge run -h
USAGE
   wasmedge run [OPTIONS] [--] WASM_OR_SO [ARG ...]
```

## Options

`wasmedge run` is an alias of `wasmedge` without `-v|--version` option.

In the other words, if users want to execute the following command.

```bash
wasmedge --reactor fibonacci.wasm fib 10
```

It is also accepted to add subcommand `run` and will have no difference on execution process and result.

```bash
wasmedge run --reactor fibonacci.wasm fib 10
```
","**Summary**

The `wasmedge run` command is a CLI tool that executes WebAssembly (WASM) files. It is an alias of the `wasmedge` command without the `-v|--version` option. The command takes optional arguments and allows users to specify WASM or Shared Object (SO) files to execute.

**Key Components**

1. **Command Syntax**: `wasmedge run [OPTIONS] [--] WASM_OR_SO [ARG ...]`
2. **Options**: Users can pass additional options to the command, but this is not explicitly documented.
3. **Aliases**: `wasmedge run` and `wasmedge` are considered aliases of each other.

**Functionality**

The `wasmedge run` command allows users to:

1. Execute WASM or SO files using the `--reactor` option.
2. Pass arguments to the executed file, as demonstrated by the example with `fibonacci.wasm` and `fib 10`.

**Potential Issues or Areas for Improvement**

1. **Lack of documentation on options**: The command syntax is provided, but there is no explanation of available options, which may lead to user confusion.
2. **Ambiguous aliases**: While `wasmedge run` and `wasmedge` are considered aliases, this might not be immediately clear to users.
3. **Inconsistent usage examples**: The original example uses `--reactor`, but the rewritten example using the `run` subcommand omits it. It would be more consistent to provide a single usage pattern throughout the documentation."
docs/develop/deploy/kubernetes/kwasm.md,"---
sidebar_position: 10
---

# Kwasm

[Kwasm](https://kwasm.sh/) is a Kubernetes Operator that adds WebAssembly support to your Kubernetes nodes.

## Quick start

You will need a running Kubernetes cluster to install Kwasm operator. Here we use a fresh cluster created by [kind](https://kind.sigs.k8s.io/):

```bash
kind create cluster
```

You will also need to [install helm](https://helm.sh/docs/intro/install/) to setup Kwasm:

```bash
helm repo add kwasm http://kwasm.sh/kwasm-operator/
helm repo update
helm install -n kwasm --create-namespace kwasm kwasm/kwasm-operator
kubectl annotate node --all kwasm.sh/kwasm-node=true
```

Apply the yaml file for the wasm job:

```bash
kubectl apply -f https://raw.githubusercontent.com/KWasm/kwasm-node-installer/main/example/test-job.yaml
```

After the job is finished, check the log:

```bash
kubectl logs job/wasm-test
```
","**Summary**

This documentation guide explains how to deploy the Kwasm Kubernetes Operator, which adds WebAssembly support to Kubernetes nodes. The guide provides a quick start section that outlines the necessary steps to install and run Kwasm on a fresh Kubernetes cluster created with Kind.

**Key Components**

1. **Kwasm Operator**: A Kubernetes Operator that adds WebAssembly support to nodes.
2. **Kind**: A tool for creating local Kubernetes clusters.
3. **Helm**: A package manager for installing and managing applications in Kubernetes.
4. **Kubectl**: The command-line interface for interacting with a Kubernetes cluster.

**Functionality**

The guide provides the following steps:

1. Create a fresh Kubernetes cluster using Kind.
2. Install Helm and add the Kwasm repository.
3. Install the Kwasm Operator using Helm.
4. Annotate all nodes in the cluster to indicate they support Kwasm.
5. Apply a YAML file for a wasm job, which runs on the Kwasm-enabled nodes.
6. Check the logs of the wasm job.

**Potential Issues or Areas for Improvement**

1. **Security**: The guide assumes that installing Helm and running `helm install` with admin privileges is secure. In production environments, careful consideration should be given to security best practices when using Helm.
2. **Cluster Configuration**: The guide does not mention any specific cluster configurations required for Kwasm to work correctly. It's essential to verify the compatibility of the Kubernetes version and other settings before deploying Kwasm.
3. **Troubleshooting**: The guide only provides a basic example of how to check logs, which might not be sufficient for troubleshooting more complex issues with the wasm job or Kwasm Operator.

By addressing these potential issues and areas for improvement, the guide can provide more robust guidance for deploying and managing Kwasm on Kubernetes clusters."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kwasm.md,"---
sidebar_position: 10
---

# Kwasm

[Kwasm](https://kwasm.sh/) is a Kubernetes Operator that adds WebAssembly support to your Kubernetes nodes.

## Quick start

You will need a running Kubernetes cluster to install Kwasm operator. Here we use a fresh cluster created by [kind](https://kind.sigs.k8s.io/):

```bash
kind create cluster
```

You will also need to [install helm](https://helm.sh/docs/intro/install/) to setup Kwasm:

```bash
helm repo add kwasm http://kwasm.sh/kwasm-operator/
helm repo update
helm install -n kwasm --create-namespace kwasm kwasm/kwasm-operator
kubectl annotate node --all kwasm.sh/kwasm-node=true
```

Apply the yaml file for the wasm job:

```bash
kubectl apply -f https://raw.githubusercontent.com/KWasm/kwasm-node-installer/main/example/test-job.yaml
```

After the job is finished, check the log:

```bash
kubectl logs job/wasm-test
```
","**Summary:**

The provided code snippet appears to be a documentation page for installing and configuring the Kwasm Kubernetes Operator on a Kubernetes cluster. The operator adds WebAssembly support to nodes in the cluster.

**Key Components:**

1. **Quick Start:** A step-by-step guide to setting up a fresh Kubernetes cluster using kind.
2. **Helm Installation:** Instructions to install Helm, a package manager for Kubernetes.
3. **Kwasm Operator Installation:** Commands to add the Kwasm operator repository and install the operator using Helm.
4. **Annotation:** An annotation is applied to all nodes in the cluster to mark them as Kwasm-enabled.
5. **WASM Job Configuration:** A YAML file is applied to create a WASM job, which can be customized for specific use cases.

**Potential Issues or Areas for Improvement:**

1. **Prerequisites:** The documentation assumes that kind and Helm are already installed on the system. However, it may not be clear to users how to install these prerequisites.
2. **Error Handling:** There is no mention of potential errors that might occur during installation or configuration, such as network connectivity issues or permission problems.
3. **Customization Options:** The example YAML file provided for the WASM job may not be suitable for all use cases. It would be helpful to provide more guidance on customizing this file.
4. **Security Considerations:** There is no mention of security considerations when using Kwasm, such as authentication and authorization mechanisms.

**Recommendations:**

1. Provide clear instructions on how to install prerequisites like kind and Helm.
2. Add error handling and troubleshooting sections to help users debug potential issues.
3. Offer more customization options for the WASM job YAML file.
4. Include security considerations and best practices for using Kwasm in production environments."
docs/contribute/source/os/raspberrypi.md,"---
sidebar_position: 9
---

# Build on Raspberry Pi

Raspberry Pi uses 64-bit processors starting from the 3 Model B. So WasmEdge can be executed on Raspberry Pi as well. For ARM, you can choose any 64-bit Linux distribution, such as Raspbian, Ubuntu, or Manjaro. This document has been tested on the Manjaro for ARM distribution, and the hardware is the Raspberry Pi 3 Model B.

The installation steps are no different from the [installation document](../../../start/install.md#install), and the execution is the same. Here's a video about installing WasmEdge and running a simple WebAssembly module to add two numbers up.

[![asciicast](https://asciinema.org/a/458453.svg)](https://asciinema.org/a/458453)
","**Summary**

This code is a documentation page for building and running WasmEdge on a Raspberry Pi. It explains that the Raspberry Pi's 64-bit processor allows WasmEdge to run on it, and provides information on how to choose a suitable Linux distribution (Raspbian, Ubuntu, or Manjaro) for ARM architecture. The installation steps are identical to those in the [installation document](../../../start/install.md#install), and execution is also the same.

**Key Components**

1. **Platform Information**: The code mentions that Raspberry Pi uses 64-bit processors from the 3 Model B onwards, enabling WasmEdge execution.
2. **Linux Distribution Options**: It lists three compatible Linux distributions for ARM architecture: Raspbian, Ubuntu, and Manjaro.
3. **Installation Link**: A link to the [installation document](../../../start/install.md#install) is provided, indicating that installation steps are the same as on other platforms.
4. **Execution Information**: Execution on Raspberry Pi is mentioned to be the same as on other platforms.
5. **Video Link**: A video demonstration of installing WasmEdge and running a simple WebAssembly module is linked.

**Potential Issues or Areas for Improvement**

1. **Platform Specificity**: While the code mentions that the hardware tested was the Raspberry Pi 3 Model B, it may be beneficial to provide more detailed platform information (e.g., specific versions of Linux distributions).
2. **Installation Steps Repetition**: The link to the [installation document](../../../start/install.md#install) repeats some installation steps. It might be better to provide a concise summary or checklist of platform-specific setup requirements.
3. **Video Content**: While the video is a good way to demonstrate WasmEdge execution, it's not directly integrated into the documentation. Consider adding a code snippet or example usage instead, or providing additional details about the WebAssembly module used in the video."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/raspberrypi.md,"---
sidebar_position: 9
---

# Build on Raspberry Pi

Raspberry Pi uses 64-bit processors starting from the 3 Model B. So WasmEdge can be executed on Raspberry Pi as well. For ARM, you can choose any 64-bit Linux distribution, such as Raspbian, Ubuntu, or Manjaro. This document has been tested on the Manjaro for ARM distribution, and the hardware is the Raspberry Pi 3 Model B.

The installation steps are no different from the [installation document](../../../start/install.md#install), and the execution is the same. Here's a video about installing WasmEdge and running a simple WebAssembly module to add two numbers up.

[![asciicast](https://asciinema.org/a/458453.svg)](https://asciinema.org/a/458453)
","**Summary**

This Markdown file is part of the i18n/zh/docusaurus-plugin-content-docs documentation for WasmEdge. It describes how to build and run WasmEdge on a Raspberry Pi device, specifically targeting 64-bit processors.

**Functionality**

The code serves as an instructional guide for users who want to install and execute WasmEdge on a Raspberry Pi. The document:

1. **Explains compatibility**: Highlights that WasmEdge can be executed on Raspberry Pi devices with 64-bit processors starting from the 3 Model B.
2. **Lists compatible Linux distributions**: Provides examples of ARM-based 64-bit Linux distributions (Raspbian, Ubuntu, or Manjaro) for users to install WasmEdge.
3. **References installation steps**: Links to a separate document (`installation document`) for detailed installation instructions.

**Key Components**

1. **Markdown syntax**: The file is written in Markdown format, using features like headers (#), links ([...](...)).
2. **Image and video embed**: Embeds an Asciinema video demonstrating the installation process.
3. **Linking**: Provides a link to a related document (`installation document`) for further information.

**Potential Issues/Improvements**

1. **Outdated compatibility information**: The Raspberry Pi 3 Model B is an older device; consider updating the text to reflect newer models' capabilities or hardware compatibility changes.
2. **Lack of concrete system requirements**: While mentioning compatible Linux distributions, it's unclear what specific minimum system configurations are required for WasmEdge execution.
3. **Readability improvements**: Breaking up long paragraphs and using concise headings can improve readability.

Overall, this code provides a clear and concise instructional guide on how to build and run WasmEdge on Raspberry Pi devices with 64-bit processors."
i18n/zh/docusaurus-plugin-content-docs/current/start/usage/use-cases.md,"---
sidebar_position: 1
---

# 使用案例

由于 WasmEdge 具备 AOT（Ahead of Time）编译器优化，是当今市场上最快的 WebAssembly 运行时之一。因此，在边缘计算、汽车行业、Jamstack、无服务器架构、SaaS、服务网格，甚至区块链应用中广泛使用。

- 现代 Web 应用程序具有丰富的用户界面，这些界面在浏览器和/或边缘云上渲染。WasmEdge 与流行的 Web UI 框架（如 React、Vue、Yew 和 Percy）合作，支持边缘服务器上的同构 [服务器端渲染（SSR）](../../embed/use-case/ssr-modern-ui.md) 功能。它还可以支持在边缘云上为 Unity3D 动画和 AI 生成的交互式视频进行服务器端渲染，用于 Web 应用程序。

- WasmEdge 为微服务提供了一个轻量级、安全且高性能的运行时。它与 Dapr 等应用服务框架以及 Kubernetes 等服务编排器完全兼容。WasmEdge 微服务可以在边缘服务器上运行，并且可以访问分布式缓存，以支持现代 Web 应用程序的无状态和有状态业务逻辑功能。另外相关的有：公共云中的无服务器函数即服务。

- [无服务器 SaaS（软件即服务）](/category/serverless-platforms) 函数使用户可以在不运营自己的 API 回调服务器的情况下扩展和自定义其 SaaS 体验。无服务器函数可以嵌入到 SaaS 中，或者驻留在与 SaaS 服务器相邻的边缘服务器上。开发人员可以简单地上传函数来响应 SaaS 事件或连接 SaaS API。

- [智能设备应用](./wasm-smart-devices.md) 可以将 WasmEdge 嵌入为中间件运行时，用于在 UI 上呈现交互式内容、连接原生设备驱动程序，并访问专门的硬件功能（例如，用于 AI 推断的 GPU）。与本地编译的机器码相比，WasmEdge 运行时的优势包括安全性、安全性、可移植性、可管理性和开发者生产力。WasmEdge 可在 Android、OpenHarmony 和 seL4 RTOS 设备上运行。

- WasmEdge 可以支持高性能的领域特定语言（DSL），或者作为一个云原生的 JavaScript 运行时，通过嵌入 JS 执行引擎或解释器。

- 开发人员可以利用诸如 [Kubernetes](../../develop/deploy/kubernetes/kubernetes-containerd-crun.md)、Docker 和 CRI-O 等容器工具来部署、管理和运行轻量级的 WebAssembly 应用程序。

- WasmEdge 应用程序可以插入到现有的应用程序框架或平台中。

如果你对 WasmEdge 有任何好的想法，请毫不犹豫地开启一个 GitHub 问题，我们一起讨论。
","**Summary:**

The provided Markdown file describes various use cases for WasmEdge, a WebAssembly runtime that enables Ahead-of-Time (AOT) compilation and optimization. The file highlights the versatility of WasmEdge in supporting modern web applications, microservices, serverless architectures, SaaS functions, smart devices, and high-performance domain-specific languages.

**Key Components:**

1. **WasmEdge**: A WebAssembly runtime that provides a lightweight, secure, and high-performance execution environment.
2. **Use Cases**:
	* Modern web applications with rich UIs
	* Microservices with compatibility with Dapr and Kubernetes
	* Serverless SaaS functions
	* Intelligent devices applications (e.g., Android, OpenHarmony, seL4 RTOS)
	* High-performance domain-specific languages (DSL) or cloud-native JavaScript runtime
3. **Deployment and Management**: Utilizing container tools like Kubernetes, Docker, and CRI-O to deploy, manage, and run WebAssembly applications

**Potential Issues or Areas for Improvement:**

1. **Code Complexity**: The Markdown file is lengthy and may benefit from reorganization into separate sections or sub-documents to improve readability.
2. **Link Clusters**: There are multiple links within the document that lead to external resources (e.g., other MD files, GitHub issues). Consider using anchor links or a table of contents to make navigation easier.
3. **Cross-References**: Some sentences or phrases reference content not explicitly mentioned in this Markdown file. Ensure consistency and provide clear context for cross-references.
4. **SEO**: Optimize the document's metadata (e.g., title, description) for better search engine visibility.

**Additional Recommendations:**

1. **Use headings and subheadings**: Enhance readability by using clear headings and subheadings to structure the content.
2. **Shorten long sentences**: Break up lengthy sentences into shorter ones to improve comprehension.
3. **Add images or diagrams**: Incorporate visual elements to illustrate complex concepts, making it easier for readers to understand.
4. **Review grammar and spelling**: Ensure accuracy in language usage and eliminate any grammatical or spelling errors."
i18n/zh/docusaurus-plugin-content-docs/current/start/overview.md,"---
sidebar_position: 1
displayed_sidebar: startSidebar
---

# 开始使用 WasmEdge

WasmEdge 是一款轻量级、高性能、可扩展的 WebAssembly 运行时，适用于云原生、边缘和去中心化应用。它支持无服务器应用、嵌入式函数、微服务、UDF、智能合约和物联网设备。WasmEdge 目前是 CNCF（Cloud Native Computing Foundation）的沙盒项目。

WasmEdge 运行时为其包含的 WebAssembly 字节码程序提供了良好定义的执行沙盒环境。该运行时提供了对操作系统资源（例如文件系统、套接字、环境变量、进程）和内存空间的隔离和保护。WasmEdge 最重要的使用场景是将用户定义的或社区贡献的代码作为软件产品中的插件（例如 SaaS、数据库、边缘节点，甚至区块链节点）安全地执行。它使第三方开发者、供应商、提供者和社区成员能够扩展和定制软件产品。

本章将介绍如何安装并开始使用 WasmEdge。

涵盖以下内容：

- [安装和卸载 WasmEdge](install.md)
- [入门指南](/category/getting-started-with-wasmEdge)
- 介绍 [WasmEdge 运行时](/category/what-is-wasmedge)
- [运行 WasmEdge](/category/running-with-wasmedge)

对于使用 WasmEdge 进行高级编程，请参考[开发 WASM 应用程序](../develop/overview.md)，[在应用中嵌入 WasmEdge](../embed/overview.md)，或向 WasmEdge [进行贡献](../contribute/overview.md) 的指南。

如果你有任何问题或有任何反馈，请通过以下方式联系我们：

- [Discord 聊天](https://discord.gg/U4B5sFTkFc)
- [创建 GitHub 问题以获取技术支持](https://github.com/WasmEdge/WasmEdge/issues)
- [提交 GitHub 讨论](https://github.com/WasmEdge/WasmEdge/discussions)
- [在 Twitter 关注 @realwasmedge](https://twitter.com/realwasmedge)
对于使用 WasmEdge 进行高级编程，请参考[开发 WASM 应用程序](../develop/overview.md)，[在应用中嵌入 WasmEdge](../embed/overview.md)，或向 WasmEdge [进行贡献](../contribute/overview.md) 的指南。

如果你有任何问题或有任何反馈，请通过以下方式联系我们：

- [Discord 聊天](https://discord.gg/U4B5sFTkFc)
- [创建 GitHub 问题以获取技术支持](https://github.com/WasmEdge/WasmEdge/issues)
- [提交 GitHub 讨论](https://github.com/WasmEdge/WasmEdge/discussions)
- [在 Twitter 关注 @realwasmedge](https://twitter.com/realwasmedge)
","**Code Summary**

This is a Markdown file titled ""开始使用 WasmEdge"" (Getting Started with WasmEdge) located in the docusaurus-plugin-content-docs project. The code provides an overview of WasmEdge, a lightweight, high-performance WebAssembly runtime, and its use cases.

**Key Components**

1. **Introduction**: A brief introduction to WasmEdge, highlighting its features and benefits.
2. **Use Cases**: A list of scenarios where WasmEdge can be used, including cloud-native, edge computing, decentralized applications, and IoT devices.
3. **Installation Guide**: A link to the installation guide for WasmEdge.
4. **Getting Started**: A link to a getting-started guide for WasmEdge.
5. **WasmEdge Runtime**: An introduction to the WasmEdge runtime environment.
6. **Running WasmEdge**: Instructions on how to run WasmEdge.
7. **Advanced Programming**: Links to guides on developing WASM applications, embedding WasmEdge in applications, and contributing to WasmEdge.
8. **Support**: Information on how to contact the WasmEdge team for support.

**Potential Issues or Areas for Improvement**

1. The code is written in Chinese, which may limit its accessibility to non-Chinese speakers.
2. There are multiple links to external resources, including Discord, GitHub, and Twitter, which may make it difficult for users to find relevant information.
3. Some of the links are not clickable, as they are encoded URLs.
4. The code could benefit from additional formatting and headings to improve readability.

Overall, the code provides a good introduction to WasmEdge and its use cases, but there are some areas for improvement in terms of accessibility, formatting, and link organization."
docs/develop/deploy/cri-runtime/containerd.md,"---
sidebar_position: 1
---

# Deploy with containerd's runwasi

The containerd-shim [runwasi](https://github.com/containerd/runwasi/) project supports WasmEdge.

## Prerequisites

1. [Install Rust](https://www.rust-lang.org/tools/install) because we need to compile the runwasi project.

2. Download the runwasi project

   ```bash
   git clone https://github.com/containerd/runwasi.git
   ```

3. Build and install the wasmedge-containerd-shim

   ```bash
   # Reference: https://github.com/containerd/runwasi/blob/main/CONTRIBUTING.md#setting-up-your-local-environment
   cd runwasi
   ./scripts/setup-linux.sh
   make build-wasmedge
   INSTALL=""sudo install"" LN=""sudo ln -sf"" make install-wasmedge
   ```

## Run a simple Wasi app

   ```bash
   make load
   sudo ctr run --rm --runtime=io.containerd.wasmedge.v1 ghcr.io/containerd/runwasi/wasi-demo-app:latest testwasm /wasi-demo-app.wasm echo 'hello'
   ```
","**Code Analysis Summary**

The code is a deployment guide for using the `containerd-shim` project with WasmEdge, which provides a runtime environment for WebAssembly (WASM) applications. The purpose of this guide is to outline the steps required to deploy and run a simple WASM application using `runwasi`, a containerization solution that supports WasmEdge.

**Key Components**

1. Prerequisites:
	* Install Rust: necessary for compiling the `runwasi` project.
	* Download the `runwasi` project from GitHub.
2. Building and installing `wasmedge-containerd-shim`:
	+ Run scripts to set up the local environment (using `setup-linux.sh`)
	+ Build and install the shim using `make`
3. Running a simple WASM application:
	+ Load the `runwasi` project into container runtime
	+ Run a `ctr` command with `--rm` option, specifying the runtime as `io.containerd.wasmedge.v1`, to execute the WASM application

**Potential Issues and Areas for Improvement**

* The guide assumes a Linux environment and does not provide instructions for other platforms (e.g., macOS or Windows).
* The `setup-linux.sh` script may not work on all distributions or environments.
* There is no error handling or debugging information in case of issues during the installation or execution process.
* The example application (`wasi-demo-app`) and its configuration might require modifications to suit specific requirements.
* There could be more detailed explanations of the containerization and runtime concepts involved."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/containerd.md,"---
sidebar_position: 1
---

# Deploy with containerd's runwasi

The containerd-shim [runwasi](https://github.com/containerd/runwasi/) project supports WasmEdge.

## Prerequisites

1. [Install Rust](https://www.rust-lang.org/tools/install) because we need to compile the runwasi project.

2. Download the runwasi project

   ```bash
   git clone https://github.com/containerd/runwasi.git
   ```

3. Build and install the wasmedge-containerd-shim

   ```bash
   cd runwasi
   make build-wasmedge
   INSTALL=""sudo install"" LN=""sudo ln -sf"" make install-wasmedge
   ```

## Run a simple Wasi app

   ```bash
   make load
   sudo ctr run --rm --runtime=io.containerd.wasmedge.v1 ghcr.io/containerd/runwasi/wasi-demo-app:latest testwasm /wasi-demo-app.wasm echo 'hello'
   ```
","**Code Summary**

This code is a part of the Docusaurus documentation for deploying a CRI (Container Runtime Interface) runtime with containerd's runwasi project. The purpose of this code is to guide users through setting up and running a simple WasmEdge application using containerd.

**Key Components**

1. **Prerequisites**: The section outlines the necessary steps to install Rust, download the runwasi project, and build/install the wasmedge-containerd-shim.
2. **Run a simple Wasi app**: This section provides the command to load the wasmedge-containerd-shim and run a simple WasmEdge application.

**Potential Issues or Areas for Improvement**

1. **Security**: The code assumes that users will install and run the containerd-shim as root, which may pose security risks. It would be better to provide instructions on how to use a non-root user.
2. **Error Handling**: There is no error handling in the provided code. Adding try-catch blocks or other error-handling mechanisms would improve the robustness of the setup process.
3. **Documentation**: While this code snippet is part of a larger documentation, it could benefit from additional explanations and examples to make it easier for users to follow along.

Overall, the code provides clear instructions on how to set up and run a CRI runtime with containerd's runwasi project. With some minor adjustments, it can be made even more user-friendly and secure."
docs/start/wasmedge/component_model.md,"---
sidebar_position: 4
---

# Component Model

The component model for WASM would dramatically improve WASM module’s reusability and composability. It will allow better access from one WASM module to other modules and systems, including the operating system APIs (e.g., networking).

WasmEdge is already committed to supporting and implementing [the component model proposal](https://github.com/WebAssembly/component-model). See the related issue [here](https://github.com/WasmEdge/WasmEdge/issues/1892).

After the support for the component model is done, WasmEdge could be integrated by Spin and Spiderlightning.
","**Summary**

The code snippet is an excerpt from a documentation file describing the Component Model for WASM (WebAssembly). The Component Model aims to enhance the reusability and composability of WASM modules by enabling better access between modules and system APIs. WasmEdge, a WebAssembly runtime, has committed to implementing this proposal.

**Key Components**

1. **Component Model**: A proposed standard for improving the modularity and integration of WASM modules.
2. **WasmEdge**: A WebAssembly runtime that will support and implement the Component Model.
3. **Spin** and **Spiderlightning**: Tools or frameworks that may integrate with WasmEdge after the Component Model is supported.

**Potential Issues or Areas for Improvement**

1. **Limited context**: The documentation snippet assumes prior knowledge of WASM, WasmEdge, and the Component Model proposal.
2. **Lack of implementation details**: The text does not provide insight into how WasmEdge will implement the Component Model or what specific changes are required.
3. **Unclear integration plans**: The mention of Spin and Spiderlightning's potential integration with WasmEdge is vague, and it is unclear what specific benefits or challenges this may bring.

To improve the code snippet, additional context and implementation details could be added to make it more accessible and informative for readers unfamiliar with the topic."
i18n/zh/docusaurus-plugin-content-docs/current/start/build-and-run/run.md,"---
sidebar_position: 2
---

# `wasmedge run` 

安装完成后（参见[安装](../install.md#install)），用户可以执行 `wasmedge run` 命令。

`wasmedge run` 是不带 `-v|--version` 选项的 `wasmedge` 的别名。`wasmedge run` 工具的用法如下：

```bash
$ wasmedge run -h
USAGE
   wasmedge run [OPTIONS] [--] WASM_OR_SO [ARG ...]
```

## 选项

`wasmedge run` 是不带 `-v|--version` 选项的 `wasmedge` 的别名。

换句话说，如果用户希望执行以下命令。

```bash
wasmedge --reactor fibonacci.wasm fib 10
```

也可以使用子命令 `run`，在执行过程和结果上不会有任何区别。

```bash
wasmedge run --reactor fibonacci.wasm fib 10
```
","**Summary**

The provided code is a documentation for the `wasmedge run` command, which is an alias of the `wasmedge` command without the `-v|--version` option. This command allows users to execute WebAssembly (WASM) files in a sandboxed environment.

**Key Components**

1. **Command syntax**: The code provides the usage syntax for the `wasmedge run` command, which takes a WASM or SO file as input and optional arguments.
2. **Options**: The documentation mentions that the `run` subcommand is equivalent to executing the main `wasmedge` command with the same arguments, without any differences in execution or results.

**Potential Issues/Improvements**

1. **Lack of clarity on reactor option**: The documentation only briefly mentions the `--reactor` option, but its purpose and usage are not clear.
2. **Insufficient error handling**: There is no information on how to handle errors that may occur when executing WASM files or passing arguments.
3. **Missing examples for non-standard use cases**: While the code provides an example for using the `--reactor` option, it would be beneficial to include more examples for less common scenarios, such as specifying custom command-line flags or handling environment variables.

Overall, the code provides a good starting point for understanding the basic usage of the `wasmedge run` command. However, additional documentation and clarifications are necessary to make it a comprehensive resource for users."
docs/start/usage/serverless/tencent.md,"---
sidebar_position: 4
---

# WebAssembly serverless functions on Tencent Cloud

As the main users of Tencent Cloud are from China, so the tutorial is [written in Chinese](https://my.oschina.net/u/4532842/blog/5172639).

We also provide a code template for deploying serverless WebAssembly functions on Tencent Cloud, please check out [the tencent-scf-wasm-runtime repo](https://github.com/second-state/tencent-scf-wasm-runtime).

Fork the repo and start writing your own rust functions.
","**Summary**

The provided code snippet is a Markdown file documenting the usage of WebAssembly serverless functions on Tencent Cloud. The tutorial is written in Chinese due to the primary user base being from China. The file includes links to external resources, including a blog post and a GitHub repository containing a code template for deploying serverless WebAssembly functions.

**Key Components**

*   Links to:
    *   A Chinese-language tutorial on My OS China
    *   The Tencent SCF Wasm Runtime GitHub repository
*   Instructions to fork the repo and write own Rust functions

**Purpose**

The purpose of this Markdown file is to provide users with a starting point for deploying serverless WebAssembly functions on Tencent Cloud. It directs them to external resources, including documentation and code templates, to help them get started.

**Areas for Improvement**

*   The language barrier posed by the Chinese-language tutorial may be a significant limitation for non-Chinese speaking developers.
*   The instruction to fork the repo assumes that users have basic knowledge of Git and GitHub, which might not be the case for all users."
docs/develop/deploy/docker_wasm.md,"---
sidebar_position: 2
---

# Docker + Wasm

Docker announced its support for WebAssembly in partnership with WasmEdge. Now we can use one single command line `docker compose up` to run WASM Apps.

Please refer to the [Quick start with Docker](../../start/getting-started/quick_start_docker.md) part.
","**Code Analysis Summary**

This code is a Markdown file (`docker_wasm.md`) located in the `docs/develop/deploy` directory. It appears to be part of a documentation set for deploying WebAssembly (WASM) applications using Docker.

**Purpose and Functionality**

The purpose of this code is to introduce and explain how to deploy WASM Apps using Docker, specifically highlighting the partnership between Docker and WasmEdge. The code serves as a quick reference guide, pointing users to another document (`quick_start_docker.md`) for further instructions on getting started with deploying Docker containers.

**Key Components**

* Markdown syntax: Used to format text and structure content.
* Sidebar configuration: `sidebar_position` is set to 2, indicating the position of this page in a sidebar or table of contents.
* Link to another document: `[Quick start with Docker](../../start/getting-started/quick_start_docker.md)`

**Potential Issues or Areas for Improvement**

1. **Lack of context**: The code snippet is incomplete and lacks surrounding content, making it difficult to understand the full context in which this information is presented.
2. **Assumed knowledge**: Readers are assumed to have prior knowledge about Docker, WASM Apps, and WasmEdge, which may not be the case for new users.
3. **Inconsistent formatting**: The Markdown code uses a mix of bold and italic text styles; using a consistent style throughout would improve readability.

Overall, this code appears to be a useful reference guide for developers familiar with Docker and WASM Apps. However, it could benefit from additional context and clarity to make it more accessible to new users."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/docker_wasm.md,"---
sidebar_position: 2
---

# Docker + Wasm

Docker announced its support for WebAssembly in partnership with WasmEdge. Now we can use one single command line `docker compose up` to run WASM Apps.

Please refer to the [Quick start with Docker](../../start/getting-started/quick_start_docker.md) part.
","**Summary:**

The provided code is a Markdown file (`docker_wasm.md`) in the Docusaurus documentation project, specifically targeting Chinese-speaking users. The file describes the integration of WebAssembly (WASM) with Docker and provides instructions on how to run WASM apps using a single command line.

**Key Components:**

1. **Documentation**: This file is part of the Docusaurus documentation project, serving as a tutorial or guide for users.
2. **WebAssembly and Docker**: The content focuses on the integration of WASM with Docker, enabling users to deploy WASM-based applications using Docker containers.
3. **Quick Start Link**: The file includes a link to another Markdown file (`quick_start_docker.md`) which is likely a step-by-step guide on getting started with Docker.

**Functionality:**

1. **Introduction**: The file introduces the concept of WebAssembly in Docker and its benefits.
2. **Instructions**: It provides instructions on how to run WASM apps using Docker Compose.

**Potential Issues or Areas for Improvement:**

1. **Lack of Specific Instructions**: While the file mentions a Quick Start link, it would be beneficial to include more detailed steps within this document.
2. **Assumes Prior Knowledge**: The content assumes that users are familiar with Docker and WebAssembly basics; adding introductory sections could enhance user understanding.

Overall, this Markdown file provides a good starting point for users interested in deploying WASM apps using Docker. However, it would benefit from additional detail and context to make the instructions more comprehensive and accessible to readers."
i18n/zh/docusaurus-plugin-content-docs/current/start/usage/wasm-smart-devices.md,"---
sidebar_position: 4
---

# WasmEdge 在智能设备上

智能设备应用可以将 WasmEdge 嵌入为中间件运行时，以在用户界面上呈现交互式内容，连接原生设备驱动程序，并访问专门的硬件功能（例如，用于 AI 推断的 GPU）。WasmEdge 运行时相对于本地编译的机器码的优势包括安全性、安全性、可移植性、可管理性、OTA 升级能力和开发者生产力。WasmEdge 可在以下设备操作系统上运行。

- [Android](/category/build-and-run-wasmedge-on-android)
- [OpenHarmony](../../contribute/source/os/openharmony.md)
- [Raspberry Pi](../../contribute/source/os/raspberrypi.md)
- [The seL4 RTOS](../../contribute/source/os/sel4.md)

通过在设备和边缘服务器上使用 WasmEdge，我们可以为丰富的客户端移动应用程序提供支持，实现[同构的服务器端渲染（SSR）](../../develop/rust/ssr.md)和[微服务](../../start/build-and-run/docker_wasm.md#deploy-the-microservice-example)，使其具备可移植性和可升级性。
","**Summary**

This is a documentation page for using WasmEdge on smart devices. It explains how WasmEdge can be embedded as a middleware runtime to run interactive content on user interfaces, connect native device drivers, and access specific hardware features (e.g., GPU for AI inference). The page highlights the benefits of running WasmEdge over machine code, including security, safety, portability, manageability, OTA upgrade capabilities, and developer productivity.

**Key Components**

1. **WasmEdge**: A middleware runtime that can be embedded on smart devices.
2. **Smart Devices**: Supported platforms include Android, OpenHarmony, Raspberry Pi, and the seL4 RTOS.
3. **Benefits**: Security, safety, portability, manageability, OTA upgrade capabilities, and developer productivity.

**Potential Issues or Areas for Improvement**

1. **Lack of detailed technical information**: The page focuses on high-level benefits and supported platforms, but lacks technical details about how to implement WasmEdge on smart devices.
2. **Unclear instructions**: The page links to other documentation pages, but it's unclear which ones are relevant for implementing WasmEdge on specific platforms.
3. **Limited platform support**: The page only mentions a few supported platforms, whereas the target audience may be interested in using WasmEdge on other devices.

**Recommendations**

1. Add more technical details about implementing WasmEdge on smart devices, including code snippets or example projects.
2. Clearly document instructions for each supported platform.
3. Expand platform support to include other popular smart device platforms (e.g., iOS, Linux-based devices)."
docs/contribute/source/os/openharmony.md,"---
sidebar_position: 7
---

# Build on OpenHarmony

<!-- prettier-ignore -->
:::info
Work in Progress
:::
 For Chinese speakers, please [check out this instruction](https://github.com/WasmEdge/WasmEdge/blob/master/utils/ohos/README-zh.md).
","**Code Analysis:**

The provided code is a Markdown file located in the `docs/contribute/source/os/openharmony.md` directory. Here's a summary of its purpose, functionality, and key components:

**Purpose:** The code is intended to provide instructions on how to build OpenHarmony, a Chinese operating system.

**Functionality:**

1. **Sidebar Positioning**: The code sets the sidebar position to 7 using the `sidebar_position` attribute.
2. **Informational Notice**: A ""Work in Progress"" notice is displayed using the `:::info` syntax.
3. **Link to Instructions for Chinese Speakers**: The file contains a link to an external README file (in Chinese) that provides additional instructions on building OpenHarmony.

**Key Components:**

1. Markdown syntax and attributes (e.g., `sidebar_position`, `:::info`)
2. Link to external documentation

**Potential Issues or Areas for Improvement:**

1. **Language**: The code is written in English, but it links to a Chinese-language README file. It would be more helpful to provide both language options within the same document.
2. **Lack of Context**: The ""Work in Progress"" notice doesn't provide any context about what's being worked on or why the instructions are not yet complete.
3. **Incomplete Instructions**: The link to the external README file is provided without explaining why users would need to read it instead of following the instructions in this document.

**Suggestions for Improvement:**

1. Merge the language options into a single document with translation attributes.
2. Provide more context about what's being worked on and why the instructions are not yet complete.
3. Consider copying relevant content from the external README file into this document to reduce the need for users to navigate externally."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/openharmony.md,"---
sidebar_position: 7
---

# Build on OpenHarmony

<!-- prettier-ignore -->
:::info
Work in Progress
:::
 For Chinese speakers, please [check out this instruction](https://github.com/WasmEdge/WasmEdge/blob/master/utils/ohos/README-zh.md).
","Here is a concise summary of the code:

**Purpose:** This Markdown file appears to be part of a documentation system, specifically providing information on contributing to OpenHarmony.

**Functionality:**

* The file has been assigned a position in the sidebar (`sidebar_position: 7`), indicating its place within the overall documentation structure.
* A notice is displayed informing readers that the content is ""Work in Progress"" (WIP).
* A link is provided for Chinese speakers, directing them to an external resource with further instructions.

**Key Components:**

* `:::info`: A Markdown codeblock used to render a highlighted warning or information box.
* `pretter-ignore`: A comment indicating that the following lines should be ignored by the Prettier code formatter.
* `sidebar_position` property: Sets the position of this page in the sidebar.

**Potential Issues or Areas for Improvement:**

* The WIP notice may not be sufficient to convey the current state of the content. Consider adding a more explicit label (e.g., ""Draft"") or providing a clear indication of when the content is expected to be complete.
* The link provided for Chinese speakers may become outdated if the target resource is updated or deleted. It would be beneficial to provide a more permanent reference, such as a repository branch or commit hash."
i18n/zh/docusaurus-plugin-content-docs/current/start/wasmedge/component_model.md,"---
sidebar_position: 4
---

# 组件模型

WASM 的组件模型将大幅改善 WASM 模块的可重用性和可组合性。它将允许一个 WASM 模块更好地访问其他模块和系统，包括操作系统的 API（例如网络功能）。

WasmEdge 已经致力于支持和实现 [组件模型提案](https://github.com/WebAssembly/component-model)。请在[此处](https://github.com/WasmEdge/WasmEdge/issues/1892)查看相关问题。

在支持组件模型之后，WasmEdge 将能够被 Spin 和 Spiderlightning 集成。
","**Summary**

The provided code is a markdown file located in the `i18n/zh/docusaurus-plugin-content-docs/current/start/wasmedge/component_model.md` directory. It discusses the Component Model for WebAssembly (WASM) and its potential benefits, including improved reusability and composability of WASM modules.

**Key Components**

1. **Component Model**: The code describes the WASM component model, which enables a WASM module to access other modules and system APIs.
2. **WasmEdge Support**: The text mentions that WasmEdge is committed to supporting and implementing the Component Model proposal.
3. **Integration with Spin and Spiderlightning**: After supporting the Component Model, WasmEdge will be able to integrate with Spin and Spiderlightning.

**Potential Issues or Areas for Improvement**

1. **Lack of technical details**: The text provides a general overview but lacks specific technical details about the Component Model, making it challenging for developers to understand its implementation.
2. **No clear guidelines for adoption**: The code does not provide guidance on how to adopt the Component Model in existing projects or when to expect WasmEdge's support.

**Recommendations**

To improve this content:

1. Provide more technical details about the Component Model, including examples and use cases.
2. Offer guidance on how to adopt the Component Model in existing projects.
3. Include a timeline for WasmEdge's support of the Component Model."
docs/embed/rust/complex_data.md,"---
sidebar_position: 4
---

# Pass Complex Data

<!-- prettier-ignore -->
:::info
Work in Progress
:::
 See an example here: <https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-4-1-define-a-host-function-with-string-arguments>
","Based on the provided code, it appears to be a documentation snippet for the Wasmedge Rust SDK. Here is a concise summary of its purpose and functionality:

**Purpose:** This section of the documentation explains how to pass complex data types as arguments in a host function.

**Functionality:**

* The example references another resource (<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-4-1-define-a-host-function-with-string-arguments>) where the concept is demonstrated.
* Although marked as ""Work in Progress,"" it implies that this section will provide guidance on passing complex data types, such as strings.

**Key Components:**

* A reference to another resource with an example implementation.
* A note indicating that the content is a work in progress.

As for potential issues or areas for improvement:

* The lack of concrete information makes it challenging for users to understand how to pass complex data types without referring to external resources.
* Given its marked ""Work in Progress"" status, it may be beneficial to indicate when this section will be completed or provide an estimated completion date.
* Consider adding more context or examples within the documentation to enhance user understanding and make it more self-contained."
i18n/zh/docusaurus-plugin-content-docs/current/embed/rust/complex_data.md,"---
sidebar_position: 4
---

# Pass Complex Data

<!-- prettier-ignore -->
:::info
Work in Progress
:::
 See an example here: <https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-4-1-define-a-host-function-with-string-arguments>
","**Code Summary**

The provided code snippet appears to be a documentation page written in Markdown format, specifically designed for the Docusaurus framework. The purpose of this page is to document how to pass complex data in Rust.

**Key Components:**

1. **Metadata**: The page has a `sidebar_position` metadata set to 4, which likely controls its positioning within the documentation sidebar.
2. **Title and Heading**: The title is ""Pass Complex Data"" and is followed by an info box indicating that this section is currently ""Work in Progress.""
3. **Link to Example Code**: A link is provided to an external GitHub repository containing example code for working with complex data in Rust.

**Functionality**

The page serves as a placeholder or a work-in-progress documentation, directing users to an external resource for an example implementation of passing complex data in Rust.

**Potential Issues/ Areas for Improvement:**

1. **Outdated link**: The provided link might become outdated if the referenced repository or code is modified.
2. **Insufficient information**: This page does not provide any concrete examples or explanations on how to pass complex data, making it less useful as a documentation resource.
3. **Lack of clarity**: Without more context, it's unclear what type of ""complex data"" this refers to, and what the implications are for users looking to implement such functionality.

To address these issues, consider adding more detailed information or examples to this page, updating any links to ensure they remain relevant, and clarifying the scope of complex data being discussed."
docs/embed/data/go.md,"---
sidebar_position: 3
---

# Go Host application with wasmedge-bindgen

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Summary**

This code is a documentation snippet for embedding data in a Go (Golang) host application using wasmedge-bindgen. The purpose of this code is to provide information on how to integrate the wasmedge-bindgen tool into a Go project.

**Key Components**

1. **Language**: The code uses Markdown syntax and appears to be part of a documentation or tutorial.
2. **Tooling**: Wasmedge-bindgen, a tool for generating WebAssembly (WASM) bindings for Go applications, is mentioned.
3. **Content**: A warning label (`Work in Progress`) suggests that the content is still being developed.

**Functionality**

The code serves as an introduction or guide to using wasmedge-bindgen with a Go host application. It likely provides instructions on how to configure and use the tool to generate WASM bindings, making it easier for developers to integrate WebAssembly modules into their Go applications.

**Potential Issues/Areas for Improvement**

1. **Incomplete content**: The ""Work in Progress"" label indicates that the documentation is still being developed. This may lead to confusion or frustration among readers.
2. **Missing context**: Without a clear understanding of the surrounding project structure and setup, new users might find it challenging to follow the instructions provided by this code snippet.

To improve this documentation, consider providing more concrete examples, detailed instructions on setting up the environment, and a clearer explanation of how wasmedge-bindgen is used in the Go host application."
docs/embed/data/rust.md,"---
sidebar_position: 2
---

# Rust Host application with wasmedge-bindgen

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Based on the provided code, I can provide a concise summary of its purpose and functionality. 

**Summary:**
The code snippet appears to be an incomplete documentation page for Rust Host application with wasmedge-bindgen integration.

**Purpose:**
The primary objective is to document the process or guide for creating or using a Rust application that leverages wasmedge-bindgen, which is likely used for building bindings between WebAssembly (WASM) code and the Rust programming language. However, due to the ""Work in Progress"" note, it's clear that this documentation is not yet complete.

**Functionality:**
While there isn't any actual code provided within the snippet, the inclusion of `wasmedge-bindgen` suggests that the documentation will focus on how to use this tool or library for integrating WASM into a Rust application. This may involve explaining how to set up the necessary dependencies, generate bindings from WASM modules, and integrate them into a Rust project.

**Key Components:**
- **Rust Host Application:** The code will likely explain what a Rust Host application is and how it interacts with WASM code.
- **Wasmedge-bindgen:** This is the library or tool that provides the necessary functionality for generating bindings from WASM to Rust. 
- **Documentation Status:** The ""Work in Progress"" status implies that this documentation page is not yet complete, suggesting ongoing development.

**Potential Issues or Areas for Improvement:**
- **Lack of Detailed Information:** Given its current state, the documentation lacks detailed information about how to use `wasmedge-bindgen` effectively.
- **Incomplete Tutorial or Guide:** Without further content, it's challenging to understand how to proceed with creating a Rust application that leverages WASM through `wasmedge-bindgen`.
- **Accuracy and Relevance:** The completeness of the documentation will likely impact its usefulness. Incomplete or outdated information could lead users astray.

Overall, this code snippet indicates the intention to provide documentation on integrating wasmedge-bindgen with a Rust Host application but emphasizes the need for further work to make it comprehensive and useful."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-runwasi.md,"---
sidebar_position: 3
---

# Kubernetes + Containerd + Runwasi

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Summary**

This Markdown file is part of a documentation project, specifically designed for i18n (internationalization) purposes. It describes how to deploy an application using Kubernetes, Containerd, and RunWASI (WebAssembly System Interface) on the WASI target platform. The document appears to be under development (""Work in Progress"").

**Key Components**

1. **Kubernetes**: A container orchestration system for automating deployment, scaling, and management of containerized applications.
2. **Containerd**: A container runtime that provides a minimal, efficient way to run containers on various platforms.
3. **RunWASI**: An implementation of the WASI API (Application Programming Interface) that allows WebAssembly programs to interact with the host operating system.

**Functionality**

The document likely describes how to:

1. Set up a Kubernetes cluster.
2. Install and configure Containerd as a container runtime on the cluster.
3. Deploy an application using RunWASI on the cluster.

**Potential Issues or Areas for Improvement**

1. **Work in Progress**: The document is marked as ""Work in Progress"", indicating that it may contain incomplete or outdated information. It's essential to verify the accuracy and completeness of the content before sharing it with others.
2. **Platform specificity**: RunWASI is a platform-specific technology, which might limit its applicability on other platforms.
3. **Containerd configuration**: The document may assume specific Containerd configurations, which could lead to errors or inconsistencies if not followed correctly.

**Recommendations**

1. Verify the accuracy and completeness of the content before sharing it with others.
2. Consider adding more details on setting up a Kubernetes cluster and installing Containerd, as these are critical steps in the deployment process.
3. Emphasize platform-specific requirements and configurations to ensure readers understand the scope and limitations of the document."
i18n/zh/docusaurus-plugin-content-docs/current/embed/data/go.md,"---
sidebar_position: 3
---

# Go Host application with wasmedge-bindgen

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Summary**

The provided code is a Markdown file (`go.md`) that appears to be part of a documentation system, likely Docusaurus, used for generating documentation for the `Go Host application with wasmedge-bindgen`. The code defines metadata and content for a specific page in the documentation.

**Key Components**

1. **Metadata**: The first line `sidebar_position: 3` sets the position of this page in the sidebar navigation.
2. **Header**: The `# Go Host application with wasmedge-bindgen` header is the title of the page.
3. **Info Block**: The `:::info Work in Progress :::` block displays an info message indicating that the content is a work-in-progress.

**Purpose**

The purpose of this code is to create a documentation page for the `Go Host application with wasmedge-bindgen`, providing a clear and organized structure for the content.

**Potential Issues or Areas for Improvement**

1. **Outdated Content Warning**: The info block suggests that the content is a work-in-progress, but it's unclear when this will be updated or what changes are being made.
2. **Lack of Context**: Without additional information, it's difficult to understand the specific context and purpose of the `Go Host application with wasmedge-bindgen`.
3. **Limited Navigation**: The sidebar position is set to 3, but without more information on the structure of the documentation, it's unclear what this means in terms of navigation.

To address these areas for improvement, the author could consider adding a clear update schedule or milestone list for the work-in-progress content, providing more context about the purpose and goals of the `Go Host application with wasmedge-bindgen`, and ensuring that the sidebar position aligns with the overall documentation structure."
i18n/zh/docusaurus-plugin-content-docs/current/embed/data/rust.md,"---
sidebar_position: 2
---

# Rust Host application with wasmedge-bindgen

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Here's a concise summary of the provided code:

**Summary**

This is a Markdown file that appears to be part of a documentation system (likely Docusaurus) for a Rust Host application with Wasmedge-Bindgen. The code defines the metadata and structure for this specific document, including its position in the sidebar.

**Key Components**

1. `sidebar_position: 2`: This line specifies the position of the current document in the sidebar, which suggests that it will be displayed as the third item (since positions are likely zero-indexed).
2. `# Rust Host application with wasmedge-bindgen`: This is a Markdown heading that indicates the title of the document.
3. `<!-- prettier-ignore -->`: This is a comment that appears to instruct a code formatter (Prettier) to ignore this line.
4. `:::info`: This is an information box or alert block, indicating that the content below is still work-in-progress.

**Potential Issues/Areas for Improvement**

1. The use of `<!-- prettier-ignore -->` may be unnecessary if the code is not being formatted by Prettier. Consider removing this line to simplify the code.
2. The document status (""Work in Progress"") may not be explicitly mentioned elsewhere in the documentation. Consider adding a more prominent warning or alert to indicate that this content is still under development.

Overall, the provided code appears to be well-structured and clear in its purpose. However, removing unnecessary comments and considering additional warnings for work-in-progress content could further improve the quality of the code."
i18n/zh/docusaurus-plugin-content-docs/current/start/usage/serverless/tencent.md,"---
sidebar_position: 4
---
# 腾讯云上的 WebAssembly 无服务器函数

由于腾讯云的主要用户来自中国，所以本教程是[用中文撰写的](https://my.oschina.net/u/4532842/blog/5172639)。

我们还提供了一个代码模板，用于在腾讯云上部署无服务器的 WebAssembly 函数，请查看 [tencent-scf-wasm-runtime 存储库](https://github.com/second-state/tencent-scf-wasm-runtime)。

Fork 这个存储库并开始编写你自己的 Rust 函数。

","Here is a concise and coherent summary of the provided code:

**Summary**

This Markdown file, titled ""腾讯云上的 WebAssembly 无服务器函数"" (WebAssembly Serverless Functions on Tencent Cloud), is part of a documentation project for Docusaurus. It provides instructions on how to deploy WebAssembly functions on Tencent Cloud's serverless platform using Rust.

**Purpose**

The purpose of this code is to guide users through the process of creating and deploying WebAssembly functions on Tencent Cloud, specifically targeting Chinese-speaking users due to Tencent Cloud's primary user base in China.

**Key Components**

1. **Code template**: The file links to a GitHub repository called ""tencent-scf-wasm-runtime"" that provides a code template for deploying WebAssembly functions on Tencent Cloud.
2. **Rust function development**: Users are encouraged to fork the repository and develop their own Rust functions using this template.

**Potential Issues or Areas for Improvement**

1. **Language barrier**: The documentation is in Chinese, which may create a language barrier for non-Chinese speaking users.
2. **Lack of step-by-step instructions**: While the file provides links to relevant resources, it does not offer explicit step-by-step instructions on how to deploy WebAssembly functions on Tencent Cloud using Rust.

Overall, this code appears to be a helpful resource for Chinese-speaking developers interested in deploying WebAssembly functions on Tencent Cloud using Rust. However, additional documentation and clearer instructions may be needed to make the process more accessible to users with varying levels of technical expertise."
docs/embed/java/intro.md,"---
sidebar_position: 1
---

# WasmEdge Java SDK Introduction

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Code Summary**

The provided code is a Markdown file (`intro.md`) that serves as an introduction to the WasmEdge Java SDK. It appears to be part of a documentation set for the SDK.

**Purpose and Functionality**

The main purpose of this code snippet is to provide a brief overview of the WasmEdge Java SDK, serving as an entry point for developers interested in using the SDK. The code includes:

1. **Sidebar Position**: Sets the position of the current page in the documentation sidebar to 1.
2. **Title and Heading**: Specifies the title and heading of the document, which is ""WasmEdge Java SDK Introduction"".
3. **Informational Note**: Includes a warning label `Work in Progress` using an `info` block, indicating that the content is still under development.

**Key Components**

* Markdown syntax for formatting text
* Use of HTML elements (e.g., `prettier-ignore`, `:::`) to include code snippets and styled text
* YAML front matter for metadata (sidebar position)

**Potential Issues or Areas for Improvement**

* The `Work in Progress` note might be unnecessary if the content is indeed still under development. A clear indication of the document's status can help developers understand its reliability.
* Consider adding a brief summary or overview section to provide more context about the WasmEdge Java SDK and its purpose.

Overall, this code snippet appears to be well-structured and follows standard Markdown conventions. However, incorporating additional details and improving clarity might enhance the overall documentation experience for users."
docs/embed/python/intro.md,"---
sidebar_position: 1
---

# WasmEdge Python SDK Introduction

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Here's a concise and coherent summary of the code:

**Summary**

This is a markdown file that serves as an introduction to the WasmEdge Python SDK. The content is part of a documentation set and is indicated to be ""Work in Progress"".

**Key Components**

* **Sidebar Position**: The `sidebar_position` metadata specifies the position of this page in the sidebar navigation, set to 1.
* **Markdown Content**: The main content of the file is written in markdown format and introduces the WasmEdge Python SDK.

**Functionality**

The purpose of this file appears to be providing an introductory overview of the WasmEdge Python SDK, likely as part of a documentation set or tutorial. The ""Work in Progress"" label suggests that this section may not be complete or up-to-date.

**Potential Issues/Areas for Improvement**

* The ""Work in Progress"" label could be misleading if the content is incomplete or outdated. A more accurate status indicator might be beneficial.
* There are no obvious technical issues with the code, but a review of the surrounding context (i.e., the rest of the documentation set) may reveal additional concerns.

Overall, this is a straightforward markdown file that serves as an introductory page for the WasmEdge Python SDK."
i18n/zh/docusaurus-plugin-content-docs/current/embed/java/intro.md,"---
sidebar_position: 1
---

# WasmEdge Java SDK Introduction

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Here is a concise, coherent summary of the code:

**Summary**

This is an introduction to the WasmEdge Java SDK written in Markdown. The content is currently marked as ""Work in Progress"" and has a specified position (1) within a sidebar.

**Key Components**

* `sidebar_position`: specifies the order of the page within a sidebar.
* `:::info` block: marks the text within as informational or note-worthy, with a red background to draw attention.

**Potential Issues/Areas for Improvement**

None identified. The code is simple and clearly indicates that it is a work in progress."
i18n/zh/docusaurus-plugin-content-docs/current/embed/python/intro.md,"---
sidebar_position: 1
---

# WasmEdge Python SDK Introduction

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Code Summary**

The provided code is a Markdown file (`intro.md`) located in the `i18n/zh/docusaurus-plugin-content-docs/current/embed/python/intro` directory. It appears to be part of a documentation project, specifically for a WasmEdge Python SDK.

**Key Components:**

1. **Sidebar Position**: The first line `sidebar_position: 1` specifies that this document should be displayed in the left sidebar with position 1.
2. **Document Title**: The `# WasmEdge Python SDK Introduction` line indicates the title of the document.
3. **Info Box**: The `:::info` block is a YAML front matter comment indicating that the content within is an ""Info"" box, which is likely used for displaying important information or warnings to readers.

**Purpose:**

The purpose of this code is to introduce the WasmEdge Python SDK and provide relevant context for developers interested in using it. The `Work in Progress` label suggests that the SDK is still being developed and may not be fully stable or functional yet.

**Potential Issues/Areas for Improvement:**

1. **Context Clarity**: While the document title provides some context, it's unclear what specific aspects of the WasmEdge Python SDK are covered in this introduction.
2. **Missing Content**: The `Work in Progress` label implies that there may be a lack of content or information about the SDK in this document.
3. **Consistency**: It would be helpful to ensure consistency across the documentation project, including formatting and styling choices.

By addressing these areas for improvement, the code can become more effective at providing valuable information to developers interested in using the WasmEdge Python SDK."
docs/develop/deploy/oci-runtime/quark.md,"---
sidebar_position: 4
---

# Deploy with quark

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Summary**

The code snippet appears to be a Markdown file (`.md`) that documents the process of deploying an application with Quark. The document is part of a larger documentation set, indicated by the `sidebar_position` and other metadata.

**Purpose**

The purpose of this code is to provide instructions on how to deploy an application using Quark, likely as part of a Kubernetes or container orchestration setup.

**Functionality**

The code does not contain any executable code, but rather provides guidance on the deployment process. However, based on the context and metadata, it's likely that the document will outline steps such as:

* Creating a Quark configuration file
* Building and pushing an image to a registry (e.g., Docker Hub)
* Deploying the application to a Kubernetes cluster or other container runtime environment

**Key Components**

Based on the metadata and context:

* **sidebar_position**: indicates the document's position in the sidebar navigation of the documentation set.
* **quark**: likely refers to the Quark deployment tool or framework being used.

**Potential Issues or Areas for Improvement**

1. **""Work in Progress"" notice**: The use of this notice may indicate that the documentation is incomplete, outdated, or subject to change. It's essential to update the document with accurate information when the work is completed.
2. **Lack of executable code**: As a Markdown file, there is no executable code in this snippet. However, it might be beneficial to provide a basic example or template for users to follow.
3. **Assumed knowledge**: The documentation assumes a level of familiarity with Quark and container deployment concepts. Additional context or explanations may be necessary for new users.

Overall, this code snippet serves as a foundation for the documentation, but further development is needed to create a comprehensive guide for deploying applications using Quark."
docs/embed/witc.md,"---
sidebar_position: 3
---

# Developing components using witc

Work in progress. Please refer to <https://github.com/second-state/witc>.
","Here's a concise summary of the provided code snippet:

**Summary:**

The provided Markdown file serves as documentation for developing components using witc. It is currently marked as ""work in progress"" and advises readers to refer to the official witc repository on GitHub.

**Functionality:**

The file appears to be a placeholder or introduction to the topic of working with witc, pointing users towards more detailed information available elsewhere.

**Key Components:**

1. Markdown syntax for documentation (e.g., `sidebar_position`, headers, and links).
2. A single link to the official GitHub repository for witc.
3. A warning label indicating that the content is work in progress.

**Potential Issues/Areas for Improvement:**

1. **Lack of detailed content:** As the file is currently marked as ""work in progress,"" it's unclear what specific topics or instructions would be included if this documentation were complete.
2. **Unclear purpose:** The file seems to exist solely for linking to an external repository, which may make it unnecessary unless the purpose is to provide a centralized location for related resources.
3. **Minimal value for users:** Without additional content or context, readers may not find this file particularly useful, especially if they are new to witc and looking for introductory information.

To address these issues, I would suggest:

1. **Filling in the gaps:** Provide a comprehensive introduction to witc, explaining its purpose, features, and usage examples.
2. **Making it self-contained:** Include relevant links and resources within the file itself, so readers can find the necessary information without having to leave the documentation.
3. **Clearly defining the scope:** Indicate what topics or aspects of witc are covered (or not) in this documentation, helping users understand its value and limitations."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime/quark.md,"---
sidebar_position: 4
---

# Deploy with quark

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Here's a concise and coherent summary of the code:

**Summary:**

This is a Markdown file named ""quark.md"" in the Docusaurus project, located in the `i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime` directory. The file contains documentation on deploying with Quark.

**Key Components:**

1. **Sidebar Position**: The file specifies a sidebar position of 4, which determines its placement within the documentation tree.
2. **Document Title**: The document title is ""Deploy with quark"".
3. **Warning Tag**: A warning tag `:::info` is used to indicate that the content is still a work in progress.

**Purpose and Functionality:**

This file serves as a placeholder for future documentation on deploying with Quark, an Oracle Cloud Infrastructure (OCI) runtime. The content is currently empty, awaiting updates to provide guidance on the deployment process.

**Potential Issues or Areas for Improvement:**

1. **Lack of Content**: As mentioned earlier, this file lacks actual content on deploying with Quark.
2. **Incomplete Documentation**: Without proper documentation, users may struggle to understand the deployment process, which can lead to frustration and wasted time.
3. **Outdated Status Indication**: The ""Work in Progress"" tag might become outdated if the document is updated but still doesn't provide comprehensive information.

To address these concerns, it's essential to update this file with accurate and comprehensive documentation on deploying with Quark, ensuring that users have a clear understanding of the process."
i18n/zh/docusaurus-plugin-content-docs/current/embed/witc.md,"---
sidebar_position: 3
---

# Developing components using witc

Work in progress. Please refer to <https://github.com/second-state/witc>.
","**Summary:**

This code snippet is a Markdown file located in the `i18n/zh/docusaurus-plugin-content-docs/current/embed` directory. It appears to be part of a documentation site, likely generated using Docusaurus.

**Purpose:** The purpose of this file is to provide an introduction or overview of developing components using witc (Work-in-Progress). It includes a link to the original GitHub repository for further information.

**Functionality:**

* The Markdown document contains a heading (`# Developing components using witc`) and a brief text that describes its work-in-progress status.
* A link is provided to direct users to the original GitHub repository for more detailed information.

**Key Components:**

* `sidebar_position`: This line specifies the position of this page in the documentation sidebar, which will be rendered accordingly.
* Link to the external resource (GitHub repository): This link provides a direct reference to the source material for those interested in learning more about witc.

**Potential Issues/Improvements:**

1. **Content**: As mentioned, the text is work-in-progress, which may indicate that this documentation section is incomplete or not up-to-date.
2. **Link Maintenance**: If the GitHub repository moves or becomes outdated, the link provided might break. Consider maintaining an active link to a stable resource or version control system like GitLab or Bitbucket.
3. **Additional Guidance**: To improve user experience, it would be beneficial to provide more context about what witc is, its benefits, and why users should care about it.

Overall, this code snippet seems to be a placeholder or draft documentation for an ongoing project. To enhance the value of this content, consider revising and refining it with relevant information and examples related to witc."
docs/develop/c/networking.md,"---
sidebar_position: 2
---

# Networking Socket

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Based on the provided code snippet, here is a concise and coherent summary:

**Purpose:** The provided code is a documentation snippet for a networking-related topic, specifically focusing on ""Networking Socket"".

**Key Components:**

* A heading with the title ""Networking Socket""
* An informational block indicating that this section is still a work-in-progress
* Prettier ignores, which are used to prevent formatting issues

**Functionality:** This code serves as a placeholder for future documentation content related to networking sockets. It provides an indication of its status and warns readers to expect updates.

**Potential Issues:**

1. **Work-in-Progress Status**: The fact that this section is still under development might lead to incomplete or outdated information, which could confuse or mislead users.
2. **Lack of Context**: Without additional surrounding text or links to related topics, this snippet may not be immediately clear or useful to readers who are seeking information on networking sockets.

**Suggestions for Improvement:**

1. **Add More Information**: Provide more context and details about what is being documented under ""Networking Socket"". This could include a brief introduction, an explanation of the topic, and possibly links to relevant resources.
2. **Schedule Completion**: Establish a clear deadline or schedule for completing this section, so readers can plan when they might expect it to be updated with useful information.
3. **Link to Relevant Topics**: Provide links to related topics or documentation sections that offer more in-depth explanations of networking-related concepts, making the content more navigable and helpful."
docs/embed/rust/reference.md,"---
sidebar_position: 7
---

# API Reference

Check out [the `wasmedge-sdk` crate](https://crates.io/crates/wasmedge-sdk) for more information.
","Based on the provided code snippet, here is a concise summary of its purpose, functionality, and key components:

**Summary**: The code is part of an API reference documentation for the `wasmedge-sdk` crate.

**Purpose**: To provide a brief introduction to the `wasmedge-sdk` crate and direct users to the official crate page on crates.io for more information.

**Functionality**: The code serves as a placeholder or table of contents entry, linking to the external resource with detailed documentation about the crate.

**Key Components**:

1. **Anchor text**: ""API Reference""
2. **Link**: A link to the `wasmedge-sdk` crate page on crates.io
3. **External resource**: The actual crate documentation and information

**Potential Issues/Areas for Improvement**: None identified in this specific code snippet. However, it's essential to ensure that the linked external resource remains up-to-date and accurate.

In general, when working with API reference documentation, consider the following best practices:

1. Ensure links are active and point to relevant resources.
2. Use clear and concise anchor text to help users navigate the documentation.
3. Regularly review and update API references as the underlying codebase or crate evolves.

This analysis highlights that this particular code snippet serves as a straightforward link to external documentation, with no complexities or areas for improvement in its own right."
i18n/zh/docusaurus-plugin-content-docs/current/develop/c/networking.md,"---
sidebar_position: 2
---

# Networking Socket

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Summary:**

The code snippet appears to be a Markdown file, likely part of a documentation project, specifically Docusaurus. The file is titled ""Networking Socket"" and has a `sidebar_position` value set to 2. It contains a warning indicating that the content is still a work in progress.

**Functionality:**

This file serves as a placeholder or a stub for documenting a section on Networking Sockets. The purpose of this file seems to be providing an empty template for future content creators to fill in, while also giving a heads-up to users that this specific topic is not yet fully developed.

**Key Components:**

1. **Metadata**: `sidebar_position` is set to 2, which likely determines the position of this documentation page within the sidebar navigation.
2. **Markdown Content**: The file contains basic Markdown formatting and some placeholder text (the ""Work in Progress"" message).

**Potential Issues or Areas for Improvement:**

1. **Lack of meaningful content**: This file does not contain any substantial information about Networking Sockets, making it less useful to users who are looking for documentation on this topic.
2. **Insufficient warning**: While the ""Work in Progress"" message is a good start, it might be more effective if the warning was clearer or more prominent, e.g., with an alarm icon or a more explicit statement about the content being incomplete.

**Recommendations:**

1. Fill in the documentation for Networking Sockets to make this page more useful.
2. Consider adding a more prominent warning or placeholder text to indicate that the content is still work in progress.
3. Review and revise the Markdown formatting and content structure to ensure consistency with other documentation pages."
i18n/zh/docusaurus-plugin-content-docs/current/embed/rust/reference.md,"---
sidebar_position: 7
---

# API Reference

Check out [the `wasmedge-sdk` crate](https://crates.io/crates/wasmedge-sdk) for more information.
","**Code Analysis Summary**

This is a Markdown file (`reference.md`) in the `i18n/zh/docusaurus-plugin-content-docs/current/embed/rust/reference` directory. The purpose of this file is to provide an API reference for Rust programming language.

**Key Components:**

1. **Sidebar Position:** The code specifies that the current page should be positioned at index 7 in the sidebar (`sidebar_position: 7`).
2. **API Reference Title:** The main title of the document is ""API Reference"".
3. **External Link:** There is a link to the `wasmedge-sdk` crate on crates.io for users who want more information about the API.

**Potential Issues or Areas for Improvement:**

1. **Lack of Content:** The current implementation only provides a brief title and an external link. A detailed API reference with descriptions, examples, and usage guides would be beneficial to users.
2. **Redundancy:** If the `wasmedge-sdk` crate is already linked elsewhere in the project, this redundancy might not be necessary.

**Recommendations:**

1. Expand on the API reference content to provide more information for developers.
2. Consider adding a table of contents or a list of APIs covered in the reference for better navigation.
3. Ensure that links and dependencies are up-to-date and correctly implemented to avoid potential errors."
docs/contribute/fuzzing.md,"---
sidebar_position: 5
---

# Fuzzing

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Based on the provided code snippet, here is a summary of its purpose, functionality, and key components:

**Summary**: This markdown document appears to be an incomplete contribution guideline for fuzzing in the project's documentation. The title suggests that fuzzing is a topic being worked on and not yet fully fleshed out.

**Functionality**: There doesn't seem to be any functional code provided; instead, it looks like a placeholder or a work-in-progress note.

**Key Components**:

* A markdown heading indicating the position of this document in the project's sidebar (sidebar_position: 5).
* An `info` box containing a warning label for ""Work in Progress"".
* The `prettier-ignore` directive, which is likely used to prevent prettier formatting from being applied to specific lines or sections of code.

**Potential Issues/ Areas for Improvement**:

* There is no actual content related to fuzzing provided; the file appears to be incomplete.
* The ""Work in Progress"" note might be misleading, as it implies that there's a tangible contribution process waiting to be documented.
* Without more context about the project or the specific requirements of the contribution guidelines, it's challenging to provide a thorough analysis."
docs/contribute/test.md,"---
sidebar_position: 4
---

# Testing

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Code Analysis Summary**

The provided code snippet appears to be a Markdown file named `test.md` located in the `docs/contribute` directory. Here's a breakdown of its purpose and functionality:

* **Purpose**: The file is intended for documenting testing procedures, likely for contributing or developing code.
* **Functionality**: There is no actual code written in this file; it only contains metadata and formatting information.

**Key Components**

1. `sidebar_position: 4`: This line specifies the position of the sidebar navigation for the page generated from this Markdown file.
2. `# Testing`: This heading indicates that the content will be related to testing procedures.
3. `<!-- prettier-ignore -->`: This comment is likely used by a code formatter (Prettier) to ignore formatting rules for the following lines.

**Potential Issues or Areas for Improvement**

* The file seems incomplete, with a ""Work in Progress"" label indicating that more content needs to be added.
* There are no actual testing procedures documented in this file.
* Consider reorganizing or splitting long files like this into smaller ones for better maintainability and clarity."
docs/develop/c/threads.md,"---
sidebar_position: 3
---

# Thread

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Here is a concise and coherent summary of the code:

**Summary**

The provided code snippet appears to be a documentation section for a ""Thread"" topic in an online knowledge base or wiki. It consists of a title (""Thread""), a heading level indicator (#), and a brief warning message that the content is still being worked on (<!-- prettier-ignore -->:::info Work in Progress:::).

**Key Components**

* Title: ""Thread""
* Heading level: ""#""
* Warning message: ""<!-- prettier-ignore -->:::info Work in Progress:::""

**Potential Issues or Areas for Improvement**

1. **Lack of content**: The documentation section is currently empty, which may make it difficult for readers to understand the topic.
2. **Outdated warning message**: Although the warning message indicates that the content is still being worked on, it is unclear what ""Work in Progress"" means in this context. Consider updating or removing it once the content is finalized.
3. **Missing organization structure**: Without any subheadings or clear sections, the documentation may feel disorganized and difficult to navigate. Consider adding more headings or separating related topics.

**Recommendations**

1. **Add content**: Fill out the documentation section with relevant information about threads, such as their definition, use cases, and examples.
2. **Update warning message (if necessary)**: Remove or update the ""Work in Progress"" warning once the content is finalized to avoid confusing readers.
3. **Organize content**: Break down the documentation into clear sections and subheadings to make it easier for readers to navigate."
docs/develop/deploy/kubernetes/openfunction.md,"---
sidebar_position: 9
---

# OpenFunction

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Here is a concise summary of the code:

**Summary**

The provided code snippet appears to be a section from an open-source documentation file (openfunction.md) for OpenFunction, a platform that allows developers to deploy serverless functions. The section is titled ""OpenFunction"" and has a position in the sidebar set to 9.

**Key Components**

1. **Metadata**: The code includes metadata such as `sidebar_position: 9`, which suggests it's part of a documentation hierarchy.
2. **Warning/Info block**: The code includes an info block with the text ""Work in Progress"", indicating that this section is currently being developed or updated.

**Purpose and Functionality**

This code snippet appears to be a placeholder or a notice for developers, indicating that the OpenFunction documentation is still under development. There is no functional code or configuration provided in this snippet.

**Potential Issues or Areas for Improvement**

1. **Incomplete Documentation**: The fact that it's marked as ""Work in Progress"" suggests that the documentation might not yet be comprehensive or accurate.
2. **Missing Content**: This section seems to be a placeholder, but the actual content related to OpenFunction is missing.

Please provide more context if you would like me to analyze any further code snippets from this file."
docs/embed/rust/asyncfy.md,"---
sidebar_position: 6
---

# Asyncfy

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Summary**

The provided code is a Markdown file (`asyncfy.md`) that appears to be part of an online documentation or tutorial series. It introduces the concept of ""Asyncfy"" and marks it as a ""Work in Progress"".

**Purpose and Functionality**

Based on the title and surrounding content, Asyncfy seems to be a tool or feature that allows users to transform synchronous code into asynchronous versions. The purpose is likely to provide a way to write more efficient, concurrent code in languages that support asynchronous programming.

**Key Components**

None are explicitly mentioned in this code snippet. However, based on the context, some possible components of Asyncfy might include:

* A transformation engine or algorithm for converting synchronous code into asynchronous versions
* Support for various programming languages and frameworks (e.g., Rust, JavaScript)
* Integration with existing libraries or tools to enhance performance

**Potential Issues and Areas for Improvement**

1. **Ambiguity around Asyncfy's purpose**: While the concept of transforming synchronous code into asynchronous versions is interesting, more context and examples would be helpful to understand its value proposition.
2. **Limited documentation**: The ""Work in Progress"" label suggests that the project is still under development. Consider adding more information on its features, benefits, and roadmap to keep users engaged.
3. **Lack of code snippets or examples**: To help users better understand how Asyncfy works, consider including short examples or code snippets illustrating its usage.

By addressing these concerns, the documentation for Asyncfy can become more comprehensive, user-friendly, and effective in promoting this innovative tool."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/fuzzing.md,"---
sidebar_position: 5
---

# Fuzzing

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Code Analysis Summary**

This is a markdown file (`fuzzing.md`) located in the Docusaurus plugin's documentation directory. Here's a summary of its purpose and functionality:

**Purpose:** This document appears to be an introductory guide on Fuzzing, a software testing technique that involves providing invalid or unexpected inputs to a program to test its behavior.

**Functionality:** The file contains a brief note indicating that the content is still a ""Work in Progress"". It also includes a prettier-ignore directive, which suggests that the formatting of this section may need special attention during code review.

**Key Components:**

1. **sidebar_position**: This line sets the position of the current document within the sidebar navigation.
2. **:::info...:::**: This is an info box containing a brief message indicating that the content is still under development.

**Potential Issues or Areas for Improvement:**

* The ""Work in Progress"" label may not be sufficient to indicate that the content is incomplete or inaccurate. Consider adding more explicit warnings or disclaimers.
* The use of prettier-ignore directives should be used judiciously and only when necessary, as it can make the code harder to read and review.

Overall, this markdown file appears to be a basic placeholder for future content on Fuzzing. Its purpose is clear, but its functionality is currently limited."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/test.md,"---
sidebar_position: 4
---

# Testing

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Summary**

The provided code is a Markdown file (`test.md`) located in the `i18n/zh/docusaurus-plugin-content-docs/current/contribute/test` directory. This file appears to be part of a documentation system, likely Docusaurus.

**Purpose and Functionality**

This file serves as a test or example document, marked with a ""Work in Progress"" note using Markdown syntax and an HTML-like info box component (`:::info`). The file also contains metadata in the first line, specifying the position of the sidebar.

**Key Components**

1. **Metadata**: `sidebar_position: 4` - specifies the position of the sidebar for this document.
2. **Markdown content**: The actual text content of the file is minimal, indicating that it's a test or placeholder page.
3. **Info box component**: `:::info` - used to mark the ""Work in Progress"" note.

**Potential Issues or Areas for Improvement**

1. **Empty content**: This document contains very little content, making it unclear what the purpose of this file is, beyond being a placeholder.
2. **Lack of context**: Without more information about the surrounding documentation and project requirements, it's difficult to determine if this file serves any specific purpose or if it can be safely removed.

In general, having an empty test document like this one might not provide much value unless it's used as a template for future documentation or testing purposes. In that case, it would be beneficial to provide more guidance on its intended use and potential next steps."
i18n/zh/docusaurus-plugin-content-docs/current/develop/c/threads.md,"---
sidebar_position: 3
---

# Thread

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Code Summary**

The provided code is a Markdown file for a documentation page in a Docusaurus project. It appears to be part of the `i18n/zh/docusaurus-plugin-content-docs` module, which suggests that it's a translation of an English version from this path.

**Functionality**

This code creates a new document with the following features:

1. **Sidebar Position**: The page will have a sidebar position of 3.
2. **Title**: The title of the page is ""Thread"".
3. **Warning Message**: A warning message is displayed at the top of the page, indicating that this content is still in progress (work-in-progress).

**Key Components**

1. **Front Matter**: The code begins with a YAML front matter section (`---`), which contains metadata for the document.
2. **Markdown Content**: The rest of the file contains Markdown-formatted text, including headings and warning messages.

**Potential Issues or Areas for Improvement**

1. **Missing content**: Although this is a work-in-progress page, it's expected to have some placeholder content or an outline to guide the development process. This is currently missing.
2. **Improper use of Docusaurus features**: The `sidebar_position` directive should be placed in a YAML front matter section with proper formatting (e.g., indentation)."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openfunction.md,"---
sidebar_position: 9
---

# OpenFunction

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Here is a concise summary of the provided code:

**Summary**

This markdown file appears to be part of a documentation project, likely for a website or knowledge base. The file describes the topic ""OpenFunction"" and has been assigned a position (9) in the sidebar.

**Key Components**

1. **Metadata**: The first line `---` indicates metadata that is not visible in the rendered markdown text.
2. **Sidebar Position**: The line `sidebar_position: 9` specifies the position of this page in the sidebar navigation.
3. **Title and Heading**: The title ""OpenFunction"" is displayed as a heading (H1) on the page.
4. **Status Indicator**: The warning icon `:::info` indicates that this content is still a work-in-progress.

**Potential Issues or Areas for Improvement**

None apparent in this code snippet. However, based on the context, it's likely that this file will need to be expanded with more content and possibly additional metadata (e.g., tags) as development progresses.

Please let me know if you'd like me to analyze any specific aspects of this code further!"
i18n/zh/docusaurus-plugin-content-docs/current/embed/rust/asyncfy.md,"---
sidebar_position: 6
---

# Asyncfy

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Here is a concise and coherent summary of the code:

**Summary:**

This is an Markdown document (`.md` file) for Docusaurus, a documentation platform. The document appears to be part of a series on asynchronous programming in Rust.

**Key Components:**

1. **sidebar_position**: This line sets the position of the document in the sidebar navigation of the documentation site, with a value of `6`.
2. **Title and Tag**: The title of the document is ""Asyncfy"", and it has an informational tag indicating that it's a work-in-progress.
3. **Content**: There is no actual content in this file, only a placeholder comment suggesting that it's currently under development.

**Potential Issues or Areas for Improvement:**

1. **Missing content**: As mentioned earlier, the file is empty except for the title and tag. This suggests that the document has not been fully implemented yet.
2. **Inconsistent formatting**: The use of `<!-- prettier-ignore -->` is a directive to disable Prettier's formatting for this line, which might be inconsistent with other parts of the documentation.

Overall, this code appears to be a placeholder or a starting point for further development, and it does not provide any concrete functionality."
docs/embed/rust/function.md,"---
sidebar_position: 3
---

# Embed WASM Functions and Async Functions

<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-4-define-and-register-a-host-function>

<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-5-define-and-register-async-host-functions>
","**Summary:**

The provided code snippet is part of the documentation for embedding WASM (WebAssembly) functions and async functions using the Wasmedge Rust SDK. The code demonstrates how to define and register host functions, as well as async host functions, which are essential components of building a web application that interacts with native code.

**Key Components:**

1. **Host Functions**: These are Rust functions that can be called from WASM code, enabling the interaction between the web application and native code.
2. **Async Host Functions**: Similar to host functions, but designed for asynchronous operations. They allow the web application to perform tasks in the background while maintaining responsiveness.

**Functionality:**

The code shows how to:

1. Define a new host function using the `#[no_mangle]` attribute, which makes the function callable from WASM.
2. Register the host function with Wasmedge using the `wasm_host_function` macro.
3. Define an async host function using the `async fn` syntax and the `#[wasmedge::main]` attribute to specify its entry point.
4. Register the async host function with Wasmedge.

**Potential Issues or Areas for Improvement:**

1. **Error Handling**: The code does not demonstrate how to handle errors that may occur during function execution or registration. Proper error handling is essential in production environments.
2. **Function Signatures**: The examples use simple function signatures, but in a real-world scenario, you might need to consider more complex signatures, such as functions with multiple parameters or return types.
3. **Performance Optimizations**: Depending on the specific requirements of your web application, you may need to optimize the performance of the embedded WASM code and host functions.

Overall, this code snippet provides a solid foundation for understanding how to embed WASM functions and async functions using the Wasmedge Rust SDK. However, it is essential to consider additional factors, such as error handling, function signatures, and performance optimizations, when building production-ready applications."
i18n/zh/docusaurus-plugin-content-docs/current/embed/rust/function.md,"---
sidebar_position: 3
---

# Embed WASM Functions and Async Functions

<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-4-define-and-register-a-host-function>

<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-5-define-and-register-async-host-functions>
","**Summary**

This Markdown file appears to be part of a documentation system for Docusaurus, a popular open-source static site generator. The content is related to embedding WebAssembly (WASM) functions and asynchronous functions using the Wasmedge-RustSDK library.

**Functionality**

The code provides links to external GitHub repositories that contain examples on how to:

1. Define and register a host function in WASM.
2. Define and register an async host function in WASM.

These examples are likely used as references or tutorials for developers interested in working with Wasmedge-RustSDK.

**Key Components**

* Markdown formatting, including headings (# Embed WASM Functions and Async Functions) and links to external resources (<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-4-define-and-register-a-host-function>).
* Links to Wasmedge-RustSDK library examples on GitHub.
* No code is provided in this file; it serves as a reference or pointer to external resources.

**Potential Issues/Areas for Improvement**

1. **Lack of context**: Without additional information, readers may not understand the purpose or context behind the links provided.
2. **No executable code**: The file does not contain any code examples that could be used for learning or reference purposes.
3. **Outdated links**: If the external resources referenced are moved or updated, the links in this file would become outdated.

To improve this file, consider adding more context, providing inline code examples, and regularly verifying the accuracy of linked resources."
CODE_OF_CONDUCT.md,"# WasmEdge Code of Conduct

See the Code of Conduct [here](https://github.com/WasmEdge/WasmEdge/blob/master/docs/CODE_OF_CONDUCT.md).
","Based on the provided code snippet from `CODE_OF_CONDUCT.md`, here is a summary of the code:

**Purpose:** The purpose of this code is to provide a link to the WasmEdge Code of Conduct document.

**Functionality:**

* The code provides an anchor link (#) with the title ""WasmEdge Code of Conduct"" that redirects users to the specified URL.
* The URL points to a separate Markdown file (`CODE_OF_CONDUCT.md`) located in the `docs` directory within the WasmEdge repository on GitHub.

**Key components:**

* A header with the title ""WasmEdge Code of Conduct""
* An anchor link (#) with the same title
* A hyperlink ([here](https://github.com/WasmEdge/WasmEdge/blob/master/docs/CODE_OF_CONDUCT.md)) to the Code of Conduct document

**Potential issues or areas for improvement:**

* The code assumes that the Code of Conduct document exists at a specific location in the repository, which might change in the future. It would be better to make the link more flexible or dynamic.
* The use of an absolute URL (https://github.com/WasmEdge/WasmEdge/blob/master/docs/CODE_OF_CONDUCT.md) might not be ideal for all users (e.g., those behind a corporate firewall). Consider providing both the GitHub-specific URL and a more general alternative."
docs/embed/rust/ai.md,"---
sidebar_position: 5
---

# AI Inference with Pytorch
","Based on the provided code snippet, it appears to be a Markdown document that serves as an introduction to AI Inference with PyTorch. Here is a concise summary of its purpose, functionality, and key components:

**Summary:**

This document is intended to provide an overview of using PyTorch for AI inference. The content will likely cover the basics of PyTorch, its application in AI inference, and possibly provide examples or tutorials on how to use it.

**Key Components:**

1. **Sidebar Position**: The `sidebar_position` metadata is set to 5, which suggests that this document will be placed at position 5 within a sidebar.
2. **Document Title**: The title of the document is ""AI Inference with Pytorch"".

**Potential Issues or Areas for Improvement:**

1. **Lack of Content**: Since the provided code snippet only includes metadata and a title, it's likely that the actual content of this document has not been included in the provided snippet.
2. **Unclear Purpose**: Without more information about the specific AI inference tasks that will be covered in this document, its purpose may be unclear to readers who are unfamiliar with PyTorch.

**Suggested Improvements:**

1. **Add more detailed content**: Include examples, tutorials, or explanations of how to use PyTorch for AI inference.
2. **Provide clear instructions on usage**: Make sure that the document provides a clear guide on how to apply the concepts and techniques discussed in the document.
3. **Consider adding a table of contents or index**: A well-organized structure would make it easier for readers to navigate the content of this document."
docs/embed/rust/app.md,"---
sidebar_position: 2
---

# Embed WASM Apps

<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-1-run-a-wasm-app-from-host>
","Summary:

The provided code snippet is a Markdown document that serves as an example of how to embed WebAssembly (WASM) applications in the browser using Rust and WASMedge. The document appears to be part of a larger documentation set, and this specific section explains how to run a WASM app from a host.

Purpose:

* To provide an example of embedding a WASM app using Rust and WASMedge
* To serve as a guide for developers on how to achieve this task

Functionality:

* The code snippet likely includes steps or instructions for setting up the project, compiling the Rust code, and loading the WASM app in the browser.
* It may also include links to external resources (such as GitHub repositories) for further information.

Key Components:

* WASMedge: A runtime environment for running WASM applications
* Rust: A programming language used for developing the WASM app
* WASM app: The application that will be embedded and run in the browser

Potential Issues or Areas for Improvement:

* The code snippet appears to be incomplete, as it only provides a link to an external resource. It would be more helpful if the actual code or instructions were included.
* There is no indication of how the WASM app is packaged or loaded into the browser. Additional information on this process might be necessary for developers to successfully embed the app.
* The documentation does not provide any information on debugging or troubleshooting techniques, which could be useful for developers encountering issues with embedding the app."
i18n/zh/docusaurus-plugin-content-docs/current/embed/rust/ai.md,"---
sidebar_position: 5
---

# AI Inference with Pytorch
","Based on the provided code, here is a summary of its purpose, functionality, and key components:

**Purpose:** The code defines a documentation page for AI Inference with PyTorch.

**Functionality:**

* The page is placed at position 5 in the sidebar.
* It is part of a larger documentation project that uses Docusaurus as the static site generator.

**Key Components:**

* `sidebar_position`: A metadata field that determines the position of the page in the sidebar.
* Markdown content: The code contains Markdown-formatted text, which will be rendered as HTML in the documentation site."
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
,,
i18n/zh/docusaurus-plugin-content-docs/current/embed/rust/app.md,"---
sidebar_position: 2
---

# Embed WASM Apps

<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-1-run-a-wasm-app-from-host>
","**Summary**

This is a Markdown file (`app.md`) that appears to be part of a documentation system for a Docusaurus plugin. The purpose of this file is to document how to embed WASM (WebAssembly) apps, specifically using the Rust programming language and the `wasmedge-rustsdk` library.

**Functionality**

The code snippet provides a link to an external resource (`README.md`) on GitHub, which contains examples for running a WASM app from a host. The file itself does not contain any executable code but serves as a documentation anchor point in the Docusaurus sidebar, indicating that this topic is located at position 2.

**Key Components**

1. **Metadata**: The first two lines (`sidebar_position: 2`) are metadata that define the document's position in the Docusaurus sidebar.
2. **Heading**: The `# Embed WASM Apps` heading serves as a title for the document.
3. **Link**: The `<https://github...>` link points to an external resource containing additional information on running WASM apps.

**Potential Issues or Areas for Improvement**

1. **Missing content**: The current file does not contain any useful content, making it unnecessary in its current form.
2. **Orphaned links**: If the linked GitHub repository is deleted or its URL changes, this document will become broken.
3. **Duplicated information**: Depending on the context of the Docusaurus plugin, it might be better to include a brief summary or example code within this file instead of relying solely on an external link.

**Recommendations**

1. Remove redundant metadata and focus on providing valuable content within the Markdown file.
2. Consider including a brief description or an example to make this document more informative.
3. Ensure that the linked resource remains up-to-date and accessible."
