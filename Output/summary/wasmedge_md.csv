Path,Content,Summary
docs/develop/javascript/ssr.md,"---
sidebar_position: 10
---

# Example: SSR

[React](https://reactjs.org/) is a very popular JavaScript web UI framework. A React application is ""compiled"" into an HTML and JavaScript static website. The web UI is rendered through the generated JavaScript code. However, executing the complex generated JavaScript entirely in the browser is often too slow and resource consuming to build the interactive HTML DOM objects. [React Server Side Rendering (SSR)](https://medium.com/jspoint/a-beginners-guide-to-react-server-side-rendering-ssr-bf3853841d55) delegates the JavaScript UI rendering to a server and has the server stream rendered HTML DOM objects to the browser. The WasmEdge JavaScript runtime provides a lightweight and high-performance container to run React SSR functions on edge servers.

Server-side rendering (SSR) is a popular technique for rendering a client-side single-page application (SPA) on the server and then sending a fully rendered page to the client, allowing dynamic components to be served as static HTML markup. This approach can be useful for search engine optimization (SEO) when indexing does not handle JavaScript properly. It may also be beneficial when downloading a large JavaScript bundle is impaired by a slow network. -- [from Digital Ocean](https://www.digitalocean.com/community/tutorials/react-server-side-rendering).

This article will show you how to use the WasmEdge QuickJS runtime to implement a React SSR function. Compared with the Docker + Linux + nodejs + v8 approach, WasmEdge is safer (suitable for multi-tenancy environments) and much lighter (1% of the footprint) with similar performance.

We will start with a complete tutorial to create and deploy a simple React Streaming SSR web application and then move on to a full React 18 demo.

- [Getting started with React streaming SSR](#getting-started)
- [A full React 18 app](#a-full-react-18-app)
- [Appendix: the create-react-app template](#appendix-the-create-react-app-template)

## Getting started

The [example_js/react_ssr_stream](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr_stream) folder in the GitHub repo contains the example's source code. It showcases how to render an HTML string from templates in a JavaScript app in WasmEdge.

The [component/LazyHome.jsx](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyHome.jsx) file is the main page template in React. It ""lazy"" loads the inner page template after a 2s delay once the outer HTML is rendered and returned to the user.

```javascript
import React, { Suspense } from 'react';
import * as LazyPage from './LazyPage.jsx';

async function sleep(ms) {
  return new Promise((r, _) => {
    setTimeout(() => r(), ms);
  });
}

async function loadLazyPage() {
  await sleep(2000);
  return LazyPage;
}

class LazyHome extends React.Component {
  render() {
    let LazyPage1 = React.lazy(() => loadLazyPage());
    return (
      <html lang=""en"">
        <head>
          <meta charSet=""utf-8"" />
          <title>Title</title>
        </head>
        <body>
          <div>
            <div> This is LazyHome </div>
            <Suspense fallback={<div> loading... </div>}>
              <LazyPage1 />
            </Suspense>
          </div>
        </body>
      </html>
    );
  }
}

export default LazyHome;
```

The [LazyPage.jsx](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyPage.jsx) is the inner page template. It is rendered 2s after the outer page is already returned to the user.

```javascript
import React from 'react';

class LazyPage extends React.Component {
  render() {
    return (
      <div>
        <div>This is lazy page</div>
      </div>
    );
  }
}

export default LazyPage;
```

The [main.mjs](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/main.mjs) file starts a non-blocking HTTP server using standard Node.js APIs, and then renders the HTML page in multiple chunks to the response.

```javascript
import * as React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import { createServer } from 'http';

import LazyHome from './component/LazyHome.jsx';

createServer((req, res) => {
  res.setHeader('Content-type', 'text/html; charset=utf-8');
  renderToPipeableStream(<LazyHome />).pipe(res);
}).listen(8001, () => {
  print('listen 8001...');
});
```

The [rollup.config.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/rollup.config.js) and [package.json](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/package.json) files are to build the React SSR dependencies and components into a bundled JavaScript file for WasmEdge. You should use the `npm` command to build it. The output is in the `dist/main.mjs` file.

```bash
npm install
npm run build
```

Copy over the system's `modules` to the working directory for Node.js API support as [noted here](nodejs.md).

```bash
cp -r ../../modules .
```

To run the example, do the following on the CLI to start the server.

```bash
nohup wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm dist/main.mjs &
```

Send the server an HTTP request via `curl` or the browser.

```bash
curl http://localhost:8001
```

The results are as follows. The service returns an HTML page with an empty inner section (i.e., the `loading` section), then 2s later, the HTML content for the inner section and the JavaScript to display.

```bash
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed

  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100   211    0   211    0     0   1029      0 --:--:-- --:--:-- --:--:--  1024
100   275    0   275    0     0    221      0 --:--:--  0:00:01 --:--:--   220
100   547    0   547    0     0    245      0 --:--:--  0:00:02 --:--:--   245
100  1020    0  1020    0     0    413      0 --:--:--  0:00:02 --:--:--   413

<!DOCTYPE html><html lang=""en""><head><meta charSet=""utf-8""/><title>Title</title></head><body><div><div> This is LazyHome </div><!--$?--><template id=""B:0""></template><div> loading... </div><!--/$--></div></body></html><div hidden id=""S:0""><template id=""P:1""></template></div><div hidden id=""S:1""><div><div>This is lazy page</div></div></div><script>function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(""S:1"",""P:1"")</script><script>function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if(""/$""===d)if(0===e)break;else e--;else""$""!==d&&""$?""!==d&&""$!""!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data=""$"";a._reactRetry&&a._reactRetry()}};$RC(""B:0"",""S:0"")</script>
```

## A full React 18 app

In this section, we will demonstrate a complete React 18 SSR application. It renders the web UI through streaming SSR. The [example_js/react18_ssr](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr) folder in the GitHub repo contains the example's source code. The [component](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr/component) folder contains the entire React 18 application's source code, and the [public](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr/public) folder contains the public resources (CSS and images) for the web application. The application also demonstrates a data provider for the UI.

The [main.mjs](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/main.mjs) file starts a non-blocking HTTP server, fetches data from a data provider, maps the `main.css` and `main.js` files in the `public` folder to web URLs, and then renders the HTML page for each request in `renderToPipeableStream()`.

```javascript
import * as React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import { createServer } from 'http';
import * as std from 'std';

import App from './component/App.js';
import { DataProvider } from './component/data.js';

let assets = {
  'main.js': '/main.js',
  'main.css': '/main.css',
};

const css = std.loadFile('./public/main.css');

function createServerData() {
  let done = false;
  let promise = null;
  return {
    read() {
      if (done) {
        return;
      }
      if (promise) {
        throw promise;
      }
      promise = new Promise((resolve) => {
        setTimeout(() => {
          done = true;
          promise = null;
          resolve();
        }, 2000);
      });
      throw promise;
    },
  };
}

createServer((req, res) => {
  print(req.url);
  if (req.url == '/main.css') {
    res.setHeader('Content-Type', 'text/css; charset=utf-8');
    res.end(css);
  } else if (req.url == '/favicon.ico') {
    res.end();
  } else {
    res.setHeader('Content-type', 'text/html');

    res.on('error', (e) => {
      print('res error', e);
    });
    let data = createServerData();
    print('createServerData');

    const stream = renderToPipeableStream(
      <DataProvider data={data}>
        <App assets={assets} />
      </DataProvider>,
      {
        onShellReady: () => {
          stream.pipe(res);
        },
        onShellError: (e) => {
          print('onShellError:', e);
        },
      },
    );
  }
}).listen(8002, () => {
  print('listen 8002...');
});
```

The [rollup.config.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/rollup.config.js) and [package.json](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/package.json) files are to build the React 18 SSR dependencies and components into a bundled JavaScript file for WasmEdge. You should use the `npm` command to build it. The output is in the `dist/main.mjs` file.

```bash
npm install
npm run build
```

Copy over the system's `modules` to the working directory for Node.js API support as [noted here](nodejs).

```bash
cp -r ../../modules .
```

To run the example, do the following on the CLI to start the server.

```bash
nohup wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm dist/main.mjs &
```

Send the server an HTTP request via `curl` or the browser.

```bash
curl http://localhost:8002
```

The results are as follows. The service returns an HTML page with an empty inner section (i.e., the `loading` section), and then 2s later, the HTML content for the inner section and the JavaScript to display it.

```bash
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed

  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100   439    0   439    0     0   1202      0 --:--:-- --:--:-- --:--:--  1199
100  2556    0  2556    0     0   1150      0 --:--:--  0:00:02 --:--:--  1150
100  2556    0  2556    0     0    926      0 --:--:--  0:00:02 --:--:--   926
100  2806    0  2806    0     0    984      0 --:--:--  0:00:02 --:--:--   984
<!DOCTYPE html><html lang=""en""><head><meta charSet=""utf-8""/><meta name=""viewport
"" content=""width=device-width, initial-scale=1""/><link rel=""stylesheet"" href=""/m
ain.css""/><title>Hello</title></head><body><noscript><b>Enable JavaScript to run
 this app.</b></noscript><!--$--><main><nav><a href=""/"">Home</a></nav><aside cla
ss=""sidebar""><!--$?--><template id=""B:0""></template><div class=""spinner spinner-
-active"" role=""progressbar"" aria-busy=""true""></div><!--/$--></aside><article cla
ss=""post""><!--$?--><template id=""B:1""></template><div class=""spinner spinner--ac
tive"" role=""progressbar"" aria-busy=""true""></div><!--/$--><section class=""comment
s""><h2>Comments</h2><!--$?--><template id=""B:2""></template><div class=""spinner s
pinner--active"" role=""progressbar"" aria-busy=""true""></div><!--/$--></section><h2
>Thanks for reading!</h2></article></main><!--/$--><script>assetManifest = {""mai
n.js"":""/main.js"",""main.css"":""/main.css""};</script></body></html><div hidden id=""
S:0""><template id=""P:3""></template></div><div hidden id=""S:1""><template id=""P:4""
></template></div><div hidden id=""S:2""><template id=""P:5""></template></div><div
hidden id=""S:3""><h1>Archive</h1><ul><li>May 2021</li><li>April 2021</li><li>Marc
h 2021</li><li>February 2021</li><li>January 2021</li><li>December 2020</li><li>
November 2020</li><li>October 2020</li><li>September 2020</li></ul></div><script
>function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for
(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChil
d,b);b.parentNode.removeChild(b)};$RS(""S:3"",""P:3"")</script><script>function $RC(
a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.remo
veChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{i
f(c&&8===c.nodeType){var d=c.data;if(""/$""===d)if(0===e)break;else e--;else""$""!==
d&&""$?""!==d&&""$!""!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.
firstChild;)f.insertBefore(b.firstChild,c);a.data=""$"";a._reactRetry&&a._reactRet
ry()}};$RC(""B:0"",""S:0"")</script><div hidden id=""S:4""><h1>Hello world</h1><p>This
 demo is <!-- --><b>artificially slowed down</b>. Open<!-- --> <!-- --><code>ser
ver/delays.js</code> to adjust how much different things are slowed down.<!-- --
></p><p>Notice how HTML for comments &quot;streams in&quot; before the JS (or Re
act) has loaded on the page.</p><p>Also notice that the JS for comments and side
bar has been code-split, but HTML for it is still included in the server output.
</p></div><script>$RS(""S:4"",""P:4"")</script><script>$RC(""B:1"",""S:1"")</script><div
 hidden id=""S:5""><p class=""comment"">Wait, it doesn&#x27;t wait for React to load
?</p><p class=""comment"">How does this even work?</p><p class=""comment"">I like ma
rshmallows</p></div><script>$RS(""S:5"",""P:5"")</script><script>$RC(""B:2"",""S:2"")</s
cript>
```

The streaming SSR examples make use of WasmEdge's unique asynchronous networking capabilities and ES6 module support (i.e., the roll-up bundled JS file contains ES6 modules). You can learn more about [async networking](networking.md) and [ES6](es6.md) in this book.

## Appendix the create-react-app template

The `create-react-app` template is a popular starting point for many developers to create React apps. In this tutorial, we will provide a step-by-step guide on how to use it to create React streaming SSR applications that run on WasmEdge.

### Step 1 — Create the React App

First, use `npx` to create a new React app. Let’s name the app `react-ssr-example`.

```bash
npx create-react-app react-ssr-example
```

Then, `cd` into the directory for the newly created app.

```bash
cd react-ssr-example
```

Start the new app to verify the installation.

```bash
npm start
```

You should see the example React app displayed in your browser window. At this stage, the app is rendered in the browser. The browser runs the generated React JavaScript to build the HTML DOM UI.

Now to prepare for SSR, you will need to make some changes to the app's `index.js` file. Change ReactDOM's `render` method to `hydrate` to indicate to the DOM renderer that you intend to rehydrate the app after it is rendered on the server. Replace the contents of the `index.js` file with the following.

```javascript
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
ReactDOM.hydrate(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root'),
);
```

<!-- prettier-ignore -->
:::note
You should import `React` redundantly in the `src/App.js`, so the server will recognize it.
:::

```js
import React from 'react';
//...
```

That concludes setting up the application. You can move on to setting up the server-side rendering functions.

### Step 2 — Create an WasmEdge QuickJS Server and Render the App Component

Now that you have the app in place let’s set up a server that will render the HTML DOM by running the React JavaScript and then send the rendered elements to the browser. We will use WasmEdge as a secure, high-performance, lightweight container to run React JavaScript.

Create a new `server` directory in the project's root directory.

```bash
mkdir server
```

Then, inside the `server` directory, create a new `index.js` file with the server code.

```javascript
import * as React from 'react';
import ReactDOMServer from 'react-dom/server';
import * as std from 'std';
import * as http from 'wasi_http';
import * as net from 'wasi_net';

import App from '../src/App.js';

async function handle_client(cs) {
  print('open:', cs.peer());
  let buffer = new http.Buffer();

  while (true) {
    try {
      let d = await cs.read();
      if (d == undefined || d.byteLength <= 0) {
        return;
      }
      buffer.append(d);
      let req = buffer.parseRequest();
      if (req instanceof http.WasiRequest) {
        handle_req(cs, req);
        break;
      }
    } catch (e) {
      print(e);
    }
  }
  print('end:', cs.peer());
}

function enlargeArray(oldArr, newLength) {
  let newArr = new Uint8Array(newLength);
  oldArr && newArr.set(oldArr, 0);
  return newArr;
}

async function handle_req(s, req) {
  print('uri:', req.uri);

  let resp = new http.WasiResponse();
  let content = '';
  if (req.uri == '/') {
    const app = ReactDOMServer.renderToString(<App />);
    content = std.loadFile('./build/index.html');
    content = content.replace(
      '<div id=""root""></div>',
      `<div id=""root"">${app}</div>`,
    );
  } else {
    let chunk = 1000; // Chunk size of each reading
    let length = 0; // The whole length of the file
    let byteArray = null; // File content as Uint8Array

    // Read file into byteArray by chunk
    let file = std.open('./build' + req.uri, 'r');
    while (true) {
      byteArray = enlargeArray(byteArray, length + chunk);
      let readLen = file.read(byteArray.buffer, length, chunk);
      length += readLen;
      if (readLen < chunk) {
        break;
      }
    }
    content = byteArray.slice(0, length).buffer;
    file.close();
  }
  let contentType = 'text/html; charset=utf-8';
  if (req.uri.endsWith('.css')) {
    contentType = 'text/css; charset=utf-8';
  } else if (req.uri.endsWith('.js')) {
    contentType = 'text/javascript; charset=utf-8';
  } else if (req.uri.endsWith('.json')) {
    contentType = 'text/json; charset=utf-8';
  } else if (req.uri.endsWith('.ico')) {
    contentType = 'image/vnd.microsoft.icon';
  } else if (req.uri.endsWith('.png')) {
    contentType = 'image/png';
  }
  resp.headers = {
    'Content-Type': contentType,
  };

  let r = resp.encode(content);
  s.write(r);
}

async function server_start() {
  print('listen 8002...');
  try {
    let s = new net.WasiTcpServer(8002);
    for (var i = 0; ; i++) {
      let cs = await s.accept();
      handle_client(cs);
    }
  } catch (e) {
    print(e);
  }
}

server_start();
```

The server renders the `<App>` component and then sends the rendered HTML string back to the browser. Three important things are taking place here.

- ReactDOMServer's `renderToString` is used to render the `<App/>` to an HTML string.
- The `index.html` file from the app's `build` output directory is loaded as a template. The app's content is injected into the `<div>` element with an id of `""root""`. It is then sent back as HTTP response.
- Other files from the `build` directory are read and served as needed at the requests of the browser.

### Step 3 — Build and deploy

For the server code to work, you will need to bundle and transpile it. This section will show you how to use Webpack and Babel. This next section will demonstrate an alternative (and potentially easier) approach using rollup.js.

Create a new Babel configuration file named `.babelrc.json` in the project's root directory and add the `env` and `react-app` presets.

```json
{
  ""presets"": [""@babel/preset-env"", ""@babel/preset-react""]
}
```

Create a webpack config for the server that uses Babel Loader to transpile the code. Create the `webpack.server.js` file in the project's root directory.

```js
const path = require('path');
module.exports = {
  entry: './server/index.js',
  externals: [
    { wasi_http: 'wasi_http' },
    { wasi_net: 'wasi_net' },
    { std: 'std' },
  ],
  output: {
    path: path.resolve('server-build'),
    filename: 'index.js',
    chunkFormat: 'module',
    library: {
      type: 'module',
    },
  },
  experiments: {
    outputModule: true,
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: 'babel-loader',
      },
      {
        test: /\.css$/,
        use: ['css-loader'],
      },
      {
        test: /\.svg$/,
        use: ['svg-url-loader'],
      },
    ],
  },
};
```

With this configuration, the transpired server bundle will be output to the `server-build` folder in a file called `index.js`.

Next, add the `svg-url-loader` package by entering the following commands in your terminal.

```bash
npm install svg-url-loader --save-dev
```

This completes the dependency installation and webpack and Babel configuration.

Now, revisit `package.json` and add helper npm scripts. Add `dev:build-server`, `dev:start-server` scripts to the `package.json` file to build and serve the SSR application.

```json
""scripts"": {
  ""dev:build-server"": ""NODE_ENV=development webpack --config webpack.server.js --mode=development"",
  ""dev:start-server"": ""wasmedge --dir .:. wasmedge_quickjs.wasm ./server-build/index.js"",
  // ...
},
```

- The `dev:build-server` script sets the environment to `""development""` and invokes webpack with the configuration file you created earlier.
- The `dev:start-server` script runs the WasmEdge server from the `wasmedge` CLI tool to serve the built output. The `wasmedge_quickjs.wasm` program contains the QuickJS runtime. [Learn more](hello_world.md)

Now you can run the following commands to build the client-side app, bundle and transpile the server code, and start the server on `:8002`.

```bash
npm run build
npm run dev:build-server
npm run dev:start-server
```

Open `http://localhost:8002/` in your web browser and observe your server-side rendered app.

Previously, the HTML source in the browser is simply the template with SSR placeholders.

```html
Output
<div id=""root""></div>
```

Now, with the SSR function running on the server, the HTML source in the browser is as follows.

```html
Output
<div id=""root""><div class=""App"" data-reactroot="""">...</div></div>
```

### Step 4 (alternative) -- build and deploy with rollup.js

Alternatively, you could use the [rollup.js](https://rollupjs.org/guide/en/) tool to [package all application components and library modules](npm.md) into a single file for WasmEdge to execute.

Create a rollup config for the server that uses Babel Loader to transpile the code. Create the `rollup.config.js` file in the project's root directory.

```js
const { babel } = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const builtins = require('rollup-plugin-node-builtins');
const plugin_async = require('rollup-plugin-async');
const css = require('rollup-plugin-import-css');
const svg = require('rollup-plugin-svg');

const babelOptions = {
  babelrc: false,
  presets: ['@babel/preset-react'],
  babelHelpers: 'bundled',
};

module.exports = [
  {
    input: './server/index.js',
    output: {
      file: 'server-build/index.js',
      format: 'esm',
    },
    external: ['std', 'wasi_net', 'wasi_http'],
    plugins: [
      plugin_async(),
      babel(babelOptions),
      nodeResolve({ preferBuiltins: true }),
      commonjs({ ignoreDynamicRequires: false }),
      css(),
      svg({ base64: true }),
      globals(),
      builtins(),
      replace({
        preventAssignment: true,
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];
```

With this configuration, the transpiled server bundle will be output to the `server-build` folder in a file called `index.js`.

Next, add the dependent packages to the `package.json` then install with `npm`.

```json
  ""devDependencies"": {
    //...
    ""@rollup/plugin-babel"": ""^5.3.0"",
    ""@rollup/plugin-commonjs"": ""^21.0.1"",
    ""@rollup/plugin-node-resolve"": ""^7.1.3"",
    ""@rollup/plugin-replace"": ""^3.0.0"",
    ""rollup"": ""^2.60.1"",
    ""rollup-plugin-async"": ""^1.2.0"",
    ""rollup-plugin-import-css"": ""^3.0.3"",
    ""rollup-plugin-node-builtins"": ""^2.1.2"",
    ""rollup-plugin-node-globals"": ""^1.4.0"",
    ""rollup-plugin-svg"": ""^2.0.0""
  }
```

```bash
npm install
```

This completes the dependency installation and rollup configuration.

Now, revisit `package.json` and add helper npm scripts. Add `dev:build-server`, `dev:start-server` scripts to the `package.json` file to build and serve the SSR application.

```json
""scripts"": {
  ""dev:build-server"": ""rollup -c rollup.config.js"",
  ""dev:start-server"": ""wasmedge --dir .:. wasmedge_quickjs.wasm ./server-build/index.js"",
  // ...
},
```

- The `dev:build-server` script sets the environment to `""development""` and invokes webpack with the configuration file you created earlier.
- The `dev:start-server` script runs the WasmEdge server from the `wasmedge` CLI tool to serve the built output. The `wasmedge_quickjs.wasm` program contains the QuickJS runtime. [Learn more](hello_world.md)

Now you can run the following commands to build the client-side app, bundle and transpile the server code, and start the server on `:8002`.

```bash
npm run build
npm run dev:build-server
npm run dev:start-server
```

Open `http://localhost:8002/` in your web browser and observe your server-side rendered app.

Previously, the HTML source in the browser was simply the template with SSR placeholders.

```html
Output
<div id=""root""></div>
```

Now, with the SSR function running on the server, the HTML source in the browser is as follows.

```html
Output
<div id=""root""><div class=""App"" data-reactroot="""">...</div></div>
```
","**Summary**

This article provides a detailed overview of how to create and deploy a simple React Streaming Server-Side Rendering (SSR) web application using the WasmEdge JavaScript runtime.

**Key Components**

*   `LazyHome` component: renders an HTML string from templates in a JavaScript app
*   `LazyPage` component: is rendered 2s after the outer page is already returned to the user
*   `main.mjs` file: starts a non-blocking HTTP server, fetches data from a data provider, and maps web URLs to file paths
*   Rollup configuration: bundles React dependencies and components into a single file for WasmEdge to execute

**Usage**

To use this code, follow these steps:

1.  Clone the repository and navigate to the `react_ssr_stream` folder.
2.  Install the required packages using `npm install`.
3.  Build the client-side app using `npm run build`.
4.  Build and serve the SSR application using `npm run dev:build-server` and `npm run dev:start-server`.
5.  Open `http://localhost:8002/` in your web browser to observe the server-side rendered app.

**Note**

This example demonstrates a basic React Streaming SSR application using WasmEdge. You can modify and extend this code to suit your specific needs and requirements.

**Advice**

When working with WasmEdge, keep in mind its unique asynchronous networking capabilities and ES6 module support. This allows for efficient streaming of server-side rendered content to the client. However, it also requires careful consideration of data synchronization and event handling between the server and client."
i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/ssr.md,"---
sidebar_position: 10
---

# Example: SSR

[React](https://reactjs.org/) is a very popular JavaScript web UI framework. A React application is ""compiled"" into an HTML and JavaScript static website. The web UI is rendered through the generated JavaScript code. However, executing the complex generated JavaScript entirely in the browser is often too slow and resource consuming to build the interactive HTML DOM objects. [React Server Side Rendering (SSR)](https://medium.com/jspoint/a-beginners-guide-to-react-server-side-rendering-ssr-bf3853841d55) delegates the JavaScript UI rendering to a server and has the server stream rendered HTML DOM objects to the browser. The WasmEdge JavaScript runtime provides a lightweight and high-performance container to run React SSR functions on edge servers.

Server-side rendering (SSR) is a popular technique for rendering a client-side single-page application (SPA) on the server and then sending a fully rendered page to the client, allowing dynamic components to be served as static HTML markup. This approach can be useful for search engine optimization (SEO) when indexing does not handle JavaScript properly. It may also be beneficial when downloading a large JavaScript bundle is impaired by a slow network. -- [from Digital Ocean](https://www.digitalocean.com/community/tutorials/react-server-side-rendering).

This article will show you how to use the WasmEdge QuickJS runtime to implement a React SSR function. Compared with the Docker + Linux + nodejs + v8 approach, WasmEdge is safer (suitable for multi-tenancy environments) and much lighter (1% of the footprint) with similar performance.

We will start with a complete tutorial to create and deploy a simple React Streaming SSR web application and then move on to a full React 18 demo.

- [Getting started with React streaming SSR](#getting-started)
- [A full React 18 app](#a-full-react-18-app)
- [Appendix: the create-react-app template](#appendix-the-create-react-app-template)

## Getting started

The [example_js/react_ssr_stream](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr_stream) folder in the GitHub repo contains the example's source code. It showcases how to render an HTML string from templates in a JavaScript app in WasmEdge.

The [component/LazyHome.jsx](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyHome.jsx) file is the main page template in React. It ""lazy"" loads the inner page template after a 2s delay once the outer HTML is rendered and returned to the user.

```javascript
import React, { Suspense } from 'react';
import * as LazyPage from './LazyPage.jsx';

async function sleep(ms) {
  return new Promise((r, _) => {
    setTimeout(() => r(), ms);
  });
}

async function loadLazyPage() {
  await sleep(2000);
  return LazyPage;
}

class LazyHome extends React.Component {
  render() {
    let LazyPage1 = React.lazy(() => loadLazyPage());
    return (
      <html lang=""en"">
        <head>
          <meta charSet=""utf-8"" />
          <title>Title</title>
        </head>
        <body>
          <div>
            <div> This is LazyHome </div>
            <Suspense fallback={<div> loading... </div>}>
              <LazyPage1 />
            </Suspense>
          </div>
        </body>
      </html>
    );
  }
}

export default LazyHome;
```

The [LazyPage.jsx](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyPage.jsx) is the inner page template. It is rendered 2s after the outer page is already returned to the user.

```javascript
import React from 'react';

class LazyPage extends React.Component {
  render() {
    return (
      <div>
        <div>This is lazy page</div>
      </div>
    );
  }
}

export default LazyPage;
```

The [main.mjs](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/main.mjs) file starts a non-blocking HTTP server using standard Node.js APIs, and then renders the HTML page in multiple chunks to the response.

```javascript
import * as React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import { createServer } from 'http';

import LazyHome from './component/LazyHome.jsx';

createServer((req, res) => {
  res.setHeader('Content-type', 'text/html; charset=utf-8');
  renderToPipeableStream(<LazyHome />).pipe(res);
}).listen(8001, () => {
  print('listen 8001...');
});
```

The [rollup.config.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/rollup.config.js) and [package.json](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/package.json) files are to build the React SSR dependencies and components into a bundled JavaScript file for WasmEdge. You should use the `npm` command to build it. The output is in the `dist/main.mjs` file.

```bash
npm install
npm run build
```

Copy over the system's `modules` to the working directory for Node.js API support as [noted here](nodejs.md).

```bash
cp -r ../../modules .
```

To run the example, do the following on the CLI to start the server.

```bash
nohup wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm dist/main.mjs &
```

Send the server an HTTP request via `curl` or the browser.

```bash
curl http://localhost:8001
```

The results are as follows. The service returns an HTML page with an empty inner section (i.e., the `loading` section), then 2s later, the HTML content for the inner section and the JavaScript to display.

```bash
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed

  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100   211    0   211    0     0   1029      0 --:--:-- --:--:-- --:--:--  1024
100   275    0   275    0     0    221      0 --:--:--  0:00:01 --:--:--   220
100   547    0   547    0     0    245      0 --:--:--  0:00:02 --:--:--   245
100  1020    0  1020    0     0    413      0 --:--:--  0:00:02 --:--:--   413

<!DOCTYPE html><html lang=""en""><head><meta charSet=""utf-8""/><title>Title</title></head><body><div><div> This is LazyHome </div><!--$?--><template id=""B:0""></template><div> loading... </div><!--/$--></div></body></html><div hidden id=""S:0""><template id=""P:1""></template></div><div hidden id=""S:1""><div><div>This is lazy page</div></div></div><script>function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(""S:1"",""P:1"")</script><script>function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if(""/$""===d)if(0===e)break;else e--;else""$""!==d&&""$?""!==d&&""$!""!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data=""$"";a._reactRetry&&a._reactRetry()}};$RC(""B:0"",""S:0"")</script>
```

## A full React 18 app

In this section, we will demonstrate a complete React 18 SSR application. It renders the web UI through streaming SSR. The [example_js/react18_ssr](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr) folder in the GitHub repo contains the example's source code. The [component](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr/component) folder contains the entire React 18 application's source code, and the [public](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr/public) folder contains the public resources (CSS and images) for the web application. The application also demonstrates a data provider for the UI.

The [main.mjs](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/main.mjs) file starts a non-blocking HTTP server, fetches data from a data provider, maps the `main.css` and `main.js` files in the `public` folder to web URLs, and then renders the HTML page for each request in `renderToPipeableStream()`.

```javascript
import * as React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import { createServer } from 'http';
import * as std from 'std';

import App from './component/App.js';
import { DataProvider } from './component/data.js';

let assets = {
  'main.js': '/main.js',
  'main.css': '/main.css',
};

const css = std.loadFile('./public/main.css');

function createServerData() {
  let done = false;
  let promise = null;
  return {
    read() {
      if (done) {
        return;
      }
      if (promise) {
        throw promise;
      }
      promise = new Promise((resolve) => {
        setTimeout(() => {
          done = true;
          promise = null;
          resolve();
        }, 2000);
      });
      throw promise;
    },
  };
}

createServer((req, res) => {
  print(req.url);
  if (req.url == '/main.css') {
    res.setHeader('Content-Type', 'text/css; charset=utf-8');
    res.end(css);
  } else if (req.url == '/favicon.ico') {
    res.end();
  } else {
    res.setHeader('Content-type', 'text/html');

    res.on('error', (e) => {
      print('res error', e);
    });
    let data = createServerData();
    print('createServerData');

    const stream = renderToPipeableStream(
      <DataProvider data={data}>
        <App assets={assets} />
      </DataProvider>,
      {
        onShellReady: () => {
          stream.pipe(res);
        },
        onShellError: (e) => {
          print('onShellError:', e);
        },
      },
    );
  }
}).listen(8002, () => {
  print('listen 8002...');
});
```

The [rollup.config.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/rollup.config.js) and [package.json](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/package.json) files are to build the React 18 SSR dependencies and components into a bundled JavaScript file for WasmEdge. You should use the `npm` command to build it. The output is in the `dist/main.mjs` file.

```bash
npm install
npm run build
```

Copy over the system's `modules` to the working directory for Node.js API support as [noted here](nodejs).

```bash
cp -r ../../modules .
```

To run the example, do the following on the CLI to start the server.

```bash
nohup wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm dist/main.mjs &
```

Send the server an HTTP request via `curl` or the browser.

```bash
curl http://localhost:8002
```

The results are as follows. The service returns an HTML page with an empty inner section (i.e., the `loading` section), and then 2s later, the HTML content for the inner section and the JavaScript to display it.

```bash
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed

  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100   439    0   439    0     0   1202      0 --:--:-- --:--:-- --:--:--  1199
100  2556    0  2556    0     0   1150      0 --:--:--  0:00:02 --:--:--  1150
100  2556    0  2556    0     0    926      0 --:--:--  0:00:02 --:--:--   926
100  2806    0  2806    0     0    984      0 --:--:--  0:00:02 --:--:--   984
<!DOCTYPE html><html lang=""en""><head><meta charSet=""utf-8""/><meta name=""viewport
"" content=""width=device-width, initial-scale=1""/><link rel=""stylesheet"" href=""/m
ain.css""/><title>Hello</title></head><body><noscript><b>Enable JavaScript to run
 this app.</b></noscript><!--$--><main><nav><a href=""/"">Home</a></nav><aside cla
ss=""sidebar""><!--$?--><template id=""B:0""></template><div class=""spinner spinner-
-active"" role=""progressbar"" aria-busy=""true""></div><!--/$--></aside><article cla
ss=""post""><!--$?--><template id=""B:1""></template><div class=""spinner spinner--ac
tive"" role=""progressbar"" aria-busy=""true""></div><!--/$--><section class=""comment
s""><h2>Comments</h2><!--$?--><template id=""B:2""></template><div class=""spinner s
pinner--active"" role=""progressbar"" aria-busy=""true""></div><!--/$--></section><h2
>Thanks for reading!</h2></article></main><!--/$--><script>assetManifest = {""mai
n.js"":""/main.js"",""main.css"":""/main.css""};</script></body></html><div hidden id=""
S:0""><template id=""P:3""></template></div><div hidden id=""S:1""><template id=""P:4""
></template></div><div hidden id=""S:2""><template id=""P:5""></template></div><div
hidden id=""S:3""><h1>Archive</h1><ul><li>May 2021</li><li>April 2021</li><li>Marc
h 2021</li><li>February 2021</li><li>January 2021</li><li>December 2020</li><li>
November 2020</li><li>October 2020</li><li>September 2020</li></ul></div><script
>function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for
(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChil
d,b);b.parentNode.removeChild(b)};$RS(""S:3"",""P:3"")</script><script>function $RC(
a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.remo
veChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{i
f(c&&8===c.nodeType){var d=c.data;if(""/$""===d)if(0===e)break;else e--;else""$""!==
d&&""$?""!==d&&""$!""!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.
firstChild;)f.insertBefore(b.firstChild,c);a.data=""$"";a._reactRetry&&a._reactRet
ry()}};$RC(""B:0"",""S:0"")</script><div hidden id=""S:4""><h1>Hello world</h1><p>This
 demo is <!-- --><b>artificially slowed down</b>. Open<!-- --> <!-- --><code>ser
ver/delays.js</code> to adjust how much different things are slowed down.<!-- --
></p><p>Notice how HTML for comments &quot;streams in&quot; before the JS (or Re
act) has loaded on the page.</p><p>Also notice that the JS for comments and side
bar has been code-split, but HTML for it is still included in the server output.
</p></div><script>$RS(""S:4"",""P:4"")</script><script>$RC(""B:1"",""S:1"")</script><div
 hidden id=""S:5""><p class=""comment"">Wait, it doesn&#x27;t wait for React to load
?</p><p class=""comment"">How does this even work?</p><p class=""comment"">I like ma
rshmallows</p></div><script>$RS(""S:5"",""P:5"")</script><script>$RC(""B:2"",""S:2"")</s
cript>
```

The streaming SSR examples make use of WasmEdge's unique asynchronous networking capabilities and ES6 module support (i.e., the roll-up bundled JS file contains ES6 modules). You can learn more about [async networking](networking.md) and [ES6](es6.md) in this book.

## Appendix the create-react-app template

The `create-react-app` template is a popular starting point for many developers to create React apps. In this tutorial, we will provide a step-by-step guide on how to use it to create React streaming SSR applications that run on WasmEdge.

### Step 1 — Create the React App

First, use `npx` to create a new React app. Let’s name the app `react-ssr-example`.

```bash
npx create-react-app react-ssr-example
```

Then, `cd` into the directory for the newly created app.

```bash
cd react-ssr-example
```

Start the new app to verify the installation.

```bash
npm start
```

You should see the example React app displayed in your browser window. At this stage, the app is rendered in the browser. The browser runs the generated React JavaScript to build the HTML DOM UI.

Now to prepare for SSR, you will need to make some changes to the app's `index.js` file. Change ReactDOM's `render` method to `hydrate` to indicate to the DOM renderer that you intend to rehydrate the app after it is rendered on the server. Replace the contents of the `index.js` file with the following.

```javascript
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
ReactDOM.hydrate(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root'),
);
```

<!-- prettier-ignore -->
:::note
You should import `React` redundantly in the `src/App.js`, so the server will recognize it.
:::

```js
import React from 'react';
//...
```

That concludes setting up the application. You can move on to setting up the server-side rendering functions.

### Step 2 — Create an WasmEdge QuickJS Server and Render the App Component

Now that you have the app in place let’s set up a server that will render the HTML DOM by running the React JavaScript and then send the rendered elements to the browser. We will use WasmEdge as a secure, high-performance, lightweight container to run React JavaScript.

Create a new `server` directory in the project's root directory.

```bash
mkdir server
```

Then, inside the `server` directory, create a new `index.js` file with the server code.

```javascript
import * as React from 'react';
import ReactDOMServer from 'react-dom/server';
import * as std from 'std';
import * as http from 'wasi_http';
import * as net from 'wasi_net';

import App from '../src/App.js';

async function handle_client(cs) {
  print('open:', cs.peer());
  let buffer = new http.Buffer();

  while (true) {
    try {
      let d = await cs.read();
      if (d == undefined || d.byteLength <= 0) {
        return;
      }
      buffer.append(d);
      let req = buffer.parseRequest();
      if (req instanceof http.WasiRequest) {
        handle_req(cs, req);
        break;
      }
    } catch (e) {
      print(e);
    }
  }
  print('end:', cs.peer());
}

function enlargeArray(oldArr, newLength) {
  let newArr = new Uint8Array(newLength);
  oldArr && newArr.set(oldArr, 0);
  return newArr;
}

async function handle_req(s, req) {
  print('uri:', req.uri);

  let resp = new http.WasiResponse();
  let content = '';
  if (req.uri == '/') {
    const app = ReactDOMServer.renderToString(<App />);
    content = std.loadFile('./build/index.html');
    content = content.replace(
      '<div id=""root""></div>',
      `<div id=""root"">${app}</div>`,
    );
  } else {
    let chunk = 1000; // Chunk size of each reading
    let length = 0; // The whole length of the file
    let byteArray = null; // File content as Uint8Array

    // Read file into byteArray by chunk
    let file = std.open('./build' + req.uri, 'r');
    while (true) {
      byteArray = enlargeArray(byteArray, length + chunk);
      let readLen = file.read(byteArray.buffer, length, chunk);
      length += readLen;
      if (readLen < chunk) {
        break;
      }
    }
    content = byteArray.slice(0, length).buffer;
    file.close();
  }
  let contentType = 'text/html; charset=utf-8';
  if (req.uri.endsWith('.css')) {
    contentType = 'text/css; charset=utf-8';
  } else if (req.uri.endsWith('.js')) {
    contentType = 'text/javascript; charset=utf-8';
  } else if (req.uri.endsWith('.json')) {
    contentType = 'text/json; charset=utf-8';
  } else if (req.uri.endsWith('.ico')) {
    contentType = 'image/vnd.microsoft.icon';
  } else if (req.uri.endsWith('.png')) {
    contentType = 'image/png';
  }
  resp.headers = {
    'Content-Type': contentType,
  };

  let r = resp.encode(content);
  s.write(r);
}

async function server_start() {
  print('listen 8002...');
  try {
    let s = new net.WasiTcpServer(8002);
    for (var i = 0; ; i++) {
      let cs = await s.accept();
      handle_client(cs);
    }
  } catch (e) {
    print(e);
  }
}

server_start();
```

The server renders the `<App>` component and then sends the rendered HTML string back to the browser. Three important things are taking place here.

- ReactDOMServer's `renderToString` is used to render the `<App/>` to an HTML string.
- The `index.html` file from the app's `build` output directory is loaded as a template. The app's content is injected into the `<div>` element with an id of `""root""`. It is then sent back as HTTP response.
- Other files from the `build` directory are read and served as needed at the requests of the browser.

### Step 3 — Build and deploy

For the server code to work, you will need to bundle and transpile it. This section will show you how to use Webpack and Babel. This next section will demonstrate an alternative (and potentially easier) approach using rollup.js.

Create a new Babel configuration file named `.babelrc.json` in the project's root directory and add the `env` and `react-app` presets.

```json
{
  ""presets"": [""@babel/preset-env"", ""@babel/preset-react""]
}
```

Create a webpack config for the server that uses Babel Loader to transpile the code. Create the `webpack.server.js` file in the project's root directory.

```js
const path = require('path');
module.exports = {
  entry: './server/index.js',
  externals: [
    { wasi_http: 'wasi_http' },
    { wasi_net: 'wasi_net' },
    { std: 'std' },
  ],
  output: {
    path: path.resolve('server-build'),
    filename: 'index.js',
    chunkFormat: 'module',
    library: {
      type: 'module',
    },
  },
  experiments: {
    outputModule: true,
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: 'babel-loader',
      },
      {
        test: /\.css$/,
        use: ['css-loader'],
      },
      {
        test: /\.svg$/,
        use: ['svg-url-loader'],
      },
    ],
  },
};
```

With this configuration, the transpired server bundle will be output to the `server-build` folder in a file called `index.js`.

Next, add the `svg-url-loader` package by entering the following commands in your terminal.

```bash
npm install svg-url-loader --save-dev
```

This completes the dependency installation and webpack and Babel configuration.

Now, revisit `package.json` and add helper npm scripts. Add `dev:build-server`, `dev:start-server` scripts to the `package.json` file to build and serve the SSR application.

```json
""scripts"": {
  ""dev:build-server"": ""NODE_ENV=development webpack --config webpack.server.js --mode=development"",
  ""dev:start-server"": ""wasmedge --dir .:. wasmedge_quickjs.wasm ./server-build/index.js"",
  // ...
},
```

- The `dev:build-server` script sets the environment to `""development""` and invokes webpack with the configuration file you created earlier.
- The `dev:start-server` script runs the WasmEdge server from the `wasmedge` CLI tool to serve the built output. The `wasmedge_quickjs.wasm` program contains the QuickJS runtime. [Learn more](hello_world.md)

Now you can run the following commands to build the client-side app, bundle and transpile the server code, and start the server on `:8002`.

```bash
npm run build
npm run dev:build-server
npm run dev:start-server
```

Open `http://localhost:8002/` in your web browser and observe your server-side rendered app.

Previously, the HTML source in the browser is simply the template with SSR placeholders.

```html
Output
<div id=""root""></div>
```

Now, with the SSR function running on the server, the HTML source in the browser is as follows.

```html
Output
<div id=""root""><div class=""App"" data-reactroot="""">...</div></div>
```

### Step 4 (alternative) -- build and deploy with rollup.js

Alternatively, you could use the [rollup.js](https://rollupjs.org/guide/en/) tool to [package all application components and library modules](npm.md) into a single file for WasmEdge to execute.

Create a rollup config for the server that uses Babel Loader to transpile the code. Create the `rollup.config.js` file in the project's root directory.

```js
const { babel } = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const builtins = require('rollup-plugin-node-builtins');
const plugin_async = require('rollup-plugin-async');
const css = require('rollup-plugin-import-css');
const svg = require('rollup-plugin-svg');

const babelOptions = {
  babelrc: false,
  presets: ['@babel/preset-react'],
  babelHelpers: 'bundled',
};

module.exports = [
  {
    input: './server/index.js',
    output: {
      file: 'server-build/index.js',
      format: 'esm',
    },
    external: ['std', 'wasi_net', 'wasi_http'],
    plugins: [
      plugin_async(),
      babel(babelOptions),
      nodeResolve({ preferBuiltins: true }),
      commonjs({ ignoreDynamicRequires: false }),
      css(),
      svg({ base64: true }),
      globals(),
      builtins(),
      replace({
        preventAssignment: true,
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];
```

With this configuration, the transpiled server bundle will be output to the `server-build` folder in a file called `index.js`.

Next, add the dependent packages to the `package.json` then install with `npm`.

```json
  ""devDependencies"": {
    //...
    ""@rollup/plugin-babel"": ""^5.3.0"",
    ""@rollup/plugin-commonjs"": ""^21.0.1"",
    ""@rollup/plugin-node-resolve"": ""^7.1.3"",
    ""@rollup/plugin-replace"": ""^3.0.0"",
    ""rollup"": ""^2.60.1"",
    ""rollup-plugin-async"": ""^1.2.0"",
    ""rollup-plugin-import-css"": ""^3.0.3"",
    ""rollup-plugin-node-builtins"": ""^2.1.2"",
    ""rollup-plugin-node-globals"": ""^1.4.0"",
    ""rollup-plugin-svg"": ""^2.0.0""
  }
```

```bash
npm install
```

This completes the dependency installation and rollup configuration.

Now, revisit `package.json` and add helper npm scripts. Add `dev:build-server`, `dev:start-server` scripts to the `package.json` file to build and serve the SSR application.

```json
""scripts"": {
  ""dev:build-server"": ""rollup -c rollup.config.js"",
  ""dev:start-server"": ""wasmedge --dir .:. wasmedge_quickjs.wasm ./server-build/index.js"",
  // ...
},
```

- The `dev:build-server` script sets the environment to `""development""` and invokes webpack with the configuration file you created earlier.
- The `dev:start-server` script runs the WasmEdge server from the `wasmedge` CLI tool to serve the built output. The `wasmedge_quickjs.wasm` program contains the QuickJS runtime. [Learn more](hello_world.md)

Now you can run the following commands to build the client-side app, bundle and transpile the server code, and start the server on `:8002`.

```bash
npm run build
npm run dev:build-server
npm run dev:start-server
```

Open `http://localhost:8002/` in your web browser and observe your server-side rendered app.

Previously, the HTML source in the browser was simply the template with SSR placeholders.

```html
Output
<div id=""root""></div>
```

Now, with the SSR function running on the server, the HTML source in the browser is as follows.

```html
Output
<div id=""root""><div class=""App"" data-reactroot="""">...</div></div>
```
","**Summary of the Code and its Functionality**

The code provided is a React application with server-side rendering (SSR) using WasmEdge as a runtime environment. The application consists of a client-side part, which is built with Webpack and Babel, and a server-side part, which is built with Rollup.js.

**Client-Side Part:**

*   Uses Webpack to bundle the React code into a single file
*   Configures Babel to transpile the code from ES6 to ES5 for better compatibility

**Server-Side Part:**

*   Uses Rollup.js to bundle the server-side code into a single file
*   Configures Rollup with various plugins, including Babel, Node Resolve, CommonJS, and others, to enable the necessary features for SSR

**WasmEdge Runtime:**

*   Used as the runtime environment for both client-side and server-side parts of the application
*   Provides a lightweight and high-performance container for running JavaScript code

**Key Functionality:**

*   Server-side rendering (SSR) allows for faster page loading times and better SEO
*   WasmEdge provides a secure and efficient way to run JavaScript code on both client-side and server-side

**Potential Issues or Areas for Improvement:**

*   The use of multiple bundlers and build tools might lead to complexity and maintenance issues
*   The application relies heavily on WasmEdge, which might require additional setup and configuration
*   Error handling and debugging might be more challenging due to the SSR architecture and WasmEdge runtime"
docs/start/install.md,"---
sidebar_position: 2
---

# Install and uninstall WasmEdge

This chapter will discuss ways to install and uninstall the WasmEdge Runtime on various OSes and platforms. We will cover how to install plug-ins to WasmEdge.

<!-- prettier-ignore -->
:::note
Docker Desktop 4.15+ already has WasmEdge bundled in its distribution binary. If you use Docker Desktop, you will not need to install WasmEdge separately. Check out [how to run WasmEdge apps in Docker Desktop.](build-and-run/docker_wasm.md)
:::

## Install

You can install the WasmEdge Runtime on any generic Linux and MacOS platforms. If you use Windows 10 or Fedora / Red Hat Linux systems, you can install with their default package managers.

### Generic Linux and MacOS

The easiest way to install WasmEdge is to run the following command. Your system should have `git` and `curl` as prerequisites.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
```

Run the following command to make the installed binary available in the current session.

```bash
source $HOME/.wasmedge/env
```

#### Install for all users

WasmEdge is installed in the `$HOME/.wasmedge` directory by default. You can install it into a system directory, such as `/usr/local` to make it available to all users. To specify an install directory, run the `install.sh` script with the `-p` flag. You will need to run the following commands as the `root` user or `sudo` since they are written write into system directories.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local
```

#### Install a specific version of WasmEdge

The WasmEdge installer script will install the latest official release by default. You could install a specific version of WasmEdge, including pre-releases or old releases by passing the `-v` argument to the installer script. Here is an example.

```bash
VERSION={{ wasmedge_version }}
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v $VERSION
```

Suppose you are interested in the latest builds from the `HEAD` of the `master` branch, which is basically WasmEdge's nightly builds. In that case, you can download the release package directly from our Github Action's CI artifact. [Here is an example](https://github.com/WasmEdge/WasmEdge/actions/runs/2969775464#artifacts).

#### Install WasmEdge with plug-ins

WasmEdge plug-ins are pre-built native modules that provide additional functionalities to the WasmEdge Runtime. To install plug-ins with the runtime, you can pass the `--plugins` parameter in the installer. For example, the command below installs the `wasi_nn-ggml` plug-in to enable LLM (Large Language Model) inference.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-ggml
```

To install multiple plug-ins, you can pass a list of plug-ins with the `--plugins` option. For example, the following command installs the `wasi_logging` and the `wasi_nn-ggml` plug-ins. The `wasi_logging` plug-in allows the Rust [log::Log](https://crates.io/crates/log) API to compile into Wasm and run in WasmEdge.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_logging wasi_nn-ggml
```

The installer downloads the plug-in files from the WasmEdge release on GitHub, unzips them, and then copies them over to the `~/.wasmedge/plugin/` folder (for user install) and to the `/usr/local/lib/wasmedge/` folder (for system install).

<!-- prettier-ignore -->
:::note
AI plug-ins for WasmEdge, such as the `OpenVINO backend` or `PyTorch backend` for `WASI-NN` plug-ins, have additional dependencies on the `OpenVINO` or `PyTorch` runtime libraries. [See the next section](#install-wasmedge-plug-ins-and-dependencies) for commands to install the plug-in dependencies.
:::

### Windows

For `Windows 10`, you could use Windows Package Manager Client (aka `winget.exe`) to install WasmEdge with one single command in your terminal.

```bash
winget install wasmedge
```

To install plug-ins, you can download plug-in binary modules from the WasmEdge release page, unzip them, and then copy them to `C:\Program Files\WasmEdge\lib`.

### Fedora and Red Hat Linux

WasmEdge is now an official package on Fedora 36, Fedora 37, Fedora 38, Fedora EPEL 8, and Fedora EPEL 9. Check out the stable version [here](https://src.fedoraproject.org/rpms/wasmedge). To install WasmEdge on Fedora, run the following command:

```bash
dnf install wasmedge
```

For more usages, please check out Fedora docs.

To install plug-ins, you can download plug-in binary modules from the WasmEdge release page, unzip them, and then copy them over to `/usr/local/lib/wasmedge/`.

## What's installed

If you install into the `$HOME/.wasmedge` directory, you will have the following directories and files after installation:

- The `$HOME/.wasmedge/bin` directory contains the WasmEdge Runtime CLI executable files. You can copy and move them around on your file system.

  - The `wasmedge` tool is the standard WasmEdge runtime. You can use it from the CLI.
    - Execute a WASM file: `wasmedge --dir .:. app.wasm`
  - The `wasmedgec` tool is the ahead-of-time (AOT) compiler to compile a `.wasm` file into a native `.so` file (or `.dylib` on MacOS, `.dll` on Windows, or `.wasm` as the universal WASM format on all platforms). The `wasmedge` can then execute the output file.

    - Compile a WASM file into a AOT-compiled WASM: `wasmedgec app.wasm app.so`
    - Execute the WASM in AOT mode: `wasmedge --dir .:. app.so`

    <!-- prettier-ignore -->
    :::note
    The usage of `wasmedgec` is equal to `wasmedge compile`. We decide to deprecate `wasmedgec` in the future.
    :::

- The `$HOME/.wasmedge/lib` directory contains WasmEdge shared libraries and dependency libraries. They are useful for WasmEdge SDKs to launch WasmEdge programs and functions from host applications.
- The `$HOME/.wasmedge/include` directory contains the WasmEdge header files. They are useful for WasmEdge SDKs.
- The `$HOME/.wasmedge/plugin` directory contains the WasmEdge plug-ins. They are loadable extensions for WasmEdge SDKs and will automatically be loaded when running the WasmEdge CLI.

<!-- prettier-ignore -->
:::note
You could also change it to `/usr/local` if you did a system-wide install.
If you used `winget` to install WasmEdge, the files are located at `C:\Program Files\WasmEdge`.
:::

## Install WasmEdge plug-ins and dependencies

WasmEdge uses plug-ins to extend its functionality. If you want to use more of WasmEdge's features, you can install WasmEdge along with its plug-ins and extensions as described below:

### The logging plug-in

The `wasi_logging` plug-in supports the [log::Log](https://crates.io/crates/log) Rust API.
It allows [log::Log](https://crates.io/crates/log) in Rust code to be compiled to Wasm and to run in WasmEdge.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_logging
```

[See more examples](https://github.com/WasmEdge/WasmEdge/tree/master/examples/plugin/wasi-logging)

### WASI-NN plug-ins

WasmEdge supports various backends for `WASI-NN`, which provides a standardized API for WasmEdge applications to access AI models for inference. Each backend supports a specific type of AI models.

- [ggml backend](#wasi-nn-plug-in-with-ggml-backend): supported on `Ubuntu 20.04+` and macOS.
- [PyTorch backend](#wasi-nn-plug-in-with-pytorch-backend): supported on `Ubuntu 20.04+` and `manylinux2014_x86_64`.
- [OpenVINO™ backend](#wasi-nn-plug-in-with-openvino-backend): supported on `Ubuntu 20.04+`.
- [TensorFlow-Lite backend](#wasi-nn-plug-in-with-tensorflow-lite-backend): supported on `Ubuntu 20.04+`, `manylinux2014_x86_64`, and `manylinux2014_aarch64`.

Noticed that the backends are exclusive. Developers can only choose and install one backend for the `WASI-NN` plug-in.

#### WASI-NN plug-in with ggml backend

The WASI-NN plug-in with ggml backend allows WasmEdge to run llama2 inference. To install WasmEdge with WASI-NN ggml backend, please pass the `wasi_nn-ggml` option to the `--plugins` flag when running the installer command.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-ggml
```

Please note, the installer from WasmEdge 0.13.5 will detect CUDA automatically. If CUDA is detected, the installer will always attempt to install a CUDA-enabled version of the plug-in.

If CPU is the only available hardware on your machine, the installer will install OpenBLAS version of plugin instead.

```bash
apt update && apt install -y libopenblas-dev # You may need sudo if the user is not root.
```

Then, go to the [Llama2 inference in Rust chapter](../develop/rust/wasinn/llm_inference) to see how to run AI inference with llama2 series of models.

#### WASI-NN plug-in with PyTorch backend

The WASI-NN plug-in with PyTorch backend allows WasmEdge applications to perform PyTorch model inference. To install WasmEdge with WASI-NN PyTorch backend, please pass the `wasi_nn-pytorch` option to the `--plugins` flag when running the installer command.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-pytorch
```

The WASI-NN plug-in with PyTorch backend depends on the `libtorch` C++ library to perform AI/ML computations. You need to install the [PyTorch 1.8.2 LTS](https://pytorch.org/get-started/locally/) dependencies for it to work properly.

```bash
export PYTORCH_VERSION=""1.8.2""
# For the Ubuntu 20.04 or above, use the libtorch with cxx11 abi.
export PYTORCH_ABI=""libtorch-cxx11-abi""
# For the manylinux2014, please use the without cxx11 abi version:
#   export PYTORCH_ABI=""libtorch""
curl -s -L -O --remote-name-all https://download.pytorch.org/libtorch/lts/1.8/cpu/${PYTORCH_ABI}-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip
unzip -q ""${PYTORCH_ABI}-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""
rm -f ""${PYTORCH_ABI}-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""
export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:$(pwd)/libtorch/lib
```

<!-- prettier-ignore -->
:::note
For the `Ubuntu 20.04` or above versions, the WasmEdge installer will install the `Ubuntu` version of WasmEdge and its plug-ins.
For other systems, the WasmEdge installer will install the `manylinux2014` version, and you should get the `libtorch` without `cxx11-abi`.
:::

Then, go to the [WASI-NN PyTorch backend in Rust chapter](../develop/rust/wasinn/pytorch) to see how to run AI inference with `Pytorch`.

#### WASI-NN plug-in with OpenVINO backend

The WASI-NN plug-in with the OpenVINO backend allows WasmEdge applications to perform OpenVINO model inference. To install WasmEdge with WASI-NN OpenVINO backend, please pass the `wasi_nn-openvino` option to the `--plugins` flag when running the installer command.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-openvino
```

The WASI-NN plug-in with OpenVINO backend depends on the OpenVINO C library to perform AI/ML computations. [OpenVINO](https://docs.openvino.ai/2023.0/openvino_docs_install_guides_installing_openvino_apt.html)(2023) dependencies. The following instructions are for Ubuntu 20.04 and above.

```bash
wget https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB
sudo apt-key add GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB
echo ""deb https://apt.repos.intel.com/openvino/2023 ubuntu20 main"" | sudo tee /etc/apt/sources.list.d/intel-openvino-2023.list
sudo apt update
sudo apt-get -y install openvino
ldconfig
```

Then, go to the [WASI-NN OpenVINO backend in Rust](../develop/rust/wasinn/openvino) chapter to see how to run AI inference with `OpenVINO.

#### WASI-NN plug-in with TensorFlow-Lite backend

The WASI-NN plug-in with Tensorflow-Lite backend allows WasmEdge applications to perform Tensorflow-Lite model inference. To install WasmEdge with WASI-NN Tensorflow-Lite backend, please pass the `wasi_nn-tensorflowlite` option to the `--plugins` flag when running the installer command.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-tensorflowlite
```

The WASI-NN plug-in with Tensorflow-Lite backend depends on the `libtensorflowlite_c` shared library to perform AI/ML computations, and it will be installed by the installer automatically.

<!-- prettier-ignore -->
:::note
If you install this plug-in WITHOUT installer, you can [refer to here to install the dependency](#tensorflow-lite-dependencies).
:::note

Then, go to [WASI-NN TensorFlow-lite backend in Rust chapter](../develop/rust/wasinn/tensorflow_lite) to see how to run AI inference with TensorFlow-Lite.

### WASI-Crypto Plug-in

[WASI-crypto](https://github.com/WebAssembly/wasi-crypto) is Cryptography API proposals for WASI. To use WASI-Crypto proposal, please use the `--plugins wasi_crypto` parameter when [running the installer command](#generic-linux-and-macos).

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_crypto
```

Then, go to [WASI-Crypto in Rust chapter](../develop/rust/wasicrypto.md) to see how to run WASI-crypto functions.

### WasmEdge OpenCV mini Plug-in

The WasmEdge OpenCV Mini plug-in supports a subset of OpenCV APIs in a [Rust API](https://github.com/second-state/opencvmini).
It is essential for developing image processing / vision AI applications in WasmEdge.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasmedge_opencvmini
```

[See an example](https://github.com/second-state/opencvmini-example)

### WasmEdge zlib Plug-in

The zlib is required for compiling and running many existing C / C++ / Rust apps in Wasm. Most noticeably, it is required for the Python port to Wasm. It supports the standard [zlib.h](https://github.com/madler/zlib/blob/develop/zlib.h) C API.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasmedge_zlib
```

[See an example](https://github.com/WasmEdge/WasmEdge/tree/master/examples/plugin/wasmedge-zlib).

### WasmEdge Image Plug-in

The wasmEdge-Image plug-in can help developers to load and decode JPEG and PNG images and convert into tensors. To install this plug-in, please use the `--plugins wasmedge_image` parameter when [running the installer command](#generic-linux-and-macos).

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasmedge_image
```

Then, go to [TensorFlow interface (image part) in Rust chapter](../develop/rust/wasinn/tf_plugin.md#image-loading-and-conversion) to see how to run WasmEdge-Image functions.

### WasmEdge TensorFlow Plug-in

The WasmEdge-TensorFlow plug-in can help developers to perform TensorFlow model inference as the similar API in python. To install this plug-in, please use the `--plugins wasmedge_tensorflow` parameter when [running the installer command](#generic-linux-and-macos).

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasmedge_tensorflow
```

The WasmEdge-Tensorflow plug-in depends on the `libtensorflow_cc` shared library.

<!-- prettier-ignore -->
:::note
If you install this plug-in WITHOUT installer, you can [refer to here to install the dependency](#tensorflow-dependencies).
:::note

Then, go to [TensorFlow interface in Rust chapter](../develop/rust/wasinn/tf_plugin.md) to see how to run `WasmEdge-TensorFlow` functions.

### TLS plug-in

<!-- prettier-ignore -->
:::note
The WasmEdge TLS plugin is being deprecated from WasmEdge 0.14.0. We now compile TLS functions directly into Wasm for better portability.
:::note

The WasmEdge TLS plug-in utilizes the native OpenSSL library to support HTTPS and TLS requests from WasmEdge sockets. To install WasmEdge with the TLS plug-in, run the following command.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.13.5 --plugins wasmedge_rustls
```

The HTTPS and TLS demos from 0.13.5 require the TLS plug-in.

### WasmEdge TensorFlow-Lite Plug-in

<!-- prettier-ignore -->
:::note
The Tensorflow Lite plugin is being deprecated. Please use the [WASI NN TensorflowLite plugin](#wasi-nn-plug-in-with-tensorflow-lite-backend) instead.
:::note

The wasmEdge-TensorFlowLite plug-in can help developers to perform TensorFlow-Lite model inference. To install this plug-in, please use the `--plugins wasmedge_tensorflowlite` parameter when [running the installer command](#generic-linux-and-macos).

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasmedge_tensorflowlite
```

## Install WasmEdge extensions and dependencies

<!-- prettier-ignore -->
:::note
The WasmEdge extensions are deprecated and replaced by the plug-ins since `0.13.0`. The latest version supporting the extensions is `0.12.1`. This chapter will be removed when the `0.12.x` versions are no longer supported by the WasmEdge installer.
:::note

To install the WasmEdge extensions, please use the `-e` option and assign the WasmEdge version before `0.13.0`. You can also use the `-e all` to install the supported extensions.

### WasmEdge Image extension

WasmEdge Image extension (replaced by the [WasmEdge-Image plug-in](#wasmedge-image-plug-in) after `0.13.0`) can help developers to load and decode JPEG and PNG images and convert them into tensors. To install this extension, please use the `-e image` parameter when [running the installer command](#generic-linux-and-macos).

### WasmEdge Tensorflow and TensorFlow-Lite extension with CLI tool

WasmEdge Tensorflow extension and the CLI tool (replaced by the [WasmEdge-Tensorflow plug-in](#wasmedge-tensorflow-plug-in) and the [WasmEdge-TensorflowLite plug-in](#wasmedge-tensorflow-lite-plug-in) after `0.13.0`) can help developers to perform `TensorFlow` and `TensorFlow-Lite` model inference as the similar API in python. To install this extension, please use the `-e tensorflow` parameter when [running the installer command](#generic-linux-and-macos).

## Uninstall

To uninstall WasmEdge, you can run the following command:

```bash
bash <(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh)
```

If the `wasmedge` binary is not in `PATH` and it wasn't installed in the default `$HOME/.wasmedge` folder, then you must provide the installation path.

```bash
bash <(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -p /path/to/parent/folder
```

If you wish to uninstall uninteractively, you can pass in the `--quick` or `-q` flag.

```bash
bash <(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -q
```

<!-- prettier-ignore -->
:::note
If a parent folder of the `wasmedge` binary contains `.wasmedge`, the folder will be considered for removal. For example, the script altogether removes the default `$HOME/.wasmedge` folder.
:::

If you used `dnf` to install WasmEdge on Fedora and Red Hat Linux, run the following command to uninstall it:

```bash
dnf remove wasmedge
```

If you used `winget` to install WasmEdge on Windows, run the following command to uninstall it:

```bash
winget uninstall wasmedge
```

## Appendix: Installing the TensorFlow Dependencies

### TensorFlow-Lite Dependencies

If you install the WASI NN TensorflowLite plug-in WITHOUT installer, you can download the shared libraries with the following commands:

```bash
VERSION=TF-2.12.0-CC
# For the WasmEdge versions before 0.13.0, please use the `TF-2.6.0-CC` version.
PLATFORM=manylinux2014_x86_64
# For the Linux aarch64 platforms, please use the `manylinux2014_aarch64`.
# For the MacOS x86_64 platforms, please use the `darwin_x86_64`.
# For the MacOS arm64 platforms, please use the `darwin_arm64`.
curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/$VERSION/WasmEdge-tensorflow-deps-TFLite-$VERSION-$PLATFORM.tar.gz
tar -zxf WasmEdge-tensorflow-deps-TFLite-$VERSION-$PLATFORM.tar.gz
rm -f WasmEdge-tensorflow-deps-TFLite-$VERSION-$PLATFORM.tar.gz
```

The shared library will be extracted in the current directory `./libtensorflowlite_c.so` (or `.dylib` for MacOS) and `./libtensorflowlite_flex.so` (after the `WasmEdge 0.13.0` version). You can move the library to the installation path:

```bash
# If you installed wasmedge locally as above
mv libtensorflowlite_c.so ~/.wasmedge/lib
mv libtensorflowlite_flex.so ~/.wasmedge/lib

# Or, if you installed wasmedge for all users in /usr/local/
mv libtensorflowlite_c.so /usr/local/lib
mv libtensorflowlite_flex.so /usr/local/lib

# Or on MacOS platforms
mv libtensorflowlite_c.dylib ~/.wasmedge/lib
mv libtensorflowlite_flex.dylib ~/.wasmedge/lib
```

### TensorFlow Dependencies

If you install the `WasmEdge-Tensorflow` plug-in WITHOUT installer, you can download the shared libraries with the following commands:

```bash
VERSION=TF-2.12.0-CC
# For the WasmEdge versions before 0.13.0, please use the `TF-2.6.0-CC` version.
PLATFORM=manylinux2014_x86_64
# For the Linux aarch64 platforms, please use the `manylinux2014_aarch64`.
# For the MacOS x86_64 platforms, please use the `darwin_x86_64`.
# For the MacOS arm64 platforms, please use the `darwin_arm64`.
curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TF-TF-$VERSION-$PLATFORM.tar.gz
tar -zxf WasmEdge-tensorflow-deps-TF-TF-$VERSION-$PLATFORM.tar.gz
rm -f WasmEdge-tensorflow-deps-TF-TF-$VERSION-$PLATFORM.tar.gz
```

The shared library will be extracted in the current directory `./libtensorflow_cc.so.2.12.0` and `./libtensorflow_framework.so.2.12.0` on `Linux` platforms, or `./libtensorflow_cc.2.12.0.dylib` and `./libtensorflow_framework.2.12.0.dylib` on `MacOS` platforms. You can move the library to the installation path:

```bash
# If you installed wasmedge locally as above
mv libtensorflow_cc.so.2.12.0 ~/.wasmedge/lib
mv libtensorflow_framework.so.2.12.0 ~/.wasmedge/lib
ln -s libtensorflow_cc.so.2.12.0 ~/.wasmedge/lib/libtensorflow_cc.so.2
ln -s libtensorflow_cc.so.2 ~/.wasmedge/lib/libtensorflow_cc.so
ln -s libtensorflow_framework.so.2.12.0 ~/.wasmedge/lib/libtensorflow_framework.so.2
ln -s libtensorflow_framework.so.2 ~/.wasmedge/lib/libtensorflow_framework.so

# Or, if you installed wasmedge for all users in /usr/local/
mv libtensorflow_cc.so.2.12.0 /usr/local/lib
mv libtensorflow_framework.so.2.12.0 /usr/local/lib
ln -s libtensorflow_cc.so.2.12.0 /usr/local/lib/libtensorflow_cc.so.2
ln -s libtensorflow_cc.so.2 /usr/local/lib/libtensorflow_cc.so
ln -s libtensorflow_framework.so.2.12.0 /usr/local/lib/libtensorflow_framework.so.2
ln -s libtensorflow_framework.so.2 /usr/local/lib/libtensorflow_framework.so

# Or on MacOS platforms
mv libtensorflow_cc.2.12.0.dylib ~/.wasmedge/lib
mv libtensorflow_framework.2.12.0.dylib ~/.wasmedge/lib
ln -s libtensorflow_cc.2.12.0.dylib ~/.wasmedge/lib/libtensorflow_cc.2.dylib
ln -s libtensorflow_cc.2.dylib ~/.wasmedge/lib/libtensorflow_cc.dylib
ln -s libtensorflow_framework.2.12.0.dylib ~/.wasmedge/lib/libtensorflow_framework.2.dylib
ln -s libtensorflow_framework.2.dylib ~/.wasmedge/lib/libtensorflow_framework.dylib
```

## Troubleshooting

Some users, especially in China, reported encountering the Connection refused error when trying to download the `install.sh` from the `githubusercontent.com`.

Please make sure your network connection can access `github.com` and `githubusercontent.com` via VPN.

```bash
# The error message
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused
```
","The code provided is a comprehensive guide to installing and uninstalling the WasmEdge Runtime on various operating systems. Here's a concise summary of its purpose, functionality, and key components:

**Purpose:**

This script provides a straightforward way to install and uninstall the WasmEdge Runtime, which is a lightweight and fast WebAssembly runtime, on different platforms.

**Functionality:**

1. Install WasmEdge on Linux (generic), MacOS, Windows 10, Fedora, and Red Hat Linux.
2. Uninstall WasmEdge from all supported platforms.
3. Install WasmEdge extensions and dependencies, such as the Image extension, TensorFlow extension, and CLI tool.
4. Provide troubleshooting tips for common issues.

**Key Components:**

1. `install.sh`: A script that downloads and installs WasmEdge on different platforms.
2. `uninstall.sh`: A script that uninstalls WasmEdge from all supported platforms.
3. `githubusercontent.com` connection settings: The script connects to this domain to download the `install.sh` and `uninstall.sh` scripts.

**Areas for Improvement:**

1. **Security:** When running the script, users may be prompted to enter their password or accept certificates, which could pose security risks if not handled correctly.
2. **Error Handling:** The script does not handle errors well, as it relies on shell scripting and may produce cryptic error messages if something goes wrong.
3. **Platform Support:** While the script supports multiple platforms, some platforms (e.g., older Linux distributions) might not be fully supported or might require additional configuration.

To address these areas for improvement, you could:

1. Use secure authentication methods to handle password inputs and certificate acceptance.
2. Implement better error handling mechanisms to provide more informative error messages.
3. Add support for additional platforms or update the existing script to ensure seamless installation and uninstallation across all supported platforms.

In terms of code quality and maintainability, the script is well-structured and readable. However, there are a few suggestions:

1. **Consistent naming conventions:** The script uses different naming conventions for variables (e.g., `install.sh` vs. `INSTALL_SH`). Ensure consistency throughout the script.
2. **Variable naming:** Some variable names could be more descriptive (e.g., `curl_url` instead of just `url`).
3. **Code organization:** While the script is relatively short, it's still a good idea to break it up into separate functions or modules for better modularity and maintainability.

Overall, this script provides a solid foundation for installing and uninstalling WasmEdge on multiple platforms. With some tweaks and refinements, it can become an even more robust and user-friendly tool."
docs/embed/c/reference/upgrade_to_0.10.0.md,"---
sidebar_position: 10
---

# Upgrade to WasmEdge 0.10.0

Due to the WasmEdge C API breaking changes, this document shows the guideline of programming with WasmEdge C API to upgrade from the `0.9.1` to the `0.10.0` version.

## Concepts

1. Merged the `WasmEdge_ImportObjectContext` into the `WasmEdge_ModuleInstanceContext`.

   The `WasmEdge_ImportObjectContext` which is for the host functions is merged into `WasmEdge_ModuleInstanceContext`. Developers can use the related APIs to construct host modules.

   - `WasmEdge_ImportObjectCreate()` is changed to `WasmEdge_ModuleInstanceCreate()`.
   - `WasmEdge_ImportObjectDelete()` is changed to `WasmEdge_ModuleInstanceDelete()`.
   - `WasmEdge_ImportObjectAddFunction()` is changed to `WasmEdge_ModuleInstanceAddFunction()`.
   - `WasmEdge_ImportObjectAddTable()` is changed to `WasmEdge_ModuleInstanceAddTable()`.
   - `WasmEdge_ImportObjectAddMemory()` is changed to `WasmEdge_ModuleInstanceAddMemory()`.
   - `WasmEdge_ImportObjectAddGlobal()` is changed to `WasmEdge_ModuleInstanceAddGlobal()`.
   - `WasmEdge_ImportObjectCreateWASI()` is changed to `WasmEdge_ModuleInstanceCreateWASI()`.
   - `WasmEdge_ImportObjectCreateWasmEdgeProcess()` is changed to `WasmEdge_ModuleInstanceCreateWasmEdgeProcess()`.
   - `WasmEdge_ImportObjectInitWASI()` is changed to `WasmEdge_ModuleInstanceInitWASI()`.
   - `WasmEdge_ImportObjectInitWasmEdgeProcess()` is changed to `WasmEdge_ModuleInstanceInitWasmEdgeProcess()`.

   For the new host function examples, please refer to [the example below](#host-functions).

2. Used the pointer to `WasmEdge_FunctionInstanceContext` instead of the index in the `FuncRef` value type.

   For the better performance and security, the `FuncRef` related APIs used the `const WasmEdge_FunctionInstanceContext *` for the parameters and returns.

   - `WasmEdge_ValueGenFuncRef()` is changed to use the `const WasmEdge_FunctionInstanceContext *` as it's argument.
   - `WasmEdge_ValueGetFuncRef()` is changed to return the `const WasmEdge_FunctionInstanceContext *`.

3. Supported multiple anonymous WASM module instantiation.

   In the version before `0.9.1`, WasmEdge only supports 1 anonymous WASM module to be instantiated at one time. If developers instantiate a new WASM module, the old one will be replaced. After the `0.10.0` version, developers can instantiate multiple anonymous WASM module by `Executor` and get the `Module` instance. But for the source code using the `VM` APIs, the behavior is not changed. For the new examples of instantiating multiple anonymous WASM modules, please refer to [the example below](#wasmedge-executor-changes).

4. Behavior changed of `WasmEdge_StoreContext`.

   The `Function`, `Table`, `Memory`, and `Global` instances retrievement from the `Store` is moved to the `Module` instance. The `Store` only manage the module linking when instantiation and the named module searching after the `0.10.0` version.

   - `WasmEdge_StoreListFunctionLength()` and `WasmEdge_StoreListFunctionRegisteredLength()` is replaced by `WasmEdge_ModuleInstanceListFunctionLength()`.
   - `WasmEdge_StoreListTableLength()` and `WasmEdge_StoreListTableRegisteredLength()` is replaced by `WasmEdge_ModuleInstanceListTableLength()`.
   - `WasmEdge_StoreListMemoryLength()` and `WasmEdge_StoreListMemoryRegisteredLength()` is replaced by `WasmEdge_ModuleInstanceListMemoryLength()`.
   - `WasmEdge_StoreListGlobalLength()` and `WasmEdge_StoreListGlobalRegisteredLength()` is replaced by `WasmEdge_ModuleInstanceListGlobalLength()`.
   - `WasmEdge_StoreListFunction()` and `WasmEdge_StoreListFunctionRegistered()` is replaced by `WasmEdge_ModuleInstanceListFunction()`.
   - `WasmEdge_StoreListTable()` and `WasmEdge_StoreListTableRegistered()` is replaced by `WasmEdge_ModuleInstanceListTable()`.
   - `WasmEdge_StoreListMemory()` and `WasmEdge_StoreListMemoryRegistered()` is replaced by `WasmEdge_ModuleInstanceListMemory()`.
   - `WasmEdge_StoreListGlobal()` and `WasmEdge_StoreListGlobalRegistered()` is replaced by `WasmEdge_ModuleInstanceListGlobal()`.
   - `WasmEdge_StoreFindFunction()` and `WasmEdge_StoreFindFunctionRegistered()` is replaced by `WasmEdge_ModuleInstanceFindFunction()`.
   - `WasmEdge_StoreFindTable()` and `WasmEdge_StoreFindTableRegistered()` is replaced by `WasmEdge_ModuleInstanceFindTable()`.
   - `WasmEdge_StoreFindMemory()` and `WasmEdge_StoreFindMemoryRegistered()` is replaced by `WasmEdge_ModuleInstanceFindMemory()`.
   - `WasmEdge_StoreFindGlobal()` and `WasmEdge_StoreFindGlobalRegistered()` is replaced by `WasmEdge_ModuleInstanceFindGlobal()`.

   For the new examples of retrieving instances, please refer to [the example below](#instances-retrievement).

5. The `WasmEdge_ModuleInstanceContext`-based resource management.

   Except the creation of `Module` instance for the host functions, the `Executor` will output a `Module` instance after instantiation. No matter the anonymous or named modules, developers have the responsibility to destroy them by `WasmEdge_ModuleInstanceDelete()` API. The `Store` will link to the named `Module` instance after registering. After the destroyment of a `Module` instance, the `Store` will unlink to that automatically; after the destroyment of the `Store`, the all `Module` instances the `Store` linked to will unlink to that `Store` automatically.

## WasmEdge VM changes

The `VM` APIs are basically not changed, except the `ImportObject` related APIs.

The following is the example of WASI initialization in WasmEdge `0.9.1` C API:

```c
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/* The following API can retrieve the pre-registration import objects from the VM context. */
/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */
WasmEdge_ImportObjectContext *WasiObject =
    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
/* Initialize the WASI. */
WasmEdge_ImportObjectInitWASI(WasiObject, /* ... ignored */ );

/* ... */

WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
```

Developers can change to use the WasmEdge `0.10.0` C API as follows, with only replacing the `WasmEdge_ImportObjectContext` into `WasmEdge_ModuleInstanceContext`:

```c
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/* The following API can retrieve the pre-registration module instances from the VM context. */
/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */
WasmEdge_ModuleInstanceContext *WasiModule =
    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
/* Initialize the WASI. */
WasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */ );

/* ... */

WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
```

The `VM` provides a new API for getting the current instantiated anonymous `Module` instance. For example, if developer want to get the exported `Global` instance:

```c
/* Assume that a WASM module is instantiated in `VMCxt`, and exports the ""global_i32"". */
WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);
WasmEdge_String GlobName = WasmEdge_StringCreateByCString(""global_i32"");
WasmEdge_GlobalInstanceContext *GlobCxt = WasmEdge_StoreFindGlobal(StoreCxt, GlobName);
WasmEdge_StringDelete(GlobName);
```

After the WasmEdge `0.10.0` C API, developers can use the `WasmEdge_VMGetActiveModule()` to get the module instance:

```c
/* Assume that a WASM module is instantiated in `VMCxt`, and exports the ""global_i32"". */
const WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_VMGetActiveModule(VMCxt);
/* The example of retrieving the global instance. */
WasmEdge_String GlobName = WasmEdge_StringCreateByCString(""global_i32"");
WasmEdge_GlobalInstanceContext *GlobCxt = WasmEdge_ModuleInstanceFindGlobal(ModCxt, GlobName);
WasmEdge_StringDelete(GlobName);
```

## WasmEdge Executor changes

`Executor` helps to instantiate a WASM module, register a WASM module into `Store` with module name, register the host modules with host functions, or invoke functions.

1. WASM module instantiation

   In WasmEdge `0.9.1` version, developers can instantiate a WASM module by the `Executor` API:

   ```c
   WasmEdge_ASTModuleContext *ASTCxt;
   /*
    * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.
    * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.
    * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.
    */
   WasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
   }
   ```

   Then the WASM module is instantiated into an anonymous module instance and handled by the `Store`. If a new WASM module is instantiated by this API, the old instantiated module instance will be cleaned. After the WasmEdge `0.10.0` version, the instantiated anonymous module will be outputted and handled by caller, and not only 1 anonymous module instance can be instantiated. Developers have the responsibility to destroy the outputted module instances.

   ```c
   WasmEdge_ASTModuleContext *ASTCxt1, *ASTCxt2;
   /*
    * Assume that `ASTCxt1` and `ASTCxt2` are loaded WASMs from different files or buffers,
    * and have both passed the validation.
    * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.
    * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.
    */
   WasmEdge_ModuleInstanceContext *ModCxt1 = NULL;
   WasmEdge_ModuleInstanceContext *ModCxt2 = NULL;
   WasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt1, StoreCxt, ASTCxt1);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
   }
   Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt2, StoreCxt, ASTCxt2);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
   }
   ```

2. WASM module registration with module name

   When instantiating and registering a WASM module with module name, developers can use the `WasmEdge_ExecutorRegisterModule()` API before WasmEdge `0.9.1`.

   ```c
   WasmEdge_ASTModuleContext *ASTCxt;
   /*
    * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.
    * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.
    * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.
    */

   /* Register the WASM module into store with the export module name ""mod"". */
   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");
   Res = WasmEdge_ExecutorRegisterModule(ExecCxt, StoreCxt, ASTCxt, ModName);
   WasmEdge_StringDelete(ModName);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));
   }
   ```

   The same feature is implemented in WasmEdge `0.10.0`, but in different API `WasmEdge_ExecutorRegister()`:

   ```c
   WasmEdge_ASTModuleContext *ASTCxt;
   /*
    * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.
    * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.
    * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.
    */

   /* Register the WASM module into store with the export module name ""mod"". */
   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");
   /* The output module instance. */
   WasmEdge_ModuleInstanceContext *ModCxt = NULL;
   Res = WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);
   WasmEdge_StringDelete(ModName);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));
   }
   ```

   Developers have the responsibility to destroy the outputted module instances.

3. Host module registration

   In WasmEdge `0.9.1`, developers can create a `WasmEdge_ImportObjectContext` and register into `Store`.

   ```c
   /* Create the import object with the export module name. */
   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""module"");
   WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ModName);
   WasmEdge_StringDelete(ModName);
   /*
    * ...
    * Add the host functions, tables, memories, and globals into the import object.
    */
   /* The import module context has already contained the export module name. */
   Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, ImpObj);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Import object registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));
   }
   ```

   After WasmEdge `0.10.0`, developers should use the `WasmEdge_ModuleInstanceContext` instead:

   ```c
   /* Create the module instance with the export module name. */
   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""module"");
   WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_ModuleInstanceCreate(ModName);
   WasmEdge_StringDelete(ModName);
   /*
    * ...
    * Add the host functions, tables, memories, and globals into the module instance.
    */
   /* The module instance context has already contained the export module name. */
   Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, ModCxt);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Module instance registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));
   }
   ```

   Developers have the responsibility to destroy the created module instances.

4. WASM function invocation

   This example uses the WASM file `fibonacci.wasm` converted from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat). In WasmEdge `0.9.1` version, developers can invoke a WASM function with the export function name:

   ```c
   /* Create the store context. The store context holds the instances. */
   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
   /* Result. */
   WasmEdge_Result Res;

   /* Create the loader context. The configure context can be NULL. */
   WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
   /* Create the validator context. The configure context can be NULL. */
   WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);
   /* Create the executor context. The configure context and the statistics context can be NULL. */
   WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);

   /* Load the WASM file or the compiled-WASM file and convert into the AST module context. */
   WasmEdge_ASTModuleContext *ASTCxt = NULL;
   Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
     return -1;
   }
   /* Validate the WASM module. */
   Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
     return -1;
   }
   /* Instantiate the WASM module into the store context. */
   Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
     return -1;
   }
   /* Invoke the function which is exported with the function name ""fib"". */
   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");
   WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };
   WasmEdge_Value Returns[1];
   Res = WasmEdge_ExecutorInvoke(ExecCxt, StoreCxt, FuncName, Params, 1, Returns, 1);
   if (WasmEdge_ResultOK(Res)) {
     printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));
   } else {
     printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
     return -1;
   }

   WasmEdge_ASTModuleDelete(ASTCxt);
   WasmEdge_LoaderDelete(LoadCxt);
   WasmEdge_ValidatorDelete(ValidCxt);
   WasmEdge_ExecutorDelete(ExecCxt);
   WasmEdge_StoreDelete(StoreCxt);
   ```

   After the WasmEdge `0.10.0`, developers should retrieve the `Function` instance by function name first.

   ```c
   /*
    * ...
    * Ignore the unchanged steps before validation. Please refer to the sample code above.
    */
   WasmEdge_ModuleInstanceContext *ModCxt = NULL;
   /* Instantiate the WASM module. */
   Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt1, StoreCxt, ASTCxt);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
     return -1;
   }
   /* Retrieve the function instance by name. */
   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");
   WasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);
   WasmEdge_StringDelete(FuncName);
   /* Invoke the function. */
   WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };
   WasmEdge_Value Returns[1];
   Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);
   if (WasmEdge_ResultOK(Res)) {
     printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));
   } else {
     printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
     return -1;
   }

   WasmEdge_ModuleInstanceDelete(ModCxt);
   WasmEdge_ASTModuleDelete(ASTCxt);
   WasmEdge_LoaderDelete(LoadCxt);
   WasmEdge_ValidatorDelete(ValidCxt);
   WasmEdge_ExecutorDelete(ExecCxt);
   WasmEdge_StoreDelete(StoreCxt);
   ```

## Instances retrievement

This example uses the WASM file `fibonacci.wasm` converted from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat).

Before the WasmEdge `0.9.1` versions, developers can retrieve all exported instances of named or anonymous modules from `Store`:

```c
/* Create the store context. The store context holds the instances. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* Result. */
WasmEdge_Result Res;

/* Create the loader context. The configure context can be NULL. */
WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
/* Create the validator context. The configure context can be NULL. */
WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);
/* Create the executor context. The configure context and the statistics context can be NULL. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);

/* Load the WASM file or the compiled-WASM file and convert into the AST module context. */
WasmEdge_ASTModuleContext *ASTCxt = NULL;
Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");
if (!WasmEdge_ResultOK(Res)) {
  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Validate the WASM module. */
Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Example: register and instantiate the WASM module with the module name ""module_fib"". */
WasmEdge_String ModName = WasmEdge_StringCreateByCString(""module_fib"");
Res = WasmEdge_ExecutorRegisterModule(ExecCxt, StoreCxt, ASTCxt, ModName);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Example: Instantiate the WASM module into the store context. */
Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
  return -1;
}
WasmEdge_StringDelete(ModName);

/* Now, developers can retrieve the exported instances from the store. */
/* Take the exported functions as example. This WASM exports the function ""fib"". */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");
WasmEdge_FunctionInstanceContext *FoundFuncCxt;
/* Find the function ""fib"" from the instantiated anonymous module. */
FoundFuncCxt = WasmEdge_StoreFindFunction(StoreCxt, FuncName);
/* Find the function ""fib"" from the registered module ""module_fib"". */
ModName = WasmEdge_StringCreateByCString(""module_fib"");
FoundFuncCxt = WasmEdge_StoreFindFunctionRegistered(StoreCxt, ModName, FuncName);
WasmEdge_StringDelete(ModName);
WasmEdge_StringDelete(FuncName);

WasmEdge_ASTModuleDelete(ASTCxt);
WasmEdge_LoaderDelete(LoadCxt);
WasmEdge_ValidatorDelete(ValidCxt);
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StoreDelete(StoreCxt);
```

After the WasmEdge `0.10.0`, developers can instantiate several anonymous `Module` instances, and should retrieve the exported instances from named or anonymous `Module` instances:

```c
/* Create the store context. The store context is the object to link the modules for imports and exports. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* Result. */
WasmEdge_Result Res;

/* Create the loader context. The configure context can be NULL. */
WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
/* Create the validator context. The configure context can be NULL. */
WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);
/* Create the executor context. The configure context and the statistics context can be NULL. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);

/* Load the WASM file or the compiled-WASM file and convert into the AST module context. */
WasmEdge_ASTModuleContext *ASTCxt = NULL;
Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");
if (!WasmEdge_ResultOK(Res)) {
  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Validate the WASM module. */
Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Example: register and instantiate the WASM module with the module name ""module_fib"". */
WasmEdge_ModuleInstanceContext *NamedModCxt = NULL;
WasmEdge_String ModName = WasmEdge_StringCreateByCString(""module_fib"");
Res = WasmEdge_ExecutorRegister(ExecCxt, &NamedModCxt, StoreCxt, ASTCxt, ModName);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Example: Instantiate the WASM module and get the output module instance. */
WasmEdge_ModuleInstanceContext *ModCxt = NULL;
Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
  return -1;
}
WasmEdge_StringDelete(ModName);

/* Now, developers can retrieve the exported instances from the module instances. */
/* Take the exported functions as example. This WASM exports the function ""fib"". */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");
WasmEdge_FunctionInstanceContext *FoundFuncCxt;
/* Find the function ""fib"" from the instantiated anonymous module. */
FoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);
/* Find the function ""fib"" from the registered module ""module_fib"". */
FoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(NamedModCxt, FuncName);
/* Or developers can get the named module instance from the store: */
ModName = WasmEdge_StringCreateByCString(""module_fib"");
const WasmEdge_ModuleInstanceContext *ModCxtGot = WasmEdge_StoreFindModule(StoreCxt, ModName);
WasmEdge_StringDelete(ModName);
FoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxtGot, FuncName);
WasmEdge_StringDelete(FuncName);

WasmEdge_ModuleInstanceDelete(NamedModCxt);
WasmEdge_ModuleInstanceDelete(ModCxt);
WasmEdge_ASTModuleDelete(ASTCxt);
WasmEdge_LoaderDelete(LoadCxt);
WasmEdge_ValidatorDelete(ValidCxt);
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StoreDelete(StoreCxt);
```

## Host functions

The difference of host functions are the replacement of `WasmEdge_ImportObjectContext`.

```c
/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

/* Create the import object. */
WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");
WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);
WasmEdge_StringDelete(ExportName);

/* Create and add a function instance into the import object. */
enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
WasmEdge_FunctionInstanceContext *HostFunc =
    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
 * The third parameter is the pointer to the additional data object.
 * Developers should guarantee the life cycle of the data, and it can be
 * `NULL` if the external data is not needed.
 */
WasmEdge_FunctionTypeDelete(HostFType);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""add"");
WasmEdge_ImportObjectAddFunction(ImpObj, FuncName, HostFunc);
WasmEdge_StringDelete(FuncName);

/*
 * The import objects should be deleted.
 * Developers should __NOT__ destroy the instances added into the import object contexts.
 */
WasmEdge_ImportObjectDelete(ImpObj);
```

Developers can use the `WasmEdge_ModuleInstanceContext` to upgrade to WasmEdge `0.10.0` easily.

```c
/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

/* Create a module instance. */
WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");
WasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);
WasmEdge_StringDelete(ExportName);

/* Create and add a function instance into the module instance. */
enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
WasmEdge_FunctionInstanceContext *HostFunc =
    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
 * The third parameter is the pointer to the additional data object.
 * Developers should guarantee the life cycle of the data, and it can be
 * `NULL` if the external data is not needed.
 */
WasmEdge_FunctionTypeDelete(HostFType);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""add"");
WasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);
WasmEdge_StringDelete(FuncName);

/*
 * The module instance should be deleted.
 * Developers should __NOT__ destroy the instances added into the module instance contexts.
 */
WasmEdge_ModuleInstanceDelete(HostModCxt);
```
","This code is a documentation for the changes in WasmEdge 0.10.0 C API, specifically highlighting the changes in module instantiation and management.

Here's a summary of the key points:

1.  **Module Instance Context:** The `WasmEdge_ModuleInstanceContext` has replaced `WasmEdge_ImportObjectContext` in various APIs.
2.  **Instantiation Changes:**
    *   Multiple anonymous modules can be instantiated simultaneously, and their instances are stored separately.
    *   Each module instance must be explicitly deleted after use to prevent memory leaks.
3.  **Store Context Changes:**
    *   The `WasmEdge_StoreContext` now manages only the linking of named modules during instantiation and searching for modules with a given name after instantiation.
    *   Retrieving instances from the store has been moved to retrieving them directly from module instance contexts.
4.  **Function Instance Retrieval:**
    *   Developers must use `WasmEdge_ModuleInstanceFindFunction()` to retrieve a function instance from a module instance context instead of using `WasmEdge_StoreFindFunction()`.
5.  **Named Module Instances:**
    *   To access named modules, developers can get the named module instance directly from the store by its name.

In terms of code changes, several APIs have been modified or replaced with new ones to accommodate these changes:

*   `WasmEdge_ImportObjectCreate()` and `WasmEdge_ModuleInstanceCreate()`
*   `WasmEdge_ImportObjectDelete()` and `WasmEdge_ModuleInstanceDelete()`
*   `WasmEdge_ImportObjectContext` has been replaced by `WasmEdge_ModuleInstanceContext`

These changes aim to improve the flexibility, manageability, and performance of module instantiation in WasmEdge 0.10.0 C API.

Overall, this documentation provides a clear overview of the changes introduced in WasmEdge 0.10.0 C API, allowing developers to easily adapt their code and make the most of these new features."
i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.10.0.md,"---
sidebar_position: 10
---

# Upgrade to WasmEdge 0.10.0

Due to the WasmEdge C API breaking changes, this document shows the guideline of programming with WasmEdge C API to upgrade from the `0.9.1` to the `0.10.0` version.

## Concepts

1. Merged the `WasmEdge_ImportObjectContext` into the `WasmEdge_ModuleInstanceContext`.

   The `WasmEdge_ImportObjectContext` which is for the host functions is merged into `WasmEdge_ModuleInstanceContext`. Developers can use the related APIs to construct host modules.

   - `WasmEdge_ImportObjectCreate()` is changed to `WasmEdge_ModuleInstanceCreate()`.
   - `WasmEdge_ImportObjectDelete()` is changed to `WasmEdge_ModuleInstanceDelete()`.
   - `WasmEdge_ImportObjectAddFunction()` is changed to `WasmEdge_ModuleInstanceAddFunction()`.
   - `WasmEdge_ImportObjectAddTable()` is changed to `WasmEdge_ModuleInstanceAddTable()`.
   - `WasmEdge_ImportObjectAddMemory()` is changed to `WasmEdge_ModuleInstanceAddMemory()`.
   - `WasmEdge_ImportObjectAddGlobal()` is changed to `WasmEdge_ModuleInstanceAddGlobal()`.
   - `WasmEdge_ImportObjectCreateWASI()` is changed to `WasmEdge_ModuleInstanceCreateWASI()`.
   - `WasmEdge_ImportObjectCreateWasmEdgeProcess()` is changed to `WasmEdge_ModuleInstanceCreateWasmEdgeProcess()`.
   - `WasmEdge_ImportObjectInitWASI()` is changed to `WasmEdge_ModuleInstanceInitWASI()`.
   - `WasmEdge_ImportObjectInitWasmEdgeProcess()` is changed to `WasmEdge_ModuleInstanceInitWasmEdgeProcess()`.

   For the new host function examples, please refer to [the example below](#host-functions).

2. Used the pointer to `WasmEdge_FunctionInstanceContext` instead of the index in the `FuncRef` value type.

   For the better performance and security, the `FuncRef` related APIs used the `const WasmEdge_FunctionInstanceContext *` for the parameters and returns.

   - `WasmEdge_ValueGenFuncRef()` is changed to use the `const WasmEdge_FunctionInstanceContext *` as it's argument.
   - `WasmEdge_ValueGetFuncRef()` is changed to return the `const WasmEdge_FunctionInstanceContext *`.

3. Supported multiple anonymous WASM module instantiation.

   In the version before `0.9.1`, WasmEdge only supports 1 anonymous WASM module to be instantiated at one time. If developers instantiate a new WASM module, the old one will be replaced. After the `0.10.0` version, developers can instantiate multiple anonymous WASM module by `Executor` and get the `Module` instance. But for the source code using the `VM` APIs, the behavior is not changed. For the new examples of instantiating multiple anonymous WASM modules, please refer to [the example below](#wasmedge-executor-changes).

4. Behavior changed of `WasmEdge_StoreContext`.

   The `Function`, `Table`, `Memory`, and `Global` instances retrievement from the `Store` is moved to the `Module` instance. The `Store` only manage the module linking when instantiation and the named module searching after the `0.10.0` version.

   - `WasmEdge_StoreListFunctionLength()` and `WasmEdge_StoreListFunctionRegisteredLength()` is replaced by `WasmEdge_ModuleInstanceListFunctionLength()`.
   - `WasmEdge_StoreListTableLength()` and `WasmEdge_StoreListTableRegisteredLength()` is replaced by `WasmEdge_ModuleInstanceListTableLength()`.
   - `WasmEdge_StoreListMemoryLength()` and `WasmEdge_StoreListMemoryRegisteredLength()` is replaced by `WasmEdge_ModuleInstanceListMemoryLength()`.
   - `WasmEdge_StoreListGlobalLength()` and `WasmEdge_StoreListGlobalRegisteredLength()` is replaced by `WasmEdge_ModuleInstanceListGlobalLength()`.
   - `WasmEdge_StoreListFunction()` and `WasmEdge_StoreListFunctionRegistered()` is replaced by `WasmEdge_ModuleInstanceListFunction()`.
   - `WasmEdge_StoreListTable()` and `WasmEdge_StoreListTableRegistered()` is replaced by `WasmEdge_ModuleInstanceListTable()`.
   - `WasmEdge_StoreListMemory()` and `WasmEdge_StoreListMemoryRegistered()` is replaced by `WasmEdge_ModuleInstanceListMemory()`.
   - `WasmEdge_StoreListGlobal()` and `WasmEdge_StoreListGlobalRegistered()` is replaced by `WasmEdge_ModuleInstanceListGlobal()`.
   - `WasmEdge_StoreFindFunction()` and `WasmEdge_StoreFindFunctionRegistered()` is replaced by `WasmEdge_ModuleInstanceFindFunction()`.
   - `WasmEdge_StoreFindTable()` and `WasmEdge_StoreFindTableRegistered()` is replaced by `WasmEdge_ModuleInstanceFindTable()`.
   - `WasmEdge_StoreFindMemory()` and `WasmEdge_StoreFindMemoryRegistered()` is replaced by `WasmEdge_ModuleInstanceFindMemory()`.
   - `WasmEdge_StoreFindGlobal()` and `WasmEdge_StoreFindGlobalRegistered()` is replaced by `WasmEdge_ModuleInstanceFindGlobal()`.

   For the new examples of retrieving instances, please refer to [the example below](#instances-retrievement).

5. The `WasmEdge_ModuleInstanceContext`-based resource management.

   Except the creation of `Module` instance for the host functions, the `Executor` will output a `Module` instance after instantiation. No matter the anonymous or named modules, developers have the responsibility to destroy them by `WasmEdge_ModuleInstanceDelete()` API. The `Store` will link to the named `Module` instance after registering. After the destroyment of a `Module` instance, the `Store` will unlink to that automatically; after the destroyment of the `Store`, the all `Module` instances the `Store` linked to will unlink to that `Store` automatically.

## WasmEdge VM changes

The `VM` APIs are basically not changed, except the `ImportObject` related APIs.

The following is the example of WASI initialization in WasmEdge `0.9.1` C API:

```c
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/* The following API can retrieve the pre-registration import objects from the VM context. */
/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */
WasmEdge_ImportObjectContext *WasiObject =
    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
/* Initialize the WASI. */
WasmEdge_ImportObjectInitWASI(WasiObject, /* ... ignored */ );

/* ... */

WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
```

Developers can change to use the WasmEdge `0.10.0` C API as follows, with only replacing the `WasmEdge_ImportObjectContext` into `WasmEdge_ModuleInstanceContext`:

```c
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/* The following API can retrieve the pre-registration module instances from the VM context. */
/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */
WasmEdge_ModuleInstanceContext *WasiModule =
    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
/* Initialize the WASI. */
WasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */ );

/* ... */

WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
```

The `VM` provides a new API for getting the current instantiated anonymous `Module` instance. For example, if developer want to get the exported `Global` instance:

```c
/* Assume that a WASM module is instantiated in `VMCxt`, and exports the ""global_i32"". */
WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);
WasmEdge_String GlobName = WasmEdge_StringCreateByCString(""global_i32"");
WasmEdge_GlobalInstanceContext *GlobCxt = WasmEdge_StoreFindGlobal(StoreCxt, GlobName);
WasmEdge_StringDelete(GlobName);
```

After the WasmEdge `0.10.0` C API, developers can use the `WasmEdge_VMGetActiveModule()` to get the module instance:

```c
/* Assume that a WASM module is instantiated in `VMCxt`, and exports the ""global_i32"". */
const WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_VMGetActiveModule(VMCxt);
/* The example of retrieving the global instance. */
WasmEdge_String GlobName = WasmEdge_StringCreateByCString(""global_i32"");
WasmEdge_GlobalInstanceContext *GlobCxt = WasmEdge_ModuleInstanceFindGlobal(ModCxt, GlobName);
WasmEdge_StringDelete(GlobName);
```

## WasmEdge Executor changes

`Executor` helps to instantiate a WASM module, register a WASM module into `Store` with module name, register the host modules with host functions, or invoke functions.

1. WASM module instantiation

   In WasmEdge `0.9.1` version, developers can instantiate a WASM module by the `Executor` API:

   ```c
   WasmEdge_ASTModuleContext *ASTCxt;
   /*
    * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.
    * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.
    * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.
    */
   WasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
   }
   ```

   Then the WASM module is instantiated into an anonymous module instance and handled by the `Store`. If a new WASM module is instantiated by this API, the old instantiated module instance will be cleaned. After the WasmEdge `0.10.0` version, the instantiated anonymous module will be outputted and handled by caller, and not only 1 anonymous module instance can be instantiated. Developers have the responsibility to destroy the outputted module instances.

   ```c
   WasmEdge_ASTModuleContext *ASTCxt1, *ASTCxt2;
   /*
    * Assume that `ASTCxt1` and `ASTCxt2` are loaded WASMs from different files or buffers,
    * and have both passed the validation.
    * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.
    * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.
    */
   WasmEdge_ModuleInstanceContext *ModCxt1 = NULL;
   WasmEdge_ModuleInstanceContext *ModCxt2 = NULL;
   WasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt1, StoreCxt, ASTCxt1);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
   }
   Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt2, StoreCxt, ASTCxt2);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
   }
   ```

2. WASM module registration with module name

   When instantiating and registering a WASM module with module name, developers can use the `WasmEdge_ExecutorRegisterModule()` API before WasmEdge `0.9.1`.

   ```c
   WasmEdge_ASTModuleContext *ASTCxt;
   /*
    * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.
    * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.
    * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.
    */

   /* Register the WASM module into store with the export module name ""mod"". */
   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");
   Res = WasmEdge_ExecutorRegisterModule(ExecCxt, StoreCxt, ASTCxt, ModName);
   WasmEdge_StringDelete(ModName);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));
   }
   ```

   The same feature is implemented in WasmEdge `0.10.0`, but in different API `WasmEdge_ExecutorRegister()`:

   ```c
   WasmEdge_ASTModuleContext *ASTCxt;
   /*
    * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.
    * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.
    * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.
    */

   /* Register the WASM module into store with the export module name ""mod"". */
   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");
   /* The output module instance. */
   WasmEdge_ModuleInstanceContext *ModCxt = NULL;
   Res = WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);
   WasmEdge_StringDelete(ModName);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));
   }
   ```

   Developers have the responsibility to destroy the outputted module instances.

3. Host module registration

   In WasmEdge `0.9.1`, developers can create a `WasmEdge_ImportObjectContext` and register into `Store`.

   ```c
   /* Create the import object with the export module name. */
   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""module"");
   WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ModName);
   WasmEdge_StringDelete(ModName);
   /*
    * ...
    * Add the host functions, tables, memories, and globals into the import object.
    */
   /* The import module context has already contained the export module name. */
   Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, ImpObj);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Import object registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));
   }
   ```

   After WasmEdge `0.10.0`, developers should use the `WasmEdge_ModuleInstanceContext` instead:

   ```c
   /* Create the module instance with the export module name. */
   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""module"");
   WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_ModuleInstanceCreate(ModName);
   WasmEdge_StringDelete(ModName);
   /*
    * ...
    * Add the host functions, tables, memories, and globals into the module instance.
    */
   /* The module instance context has already contained the export module name. */
   Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, ModCxt);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Module instance registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));
   }
   ```

   Developers have the responsibility to destroy the created module instances.

4. WASM function invocation

   This example uses the WASM file `fibonacci.wasm` converted from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat). In WasmEdge `0.9.1` version, developers can invoke a WASM function with the export function name:

   ```c
   /* Create the store context. The store context holds the instances. */
   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
   /* Result. */
   WasmEdge_Result Res;

   /* Create the loader context. The configure context can be NULL. */
   WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
   /* Create the validator context. The configure context can be NULL. */
   WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);
   /* Create the executor context. The configure context and the statistics context can be NULL. */
   WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);

   /* Load the WASM file or the compiled-WASM file and convert into the AST module context. */
   WasmEdge_ASTModuleContext *ASTCxt = NULL;
   Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
     return -1;
   }
   /* Validate the WASM module. */
   Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
     return -1;
   }
   /* Instantiate the WASM module into the store context. */
   Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
     return -1;
   }
   /* Invoke the function which is exported with the function name ""fib"". */
   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");
   WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };
   WasmEdge_Value Returns[1];
   Res = WasmEdge_ExecutorInvoke(ExecCxt, StoreCxt, FuncName, Params, 1, Returns, 1);
   if (WasmEdge_ResultOK(Res)) {
     printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));
   } else {
     printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
     return -1;
   }

   WasmEdge_ASTModuleDelete(ASTCxt);
   WasmEdge_LoaderDelete(LoadCxt);
   WasmEdge_ValidatorDelete(ValidCxt);
   WasmEdge_ExecutorDelete(ExecCxt);
   WasmEdge_StoreDelete(StoreCxt);
   ```

   After the WasmEdge `0.10.0`, developers should retrieve the `Function` instance by function name first.

   ```c
   /*
    * ...
    * Ignore the unchanged steps before validation. Please refer to the sample code above.
    */
   WasmEdge_ModuleInstanceContext *ModCxt = NULL;
   /* Instantiate the WASM module. */
   Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt1, StoreCxt, ASTCxt);
   if (!WasmEdge_ResultOK(Res)) {
     printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
     return -1;
   }
   /* Retrieve the function instance by name. */
   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");
   WasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);
   WasmEdge_StringDelete(FuncName);
   /* Invoke the function. */
   WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };
   WasmEdge_Value Returns[1];
   Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);
   if (WasmEdge_ResultOK(Res)) {
     printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));
   } else {
     printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
     return -1;
   }

   WasmEdge_ModuleInstanceDelete(ModCxt);
   WasmEdge_ASTModuleDelete(ASTCxt);
   WasmEdge_LoaderDelete(LoadCxt);
   WasmEdge_ValidatorDelete(ValidCxt);
   WasmEdge_ExecutorDelete(ExecCxt);
   WasmEdge_StoreDelete(StoreCxt);
   ```

## Instances retrievement

This example uses the WASM file `fibonacci.wasm` converted from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat).

Before the WasmEdge `0.9.1` versions, developers can retrieve all exported instances of named or anonymous modules from `Store`:

```c
/* Create the store context. The store context holds the instances. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* Result. */
WasmEdge_Result Res;

/* Create the loader context. The configure context can be NULL. */
WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
/* Create the validator context. The configure context can be NULL. */
WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);
/* Create the executor context. The configure context and the statistics context can be NULL. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);

/* Load the WASM file or the compiled-WASM file and convert into the AST module context. */
WasmEdge_ASTModuleContext *ASTCxt = NULL;
Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");
if (!WasmEdge_ResultOK(Res)) {
  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Validate the WASM module. */
Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Example: register and instantiate the WASM module with the module name ""module_fib"". */
WasmEdge_String ModName = WasmEdge_StringCreateByCString(""module_fib"");
Res = WasmEdge_ExecutorRegisterModule(ExecCxt, StoreCxt, ASTCxt, ModName);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Example: Instantiate the WASM module into the store context. */
Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
  return -1;
}
WasmEdge_StringDelete(ModName);

/* Now, developers can retrieve the exported instances from the store. */
/* Take the exported functions as example. This WASM exports the function ""fib"". */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");
WasmEdge_FunctionInstanceContext *FoundFuncCxt;
/* Find the function ""fib"" from the instantiated anonymous module. */
FoundFuncCxt = WasmEdge_StoreFindFunction(StoreCxt, FuncName);
/* Find the function ""fib"" from the registered module ""module_fib"". */
ModName = WasmEdge_StringCreateByCString(""module_fib"");
FoundFuncCxt = WasmEdge_StoreFindFunctionRegistered(StoreCxt, ModName, FuncName);
WasmEdge_StringDelete(ModName);
WasmEdge_StringDelete(FuncName);

WasmEdge_ASTModuleDelete(ASTCxt);
WasmEdge_LoaderDelete(LoadCxt);
WasmEdge_ValidatorDelete(ValidCxt);
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StoreDelete(StoreCxt);
```

After the WasmEdge `0.10.0`, developers can instantiate several anonymous `Module` instances, and should retrieve the exported instances from named or anonymous `Module` instances:

```c
/* Create the store context. The store context is the object to link the modules for imports and exports. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* Result. */
WasmEdge_Result Res;

/* Create the loader context. The configure context can be NULL. */
WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
/* Create the validator context. The configure context can be NULL. */
WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);
/* Create the executor context. The configure context and the statistics context can be NULL. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);

/* Load the WASM file or the compiled-WASM file and convert into the AST module context. */
WasmEdge_ASTModuleContext *ASTCxt = NULL;
Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");
if (!WasmEdge_ResultOK(Res)) {
  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Validate the WASM module. */
Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Example: register and instantiate the WASM module with the module name ""module_fib"". */
WasmEdge_ModuleInstanceContext *NamedModCxt = NULL;
WasmEdge_String ModName = WasmEdge_StringCreateByCString(""module_fib"");
Res = WasmEdge_ExecutorRegister(ExecCxt, &NamedModCxt, StoreCxt, ASTCxt, ModName);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Example: Instantiate the WASM module and get the output module instance. */
WasmEdge_ModuleInstanceContext *ModCxt = NULL;
Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
  return -1;
}
WasmEdge_StringDelete(ModName);

/* Now, developers can retrieve the exported instances from the module instances. */
/* Take the exported functions as example. This WASM exports the function ""fib"". */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");
WasmEdge_FunctionInstanceContext *FoundFuncCxt;
/* Find the function ""fib"" from the instantiated anonymous module. */
FoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);
/* Find the function ""fib"" from the registered module ""module_fib"". */
FoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(NamedModCxt, FuncName);
/* Or developers can get the named module instance from the store: */
ModName = WasmEdge_StringCreateByCString(""module_fib"");
const WasmEdge_ModuleInstanceContext *ModCxtGot = WasmEdge_StoreFindModule(StoreCxt, ModName);
WasmEdge_StringDelete(ModName);
FoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxtGot, FuncName);
WasmEdge_StringDelete(FuncName);

WasmEdge_ModuleInstanceDelete(NamedModCxt);
WasmEdge_ModuleInstanceDelete(ModCxt);
WasmEdge_ASTModuleDelete(ASTCxt);
WasmEdge_LoaderDelete(LoadCxt);
WasmEdge_ValidatorDelete(ValidCxt);
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StoreDelete(StoreCxt);
```

## Host functions

The difference of host functions are the replacement of `WasmEdge_ImportObjectContext`.

```c
/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

/* Create the import object. */
WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");
WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);
WasmEdge_StringDelete(ExportName);

/* Create and add a function instance into the import object. */
enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
WasmEdge_FunctionInstanceContext *HostFunc =
    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
 * The third parameter is the pointer to the additional data object.
 * Developers should guarantee the life cycle of the data, and it can be
 * `NULL` if the external data is not needed.
 */
WasmEdge_FunctionTypeDelete(HostFType);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""add"");
WasmEdge_ImportObjectAddFunction(ImpObj, FuncName, HostFunc);
WasmEdge_StringDelete(FuncName);

/*
 * The import objects should be deleted.
 * Developers should __NOT__ destroy the instances added into the import object contexts.
 */
WasmEdge_ImportObjectDelete(ImpObj);
```

Developers can use the `WasmEdge_ModuleInstanceContext` to upgrade to WasmEdge `0.10.0` easily.

```c
/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

/* Create a module instance. */
WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");
WasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);
WasmEdge_StringDelete(ExportName);

/* Create and add a function instance into the module instance. */
enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
WasmEdge_FunctionInstanceContext *HostFunc =
    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
 * The third parameter is the pointer to the additional data object.
 * Developers should guarantee the life cycle of the data, and it can be
 * `NULL` if the external data is not needed.
 */
WasmEdge_FunctionTypeDelete(HostFType);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""add"");
WasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);
WasmEdge_StringDelete(FuncName);

/*
 * The module instance should be deleted.
 * Developers should __NOT__ destroy the instances added into the module instance contexts.
 */
WasmEdge_ModuleInstanceDelete(HostModCxt);
```
","This code is a documentation for the WasmEdge 0.10.0 C API, which provides an interface to work with WebAssembly (WASM) modules. The API allows developers to create and manipulate WASM modules, including instantiating them, registering imports and exports, and invoking functions.

The documentation covers the following topics:

1. Upgrading from WasmEdge 0.9.1 to 0.10.0:
	* Changes in the `WasmEdge_ImportObjectContext` structure
	* Replacement of APIs with new ones
2. Instantiating a WASM module:
	* Creating an instance from a compiled-WASM file or a binary buffer
	* Validating the instance
	* Registering imports and exports
3. Retrieving instances from the store:
	* Finding functions, tables, memories, and globals by name or index
4. Host functions:
	* Defining a host function body
	* Creating an import object context
	* Adding a function instance to the import object context
5. Using the `WasmEdge_ModuleInstanceContext` structure:
	* Creating a module instance from a compiled-WASM file or a binary buffer
	* Validating the instance
	* Registering imports and exports

The documentation includes code snippets in C that demonstrate how to use each API."
docs/embed/go/reference/upgrade_to_0.10.0.md,"---
sidebar_position: 8
---

# Upgrade to WasmEdge-Go v0.10.0

Due to the WasmEdge-Go API breaking changes, this document shows the guideline of programming with WasmEdge-Go API to upgrade from the `v0.9.2` to the `v0.10.0` version.

**Due to the `v0.9.1` is retracted, we use the version `v0.9.2` here.**

## Concepts

1. Merged the `ImportObject` into the `Module`.

   The `ImportObject` struct which is for the host functions is merged into `Module`. Developers can use the related APIs to construct host modules.

   - `wasmedge.NewImportObject()` is changed to `wasmedge.NewModule()`.
   - `(*wasmedge.ImportObject).Release()` is changed to `(*wasmedge.Module).Release()`.
   - `(*wasmedge.ImportObject).AddFunction()` is changed to `(*wasmedge.Module).AddFunction()`.
   - `(*wasmedge.ImportObject).AddTable()` is changed to `(*wasmedge.Module).AddTable()`.
   - `(*wasmedge.ImportObject).AddMemory()` is changed to `(*wasmedge.Module).AddMemory()`.
   - `(*wasmedge.ImportObject).AddGlobal()` is changed to `(*wasmedge.Module).AddGlobal()`.
   - `(*wasmedge.ImportObject).NewWasiImportObject()` is changed to `(*wasmedge.Module).NewWasiModule()`.
   - `(*wasmedge.ImportObject).NewWasmEdgeProcessImportObject()` is changed to `(*wasmedge.Module).NewWasmEdgeProcessModule()`.
   - `(*wasmedge.ImportObject).InitWASI()` is changed to `(*wasmedge.Module).InitWASI()`.
   - `(*wasmedge.ImportObject).InitWasmEdgeProcess()` is changed to `(*wasmedge.Module).InitWasmEdgeProcess()`.
   - `(*wasmedge.ImportObject).WasiGetExitCode()` is changed to `(*wasmedge.Module).WasiGetExitCode`.
   - `(*wasmedge.VM).RegisterImport()` is changed to `(*wasmedge.VM).RegisterModule()`.
   - `(*wasmedge.VM).GetImportObject()` is changed to `(*wasmedge.VM).GetImportModule()`.

   For the new host function examples, please refer to [the example below](#host-functions).

2. Used the pointer to `Function` instead of the index in the `FuncRef` value type.

   For the better performance and security, the `FuncRef` related APIs used the `*wasmedge.Function` for the parameters and returns.

   - `wasmedge.NewFuncRef()` is changed to use the `*Function` as it's argument.
   - Added `(wasmedge.FuncRef).GetRef()` to retrieve the `*Function`.

3. Supported multiple anonymous WASM module instantiation.

   In the version before `v0.9.2`, WasmEdge only supports 1 anonymous WASM module to be instantiated at one time. If developers instantiate a new WASM module, the old one will be replaced. After the `v0.10.0` version, developers can instantiate multiple anonymous WASM module by `Executor` and get the `Module` instance. But for the source code using the `VM` APIs, the behavior is not changed. For the new examples of instantiating multiple anonymous WASM modules, please refer to [the example below](#wasmedge-executor-changes).

4. Behavior changed of `Store`.

   The `Function`, `Table`, `Memory`, and `Global` instances retrievement from the `Store` is moved to the `Module` instance. The `Store` only manage the module linking when instantiation and the named module searching after the `v0.10.0` version.

   - `(*wasmedge.Store).ListFunction()` and `(*wasmedge.Store).ListFunctionRegistered()` is replaced by `(*wasmedge.Module).ListFunction()`.
   - `(*wasmedge.Store).ListTable()` and `(*wasmedge.Store).ListTableRegistered()` is replaced by `(*wasmedge.Module).ListTable()`.
   - `(*wasmedge.Store).ListMemory()` and `(*wasmedge.Store).ListMemoryRegistered()` is replaced by `(*wasmedge.Module).ListMemory()`.
   - `(*wasmedge.Store).ListGlobal()` and `(*wasmedge.Store).ListGlobalRegistered()` is replaced by `(*wasmedge.Module).ListGlobal()`.
   - `(*wasmedge.Store).FindFunction()` and `(*wasmedge.Store).FindFunctionRegistered()` is replaced by `(*wasmedge.Module).FindFunction()`.
   - `(*wasmedge.Store).FindTable()` and `(*wasmedge.Store).FindTableRegistered()` is replaced by `(*wasmedge.Module).FindTable()`.
   - `(*wasmedge.Store).FindMemory()` and `(*wasmedge.Store).FindMemoryRegistered()` is replaced by `(*wasmedge.Module).FindMemory()`.
   - `(*wasmedge.Store).FindGlobal()` and `(*wasmedge.Store).FindGlobalRegistered()` is replaced by `(*wasmedge.Module).FindGlobal()`.

   For the new examples of retrieving instances, please refer to [the example below](#instances-retrievement).

5. The `Module`-based resource management.

   Except the creation of `Module` instance for the host functions, the `Executor` will output a `Module` instance after instantiation. No matter the anonymous or named modules, developers have the responsibility to destroy them by `(*wasmedge.Module).Release()` API. The `Store` will link to the named `Module` instance after registering. After the destroyment of a `Module` instance, the `Store` will unlink to that automatically; after the destroyment of the `Store`, the all `Module` instances the `Store` linked to will unlink to that `Store` automatically.

## WasmEdge-Go VM changes

The `VM` APIs are basically not changed, except the `ImportObject` related APIs.

The following is the example of WASI initialization in WasmEdge-Go `v0.9.2`:

```go
conf := wasmedge.NewConfigure(wasmedge.WASI)
vm := wasmedge.NewVMWithConfig(conf)

// The following API can retrieve the pre-registration import objects from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
wasiobj := vm.GetImportObject(wasmedge.WASI)
// Initialize the WASI.
wasiobj.InitWasi(
  os.Args[1:],     // The args
  os.Environ(),    // The envs
  []string{"".:.""}, // The mapping preopens
)

// ...

vm.Release()
conf.Release()
```

Developers can change to use the WasmEdge-Go `v0.10.0` as follows, with only replacing the `ImportObject` into `Module`:

```go
conf := wasmedge.NewConfigure(wasmedge.WASI)
vm := wasmedge.NewVMWithConfig(conf)

// The following API can retrieve the pre-registration module instances from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
wasiobj := vm.GetImportModule(wasmedge.WASI)
// Initialize the WASI.
wasiobj.InitWasi(
  os.Args[1:],     // The args
  os.Environ(),    // The envs
  []string{"".:.""}, // The mapping preopens
)

// ...

vm.Release()
conf.Release()
```

The `VM` provides a new API for getting the current instantiated anonymous `Module` instance. For example, if developer want to get the exported `Global` instance:

```go
// Assume that a WASM module is instantiated in `vm`, and exports the ""global_i32"".
store := vm.GetStore()

globinst := store.FindGlobal(""global_i32"")
```

After the WasmEdge-Go `v0.10.0`, developers can use the `(*wasmedge.VM).GetActiveModule()` to get the module instance:

```go
// Assume that a WASM module is instantiated in `vm`, and exports the ""global_i32"".
mod := vm.GetActiveModule()

// The example of retrieving the global instance.
globinst := mod.FindGlobal(""global_i32"")
```

## WasmEdge Executor changes

`Executor` helps to instantiate a WASM module, register a WASM module into `Store` with module name, register the host modules with host functions, or invoke functions.

1. WASM module instantiation

   In WasmEdge-Go `v0.9.2` version, developers can instantiate a WASM module by the `Executor` API:

   ```go
   var ast *wasmedge.AST
   // Assume that `ast` is a loaded WASM from file or buffer and has passed the validation.
   // Assume that `executor` is a `*wasmedge.Executor`.
   // Assume that `store` is a `*wasmedge.Store`.
   err := executor.Instantiate(store, ast)
   if err != nil {
     fmt.Println(""Instantiation FAILED:"", err.Error())
   }
   ```

   Then the WASM module is instantiated into an anonymous module instance and handled by the `Store`. If a new WASM module is instantiated by this API, the old instantiated module instance will be cleaned. After the WasmEdge-Go `v0.10.0` version, the instantiated anonymous module will be outputted and handled by caller, and not only 1 anonymous module instance can be instantiated. Developers have the responsibility to release the outputted module instances.

   ```go
   var ast1 *wasmedge.AST
   var ast2 *wasmedge.AST
   // Assume that `ast1` and `ast2` are loaded WASMs from different files or buffers,
   // and have both passed the validation.
   // Assume that `executor` is a `*wasmedge.Executor`.
   // Assume that `store` is a `*wasmedge.Store`.
   mod1, err1 := executor.Instantiate(store, ast1)
   if err1 != nil {
     fmt.Println(""Instantiation FAILED:"", err1.Error())
   }
   mod2, err2 := executor.Instantiate(store, ast2)
   if err2 != nil {
     fmt.Println(""Instantiation FAILED:"", err2.Error())
   }
   mod1.Release()
   mod2.Release()
   ```

2. WASM module registration with module name

   When instantiating and registering a WASM module with module name, developers can use the `(*wasmedge.Executor).RegisterModule()` API before WasmEdge-Go `v0.9.2`.

   ```go
   var ast *wasmedge.AST
   // Assume that `ast` is a loaded WASM from file or buffer and has passed the validation.
   // Assume that `executor` is a `*wasmedge.Executor`.
   // Assume that `store` is a `*wasmedge.Store`.

   // Register the WASM module into store with the export module name ""mod"".
   err := executor.RegisterModule(store, ast, ""mod"")
   if err != nil {
     fmt.Println(""WASM registration FAILED:"", err.Error())
   }
   ```

   The same feature is implemented in WasmEdge-Go `v0.10.0`, but in different API `(*wasmedge.Executor).Register()`:

   ```go
   var ast *wasmedge.AST
   // Assume that `ast` is a loaded WASM from file or buffer and has passed the validation.
   // Assume that `executor` is a `*wasmedge.Executor`.
   // Assume that `store` is a `*wasmedge.Store`.

   // Register the WASM module into store with the export module name ""mod"".
   mod, err := executor.Register(store, ast, ""mod"")
   if err != nil {
     fmt.Println(""WASM registration FAILED:"", err.Error())
   }
   mod.Release()
   ```

   Developers have the responsibility to release the outputted module instances.

3. Host module registration

   In WasmEdge-Go `v0.9.2`, developers can create an `ImportObject` and register into `Store`.

   ```go
   // Create the import object with the export module name.
   impobj := wasmedge.NewImportObject(""module"")

   // ...
   // Add the host functions, tables, memories, and globals into the import object.

   // The import object has already contained the export module name.
   err := executor.RegisterImport(store, impobj)
   if err != nil {
     fmt.Println(""Import object registration FAILED:"", err.Error())
   }
   ```

   After WasmEdge-Go `v0.10.0`, developers should use the `Module` instance instead:

   ```go
   // Create the module instance with the export module name.
   impmod := wasmedge.NewModule(""module"")

   // ...
   // Add the host functions, tables, memories, and globals into the module instance.

   // The module instance has already contained the export module name.
   err := executor.RegisterImport(store, impmod)
   if err != nil {
     fmt.Println(""Module instance registration FAILED:"", err.Error())
   }
   ```

   Developers have the responsibility to release the created module instances.

4. WASM function invocation

   This example uses the WASM file `fibonacci.wasm` converted from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat). In WasmEdge-Go `v0.9.2` version, developers can invoke a WASM function with the export function name:

   ```go
   // Create the store object. The store object holds the instances.
   store := wasmedge.NewStore()
   // Error.
   var err error
   // AST object.
   var ast *wasmedge.AST
   // Return values.
   var res []interface{}

   // Create the loader object.
   loader := wasmedge.NewLoader()
   // Create the validator object.
   validator := wasmedge.NewValidator()
   // Create the executor object.
   executor := wasmedge.NewExecutor()

   // Load the WASM file or the compiled-WASM file and convert into the AST object.
   ast, err = loader.LoadFile(""fibonacci.wasm"")
   if err != nil {
     fmt.Println(""Load WASM from file FAILED:"", err.Error())
     return
   }
   // Validate the WASM module.
   err = validator.Validate(ast)
   if err != nil {
     fmt.Println(""Validation FAILED:"", err.Error())
     return
   }
   // Instantiate the WASM module into the Store object.
   err = executor.Instantiate(store, ast)
   if err != nil {
     fmt.Println(""Instantiation FAILED:"", err.Error())
     return
   }
   // Invoke the function which is exported with the function name ""fib"".
   res, err = executor.Invoke(store, ""fib"", int32(30))
   if err == nil {
     fmt.Println(""Get fibonacci[30]:"", res[0].(int32))
   } else {
     fmt.Println(""Run failed:"", err.Error())
   }

   ast.Release()
   loader.Release()
   validator.Release()
   executor.Release()
   store.Release()
   ```

   After the WasmEdge-Go `v0.10.0`, developers should retrieve the `Function` instance by function name first.

   ```go
   // ...
   // Ignore the unchanged steps before validation. Please refer to the sample code above.

   var mod *wasmedge.Module
   // Instantiate the WASM module and get the output module instance.
   mod, err = executor.Instantiate(store, ast)
   if err != nil {
     fmt.Println(""Instantiation FAILED:"", err.Error())
     return
   }
   // Retrieve the function instance by name.
   funcinst := mod.FindFunction(""fib"")
   if funcinst == nil {
     fmt.Println(""Run FAILED: Function name `fib` not found"")
     return
   }
   res, err = executor.Invoke(store, funcinst, int32(30))
   if err == nil {
     fmt.Println(""Get fibonacci[30]:"", res[0].(int32))
   } else {
     fmt.Println(""Run FAILED:"", err.Error())
   }

   ast.Release()
   mod.Release()
   loader.Release()
   validator.Release()
   executor.Release()
   store.Release()
   ```

## Instances retrievement

This example uses the WASM file `fibonacci.wasm` converted from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat).

Before the WasmEdge-Go `v0.9.2` versions, developers can retrieve all exported instances of named or anonymous modules from `Store`:

```go
// Create the store object. The store object holds the instances.
store := wasmedge.NewStore()
// Error.
var err error
// AST object.
var ast *wasmedge.AST

// Create the loader object.
loader := wasmedge.NewLoader()
// Create the validator object.
validator := wasmedge.NewValidator()
// Create the executor object.
executor := wasmedge.NewExecutor()

// Load the WASM file or the compiled-WASM file and convert into the AST object.
ast, err = loader.LoadFile(""fibonacci.wasm"")
if err != nil {
  fmt.Println(""Load WASM from file FAILED:"", err.Error())
  return
}
// Validate the WASM module.
err = validator.Validate(ast)
if err != nil {
  fmt.Println(""Validation FAILED:"", err.Error())
  return
}
// Example: register and instantiate the WASM module with the module name ""module_fib"".
err = executor.RegisterModule(store, ast, ""module_fib"")
if err != nil {
  fmt.Println(""Instantiation FAILED:"", err.Error())
  return
}
// Example: Instantiate the WASM module into the Store object.
err = executor.Instantiate(store, ast)
if err != nil {
  fmt.Println(""Instantiation FAILED:"", err.Error())
  return
}

// Now, developers can retrieve the exported instances from the store.
// Take the exported functions as example. This WASM exports the function ""fib"".
// Find the function ""fib"" from the instantiated anonymous module.
func1 := store.FindFunction(""fib"")
// Find the function ""fib"" from the registered module ""module_fib"".
func2 := store.FindFunctionRegistered(""module_fib"", ""fib"")

ast.Release()
store.Release()
loader.Release()
validator.Release()
executor.Release()
```

After the WasmEdge-Go `v0.10.0`, developers can instantiate several anonymous `Module` instances, and should retrieve the exported instances from named or anonymous `Module` instances:

```go
// Create the store object. The store is the object to link the modules for imports and exports.
store := wasmedge.NewStore()
// Error.
var err error
// AST object.
var ast *wasmedge.AST
// Module instances.
var namedmod *wasmedge.Module
var anonymousmod *wasmedge.Module

// Create the loader object.
loader := wasmedge.NewLoader()
// Create the validator object.
validator := wasmedge.NewValidator()
// Create the executor object.
executor := wasmedge.NewExecutor()

// Load the WASM file or the compiled-WASM file and convert into the AST object.
ast, err = loader.LoadFile(""fibonacci.wasm"")
if err != nil {
  fmt.Println(""Load WASM from file FAILED:"", err.Error())
  return
}
// Validate the WASM module.
err = validator.Validate(ast)
if err != nil {
  fmt.Println(""Validation FAILED:"", err.Error())
  return
}
// Example: register and instantiate the WASM module with the module name ""module_fib"".
namedmod, err = executor.Register(store, ast, ""module_fib"")
if err != nil {
  fmt.Println(""Instantiation FAILED:"", err.Error())
  return
}
// Example: Instantiate the WASM module and get the output module instance.
anonymousmod, err = executor.Instantiate(store, ast)
if err != nil {
  fmt.Println(""Instantiation FAILED:"", err.Error())
  return
}

// Now, developers can retrieve the exported instances from the module instances.
// Take the exported functions as example. This WASM exports the function ""fib"".
// Find the function ""fib"" from the instantiated anonymous module.
func1 := anonymousmod.FindFunction(""fib"")
// Find the function ""fib"" from the registered module ""module_fib"".
func2 := namedmod.FindFunction(""fib"")
// Or developers can get the named module instance from the store:
gotmod := store.FindModule(""module_fib"")
func3 := gotmod.FindFunction(""fib"")

namedmod.Release()
anonymousmod.Release()
ast.Release()
store.Release()
loader.Release()
validator.Release()
executor.Release()
```

## Host functions

The difference of host functions are the replacement of `ImportObject` struct.

```go
// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -> i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Return
  return returns, wasmedge.Result_Success
}

// ...

// Create an import object with the module name ""module"".
impobj := wasmedge.NewImportObject(""module"")

// Create and add a function instance into the import object with export name ""add"".
functype := wasmedge.NewFunctionType(
  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
  []wasmedge.ValType{wasmedge.ValType_I32},
)
hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
// The third parameter is the pointer to the additional data object.
// Developers should guarantee the life cycle of the data, and it can be `nil`
// if the external data is not needed.
functype.Release()
impobj.AddFunction(""add"", hostfunc)

// The import object should be released.
// Developers should __NOT__ release the instances added into the import objects.
impobj.Release()
```

Developers can use the `Module` struct to upgrade to WasmEdge `v0.10.0` easily.

```go
// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -> i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Return
  return returns, wasmedge.Result_Success
}

// ...

// Create a module instance with the module name ""module"".
mod := wasmedge.NewModule(""module"")

// Create and add a function instance into the module instance with export name ""add"".
functype := wasmedge.NewFunctionType(
  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
  []wasmedge.ValType{wasmedge.ValType_I32},
)
hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
// The third parameter is the pointer to the additional data object.
// Developers should guarantee the life cycle of the data, and it can be `nil`
// if the external data is not needed.
functype.Release()
mod.AddFunction(""add"", hostfunc)

// The module instances should be released.
// Developers should __NOT__ release the instances added into the module instance objects.
mod.Release()
```
","Based on the provided documentation, here is a concise and coherent summary of the code:

**Summary**

This document outlines the changes to the WasmEdge-Go API between versions `v0.9.2` and `v0.10.0`. The main changes involve the replacement of the `ImportObject` struct with the `Module` struct, which provides a more intuitive and efficient way to manage host functions, tables, memories, and globals.

**Key Changes**

1. **Replacement of ImportObject with Module**: The `Module` struct has been introduced as a replacement for the `ImportObject` struct. This change simplifies the management of host functions, tables, memories, and globals.
2. **Use of Function pointers instead of indices**: The use of function pointers (e.g., `*Function`) has replaced the use of function indices (e.g., `FuncRef`) to improve performance and security.
3. **Multiple anonymous WASM module instantiation**: WasmEdge-Go `v0.10.0` now supports instantiating multiple anonymous WASM modules using the Executor API, which returns a Module instance for each instantiated module.
4. **Module-based resource management**: The Executor API has been modified to return Module instances after instantiation, which allows developers to manage resources more efficiently.
5. **Store changes**: The Store API has been updated to only manage module linking and named module searching, while the Module instance is responsible for managing its own resources.

**Host Functions**

The documentation provides an example of how to define a host function using the `Module` struct, which simplifies the process of adding host functions to WasmEdge-Go.

In terms of potential issues or areas for improvement, the following points stand out:

1. **Code compatibility**: The changes in `v0.10.0` may break existing code that relies on the `ImportObject` struct. Developers should ensure their code is compatible with the new API.
2. **Performance implications**: The use of function pointers and Module instances may have performance implications, especially for large-scale applications. Developers should profile their code to identify any potential bottlenecks.
3. **Documentation completeness**: While the documentation provides a good overview of the changes, some sections (e.g., Store changes) could be expanded to provide more detailed information.

Overall, these changes aim to improve the efficiency and simplicity of WasmEdge-Go, making it easier for developers to work with WASM modules and host functions."
i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.10.0.md,"---
sidebar_position: 8
---

# Upgrade to WasmEdge-Go v0.10.0

Due to the WasmEdge-Go API breaking changes, this document shows the guideline of programming with WasmEdge-Go API to upgrade from the `v0.9.2` to the `v0.10.0` version.

**Due to the `v0.9.1` is retracted, we use the version `v0.9.2` here.**

## Concepts

1. Merged the `ImportObject` into the `Module`.

   The `ImportObject` struct which is for the host functions is merged into `Module`. Developers can use the related APIs to construct host modules.

   - `wasmedge.NewImportObject()` is changed to `wasmedge.NewModule()`.
   - `(*wasmedge.ImportObject).Release()` is changed to `(*wasmedge.Module).Release()`.
   - `(*wasmedge.ImportObject).AddFunction()` is changed to `(*wasmedge.Module).AddFunction()`.
   - `(*wasmedge.ImportObject).AddTable()` is changed to `(*wasmedge.Module).AddTable()`.
   - `(*wasmedge.ImportObject).AddMemory()` is changed to `(*wasmedge.Module).AddMemory()`.
   - `(*wasmedge.ImportObject).AddGlobal()` is changed to `(*wasmedge.Module).AddGlobal()`.
   - `(*wasmedge.ImportObject).NewWasiImportObject()` is changed to `(*wasmedge.Module).NewWasiModule()`.
   - `(*wasmedge.ImportObject).NewWasmEdgeProcessImportObject()` is changed to `(*wasmedge.Module).NewWasmEdgeProcessModule()`.
   - `(*wasmedge.ImportObject).InitWASI()` is changed to `(*wasmedge.Module).InitWASI()`.
   - `(*wasmedge.ImportObject).InitWasmEdgeProcess()` is changed to `(*wasmedge.Module).InitWasmEdgeProcess()`.
   - `(*wasmedge.ImportObject).WasiGetExitCode()` is changed to `(*wasmedge.Module).WasiGetExitCode`.
   - `(*wasmedge.VM).RegisterImport()` is changed to `(*wasmedge.VM).RegisterModule()`.
   - `(*wasmedge.VM).GetImportObject()` is changed to `(*wasmedge.VM).GetImportModule()`.

   For the new host function examples, please refer to [the example below](#host-functions).

2. Used the pointer to `Function` instead of the index in the `FuncRef` value type.

   For the better performance and security, the `FuncRef` related APIs used the `*wasmedge.Function` for the parameters and returns.

   - `wasmedge.NewFuncRef()` is changed to use the `*Function` as it's argument.
   - Added `(wasmedge.FuncRef).GetRef()` to retrieve the `*Function`.

3. Supported multiple anonymous WASM module instantiation.

   In the version before `v0.9.2`, WasmEdge only supports 1 anonymous WASM module to be instantiated at one time. If developers instantiate a new WASM module, the old one will be replaced. After the `v0.10.0` version, developers can instantiate multiple anonymous WASM module by `Executor` and get the `Module` instance. But for the source code using the `VM` APIs, the behavior is not changed. For the new examples of instantiating multiple anonymous WASM modules, please refer to [the example below](#wasmedge-executor-changes).

4. Behavior changed of `Store`.

   The `Function`, `Table`, `Memory`, and `Global` instances retrievement from the `Store` is moved to the `Module` instance. The `Store` only manage the module linking when instantiation and the named module searching after the `v0.10.0` version.

   - `(*wasmedge.Store).ListFunction()` and `(*wasmedge.Store).ListFunctionRegistered()` is replaced by `(*wasmedge.Module).ListFunction()`.
   - `(*wasmedge.Store).ListTable()` and `(*wasmedge.Store).ListTableRegistered()` is replaced by `(*wasmedge.Module).ListTable()`.
   - `(*wasmedge.Store).ListMemory()` and `(*wasmedge.Store).ListMemoryRegistered()` is replaced by `(*wasmedge.Module).ListMemory()`.
   - `(*wasmedge.Store).ListGlobal()` and `(*wasmedge.Store).ListGlobalRegistered()` is replaced by `(*wasmedge.Module).ListGlobal()`.
   - `(*wasmedge.Store).FindFunction()` and `(*wasmedge.Store).FindFunctionRegistered()` is replaced by `(*wasmedge.Module).FindFunction()`.
   - `(*wasmedge.Store).FindTable()` and `(*wasmedge.Store).FindTableRegistered()` is replaced by `(*wasmedge.Module).FindTable()`.
   - `(*wasmedge.Store).FindMemory()` and `(*wasmedge.Store).FindMemoryRegistered()` is replaced by `(*wasmedge.Module).FindMemory()`.
   - `(*wasmedge.Store).FindGlobal()` and `(*wasmedge.Store).FindGlobalRegistered()` is replaced by `(*wasmedge.Module).FindGlobal()`.

   For the new examples of retrieving instances, please refer to [the example below](#instances-retrievement).

5. The `Module`-based resource management.

   Except the creation of `Module` instance for the host functions, the `Executor` will output a `Module` instance after instantiation. No matter the anonymous or named modules, developers have the responsibility to destroy them by `(*wasmedge.Module).Release()` API. The `Store` will link to the named `Module` instance after registering. After the destroyment of a `Module` instance, the `Store` will unlink to that automatically; after the destroyment of the `Store`, the all `Module` instances the `Store` linked to will unlink to that `Store` automatically.

## WasmEdge-Go VM changes

The `VM` APIs are basically not changed, except the `ImportObject` related APIs.

The following is the example of WASI initialization in WasmEdge-Go `v0.9.2`:

```go
conf := wasmedge.NewConfigure(wasmedge.WASI)
vm := wasmedge.NewVMWithConfig(conf)

// The following API can retrieve the pre-registration import objects from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
wasiobj := vm.GetImportObject(wasmedge.WASI)
// Initialize the WASI.
wasiobj.InitWasi(
  os.Args[1:],     // The args
  os.Environ(),    // The envs
  []string{"".:.""}, // The mapping preopens
)

// ...

vm.Release()
conf.Release()
```

Developers can change to use the WasmEdge-Go `v0.10.0` as follows, with only replacing the `ImportObject` into `Module`:

```go
conf := wasmedge.NewConfigure(wasmedge.WASI)
vm := wasmedge.NewVMWithConfig(conf)

// The following API can retrieve the pre-registration module instances from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
wasiobj := vm.GetImportModule(wasmedge.WASI)
// Initialize the WASI.
wasiobj.InitWasi(
  os.Args[1:],     // The args
  os.Environ(),    // The envs
  []string{"".:.""}, // The mapping preopens
)

// ...

vm.Release()
conf.Release()
```

The `VM` provides a new API for getting the current instantiated anonymous `Module` instance. For example, if developer want to get the exported `Global` instance:

```go
// Assume that a WASM module is instantiated in `vm`, and exports the ""global_i32"".
store := vm.GetStore()

globinst := store.FindGlobal(""global_i32"")
```

After the WasmEdge-Go `v0.10.0`, developers can use the `(*wasmedge.VM).GetActiveModule()` to get the module instance:

```go
// Assume that a WASM module is instantiated in `vm`, and exports the ""global_i32"".
mod := vm.GetActiveModule()

// The example of retrieving the global instance.
globinst := mod.FindGlobal(""global_i32"")
```

## WasmEdge Executor changes

`Executor` helps to instantiate a WASM module, register a WASM module into `Store` with module name, register the host modules with host functions, or invoke functions.

1. WASM module instantiation

   In WasmEdge-Go `v0.9.2` version, developers can instantiate a WASM module by the `Executor` API:

   ```go
   var ast *wasmedge.AST
   // Assume that `ast` is a loaded WASM from file or buffer and has passed the validation.
   // Assume that `executor` is a `*wasmedge.Executor`.
   // Assume that `store` is a `*wasmedge.Store`.
   err := executor.Instantiate(store, ast)
   if err != nil {
     fmt.Println(""Instantiation FAILED:"", err.Error())
   }
   ```

   Then the WASM module is instantiated into an anonymous module instance and handled by the `Store`. If a new WASM module is instantiated by this API, the old instantiated module instance will be cleaned. After the WasmEdge-Go `v0.10.0` version, the instantiated anonymous module will be outputted and handled by caller, and not only 1 anonymous module instance can be instantiated. Developers have the responsibility to release the outputted module instances.

   ```go
   var ast1 *wasmedge.AST
   var ast2 *wasmedge.AST
   // Assume that `ast1` and `ast2` are loaded WASMs from different files or buffers,
   // and have both passed the validation.
   // Assume that `executor` is a `*wasmedge.Executor`.
   // Assume that `store` is a `*wasmedge.Store`.
   mod1, err1 := executor.Instantiate(store, ast1)
   if err1 != nil {
     fmt.Println(""Instantiation FAILED:"", err1.Error())
   }
   mod2, err2 := executor.Instantiate(store, ast2)
   if err2 != nil {
     fmt.Println(""Instantiation FAILED:"", err2.Error())
   }
   mod1.Release()
   mod2.Release()
   ```

2. WASM module registration with module name

   When instantiating and registering a WASM module with module name, developers can use the `(*wasmedge.Executor).RegisterModule()` API before WasmEdge-Go `v0.9.2`.

   ```go
   var ast *wasmedge.AST
   // Assume that `ast` is a loaded WASM from file or buffer and has passed the validation.
   // Assume that `executor` is a `*wasmedge.Executor`.
   // Assume that `store` is a `*wasmedge.Store`.

   // Register the WASM module into store with the export module name ""mod"".
   err := executor.RegisterModule(store, ast, ""mod"")
   if err != nil {
     fmt.Println(""WASM registration FAILED:"", err.Error())
   }
   ```

   The same feature is implemented in WasmEdge-Go `v0.10.0`, but in different API `(*wasmedge.Executor).Register()`:

   ```go
   var ast *wasmedge.AST
   // Assume that `ast` is a loaded WASM from file or buffer and has passed the validation.
   // Assume that `executor` is a `*wasmedge.Executor`.
   // Assume that `store` is a `*wasmedge.Store`.

   // Register the WASM module into store with the export module name ""mod"".
   mod, err := executor.Register(store, ast, ""mod"")
   if err != nil {
     fmt.Println(""WASM registration FAILED:"", err.Error())
   }
   mod.Release()
   ```

   Developers have the responsibility to release the outputted module instances.

3. Host module registration

   In WasmEdge-Go `v0.9.2`, developers can create an `ImportObject` and register into `Store`.

   ```go
   // Create the import object with the export module name.
   impobj := wasmedge.NewImportObject(""module"")

   // ...
   // Add the host functions, tables, memories, and globals into the import object.

   // The import object has already contained the export module name.
   err := executor.RegisterImport(store, impobj)
   if err != nil {
     fmt.Println(""Import object registration FAILED:"", err.Error())
   }
   ```

   After WasmEdge-Go `v0.10.0`, developers should use the `Module` instance instead:

   ```go
   // Create the module instance with the export module name.
   impmod := wasmedge.NewModule(""module"")

   // ...
   // Add the host functions, tables, memories, and globals into the module instance.

   // The module instance has already contained the export module name.
   err := executor.RegisterImport(store, impmod)
   if err != nil {
     fmt.Println(""Module instance registration FAILED:"", err.Error())
   }
   ```

   Developers have the responsibility to release the created module instances.

4. WASM function invocation

   This example uses the WASM file `fibonacci.wasm` converted from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat). In WasmEdge-Go `v0.9.2` version, developers can invoke a WASM function with the export function name:

   ```go
   // Create the store object. The store object holds the instances.
   store := wasmedge.NewStore()
   // Error.
   var err error
   // AST object.
   var ast *wasmedge.AST
   // Return values.
   var res []interface{}

   // Create the loader object.
   loader := wasmedge.NewLoader()
   // Create the validator object.
   validator := wasmedge.NewValidator()
   // Create the executor object.
   executor := wasmedge.NewExecutor()

   // Load the WASM file or the compiled-WASM file and convert into the AST object.
   ast, err = loader.LoadFile(""fibonacci.wasm"")
   if err != nil {
     fmt.Println(""Load WASM from file FAILED:"", err.Error())
     return
   }
   // Validate the WASM module.
   err = validator.Validate(ast)
   if err != nil {
     fmt.Println(""Validation FAILED:"", err.Error())
     return
   }
   // Instantiate the WASM module into the Store object.
   err = executor.Instantiate(store, ast)
   if err != nil {
     fmt.Println(""Instantiation FAILED:"", err.Error())
     return
   }
   // Invoke the function which is exported with the function name ""fib"".
   res, err = executor.Invoke(store, ""fib"", int32(30))
   if err == nil {
     fmt.Println(""Get fibonacci[30]:"", res[0].(int32))
   } else {
     fmt.Println(""Run failed:"", err.Error())
   }

   ast.Release()
   loader.Release()
   validator.Release()
   executor.Release()
   store.Release()
   ```

   After the WasmEdge-Go `v0.10.0`, developers should retrieve the `Function` instance by function name first.

   ```go
   // ...
   // Ignore the unchanged steps before validation. Please refer to the sample code above.

   var mod *wasmedge.Module
   // Instantiate the WASM module and get the output module instance.
   mod, err = executor.Instantiate(store, ast)
   if err != nil {
     fmt.Println(""Instantiation FAILED:"", err.Error())
     return
   }
   // Retrieve the function instance by name.
   funcinst := mod.FindFunction(""fib"")
   if funcinst == nil {
     fmt.Println(""Run FAILED: Function name `fib` not found"")
     return
   }
   res, err = executor.Invoke(store, funcinst, int32(30))
   if err == nil {
     fmt.Println(""Get fibonacci[30]:"", res[0].(int32))
   } else {
     fmt.Println(""Run FAILED:"", err.Error())
   }

   ast.Release()
   mod.Release()
   loader.Release()
   validator.Release()
   executor.Release()
   store.Release()
   ```

## Instances retrievement

This example uses the WASM file `fibonacci.wasm` converted from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat).

Before the WasmEdge-Go `v0.9.2` versions, developers can retrieve all exported instances of named or anonymous modules from `Store`:

```go
// Create the store object. The store object holds the instances.
store := wasmedge.NewStore()
// Error.
var err error
// AST object.
var ast *wasmedge.AST

// Create the loader object.
loader := wasmedge.NewLoader()
// Create the validator object.
validator := wasmedge.NewValidator()
// Create the executor object.
executor := wasmedge.NewExecutor()

// Load the WASM file or the compiled-WASM file and convert into the AST object.
ast, err = loader.LoadFile(""fibonacci.wasm"")
if err != nil {
  fmt.Println(""Load WASM from file FAILED:"", err.Error())
  return
}
// Validate the WASM module.
err = validator.Validate(ast)
if err != nil {
  fmt.Println(""Validation FAILED:"", err.Error())
  return
}
// Example: register and instantiate the WASM module with the module name ""module_fib"".
err = executor.RegisterModule(store, ast, ""module_fib"")
if err != nil {
  fmt.Println(""Instantiation FAILED:"", err.Error())
  return
}
// Example: Instantiate the WASM module into the Store object.
err = executor.Instantiate(store, ast)
if err != nil {
  fmt.Println(""Instantiation FAILED:"", err.Error())
  return
}

// Now, developers can retrieve the exported instances from the store.
// Take the exported functions as example. This WASM exports the function ""fib"".
// Find the function ""fib"" from the instantiated anonymous module.
func1 := store.FindFunction(""fib"")
// Find the function ""fib"" from the registered module ""module_fib"".
func2 := store.FindFunctionRegistered(""module_fib"", ""fib"")

ast.Release()
store.Release()
loader.Release()
validator.Release()
executor.Release()
```

After the WasmEdge-Go `v0.10.0`, developers can instantiate several anonymous `Module` instances, and should retrieve the exported instances from named or anonymous `Module` instances:

```go
// Create the store object. The store is the object to link the modules for imports and exports.
store := wasmedge.NewStore()
// Error.
var err error
// AST object.
var ast *wasmedge.AST
// Module instances.
var namedmod *wasmedge.Module
var anonymousmod *wasmedge.Module

// Create the loader object.
loader := wasmedge.NewLoader()
// Create the validator object.
validator := wasmedge.NewValidator()
// Create the executor object.
executor := wasmedge.NewExecutor()

// Load the WASM file or the compiled-WASM file and convert into the AST object.
ast, err = loader.LoadFile(""fibonacci.wasm"")
if err != nil {
  fmt.Println(""Load WASM from file FAILED:"", err.Error())
  return
}
// Validate the WASM module.
err = validator.Validate(ast)
if err != nil {
  fmt.Println(""Validation FAILED:"", err.Error())
  return
}
// Example: register and instantiate the WASM module with the module name ""module_fib"".
namedmod, err = executor.Register(store, ast, ""module_fib"")
if err != nil {
  fmt.Println(""Instantiation FAILED:"", err.Error())
  return
}
// Example: Instantiate the WASM module and get the output module instance.
anonymousmod, err = executor.Instantiate(store, ast)
if err != nil {
  fmt.Println(""Instantiation FAILED:"", err.Error())
  return
}

// Now, developers can retrieve the exported instances from the module instances.
// Take the exported functions as example. This WASM exports the function ""fib"".
// Find the function ""fib"" from the instantiated anonymous module.
func1 := anonymousmod.FindFunction(""fib"")
// Find the function ""fib"" from the registered module ""module_fib"".
func2 := namedmod.FindFunction(""fib"")
// Or developers can get the named module instance from the store:
gotmod := store.FindModule(""module_fib"")
func3 := gotmod.FindFunction(""fib"")

namedmod.Release()
anonymousmod.Release()
ast.Release()
store.Release()
loader.Release()
validator.Release()
executor.Release()
```

## Host functions

The difference of host functions are the replacement of `ImportObject` struct.

```go
// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -> i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Return
  return returns, wasmedge.Result_Success
}

// ...

// Create an import object with the module name ""module"".
impobj := wasmedge.NewImportObject(""module"")

// Create and add a function instance into the import object with export name ""add"".
functype := wasmedge.NewFunctionType(
  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
  []wasmedge.ValType{wasmedge.ValType_I32},
)
hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
// The third parameter is the pointer to the additional data object.
// Developers should guarantee the life cycle of the data, and it can be `nil`
// if the external data is not needed.
functype.Release()
impobj.AddFunction(""add"", hostfunc)

// The import object should be released.
// Developers should __NOT__ release the instances added into the import objects.
impobj.Release()
```

Developers can use the `Module` struct to upgrade to WasmEdge `v0.10.0` easily.

```go
// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -> i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Return
  return returns, wasmedge.Result_Success
}

// ...

// Create a module instance with the module name ""module"".
mod := wasmedge.NewModule(""module"")

// Create and add a function instance into the module instance with export name ""add"".
functype := wasmedge.NewFunctionType(
  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
  []wasmedge.ValType{wasmedge.ValType_I32},
)
hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
// The third parameter is the pointer to the additional data object.
// Developers should guarantee the life cycle of the data, and it can be `nil`
// if the external data is not needed.
functype.Release()
mod.AddFunction(""add"", hostfunc)

// The module instances should be released.
// Developers should __NOT__ release the instances added into the module instance objects.
mod.Release()
```
","Based on the provided specification, here is a concise summary of the code's purpose, functionality, and key components:

**Purpose:** The code is for upgrading to WasmEdge-Go v0.10.0 from v0.9.x.

**Functionality:**

1. **API changes:** The code documents changes in the APIs between WasmEdge-Go v0.9.x and v0.10.0, including:
	* `ImportObject` struct is merged into `Module`.
	* Use of pointer to `Function` instead of index in `FuncRef`.
	* Support for multiple anonymous WASM module instantiation.
	* Changes in behavior of `Store`.
2. **WasmEdge-Go VM changes:** The code highlights the unchanged APIs and the new API for getting the current instantiated anonymous `Module` instance.
3. **WasmEdge Executor changes:** The code documents the changes in the `Executor` API, including:
	* Instantiation of multiple anonymous modules.
	* Registration with module name.
	* Host module registration.
4. **Instances retrievement:** The code explains how to retrieve instances from named or anonymous modules in v0.10.0.

**Key components:**

1. **ImportObject**: Replaced by `Module` struct in v0.10.0.
2. **Store**: Now only manages module linking and named module searching.
3. **Executor**: Offers new APIs for instantiating multiple anonymous modules, registering with module name, and host module registration.
4. **WasmEdge-Go VM**: Remains mostly unchanged, but with the addition of a new API for getting the current instantiated anonymous `Module` instance.

The code aims to provide a clear migration path for developers upgrading from WasmEdge-Go v0.9.x to v0.10.0."
docs/embed/go/passing_data.md,"---
sidebar_position: 4
---

# Pass complex parameters to WASM functions

An issue with the WebAssembly spec is that it only supports a very limited number of data types. If you want to embed a WebAssembly function with complex call parameters or return values, you must manage memory pointers on Go SDK and WebAssembly function sides.

Complex call parameters and return values include dynamic memory structures such as strings and byte arrays.

In this section, we will discuss several examples.

- [Pass complex parameters to WASM functions](#pass-complex-parameters-to-wasm-functions)
  - [Pass strings to Rust functions](#pass-strings-to-rust-functions)
  - [Pass strings to TinyGo functions](#pass-strings-to-tinygo-functions)
  - [Pass bytes to Rust functions](#pass-bytes-to-rust-functions)
  - [Pass bytes to TinyGo functions](#pass-bytes-to-tinygo-functions)

## Pass strings to Rust functions

In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_MemoryGreet), we will demonstrate how to call [a Rust-based WebAssembly function](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreet/rust_memory_greet/src/lib.rs) from a Go app. Specially, we will discuss how to pass string data.

<!-- prettier-ignore -->
:::note
An alternative approach to pass and return complex values to Rust functions in WebAssembly is to use the `wasmedge_bindgen` compiler tool. You can [learn more here](bindgen.md).
:::

The Rust function takes a memory pointer for the string and constructs the Rust string itself.

```rust
use std::ffi::{CStr, CString};
use std::mem;
use std::os::raw::{c_char, c_void};

#[no_mangle]
pub extern fn allocate(size: usize) -> *mut c_void {
  let mut buffer = Vec::with_capacity(size);
  let pointer = buffer.as_mut_ptr();
  mem::forget(buffer);

  pointer as *mut c_void
}

#[no_mangle]
pub extern fn deallocate(pointer: *mut c_void, capacity: usize) {
  unsafe {
    let _ = Vec::from_raw_parts(pointer, 0, capacity);
  }
}

#[no_mangle]
pub extern fn greet(subject: *mut c_char) -> *mut c_char {
  let subject = unsafe { CStr::from_ptr(subject).to_bytes().to_vec() };
  let mut output = b""Hello, "".to_vec();
  output.extend(&subject);
  output.extend(&[b'!']);

  unsafe { CString::from_vec_unchecked(output) }.into_raw()
}
```

Use standard Rust compiler tools to compile the Rust source code into a WebAssembly bytecode application.

```bash
cd rust_memory_greet
cargo build --target wasm32-wasi
# The output WASM will be `target/wasm32-wasi/debug/rust_memory_greet_lib.wasm`.
```

The [Go SDK application](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreet/greet_memory.go) must call `allocate` from the WasmEdge VM to get a pointer to the string parameter. It will then call the `greet` function in Rust with the pointer. After the function returns, the Go application will call `deallocate` to free the memory space.

```go
package main

import (
  ""fmt""
  ""os""
  ""strings""

  ""github.com/second-state/WasmEdge-go/wasmedge""
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  vm := wasmedge.NewVMWithConfig(conf)

  wasi := vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{"".:.""},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(""failed to load wasm"")
  }
  vm.Validate()
  vm.Instantiate()

  subject := ""WasmEdge""
  lengthOfSubject := len(subject)

  // Allocate memory for the subject, and get a pointer to it.
  // Include a byte for the NULL terminator we add below.
  allocateResult, _ := vm.Execute(""allocate"", int32(lengthOfSubject + 1))
  inputPointer := allocateResult[0].(int32)

  // Write the subject into the memory.
  mod := vm.GetActiveModule()
  mem := mod.FindMemory(""memory"")
  memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))
  copy(memData, subject)

  // C-string terminates by NULL.
  memData[lengthOfSubject] = 0

  // Run the `greet` function. Given the pointer to the subject.
  greetResult, _ := vm.Execute(""greet"", inputPointer)
  outputPointer := greetResult[0].(int32)

  pageSize := mem.GetPageSize()
  // Read the result of the `greet` function.
  memData, _ = mem.GetData(uint(0), uint(pageSize * 65536))
  nth := 0
  var output strings.Builder

  for {
    if memData[int(outputPointer) + nth] == 0 {
      break
    }

    output.WriteByte(memData[int(outputPointer) + nth])
    nth++
  }

  lengthOfOutput := nth

  fmt.Println(output.String())

  // Deallocate the subject, and the output.
  vm.Execute(""deallocate"", inputPointer, int32(lengthOfSubject+1))
  vm.Execute(""deallocate"", outputPointer, int32(lengthOfOutput+1))

  vm.Release()
  conf.Release()
}
```

To build the Go SDK example, run the following commands.

```bash
go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}
go build greet_memory.go
```

Now you can use the Go application to run the WebAssembly plug-in compiled from Rust.

```bash
$ ./greet_memory rust_memory_greet_lib.wasm
Hello, WasmEdge!
```

## Pass strings to TinyGo functions

In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_MemoryGreetTinyGo), we will demonstrate how to call [a TinyGo-based WebAssembly function](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreetTinyGo/greet.go) from a Go app.

The TinyGo function takes a memory pointer for the string, and constructs the TinyGo string itself.

<!-- prettier-ignore -->
:::note
The empty `main()` is needed for the compiled WebAssembly program to set up WASI properly.
:::

```go
package main

import (
  ""strings""
  ""unsafe""
)

func main() {}

//export greet
func greet(subject *int32) *int32 {
  nth := 0
  var subjectStr strings.Builder
  pointer := uintptr(unsafe.Pointer(subject))
  for {
    s := *(*int32)(unsafe.Pointer(pointer + uintptr(nth)))
    if s == 0 {
      break
    }

    subjectStr.WriteByte(byte(s))
    nth++
  }

  output := []byte(""Hello, "" + subjectStr.String() + ""!"")

  r := make([]int32, 2)
  r[0] = int32(uintptr(unsafe.Pointer(&(output[0]))))
  r[1] = int32(len(output))

  return &r[0]
}
```

Use the TinyGo compiler tools to compile the Go source code into a WebAssembly bytecode application.

```bash
tinygo build -o greet.wasm -target wasi greet.go
```

The [Go SDK application](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreetTinyGo/greet_memory.go) must call `malloc` from the WasmEdge VM to get a pointer to the string parameter. It will then call the `greet` function in TinyGo with the pointer. After the function returns, the Go application will call `free` to free the memory space.

```go
package main

import (
  ""fmt""
  ""os""
  ""encoding/binary""

  ""github.com/second-state/WasmEdge-go/wasmedge""
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  vm := wasmedge.NewVMWithConfig(conf)

  wasi := vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{"".:.""},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(""failed to load wasm"")
  }
  vm.Validate()
  vm.Instantiate()

  subject := ""WasmEdge""
  lengthOfSubject := len(subject)

  // Allocate memory for the subject, and get a pointer to it.
  // Include a byte for the NULL terminator we add below.
  allocateResult, _ := vm.Execute(""malloc"", int32(lengthOfSubject+1))
  inputPointer := allocateResult[0].(int32)

  // Write the subject into the memory.
  mod := vm.GetActiveModule()
  mem := mod.FindMemory(""memory"")
  memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))
  copy(memData, subject)

  // C-string terminates by NULL.
  memData[lengthOfSubject] = 0

  // Run the `greet` function. Given the pointer to the subject.
  greetResult, _ := vm.Execute(""greet"", inputPointer)
  outputPointer := greetResult[0].(int32)

  memData, _ = mem.GetData(uint(outputPointer), 8)
  resultPointer := binary.LittleEndian.Uint32(memData[:4])
  resultLength := binary.LittleEndian.Uint32(memData[4:])

  // Read the result of the `greet` function.
  memData, _ = mem.GetData(uint(resultPointer), uint(resultLength))
  fmt.Println(string(memData))

  // Deallocate the subject, and the output.
  vm.Execute(""free"", inputPointer)

  vm.Release()
  conf.Release()
}
```

To build the Go SDK example, run the following commands.

```bash
go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}
go build greet_memory.go
```

Now you can use the Go application to run the WebAssembly plug-in compiled from TinyGo.

```bash
$ ./greet_memory greet.wasm
Hello, WasmEdge!
```

## Pass bytes to Rust functions

In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_AccessMemory), we will demonstrate how to call [Rust-based WebAssembly functions](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemory/rust_access_memory/src/lib.rs) and pass arrays to and from a Go app.

<!-- prettier-ignore -->
:::note
An alternative approach to pass and return complex values to Rust functions in WebAssembly is to use the `wasmedge_bindgen` compiler tool. You can [learn more here](bindgen.md).
:::

The `fib_array()` function takes an array as a call parameter and fills it with a Fibonacci sequence of numbers. Alternatively, the `fib_array_return_memory()` function returns an array of Fibonacci sequences of numbers.

For the array in the call parameter, the Rust function `fib_array()` takes a memory pointer and constructs the Rust `Vec` using `from_raw_parts`. For the array return value, the Rust function `fib_array_return_memory()` simply returns the pointer.

```rust
use std::mem;
use std::os::raw::{c_void, c_int};

#[no_mangle]
pub extern fn allocate(size: usize) -> *mut c_void {
  let mut buffer = Vec::with_capacity(size);
  let pointer = buffer.as_mut_ptr();
  mem::forget(buffer);

  pointer as *mut c_void
}

#[no_mangle]
pub extern fn deallocate(pointer: *mut c_void, capacity: usize) {
  unsafe {
    let _ = Vec::from_raw_parts(pointer, 0, capacity);
  }
}

#[no_mangle]
pub extern fn fib_array(n: i32, p: *mut c_int) -> i32 {
  unsafe {
    let mut arr = Vec::<i32>::from_raw_parts(p, 0, (4*n) as usize);
    for i in 0..n {
      if i < 2 {
        arr.push(i);
      } else {
        arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);
      }
    }
    let r = arr[(n - 1) as usize];
    mem::forget(arr);
    r
  }
}

#[no_mangle]
pub extern fn fib_array_return_memory(n: i32) -> *mut c_int {
  let mut arr = Vec::with_capacity((4 * n) as usize);
  let pointer = arr.as_mut_ptr();
  for i in 0..n {
    if i < 2 {
      arr.push(i);
    } else {
      arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);
    }
  }
  mem::forget(arr);
  pointer
}
```

Use standard Rust compiler tools to compile the Rust source code into a WebAssembly bytecode application.

```bash
cd rust_access_memory
cargo build --target wasm32-wasi
# The output WASM will be target/wasm32-wasi/debug/rust_access_memory_lib.wasm.
```

The [Go SDK application](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemory/run.go) must call `allocate` from the WasmEdge VM to get a pointer to the array. It will then call the `fib_array()` function in Rust and pass in the pointer. After the functions return, the Go application will use the WasmEdge `store` API to construct an array from the pointer in the call parameter (`fib_array()`) or in the return value (`fib_array_return_memory()`). The Go app will eventually call `deallocate` to free the memory space.

```go
package main

import (
  ""fmt""
  ""os""
  ""unsafe""

  ""github.com/second-state/WasmEdge-go/wasmedge""
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  vm := wasmedge.NewVMWithConfig(conf)

  wasi := vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{"".:.""},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(""failed to load wasm"")
  }
  vm.Validate()
  vm.Instantiate()

  n := int32(10)

  p, err := vm.Execute(""allocate"", 4 * n)
  if err != nil {
    fmt.Println(""allocate failed:"", err)
  }

  fib, err := vm.Execute(""fib_array"", n, p[0])
  if err != nil {
    fmt.Println(""fib_rray failed:"", err)
  } else {
    fmt.Println(""fib_array() returned:"", fib[0])
    fmt.Printf(""fib_array memory at: %p\n"", unsafe.Pointer((uintptr)(p[0].(int32))))
    mod := vm.GetActiveModule()
    mem := mod.FindMemory(""memory"")
    if mem != nil {
      // int32 occupies 4 bytes
      fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))
      if err == nil && fibArray != nil {
        fmt.Println(""fibArray:"", fibArray)
      }
    }
  }

  fibP, err := vm.Execute(""fib_array_return_memory"", n)
  if err != nil {
    fmt.Println(""fib_array_return_memory failed:"", err)
  } else {
    fmt.Printf(""fib_array_return_memory memory at: %p\n"", unsafe.Pointer((uintptr)(fibP[0].(int32))))
    mod := vm.GetActiveModule()
    mem := mod.FindMemory(""memory"")
    if mem != nil {
      // int32 occupies 4 bytes
      fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))
      if err == nil && fibArrayReturnMemory != nil {
        fmt.Println(""fibArrayReturnMemory:"", fibArrayReturnMemory)
      }
    }
  }

  _, err = vm.Execute(""deallocate"", p[0].(int32), 4 * n)
  if err != nil {
    fmt.Println(""free failed:"", err)
  }


  exitcode := wasi.WasiGetExitCode()
  if exitcode != 0 {
    fmt.Println(""Go: Running wasm failed, exit code:"", exitcode)
  }

  vm.Release()
  conf.Release()
}
```

To build the Go SDK example, run the following commands.

```bash
go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}
go build run.go
```

Now you can use the Go application to run the WebAssembly plug-in compiled from Rust.

```bash
$ ./run rust_access_memory_lib.wasm
fib_array() returned: 34
fib_array memory at: 0x102d80
fibArray: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
fib_array_return_memory memory at: 0x105430
fibArrayReturnMemory: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
```

## Pass bytes to TinyGo functions

In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_AccessMemoryTinyGo), we will demonstrate how to call [TinyGo-based WebAssembly functions](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemoryTinyGo/fib.go) and pass arrays to and from a Go app.

The `fibArray` function takes an array as a call parameter and fills it with a Fibonacci sequence of numbers. Alternatively, the `fibArrayReturnMemory` function returns an array of Fibonacci sequences of numbers.

```go
package main

import (
  ""fmt""
  ""unsafe""
)

func main() {
  println(""in main"")
  n := int32(10)
  arr := make([]int32, n)
  arrP := &arr[0]
  fmt.Printf(""call fibArray(%d, %p) = %d\n"", n, arrP, fibArray(n, arrP))
  fmt.Printf(""call fibArrayReturnMemory(%d) return %p\n"", n, fibArrayReturnMemory(n))
}

// export fibArray
func fibArray(n int32, p *int32) int32 {
  arr := unsafe.Slice(p, n)
  for i := int32(0); i < n; i++ {
    switch {
    case i < 2:
      arr[i] = i
    default:
      arr[i] = arr[i-1] + arr[i-2]
    }
  }
  return arr[n-1]
}

// export fibArrayReturnMemory
func fibArrayReturnMemory(n int32) *int32 {
  arr := make([]int32, n)
  for i := int32(0); i < n; i++ {
    switch {
    case i < 2:
      arr[i] = i
    default:
      arr[i] = arr[i-1] + arr[i-2]
    }
  }
  return &arr[0]
}
```

Use the TinyGo compiler tools to compile the Go source code into a WebAssembly bytecode application.

```bash
tinygo build -o fib.wasm -target wasi fib.go
```

The [Go SDK application](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemoryTinyGo/run.go) must call `malloc` from the WasmEdge VM to get a pointer to the array. It will then call the `fibArray()` function in TinyGo with the pointer. After the functions return, the Go app uses the WasmEdge SDK's `store` API to construct an array from the pointer in the call parameter (`fibArray()`) or in the return value (`fibArrayReturnMemory()`). The Go application will eventually call `free` to free the memory space.

```go
package main

import (
  ""fmt""
  ""os""
  ""unsafe""

  ""github.com/second-state/WasmEdge-go/wasmedge""
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  vm := wasmedge.NewVMWithConfig(conf)

  wasi := vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{"".:.""},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(""failed to load wasm"")
  }
  vm.Validate()
  vm.Instantiate()

  n := int32(10)

  p, err := vm.Execute(""malloc"", n)
  if err != nil {
    fmt.Println(""malloc failed:"", err)
  }

  fib, err := vm.Execute(""fibArray"", n, p[0])
  if err != nil {
    fmt.Println(""fibArray failed:"", err)
  } else {
    fmt.Println(""fibArray() returned:"", fib[0])
    fmt.Printf(""fibArray memory at: %p\n"", unsafe.Pointer((uintptr)(p[0].(int32))))
    mod := vm.GetActiveModule()
    mem := mod.FindMemory(""memory"")
    if mem != nil {
      // int32 occupies 4 bytes
      fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))
      if err == nil && fibArray != nil {
        fmt.Println(""fibArray:"", fibArray)
      }
    }
  }

  fibP, err := vm.Execute(""fibArrayReturnMemory"", n)
  if err != nil {
    fmt.Println(""fibArrayReturnMemory failed:"", err)
  } else {
    fmt.Printf(""fibArrayReturnMemory memory at: %p\n"", unsafe.Pointer((uintptr)(fibP[0].(int32))))
    mod := vm.GetActiveModule()
    mem := mod.FindMemory(""memory"")
    if mem != nil {
      // int32 occupies 4 bytes
      fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))
      if err == nil && fibArrayReturnMemory != nil {
        fmt.Println(""fibArrayReturnMemory:"", fibArrayReturnMemory)
      }
    }
  }

  _, err = vm.Execute(""free"", p...)
  if err != nil {
    fmt.Println(""free failed:"", err)
  }

  exitcode := wasi.WasiGetExitCode()
  if exitcode != 0 {
    fmt.Println(""Go: Running wasm failed, exit code:"", exitcode)
  }

  vm.Release()
  conf.Release()
}
```

To build the Go SDK example, run the following commands.

```bash
go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}
go build run.go
```

Now you can use the Go application to run the WebAssembly plug-in compiled from TinyGo.

```bash
$ ./run fib.wasm
fibArray() returned: 34
fibArray memory at: 0x14d3c
fibArray: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
fibArrayReturnMemory memory at: 0x14d4c
fibArrayReturnMemory: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
```
","**Summary**

The provided code is a collection of examples that demonstrate how to pass complex parameters and return values between Go and WebAssembly (WASM) functions. The examples cover various scenarios, including passing strings and bytes to WASM functions compiled from Rust and TinyGo.

**Key Components**

1. **WebAssembly runtime**: The WASM runtime is used to load and execute the WASM functions.
2. **Go SDK**: The Go SDK provides a set of APIs for interacting with the WASM runtime.
3. **WASM functions**: The examples demonstrate how to define WASM functions in Rust and TinyGo, which can be called from the Go application.

**Functionality**

The code showcases several key aspects of passing complex parameters and return values between Go and WASM:

1. **Passing strings**: The code demonstrates how to pass strings as call parameters from Go to WASM functions compiled from Rust and TinyGo.
2. **Passing bytes**: The code shows how to pass arrays (bytes) as call parameters from Go to WASM functions compiled from Rust and TinyGo.
3. **Returning complex values**: The examples demonstrate how to return complex values, such as arrays (bytes), from WASM functions compiled from Rust and TinyGo.

**Potential Issues**

1. **Memory management**: When passing complex data types between languages, memory management becomes crucial. In the provided code, the Go application is responsible for allocating and deallocating memory using the `malloc` and `free` functions.
2. **Type safety**: The examples use explicit type casting to ensure type safety when working with WASM functions. However, in more complex scenarios, type errors can occur if not handled properly.

**Improvement Suggestions**

1. **Use a more robust memory management approach**: Instead of relying on manual memory allocation and deallocation using `malloc` and `free`, consider using a memory pool or a garbage collector to manage memory.
2. **Implement error handling mechanisms**: Add try-catch blocks to handle errors that may occur during WASM function calls, such as invalid input data or runtime errors.
3. **Optimize performance-critical code**: Identify performance bottlenecks in the code and optimize them using techniques like caching, loop unrolling, or parallel processing."
i18n/zh/docusaurus-plugin-content-docs/current/embed/go/passing_data.md,"---
sidebar_position: 4
---

# Pass complex parameters to WASM functions

An issue with the WebAssembly spec is that it only supports a very limited number of data types. If you want to embed a WebAssembly function with complex call parameters or return values, you must manage memory pointers on Go SDK and WebAssembly function sides.

Complex call parameters and return values include dynamic memory structures such as strings and byte arrays.

In this section, we will discuss several examples.

- [Pass complex parameters to WASM functions](#pass-complex-parameters-to-wasm-functions)
  - [Pass strings to Rust functions](#pass-strings-to-rust-functions)
  - [Pass strings to TinyGo functions](#pass-strings-to-tinygo-functions)
  - [Pass bytes to Rust functions](#pass-bytes-to-rust-functions)
  - [Pass bytes to TinyGo functions](#pass-bytes-to-tinygo-functions)

## Pass strings to Rust functions

In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_MemoryGreet), we will demonstrate how to call [a Rust-based WebAssembly function](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreet/rust_memory_greet/src/lib.rs) from a Go app. Specially, we will discuss how to pass string data.

<!-- prettier-ignore -->
:::note
An alternative approach to pass and return complex values to Rust functions in WebAssembly is to use the `wasmedge_bindgen` compiler tool. You can [learn more here](bindgen.md).
:::

The Rust function takes a memory pointer for the string and constructs the Rust string itself.

```rust
use std::ffi::{CStr, CString};
use std::mem;
use std::os::raw::{c_char, c_void};

#[no_mangle]
pub extern fn allocate(size: usize) -> *mut c_void {
  let mut buffer = Vec::with_capacity(size);
  let pointer = buffer.as_mut_ptr();
  mem::forget(buffer);

  pointer as *mut c_void
}

#[no_mangle]
pub extern fn deallocate(pointer: *mut c_void, capacity: usize) {
  unsafe {
    let _ = Vec::from_raw_parts(pointer, 0, capacity);
  }
}

#[no_mangle]
pub extern fn greet(subject: *mut c_char) -> *mut c_char {
  let subject = unsafe { CStr::from_ptr(subject).to_bytes().to_vec() };
  let mut output = b""Hello, "".to_vec();
  output.extend(&subject);
  output.extend(&[b'!']);

  unsafe { CString::from_vec_unchecked(output) }.into_raw()
}
```

Use standard Rust compiler tools to compile the Rust source code into a WebAssembly bytecode application.

```bash
cd rust_memory_greet
cargo build --target wasm32-wasi
# The output WASM will be `target/wasm32-wasi/debug/rust_memory_greet_lib.wasm`.
```

The [Go SDK application](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreet/greet_memory.go) must call `allocate` from the WasmEdge VM to get a pointer to the string parameter. It will then call the `greet` function in Rust with the pointer. After the function returns, the Go application will call `deallocate` to free the memory space.

```go
package main

import (
  ""fmt""
  ""os""
  ""strings""

  ""github.com/second-state/WasmEdge-go/wasmedge""
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  vm := wasmedge.NewVMWithConfig(conf)

  wasi := vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{"".:.""},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(""failed to load wasm"")
  }
  vm.Validate()
  vm.Instantiate()

  subject := ""WasmEdge""
  lengthOfSubject := len(subject)

  // Allocate memory for the subject, and get a pointer to it.
  // Include a byte for the NULL terminator we add below.
  allocateResult, _ := vm.Execute(""allocate"", int32(lengthOfSubject + 1))
  inputPointer := allocateResult[0].(int32)

  // Write the subject into the memory.
  mod := vm.GetActiveModule()
  mem := mod.FindMemory(""memory"")
  memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))
  copy(memData, subject)

  // C-string terminates by NULL.
  memData[lengthOfSubject] = 0

  // Run the `greet` function. Given the pointer to the subject.
  greetResult, _ := vm.Execute(""greet"", inputPointer)
  outputPointer := greetResult[0].(int32)

  pageSize := mem.GetPageSize()
  // Read the result of the `greet` function.
  memData, _ = mem.GetData(uint(0), uint(pageSize * 65536))
  nth := 0
  var output strings.Builder

  for {
    if memData[int(outputPointer) + nth] == 0 {
      break
    }

    output.WriteByte(memData[int(outputPointer) + nth])
    nth++
  }

  lengthOfOutput := nth

  fmt.Println(output.String())

  // Deallocate the subject, and the output.
  vm.Execute(""deallocate"", inputPointer, int32(lengthOfSubject+1))
  vm.Execute(""deallocate"", outputPointer, int32(lengthOfOutput+1))

  vm.Release()
  conf.Release()
}
```

To build the Go SDK example, run the following commands.

```bash
go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}
go build greet_memory.go
```

Now you can use the Go application to run the WebAssembly plug-in compiled from Rust.

```bash
$ ./greet_memory rust_memory_greet_lib.wasm
Hello, WasmEdge!
```

## Pass strings to TinyGo functions

In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_MemoryGreetTinyGo), we will demonstrate how to call [a TinyGo-based WebAssembly function](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreetTinyGo/greet.go) from a Go app.

The TinyGo function takes a memory pointer for the string, and constructs the TinyGo string itself.

<!-- prettier-ignore -->
:::note
The empty `main()` is needed for the compiled WebAssembly program to set up WASI properly.
:::

```go
package main

import (
  ""strings""
  ""unsafe""
)

func main() {}

//export greet
func greet(subject *int32) *int32 {
  nth := 0
  var subjectStr strings.Builder
  pointer := uintptr(unsafe.Pointer(subject))
  for {
    s := *(*int32)(unsafe.Pointer(pointer + uintptr(nth)))
    if s == 0 {
      break
    }

    subjectStr.WriteByte(byte(s))
    nth++
  }

  output := []byte(""Hello, "" + subjectStr.String() + ""!"")

  r := make([]int32, 2)
  r[0] = int32(uintptr(unsafe.Pointer(&(output[0]))))
  r[1] = int32(len(output))

  return &r[0]
}
```

Use the TinyGo compiler tools to compile the Go source code into a WebAssembly bytecode application.

```bash
tinygo build -o greet.wasm -target wasi greet.go
```

The [Go SDK application](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreetTinyGo/greet_memory.go) must call `malloc` from the WasmEdge VM to get a pointer to the string parameter. It will then call the `greet` function in TinyGo with the pointer. After the function returns, the Go application will call `free` to free the memory space.

```go
package main

import (
  ""fmt""
  ""os""
  ""encoding/binary""

  ""github.com/second-state/WasmEdge-go/wasmedge""
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  vm := wasmedge.NewVMWithConfig(conf)

  wasi := vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{"".:.""},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(""failed to load wasm"")
  }
  vm.Validate()
  vm.Instantiate()

  subject := ""WasmEdge""
  lengthOfSubject := len(subject)

  // Allocate memory for the subject, and get a pointer to it.
  // Include a byte for the NULL terminator we add below.
  allocateResult, _ := vm.Execute(""malloc"", int32(lengthOfSubject+1))
  inputPointer := allocateResult[0].(int32)

  // Write the subject into the memory.
  mod := vm.GetActiveModule()
  mem := mod.FindMemory(""memory"")
  memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))
  copy(memData, subject)

  // C-string terminates by NULL.
  memData[lengthOfSubject] = 0

  // Run the `greet` function. Given the pointer to the subject.
  greetResult, _ := vm.Execute(""greet"", inputPointer)
  outputPointer := greetResult[0].(int32)

  memData, _ = mem.GetData(uint(outputPointer), 8)
  resultPointer := binary.LittleEndian.Uint32(memData[:4])
  resultLength := binary.LittleEndian.Uint32(memData[4:])

  // Read the result of the `greet` function.
  memData, _ = mem.GetData(uint(resultPointer), uint(resultLength))
  fmt.Println(string(memData))

  // Deallocate the subject, and the output.
  vm.Execute(""free"", inputPointer)

  vm.Release()
  conf.Release()
}
```

To build the Go SDK example, run the following commands.

```bash
go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}
go build greet_memory.go
```

Now you can use the Go application to run the WebAssembly plug-in compiled from TinyGo.

```bash
$ ./greet_memory greet.wasm
Hello, WasmEdge!
```

## Pass bytes to Rust functions

In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_AccessMemory), we will demonstrate how to call [Rust-based WebAssembly functions](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemory/rust_access_memory/src/lib.rs) and pass arrays to and from a Go app.

<!-- prettier-ignore -->
:::note
An alternative approach to pass and return complex values to Rust functions in WebAssembly is to use the `wasmedge_bindgen` compiler tool. You can [learn more here](bindgen.md).
:::

The `fib_array()` function takes an array as a call parameter and fills it with a Fibonacci sequence of numbers. Alternatively, the `fib_array_return_memory()` function returns an array of Fibonacci sequences of numbers.

For the array in the call parameter, the Rust function `fib_array()` takes a memory pointer and constructs the Rust `Vec` using `from_raw_parts`. For the array return value, the Rust function `fib_array_return_memory()` simply returns the pointer.

```rust
use std::mem;
use std::os::raw::{c_void, c_int};

#[no_mangle]
pub extern fn allocate(size: usize) -> *mut c_void {
  let mut buffer = Vec::with_capacity(size);
  let pointer = buffer.as_mut_ptr();
  mem::forget(buffer);

  pointer as *mut c_void
}

#[no_mangle]
pub extern fn deallocate(pointer: *mut c_void, capacity: usize) {
  unsafe {
    let _ = Vec::from_raw_parts(pointer, 0, capacity);
  }
}

#[no_mangle]
pub extern fn fib_array(n: i32, p: *mut c_int) -> i32 {
  unsafe {
    let mut arr = Vec::<i32>::from_raw_parts(p, 0, (4*n) as usize);
    for i in 0..n {
      if i < 2 {
        arr.push(i);
      } else {
        arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);
      }
    }
    let r = arr[(n - 1) as usize];
    mem::forget(arr);
    r
  }
}

#[no_mangle]
pub extern fn fib_array_return_memory(n: i32) -> *mut c_int {
  let mut arr = Vec::with_capacity((4 * n) as usize);
  let pointer = arr.as_mut_ptr();
  for i in 0..n {
    if i < 2 {
      arr.push(i);
    } else {
      arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);
    }
  }
  mem::forget(arr);
  pointer
}
```

Use standard Rust compiler tools to compile the Rust source code into a WebAssembly bytecode application.

```bash
cd rust_access_memory
cargo build --target wasm32-wasi
# The output WASM will be target/wasm32-wasi/debug/rust_access_memory_lib.wasm.
```

The [Go SDK application](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemory/run.go) must call `allocate` from the WasmEdge VM to get a pointer to the array. It will then call the `fib_array()` function in Rust and pass in the pointer. After the functions return, the Go application will use the WasmEdge `store` API to construct an array from the pointer in the call parameter (`fib_array()`) or in the return value (`fib_array_return_memory()`). The Go app will eventually call `deallocate` to free the memory space.

```go
package main

import (
  ""fmt""
  ""os""
  ""unsafe""

  ""github.com/second-state/WasmEdge-go/wasmedge""
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  vm := wasmedge.NewVMWithConfig(conf)

  wasi := vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{"".:.""},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(""failed to load wasm"")
  }
  vm.Validate()
  vm.Instantiate()

  n := int32(10)

  p, err := vm.Execute(""allocate"", 4 * n)
  if err != nil {
    fmt.Println(""allocate failed:"", err)
  }

  fib, err := vm.Execute(""fib_array"", n, p[0])
  if err != nil {
    fmt.Println(""fib_rray failed:"", err)
  } else {
    fmt.Println(""fib_array() returned:"", fib[0])
    fmt.Printf(""fib_array memory at: %p\n"", unsafe.Pointer((uintptr)(p[0].(int32))))
    mod := vm.GetActiveModule()
    mem := mod.FindMemory(""memory"")
    if mem != nil {
      // int32 occupies 4 bytes
      fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))
      if err == nil && fibArray != nil {
        fmt.Println(""fibArray:"", fibArray)
      }
    }
  }

  fibP, err := vm.Execute(""fib_array_return_memory"", n)
  if err != nil {
    fmt.Println(""fib_array_return_memory failed:"", err)
  } else {
    fmt.Printf(""fib_array_return_memory memory at: %p\n"", unsafe.Pointer((uintptr)(fibP[0].(int32))))
    mod := vm.GetActiveModule()
    mem := mod.FindMemory(""memory"")
    if mem != nil {
      // int32 occupies 4 bytes
      fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))
      if err == nil && fibArrayReturnMemory != nil {
        fmt.Println(""fibArrayReturnMemory:"", fibArrayReturnMemory)
      }
    }
  }

  _, err = vm.Execute(""deallocate"", p[0].(int32), 4 * n)
  if err != nil {
    fmt.Println(""free failed:"", err)
  }


  exitcode := wasi.WasiGetExitCode()
  if exitcode != 0 {
    fmt.Println(""Go: Running wasm failed, exit code:"", exitcode)
  }

  vm.Release()
  conf.Release()
}
```

To build the Go SDK example, run the following commands.

```bash
go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}
go build run.go
```

Now you can use the Go application to run the WebAssembly plug-in compiled from Rust.

```bash
$ ./run rust_access_memory_lib.wasm
fib_array() returned: 34
fib_array memory at: 0x102d80
fibArray: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
fib_array_return_memory memory at: 0x105430
fibArrayReturnMemory: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
```

## Pass bytes to TinyGo functions

In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_AccessMemoryTinyGo), we will demonstrate how to call [TinyGo-based WebAssembly functions](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemoryTinyGo/fib.go) and pass arrays to and from a Go app.

The `fibArray` function takes an array as a call parameter and fills it with a Fibonacci sequence of numbers. Alternatively, the `fibArrayReturnMemory` function returns an array of Fibonacci sequences of numbers.

```go
package main

import (
  ""fmt""
  ""unsafe""
)

func main() {
  println(""in main"")
  n := int32(10)
  arr := make([]int32, n)
  arrP := &arr[0]
  fmt.Printf(""call fibArray(%d, %p) = %d\n"", n, arrP, fibArray(n, arrP))
  fmt.Printf(""call fibArrayReturnMemory(%d) return %p\n"", n, fibArrayReturnMemory(n))
}

// export fibArray
func fibArray(n int32, p *int32) int32 {
  arr := unsafe.Slice(p, n)
  for i := int32(0); i < n; i++ {
    switch {
    case i < 2:
      arr[i] = i
    default:
      arr[i] = arr[i-1] + arr[i-2]
    }
  }
  return arr[n-1]
}

// export fibArrayReturnMemory
func fibArrayReturnMemory(n int32) *int32 {
  arr := make([]int32, n)
  for i := int32(0); i < n; i++ {
    switch {
    case i < 2:
      arr[i] = i
    default:
      arr[i] = arr[i-1] + arr[i-2]
    }
  }
  return &arr[0]
}
```

Use the TinyGo compiler tools to compile the Go source code into a WebAssembly bytecode application.

```bash
tinygo build -o fib.wasm -target wasi fib.go
```

The [Go SDK application](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemoryTinyGo/run.go) must call `malloc` from the WasmEdge VM to get a pointer to the array. It will then call the `fibArray()` function in TinyGo with the pointer. After the functions return, the Go app uses the WasmEdge SDK's `store` API to construct an array from the pointer in the call parameter (`fibArray()`) or in the return value (`fibArrayReturnMemory()`). The Go application will eventually call `free` to free the memory space.

```go
package main

import (
  ""fmt""
  ""os""
  ""unsafe""

  ""github.com/second-state/WasmEdge-go/wasmedge""
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  vm := wasmedge.NewVMWithConfig(conf)

  wasi := vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{"".:.""},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(""failed to load wasm"")
  }
  vm.Validate()
  vm.Instantiate()

  n := int32(10)

  p, err := vm.Execute(""malloc"", n)
  if err != nil {
    fmt.Println(""malloc failed:"", err)
  }

  fib, err := vm.Execute(""fibArray"", n, p[0])
  if err != nil {
    fmt.Println(""fibArray failed:"", err)
  } else {
    fmt.Println(""fibArray() returned:"", fib[0])
    fmt.Printf(""fibArray memory at: %p\n"", unsafe.Pointer((uintptr)(p[0].(int32))))
    mod := vm.GetActiveModule()
    mem := mod.FindMemory(""memory"")
    if mem != nil {
      // int32 occupies 4 bytes
      fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))
      if err == nil && fibArray != nil {
        fmt.Println(""fibArray:"", fibArray)
      }
    }
  }

  fibP, err := vm.Execute(""fibArrayReturnMemory"", n)
  if err != nil {
    fmt.Println(""fibArrayReturnMemory failed:"", err)
  } else {
    fmt.Printf(""fibArrayReturnMemory memory at: %p\n"", unsafe.Pointer((uintptr)(fibP[0].(int32))))
    mod := vm.GetActiveModule()
    mem := mod.FindMemory(""memory"")
    if mem != nil {
      // int32 occupies 4 bytes
      fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))
      if err == nil && fibArrayReturnMemory != nil {
        fmt.Println(""fibArrayReturnMemory:"", fibArrayReturnMemory)
      }
    }
  }

  _, err = vm.Execute(""free"", p...)
  if err != nil {
    fmt.Println(""free failed:"", err)
  }

  exitcode := wasi.WasiGetExitCode()
  if exitcode != 0 {
    fmt.Println(""Go: Running wasm failed, exit code:"", exitcode)
  }

  vm.Release()
  conf.Release()
}
```

To build the Go SDK example, run the following commands.

```bash
go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}
go build run.go
```

Now you can use the Go application to run the WebAssembly plug-in compiled from TinyGo.

```bash
$ ./run fib.wasm
fibArray() returned: 34
fibArray memory at: 0x14d3c
fibArray: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
fibArrayReturnMemory memory at: 0x14d4c
fibArrayReturnMemory: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
```
","**Summary**

This documentation provides a detailed guide on how to pass complex data types (strings, bytes) between Go and WebAssembly functions using the WasmEdge SDK. It covers three use cases: passing strings from Go to Rust functions, passing bytes from Go to TinyGo functions, and passing arrays from Go to Rust and TinyGo functions.

**Key Components**

1. **WasmEdge SDK**: The WasmEdge SDK is used to interact with WebAssembly modules and provide memory management for complex data types.
2. **WebAssembly Modules**: The guide covers the use of three different WebAssembly modules: one written in Rust, one written in TinyGo, and two examples that demonstrate passing arrays from Go to these modules.

**Functionality**

1. **Passing Strings**: The guide demonstrates how to pass strings from Go to a Rust function using the `greet` function.
2. **Passing Bytes**: The guide demonstrates how to pass bytes from Go to a TinyGo function using the `fibArrayReturnMemory` function.
3. **Passing Arrays**: The guide demonstrates how to pass arrays from Go to both a Rust and a TinyGo function using the `fibArray` and `fibArrayReturnMemory` functions, respectively.

**Potential Issues**

1. **Memory Management**: Memory management for complex data types can be challenging in WebAssembly. The WasmEdge SDK provides tools for managing memory, but it requires careful consideration of memory allocation and deallocation.
2. **Performance**: Passing complex data types between Go and WebAssembly modules can introduce performance overhead due to the need for memory management and serialization.

**Future Work**

1. **Optimizing Performance**: Further optimization of memory management and serialization techniques could improve performance when passing complex data types between Go and WebAssembly modules.
2. **Adding More Use Cases**: The guide currently covers three use cases, but there may be other scenarios where passing complex data types is necessary. Future work could include adding more examples to the guide."
docs/embed/c/externref.md,"---
sidebar_position: 4
---

# Customized External References

[External References](https://webassembly.github.io/spec/core/syntax/types.html#syntax-reftype) denotes an opaque and unforgettable reference to a host object. A new `externref` type can be passed into a WASM module or returned. The WASM module cannot reveal an `externref` value's bit pattern nor create a fake host reference by an integer value.

<!-- prettier-ignore -->
:::note
For all WASM example codes used in this chapter, users can convert `wat` to `wasm` through [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) live tool.
:::

## Tutorial

The following tutorial summarizes the `externref` example in WasmEdge.

### Prepare Your WASM File

The WASM file should contain importing host functions that take the `externref`. Take [this WAT](https://github.com/WasmEdge/WasmEdge/blob/master/test/externref/externrefTestData/funcs.wat) as an example:

```wasm
(module
  (type $t0 (func (param externref i32) (result i32)))
  (type $t1 (func (param externref i32 i32) (result i32)))
  (type $t2 (func (param externref externref i32 i32) (result i32)))
  (import ""extern_module"" ""functor_square"" (func $functor_square (type $t0)))
  (import ""extern_module"" ""class_add"" (func $class_add (type $t1)))
  (import ""extern_module"" ""func_mul"" (func $func_mul (type $t1)))
  (func $call_add (export ""call_add"") (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $class_add
      (local.get $p0)
      (local.get $p1)
      (local.get $p2)))
  (func $call_mul (export ""call_mul"") (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $func_mul
      (local.get $p0)
      (local.get $p1)
      (local.get $p2)))
  (func $call_square (export ""call_square"") (type $t0) (param $p0 externref) (param $p1 i32) (result i32)
    (call $functor_square
      (local.get $p0)
      (local.get $p1)))
  (func $call_add_square (export ""call_add_square"") (type $t2) (param $p0 externref) (param $p1 externref) (param $p2 i32) (param $p3 i32) (result i32)
    (call $functor_square
      (local.get $p1)
      (call $class_add
        (local.get $p0)
        (local.get $p2)
        (local.get $p3))))
  (memory $memory (export ""memory"") 1))
```

### Implement Host Module and Register into WasmEdge

The host module should be implemented and registered into WasmEdge before executing Wasm. Assume that the following code is saved as `main.c`:

```c
#include <wasmedge/wasmedge.h>

#include <stdio.h>

uint32_t SquareFunc(uint32_t A) { return A * A; }
uint32_t AddFunc(uint32_t A, uint32_t B) { return A + B; }
uint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }

// Host function to call `SquareFunc` by external reference
WasmEdge_Result ExternSquare(void *Data,
                             const WasmEdge_CallingFrameContext *CallFrameCxt,
                             const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32} -> {i32}
  uint32_t (*Func)(uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

// Host function to call `AddFunc` by external reference
WasmEdge_Result ExternAdd(void *Data,
                          const WasmEdge_CallingFrameContext *CallFrameCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32, i32} -> {i32}
  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

// Host function to call `ExternMul` by external reference
WasmEdge_Result ExternMul(void *Data,
                          const WasmEdge_CallingFrameContext *CallFrameCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32, i32} -> {i32}
  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

// Helper function to create the ""extern_module"" module instance.
WasmEdge_ModuleInstanceContext *CreateExternModule() {
  WasmEdge_String HostName;
  WasmEdge_FunctionTypeContext *HostFType = NULL;
  WasmEdge_FunctionInstanceContext *HostFunc = NULL;
  WasmEdge_ValType P[3], R[1];

  HostName = WasmEdge_StringCreateByCString(""extern_module"");
  WasmEdge_ModuleInstanceContext *HostMod =
      WasmEdge_ModuleInstanceCreate(HostName);
  WasmEdge_StringDelete(HostName);

  // Add host function ""functor_square"": {externref, i32} -> {i32}
  P[0] = WasmEdge_ValTypeGenExternRef();
  P[1] = WasmEdge_ValTypeGenI32();
  R[0] = WasmEdge_ValTypeGenI32();
  HostFType = WasmEdge_FunctionTypeCreate(P, 2, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternSquare, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(""functor_square"");
  WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  // Add host function ""class_add"": {externref, i32, i32} -> {i32}
  P[2] = WasmEdge_ValTypeGenI32();
  HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternAdd, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(""class_add"");
  WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  // Add host function ""func_mul"": {externref, i32, i32} -> {i32}
  HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternMul, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(""func_mul"");
  WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  return HostMod;
}

int main() {
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
  WasmEdge_ModuleInstanceContext *HostMod = CreateExternModule();
  WasmEdge_Value P[3], R[1];
  WasmEdge_String FuncName;
  WasmEdge_Result Res;

  Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, HostMod);
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Host module instance registration failed\n"");
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""funcs.wasm"");
  if (!WasmEdge_ResultOK(Res)) {
    printf(""WASM file loading failed\n"");
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMValidate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(""WASM validation failed\n"");
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMInstantiate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(""WASM instantiation failed\n"");
    return EXIT_FAILURE;
  }

  // Test 1: call add -- 1234 + 5678
  P[0] = WasmEdge_ValueGenExternRef(AddFunc);
  P[1] = WasmEdge_ValueGenI32(1234);
  P[2] = WasmEdge_ValueGenI32(5678);
  FuncName = WasmEdge_StringCreateByCString(""call_add"");
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
  WasmEdge_StringDelete(FuncName);
  if (WasmEdge_ResultOK(Res)) {
    printf(""Test 1 -- `call_add` -- 1234 + 5678 = %d\n"",
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(""Test 1 -- `call_add` -- 1234 + 5678 -- failed\n"");
    return EXIT_FAILURE;
  }

  // Test 2: call mul -- 789 * 4321
  P[0] = WasmEdge_ValueGenExternRef(MulFunc);
  P[1] = WasmEdge_ValueGenI32(789);
  P[2] = WasmEdge_ValueGenI32(4321);
  FuncName = WasmEdge_StringCreateByCString(""call_mul"");
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
  WasmEdge_StringDelete(FuncName);
  if (WasmEdge_ResultOK(Res)) {
    printf(""Test 2 -- `call_mul` -- 789 * 4321 = %d\n"",
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(""Test 2 -- `call_mul` -- 789 * 4321 -- failed\n"");
    return EXIT_FAILURE;
  }

  // Test 3: call square -- 8256^2
  P[0] = WasmEdge_ValueGenExternRef(SquareFunc);
  P[1] = WasmEdge_ValueGenI32(8256);
  FuncName = WasmEdge_StringCreateByCString(""call_square"");
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(""Test 3 -- `call_mul` -- 8256 ^ 2 = %d\n"",
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(""Test 3 -- `call_mul` -- 8256 ^ 2 -- failed\n"");
    return EXIT_FAILURE;
  }

  return EXIT_SUCCESS;
}
```

### Setup the Environment And Compile

1. Install the WasmEdge shared library.

   For details, please refer to the [Installation](../../start/install.md#install).

2. Prepare the WASM and the `main.c` source files as above.

3. Compile

   ```bash
   gcc main.c -lwasmedge
   # Or you can use g++ for the C++ case, or use the clang.
   ```

4. Run the Test

   ```bash
   $ ./a.out
   Test 1 -- `call_add` -- 1234 + 5678 = 6912
   Test 2 -- `call_mul` -- 789 * 4321 = 3409269
   Test 3 -- `call_mul` -- 8256 ^ 2 = 68161536
   ```

## WASM module with External References

Take the following `wat` for example:

```wasm
(module
  (type $t0 (func (param externref i32) (result i32)))
  ;; Import a host function which type is {externref i32} -> {i32}
  (import ""extern_module"" ""functor_square"" (func $functor_square (type $t0)))
  ;; WASM function which type is {externref i32} -> {i32} and exported as ""call_square""
  (func $call_square (export ""call_square"") (type $t0) (param $p0 externref) (param $p1 i32) (result i32)
    (call $functor_square (local.get $p0) (local.get $p1))
  )
  (memory $memory (export ""memory"") 1))
```

The WASM function ""`call_square`"" takes an `externref` parameter and calls the imported host function `functor_square` with that `externref`. Therefore, the `functor_square` host function can get the object reference when users call ""`call_square`"" WASM function and pass the object's reference.

## WasmEdge ExternRef Example

The following examples are how to use `externref` in WASM with WasmEdge C API.

### WASM Code

The WASM code must pass the `externref` to host functions that want to access it. Take the following `wat` for example, which is a part of [the test WASM file](https://github.com/WasmEdge/WasmEdge/blob/master/test/externref/externrefTestData/funcs.wat):

```wasm
(module
  (type $t0 (func (param externref i32 i32) (result i32)))
  (import ""extern_module"" ""func_mul"" (func $func_mul (type $t0)))
  (func $call_mul (export ""call_mul"") (type $t0) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $func_mul (local.get $p0) (local.get $p1) (local.get $p2))
  )
  (memory $memory (export ""memory"") 1))
```

The host function ""`extern_module::func_mul`"" takes `externref` as a function pointer to multiply parameters 1 and 2 and then returns the result. The exported WASM function ""`call_mul`"" calls ""`func_mul`"" and passes the `externref` and 2 numbers as arguments.

### Host Functions

To instantiate the above example Wasm, the host functions must be registered into WasmEdge. See [Host Functions](reference/latest.md#host-functions) for more details. The host functions which take `externref`s must know the original objects' types. We take the function pointer case, for example.

```c
/* Function to pass as function pointer. */
uint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }

/* Host function to call the function by external reference as a function pointer */
WasmEdge_Result ExternMul(void *, const WasmEdge_CallingFrameContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {externref, i32, i32} -> {i32} */
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t (*Obj)(uint32_t, uint32_t) = Ptr;
  /*
   * For C++, the `reinterpret_cast` is needed:
   * uint32_t (*Obj)(uint32_t, uint32_t) =
   *   *reinterpret_cast<uint32_t (*)(uint32_t, uint32_t)>(Ptr);
   */
  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
```

""`MulFunc`"" is a function that will be passed into WASM as `externref`. In the ""`func_mul`"" host function, users can use ""`WasmEdge_ValueGetExternRef`"" API to get the pointer from the `WasmEdge_Value` which contains a `externref`.

Developers can add the host functions with names into a module instance.

```c
/* Create a module instance. */
WasmEdge_String HostName = WasmEdge_StringCreateByCString(""extern_module"");
WasmEdge_ModuleInstanceContext *HostMod =
    WasmEdge_ModuleInstanceCreate(HostName);
WasmEdge_StringDelete(HostName);

/* Create a function instance and add to the module instance. */
WasmEdge_ValType P[3], R[1];
P[0] = WasmEdge_ValTypeGenExternRef();
P[1] = WasmEdge_ValTypeGenI32();
P[2] = WasmEdge_ValTypeGenI32();
R[0] = WasmEdge_ValTypeGenI32();
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(P, 3, R, 1);
WasmEdge_FunctionInstanceContext *HostFunc =
    WasmEdge_FunctionInstanceCreate(HostFType, ExternFuncMul, NULL, 0);
WasmEdge_FunctionTypeDelete(HostFType);
HostName = WasmEdge_StringCreateByCString(""func_mul"");
WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);
WasmEdge_StringDelete(HostName);

...
```

### Execution

Take [the test WASM file in text format](https://github.com/WasmEdge/WasmEdge/raw/master/test/externref/externrefTestData/funcs.wat) for example. Assume the `funcs.wasm` is copied into the current directory. The following is an example of executing WASM with `externref` through the WasmEdge C API.

```c
/* Create the VM context. */
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
/* Create the module instance context that contains the host functions. */
WasmEdge_ModuleInstanceContext *HostMod = /* Ignored ... */;
/* Assume the host functions are added to the module instance above. */
WasmEdge_Value P[3], R[1];
WasmEdge_String FuncName;
WasmEdge_Result Res;

/* Register the module instance into VM. */
Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, HostMod);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Import object registration failed\n"");
  return EXIT_FAILURE;
}
/* Load WASM from the file. */
Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""funcs.wasm"");
if (!WasmEdge_ResultOK(Res)) {
  printf(""WASM file loading failed\n"");
  return EXIT_FAILURE;
}
/* Validate WASM. */
Res = WasmEdge_VMValidate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""WASM validation failed\n"");
  return EXIT_FAILURE;
}
/* Instantiate the WASM module. */
Res = WasmEdge_VMInstantiate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""WASM instantiation failed\n"");
  return EXIT_FAILURE;
}

/* Run a WASM function. */
P[0] = WasmEdge_ValueGenExternRef(AddFunc);
P[1] = WasmEdge_ValueGenI32(1234);
P[2] = WasmEdge_ValueGenI32(5678);
/* Run the `call_add` function. */
FuncName = WasmEdge_StringCreateByCString(""call_add"");
Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  printf(""Run -- `call_add` -- 1234 + 5678 = %d\n"",
          WasmEdge_ValueGetI32(R[0]));
} else {
  printf(""Run -- `call_add` -- 1234 + 5678 -- failed\n"");
  return EXIT_FAILURE;
}
```

## Passing Objects

The above example is passing a function reference as `externref`. The following examples are about how to pass an object reference into WASM as `externref` in C++.

### Passing a Class

The object instance is needed to pass a class as `externref`.

```cpp
class AddClass {
public:
  uint32_t add(uint32_t A, uint32_t B) const { return A + B; }
};

AddClass AC;
```

Then users can pass the object into WasmEdge by using `WasmEdge_ValueGenExternRef()` API.

```cpp
WasmEdge_Value P[3], R[1];
P[0] = WasmEdge_ValueGenExternRef(&AC);
P[1] = WasmEdge_ValueGenI32(1234);
P[2] = WasmEdge_ValueGenI32(5678);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""call_add"");
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  std::cout << ""Result : "" << WasmEdge_ValueGetI32(R[0]) std::endl;
  // Will print `6912`.
} else {
  return EXIT_FAILURE;
}
```

In the host function which would access the object by reference, users can use the `WasmEdge_ValueGetExternRef()` API to retrieve the reference to the object.

```cpp
// Modify the `ExternAdd` in the above tutorial.
WasmEdge_Result ExternAdd(void *, const WasmEdge_CallingFrameContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32, i32} -> {i32}
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  AddClass &Obj = *reinterpret_cast<AddClass *>(Ptr);
  uint32_t C =
      Obj.add(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
```

### Passing an Object As Functor

Like passing a class instance, the functor object instance is needed.

```cpp
struct SquareStruct {
  uint32_t operator()(uint32_t Val) const { return Val * Val; }
};

SquareStruct SS;
```

Then users can pass the object into WasmEdge using the `WasmEdge_ValueGenExternRef()` API.

```cpp
WasmEdge_Value P[2], R[1];
P[0] = WasmEdge_ValueGenExternRef(&SS);
P[1] = WasmEdge_ValueGenI32(1024);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""call_square"");
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  std::cout << ""Result : "" << WasmEdge_ValueGetI32(R[0]) std::endl;
  // Will print `1048576`.
} else {
  return EXIT_FAILURE;
}
```

In the host function, which would access the object by reference, users can use the `WasmEdge_ValueGetExternRef` API to retrieve the reference to the object, which is a functor.

```cpp
// Modify the `ExternSquare` in the above tutorial.
WasmEdge_Result ExternSquare(void *, const WasmEdge_CallingFrameContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32, i32} -> {i32}
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  SquareStruct &Obj = *reinterpret_cast<SquareStruct *>(Ptr);
  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
```

### Passing STL Objects

The [example WASM in text format](https://github.com/WasmEdge/WasmEdge/raw/master/test/externref/externrefTestData/stl.wat) provides functions to interact with host functions which can access C++ STL objects. Assume that the WASM file `stl.wasm` is copied into the current directory.

Take the `std::ostream` and `std::string` objects for example. Assume that there's a host function that accesses to a `std::ostream` and a `std::string` through `externref`s:

```cpp
// Host function to output std::string through std::ostream
WasmEdge_Result ExternSTLOStreamStr(void *,
                                    const WasmEdge_CallingFrameContext *,
                                    const WasmEdge_Value *In,
                                    WasmEdge_Value *) {
  // Function type: {externref, externref} -> {}
  void *Ptr0 = WasmEdge_ValueGetExternRef(In[0]);
  void *Ptr1 = WasmEdge_ValueGetExternRef(In[1]);
  std::ostream &RefOS = *reinterpret_cast<std::ostream *>(Ptr0);
  std::string &RefStr = *reinterpret_cast<std::string *>(Ptr1);
  RefOS << RefStr;
  return WasmEdge_Result_Success;
}
```

Assume that the above host function is added to the module instance `HostMod`, and the `HostMod` is registered into a VM context `VMCxt`. Then users can instantiate the WASM module:

```cpp
WasmEdge_Result Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""stl.wasm"");
if (!WasmEdge_ResultOK(Res)) {
  printf(""WASM file loading failed\n"");
  return EXIT_FAILURE;
}
Res = WasmEdge_VMValidate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""WASM validation failed\n"");
  return EXIT_FAILURE;
}
Res = WasmEdge_VMInstantiate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""WASM instantiation failed\n"");
  return EXIT_FAILURE;
}
```

Last, pass the `std::cout` and a `std::string` object by external references.

```cpp
std::string PrintStr(""Hello world!"");
WasmEdge_Value P[2], R[1];
P[0] = WasmEdge_ValueGenExternRef(&std::cout);
P[1] = WasmEdge_ValueGenExternRef(&PrintStr);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""call_ostream_str"");
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
// Will print ""Hello world!"" to stdout.
WasmEdge_StringDelete(FuncName);
if (!WasmEdge_ResultOK(Res)) {
  return EXIT_FAILURE;
}
```

For other C++ STL objects cases, such as `std::vector<T>`, `std::map<T, U>`, or `std::set<T>`, the object can be accessed correctly in host functions if the type in `reinterpret_cast` is correct.
","This is a long and detailed analysis of the provided code. It appears to be an explanation of how to use external references in WebAssembly (WASM) with the WasmEdge C API.

Here are some key points from the summary:

* External references allow host functions to access WASM objects.
* Host functions can be passed as function pointers or object instances.
* The `externref` type is used to represent a reference to an external object in WASM.
* Host functions that want to access external objects must be registered into the WasmEdge VM context.
* External references can be passed into host functions using the `WasmEdge_ValueGenExternRef()` API.

The analysis provides several examples of how to use external references, including:

* Passing a class instance as an external reference
* Passing a functor object as an external reference
* Accessing STL objects (such as `std::ostream` and `std::string`) using external references

Overall, the summary provides a clear explanation of how to use external references in WASM with WasmEdge C API."
i18n/zh/docusaurus-plugin-content-docs/current/embed/c/externref.md,"---
sidebar_position: 4
---

# Customized External References

[External References](https://webassembly.github.io/spec/core/syntax/types.html#syntax-reftype) denotes an opaque and unforgettable reference to a host object. A new `externref` type can be passed into a WASM module or returned. The WASM module cannot reveal an `externref` value's bit pattern nor create a fake host reference by an integer value.

<!-- prettier-ignore -->
:::note
For all WASM example codes used in this chapter, users can convert `wat` to `wasm` through [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) live tool.
:::

## Tutorial

The following tutorial summarizes the `externref` example in WasmEdge.

### Prepare Your WASM File

The WASM file should contain importing host functions that take the `externref`. Take [this WAT](https://github.com/WasmEdge/WasmEdge/blob/master/test/externref/externrefTestData/funcs.wat) as an example:

```wasm
(module
  (type $t0 (func (param externref i32) (result i32)))
  (type $t1 (func (param externref i32 i32) (result i32)))
  (type $t2 (func (param externref externref i32 i32) (result i32)))
  (import ""extern_module"" ""functor_square"" (func $functor_square (type $t0)))
  (import ""extern_module"" ""class_add"" (func $class_add (type $t1)))
  (import ""extern_module"" ""func_mul"" (func $func_mul (type $t1)))
  (func $call_add (export ""call_add"") (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $class_add
      (local.get $p0)
      (local.get $p1)
      (local.get $p2)))
  (func $call_mul (export ""call_mul"") (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $func_mul
      (local.get $p0)
      (local.get $p1)
      (local.get $p2)))
  (func $call_square (export ""call_square"") (type $t0) (param $p0 externref) (param $p1 i32) (result i32)
    (call $functor_square
      (local.get $p0)
      (local.get $p1)))
  (func $call_add_square (export ""call_add_square"") (type $t2) (param $p0 externref) (param $p1 externref) (param $p2 i32) (param $p3 i32) (result i32)
    (call $functor_square
      (local.get $p1)
      (call $class_add
        (local.get $p0)
        (local.get $p2)
        (local.get $p3))))
  (memory $memory (export ""memory"") 1))
```

### Implement Host Module and Register into WasmEdge

The host module should be implemented and registered into WasmEdge before executing Wasm. Assume that the following code is saved as `main.c`:

```c
#include <wasmedge/wasmedge.h>

#include <stdio.h>

uint32_t SquareFunc(uint32_t A) { return A * A; }
uint32_t AddFunc(uint32_t A, uint32_t B) { return A + B; }
uint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }

// Host function to call `SquareFunc` by external reference
WasmEdge_Result ExternSquare(void *Data,
                             const WasmEdge_CallingFrameContext *CallFrameCxt,
                             const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32} -> {i32}
  uint32_t (*Func)(uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

// Host function to call `AddFunc` by external reference
WasmEdge_Result ExternAdd(void *Data,
                          const WasmEdge_CallingFrameContext *CallFrameCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32, i32} -> {i32}
  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

// Host function to call `ExternMul` by external reference
WasmEdge_Result ExternMul(void *Data,
                          const WasmEdge_CallingFrameContext *CallFrameCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32, i32} -> {i32}
  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

// Helper function to create the ""extern_module"" module instance.
WasmEdge_ModuleInstanceContext *CreateExternModule() {
  WasmEdge_String HostName;
  WasmEdge_FunctionTypeContext *HostFType = NULL;
  WasmEdge_FunctionInstanceContext *HostFunc = NULL;
  WasmEdge_ValType P[3], R[1];

  HostName = WasmEdge_StringCreateByCString(""extern_module"");
  WasmEdge_ModuleInstanceContext *HostMod =
      WasmEdge_ModuleInstanceCreate(HostName);
  WasmEdge_StringDelete(HostName);

  // Add host function ""functor_square"": {externref, i32} -> {i32}
  P[0] = WasmEdge_ValTypeGenExternRef();
  P[1] = WasmEdge_ValTypeGenI32();
  R[0] = WasmEdge_ValTypeGenI32();
  HostFType = WasmEdge_FunctionTypeCreate(P, 2, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternSquare, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(""functor_square"");
  WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  // Add host function ""class_add"": {externref, i32, i32} -> {i32}
  P[2] = WasmEdge_ValTypeGenI32();
  HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternAdd, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(""class_add"");
  WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  // Add host function ""func_mul"": {externref, i32, i32} -> {i32}
  HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternMul, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(""func_mul"");
  WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  return HostMod;
}

int main() {
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
  WasmEdge_ModuleInstanceContext *HostMod = CreateExternModule();
  WasmEdge_Value P[3], R[1];
  WasmEdge_String FuncName;
  WasmEdge_Result Res;

  Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, HostMod);
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Host module instance registration failed\n"");
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""funcs.wasm"");
  if (!WasmEdge_ResultOK(Res)) {
    printf(""WASM file loading failed\n"");
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMValidate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(""WASM validation failed\n"");
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMInstantiate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(""WASM instantiation failed\n"");
    return EXIT_FAILURE;
  }

  // Test 1: call add -- 1234 + 5678
  P[0] = WasmEdge_ValueGenExternRef(AddFunc);
  P[1] = WasmEdge_ValueGenI32(1234);
  P[2] = WasmEdge_ValueGenI32(5678);
  FuncName = WasmEdge_StringCreateByCString(""call_add"");
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
  WasmEdge_StringDelete(FuncName);
  if (WasmEdge_ResultOK(Res)) {
    printf(""Test 1 -- `call_add` -- 1234 + 5678 = %d\n"",
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(""Test 1 -- `call_add` -- 1234 + 5678 -- failed\n"");
    return EXIT_FAILURE;
  }

  // Test 2: call mul -- 789 * 4321
  P[0] = WasmEdge_ValueGenExternRef(MulFunc);
  P[1] = WasmEdge_ValueGenI32(789);
  P[2] = WasmEdge_ValueGenI32(4321);
  FuncName = WasmEdge_StringCreateByCString(""call_mul"");
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
  WasmEdge_StringDelete(FuncName);
  if (WasmEdge_ResultOK(Res)) {
    printf(""Test 2 -- `call_mul` -- 789 * 4321 = %d\n"",
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(""Test 2 -- `call_mul` -- 789 * 4321 -- failed\n"");
    return EXIT_FAILURE;
  }

  // Test 3: call square -- 8256^2
  P[0] = WasmEdge_ValueGenExternRef(SquareFunc);
  P[1] = WasmEdge_ValueGenI32(8256);
  FuncName = WasmEdge_StringCreateByCString(""call_square"");
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(""Test 3 -- `call_mul` -- 8256 ^ 2 = %d\n"",
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(""Test 3 -- `call_mul` -- 8256 ^ 2 -- failed\n"");
    return EXIT_FAILURE;
  }

  return EXIT_SUCCESS;
}
```

### Setup the Environment And Compile

1. Install the WasmEdge shared library.

   For details, please refer to the [Installation](../../start/install.md#install).

2. Prepare the WASM and the `main.c` source files as above.

3. Compile

   ```bash
   gcc main.c -lwasmedge
   # Or you can use g++ for the C++ case, or use the clang.
   ```

4. Run the Test

   ```bash
   $ ./a.out
   Test 1 -- `call_add` -- 1234 + 5678 = 6912
   Test 2 -- `call_mul` -- 789 * 4321 = 3409269
   Test 3 -- `call_mul` -- 8256 ^ 2 = 68161536
   ```

## WASM module with External References

Take the following `wat` for example:

```wasm
(module
  (type $t0 (func (param externref i32) (result i32)))
  ;; Import a host function which type is {externref i32} -> {i32}
  (import ""extern_module"" ""functor_square"" (func $functor_square (type $t0)))
  ;; WASM function which type is {externref i32} -> {i32} and exported as ""call_square""
  (func $call_square (export ""call_square"") (type $t0) (param $p0 externref) (param $p1 i32) (result i32)
    (call $functor_square (local.get $p0) (local.get $p1))
  )
  (memory $memory (export ""memory"") 1))
```

The WASM function ""`call_square`"" takes an `externref` parameter and calls the imported host function `functor_square` with that `externref`. Therefore, the `functor_square` host function can get the object reference when users call ""`call_square`"" WASM function and pass the object's reference.

## WasmEdge ExternRef Example

The following examples are how to use `externref` in WASM with WasmEdge C API.

### WASM Code

The WASM code must pass the `externref` to host functions that want to access it. Take the following `wat` for example, which is a part of [the test WASM file](https://github.com/WasmEdge/WasmEdge/blob/master/test/externref/externrefTestData/funcs.wat):

```wasm
(module
  (type $t0 (func (param externref i32 i32) (result i32)))
  (import ""extern_module"" ""func_mul"" (func $func_mul (type $t0)))
  (func $call_mul (export ""call_mul"") (type $t0) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $func_mul (local.get $p0) (local.get $p1) (local.get $p2))
  )
  (memory $memory (export ""memory"") 1))
```

The host function ""`extern_module::func_mul`"" takes `externref` as a function pointer to multiply parameters 1 and 2 and then returns the result. The exported WASM function ""`call_mul`"" calls ""`func_mul`"" and passes the `externref` and 2 numbers as arguments.

### Host Functions

To instantiate the above example Wasm, the host functions must be registered into WasmEdge. See [Host Functions](reference/latest.md#host-functions) for more details. The host functions which take `externref`s must know the original objects' types. We take the function pointer case, for example.

```c
/* Function to pass as function pointer. */
uint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }

/* Host function to call the function by external reference as a function pointer */
WasmEdge_Result ExternMul(void *, const WasmEdge_CallingFrameContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {externref, i32, i32} -> {i32} */
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t (*Obj)(uint32_t, uint32_t) = Ptr;
  /*
   * For C++, the `reinterpret_cast` is needed:
   * uint32_t (*Obj)(uint32_t, uint32_t) =
   *   *reinterpret_cast<uint32_t (*)(uint32_t, uint32_t)>(Ptr);
   */
  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
```

""`MulFunc`"" is a function that will be passed into WASM as `externref`. In the ""`func_mul`"" host function, users can use ""`WasmEdge_ValueGetExternRef`"" API to get the pointer from the `WasmEdge_Value` which contains a `externref`.

Developers can add the host functions with names into a module instance.

```c
/* Create a module instance. */
WasmEdge_String HostName = WasmEdge_StringCreateByCString(""extern_module"");
WasmEdge_ModuleInstanceContext *HostMod =
    WasmEdge_ModuleInstanceCreate(HostName);
WasmEdge_StringDelete(HostName);

/* Create a function instance and add to the module instance. */
WasmEdge_ValType P[3], R[1];
P[0] = WasmEdge_ValTypeGenExternRef();
P[1] = WasmEdge_ValTypeGenI32();
P[2] = WasmEdge_ValTypeGenI32();
R[0] = WasmEdge_ValTypeGenI32();
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(P, 3, R, 1);
WasmEdge_FunctionInstanceContext *HostFunc =
    WasmEdge_FunctionInstanceCreate(HostFType, ExternFuncMul, NULL, 0);
WasmEdge_FunctionTypeDelete(HostFType);
HostName = WasmEdge_StringCreateByCString(""func_mul"");
WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);
WasmEdge_StringDelete(HostName);

...
```

### Execution

Take [the test WASM file in text format](https://github.com/WasmEdge/WasmEdge/raw/master/test/externref/externrefTestData/funcs.wat) for example. Assume the `funcs.wasm` is copied into the current directory. The following is an example of executing WASM with `externref` through the WasmEdge C API.

```c
/* Create the VM context. */
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
/* Create the module instance context that contains the host functions. */
WasmEdge_ModuleInstanceContext *HostMod = /* Ignored ... */;
/* Assume the host functions are added to the module instance above. */
WasmEdge_Value P[3], R[1];
WasmEdge_String FuncName;
WasmEdge_Result Res;

/* Register the module instance into VM. */
Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, HostMod);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Import object registration failed\n"");
  return EXIT_FAILURE;
}
/* Load WASM from the file. */
Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""funcs.wasm"");
if (!WasmEdge_ResultOK(Res)) {
  printf(""WASM file loading failed\n"");
  return EXIT_FAILURE;
}
/* Validate WASM. */
Res = WasmEdge_VMValidate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""WASM validation failed\n"");
  return EXIT_FAILURE;
}
/* Instantiate the WASM module. */
Res = WasmEdge_VMInstantiate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""WASM instantiation failed\n"");
  return EXIT_FAILURE;
}

/* Run a WASM function. */
P[0] = WasmEdge_ValueGenExternRef(AddFunc);
P[1] = WasmEdge_ValueGenI32(1234);
P[2] = WasmEdge_ValueGenI32(5678);
/* Run the `call_add` function. */
FuncName = WasmEdge_StringCreateByCString(""call_add"");
Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  printf(""Run -- `call_add` -- 1234 + 5678 = %d\n"",
          WasmEdge_ValueGetI32(R[0]));
} else {
  printf(""Run -- `call_add` -- 1234 + 5678 -- failed\n"");
  return EXIT_FAILURE;
}
```

## Passing Objects

The above example is passing a function reference as `externref`. The following examples are about how to pass an object reference into WASM as `externref` in C++.

### Passing a Class

The object instance is needed to pass a class as `externref`.

```cpp
class AddClass {
public:
  uint32_t add(uint32_t A, uint32_t B) const { return A + B; }
};

AddClass AC;
```

Then users can pass the object into WasmEdge by using `WasmEdge_ValueGenExternRef()` API.

```cpp
WasmEdge_Value P[3], R[1];
P[0] = WasmEdge_ValueGenExternRef(&AC);
P[1] = WasmEdge_ValueGenI32(1234);
P[2] = WasmEdge_ValueGenI32(5678);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""call_add"");
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  std::cout << ""Result : "" << WasmEdge_ValueGetI32(R[0]) std::endl;
  // Will print `6912`.
} else {
  return EXIT_FAILURE;
}
```

In the host function which would access the object by reference, users can use the `WasmEdge_ValueGetExternRef()` API to retrieve the reference to the object.

```cpp
// Modify the `ExternAdd` in the above tutorial.
WasmEdge_Result ExternAdd(void *, const WasmEdge_CallingFrameContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32, i32} -> {i32}
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  AddClass &Obj = *reinterpret_cast<AddClass *>(Ptr);
  uint32_t C =
      Obj.add(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
```

### Passing an Object As Functor

Like passing a class instance, the functor object instance is needed.

```cpp
struct SquareStruct {
  uint32_t operator()(uint32_t Val) const { return Val * Val; }
};

SquareStruct SS;
```

Then users can pass the object into WasmEdge using the `WasmEdge_ValueGenExternRef()` API.

```cpp
WasmEdge_Value P[2], R[1];
P[0] = WasmEdge_ValueGenExternRef(&SS);
P[1] = WasmEdge_ValueGenI32(1024);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""call_square"");
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  std::cout << ""Result : "" << WasmEdge_ValueGetI32(R[0]) std::endl;
  // Will print `1048576`.
} else {
  return EXIT_FAILURE;
}
```

In the host function, which would access the object by reference, users can use the `WasmEdge_ValueGetExternRef` API to retrieve the reference to the object, which is a functor.

```cpp
// Modify the `ExternSquare` in the above tutorial.
WasmEdge_Result ExternSquare(void *, const WasmEdge_CallingFrameContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32, i32} -> {i32}
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  SquareStruct &Obj = *reinterpret_cast<SquareStruct *>(Ptr);
  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
```

### Passing STL Objects

The [example WASM in text format](https://github.com/WasmEdge/WasmEdge/raw/master/test/externref/externrefTestData/stl.wat) provides functions to interact with host functions which can access C++ STL objects. Assume that the WASM file `stl.wasm` is copied into the current directory.

Take the `std::ostream` and `std::string` objects for example. Assume that there's a host function that accesses to a `std::ostream` and a `std::string` through `externref`s:

```cpp
// Host function to output std::string through std::ostream
WasmEdge_Result ExternSTLOStreamStr(void *,
                                    const WasmEdge_CallingFrameContext *,
                                    const WasmEdge_Value *In,
                                    WasmEdge_Value *) {
  // Function type: {externref, externref} -> {}
  void *Ptr0 = WasmEdge_ValueGetExternRef(In[0]);
  void *Ptr1 = WasmEdge_ValueGetExternRef(In[1]);
  std::ostream &RefOS = *reinterpret_cast<std::ostream *>(Ptr0);
  std::string &RefStr = *reinterpret_cast<std::string *>(Ptr1);
  RefOS << RefStr;
  return WasmEdge_Result_Success;
}
```

Assume that the above host function is added to the module instance `HostMod`, and the `HostMod` is registered into a VM context `VMCxt`. Then users can instantiate the WASM module:

```cpp
WasmEdge_Result Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""stl.wasm"");
if (!WasmEdge_ResultOK(Res)) {
  printf(""WASM file loading failed\n"");
  return EXIT_FAILURE;
}
Res = WasmEdge_VMValidate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""WASM validation failed\n"");
  return EXIT_FAILURE;
}
Res = WasmEdge_VMInstantiate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""WASM instantiation failed\n"");
  return EXIT_FAILURE;
}
```

Last, pass the `std::cout` and a `std::string` object by external references.

```cpp
std::string PrintStr(""Hello world!"");
WasmEdge_Value P[2], R[1];
P[0] = WasmEdge_ValueGenExternRef(&std::cout);
P[1] = WasmEdge_ValueGenExternRef(&PrintStr);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""call_ostream_str"");
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
// Will print ""Hello world!"" to stdout.
WasmEdge_StringDelete(FuncName);
if (!WasmEdge_ResultOK(Res)) {
  return EXIT_FAILURE;
}
```

For other C++ STL objects cases, such as `std::vector<T>`, `std::map<T, U>`, or `std::set<T>`, the object can be accessed correctly in host functions if the type in `reinterpret_cast` is correct.
","The code provided is a C++ implementation of a WebAssembly (WASM) module using the WasmEdge API. The code is designed to demonstrate how to pass C++ objects as external references to WASM functions.

Here's a concise summary of the code:

1.  **Main Function**: The main function creates a VM context, loads and validates a WASM file, instantiates it, and executes a WASM function.
2.  **Passing Objects as External References**: The code shows how to pass C++ objects such as `AddClass`, `SquareStruct`, and STL objects (`std::ostream` and `std::string`) as external references to WASM functions using the `WasmEdge_ValueGenExternRef()` API.

The key components of this code are:

1.  **Host Function**: A host function is defined that takes an object reference, extracts the object pointer from it using `reinterpret_cast`, and then accesses the object's methods or data.
2.  **Passing Object References to WASM Functions**: The object references are generated using the `WasmEdge_ValueGenExternRef()` API and passed as arguments to the WASM functions.

Potential issues with this code include:

1.  **Memory Management**: The code relies on manual memory management for the C++ objects being passed as external references. If not properly managed, this could lead to memory leaks or crashes.
2.  **Object Pointer Conversion**: The `reinterpret_cast` operation is used to convert the object pointer from the WASM value type to a C++ object pointer. This assumes that the correct type is used, and any incorrect cast would result in undefined behavior.

To improve this code:

1.  **Use Smart Pointers**: Instead of manual memory management, use smart pointers (e.g., `std::unique_ptr`) to ensure proper memory release for the objects being passed as external references.
2.  **Type Safety**: Consider using type-safe conversion mechanisms instead of `reinterpret_cast` to avoid incorrect casts and potential undefined behavior.

By addressing these potential issues, the code can be improved in terms of reliability, maintainability, and robustness."
docs/embed/c/multiple_modules.md,"---
sidebar_position: 5
---

# Multiple WASM Module Example

For those WASM modules that export their functions, the other WASM modules can import them as a library.

This will cause a situation that links multiple modules for the dependencies in execution.

This chapter will introduce examples of linking and executing multiple WASM modules in WasmEdge.

## Example WASM file

### The Library WASM

Assume that there's a WASM that exports it's function:

```wasm
(module
  (func (export ""add"") (param i32 i32) (result i32)
    ;; Function to add 2 numbers and exported as ""add"".
    (i32.add (local.get 0) (local.get 1))
  )
  (func (export ""mul"") (param i32 i32) (result i32)
    ;; Function to mul 2 number and exported as ""mul"".
    (i32.mul (local.get 0) (local.get 1))
  )
)
```

Users can convert `wat` to `wasm` through [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) live tool. Assume that this `wat` is converted into the WASM binary format and saved as `lib.wasm`.

### The Entering WASM

Assume that there's a WASM which imports some functions from the `lib.wasm`, and this WASM exports the functions which can be invoked:

```wasm
(module
  (type $type0 (func (param i32 i32)(result i32)))
  ;; Import the ""add"" function which calculate ""a + b"".
  (import ""math"" ""add"" (func $math-add (type $type0)))
  ;; Import the ""mul"" function which calculate ""a * b"".
  (import ""math"" ""mul"" (func $math-mul (type $type0)))
  (func (export ""add_and_square"") (param i32 i32) (result i32)
    ;; Function to add 2 numbers and square it ((a + b)^2).
    ;; Exported as ""add_and_square"".
    (call $math-mul
      (call $math-add (local.get 0) (local.get 1))
      (call $math-add (local.get 0) (local.get 1))
    )
  )
  (func (export ""sum_of_squares"") (param i32 i32) (result i32)
    ;; Function to calculate the sum of squares (a^2 + b^2).
    ;; Exported as ""sum_of_squares"".
    (call $math-add
      (call $math-mul (local.get 0) (local.get 0))
      (call $math-mul (local.get 1) (local.get 1))
    )
  )
)
```

Users can convert `wat` to `wasm` through [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) live tool. Assume that this `wat` is converted into the WASM binary format and saved as `test.wasm`.

### Prerequisites

For executing these examples, developers should [install WasmEdge](../../start/install.md#install).

To improve the performance of executing WASM, developers can also use the [AOT compiler](../../start/build-and-run/aot.md) to compile the above WASM files.

## Linking WASM Modules With the VM Context

With the `WasmEdge_VMContext`, developers can instantiate and execute WASM quickly. There are at least four ways to link these multiple WASM modules with the VM context. For the example codes below, assume that the C code is saved as `example.c`.

1. Register and instantiate the `lib.wasm` from the file directly.

   ```c
   #include <stdio.h>
   #include <wasmedge/wasmedge.h>

   int main() {
     /* The result. */
     WasmEdge_Result Res;

     /* The params and returns. */
     WasmEdge_Value Params[2], Returns[1];

     /* Create the VM context. */
     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

     /* Register the `lib.wasm` from file with the module name ""math"". */
     WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(""math"");
     Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModuleName, ""lib.wasm"");
     WasmEdge_StringDelete(ModuleName);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Register lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Instantiate the `test.wasm`. */
     /*
      * Developers can use the APIs such as `WasmEdge_VMRunWasmFromFile` to
      * instantiate and execute quickly.
      */
     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""test.wasm"");
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Load test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_VMValidate(VMCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Validate test.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_VMInstantiate(VMCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Instantiate test.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Invoke the functions. */
     /* Invoke the ""add_and_square"" to calculate (123 + 456)^2 */
     WasmEdge_String FuncName =
         WasmEdge_StringCreateByCString(""add_and_square"");
     Params[0] = WasmEdge_ValueGenI32(123);
     Params[1] = WasmEdge_ValueGenI32(456);
     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);
     WasmEdge_StringDelete(FuncName);
     if (WasmEdge_ResultOK(Res)) {
       printf(""Get the '(%d + %d)^2' result: %d\n"", 123, 456,
              WasmEdge_ValueGetI32(Returns[0]));
     } else {
       printf(""Execute 'add_and_square' error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
     }
     /* Invoke the ""sum_of_squares"" to calculate (77^2 + 88^2) */
     FuncName = WasmEdge_StringCreateByCString(""sum_of_squares"");
     Params[0] = WasmEdge_ValueGenI32(77);
     Params[1] = WasmEdge_ValueGenI32(88);
     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);
     WasmEdge_StringDelete(FuncName);
     if (WasmEdge_ResultOK(Res)) {
       printf(""Get the '%d^2 + %d^2' result: %d\n"", 77, 88,
              WasmEdge_ValueGetI32(Returns[0]));
     } else {
       printf(""Execute 'sum_of_squares' error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
     }

     /* Resources deallocations. */
     WasmEdge_VMDelete(VMCxt);
     return 0;
   }
   ```

   Then compile and execute:

   ```bash
   $ gcc test.c -lwasmedge
   $ ./a.out
   Get the '(123 + 456)^2' result: 335241
   Get the '77^2 + 88^2' result: 13673
   ```

2. Register and instantiate the `lib.wasm` from the buffer.

   ```c
   #include <stdio.h>
   #include <wasmedge/wasmedge.h>

   int main() {
     /* The result. */
     WasmEdge_Result Res;

     /* The params and returns. */
     WasmEdge_Value Params[2], Returns[1];

     /* The `lib.wasm` buffer example. */
     /* Developers can also load the buffer from file. */
     uint8_t WASM[] = {/* WASM header */
                       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
                       /* Type section */
                       0x01, 0x07, 0x01,
                       /* function type {i32, i32} -> {i32} */
                       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
                       /* Function section */
                       0x03, 0x03, 0x02, 0x00, 0x00,
                       /* Export section */
                       0x07, 0x0D, 0x02,
                       /* export function: ""add"" */
                       0x03, 0x61, 0x64, 0x64, 0x00, 0x00,
                       /* export function: ""mul"" */
                       0x03, 0x6D, 0x75, 0x6C, 0x00, 0x01,
                       /* Code section */
                       0x0A, 0x11, 0x02,
                       /* ""add"" code body */
                       0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6A, 0x0B,
                       /* ""mul"" code body */
                       0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6C, 0x0B};

     /* Create the VM context. */
     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

     /* Register the `lib.wasm` from the buffer with the module name ""math"". */
     WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(""math"");
     Res = WasmEdge_VMRegisterModuleFromBuffer(VMCxt, ModuleName, WASM,
                                               sizeof(WASM));
     WasmEdge_StringDelete(ModuleName);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Register lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Instantiate the `test.wasm`. */
     /*
      * Developers can use the APIs such as `WasmEdge_VMRunWasmFromFile` to
      * instantiate and execute quickly.
      */
     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""test.wasm"");
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Load test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_VMValidate(VMCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Validate test.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_VMInstantiate(VMCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Instantiate test.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Invoke the functions. */
     /* Invoke the ""add_and_square"" to calculate (123 + 456)^2 */
     WasmEdge_String FuncName =
         WasmEdge_StringCreateByCString(""add_and_square"");
     Params[0] = WasmEdge_ValueGenI32(123);
     Params[1] = WasmEdge_ValueGenI32(456);
     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);
     WasmEdge_StringDelete(FuncName);
     if (WasmEdge_ResultOK(Res)) {
       printf(""Get the '(%d + %d)^2' result: %d\n"", 123, 456,
              WasmEdge_ValueGetI32(Returns[0]));
     } else {
       printf(""Execute 'add_and_square' error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
     }
     /* Invoke the ""sum_of_squares"" to calculate (77^2 + 88^2) */
     FuncName = WasmEdge_StringCreateByCString(""sum_of_squares"");
     Params[0] = WasmEdge_ValueGenI32(77);
     Params[1] = WasmEdge_ValueGenI32(88);
     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);
     WasmEdge_StringDelete(FuncName);
     if (WasmEdge_ResultOK(Res)) {
       printf(""Get the '%d^2 + %d^2' result: %d\n"", 77, 88,
              WasmEdge_ValueGetI32(Returns[0]));
     } else {
       printf(""Execute 'sum_of_squares' error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
     }

     /* Resources deallocations. */
     WasmEdge_VMDelete(VMCxt);
     return 0;
   }
   ```

   Then compile and execute:

   ```bash
   $ gcc test.c -lwasmedge
   $ ./a.out
   Get the '(123 + 456)^2' result: 335241
   Get the '77^2 + 88^2' result: 13673
   ```

3. Load the `lib.wasm` to an AST Context first

   ```c
   #include <stdio.h>
   #include <wasmedge/wasmedge.h>

   int main() {
     /* The result. */
     WasmEdge_Result Res;

     /* The params and returns. */
     WasmEdge_Value Params[2], Returns[1];

     /* Assume that the `lib.wasm` has loaded first. */
     WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
     WasmEdge_ASTModuleContext *LibASTCxt = NULL;
     Res = WasmEdge_LoaderParseFromFile(LoadCxt, &LibASTCxt, ""lib.wasm"");
     WasmEdge_LoaderDelete(LoadCxt);
     if (!WasmEdge_ResultOK(Res)) {
       printf(""Load lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Create the VM context. */
     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

     /* Register the loaded AST context with the module name ""math"". */
     WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(""math"");
     Res =
         WasmEdge_VMRegisterModuleFromASTModule(VMCxt, ModuleName, LibASTCxt);
     WasmEdge_StringDelete(ModuleName);
     WasmEdge_ASTModuleDelete(LibASTCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Register lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Instantiate the `test.wasm`. */
     /*
      * Developers can use the APIs such as `WasmEdge_VMRunWasmFromFile` to
      * instantiate and execute quickly.
      */
     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""test.wasm"");
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Load test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_VMValidate(VMCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Validate test.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_VMInstantiate(VMCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Instantiate test.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Invoke the functions. */
     /* Invoke the ""add_and_square"" to calculate (123 + 456)^2 */
     WasmEdge_String FuncName =
         WasmEdge_StringCreateByCString(""add_and_square"");
     Params[0] = WasmEdge_ValueGenI32(123);
     Params[1] = WasmEdge_ValueGenI32(456);
     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);
     WasmEdge_StringDelete(FuncName);
     if (WasmEdge_ResultOK(Res)) {
       printf(""Get the '(%d + %d)^2' result: %d\n"", 123, 456,
              WasmEdge_ValueGetI32(Returns[0]));
     } else {
       printf(""Execute 'add_and_square' error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
     }
     /* Invoke the ""sum_of_squares"" to calculate (77^2 + 88^2) */
     FuncName = WasmEdge_StringCreateByCString(""sum_of_squares"");
     Params[0] = WasmEdge_ValueGenI32(77);
     Params[1] = WasmEdge_ValueGenI32(88);
     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);
     WasmEdge_StringDelete(FuncName);
     if (WasmEdge_ResultOK(Res)) {
       printf(""Get the '%d^2 + %d^2' result: %d\n"", 77, 88,
              WasmEdge_ValueGetI32(Returns[0]));
     } else {
       printf(""Execute 'sum_of_squares' error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
     }

     /* Resources deallocations. */
     WasmEdge_VMDelete(VMCxt);
     return 0;
   }
   ```

   Then compile and execute:

   ```bash
   $ gcc test.c -lwasmedge
   $ ./a.out
   Get the '(123 + 456)^2' result: 335241
   Get the '77^2 + 88^2' result: 13673
   ```

4. Instantiate the `lib.wasm` first

   ```c
   #include <stdio.h>
   #include <wasmedge/wasmedge.h>

   int main() {
     /* The result. */
     WasmEdge_Result Res;

     /* The params and returns. */
     WasmEdge_Value Params[2], Returns[1];

     /* Create the VM context. */
     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

     /* Assume that the `lib.wasm` has instantiated first. */
     WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
     WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);
     WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);
     WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
     WasmEdge_ASTModuleContext *LibASTCxt = NULL;
     WasmEdge_ModuleInstanceContext *LibInstCxt = NULL;
     Res = WasmEdge_LoaderParseFromFile(LoadCxt, &LibASTCxt, ""lib.wasm"");
     WasmEdge_LoaderDelete(LoadCxt);
     if (!WasmEdge_ResultOK(Res)) {
       printf(""Load lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_ValidatorValidate(ValidCxt, LibASTCxt);
     WasmEdge_ValidatorDelete(ValidCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_ASTModuleDelete(LibASTCxt);
       printf(""Validate lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     /*
      * The module name is determined when instantiation.
      * If use the `WasmEdge_ExecutorInstantiate` API, the module name will be
      * """".
      */
     WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(""math"");
     Res = WasmEdge_ExecutorRegister(ExecCxt, &LibInstCxt, StoreCxt, LibASTCxt,
                                     ModuleName);
     WasmEdge_ExecutorDelete(ExecCxt);
     WasmEdge_ASTModuleDelete(LibASTCxt);
     WasmEdge_StringDelete(ModuleName);
     WasmEdge_StoreDelete(StoreCxt);
     if (!WasmEdge_ResultOK(Res)) {
       printf(""Instantiate lib.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Register the module instance with the module name ""math"". */
     /* The module name has been determined when instantiating the `lib.wasm`. */
     Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, LibInstCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       WasmEdge_ModuleInstanceDelete(LibInstCxt);
       printf(""Register lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Instantiate the `test.wasm`. */
     /*
      * Developers can use the APIs such as `WasmEdge_VMRunWasmFromFile` to
      * instantiate and execute quickly.
      */
     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""test.wasm"");
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       WasmEdge_ModuleInstanceDelete(LibInstCxt);
       printf(""Load test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_VMValidate(VMCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       WasmEdge_ModuleInstanceDelete(LibInstCxt);
       printf(""Validate test.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_VMInstantiate(VMCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       WasmEdge_ModuleInstanceDelete(LibInstCxt);
       printf(""Instantiate test.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Invoke the functions. */
     /* Invoke the ""add_and_square"" to calculate (123 + 456)^2 */
     WasmEdge_String FuncName =
         WasmEdge_StringCreateByCString(""add_and_square"");
     Params[0] = WasmEdge_ValueGenI32(123);
     Params[1] = WasmEdge_ValueGenI32(456);
     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);
     WasmEdge_StringDelete(FuncName);
     if (WasmEdge_ResultOK(Res)) {
       printf(""Get the '(%d + %d)^2' result: %d\n"", 123, 456,
              WasmEdge_ValueGetI32(Returns[0]));
     } else {
       printf(""Execute 'add_and_square' error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
     }
     /* Invoke the ""sum_of_squares"" to calculate (77^2 + 88^2) */
     FuncName = WasmEdge_StringCreateByCString(""sum_of_squares"");
     Params[0] = WasmEdge_ValueGenI32(77);
     Params[1] = WasmEdge_ValueGenI32(88);
     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);
     WasmEdge_StringDelete(FuncName);
     if (WasmEdge_ResultOK(Res)) {
       printf(""Get the '%d^2 + %d^2' result: %d\n"", 77, 88,
              WasmEdge_ValueGetI32(Returns[0]));
     } else {
       printf(""Execute 'sum_of_squares' error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
     }

     /* Resources deallocations. */
     WasmEdge_VMDelete(VMCxt);
     /* The imported module instance should be destroyed. */
     WasmEdge_ModuleInstanceDelete(LibInstCxt);
     return 0;
   }
   ```

   Then compile and execute:

   ```bash
   $ gcc test.c -lwasmedge
   $ ./a.out
   Get the '(123 + 456)^2' result: 335241
   Get the '77^2 + 88^2' result: 13673
   ```

## Linking WASM Modules By the Executor Context

For linking multiple WASM modules, developers should instantiate them first by considering their dependencies.

```c
#include <stdio.h>
#include <wasmedge/wasmedge.h>

int main() {
  /* The result. */
  WasmEdge_Result Res;

  /* The params and returns. */
  WasmEdge_Value Params[2], Returns[1];

  /* Create the contexts. */
  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);
  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);
  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

  /* Load and register the `lib.wasm` with the module name ""math"". */
  WasmEdge_ASTModuleContext *LibASTCxt = NULL;
  WasmEdge_ModuleInstanceContext *LibInstCxt = NULL;
  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &LibASTCxt, ""lib.wasm"");
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Load lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
    return -1;
  }
  Res = WasmEdge_ValidatorValidate(ValidCxt, LibASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Validate lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
    return -1;
  }
  WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(""math"");
  Res = WasmEdge_ExecutorRegister(ExecCxt, &LibInstCxt, StoreCxt, LibASTCxt,
                                  ModuleName);
  WasmEdge_StringDelete(ModuleName);
  WasmEdge_ASTModuleDelete(LibASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Instantiate lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
    return -1;
  }

  /* Load and instantiate the `test.wasm`. */
  WasmEdge_ASTModuleContext *TestASTCxt = NULL;
  WasmEdge_ModuleInstanceContext *TestInstCxt = NULL;
  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &TestASTCxt, ""test.wasm"");
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Load test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
    return -1;
  }
  Res = WasmEdge_ValidatorValidate(ValidCxt, TestASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Validate test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
    return -1;
  }
  Res =
      WasmEdge_ExecutorInstantiate(ExecCxt, &TestInstCxt, StoreCxt, TestASTCxt);
  WasmEdge_ASTModuleDelete(TestASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Instantiate test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
    return -1;
  }

  /* Invoke the functions. */
  /* Invoke the ""add_and_square"" to calculate (123 + 456)^2 */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""add_and_square"");
  WasmEdge_FunctionInstanceContext *FuncCxt =
      WasmEdge_ModuleInstanceFindFunction(TestInstCxt, FuncName);
  WasmEdge_StringDelete(FuncName);
  if (FuncCxt == NULL) {
    printf(""Function 'add_and_square' not found.\n"");
    return -1;
  }
  Params[0] = WasmEdge_ValueGenI32(123);
  Params[1] = WasmEdge_ValueGenI32(456);
  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 2, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(""Get the '(%d + %d)^2' result: %d\n"", 123, 456,
           WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(""Execute 'add_and_square' error: %s\n"",
           WasmEdge_ResultGetMessage(Res));
  }
  /* Invoke the ""sum_of_squares"" to calculate (77^2 + 88^2) */
  FuncName = WasmEdge_StringCreateByCString(""sum_of_squares"");
  FuncCxt = WasmEdge_ModuleInstanceFindFunction(TestInstCxt, FuncName);
  WasmEdge_StringDelete(FuncName);
  if (FuncCxt == NULL) {
    printf(""Function 'sum_of_squares' not found.\n"");
    return -1;
  }
  Params[0] = WasmEdge_ValueGenI32(77);
  Params[1] = WasmEdge_ValueGenI32(88);
  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 2, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(""Get the '%d^2 + %d^2' result: %d\n"", 77, 88,
           WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(""Execute 'sum_of_squares' error: %s\n"",
           WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_LoaderDelete(LoadCxt);
  WasmEdge_ValidatorDelete(ValidCxt);
  WasmEdge_ExecutorDelete(ExecCxt);
  WasmEdge_StoreDelete(StoreCxt);
  WasmEdge_ModuleInstanceDelete(LibInstCxt);
  WasmEdge_ModuleInstanceDelete(TestInstCxt);
  return 0;
}
```

Then compile and execute:

```bash
$ gcc test.c -lwasmedge
$ ./a.out
Get the '(123 + 456)^2' result: 335241
Get the '77^2 + 88^2' result: 13673
```
","The provided code is a C program that demonstrates how to link and execute multiple WebAssembly (WASM) modules using the WasmEdge SDK. The code uses four different methods to link WASM modules:

1.  **Registering and instantiating from file**: This method loads the WASM module from a file, validates it, registers it with the VM context, and then instantiates it.
2.  **Parsing and registering from buffer**: Similar to the first method, but the WASM code is loaded from a buffer instead of a file.
3.  **Instantiating from loader context**: This method uses the loader context to load, parse, and register the WASM module, and then instantiates it.
4.  **Linking with executor context**: This method uses the executor context to load, parse, and instantiate multiple WASM modules.

The code also demonstrates how to invoke functions from these linked WASM modules using the `ExecutorInvoke` function.

Here's a concise summary of the provided code:

*   The code includes four different methods to link WASM modules:
    *   Registering and instantiating from file
    *   Parsing and registering from buffer
    *   Instantiating from loader context
    *   Linking with executor context
*   Each method is implemented in a separate function
*   The code uses the WasmEdge SDK functions to load, parse, validate, register, and instantiate WASM modules
*   The code demonstrates how to invoke functions from linked WASM modules using the `ExecutorInvoke` function

Potential improvements:

*   Error handling: The code does not handle errors well. It assumes that all API calls will succeed and only prints error messages when an API call fails. A better approach would be to check the return values of API calls and handle errors properly.
*   Code organization: The code is a bit disorganized, with functions doing multiple things at once. Consider breaking down the code into smaller functions each responsible for one task.
*   Comments: The code could benefit from more comments explaining what each function does and how it relates to the rest of the code.

Here's an example of refactored code:

```c
#include <stdio.h>
#include <wasmedge/wasmedge.h>

// Function to register a WASM module from file
WasmEdge_Result register_wasm_module_from_file(
    WasmEdge_LoaderContext *load_cxt, char *file_path) {
  WasmEdge_ASTModuleContext *ast_cxt = NULL;
  return WasmEdge_LoaderParseFromFile(load_cxt, &ast_cxt, file_path);
}

// Function to instantiate a WASM module
WasmEdge_ModuleInstanceContext *instantiate_wasm_module(
    WasmEdge_LoaderContext *load_cxt, WasmEdge_ASTModuleContext *ast_cxt) {
  return WasmEdge_ExecutorInstantiate(load_cxt, NULL, NULL, ast_cxt);
}

// Function to invoke a function from a linked WASM module
WasmEdge_Result invoke_function(
    WasmEdge_ModuleInstanceContext *module_inst_cxt,
    char *func_name,
    WasmEdge_Value *params) {
  WasmEdge_FunctionInstanceContext *func_cxt =
      WasmEdge_ModuleInstanceFindFunction(module_inst_cxt, func_name);
  if (func_cxt == NULL) {
    return WasmEdge_ResultCreateWithMessage(""Function not found"");
  }

  return WasmEdge_ExecutorInvoke(NULL, func_cxt, params, 1, NULL, 1);
}

int main() {
  // Create loader context
  WasmEdge_LoaderContext *load_cxt = WasmEdge_LoaderCreate(NULL);

  // Register and instantiate a WASM module from file
  char *file_path = ""lib.wasm"";
  WasmEdge_ASTModuleContext *ast_cxt = NULL;
  WasmEdge_ModuleInstanceContext *module_inst_cxt =
      instantiate_wasm_module(load_cxt, register_wasm_module_from_file(
          load_cxt, file_path));

  // Invoke a function from the linked WASM module
  char *func_name = ""add_and_square"";
  WasmEdge_Value params[2] = {WasmEdge_ValueGenI32(123), WasmEdge_ValueGenI32(456)};
  WasmEdge_Result result = invoke_function(module_inst_cxt, func_name, params);

  // Print the result
  if (WasmEdge_ResultOK(result)) {
    printf(""Get the '(123 + 456)^2' result: %d\n"",
           WasmEdge_ValueGetI32(WasmEdge_ValueResultValue(result)));
  } else {
    printf(""Execute 'add_and_square' error: %s\n"",
           WasmEdge_ResultGetMessage(result));
  }

  return 0;
}
```"
i18n/zh/docusaurus-plugin-content-docs/current/embed/c/multiple_modules.md,"---
sidebar_position: 5
---

# Multiple WASM Module Example

For those WASM modules that export their functions, the other WASM modules can import them as a library.

This will cause a situation that links multiple modules for the dependencies in execution.

This chapter will introduce examples of linking and executing multiple WASM modules in WasmEdge.

## Example WASM file

### The Library WASM

Assume that there's a WASM that exports it's function:

```wasm
(module
  (func (export ""add"") (param i32 i32) (result i32)
    ;; Function to add 2 numbers and exported as ""add"".
    (i32.add (local.get 0) (local.get 1))
  )
  (func (export ""mul"") (param i32 i32) (result i32)
    ;; Function to mul 2 number and exported as ""mul"".
    (i32.mul (local.get 0) (local.get 1))
  )
)
```

Users can convert `wat` to `wasm` through [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) live tool. Assume that this `wat` is converted into the WASM binary format and saved as `lib.wasm`.

### The Entering WASM

Assume that there's a WASM which imports some functions from the `lib.wasm`, and this WASM exports the functions which can be invoked:

```wasm
(module
  (type $type0 (func (param i32 i32)(result i32)))
  ;; Import the ""add"" function which calculate ""a + b"".
  (import ""math"" ""add"" (func $math-add (type $type0)))
  ;; Import the ""mul"" function which calculate ""a * b"".
  (import ""math"" ""mul"" (func $math-mul (type $type0)))
  (func (export ""add_and_square"") (param i32 i32) (result i32)
    ;; Function to add 2 numbers and square it ((a + b)^2).
    ;; Exported as ""add_and_square"".
    (call $math-mul
      (call $math-add (local.get 0) (local.get 1))
      (call $math-add (local.get 0) (local.get 1))
    )
  )
  (func (export ""sum_of_squares"") (param i32 i32) (result i32)
    ;; Function to calculate the sum of squares (a^2 + b^2).
    ;; Exported as ""sum_of_squares"".
    (call $math-add
      (call $math-mul (local.get 0) (local.get 0))
      (call $math-mul (local.get 1) (local.get 1))
    )
  )
)
```

Users can convert `wat` to `wasm` through [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) live tool. Assume that this `wat` is converted into the WASM binary format and saved as `test.wasm`.

### Prerequisites

For executing these examples, developers should [install WasmEdge](../../start/install.md#install).

To improve the performance of executing WASM, developers can also use the [AOT compiler](../../start/build-and-run/aot.md) to compile the above WASM files.

## Linking WASM Modules With the VM Context

With the `WasmEdge_VMContext`, developers can instantiate and execute WASM quickly. There are at least four ways to link these multiple WASM modules with the VM context. For the example codes below, assume that the C code is saved as `example.c`.

1. Register and instantiate the `lib.wasm` from the file directly.

   ```c
   #include <stdio.h>
   #include <wasmedge/wasmedge.h>

   int main() {
     /* The result. */
     WasmEdge_Result Res;

     /* The params and returns. */
     WasmEdge_Value Params[2], Returns[1];

     /* Create the VM context. */
     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

     /* Register the `lib.wasm` from file with the module name ""math"". */
     WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(""math"");
     Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModuleName, ""lib.wasm"");
     WasmEdge_StringDelete(ModuleName);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Register lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Instantiate the `test.wasm`. */
     /*
      * Developers can use the APIs such as `WasmEdge_VMRunWasmFromFile` to
      * instantiate and execute quickly.
      */
     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""test.wasm"");
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Load test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_VMValidate(VMCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Validate test.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_VMInstantiate(VMCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Instantiate test.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Invoke the functions. */
     /* Invoke the ""add_and_square"" to calculate (123 + 456)^2 */
     WasmEdge_String FuncName =
         WasmEdge_StringCreateByCString(""add_and_square"");
     Params[0] = WasmEdge_ValueGenI32(123);
     Params[1] = WasmEdge_ValueGenI32(456);
     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);
     WasmEdge_StringDelete(FuncName);
     if (WasmEdge_ResultOK(Res)) {
       printf(""Get the '(%d + %d)^2' result: %d\n"", 123, 456,
              WasmEdge_ValueGetI32(Returns[0]));
     } else {
       printf(""Execute 'add_and_square' error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
     }
     /* Invoke the ""sum_of_squares"" to calculate (77^2 + 88^2) */
     FuncName = WasmEdge_StringCreateByCString(""sum_of_squares"");
     Params[0] = WasmEdge_ValueGenI32(77);
     Params[1] = WasmEdge_ValueGenI32(88);
     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);
     WasmEdge_StringDelete(FuncName);
     if (WasmEdge_ResultOK(Res)) {
       printf(""Get the '%d^2 + %d^2' result: %d\n"", 77, 88,
              WasmEdge_ValueGetI32(Returns[0]));
     } else {
       printf(""Execute 'sum_of_squares' error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
     }

     /* Resources deallocations. */
     WasmEdge_VMDelete(VMCxt);
     return 0;
   }
   ```

   Then compile and execute:

   ```bash
   $ gcc test.c -lwasmedge
   $ ./a.out
   Get the '(123 + 456)^2' result: 335241
   Get the '77^2 + 88^2' result: 13673
   ```

2. Register and instantiate the `lib.wasm` from the buffer.

   ```c
   #include <stdio.h>
   #include <wasmedge/wasmedge.h>

   int main() {
     /* The result. */
     WasmEdge_Result Res;

     /* The params and returns. */
     WasmEdge_Value Params[2], Returns[1];

     /* The `lib.wasm` buffer example. */
     /* Developers can also load the buffer from file. */
     uint8_t WASM[] = {/* WASM header */
                       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
                       /* Type section */
                       0x01, 0x07, 0x01,
                       /* function type {i32, i32} -> {i32} */
                       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
                       /* Function section */
                       0x03, 0x03, 0x02, 0x00, 0x00,
                       /* Export section */
                       0x07, 0x0D, 0x02,
                       /* export function: ""add"" */
                       0x03, 0x61, 0x64, 0x64, 0x00, 0x00,
                       /* export function: ""mul"" */
                       0x03, 0x6D, 0x75, 0x6C, 0x00, 0x01,
                       /* Code section */
                       0x0A, 0x11, 0x02,
                       /* ""add"" code body */
                       0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6A, 0x0B,
                       /* ""mul"" code body */
                       0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6C, 0x0B};

     /* Create the VM context. */
     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

     /* Register the `lib.wasm` from the buffer with the module name ""math"". */
     WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(""math"");
     Res = WasmEdge_VMRegisterModuleFromBuffer(VMCxt, ModuleName, WASM,
                                               sizeof(WASM));
     WasmEdge_StringDelete(ModuleName);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Register lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Instantiate the `test.wasm`. */
     /*
      * Developers can use the APIs such as `WasmEdge_VMRunWasmFromFile` to
      * instantiate and execute quickly.
      */
     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""test.wasm"");
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Load test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_VMValidate(VMCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Validate test.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_VMInstantiate(VMCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Instantiate test.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Invoke the functions. */
     /* Invoke the ""add_and_square"" to calculate (123 + 456)^2 */
     WasmEdge_String FuncName =
         WasmEdge_StringCreateByCString(""add_and_square"");
     Params[0] = WasmEdge_ValueGenI32(123);
     Params[1] = WasmEdge_ValueGenI32(456);
     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);
     WasmEdge_StringDelete(FuncName);
     if (WasmEdge_ResultOK(Res)) {
       printf(""Get the '(%d + %d)^2' result: %d\n"", 123, 456,
              WasmEdge_ValueGetI32(Returns[0]));
     } else {
       printf(""Execute 'add_and_square' error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
     }
     /* Invoke the ""sum_of_squares"" to calculate (77^2 + 88^2) */
     FuncName = WasmEdge_StringCreateByCString(""sum_of_squares"");
     Params[0] = WasmEdge_ValueGenI32(77);
     Params[1] = WasmEdge_ValueGenI32(88);
     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);
     WasmEdge_StringDelete(FuncName);
     if (WasmEdge_ResultOK(Res)) {
       printf(""Get the '%d^2 + %d^2' result: %d\n"", 77, 88,
              WasmEdge_ValueGetI32(Returns[0]));
     } else {
       printf(""Execute 'sum_of_squares' error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
     }

     /* Resources deallocations. */
     WasmEdge_VMDelete(VMCxt);
     return 0;
   }
   ```

   Then compile and execute:

   ```bash
   $ gcc test.c -lwasmedge
   $ ./a.out
   Get the '(123 + 456)^2' result: 335241
   Get the '77^2 + 88^2' result: 13673
   ```

3. Load the `lib.wasm` to an AST Context first

   ```c
   #include <stdio.h>
   #include <wasmedge/wasmedge.h>

   int main() {
     /* The result. */
     WasmEdge_Result Res;

     /* The params and returns. */
     WasmEdge_Value Params[2], Returns[1];

     /* Assume that the `lib.wasm` has loaded first. */
     WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
     WasmEdge_ASTModuleContext *LibASTCxt = NULL;
     Res = WasmEdge_LoaderParseFromFile(LoadCxt, &LibASTCxt, ""lib.wasm"");
     WasmEdge_LoaderDelete(LoadCxt);
     if (!WasmEdge_ResultOK(Res)) {
       printf(""Load lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Create the VM context. */
     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

     /* Register the loaded AST context with the module name ""math"". */
     WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(""math"");
     Res =
         WasmEdge_VMRegisterModuleFromASTModule(VMCxt, ModuleName, LibASTCxt);
     WasmEdge_StringDelete(ModuleName);
     WasmEdge_ASTModuleDelete(LibASTCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Register lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Instantiate the `test.wasm`. */
     /*
      * Developers can use the APIs such as `WasmEdge_VMRunWasmFromFile` to
      * instantiate and execute quickly.
      */
     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""test.wasm"");
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Load test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_VMValidate(VMCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Validate test.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_VMInstantiate(VMCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       printf(""Instantiate test.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Invoke the functions. */
     /* Invoke the ""add_and_square"" to calculate (123 + 456)^2 */
     WasmEdge_String FuncName =
         WasmEdge_StringCreateByCString(""add_and_square"");
     Params[0] = WasmEdge_ValueGenI32(123);
     Params[1] = WasmEdge_ValueGenI32(456);
     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);
     WasmEdge_StringDelete(FuncName);
     if (WasmEdge_ResultOK(Res)) {
       printf(""Get the '(%d + %d)^2' result: %d\n"", 123, 456,
              WasmEdge_ValueGetI32(Returns[0]));
     } else {
       printf(""Execute 'add_and_square' error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
     }
     /* Invoke the ""sum_of_squares"" to calculate (77^2 + 88^2) */
     FuncName = WasmEdge_StringCreateByCString(""sum_of_squares"");
     Params[0] = WasmEdge_ValueGenI32(77);
     Params[1] = WasmEdge_ValueGenI32(88);
     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);
     WasmEdge_StringDelete(FuncName);
     if (WasmEdge_ResultOK(Res)) {
       printf(""Get the '%d^2 + %d^2' result: %d\n"", 77, 88,
              WasmEdge_ValueGetI32(Returns[0]));
     } else {
       printf(""Execute 'sum_of_squares' error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
     }

     /* Resources deallocations. */
     WasmEdge_VMDelete(VMCxt);
     return 0;
   }
   ```

   Then compile and execute:

   ```bash
   $ gcc test.c -lwasmedge
   $ ./a.out
   Get the '(123 + 456)^2' result: 335241
   Get the '77^2 + 88^2' result: 13673
   ```

4. Instantiate the `lib.wasm` first

   ```c
   #include <stdio.h>
   #include <wasmedge/wasmedge.h>

   int main() {
     /* The result. */
     WasmEdge_Result Res;

     /* The params and returns. */
     WasmEdge_Value Params[2], Returns[1];

     /* Create the VM context. */
     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

     /* Assume that the `lib.wasm` has instantiated first. */
     WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
     WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);
     WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);
     WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
     WasmEdge_ASTModuleContext *LibASTCxt = NULL;
     WasmEdge_ModuleInstanceContext *LibInstCxt = NULL;
     Res = WasmEdge_LoaderParseFromFile(LoadCxt, &LibASTCxt, ""lib.wasm"");
     WasmEdge_LoaderDelete(LoadCxt);
     if (!WasmEdge_ResultOK(Res)) {
       printf(""Load lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_ValidatorValidate(ValidCxt, LibASTCxt);
     WasmEdge_ValidatorDelete(ValidCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_ASTModuleDelete(LibASTCxt);
       printf(""Validate lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     /*
      * The module name is determined when instantiation.
      * If use the `WasmEdge_ExecutorInstantiate` API, the module name will be
      * """".
      */
     WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(""math"");
     Res = WasmEdge_ExecutorRegister(ExecCxt, &LibInstCxt, StoreCxt, LibASTCxt,
                                     ModuleName);
     WasmEdge_ExecutorDelete(ExecCxt);
     WasmEdge_ASTModuleDelete(LibASTCxt);
     WasmEdge_StringDelete(ModuleName);
     WasmEdge_StoreDelete(StoreCxt);
     if (!WasmEdge_ResultOK(Res)) {
       printf(""Instantiate lib.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Register the module instance with the module name ""math"". */
     /* The module name has been determined when instantiating the `lib.wasm`. */
     Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, LibInstCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       WasmEdge_ModuleInstanceDelete(LibInstCxt);
       printf(""Register lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Instantiate the `test.wasm`. */
     /*
      * Developers can use the APIs such as `WasmEdge_VMRunWasmFromFile` to
      * instantiate and execute quickly.
      */
     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""test.wasm"");
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       WasmEdge_ModuleInstanceDelete(LibInstCxt);
       printf(""Load test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_VMValidate(VMCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       WasmEdge_ModuleInstanceDelete(LibInstCxt);
       printf(""Validate test.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }
     Res = WasmEdge_VMInstantiate(VMCxt);
     if (!WasmEdge_ResultOK(Res)) {
       WasmEdge_VMDelete(VMCxt);
       WasmEdge_ModuleInstanceDelete(LibInstCxt);
       printf(""Instantiate test.wasm error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
       return -1;
     }

     /* Invoke the functions. */
     /* Invoke the ""add_and_square"" to calculate (123 + 456)^2 */
     WasmEdge_String FuncName =
         WasmEdge_StringCreateByCString(""add_and_square"");
     Params[0] = WasmEdge_ValueGenI32(123);
     Params[1] = WasmEdge_ValueGenI32(456);
     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);
     WasmEdge_StringDelete(FuncName);
     if (WasmEdge_ResultOK(Res)) {
       printf(""Get the '(%d + %d)^2' result: %d\n"", 123, 456,
              WasmEdge_ValueGetI32(Returns[0]));
     } else {
       printf(""Execute 'add_and_square' error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
     }
     /* Invoke the ""sum_of_squares"" to calculate (77^2 + 88^2) */
     FuncName = WasmEdge_StringCreateByCString(""sum_of_squares"");
     Params[0] = WasmEdge_ValueGenI32(77);
     Params[1] = WasmEdge_ValueGenI32(88);
     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);
     WasmEdge_StringDelete(FuncName);
     if (WasmEdge_ResultOK(Res)) {
       printf(""Get the '%d^2 + %d^2' result: %d\n"", 77, 88,
              WasmEdge_ValueGetI32(Returns[0]));
     } else {
       printf(""Execute 'sum_of_squares' error: %s\n"",
              WasmEdge_ResultGetMessage(Res));
     }

     /* Resources deallocations. */
     WasmEdge_VMDelete(VMCxt);
     /* The imported module instance should be destroyed. */
     WasmEdge_ModuleInstanceDelete(LibInstCxt);
     return 0;
   }
   ```

   Then compile and execute:

   ```bash
   $ gcc test.c -lwasmedge
   $ ./a.out
   Get the '(123 + 456)^2' result: 335241
   Get the '77^2 + 88^2' result: 13673
   ```

## Linking WASM Modules By the Executor Context

For linking multiple WASM modules, developers should instantiate them first by considering their dependencies.

```c
#include <stdio.h>
#include <wasmedge/wasmedge.h>

int main() {
  /* The result. */
  WasmEdge_Result Res;

  /* The params and returns. */
  WasmEdge_Value Params[2], Returns[1];

  /* Create the contexts. */
  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);
  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);
  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

  /* Load and register the `lib.wasm` with the module name ""math"". */
  WasmEdge_ASTModuleContext *LibASTCxt = NULL;
  WasmEdge_ModuleInstanceContext *LibInstCxt = NULL;
  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &LibASTCxt, ""lib.wasm"");
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Load lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
    return -1;
  }
  Res = WasmEdge_ValidatorValidate(ValidCxt, LibASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Validate lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
    return -1;
  }
  WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(""math"");
  Res = WasmEdge_ExecutorRegister(ExecCxt, &LibInstCxt, StoreCxt, LibASTCxt,
                                  ModuleName);
  WasmEdge_StringDelete(ModuleName);
  WasmEdge_ASTModuleDelete(LibASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Instantiate lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
    return -1;
  }

  /* Load and instantiate the `test.wasm`. */
  WasmEdge_ASTModuleContext *TestASTCxt = NULL;
  WasmEdge_ModuleInstanceContext *TestInstCxt = NULL;
  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &TestASTCxt, ""test.wasm"");
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Load test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
    return -1;
  }
  Res = WasmEdge_ValidatorValidate(ValidCxt, TestASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Validate test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
    return -1;
  }
  Res =
      WasmEdge_ExecutorInstantiate(ExecCxt, &TestInstCxt, StoreCxt, TestASTCxt);
  WasmEdge_ASTModuleDelete(TestASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Instantiate test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));
    return -1;
  }

  /* Invoke the functions. */
  /* Invoke the ""add_and_square"" to calculate (123 + 456)^2 */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""add_and_square"");
  WasmEdge_FunctionInstanceContext *FuncCxt =
      WasmEdge_ModuleInstanceFindFunction(TestInstCxt, FuncName);
  WasmEdge_StringDelete(FuncName);
  if (FuncCxt == NULL) {
    printf(""Function 'add_and_square' not found.\n"");
    return -1;
  }
  Params[0] = WasmEdge_ValueGenI32(123);
  Params[1] = WasmEdge_ValueGenI32(456);
  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 2, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(""Get the '(%d + %d)^2' result: %d\n"", 123, 456,
           WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(""Execute 'add_and_square' error: %s\n"",
           WasmEdge_ResultGetMessage(Res));
  }
  /* Invoke the ""sum_of_squares"" to calculate (77^2 + 88^2) */
  FuncName = WasmEdge_StringCreateByCString(""sum_of_squares"");
  FuncCxt = WasmEdge_ModuleInstanceFindFunction(TestInstCxt, FuncName);
  WasmEdge_StringDelete(FuncName);
  if (FuncCxt == NULL) {
    printf(""Function 'sum_of_squares' not found.\n"");
    return -1;
  }
  Params[0] = WasmEdge_ValueGenI32(77);
  Params[1] = WasmEdge_ValueGenI32(88);
  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 2, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(""Get the '%d^2 + %d^2' result: %d\n"", 77, 88,
           WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(""Execute 'sum_of_squares' error: %s\n"",
           WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_LoaderDelete(LoadCxt);
  WasmEdge_ValidatorDelete(ValidCxt);
  WasmEdge_ExecutorDelete(ExecCxt);
  WasmEdge_StoreDelete(StoreCxt);
  WasmEdge_ModuleInstanceDelete(LibInstCxt);
  WasmEdge_ModuleInstanceDelete(TestInstCxt);
  return 0;
}
```

Then compile and execute:

```bash
$ gcc test.c -lwasmedge
$ ./a.out
Get the '(123 + 456)^2' result: 335241
Get the '77^2 + 88^2' result: 13673
```
","The provided code demonstrates how to link and execute multiple WASM modules in the WasmEdge VM. It uses four different methods to register and instantiate the `lib.wasm` and `test.wasm` files:

1. Registering from a file directly using `WasmEdge_VMRegisterModuleFromFile`.
2. Loading from a buffer using `WasmEdge_VMRegisterModuleFromBuffer`.
3. Instantiating first by considering their dependencies.
4. Linking WASM modules by the Executor Context.

The code also shows how to invoke functions in the instantiated module instances using `WasmEdge_ExecutorInvoke`. The output of the program will be the results of the ""add_and_square"" and ""sum_of_squares"" function invocations, which are calculated as follows:

- `(123 + 456)^2 = 335241`
- `77^2 + 88^2 = 13673`

The code is well-documented with comments explaining each section. However, there are some areas that could be improved for better readability and maintainability:

1. **Consistent naming conventions**: The code uses both camelCase and underscore notation for variable names. It's recommended to use a consistent naming convention throughout the code.
2. **Code organization**: Some of the functions (e.g., `add_and_square` and `sum_of_squares`) are not explicitly declared in the code, but their implementations are scattered across different sections. Consider grouping related functions together for better readability.
3. **Magic numbers**: The code uses magic numbers (e.g., `123`, `456`, `77`, and `88`) as inputs to function invocations. These numbers could be replaced with named constants or variables for better clarity.

Overall, the provided code demonstrates a clear understanding of the WasmEdge API and its capabilities for working with WASM modules. However, there are opportunities for improvement in terms of coding best practices, organization, and maintainability."
docs/contribute/source/plugin/wasi_nn.md,"---
sidebar_position: 2
---

# Build with WASI-nn Plug-in

The WASI-NN plug-in is a proposed WebAssembly System Interface (WASI) API for machine learning. It allows WebAssembly programs to access host-provided machine learning functions.

## Prerequisites

Currently, WasmEdge used OpenVINO™, PyTorch, TensorFlow Lite, or llama.cpp as the WASI-NN backend implementation. For using WASI-NN on WasmEdge, you need to install [OpenVINO™](https://docs.openvino.ai/2023.0/openvino_docs_install_guides_installing_openvino_apt.html)(2023), [TensorFlow Lite](https://www.tensorflow.org/install/lang_c), or [PyTorch 1.8.2 LTS](https://pytorch.org/get-started/locally/) for the backend.

By default, we don't enable any WASI-NN backend in WasmEdge. Therefore developers should [build the WasmEdge from source](../os/linux.md) with the cmake option `WASMEDGE_PLUGIN_WASI_NN_BACKEND` to enable the backends.

## Build WasmEdge with WASI-NN OpenVINO Backend

For choosing and installing OpenVINO™ on `Ubuntu 20.04` for the backend, we recommend the following commands:

```bash
wget https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB
sudo apt-key add GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB
echo ""deb https://apt.repos.intel.com/openvino/2023 ubuntu20 main"" | sudo tee /etc/apt/sources.list.d/intel-openvino-2023.list
sudo apt update
sudo apt-get -y install openvino
ldconfig
```

Then build and install WasmEdge from source:

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""OpenVINO""
cmake --build build
# For the WASI-NN plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-NN plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_nn/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-NN with OpenVINO backend plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiNN.so` after installation.

## Build WasmEdge with WASI-NN PyTorch Backend

For choosing and installing PyTorch on `Ubuntu 20.04` for the backend, we recommend the following commands:

```bash
export PYTORCH_VERSION=""1.8.2""
curl -s -L -O --remote-name-all https://download.pytorch.org/libtorch/lts/1.8/cpu/libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip
unzip -q ""libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""
rm -f ""libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""
export LD_LIBRARY_PATH=$(pwd)/libtorch/lib:${LD_LIBRARY_PATH}
export Torch_DIR=$(pwd)/libtorch
```

For the legacy operating system such as `CentOS 7.6`, please use the `pre-cxx11-abi` version of `libtorch` instead:

```bash
export PYTORCH_VERSION=""1.8.2""
curl -s -L -O --remote-name-all https://download.pytorch.org/libtorch/lts/1.8/cpu/libtorch-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip
unzip -q ""libtorch-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""
rm -f ""libtorch-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""
export LD_LIBRARY_PATH=$(pwd)/libtorch/lib:${LD_LIBRARY_PATH}
export Torch_DIR=$(pwd)/libtorch
```

The PyTorch library will be extracted in the current directory `./libtorch`.

Then build and install WasmEdge from source:

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""PyTorch""
cmake --build build
# For the WASI-NN plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-NN plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_nn/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-NN with PyTorch backend plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiNN.so` after installation.

## Build WasmEdge with WASI-NN TensorFlow-Lite Backend

You can build and install WasmEdge from source directly (on `Linux x86_64`, `Linux aarch64`, `MacOS x86_64`, or `MacOS arm64` platforms):

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""TensorflowLite""
cmake --build build
# For the WASI-NN plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-NN plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_nn/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-NN with TensorFlow-lite backend plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiNN.so` after installation.

Installing the necessary `libtensorflowlite_c.so` and `libtensorflowlite_flex.so` on both `Ubuntu 20.04` and `manylinux2014` for the backend, we recommend the following commands:

```bash
curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
tar -zxf WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
rm -f WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
```

The shared library will be extracted in the current directory `./libtensorflowlite_c.so` and `./libtensorflowlite_flex.so`.

Then you can move the library to the installation path:

```bash
mv libtensorflowlite_c.so /usr/local/lib
mv libtensorflowlite_flex.so /usr/local/lib
```

Or set the environment variable `export LD_LIBRARY_PATH=$(pwd):${LD_LIBRARY_PATH}`.

<!-- prettier-ignore -->
:::note
We also provided the `darwin_x86_64`, `darwin_arm64`, and `manylinux_aarch64` versions of the TensorFlow-Lite pre-built shared libraries.
:::

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasi_nn).

## Build WasmEdge with WASI-NN llama.cpp Backend

You don't need to install any llama.cpp libraries. WasmEdge will download it during the building period.

Due to the acceleration frameworks being various, you will need to use different compilation options to build this plugin. Please make sure you are following the same OS section to do this.

### MacOS

#### Intel Model

If you are using the Intel Model macOS, we won't enable any acceleration framework. It is a pure CPU mode plugin.

```bash
cd <path/to/your/wasmedge/source/folder>
# Disable BLAS and METAL on x86_64 macOS.
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \
  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_METAL=OFF \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \
  .
cmake --build build
# For the WASI-NN plugin, you should install this project.
cmake --install build
```

#### Apple Silicon Model

You can build and install WasmEdge from source directly on the macOS arm64 platform. It will use the built-in GPU by default.

```bash
cd <path/to/your/wasmedge/source/folder>
# Enable METAL on arm64 macOS.
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \
  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_METAL=ON \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \
  .
cmake --build build
# For the WASI-NN plugin, you should install this project.
cmake --install build
```

### Linux

#### Ubuntu/Debian with CUDA 12

Please follow the official guide provided by NVIDIA for installing the CUDA framework: <https://developer.nvidia.com/cuda-12-2-0-download-archive>

```bash
cd <path/to/your/wasmedge/source/folder>

# You may need to install dependencies
apt update
apt install -y software-properties-common lsb-release \
  cmake unzip pkg-config

# Due to cuda-related files, it will produce some warning.
# Disable the warning as an error to avoid failures.
export CXXFLAGS=""-Wno-error""
# Please make sure you set up the correct CUDAARCHS.
# We use `60;61;70` for maximum compatibility.
export CUDAARCHS=""60;61;70""

# BLAS cannot work with CUBLAS
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \
  -DCMAKE_CUDA_ARCHITECTURES=""60;61;70"" \
  -DCMAKE_CUDA_COMPILER=/usr/local/cuda/bin/nvcc \
  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_CUBLAS=ON \
  .

cmake --build build

# For the WASI-NN plugin, you should install this project.
cmake --install build
```

#### Ubuntu on NVIDIA Jetson AGX Orin

You should use the pre-built OS image from the NVIDIA official site.

```bash
cd <path/to/your/wasmedge/source/folder>

# Due to cuda-related files, it will produce some warning.
# Disable the warning as an error to avoid failures.
export CXXFLAGS=""-Wno-error""
# Please make sure you set up the correct CUDAARCHS.
# 72 is for NVIDIA Jetson AGX Orin
export CUDAARCHS=72

# BLAS cannot work with CUBLAS
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \
  -DCMAKE_CUDA_COMPILER=/usr/local/cuda/bin/nvcc \
  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_CUBLAS=ON \
  .

cmake --build build

# For the WASI-NN plugin, you should install this project.
cmake --install build
```

#### Ubuntu/Debian with OpenBLAS

Please install OpenBLAS before building the plugin.

```bash
cd <path/to/your/wasmedge/source/folder>

# You may need to install dependencies
apt update
apt install -y software-properties-common lsb-release \
  cmake unzip pkg-config
# You must install OpenBLAS
apt install libopenblas-dev

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \
  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=ON \
  .

cmake --build build

# For the WASI-NN plugin, you should install this project.
cmake --install build
```

#### General Linux without any acceleration framework

```bash
cd <path/to/your/wasmedge/source/folder>

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \
  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \
  .

cmake --build build

# For the WASI-NN plugin, you should install this project.
cmake --install build
```

### Windows

#### Install Dependencies

1. (Optional, skip this deps if you don't need to use GPU) Download and install CUDA toolkit
    - We use CUDA Toolkit 12 for the release assets
    - Link: https://developer.nvidia.com/cuda-downloads?target_os=Windows&target_arch=x86_64&target_version=11&target_type=exe_local

2. Download and install Visual Studio 2022 Community Edition
    - Link: https://visualstudio.microsoft.com/vs/community/
    - Select the following components in the installer:
        - msvc v143 - vs 2022 c++ x64/x86 build tools (latest)
        - windows 11 sdk (10.0.22621.0)
        - C++ ATL for v143 build tools (x86 & x64)

3. Download and install cmake
    - We use cmake 3.29.3 for the release assets
    - Link: https://github.com/Kitware/CMake/releases/download/v3.29.3/cmake-3.29.3-windows-x86_64.msi

5. Download and install git
    - We use git 2.45.1
    - Link: https://github.com/git-for-windows/git/releases/download/v2.45.1.windows.1/Git-2.45.1-64-bit.exe

6. Download and install ninja-build
    - We use ninja-build 1.12.1
    - Link: https://github.com/ninja-build/ninja/releases/download/v1.12.1/ninja-win.zip
    - Installation: just unzip it to a custom folder

#### Build

1. Open Developer PowerShell for VS 2022
    - Start -> Visual Studio 2022 -> Visual Studio Tools -> Developer PowerShell for VS 2022

2. Inside the PowerShell, use git to download wasmedge repo

```console
cd $HOME
git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
```

3. Compile wasmedge with enabling the `wasi_nn_ggml` related options, please use the following commands. To build the plugin, you don't need to enable AOT/LLVM related features, so set them to OFF.

##### CUDA Enable

```console
# CUDA ENABLE:
& ""C:\Program files\CMake\bin\cmake.exe"" -Bbuild -GNinja -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=ggml -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_CUBLAS=ON -DWASMEDGE_USE_LLVM=OFF .
& ""<the ninja-build folder>\ninja.exe"" -C build
```

##### CUDA Disable

```console
# CUDA DISABLE:
& ""C:\Program files\CMake\bin\cmake.exe"" -Bbuild -GNinja -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=ggml -DWASMEDGE_USE_LLVM=OFF .
& ""<the ninja-build folder>\ninja.exe"" -C build
```

#### Execute the WASI-NN plugin with the llama example

1. Set the environment variables

```console
$env:PATH += "";$pwd\build\lib\api""
$env:WASMEDGE_PLUGIN_PATH = ""$pwd\build\plugins""
```

2. Download the wasm and run

```console
wget https://github.com/second-state/WasmEdge-WASINN-examples/raw/master/wasmedge-ggml/llama/wasmedge-ggml-llama.wasm
wget https://huggingface.co/QuantFactory/Meta-Llama-3-8B-Instruct-GGUF/blob/main/Meta-Llama-3-8B-Instruct.Q5_K_M.gguf
wasmedge --dir .:. --env llama3=true --env n_gpu_layers=100 --nn-preload default:GGML:AUTO:Meta-Llama-3-8B-Instruct.Q5_K_M.gguf wasmedge-ggml-llama.wasm default
```

### Appendix

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-NN plugin, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plugin installation path (such as `/usr/local/lib/wasmedge/` or the built plugin path `build/plugins/wasi_nn/`) to try to fix this issue.
:::

<!-- prettier-ignore -->
:::note
We also provided the pre-built ggml plugins on the following platforms:

- darwin\_x86\_64: Intel Model macOS
- darwin\_arm64: Apple Silicon Model macOS
- ubuntu20.04\_x86\_64: x86\_64 Linux (the glibc is using Ubuntu20.04 one)
- ubuntu20.04\_aarch64: aarch64 Linux (the glibc is using Ubuntu20.04 one)
- ubuntu20.04\_blas\_x86\_64: x86\_64 Linux with OpenBLAS support (the glibc is using Ubuntu20.04 one)
- ubuntu20.04\_blas\_aarch64: aarch64 Linux with OpenBLAS support (the glibc is using Ubuntu20.04 one)
- ubuntu20.04\_cuda\_x86\_64: x86\_64 Linux with CUDA 12 support (the glibc is using Ubuntu20.04 one)
- ubuntu20.04\_cuda\_aarch64: aarch64 Linux with CUDA 11 support (the glibc is using Ubuntu20.04 one), for NVIDIA Jetson AGX Orin
- manylinux2014\_x86\_64: x86\_64 Linux (the glibc is using CentOS 7 one)
- manylinux2014\_aarch64: aarch64 Linux (the glibc is using CentOS 7 one)

:::

## Build WasmEdge with WASI-NN Neural Speed Backend

The Neural Speed backend relies on Neural Speed, we recommend the following commands to install Neural Speed.

```bash
sudo apt update
sudo apt upgrade
sudo apt install python3-dev
wget https://raw.githubusercontent.com/intel/neural-speed/main/requirements.txt
pip install -r requirements.txt
pip install neural-speed
```

Then build and install WasmEdge from source:

```bash
cd <path/to/your/wasmedge/source/folder>

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""neuralspeed""
cmake --build build

# For the WASI-NN plugin, you should install this project.
cmake --install build
```

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-NN with Neural Speed backend plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiNN.so` after installation.

## Build WasmEdge with WASI-NN Piper Backend

Build and install WasmEdge from source:

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""Piper""
cmake --build build
# For the WASI-NN plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-NN plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_nn/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-NN with Piper backend plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiNN.so` after installation.

## Build WasmEdge with WASI-NN ChatTTS Backend

The ChatTTS backend relies on ChatTTS and Python library, we recommend the following commands to install dependencies.
```bash
sudo apt update
sudo apt upgrade
sudo apt install python3-dev
pip install chattts==0.1.1
```

Then build and install WasmEdge from source:

``` bash
cd <path/to/your/wasmedge/source/folder>

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""chatTTS""
cmake --build build

# For the WASI-NN plugin, you should install this project.
cmake --install build
```


<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-NN plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_nn/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-NN with ChatTTS backend plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiNN.so` after installation.
","The provided code is a documentation for building and installing the WasmEdge runtime with various machine learning (ML) backend plugins, including WASI-NN, using different programming languages such as C++, Python, and Rust. The code explains how to build and install the WasmEdge runtime from source, along with specific instructions for each ML backend plugin.

Here is a summary of the key components and functionality:

*   **WASMEDGE_PLUGIN_WASI_NN_BACKEND**: A cmake option used to specify the backend plugin to be enabled.
*   **Build and Install WasmEdge**: The code provides instructions on how to build and install WasmEdge from source, including using the Ninja build system.
*   **WASI-NN Backend Plugins**: The code explains how to build and install various WASI-NN backend plugins, including:
    *   **OpenVINO Backend**: Instructions for installing OpenVINO on Ubuntu 20.04 and building WasmEdge with the OpenVINO backend.
    *   **PyTorch Backend**: Instructions for installing PyTorch on Ubuntu 20.04 and building WasmEdge with the PyTorch backend.
    *   **TensorFlow-Lite Backend**: Instructions for building WasmEdge with the TensorFlow-lite backend.
    *   **LLAMA.cpp Backend**: Instructions for building WasmEdge with the LLAMA.cpp backend, including options for various acceleration frameworks such as CUDA and OpenBLAS.
    *   **Neural Speed Backend**: Instructions for installing Neural Speed and building WasmEdge with the Neural Speed backend.
    *   **Piper Backend**: Instructions for building WasmEdge with the Piper backend.
    *   **ChatTTS Backend**: Instructions for installing dependencies and building WasmEdge with the ChatTTS backend.

The code also provides notes on potential issues, such as setting the `WASMEDGE_PLUGIN_PATH` environment variable to fix installation issues."
docs/start/build-and-run/cli.md,"---
sidebar_position: 1
---

# The `wasmedge` CLI

After installing WasmEdge, you can use the `wasmedge` CLI to execute WASM files. We will cover how to run WASM files with WasmEdge on your machine and Docker images.

The `wasmedge` binary is a command line interface (CLI) program that runs WebAssembly programs.

- If the WebAssembly program contains a `main()` function, `wasmedge` would execute it as a standalone program in the command mode.
- If the WebAssembly program contains one or more exported public functions, `wasmedge` could invoke individual functions in the reactor mode.

By default, the `wasmedge` will execute WebAssembly programs in interpreter mode and execute the AOT-compiled `.so`, `.dylib`, `.dll`, or `.wasm` (universal output format) in AOT mode. If you want to accelerate the WASM execution, we recommend to [compile the WebAssembly with the AOT compiler](aot.md) first.

<!-- prettier-ignore -->
:::note
The original `wasmedgec` tool is changed to `wasmedge compile`. The [`wasmedge compile` CLI tool](aot.md) is the ahead-of-time compiler to compile the WebAssembly file into native code.
:::

```bash
$ wasmedge -v
wasmedge version {{ wasmedge_version }}
```

Users can run the `wasmedge -h` to realize the command line options quickly or [refer to the detailed `wasmedge` CLI options here](#options). The usage of the `wasmedge` tool will be:

```bash
$ wasmedge -h
USAGE
   wasmedge [OPTIONS] [--] WASM_OR_SO [ARG ...]

...
```

The `wasmedge` CLI tool will execute the wasm file in ahead-of-time(AOT) mode or interpreter mode. If the file has been compiled with `wasmedge compile`, then WasmEdge will execute it in AOT mode, otherwise, WasmEdge will execute it in interpreter mode.

## Options

The options of the `wasmedge` CLI tool are as follows:

1. `-v|--version`: Show the version information. Will ignore other arguments below.
2. `-h|--help`: Show the help messages. Will ignore other arguments below.
3. _(Optional)_ `--reactor`: Enable the reactor mode.
   - In the reactor mode, `wasmedge` runs a specified function exported by the WebAssembly program.
   - WasmEdge will execute the function whose name should be given in `ARG[0]`.
   - If an exported function names `_initialize`, the function will be executed with the empty parameter at first.
4. _(Optional)_ `--dir`: Bind directories into WASI virtual filesystem.
   - Use `--dir guest_path:host_path` to bind the host path into the guest path in WASI virtual system.
5. _(Optional)_ `--env`: Assign the environment variables in WASI.
   - Use `--env ENV_NAME=VALUE` to assign the environment variable.
6. _(Optional)_ Statistics information:
   - Use `--enable-time-measuring` to show the execution time.
   - Use `--enable-gas-measuring` to show the amount of used gas.
   - Use `--enable-instruction-count` to display the number of executed instructions.
   - Or use `--enable-all-statistics` to enable all of the statistics options.
7. _(Optional)_ Resource limitations:
   - Use `--time-limit MILLISECOND_TIME` to limit the execution time. Default value is `0` which specifies no limitation.
   - Use `--gas-limit GAS_LIMIT` to limit the execution cost.
   - Use `--memory-page-limit PAGE_COUNT` to set the limitation of pages(as size of 64 KiB) in every memory instance.
8. _(Optional)_ Execution mode:
   - Use `--force-interpreter` to forcibly run WASM in interpreter mode.
   - Use `--enable-jit` to enable Just-In-Time compiler for running WASM.
9. _(Optional)_ WebAssembly proposals:
   - Use `--disable-import-export-mut-globals` to disable the [Import/Export of Mutable Globals](https://github.com/WebAssembly/mutable-global) proposal (Default `ON`).
   - Use `--disable-non-trap-float-to-int` to disable the [Non-Trapping Float-to-Int Conversions](https://github.com/WebAssembly/nontrapping-float-to-int-conversions) proposal (Default `ON`).
   - Use `--disable-sign-extension-operators` to disable the [Sign-Extension Operators](https://github.com/WebAssembly/sign-extension-ops) proposal (Default `ON`).
   - Use `--disable-multi-value` to disable the [Multi-value](https://github.com/WebAssembly/multi-value) proposal (Default `ON`).
   - Use `--disable-bulk-memory` to disable the [Bulk Memory Operations](https://github.com/WebAssembly/bulk-memory-operations) proposal (Default `ON`).
   - Use `--disable-reference-types` to disable the [Reference Types](https://github.com/WebAssembly/reference-types) proposal (Default `ON`).
   - Use `--disable-simd` to disable the [Fixed-width SIMD](https://github.com/webassembly/simd) proposal (Default `ON`).
   - Use `--enable-multi-memory` to enable the [Multiple Memories](https://github.com/WebAssembly/multi-memory) proposal (Default `OFF`).
   - Use `--enable-tail-call` to enable the [Tail call](https://github.com/WebAssembly/tail-call) proposal (Default `OFF`).
   - Use `--enable-extended-const` to enable the [Extended Constant Expressions](https://github.com/WebAssembly/extended-const) proposal (Default `OFF`).
   - Use `--enable-threads` to enable the [Threads](https://github.com/webassembly/threads) proposal (Default `OFF`).
   - Use `--enable-function-reference` to enable the [Typed-Function References](https://github.com/WebAssembly/function-references) proposal (Default `OFF`).
   - Use `--enable-gc` to enable the [GC](https://github.com/WebAssembly/gc) proposal (Default `OFF`, interpreter mode only).
   - Use `--enable-exception-handling` to enable the [Exception Handling](https://github.com/WebAssembly/exception-handling) proposal (Default `OFF`, interpreter mode only).
   - Use `--enable-component` to enable the [Component Model](https://github.com/WebAssembly/component-model) proposal (Default `OFF`, loader phase only).
   - Use `--enable-all` to enable ALL proposals above.
10. WASM file (`/path/to/wasm/file`).
11. _(Optional)_ `ARG` command line arguments array.
    - In reactor mode, the first argument will be the function name, and the arguments after `ARG[0]` will be parameters of wasm function `ARG[0]`.
    - In command mode, the arguments will be the command line arguments of the WASI `_start` function. They are also known as command line arguments(`argv`) for a standalone C/C++ program.

## TensorFlow Tools

<!-- prettier-ignore -->
:::note
The `WasmEdge-tensorflow-tools` has been deprecated after the 0.12.1 version and replaced by the plug-ins after the 0.13.0 version.
:::

If users install WasmEdge from the install script with the option `-e tf,image`, the WasmEdge CLI tools with TensorFlow and TensorFlow-Lite extensions will also be installed.

- `wasmedge-tensorflow` CLI tool
  - The `wasmedge` tool with TensorFlow, TensorFlow-Lite, and `wasmedge-image` extensions.
  - Only on `x86_64` and `aarch64` Linux platforms and `x86_64` MacOS.
- `wasmedge-tensorflow-lite` CLI tool
  - The `wasmedge` tool with TensorFlow-Lite, and `wasmedge-image` extensions.
  - Only on `x86_64` and `aarch64` Linux platforms, Android, and `x86_64` MacOS.

## Examples

### Build and run a standalone WebAssembly app

The Hello World example is a standalone Rust application that can be executed by the [WasmEdge CLI](../build-and-run/cli). Its source code and build instructions are available [here](https://github.com/second-state/rust-examples/tree/main/hello).

You will need to have the [Rust compiler installed](https://github.com/second-state/rust-examples/blob/main/README.md#prerequisites), and then use the following command to build the WASM bytecode file from the Rust source code.

```bash
cargo build --target wasm32-wasi --release
```

You can then use the `wasmedge` command to run the program.

```bash
$ wasmedge target/wasm32-wasi/release/hello.wasm
Hello WasmEdge!
```

#### Execute with `statistics` enabled

The CLI supports `--enable-all-statistics` flags for the statistics and gas metering.

You can run:

```bash
wasmedge --enable-all-statistics hello.wasm
```

The output will be:

```bash
Hello WasmEdge!
[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================
[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns
[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns
[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns
[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425
[2021-12-09 16:03:33.261] [info]  Gas costs: 20425
[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218
[2021-12-09 16:03:33.261] [info] =======================   End   ======================
```

#### Execute with `gas-limit` enabled

The CLI supports `--gas-limit` flags for controlling the execution costs.

For giving sufficient gas as the example, you can run:

```bash
wasmedge --enable-all-statistics --gas-limit 20425 hello.wasm
```

The output will be:

```bash
Hello WasmEdge!
[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================
[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns
[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns
[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns
[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425
[2021-12-09 16:03:33.261] [info]  Gas costs: 20425
[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218
[2021-12-09 16:03:33.261] [info] =======================   End   ======================
```

For giving insufficient gas as the example, you can run:

```bash
wasmedge --enable-all-statistics --gas-limit 20 hello.wasm
```

The output will be:

```bash
Hello WasmEdge!
[2021-12-23 15:19:06.690] [error] Cost exceeded limit. Force terminate the execution.
[2021-12-23 15:19:06.690] [error]     In instruction: ref.func (0xd2) , Bytecode offset: 0x00000000
[2021-12-23 15:19:06.690] [error]     At AST node: expression
[2021-12-23 15:19:06.690] [error]     At AST node: element segment
[2021-12-23 15:19:06.690] [error]     At AST node: element section
[2021-12-23 15:19:06.690] [error]     At AST node: module
[2021-12-23 15:19:06.690] [info] ====================  Statistics  ====================
[2021-12-23 15:19:06.690] [info]  Total execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Wasm instructions execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Host functions execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Executed wasm instructions count: 21
[2021-12-23 15:19:06.690] [info]  Gas costs: 20
```

### Call a WebAssembly function compiled from Rust

The [add](https://github.com/second-state/wasm-learning/tree/master/cli/add) program is written in Rust and contains an exported `add()` function. You can compile it into WebAssembly and use `wasmedge` to call the `add()` function. In this example, you will see how it is done from the CLI. It is often used when you embed WasmEdge into another host application, and need to call a WASM function from the host.

You will need to have the [Rust compiler](https://github.com/second-state/rust-examples/blob/main/README.md#prerequisites) installed, and then use the following command to build the WASM bytecode file from the Rust source code.

```bash
cargo build --target wasm32-wasi --release
```

You can execute `wasmedge` in reactor mode to invoke the `add()` function with two `i32` integer input parameters.

```bash
wasmedge --reactor add.wasm add 2 2
```

The output will be:

```bash
4
```

### Call a WebAssembly function written in WAT

We created the hand-written [fibonacci.wat](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wat) and used the [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) tool to convert it into the `fibonacci.wasm` WebAssembly program. It exported a `fib()` function which takes a single `i32` integer as the input parameter. We can execute `wasmedge` in reactor mode to invoke the exported function.

You can run:

```bash
wasmedge --reactor fibonacci.wasm fib 10
```

The output will be:

```bash
89
```

### JavaScript examples

Using WasmEdge as a high-performance, secure, extensible, easy-to-deploy, and [Kubernetes-compliant](https://github.com/second-state/wasmedge-containers-examples) JavaScript runtime is possible. There is no need to build a JavaScript app. You need to download the WasmEdge JavaScript runtime for Node.js.

- [Download the wasmedge_quickjs.wasm file here](https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm)
- [Download the modules.zip file here](https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip) and then unzip it into the current folder as `./modules/`

```bash
wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm
wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip
unzip modules.zip
```

Take a simple Javascript file for example. Save the following code as `hello.js`:

```javascript
args = args.slice(1);
print('Hello', ...args);
```

You can run:

```bash
wasmedge --dir .:. wasmedge_quickjs.wasm hello.js 1 2 3
```

The output will be:

```bash
Hello 1 2 3
```

The [qjs_tf.wasm](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/js/qjs_tf.wasm) is a JavaScript interpreter with [WasmEdge Tensorflow extension](https://www.secondstate.io/articles/wasi-tensorflow/) compiled into WebAssembly. To run [qjs_tf.wasm](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/js/qjs_tf.wasm), you must use the `wasmedge-tensorflow-lite` CLI tool, which is a build of WasmEdge with Tensorflow-Lite extension built-in. You can download a full [Tensorflow-based JavaScript example](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo) to classify images.

```bash
# Download the Tensorflow example
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js

$ wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js
label: Hot dog
confidence: 0.8941176470588236
```

## Docker images for the CLI tools

The Docker images in this section are mostly used for development purposes. They allow you to use WasmEdge tools in containerized Linux environments. If you want to containerize WASM apps, check out [this](../getting-started/quick_start_docker.md) section.

The `wasmedge/slim:{version}` Docker images provide a slim WasmEdge images built with [DockerSlim](https://dockersl.im) every releases.

- Image `wasmedge/slim-runtime:{version}` includes only WasmEdge runtime with `wasmedge` command.
- Image `wasmedge/slim:{version}` includes the following command line utilities:
  - `wasmedge`
  - `wasmedge compile`
- Image `wasmedge/slim-tf:{version}` includes the following command line utilities (DEPRECATED after 0.13.0):
  - `wasmedge`
  - `wasmedge compile`
  - `wasmedge-tensorflow-lite`
  - `wasmedge-tensorflow`
  - `show-tflite-tensor`
- The working directory of the release docker image is `/app`.

### Dockerslim Examples

After pulling the docker image successfully, you could use `wasmedge compile` and `wasmedge` to aot compile the wasm file and run the wasm app.

```bash
$ docker pull wasmedge/slim:{{ wasmedge_version }}

$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge compile hello.wasm hello.aot.wasm
[2022-07-07 08:15:49.154] [info] compile start
[2022-07-07 08:15:49.163] [info] verify start
[2022-07-07 08:15:49.169] [info] optimize start
[2022-07-07 08:15:49.808] [info] codegen start
[2022-07-07 08:15:50.419] [info] output start
[2022-07-07 08:15:50.421] [info] compile done
[2022-07-07 08:15:50.422] [info] output start

$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge hello.aot.wasm world
hello
world
```

Use `wasmedge-tensorflow-lite` ([link](https://github.com/WasmEdge/WasmEdge/tree/master/examples/js)):

<!-- prettier-ignore -->
:::note
The `WasmEdge-tensorflow-tools` has been deprecated after the 0.12.1 version. We'll update to use the WasmEdge plug-in in the future.
:::

```bash
$ docker pull wasmedge/slim-tf:0.12.1
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js

$ docker run -it --rm -v $PWD:/app wasmedge/slim-tf:0.12.1 wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js
label:
Hot dog
confidence:
0.8941176470588236
```
","The code is a part of the documentation for the WasmEdge CLI tool, which is used to execute WebAssembly (WASM) files. Here's a concise summary:

**Purpose:** The WasmEdge CLI tool is used to run WASM files using the WasmEdge engine.

**Key Components:**

1. **Command Line Interface (CLI):** The `wasmedge` command-line tool is the primary interface for running WASM files.
2. **WASM Execution Modes:** The CLI supports two execution modes:
	* Interpreter Mode: Default mode, which runs WASM programs in an interpreter-based environment.
	* AOT (Ahead-of-Time) Mode: Runs compiled WASM programs using native code generation.
3. **Arguments and Options:**
	* `--reactor`: Enables reactor mode for executing specific functions exported by the WASM program.
	* `--dir`: Specifies directories to bind into the WASI virtual filesystem.
	* `--env`: Assigns environment variables in the WASI virtual system.
	* Statistics options (`--enable-time-measuring`, `--enable-gas-measuring`, etc.): Enables various statistics and gas metering features.
4. **Docker Images:** Docker images are available for development purposes, allowing users to use WasmEdge tools in containerized Linux environments.

**Key Features:**

1. **Compilation Support:** The CLI tool supports compilation of WASM files using the `wasmedge compile` command.
2. **TensorFlow and TensorFlow-Lite Integration:** The `wasmedge-tensorflow-lite` command is used for integrating WasmEdge with TensorFlow Lite.

**Best Practices:**

1. Use the `wasmedge` CLI tool to run WASM programs in interpreter mode or AOT mode, depending on the specific requirements.
2. Utilize the various options and arguments provided by the CLI tool to customize the execution of WASM programs.
3. Consider using Docker images for development purposes.

Overall, the WasmEdge CLI tool provides a flexible and powerful interface for executing WASM files, making it an essential tool for WebAssembly developers and enthusiasts."
docs/start/build-and-run/docker_wasm.md,"---
sidebar_position: 4
---

# Docker + WASM

The Docker Desktop distributes with the WasmEdge Runtime embedded. That allows developers to build, share and run very lightweight containers (i.e., a `scratch` empty container with only the `.wasm` file without any Linux OS libraries or files) through Docker tools. Those ""WASM containers"" are fully OCI-compliant and hence can be managed by Docker Hub. They are cross-platform and can run on any OS / CPU Docker supports (the OS and CPU platform is `wasi/wasm`). But most importantly, they are 1/10 of the size of a comparable Linux container and start up in 1/10 of the time, as the WASM containers do not need to bundle and start Linux libraries and services.

Together with Docker's capability to containerize developer and deployment environments, you can create and deploy complex applications without installing any dependencies. For example, you could setup a complete Rust and WasmEdge development environment without installing either tool on your local dev machine. You can also deploy a complex WasmEdge app that needs to connect to a MySQL database without having to install MySQL locally.

In this guide, we will cover how to:

- [Create and run a Rust program](#create-and-run-a-rust-program)
- [Create and run a node.js server](#create-and-run-a-nodejs-server)
- [Create and deploy a database driven microservice in Rust](#create-and-deploy-a-database-driven-microservice-in-rust)

## Prerequisite

Install [Docker Desktop](https://www.docker.com/products/docker-desktop/) and turn on the containerd image store feature in your Docker Desktop settings.

![Docker config](docker_config.png)

## Create and run a Rust program

With Docker + WASM, you can use the entire Rust toolchain in a Docker container to build the WASM bytecode application, and then publish and run the WASM application. The [example Rust source code and build instructions are available here](https://github.com/second-state/rust-examples/tree/main/hello).

### Build the rust example

In the project directory, run the following command to build the Rust source code into WASM and then package the WASM file into an empty container image. Notice that you do not need to install the Rust compiler toolchain here.

```bash
docker buildx build --platform wasi/wasm -t secondstate/rust-example-hello .
```

The [Dockerfile](https://github.com/second-state/rust-examples/blob/main/hello/Dockerfile) shows how it is done. The Dockerfile has three parts. The first part sets up a Docker container for the Rust build environment.

```dockerfile
FROM --platform=$BUILDPLATFORM rust:1.64 AS buildbase
WORKDIR /src
RUN <<EOT bash
    set -ex
    apt-get update
    apt-get install -y \
        git \
        clang
    rustup target add wasm32-wasi
EOT
```

The second part uses the Rust build environment to compile the Rust source code and generate the WASM file.

```dockerfile
FROM buildbase AS build
COPY Cargo.toml .
COPY src ./src
# Build the WASM binary
RUN cargo build --target wasm32-wasi --release
```

The third part is the essential. It copies the WASM file into an empty `scratch` container and then set the WASM file as the `ENTRYPOINT` of the container. It is the container image `rust-example-hello` built by the command in this section.

```dockerfile
FROM scratch
ENTRYPOINT [ ""hello.wasm"" ]
COPY --link --from=build /src/target/wasm32-wasi/release/hello.wasm /hello.wasm
```

The WASM container image is only 0.5MB. It is much smaller than a natively compiled Rust program in a minimal Linux container.

### Publish the rust example

To publish the WASM container image to Docker Hub, do the following.

```bash
docker push secondstate/rust-example-hello
```

### Run the rust example

You can use the regular Docker `run` command to run the WASM container application. Notice that you do need to specify the `runtime` and `platform` flags to tell Docker that this is a non-Linux container and requires WasmEdge to run it.

```bash
$ docker run --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/rust-example-hello:latest
Hello WasmEdge!
```

That's it.

### Further reading for the rust example

To see more Dockerized Rust example apps for WasmEdge, check out the following.

- [Use Rust standard libraries](https://github.com/second-state/rust-examples/tree/main/wasi)
- [Create a HTTP server in hyper and tokio](https://github.com/second-state/rust-examples/tree/main/server)

## Create and run a node.js server

WasmEdge provides a node.js compatible JavaScript runtime. You can create lightweight WASM container images that runs node.js apps. Compared with standard node.js Linux container images, the WASM images are 1/100 of the size, completely portable, and starts up in 1/10 of the time.

In this guide, the example app is an HTTP web server written in node.js. Its [source code and build instructions are available here](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/docker_wasm/server).

### Build the node.js example

In the project directory, run the following command to package the WasmEdge JavaScript runtime and the JS HTTP server program into an empty container image.

```bash
docker buildx build --platform wasi/wasm -t secondstate/node-example-hello .
```

The [Dockerfile](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/docker_wasm/server/Dockerfile) shows how it is done. The Dockerfile has three parts. The first part sets up a Docker container for the `wget` and `unzip` utilities.

```dockerfile
FROM --platform=$BUILDPLATFORM rust:1.64 AS buildbase
WORKDIR /src
RUN <<EOT bash
    set -ex
    apt-get update
    apt-get install -y \
        wget unzip
EOT
```

The second part uses `wget` and `unzip` to download and extract the WasmEdge JavaScript runtime files and the JS application files into a build container.

```dockerfile
FROM buildbase AS build
COPY server.js .
RUN wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm
RUN wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip
RUN unzip modules.zip
```

The third part is the essential. It copies the WasmEdge JavaScript runtime files and the JS application files into an empty `scratch` container and then set the `ENTRYPOINT`. It is the container image `node-example-hello` built by the command in this section.

```dockerfile
FROM scratch
ENTRYPOINT [ ""wasmedge_quickjs.wasm"", ""server.js"" ]
COPY --link --from=build /src/wasmedge_quickjs.wasm /wasmedge_quickjs.wasm
COPY --link --from=build /src/server.js /server.js
COPY --link --from=build /src/modules /modules
```

The WASM container image for the entire node.js app is only 1MB. It is much smaller than a standard node.js image, which is 300+MB.

### Publish the node.js example

To publish the WASM container image to Docker Hub, do the following.

```bash
docker push secondstate/node-example-hello
```

### Run and test the node.js example

You can use the regular Docker `run` command to run the WASM container application. Notice that you do need to specify the `runtime` and `platform` flags to tell Docker that this is a non-Linux container and requires WasmEdge to run it. Since this is an HTTP server app, you also need to map the container port 8080 to host so that you can access the server from the host.

```bash
$ docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/node-example-server:latest
listen 8080 ...
```

From another terminal, test the server application.

```bash
$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

That's it.

### Further reading for the node.js example

- [Use the fetch() API](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js)
- [Image classification using Tensorflow Lite](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo)

## Create and deploy a database driven microservice in Rust

Docker + wasm allows us to build and run WASM containers. However, in most complex applications, the WASM container is only part of the application. It needs to work together with other Linux containers in the system. The [Docker compose](https://docs.docker.com/compose/) tool is widely used to compose and manage multi-container deployments. It is installed with Docker Desktop.

In our [example microservice application](https://github.com/second-state/microservice-rust-mysql), there is an Nginx web server and a MySQL database. The WASM container is only for the Rust application that accesses the database and processes the HTTP requests (i.e., the application server).

<!-- prettier-ignore -->
:::note
For more Docker compose examples, including Linux containers + WASM containers mixed deployments, check out the [awesome-compose](https://github.com/docker/awesome-compose) repo.
:::

### Build the microservice example

In the project directory, run the following command to build all three containers: `client`, `server` and `db`.

```bash
docker compose up
```

There is a [docker-compose.yml](https://github.com/second-state/microservice-rust-mysql/blob/main/docker-compose.yml) file. It defines the 3 containers needed in this application.

```yaml
services:
  client:
    image: nginx:alpine
    ports:
      - 8090:80
    volumes:
      - ./client:/usr/share/nginx/html
  server:
    image: demo-microservice
    platform: wasi/wasm
    build:
      context: .
    ports:
      - 8080:8080
    environment:
      DATABASE_URL: mysql://root:whalehello@db:3306/mysql
      RUST_BACKTRACE: full
    restart: unless-stopped
    runtime: io.containerd.wasmedge.v1
  db:
    image: mariadb:10.9
    environment:
      MYSQL_ROOT_PASSWORD: whalehello
```

- The `client` container is an Nginx web server
  - Linux container with mapped HTTP port and volume for the static HTML/JS files
- The `server` container is a Rust container for the business logic
  - The WASM container is built from [Rust source code](https://github.com/second-state/microservice-rust-mysql/blob/main/src/main.rs) using this [Dockerfile](https://github.com/second-state/microservice-rust-mysql/blob/main/Dockerfile)
  - WASM container with mapped web service port and an environment variable for the database connection string
- The `db` container is a MySQL database
  - Linux container with a pre-set database password

### Deploy the microservice example

Start and run all three containers in the correct order with one command.

```bash
docker compose up
```

Go back to Docker Desktop Dash board, you will see there're three containers running.

![Docker](docker.jpeg)

### CRUD tests

Open another terminal, and you can use the `curl` command to interact with the web service.

When the microservice receives a `GET` request to the `/init` endpoint, it would initialize the database with the `orders` table.

```bash
curl http://localhost:8080/init
```

When the microservice receives a `POST` request to the `/create_order` endpoint, it would extract the JSON data from the `POST` body and insert an `Order` record into the database table. For multiple records, use the `/create_orders` endpoint and `POST` a JSON array of `Order` objects.

```bash
curl http://localhost:8080/create_orders -X POST -d @orders.json
```

When the microservice receives a `GET` request to the `/orders` endpoint, it would get all rows from the `orders` table and return the result set in a JSON array in the HTTP response.

```bash
curl http://localhost:8080/orders
```

When the microservice receives a `POST` request to the `/update_order` endpoint, it would extract the JSON data from the `POST` body and update the `Order` record in the database table that matches the `order_id` in the input data.

```bash
curl http://localhost:8080/update_order -X POST -d @update_order.json
```

When the microservice receives a `GET` request to the `/delete_order` endpoint, it would delete the row in the `orders` table that matches the `id` `GET` parameter.

```bash
curl http://localhost:8080/delete_order?id=2
```

That's it. Feel free to fork this project and use it as a template for your own lightweight microservices!

### Further reading for the microservice example

To learn how Docker + WASM works under the hood, visit the [containerd](../../develop/deploy/cri-runtime/containerd.md) chapter for more details.
","**Code Analysis**

The provided code is a guide on how to create and deploy complex applications using Docker + WASM. The code consists of three examples:

1. **Rust Example**: A simple ""Hello World"" application written in Rust that uses the WasmEdge JavaScript runtime.
2. **Node.js Example**: An HTTP web server written in Node.js that uses the WasmEdge QuickJS engine.
3. **Microservice Example**: A database-driven microservice in Rust that interacts with an Nginx web server and a MySQL database.

**Key Components**

1. **Docker Compose**: Used to compose and manage multi-container deployments.
2. **WasmEdge JavaScript Runtime**: A Wasm-based JavaScript engine used in the Rust and Node.js examples.
3. **Containerd**: A container runtime that allows for the creation and execution of containers, including WASM containers.

**Potential Issues**

1. **Security**: The use of Docker + WASM may introduce security risks if not properly configured and managed.
2. **Performance**: The performance of WasmEdge may vary depending on the specific use case and workload.
3. **Debugging**: Debugging Wasm-based applications can be challenging due to the lack of native debugging tools.

**Areas for Improvement**

1. **Documentation**: The code could benefit from more detailed documentation, including explanations of the architecture and configuration options.
2. **Testing**: The code should include comprehensive testing to ensure that it is working as expected.
3. **Optimization**: The performance of WasmEdge can be optimized by adjusting settings and using caching mechanisms.

Overall, the provided code is a good starting point for creating and deploying complex applications using Docker + WASM. However, further development and refinement are needed to make it more robust and production-ready."
docs/start/usage/serverless/aws.md,"---
sidebar_position: 1
---

# WebAssembly Serverless Functions in AWS Lambda

In this article, we will show you two serverless functions in Rust and WasmEdge deployed on AWS Lambda. One is the image processing function, the other one is the TensorFlow inference function.

> For the insight on why WasmEdge on AWS Lambda, please refer to the article [WebAssembly Serverless Functions in AWS Lambda](https://www.secondstate.io/articles/webassembly-serverless-functions-in-aws-lambda/)

## Prerequisites

Since our demo WebAssembly functions are written in Rust, you will need a [Rust compiler](https://www.rust-lang.org/tools/install). Make sure that you install the `wasm32-wasi` compiler target as follows, in order to generate WebAssembly bytecode.

```bash
rustup target add wasm32-wasi
```

The demo application front end is written in [Next.js](https://nextjs.org/), and deployed on AWS Lambda. We will assume that you already have the basic knowledge of how to work with Next.js and Lambda.

## Example 1: Image processing

Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A [live demo](https://second-state.github.io/aws-lambda-wasm-runtime/) deployed through GitHub Pages is available.

Fork the [demo application’s GitHub repo](https://github.com/second-state/aws-lambda-wasm-runtime) to get started. To deploy the application on AWS Lambda, follow the guide in the repository [README](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md).

### Create the function

This repo is a standard Next.js application. The backend serverless function is in the `api/functions/image_grayscale` folder. The `src/main.rs` file contains the Rust program’s source code. The Rust program reads image data from the `STDIN`, and then outputs the black-white image to the `STDOUT`.

```rust
use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&buf).unwrap();
  let img = image::load_from_memory(&buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif => {
      filtered.write_to(&mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ => {
      filtered.write_to(&mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&buf).unwrap();
  io::stdout().flush().unwrap();
}
```

You can use Rust’s `cargo` tool to build the Rust program into WebAssembly bytecode or native code.

```bash
cd api/functions/image-grayscale/
cargo build --release --target wasm32-wasi
```

Copy the build artifacts to the `api` folder.

```bash
cp target/wasm32-wasi/release/grayscale.wasm ../../
```

> When we build the docker image, `api/pre.sh` is executed. `pre.sh` installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native `so` library for faster execution.

### Create the service script to load the function

The [`api/hello.js`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/hello.js) script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via `STDIN`. Notice that [`api/hello.js`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/hello.js) runs the compiled `grayscale.so` file generated by [`api/pre.sh`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/pre.sh) for better performance.

```javascript
const { spawn } = require('child_process');
const path = require('path');

function _runWasm(reqBody) {
  return new Promise((resolve) => {
    const wasmedge = spawn(path.join(__dirname, 'wasmedge'), [
      path.join(__dirname, 'grayscale.so'),
    ]);

    let d = [];
    wasmedge.stdout.on('data', (data) => {
      d.push(data);
    });

    wasmedge.on('close', (code) => {
      let buf = Buffer.concat(d);
      resolve(buf);
    });

    wasmedge.stdin.write(reqBody);
    wasmedge.stdin.end('');
  });
}
```

The `exports.handler` part of `hello.js` exports an async function handler, used to handle different events every time the serverless function is called. In this example, we simply process the image by calling the function above and return the result, but more complicated event-handling behavior may be defined based on your need. We also need to return some `Access-Control-Allow` headers to avoid [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) errors when calling the serverless function from a browser. You can read more about CORS errors [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors) if you encounter them when replicating our example.

```javascript
exports.handler = async function (event, context) {
  var typedArray = new Uint8Array(
    event.body.match(/[\da-f]{2}/gi).map(function (h) {
      return parseInt(h, 16);
    }),
  );
  let buf = await _runWasm(typedArray);
  return {
    statusCode: 200,
    headers: {
      'Access-Control-Allow-Headers':
        'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods':
        'DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT',
    },
    body: buf.toString('hex'),
  };
};
```

### Build the Docker image for Lambda deployment

Now we have the WebAssembly bytecode function and the script to load and connect to the web request. In order to deploy them as a function service on AWS Lambda, you still need to package the whole thing into a Docker image.

We are not going to cover in detail about how to build the Docker image and deploy on AWS Lambda, as there are detailed steps in the [Deploy section of the repository README](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md#deploy). However, we will highlight some lines in the [`Dockerfile`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/Dockerfile) for you to avoid some pitfalls.

```dockerfile
FROM public.ecr.aws/lambda/nodejs:14

# Change directory to /var/task
WORKDIR /var/task

RUN yum update -y && yum install -y curl tar gzip

# Bundle and pre-compile the wasm files
COPY *.wasm ./
COPY pre.sh ./
RUN chmod +x pre.sh
RUN ./pre.sh

# Bundle the JS files
COPY *.js ./

CMD [ ""hello.handler"" ]
```

First, we are building the image from [AWS Lambda's Node.js base image](https://hub.docker.com/r/amazon/aws-lambda-nodejs). The advantage of using AWS Lambda's base image is that it includes the [Lambda Runtime Interface Client (RIC)](https://github.com/aws/aws-lambda-nodejs-runtime-interface-client), which we need to implement in our Docker image as it is required by AWS Lambda. The Amazon Linux uses `yum` as the package manager.

> These base images contain the Amazon Linux Base operating system, the runtime for a given language, dependencies and the Lambda Runtime Interface Client (RIC), which implements the Lambda [Runtime API](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html). The Lambda Runtime Interface Client allows your runtime to receive requests from and send requests to the Lambda service.

Second, we need to put our function and all its dependencies in the `/var/task` directory. Files in other folders will not be executed by AWS Lambda.

Third, we need to define the default command when we start our container. `CMD [ ""hello.handler"" ]` means that we will call the `handler` function in `hello.js` whenever our serverless function is called. Recall that we have defined and exported the handler function in the previous steps through `exports.handler = ...` in `hello.js`.

### Optional: test the Docker image locally

Docker images built from AWS Lambda's base images can be tested locally following [this guide](https://docs.aws.amazon.com/lambda/latest/dg/images-test.html). Local testing requires [AWS Lambda Runtime Interface Emulator (RIE)](https://github.com/aws/aws-lambda-runtime-interface-emulator), which is already installed in all of AWS Lambda's base images. To test your image, first, start the Docker container by running:

```bash
docker run -p 9000:8080  myfunction:latest
```

This command sets a function endpoint on your local machine at `http://localhost:9000/2015-03-31/functions/function/invocations`.

Then, from a separate terminal window, run:

```bash
curl -XPOST ""http://localhost:9000/2015-03-31/functions/function/invocations"" -d '{}'
```

And you should get your expected output in the terminal.

If you don't want to use a base image from AWS Lambda, you can also use your own base image and install RIC and/or RIE while building your Docker image. Just follow **Create an image from an alternative base image** section from [this guide](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html).

That's it! After building your Docker image, you can deploy it to AWS Lambda following steps outlined in the repository [README](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md#deploy). Now your serverless function is ready to rock!

## Example 2: AI inference

The [second demo](https://github.com/second-state/aws-lambda-wasm-runtime/tree/tensorflow) application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.

It is in [the same GitHub repo](https://github.com/second-state/aws-lambda-wasm-runtime/tree/tensorflow) as the previous example but in the `tensorflow` branch. The backend serverless function for image classification is in the `api/functions/image-classification` folder in the `tensorflow` branch. The `src/main.rs` file contains the Rust program’s source code. The Rust program reads image data from the `STDIN`, and then outputs the text output to the `STDOUT`. It utilizes the WasmEdge Tensorflow API to run the AI inference.

```rust
pub fn main() {
  // Step 1: Load the TFLite model
  let model_data: &[u8] = include_bytes!(""models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite"");
  let labels = include_str!(""models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt"");

  // Step 2: Read image from STDIN
  let mut buf = Vec::new();
  io::stdin().read_to_end(&mut buf).unwrap();

  // Step 3: Resize the input image for the tensorflow model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&buf, 224, 224);

  // Step 4: AI inference
  let mut session = wasmedge_tensorflow_interface::Session::new(&model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(""input"", &flat_img, &[1, 224, 224, 3])
         .run();
  let res_vec: Vec<u8> = session.get_output(""MobilenetV1/Predictions/Reshape_1"");

  // Step 5: Find the food label that responds to the highest probability in res_vec
  // ... ...
  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }

  // Step 6: Generate the output text
  let class_name = label_lines.next().unwrap().to_string();
  if max_value > 50 {
    println!(""It {} a <a href='https://www.google.com/search?q={}'>{}</a> in the picture"", confidence.to_string(), class_name, class_name);
  } else {
    println!(""It does not appears to be any food item in the picture."");
  }
}
```

You can use the `cargo` tool to build the Rust program into WebAssembly bytecode or native code.

```bash
cd api/functions/image-classification/
cargo build --release --target wasm32-wasi
```

Copy the build artifacts to the `api` folder.

```bash
cp target/wasm32-wasi/release/classify.wasm ../../
```

Again, the `api/pre.sh` script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the `classify.wasm` bytecode program to the `classify.so` native shared library at the time of deployment.

The [`api/hello.js`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/hello.js) script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via `STDIN`. Notice [`api/hello.js`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/hello.js) runs the compiled `classify.so` file generated by [`api/pre.sh`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/pre.sh) for better performance. The handler function is similar to our previous example, and is omitted here.

```javascript
const { spawn } = require('child_process');
const path = require('path');

function _runWasm(reqBody) {
  return new Promise(resolve => {
    const wasmedge = spawn(
      path.join(__dirname, 'wasmedge-tensorflow-lite'),
      [path.join(__dirname, 'classify.so')],
      {env: {'LD_LIBRARY_PATH': __dirname}}
    );

    let d = [];
    wasmedge.stdout.on('data', (data) => {
      d.push(data);
    });

    wasmedge.on('close', (code) => {
      resolve(d.join(''));
    });

    wasmedge.stdin.write(reqBody);
    wasmedge.stdin.end('');
  });
}

exports.handler = ... // _runWasm(reqBody) is called in the handler
```

You can build your Docker image and deploy the function in the same way as outlined in the previous example. Now you have created a web app for subject classification!

Next, it's your turn to use the [aws-lambda-wasm-runtime repo](https://github.com/second-state/aws-lambda-wasm-runtime/tree/main) as a template to develop Rust serverless function on AWS Lambda. Looking forward to your great work.
","This is a summary of the provided code, highlighting its purpose, functionality, and key components.

**Purpose:**
The code demonstrates how to create two serverless functions in Rust using WasmEdge deployed on AWS Lambda. The first function performs image processing (black and white conversion) while the second one runs an AI inference model for image classification.

**Functionality:**

1. **Image Processing**: The `image_grayscale` function reads an input image from STDIN, detects its format, and converts it to grayscale using the WasmEdge library. It then outputs the resulting image as a PNG or GIF file.
2. **AI Inference**: The `classify.wasm` function loads a pre-trained TensorFlow Lite model, reads an input image from STDIN, and performs AI inference using the WasmEdge Tensorflow API. It returns a text output indicating the classified object.

**Key Components:**

1. **WasmEdge Library**: Used for WebAssembly runtime and its dependencies.
2. **Cargo Tool**: For building Rust programs into WebAssembly bytecode or native code.
3. **Docker Image**: Built from AWS Lambda's Node.js base image, including RIC (Runtime Interface Client) and RIE (Runtime Interface Emulator).
4. **`api/pre.sh` script**: Installs WasmEdge runtime and its dependencies for Tensorflow inference.

**Potential Issues:**

1. The code assumes a specific directory structure and file naming conventions.
2. The Docker image build process requires manual installation of WasmEdge dependencies.
3. The `classify.wasm` function uses a pre-trained model, which may not be suitable for all use cases.
4. Error handling is limited in both functions.

**Areas for Improvement:**

1. Simplify the directory structure and file naming conventions.
2. Automate the installation of WasmEdge dependencies in the Docker image build process.
3. Add more robust error handling to both functions.
4. Consider using a more advanced model or library for AI inference."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/llm_inference.md,"---
sidebar_position: 1
---

# Llama 2 inference

WasmEdge now supports running llama2 series of models in Rust. We will use [this example project](https://github.com/second-state/LlamaEdge/tree/main/chat) to show how to make AI inferences with the llama2 model in WasmEdge and Rust.

WasmEdge now supports the following models:

1. Llama-2-7B-Chat
1. Llama-2-13B-Chat
1. CodeLlama-13B-Instruct
1. Mistral-7B-Instruct-v0.1
1. Mistral-7B-Instruct-v0.2
1. MistralLite-7B
1. OpenChat-3.5-0106
1. OpenChat-3.5-1210
1. OpenChat-3.5
1. Wizard-Vicuna-13B-Uncensored-GGUF
1. TinyLlama-1.1B-Chat-v1.0
1. Baichuan2-13B-Chat
1. OpenHermes-2.5-Mistral-7B
1. Dolphin-2.2-Yi-34B
1. Dolphin-2.6-Mistral-7B
1. Samantha-1.2-Mistral-7B
1. Samantha-1.11-CodeLlama-34B
1. WizardCoder-Python-7B-V1.0
1. Zephyr-7B-Alpha
1. WizardLM-13B-V1.0-Uncensored
1. Orca-2-13B
1. Neural-Chat-7B-v3-1
1. Yi-34B-Chat
1. Starling-LM-7B-alpha
1. DeepSeek-Coder-6.7B
1. DeepSeek-LLM-7B-Chat
1. SOLAR-10.7B-Instruct-v1.0
1. Mixtral-8x7B-Instruct-v0.1
1. Nous-Hermes-2-Mixtral-8x7B-DPO
1. Nous-Hermes-2-Mixtral-8x7B-SFT

And more, please check [the supported models](https://github.com/second-state/LlamaEdge/blob/main/models.md) for detials.

## Prerequisite

Besides the [regular WasmEdge and Rust requirements](../../rust/setup.md), please make sure that you have the [Wasi-NN plugin with ggml installed](../../../start/install.md#wasi-nn-plug-in-with-ggml-backend).

## Quick start

Because the example already includes a compiled WASM file from the Rust code, we could use WasmEdge CLI to execute the example directly.

First, get the latest llama-chat wasm application

```bash
curl -LO https://github.com/LlamaEdge/LlamaEdge/releases/latest/download/llama-chat.wasm
```

Next, let's get the model. In this example, we are going to use the llama2 7b chat model in GGUF format. You can also use other kinds of llama2 models, check out [here](https://github.com/second-state/llamaedge/blob/main/chat/README.md#get-model).

```bash
curl -LO https://huggingface.co/wasmedge/llama2/resolve/main/llama-2-7b-chat-q5_k_m.gguf
```

Run the inference application in WasmEdge.

```bash
wasmedge --dir .:. --nn-preload default:GGML:AUTO:llama-2-7b-chat-q5_k_m.gguf llama-chat.wasm
```

After executing the command, you may need to wait a moment for the input prompt to appear. You can enter your question once you see the `[USER]:` prompt:

```bash
[USER]:
I have two apples, each costing 5 dollars. What is the total cost of these apple
[ASSISTANT]:
The total cost of the two apples is 10 dollars.
[USER]:
How about four apples?
[ASSISTANT]:
The total cost of four apples is 20 dollars.
```

## Build and run

Let's build the wasm file from the rust source code. First, git clone the `llamaedge` repo.

```bash
git clone https://github.com/LlamaEdge/LlamaEdge.git
cd chat
```

Second, use `cargo` to build the example project.

```bash
cargo build --target wasm32-wasi --release
```

The output WASM file is `target/wasm32-wasi/release/llama-chat.wasm`. Next, use WasmEdge to load the llama-2-7b model and then ask the model to questions.

```bash
wasmedge --dir .:. --nn-preload default:GGML:AUTO:llama-2-7b-chat-q5_k_m.gguf llama-chat.wasm
```

After executing the command, you may need to wait a moment for the input prompt to appear. You can enter your question once you see the `[USER]:` prompt:

```bash
[USER]:
Who is Robert Oppenheimer?
[ASSISTANT]:
Robert Oppenheimer was an American theoretical physicist and director of the Manhattan Project, which developed the atomic bomb during World War II. He is widely regarded as one of the most important physicists of the 20th century and is known for his contributions to the development of quantum mechanics and the theory of the atomic nucleus. Oppenheimer was also a prominent figure in the post-war nuclear weapons debate and was a strong advocate for international cooperation on nuclear weapons control.
```

## Options

You can configure the chat inference application through CLI options.

```bash
  -m, --model-alias <ALIAS>
          Model alias [default: default]
  -c, --ctx-size <CTX_SIZE>
          Size of the prompt context [default: 4096]
  -n, --n-predict <N_PRDICT>
          Number of tokens to predict [default: 1024]
  -g, --n-gpu-layers <N_GPU_LAYERS>
          Number of layers to run on the GPU [default: 100]
  -b, --batch-size <BATCH_SIZE>
          Batch size for prompt processing [default: 4096]
  -r, --reverse-prompt <REVERSE_PROMPT>
          Halt generation at PROMPT, return control.
  -s, --system-prompt <SYSTEM_PROMPT>
          System prompt message string [default: ""[Default system message for the prompt template]""]
  -p, --prompt-template <TEMPLATE>
          Prompt template. [default: llama-2-chat] [possible values: llama-2-chat, codellama-instruct, mistral-instruct-v0.1, mistrallite, openchat, belle-llama-2-chat, vicuna-chat, chatml]
      --log-prompts
          Print prompt strings to stdout
      --log-stat
          Print statistics to stdout
      --log-all
          Print all log information to stdout
      --stream-stdout
          Print the output to stdout in the streaming way
  -h, --help
          Print help
```

The `--prompt-template` option is perhaps the most interesting. It allows the application to support different open source LLM models beyond llama2. Check out more prompt templates [here](https://github.com/LlamaEdge/LlamaEdge/tree/main/api-server/chat-prompts).

| Template name         | Model                                                                    | Download                                                                                                                                |
| ------------          | ------------------------------                                           | ---                                                                                                                                     |
| llama-2-chat          | [The standard llama2 chat model](https://ai.meta.com/llama/)             | [7b](https://huggingface.co/wasmedge/llama2/resolve/main/llama-2-7b-chat-q5_k_m.gguf)                                                   |
| codellama-instruct    | [CodeLlama](https://about.fb.com/news/2023/08/code-llama-ai-for-coding/) | [7b](https://huggingface.co/TheBloke/CodeLlama-7B-Instruct-GGUF/resolve/main/codellama-7b-instruct.Q5_K_M.gguf)                         |
| mistral-instruct-v0.1 | [Mistral](https://mistral.ai/)                                           | [7b](https://huggingface.co/TheBloke/Mistral-7B-Instruct-v0.1-GGUF/resolve/main/mistral-7b-instruct-v0.1.Q5_K_M.gguf)                   |
| mistrallite           | [Mistral Lite](https://huggingface.co/amazon/MistralLite)                | [7b](https://huggingface.co/TheBloke/MistralLite-7B-GGUF/resolve/main/mistrallite.Q5_K_M.gguf)                                          |
| openchat              | [OpenChat](https://github.com/imoneoi/openchat)                          | [7b](https://huggingface.co/TheBloke/openchat_3.5-GGUF/resolve/main/openchat_3.5.Q5_K_M.gguf)                                           |
| belle-llama-2-chat    | [BELLE](https://github.com/LianjiaTech/BELLE)                            | [13b](https://huggingface.co/second-state/BELLE-Llama2-13B-Chat-0.4M-GGUF/resolve/main/BELLE-Llama2-13B-Chat-0.4M-ggml-model-q4_0.gguf) |
| vicuna-chat           | [Vicuna](https://lmsys.org/blog/2023-03-30-vicuna/)                      | [7b](https://huggingface.co/TheBloke/vicuna-7B-v1.5-GGUF/resolve/main/vicuna-7b-v1.5.Q5_K_M.gguf)                                       |
| chatml                | [ChatML](https://huggingface.co/chargoddard/rpguild-chatml-13b)          | [13b](https://huggingface.co/TheBloke/rpguild-chatml-13B-GGUF/resolve/main/rpguild-chatml-13b.Q5_K_M.gguf)                              |

Furthermore, the following command tells WasmEdge to print out logs and statistics of the model at runtime.

```bash
wasmedge --dir .:. --nn-preload default:GGML:AUTO:llama-2-7b-chat-q5_k_m.gguf \
  llama-chat.wasm --prompt-template llama-2-chat --log-stat
..................................................................................................
llama_new_context_with_model: n_ctx      = 512
llama_new_context_with_model: freq_base  = 10000.0
llama_new_context_with_model: freq_scale = 1
llama_new_context_with_model: kv self size  =  256.00 MB
llama_new_context_with_model: compute buffer total size = 76.63 MB
[2023-11-07 02:07:44.019] [info] [WASI-NN] GGML backend: llama_system_info: AVX = 0 | AVX2 = 0 | AVX512 = 0 | AVX512_VBMI = 0 | AVX512_VNNI = 0 | FMA = 0 | NEON = 1 | ARM_FMA = 1 | F16C = 0 | FP16_VA = 1 | WASM_SIMD = 0 | BLAS = 0 | SSE3 = 0 | SSSE3 = 0 | VSX = 0 | 

llama_print_timings:        load time =   11523.19 ms
llama_print_timings:      sample time =       2.62 ms /   102 runs   (    0.03 ms per token, 38961.04 tokens per second)
llama_print_timings: prompt eval time =   11479.27 ms /    49 tokens (  234.27 ms per token,     4.27 tokens per second)
llama_print_timings:        eval time =   13571.37 ms /   101 runs   (  134.37 ms per token,     7.44 tokens per second)
llama_print_timings:       total time =   25104.57 ms
[ASSISTANT]:
Ah, a fellow Peanuts enthusiast! Snoopy is Charlie Brown's lovable and imaginative beagle, known for his wild and wacky adventures in the comic strip and television specials. He's a loyal companion to Charlie Brown and the rest of the Peanuts gang, and his antics often provide comic relief in the series. Is there anything else you'd like to know about Snoopy? 🐶
```

## Improving performance

You can make the inference program run faster by AOT compiling the wasm file first.

```bash
wasmedge compile llama-chat.wasm llama-chat.wasm
wasmedge --dir .:.  --nn-preload default:GGML:AUTO:llama-2-7b-chat-q5_k_m.gguf llama-chat.wasm
```

## Understand the code

The [main.rs](https://github.com/second-state/llamaedge/blob/main/chat/src/main.rs) is the full Rust code to create an interactive chatbot using a LLM. The Rust program manages the user input, tracks the conversation history, transforms the text into the llama2 and other model’s chat templates, and runs the inference operations using the WASI NN standard API. The code logic for the chat interaction is somewhat complex. In this section, we will use the [simple example](https://github.com/second-state/llamaedge/tree/main/simple) to explain how to set up and perform one inference round trip. Here is how you use the simple example.

```bash
# Download the compiled simple inference wasm
curl -LO https://github.com/second-state/llamaedge/releases/latest/download/llama-simple.wasm

# Give it a prompt and ask it to use the model to complete it.
wasmedge --dir .:. --nn-preload default:GGML:AUTO:llama-2-7b-chat-q5_k_m.gguf llama-simple.wasm \
  --prompt 'Robert Oppenheimer most important achievement is ' --ctx-size 4096

output: in 1942, when he led the team that developed the first atomic bomb, which was dropped on Hiroshima, Japan in 1945.
```

First, let's parse command line arguments to customize the chatbot's behavior using `Command` struct. It extracts the following parameters: `prompt` (a prompt that guides the conversation), `model_alias` (a list for the loaded model), and `ctx_size` (the size of the chat context).

```rust
fn main() -> Result<(), String> {
    let matches = Command::new(""Simple LLM inference"")
        .arg(
            Arg::new(""prompt"")
                .short('p')
                .long(""prompt"")
                .value_name(""PROMPT"")
                .help(""Sets the prompt."")
                .required(true),
        )
        .arg(
            Arg::new(""model_alias"")
                .short('m')
                .long(""model-alias"")
                .value_name(""ALIAS"")
                .help(""Sets the model alias"")
                .default_value(""default""),
        )
        .arg(
            Arg::new(""ctx_size"")
                .short('c')
                .long(""ctx-size"")
                .value_parser(clap::value_parser!(u32))
                .value_name(""CTX_SIZE"")
                .help(""Sets the prompt context size"")
                .default_value(DEFAULT_CTX_SIZE),
        )
        .get_matches();

    // model alias
    let model_name = matches
        .get_one::<String>(""model_alias"")
        .unwrap()
        .to_string();

    // prompt context size
    let ctx_size = matches.get_one::<u32>(""ctx_size"").unwrap();
    CTX_SIZE
        .set(*ctx_size as usize)
        .expect(""Fail to parse prompt context size"");

    // prompt
    let prompt = matches.get_one::<String>(""prompt"").unwrap().to_string();
```

After that, the program will create a new Graph using the `GraphBuilder` and loads the model specified by the `model_name` .

```rust
// load the model to wasi-nn
     let graph =
        wasi_nn::GraphBuilder::new(wasi_nn::GraphEncoding::Ggml, wasi_nn::ExecutionTarget::AUTO)
            .build_from_cache(&model_name)
            .expect(""Failed to load the model"");
```

Next, We create an execution context from the loaded Graph. The context is mutable because we will be changing it when we set the input tensor and execute the inference.

```rust
 // initialize the execution context
    let mut context = graph
        .init_execution_context()
        .expect(""Failed to init context"");
```

Next, The prompt is converted into bytes and set as the input tensor for the model inference.

```rust
 // set input tensor
    let tensor_data = prompt.as_str().as_bytes().to_vec();
    context
        .set_input(0, wasi_nn::TensorType::U8, &[1], &tensor_data)
        .expect(""Failed to set prompt as the input tensor"");
```

Next, execute the model inference.

```rust
  // execute the inference
    context.compute().expect(""Failed to complete inference"");
```

After the inference is finished, extract the result from the computation context and losing invalid UTF8 sequences handled by converting the output to a string using `String::from_utf8_lossy`.

```rust
  let mut output_buffer = vec![0u8; *CTX_SIZE.get().unwrap()];
    let mut output_size = context
        .get_output(0, &mut output_buffer)
        .expect(""Failed to get output tensor"");
    output_size = std::cmp::min(*CTX_SIZE.get().unwrap(), output_size);
    let output = String::from_utf8_lossy(&output_buffer[..output_size]).to_string();
```

Finally, print the prompt and the inference output to the console.

```rust
println!(""\nprompt: {}"", &prompt);
println!(""\noutput: {}"", output);
```

## Resources

* If you're looking for multi-turn conversations with llama 2 models, please check out the above mentioned chat example source code [here](https://github.com/second-state/llamaedge/tree/main/chat).
* If you want to construct OpenAI-compatible APIs specifically for your llama2 model, or the Llama2 model itself, please check out the source code [for the API server](https://github.com/second-state/llamaedge/tree/main/api-server).
* To learn more, please check out [this article](https://medium.com/stackademic/fast-and-portable-llama2-inference-on-the-heterogeneous-edge-a62508e82359).
","This is a detailed summary of the provided code, which appears to be related to running Llama 2 inference with Rust and WasmEdge.

**Purpose:** The code provides an example of how to run Llama 2 inference using Rust and WasmEdge. It demonstrates how to create a chatbot that uses a LLM (Large Language Model) to generate responses to user input.

**Key Components:**

1. **WasmEdge**: A WebAssembly runtime for the edge, allowing for fast and portable execution of WebAssembly modules.
2. **Rust**: A systems programming language used to write the inference application.
3. **LLM**: The Llama 2 model is a large language model that can be fine-tuned for specific tasks, such as chatbots.

**Functionality:**

1. **Loading models**: The code loads pre-trained LLM models, specifically Llama 2 models.
2. **Creating an execution context**: The code creates an execution context from the loaded model and initializes it.
3. **Setting input tensor**: The code sets the user input as the input tensor for the model inference.
4. **Executing inference**: The code executes the model inference using the WASI NN standard API.
5. **Extracting output**: The code extracts the output from the computation context.

**Options:**

1. **Model alias**: The code allows setting a custom model alias to load specific LLM models.
2. **Prompt context size**: The code allows setting the prompt context size for the inference application.
3. **Prompt**: The code allows setting a custom prompt to guide the conversation.

**Improvement Opportunities:**

1. **AOT compilation**: The code can be improved by AOT compiling the WASM file before executing it, which may improve performance.
2. **Multi-turn conversations**: The code can be extended to support multi-turn conversations with Llama 2 models.
3. **OpenAI-compatible APIs**: The code can be modified to construct OpenAI-compatible APIs specifically for Llama 2 models.

Overall, the code provides a solid foundation for running Llama 2 inference using Rust and WasmEdge."
i18n/zh/docusaurus-plugin-content-docs/current/start/install.md,"---
sidebar_position: 2
---

# 安装和卸载 WasmEdge

本章将讨论在各种操作系统和平台上安装和卸载 WasmEdge 运行时的方法。同时也将介绍如何为 WasmEdge 安装插件。

<!-- prettier-ignore -->
:::note
Docker Desktop 4.15+ 已经在其分发二进制文件中打包了 WasmEdge。如果你使用 Docker Desktop，则无需再单独安装 WasmEdge。详情请查看[如何在 Docker Desktop 中运行 WasmEdge 应用](build-and-run/docker_wasm.md)。
:::

## 安装

你可以在任何通用的 Linux 和 MacOS 平台上安装 WasmEdge 运行时。如果你使用 Windows 10 或 Fedora/Red Hat Linux 系统，可以使用默认软件包管理器进行安装。

### 通用的 Linux 和 MacOS 平台

确保系统中已经安装了 `git` 和 `curl`，然后运行以下的命令安装 WasmEdge：

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
```

运行以下命令让刚才安装的二进制文件可以在当前会话中使用。

```bash
source $HOME/.wasmedge/env
```

#### 全局安装

WasmEdge 默认被安装在 `$HOME/.wasmedge` 目录中。你也可以将其安装到系统目录，如 `/usr/local`，以使其对所有用户可用。若要指定安装目录，应使用 `install.sh -p` 进行安装，由于这些命令会执行会写入系统目录的操作，所以需要以 `root` 用户或使用 `sudo` 执行：

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local
```

#### 安装特定版本的 WasmEdge

WasmEdge 安装程序脚本默认会安装最新的官方发布版本。 你可以通过使用 `-v` 参数来安装特定版本的 WasmEdge，包括预发布版本或旧版本。如下所示：

```bash
VERSION={{ wasmedge_version }}
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v $VERSION
```

如果你对 `master` 分支的 `HEAD` 构建感兴趣（这基本上是 WasmEdge 的每夜构建版本）。在这种情况下，可以直接从我们的 Github Action 的 CI artifact 下载发布包。[以下是一个示例链接](https://github.com/WasmEdge/WasmEdge/actions/runs/2969775464#artifacts)。

#### 带插件安装 WasmEdge

WasmEdge 插件是预构建的原生模块，为 WasmEdge 运行时提供额外功能。要在安装运行时的同时也安装插件，可以在安装程序中使用 `--plugins` 参数。例如，下面的命令安装 `WASI-NN TensorFlow-Lite backend` 插件，使 WasmEdge 应用能够在具有 `WASI-NN` 提案的 Tensorflow-Lite 模型上运行推理。

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-tensorflowlite
```

若要安装多个插件，可以使用 `--plugins` 选项并传递插件列表。例如，以下命令安装了 `wasi-nn TensorFlow-Lite backend` 和 `wasmedge_tensorflow` 插件。

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-tensorflowlite wasmedge_tensorflow
```

安装程序会从 GitHub 上的 WasmEdge 发布中下载插件文件，解压然后复制到 `~/.wasmedge/plugin/` 文件夹（用户安装）或 `/usr/local/lib/wasmedge/` 文件夹（系统安装）。

<!-- prettier-ignore -->
:::note
WasmEdge 的 AI 插件，如用于 `WASI-NN` 插件的 `OpenVINO backend` 或 `PyTorch backend`，还依赖于 `OpenVINO` 或 `PyTorch` 运行时库的其他依赖项。请参阅[下一节](#安装_WasmEdge_插件和依赖)获取安装插件依赖项的命令。
:::

### Windows

对于 `Windows 10` 系统，你可以使用 Windows 软件包管理器客户端（即 `winget.exe`）在终端中使用下面的命令来安装 WasmEdge。

```bash
winget install wasmedge
```

如果要安装插件，可以从 WasmEdge 发布页面下载插件二进制模块，解压然后复制到 `C:\Program Files\WasmEdge\lib` 目录下。

### Fedora 和 Red Hat Linux

WasmEdge 现在是 Fedora 36、Fedora 37、Fedora 38、Fedora EPEL 8 和 Fedora EPEL 9 的官方软件包。要在 Fedora 上安装 WasmEdge，请运行以下命令：

```bash
dnf install wasmedge
```

更多用法，请查阅 Fedora 文档。

若要安装插件，可以从 WasmEdge 发布页面下载插件的二进制模块，解压然后复制到 `/usr/local/lib/wasmedge/` 目录下。

## 安装内容

如果安装目录为 `$HOME/.wasmedge`，则在安装完成后会有以下目录和文件：

- `$HOME/.wasmedge/bin` 目录中包含 WasmEdge 运行时可执行文件。你可以在文件系统中复制和移动它们。

  - `wasmedge` 工具是标准的 WasmEdge 运行时。你可以通过命令行界面 (CLI) 使用它。
    - 运行一个 WASM 文件：`wasmedge --dir .:. app.wasm`
  - `wasmedgec` 工具是提前（AOT）编译器，用于将 `.wasm` 文件编译成本机的 `.so` 文件（在 MacOS 上则编译成 `.dylib`，在 Windows 上则编译成 `.dll`，或编译成在各平台上通用的 `.wasm` 格式）。`wasmedge` 可以执行编译后的文件。

    - 使用 AOT 编译 WASM 文件：`wasmedgec app.wasm app.so`
    - 以 AOT 模式运行 WASM：`wasmedge --dir .:. app.so`

    <!-- prettier-ignore -->
    :::note
    `wasmedgec` 的用法等同于 `wasmedge compile`。我们决定在未来废弃 `wasmedgec`。
    :::

- `$HOME/.wasmedge/lib` 目录包含 WasmEdge 共享库和依赖库。这对于 WasmEdge SDK 在主机应用程序中启动 WasmEdge 程序和函数很有用。
- `$HOME/.wasmedge/include` 目录包含 WasmEdge 头文件。这对于 WasmEdge SDK 很有用。
- `$HOME/.wasmedge/plugin` 目录包含 WasmEdge 插件。这些是 WasmEdge SDK 的可加载扩展，在运行 WasmEdge CLI 时会自动加载。

<!-- prettier-ignore -->
:::note
如果进行全局安装，则安装路径为 `/usr/local`。
如果使用 `winget` 安装，则文件位于 `C:\Program Files\WasmEdge`。
:::

## 安装 WasmEdge 插件和依赖项

WasmEdge 使用插件来扩展其功能。如果你想使用更多 WasmEdge 的功能，可以按下面的说明安装 WasmEdge 以及其插件和扩展：

### TLS 插件

WasmEdge TLS 插件利用本机 OpenSSL 库来支持 WasmEdge sockets 的 HTTPS 和 TLS 请求。如果要在 Linux 上安装 WasmEdge TLS 插件，则在安装 WasmEdge 后运行以下命令：

```bash
wget https://github.com/WasmEdge/WasmEdge/releases/download/0.13.4/WasmEdge-plugin-wasmedge_rustls-0.13.4-manylinux2014_x86_64.tar.gz
tar xf WasmEdge-plugin-wasmedge_rustls-0.13.4-manylinux2014_x86_64.tar.gz

# If you only installed WasmEdge for the local user
cp libwasmedge_rustls.so ~/.wasmedge/plugin/

# If you installed Wasmedge at /usr/local for all users
sudo mkdir -p /usr/local/lib/wasmedge/
sudo cp libwasmedge_rustls.so /usr/local/lib/wasmedge/
```

安装完成后，在 [Rust 中的 HTTPS 请求](../develop/rust/http_service/client.md) 章节中查看如何使用 Rust 运行 HTTPS 服务。

### WASI-NN 插件

WasmEdge 支持多种 `WASI-NN` 的后端。

- [ggml 后端](#wasi-nn-plug-in-with-pytorch-backend)：支持 `Ubuntu 20.04 以上`、macOS (M1 和 M2) 和 `GPU (NVIDIA)`。
- [PyTorch 后端](#wasi-nn-plug-in-with-pytorch-backend)：支持 `Ubuntu 20.04 以上` 和 `manylinux2014_x86_64`。
- [OpenVINO™ 后端](#wasi-nn-plug-in-with-openvino-backend)：支持 `Ubuntu 20.04 以上`。
- [TensorFlow-Lite 后端](#wasi-nn-plug-in-with-tensorflow-lite-backend)：支持 `Ubuntu 20.04 以上`，`manylinux2014_x86_64` 和 `manylinux2014_aarch64`。

注意这些后端是互斥的。开发者只能选择并安装一个后端用于 `WASI-NN` 插件。

#### 带有 ggml 后端的 WASI-NN 插件

`WASI-NN` 插件与 `ggml` 后端允许 WasmEdge 应用执行 Llama 2 系列大模型的推理。要在 Linux 上安装带有 `WASI-NN ggml backend` 的 WasmEdge，请在[运行安装命令](#generic-linux-and-macos)时使用 `--plugins wasi_nn-ggml` 参数。

注意，WasmEdge 0.13.5 的安装程序将自动检测 CUDA。如果检测到 CUDA，安装程序将始终尝试安装支持 CUDA 的插件版本。

如果您的机器上只有CPU可用，那么需要安装 OpenBLAS 版本的插件。

```
apt update && apt install -y libopenblas-dev # You may need sudo if the user is not root.
```

安装完成后，请在 [Rust 中的大模型推理](../develop/rust/wasinn/llm_inference) 章节中了解如何使用 `ggml` 运行 LLM 推理程序。

#### 带有 PyTorch 后端的 WASI-NN 插件

`WASI-NN` 插件与 `PyTorch` 后端允许 WasmEdge 应用执行 `PyTorch` 模型推理。要在 Linux 上安装带有 `WASI-NN PyTorch 后端` 的 WasmEdge，请在[运行安装命令](#generic-linux-and-macos)时使用 `--plugins wasi_nn-pytorch` 参数。

`WASI-NN` 插件带有 `PyTorch` 后端依赖于 `libtorch` C++ 库来进行人工智能/机器学习计算。你需要安装[PyTorch 1.8.2 LTS](https://pytorch.org/get-started/locally/)的依赖项，以确保其正常工作。

```bash
export PYTORCH_VERSION=""1.8.2""
# For the Ubuntu 20.04 or above, use the libtorch with cxx11 abi.
export PYTORCH_ABI=""libtorch-cxx11-abi""
# For the manylinux2014, please use the without cxx11 abi version:
#   export PYTORCH_ABI=""libtorch""
curl -s -L -O --remote-name-all https://download.pytorch.org/libtorch/lts/1.8/cpu/${PYTORCH_ABI}-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip
unzip -q ""${PYTORCH_ABI}-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""
rm -f ""${PYTORCH_ABI}-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""
export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:$(pwd)/libtorch/lib
```

<!-- prettier-ignore -->
:::note
对于 `Ubuntu 20.04` 或更高版本，WasmEdge 安装程序将安装 `Ubuntu` 版本的 WasmEdge 及其插件。
对于其他系统，WasmEdge 安装程序将安装 `manylinux2014` 版本，并且你应该使用不带 `cxx11-abi` 的 `libtorch`。
:::

安装完成后，请在 [Rust 中的 WASI-NN PyTorch 后端](../develop/rust/wasinn/pytorch) 章节中了解如何使用 `PyTorch` 运行人工智能推理。

#### 带有 OpenVINO 后端的 WASI-NN 插件

`WASI-NN` 插件与 `OpenVINO™` 后端允许 WasmEdge 应用执行 `OpenVINO™` 模型推理。要在 Linux 上安装带有 `WASI-NN OpenVINO™ 后端` 的 WasmEdge，请在[运行安装命令](#generic-linux-and-macos)时使用 `--plugins wasi_nn-openvino` 参数。

`WASI-NN` 插件带有 `OpenVINO™` 后端依赖于 `OpenVINO™` C 库来进行人工智能/机器学习计算。[OpenVINO™](https://docs.openvino.ai/2023.0/openvino_docs_install_guides_installing_openvino_apt.html)（2023）依赖项。以下说明适用于 Ubuntu 20.04 及以上版本。

```bash
wget https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB
sudo apt-key add GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB
echo ""deb https://apt.repos.intel.com/openvino/2023 ubuntu20 main"" | sudo tee /etc/apt/sources.list.d/intel-openvino-2023.list
sudo apt update
sudo apt-get -y install openvino
ldconfig
```

安装完成后，请在 [Rust 中的 WASI-NN OpenVINO™ 后端](../develop/rust/wasinn/openvino) 章节查看如何使用 `OpenVINO™` 运行人工智能推理。

#### 带有 TensorFlow-Lite 后端的 WASI-NN 插件

`WASI-NN` 插件与 `Tensorflow-Lite` 后端允许 WasmEdge 应用执行 `Tensorflow-Lite` 模型推理。要在 Linux 上安装带有 `WASI-NN Tensorflow-Lite 后端` 的 WasmEdge，请在[运行安装命令](#generic-linux-and-macos)时使用 `--plugins wasi_nn-tensorflowlite` 参数。

`WASI-NN` 插件带有 `Tensorflow-Lite` 后端依赖于 `libtensorflowlite_c` 共享库来进行人工智能/机器学习计算，并将由安装程序自动安装。

<!-- prettier-ignore -->
:::note
如果安装了该插件，但并非使用上面的方式，可以参考[此处](#tensorflow-lite-dependencies)安装依赖项。
:::note

安装完成后，查看 [Rust 中的 WASI-NN TensorFlow-Lite 后端](../develop/rust/wasinn/tensorflow_lite) 章节了解如何使用 `TensorFlow-Lite` 运行人工智能推理。

### WASI-Crypto 插件

[WASI-crypto](https://github.com/WebAssembly/wasi-crypto) 是 WASI 的密码学 API 提案。若要使用 WASI-Crypto 提案，请在[运行安装命令](#generic-linux-and-macos)时使用 `--plugins wasi_crypto` 参数。

安装完成后，查看 [Rust 中的 WASI-Crypto](../develop/rust/wasicrypto.md)  章节了解如何运行 `WASI-crypto` 函数。

### WasmEdge 图像插件

wasmEdge-Image 插件可以帮助开发人员加载和解码 JPEG 和 PNG 图像，并将其转换为张量。要安装此插件，请在[运行安装命令](#generic-linux-and-macos)时使用 `--plugins wasmedge_image` 参数。

安装完成后，查看 [Rust 中的 TensorFlow 接口（图像部分）](../develop/rust/wasinn/tf_plugin.md#image-loading-and-conversion) 章节了解如何运行 `WasmEdge-Image` 函数。

### WasmEdge TensorFlow 插件

WasmEdge-TensorFlow 插件可以帮助开发人员执行与 Python 中相似的 `TensorFlow` 模型推理。要安装此插件，请在[运行安装命令](#generic-linux-and-macos)时使用 `--plugins wasmedge_tensorflow` 参数。

WasmEdge-TensorFlow 插件依赖于 `libtensorflow_cc` 共享库。

<!-- prettier-ignore -->
:::note
如果安装了该插件，但并非使用上面的方式，可以参考[此处](#tensorflow-dependencies)安装依赖项。
:::note

安装完成后，查看 [Rust 中的 TensorFlow 接口](../develop/rust/wasinn/tf_plugin.md) 章节了解如何运行 `WasmEdge-TensorFlow` 函数。

### WasmEdge TensorFlow-Lite 插件

wasmEdge-TensorFlowLite 插件可以帮助开发人员执行与 Python 中类似的 `TensorFlow-Lite` 模型推理。要安装此插件，请在[运行安装命令](#generic-linux-and-macos)时使用 `--plugins wasmedge_tensorflowlite` 参数。

WasmEdge-TensorflowLite 插件依赖于 `libtensorflowlite_c` 共享库来执行人工智能/机器学习计算（由安装程序自动安装）。

<!-- prettier-ignore -->
:::note
如果安装了该插件，但并非使用上面的方式，可以参考[此处](#tensorflow-lite-dependencies)安装依赖项。
:::note

Then, go to [TensorFlow interface in Rust chapter](../develop/rust/wasinn/tf_plugin.md) to see how to run `WasmEdge-TensorFlowLite` functions.
安装完成后，查看 [Rust 中的 TensorFlow 接口](../develop/rust/wasinn/tf_plugin.md) 章节了解如何运行 `WasmEdge-TensorFlowLite` 函数。

## 安装 WasmEdge 扩展和依赖项

<!-- prettier-ignore -->
:::note
WasmEdge 扩展自 `0.13.0` 版本起已被弃用，并由插件取代。支持扩展的最新版本是 `0.12.1`。当 WasmEdge 安装程序不再支持 `0.12.x` 版本时，本章节将被移除。
:::note

要安装 WasmEdge 扩展，请在使用 `-e` 选项指定查看，并安装 `0.13.0` 之前的版本。你也可以使用 `-e all` 安装所有支持的扩展。

### WasmEdge 图像扩展

WasmEdge 图像扩展（在 `0.13.0`后被 [WasmEdge-Image 插件](#wasmedge-image-plug-in) 取代）可以帮助开发者加载和解码 JPEG 和 PNG 图像，并将其转换为张量。要安装此扩展，请在[运行安装命令](#generic-linux-and-macos)时使用 `-e image` 参数。

### WasmEdge Tensorflow 和 TensorFlow-Lite 带有 CLI 工具的扩展

WasmEdge Tensorflow 扩展和 CLI 工具（在 `0.13.0` 后被 [WasmEdge-Tensorflow 插件](#wasmedge-tensorflow-plug-in) 和 [WasmEdge-TensorflowLite 插件](#wasmedge-tensorflow-lite-plug-in) 取代）可以帮助开发者执行类似于 Python 中的 `TensorFlow` 和 `TensorFlow-Lite` 模型推理。要安装此扩展，请在[运行安装命令](#generic-linux-and-macos)时使用 `-e tensorflow` 参数。

## 卸载

使用下面的指令卸载 WasmEdge：

```bash
bash <(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh)
```

如果 `wasmedge` 可执行文件不在系统路径 `PATH` 中，并且没有被安装在默认的 `$HOME/.wasmedge` 文件夹中，则必须提供安装路径才能卸载。

```bash
bash <(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -p /path/to/parent/folder
```

如果你希望以非交互的方式执行卸载，可以使用 `--quick` 或 `-q` 参数。

```bash
bash <(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -q
```

<!-- prettier-ignore -->
:::note
如果 `wasmedge` 可执行文件的父文件夹包含 `.wasmedge`，则该文件夹也会被删除。例如，脚本会一并删除默认的 `$HOME/.wasmedge` 文件夹。
:::

如果你在 Fedora 和 Red Hat Linux 上使用 `dnf` 安装了 WasmEdge，运行以下命令来卸载它：

```bash
dnf remove wasmedge
```

如果你在 Windows 上使用 `winget` 安装 WasmEdge，运行以下命令来卸载它：

```bash
winget uninstall wasmedge
```

## 附录：安装 TensorFlow 依赖项

### TensorFlow 依赖

如果未使用安装程序安装 `WasmEdge-Tensorflow` 插件，你可以使用以下命令下载共享库：

```bash
VERSION=TF-2.12.0-CC
# For the WasmEdge versions before 0.13.0, please use the `TF-2.6.0-CC` version.
PLATFORM=manylinux2014_x86_64
# For the Linux aarch64 platforms, please use the `manylinux2014_aarch64`.
# For the MacOS x86_64 platforms, please use the `darwin_x86_64`.
# For the MacOS arm64 platforms, please use the `darwin_arm64`.
curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TF-TF-$VERSION-$PLATFORM.tar.gz
tar -zxf WasmEdge-tensorflow-deps-TF-TF-$VERSION-$PLATFORM.tar.gz
rm -f WasmEdge-tensorflow-deps-TF-TF-$VERSION-$PLATFORM.tar.gz
```

在 `Linux` 平台上，共享库将被提取到当前目录 `./libtensorflow_cc.so.2.12.0` 和 `./libtensorflow_framework.so.2.12.0`，而在 `MacOS` 平台上，共享库将提取到 `./libtensorflow_cc.2.12.0.dylib` 和 `./libtensorflow_framework.2.12.0.dylib`。你可以手动将库移动到安装路径：

```bash
# If you installed wasmedge locally as above
mv libtensorflow_cc.so.2.12.0 ~/.wasmedge/lib
mv libtensorflow_framework.so.2.12.0 ~/.wasmedge/lib
ln -s libtensorflow_cc.so.2.12.0 ~/.wasmedge/lib/libtensorflow_cc.so.2
ln -s libtensorflow_cc.so.2 ~/.wasmedge/lib/libtensorflow_cc.so
ln -s libtensorflow_framework.so.2.12.0 ~/.wasmedge/lib/libtensorflow_framework.so.2
ln -s libtensorflow_framework.so.2 ~/.wasmedge/lib/libtensorflow_framework.so

# Or, if you installed wasmedge for all users in /usr/local/
mv libtensorflow_cc.so.2.12.0 /usr/local/lib
mv libtensorflow_framework.so.2.12.0 /usr/local/lib
ln -s libtensorflow_cc.so.2.12.0 /usr/local/lib/libtensorflow_cc.so.2
ln -s libtensorflow_cc.so.2 /usr/local/lib/libtensorflow_cc.so
ln -s libtensorflow_framework.so.2.12.0 /usr/local/lib/libtensorflow_framework.so.2
ln -s libtensorflow_framework.so.2 /usr/local/lib/libtensorflow_framework.so

# Or on MacOS platforms
mv libtensorflow_cc.2.12.0.dylib ~/.wasmedge/lib
mv libtensorflow_framework.2.12.0.dylib ~/.wasmedge/lib
ln -s libtensorflow_cc.2.12.0.dylib ~/.wasmedge/lib/libtensorflow_cc.2.dylib
ln -s libtensorflow_cc.2.dylib ~/.wasmedge/lib/libtensorflow_cc.dylib
ln -s libtensorflow_framework.2.12.0.dylib ~/.wasmedge/lib/libtensorflow_framework.2.dylib
ln -s libtensorflow_framework.2.dylib ~/.wasmedge/lib/libtensorflow_framework.dylib
```

### TensorFlow-Lite 依赖

如果未使用安装程序安装 `WasmEdge-TensorflowLite` 插件，你可以使用以下命令下载共享库：

```bash
VERSION=TF-2.12.0-CC
# For the WasmEdge versions before 0.13.0, please use the `TF-2.6.0-CC` version.
PLATFORM=manylinux2014_x86_64
# For the Linux aarch64 platforms, please use the `manylinux2014_aarch64`.
# For the MacOS x86_64 platforms, please use the `darwin_x86_64`.
# For the MacOS arm64 platforms, please use the `darwin_arm64`.
curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/$VERSION/WasmEdge-tensorflow-deps-TFLite-$VERSION-$PLATFORM.tar.gz
tar -zxf WasmEdge-tensorflow-deps-TFLite-$VERSION-$PLATFORM.tar.gz
rm -f WasmEdge-tensorflow-deps-TFLite-$VERSION-$PLATFORM.tar.gz
```

The shared library will be extracted in the current directory `./libtensorflowlite_c.so` (or `.dylib` for MacOS) and `./libtensorflowlite_flex.so` (after the `WasmEdge 0.13.0` version). You can move the library to the installation path:

共享库将被提取到当前目录 `./libtensorflowlite_c.so`（在 MacOS 则是 `.dylib`），以及 `./libtensorflowlite_flex.so`（自 `WasmEdge 0.13.0` 版本之后）。你可以手动将这些库移动到安装路径：

```bash
# If you installed wasmedge locally as above
mv libtensorflowlite_c.so ~/.wasmedge/lib
mv libtensorflowlite_flex.so ~/.wasmedge/lib

# Or, if you installed wasmedge for all users in /usr/local/
mv libtensorflowlite_c.so /usr/local/lib
mv libtensorflowlite_flex.so /usr/local/lib

# Or on MacOS platforms
mv libtensorflowlite_c.dylib ~/.wasmedge/lib
mv libtensorflowlite_flex.dylib ~/.wasmedge/lib
```

## Troubleshooting

Some users, especially in China, reported encountering the Connection refused error when trying to download the `install.sh` from the `githubusercontent.com`.

Please make sure your network connection can access `github.com` and `githubusercontent.com` via VPN.

## 故障排除

一些用户，特别是在中国用户，在从 `githubusercontent.com` 上下载 `install.sh` 时遇到了“连接被拒绝”的错误。

请确保你的网络可以访问 `github.com` 和 `githubusercontent.com`（可以使用代理或 VPN、或 github 代理）。

```bash
# The error message
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused
```
","This code is a user manual for installing and uninstalling WasmEdge, a webassembly runtime environment. Here's a concise summary of the code:

**Installation**

* The installation process can be performed on Linux, MacOS, or Windows platforms.
* Users can download and run an installation script (install.sh) to install WasmEdge.
* The script will automatically detect and download the required dependencies for the user's system.
* Users can choose to install WasmEdge in a local directory or globally.

**Installation Steps**

1. Run the installation script (install.sh) with the correct arguments for your system (e.g., Linux, MacOS, Windows).
2. The script will automatically detect and download the required dependencies for your system.
3. Choose the installation location: local directory or global install.
4. If installing globally, select the package manager (e.g., apt, pip).

**Uninstallation**

* Users can uninstall WasmEdge using the same installation script (install.sh) with the correct arguments.
* The script will remove all files and directories installed by WasmEdge.

**Troubleshooting**

* Some users may encounter connection refused errors when downloading dependencies from GitHub. This issue can be resolved by checking network connectivity or using a VPN/proxy to access GitHub.

**Appendix: Installing TensorFlow Dependencies**

* Users who choose not to use the installation script (install.sh) to install WasmEdge-TensorFlow plugin, need to manually download and extract the required shared libraries.
* The shared libraries are `libtensorflow_cc.so` and `libtensorflow_framework.so`.
* Users can move these libraries to the installation path.

**Appendix: Installing TensorFlow-Lite Dependencies**

* Users who choose not to use the installation script (install.sh) to install WasmEdge-TensorFlowLite plugin, need to manually download and extract the required shared libraries.
* The shared library is `libtensorflowlite_c.so` for Linux systems or `.dylib` on MacOS."
docs/develop/deploy/kubernetes/openyurt.md,"---
sidebar_position: 4
---

# OpenYurt

OpenYurt is an intelligent edge computing platform that aims to extend the Cloud Native ecosystem to edge computing and IoT scenarios.

This article will introduce how to run a WasmEdge simple demo app with Containerd over [OpenYurt](https://github.com/openyurtio/openyurt).

<!-- prettier-ignore -->
:::note
This demo is based on containerd + crun.
:::

## Set up an OpenYurt Cluster

Here, we introduce two ways to set up an OpenYurt Cluster. The first is to set up an OpenYurt Cluster from scratch, and use `yurtctl convert` to realize a K8s Cluster conversion to an OpenYurt Cluster. The second one is to use the ability of OpenYurt Experience Center, which is easy to achieve an OpenYurt Cluster.

### Prerequisite

|        | OS/kernel                           | Private IP/Public IP         |
| ------ | ----------------------------------- | ---------------------------- |
| Master | Ubuntu 20.04.3 LTS/5.4.0-91-generic | 192.168.3.169/120.55.126.18  |
| Node   | Ubuntu 20.04.3 LTS/5.4.0-91-generic | 192.168.3.170/121.43.113.152 |

Some steps may differ slightly depending on the operating system differences. Please refer to the installation of [OpenYurt](https://github.com/openyurtio/openyurt) and [crun](https://github.com/containers/crun).

We use `yurtctl convert` to convert a K8s Cluster to OpenYurt Cluster, so we should set up a K8s Cluster. If you use `yurtctl init/join` to set up an OpenYurt Cluster, you can skip this step, which introduces installing K8s.

Find the difference between `yurtctl convert/revert` and `yurtctl init/join`, you can refer to the following two articles.

[how to use `Yurtctl init/join`](https://openyurt.io/docs/v0.6.0/installation/yurtctl-init-join)

[Conversion between OpenYurt and Kubernetes:`yurtctl convert/revert`](https://openyurt.io/docs/v0.6.0/installation/yurtctl-convert-revert)

- Close the swap space of the master and node first.

```bash
sudo swapoff -a
//verify
free -m
```

- Configure the file /etc/hosts of two nodes as the following.

```bash
192.168.3.169  oy-master
120.55.126.18  oy-master
92.168.3.170   oy-node
121.43.113.152 oy-node
```

- Load the br_netfilter Kernel module and modify the Kernel parameter.

```bash
//load the module
sudo modprobe br_netfilter
//verify
lsmod | grep br_netfilter
// create k8s.conf
cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
sudo sysctl --system
```

- Setup the value of rp-filter (adjusting the value of two parameters in `/etc/sysctl.d/10-network-security.conf` from 2 to 1 and setting up the value of /proc/sys/net/ipv4/ip_forward to 1)

```bash
sudo vi /etc/sysctl.d/10-network-security.conf
echo 1 > /proc/sys/net/ipv4/ip_forward
sudo sysctl --system
```

#### Install containerd and modify the default configure of containerd

Use the following commands to install containerd on your edge node to run a simple WasmEdge demo.

```bash
export VERSION=""1.5.7""
echo -e ""Version: $VERSION""
echo -e ""Installing libseccomp2 ...""
sudo apt install -y libseccomp2
echo -e ""Installing wget""
sudo apt install -y wget

wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum
sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum

sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
sudo systemctl daemon-reload
```

As the crun project support WasmEdge as default, we need to configure the containerd configuration for runc. So we need to modify the runc parameters in /etc/containerd/config.toml to curn and add pod_annotation.

```bash
sudo mkdir -p /etc/containerd/
sudo bash -c ""containerd config default > /etc/containerd/config.toml""
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff
sudo patch -d/ -p0 < containerd_config.diff
```

After that, restart containerd to make the configuration take effect.

```bash
systemctl start containerd
```

#### Install WasmEdge

Use the [simple install script](../../../start/install.md#install) to install WasmEdge on your edge node.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
```

#### Build and install crun

We need a crun binary that supports WasmEdge on the edge node. For now, the most straightforward approach is to build it yourself from the source. First, ensure that crun dependencies are installed on your Ubuntu 20.04. For other Linux distributions, please see [here](https://github.com/containers/crun#readme).

- Dependencies are required for the build

```bash
sudo apt update
sudo apt install -y make git gcc build-essential pkgconf libtool \
  libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
  go-md2man libtool autoconf python3 automake
```

- Configure, build, and install a crun binary with WasmEdge support.

```bash
git clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
```

### From scratch set up an OpenYurt Cluster

We will use two machines in this demo to set up an OpenYurt Cluster. One simulated cloud node is called Master, the other simulated edge node is called Node. These two nodes form the simplest OpenYurt Cluster, where OpenYurt components run on.

#### Set up a K8s Cluster

Kubernetes version 1.18.9

```bash
$ sudo apt-get update && sudo apt-get install -y ca-certificates curl software-properties-common apt-transport-https
// add K8s source
$ curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -
$ sudo tee /etc/apt/sources.list.d/kubernetes.list <<EOF
$ deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main
// install K8s components 1.18.9
$ sudo apt-get update && sudo apt-get install -y kubelet=1.18.9-00 kubeadm=1.18.9-00 kubectl=1.18.9-00
// Initialize the master node
$ sudo kubeadm init --pod-network-cidr 172.16.0.0/16 \
--apiserver-advertise-address=192.168.3.167 \
--image-repository registry.cn-hangzhou.aliyuncs.com/google_containers
// join the work node
$ kubeadm join 192.168.3.167:6443 --token 3zefbt.99e6denc1cxpk9fg \
   --discovery-token-ca-cert-hash sha256:8077d4e7dd6eee64a999d56866ae4336073ed5ffc3f23281d757276b08b9b195
```

#### Install yurtctl

Use the following command line to install yurtctl. The yurtctl CLI tool helps install/uninstall OpenYurt and convert a standard Kubernetes cluster to an OpenYurt cluster.

```bash
git clone https://github.com/openyurtio/openyurt.git
cd openyurt
make build WHAT=cmd/yurtctl
```

#### Install OpenYurt components

OpenYurt includes several components. YurtHub is the traffic proxy between the components on the node and Kube-apiserver. The YurtHub on the edge will cache the data returned from the cloud. Yurt controller supplements the upstream node controller to support edge computing requirements. TunnelServer connects with the TunnelAgent daemon running in each edge node via a reverse proxy to establish secure network access between the cloud site control plane and the edge nodes that are connected to the intranet. For more detailed information, refer to the [OpenYurt docs](https://github.com/openyurtio/openyurt).

```bash
yurtctl convert --deploy-yurttunnel --cloud-nodes oy-master --provider kubeadm\
--yurt-controller-manager-image=""openyurt/yurt-controller-manager:v0.5.0""\
--yurt-tunnel-agent-image=""openyurt/yurt-tunnel-agent:v0.5.0""\
--yurt-tunnel-server-image=""openyurt/yurt-tunnel-server:v0.5.0""\
--node-servant-image=""openyurt/node-servant:latest""\
--yurthub-image=""openyurt/yurthub:v0.5.0""
```

We need to change the `openyurt/node-server-version` to latest here: `--node-servant-image=""openyurt/node-servant:latest""`

OpenYurt components 0.6.0 version is recommended to be installed and proved successful in running a WasmEdge demo. How to install OpenYurt:0.6.0, you can see [this](https://github.com/openyurtio/openyurt/releases/tag/v0.6.0)

### Use OpenYurt Experience Center to set up an OpenYurt Cluster quickly

An easier way to set up an OpenYurt Cluster is to use the OpenYurt Experience Center. All you need to do is to sign up for an account for testing, and then you will get an OpenYurt cluster. Next, you could use `yurtctl join` command line to join an edge node. See more OpenYurt Experience Center details [here](https://openyurt.io/docs/installation/openyurt-experience-center/overview/).

## Run a simple WebAssembly app

Next, let's run a WebAssembly program through the OpenYurt cluster as a container in the pod. This section will start by pulling this WebAssembly-based container image from the Docker hub. If you want to learn how to compile, package, and publish the WebAssembly program as a container image to the Docker hub, please refer to [WasmEdge Book](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md).

Because the kubectl run (version 1.18.9 ) missed annotations parameters, we need to adjust the command line here. If you use OpenYurt Experience Center with OpenYurt 0.6.0 and Kubernetes 1.20.11 by default, please refer to [the Kubernetes sections] in the WasmEdge book to run the wasm app.

```bash
// kubectl 1.18.9
$ sudo kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest  --overrides='{""kind"":""Pod"",""metadata"":{""annotations"":{""module.wasm.image/variant"":""compat-smart""}} , ""apiVersion"":""v1"", ""spec"": {""hostNetwork"": true}}' /wasi_example_main.wasm 50000000

// kubectl 1.20.11
$ sudo kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" --overrides='{""kind"":""Pod"", ""apiVersion"":""v1"", ""spec"": {""hostNetwork"": true}}' /wasi_example_main.wasm 50000000

```

The output from the containerized application is printed into the console. It is the same for all Kubernetes versions.

```bash
Random number: 1123434661
Random bytes: [25, 169, 202, 211, 22, 29, 128, 133, 168, 185, 114, 161, 48, 154, 56, 54, 99, 5, 229, 161, 225, 47, 85, 133, 90, 61, 156, 86, 3, 14, 10, 69, 185, 225, 226, 181, 141, 67, 44, 121, 157, 98, 247, 148, 201, 248, 236, 190, 217, 245, 131, 68, 124, 28, 193, 143, 215, 32, 184, 50, 71, 92, 148, 35, 180, 112, 125, 12, 152, 111, 32, 30, 86, 15, 107, 225, 39, 30, 178, 215, 182, 113, 216, 137, 98, 189, 72, 68, 107, 246, 108, 210, 148, 191, 28, 40, 233, 200, 222, 132, 247, 207, 239, 32, 79, 238, 18, 62, 67, 114, 186, 6, 212, 215, 31, 13, 53, 138, 97, 169, 28, 183, 235, 221, 218, 81, 84, 235]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod ""wasi-demo"" deleted
```

You can now check out the pod status through the Kubernetes command line.

```bash
crictl ps -a
```

The log shows the events from scheduling to running the WebAssembly workload.

```bash
CONTAINER           IMAGE               CREATED             STATE               NAME                 ATTEMPT             POD ID
0c176ed65599a       0423b8eb71e31       8 seconds ago       Exited              wasi-demo
```
","This is a detailed summary of the provided code and its functionality.

**Summary**

The code provides instructions on how to set up an OpenYurt cluster, install WasmEdge, and run a simple WebAssembly app. The process involves setting up a Kubernetes cluster, installing OpenYurt components, and configuring WasmEdge.

**Functionality**

1. **Set up a K8s Cluster**: The code guides the reader through setting up a Kubernetes 1.18.9 cluster on two nodes: a master node and an edge node.
2. **Install yurtctl**: The reader is instructed to install `yurtctl`, a CLI tool that helps with installing/uninstalling OpenYurt and converting a standard Kubernetes cluster to an OpenYurt cluster.
3. **Install OpenYurt components**: The code provides instructions on how to install OpenYurt components, including YurtHub, YurtController, TunnelServer, and NodeServant.
4. **Configure WasmEdge**: The reader is instructed to configure WasmEdge to run a simple WebAssembly app.
5. **Run the WebAssembly app**: The code guides the reader through running a simple WebAssembly app using the `kubectl` command.

**Key Components**

* `yurtctl`: A CLI tool for installing/uninstalling OpenYurt and converting a standard Kubernetes cluster to an OpenYurt cluster.
* `kubeadm`: A tool for initializing a Kubernetes cluster.
* `kubectl`: A CLI tool for managing Kubernetes clusters.
* `WasmEdge`: An edge computing platform that enables running WebAssembly workloads on edge devices.

**Potential Issues**

1. **Kubernetes version compatibility**: The code uses an older version of Kubernetes (1.18.9), which may not be compatible with newer versions of OpenYurt and WasmEdge.
2. **Dependence on specific tools**: The reader is required to install `yurtctl` and other tools, which may not be widely available or up-to-date.
3. **Complexity of the instructions**: The code assumes a certain level of familiarity with Kubernetes and containerization, which may be a barrier for new users.

**Areas for Improvement**

1. **Update to newer versions of Kubernetes and OpenYurt**: Update the code to use more recent versions of these tools to ensure compatibility.
2. **Simplify the instructions**: Provide clearer, step-by-step instructions that are easier to follow, even for new users.
3. **Provide additional resources**: Offer additional resources, such as tutorials or documentation, to help readers understand the concepts and tools involved in setting up an OpenYurt cluster and running a WebAssembly app."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openyurt.md,"---
sidebar_position: 4
---

# OpenYurt

OpenYurt is an intelligent edge computing platform that aims to extend the Cloud Native ecosystem to edge computing and IoT scenarios.

This article will introduce how to run a WasmEdge simple demo app with Containerd over [OpenYurt](https://github.com/openyurtio/openyurt).

<!-- prettier-ignore -->
:::note
This demo is based on containerd + crun.
:::

## Set up an OpenYurt Cluster

Here, we introduce two ways to set up an OpenYurt Cluster. The first is to set up an OpenYurt Cluster from scratch, and use `yurtctl convert` to realize a K8s Cluster conversion to an OpenYurt Cluster. The second one is to use the ability of OpenYurt Experience Center, which is easy to achieve an OpenYurt Cluster.

### Prerequisite

|        | OS/kernel                           | Private IP/Public IP         |
| ------ | ----------------------------------- | ---------------------------- |
| Master | Ubuntu 20.04.3 LTS/5.4.0-91-generic | 192.168.3.169/120.55.126.18  |
| Node   | Ubuntu 20.04.3 LTS/5.4.0-91-generic | 192.168.3.170/121.43.113.152 |

Some steps may differ slightly depending on the operating system differences. Please refer to the installation of [OpenYurt](https://github.com/openyurtio/openyurt) and [crun](https://github.com/containers/crun).

We use `yurtctl convert` to convert a K8s Cluster to OpenYurt Cluster, so we should set up a K8s Cluster. If you use `yurtctl init/join` to set up an OpenYurt Cluster, you can skip this step, which introduces installing K8s.

Find the difference between `yurtctl convert/revert` and `yurtctl init/join`, you can refer to the following two articles.

[how to use `Yurtctl init/join`](https://openyurt.io/docs/v0.6.0/installation/yurtctl-init-join)

[Conversion between OpenYurt and Kubernetes:`yurtctl convert/revert`](https://openyurt.io/docs/v0.6.0/installation/yurtctl-convert-revert)

- Close the swap space of the master and node first.

```bash
sudo swapoff -a
//verify
free -m
```

- Configure the file /etc/hosts of two nodes as the following.

```bash
192.168.3.169  oy-master
120.55.126.18  oy-master
92.168.3.170   oy-node
121.43.113.152 oy-node
```

- Load the br_netfilter Kernel module and modify the Kernel parameter.

```bash
//load the module
sudo modprobe br_netfilter
//verify
lsmod | grep br_netfilter
// create k8s.conf
cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
sudo sysctl --system
```

- Setup the value of rp-filter (adjusting the value of two parameters in `/etc/sysctl.d/10-network-security.conf` from 2 to 1 and setting up the value of /proc/sys/net/ipv4/ip_forward to 1)

```bash
sudo vi /etc/sysctl.d/10-network-security.conf
echo 1 > /proc/sys/net/ipv4/ip_forward
sudo sysctl --system
```

#### Install containerd and modify the default configure of containerd

Use the following commands to install containerd on your edge node to run a simple WasmEdge demo.

```bash
export VERSION=""1.5.7""
echo -e ""Version: $VERSION""
echo -e ""Installing libseccomp2 ...""
sudo apt install -y libseccomp2
echo -e ""Installing wget""
sudo apt install -y wget

wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum
sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum

sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
sudo systemctl daemon-reload
```

As the crun project support WasmEdge as default, we need to configure the containerd configuration for runc. So we need to modify the runc parameters in /etc/containerd/config.toml to curn and add pod_annotation.

```bash
sudo mkdir -p /etc/containerd/
sudo bash -c ""containerd config default > /etc/containerd/config.toml""
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff
sudo patch -d/ -p0 < containerd_config.diff
```

After that, restart containerd to make the configuration take effect.

```bash
systemctl start containerd
```

#### Install WasmEdge

Use the [simple install script](../../../start/install.md#install) to install WasmEdge on your edge node.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
```

#### Build and install crun

We need a crun binary that supports WasmEdge on the edge node. For now, the most straightforward approach is to build it yourself from the source. First, ensure that crun dependencies are installed on your Ubuntu 20.04. For other Linux distributions, please see [here](https://github.com/containers/crun#readme).

- Dependencies are required for the build

```bash
sudo apt update
sudo apt install -y make git gcc build-essential pkgconf libtool \
  libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
  go-md2man libtool autoconf python3 automake
```

- Configure, build, and install a crun binary with WasmEdge support.

```bash
git clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
```

### From scratch set up an OpenYurt Cluster

We will use two machines in this demo to set up an OpenYurt Cluster. One simulated cloud node is called Master, the other simulated edge node is called Node. These two nodes form the simplest OpenYurt Cluster, where OpenYurt components run on.

#### Set up a K8s Cluster

Kubernetes version 1.18.9

```bash
$ sudo apt-get update && sudo apt-get install -y ca-certificates curl software-properties-common apt-transport-https
// add K8s source
$ curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -
$ sudo tee /etc/apt/sources.list.d/kubernetes.list <<EOF
$ deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main
// install K8s components 1.18.9
$ sudo apt-get update && sudo apt-get install -y kubelet=1.18.9-00 kubeadm=1.18.9-00 kubectl=1.18.9-00
// Initialize the master node
$ sudo kubeadm init --pod-network-cidr 172.16.0.0/16 \
--apiserver-advertise-address=192.168.3.167 \
--image-repository registry.cn-hangzhou.aliyuncs.com/google_containers
// join the work node
$ kubeadm join 192.168.3.167:6443 --token 3zefbt.99e6denc1cxpk9fg \
   --discovery-token-ca-cert-hash sha256:8077d4e7dd6eee64a999d56866ae4336073ed5ffc3f23281d757276b08b9b195
```

#### Install yurtctl

Use the following command line to install yurtctl. The yurtctl CLI tool helps install/uninstall OpenYurt and convert a standard Kubernetes cluster to an OpenYurt cluster.

```bash
git clone https://github.com/openyurtio/openyurt.git
cd openyurt
make build WHAT=cmd/yurtctl
```

#### Install OpenYurt components

OpenYurt includes several components. YurtHub is the traffic proxy between the components on the node and Kube-apiserver. The YurtHub on the edge will cache the data returned from the cloud. Yurt controller supplements the upstream node controller to support edge computing requirements. TunnelServer connects with the TunnelAgent daemon running in each edge node via a reverse proxy to establish secure network access between the cloud site control plane and the edge nodes that are connected to the intranet. For more detailed information, refer to the [OpenYurt docs](https://github.com/openyurtio/openyurt).

```bash
yurtctl convert --deploy-yurttunnel --cloud-nodes oy-master --provider kubeadm\
--yurt-controller-manager-image=""openyurt/yurt-controller-manager:v0.5.0""\
--yurt-tunnel-agent-image=""openyurt/yurt-tunnel-agent:v0.5.0""\
--yurt-tunnel-server-image=""openyurt/yurt-tunnel-server:v0.5.0""\
--node-servant-image=""openyurt/node-servant:latest""\
--yurthub-image=""openyurt/yurthub:v0.5.0""
```

We need to change the `openyurt/node-server-version` to latest here: `--node-servant-image=""openyurt/node-servant:latest""`

OpenYurt components 0.6.0 version is recommended to be installed and proved successful in running a WasmEdge demo. How to install OpenYurt:0.6.0, you can see [this](https://github.com/openyurtio/openyurt/releases/tag/v0.6.0)

### Use OpenYurt Experience Center to set up an OpenYurt Cluster quickly

An easier way to set up an OpenYurt Cluster is to use the OpenYurt Experience Center. All you need to do is to sign up for an account for testing, and then you will get an OpenYurt cluster. Next, you could use `yurtctl join` command line to join an edge node. See more OpenYurt Experience Center details [here](https://openyurt.io/docs/installation/openyurt-experience-center/overview/).

## Run a simple WebAssembly app

Next, let's run a WebAssembly program through the OpenYurt cluster as a container in the pod. This section will start by pulling this WebAssembly-based container image from the Docker hub. If you want to learn how to compile, package, and publish the WebAssembly program as a container image to the Docker hub, please refer to [WasmEdge Book](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md).

Because the kubectl run (version 1.18.9 ) missed annotations parameters, we need to adjust the command line here. If you use OpenYurt Experience Center with OpenYurt 0.6.0 and Kubernetes 1.20.11 by default, please refer to [the Kubernetes sections] in the WasmEdge book to run the wasm app.

```bash
// kubectl 1.18.9
$ sudo kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest  --overrides='{""kind"":""Pod"",""metadata"":{""annotations"":{""module.wasm.image/variant"":""compat-smart""}} , ""apiVersion"":""v1"", ""spec"": {""hostNetwork"": true}}' /wasi_example_main.wasm 50000000

// kubectl 1.20.11
$ sudo kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" --overrides='{""kind"":""Pod"", ""apiVersion"":""v1"", ""spec"": {""hostNetwork"": true}}' /wasi_example_main.wasm 50000000

```

The output from the containerized application is printed into the console. It is the same for all Kubernetes versions.

```bash
Random number: 1123434661
Random bytes: [25, 169, 202, 211, 22, 29, 128, 133, 168, 185, 114, 161, 48, 154, 56, 54, 99, 5, 229, 161, 225, 47, 85, 133, 90, 61, 156, 86, 3, 14, 10, 69, 185, 225, 226, 181, 141, 67, 44, 121, 157, 98, 247, 148, 201, 248, 236, 190, 217, 245, 131, 68, 124, 28, 193, 143, 215, 32, 184, 50, 71, 92, 148, 35, 180, 112, 125, 12, 152, 111, 32, 30, 86, 15, 107, 225, 39, 30, 178, 215, 182, 113, 216, 137, 98, 189, 72, 68, 107, 246, 108, 210, 148, 191, 28, 40, 233, 200, 222, 132, 247, 207, 239, 32, 79, 238, 18, 62, 67, 114, 186, 6, 212, 215, 31, 13, 53, 138, 97, 169, 28, 183, 235, 221, 218, 81, 84, 235]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod ""wasi-demo"" deleted
```

You can now check out the pod status through the Kubernetes command line.

```bash
crictl ps -a
```

The log shows the events from scheduling to running the WebAssembly workload.

```bash
CONTAINER           IMAGE               CREATED             STATE               NAME                 ATTEMPT             POD ID
0c176ed65599a       0423b8eb71e31       8 seconds ago       Exited              wasi-demo
```
","The code is a Markdown document that provides instructions on how to run a WebAssembly application using the OpenYurt cluster. Here's a concise, coherent summary:

**Purpose:** The purpose of this document is to provide step-by-step instructions on how to set up and run a simple WebAssembly application on the OpenYurt cluster.

**Key Components:**

1. **OpenYurt**: An intelligent edge computing platform that extends the Cloud Native ecosystem to edge computing and IoT scenarios.
2. **yurtctl**: A CLI tool that helps install/uninstall OpenYurt and convert a standard Kubernetes cluster to an OpenYurt cluster.
3. **WasmEdge**: A WebAssembly runtime for building high-performance applications.

**Step-by-Step Instructions:**

1. Set up a Kubernetes cluster using kubeadm.
2. Install yurtctl and its dependencies.
3. Configure the containerd configuration for runc.
4. Build and install crun with WasmEdge support.
5. Pull the WebAssembly-based container image from Docker Hub.
6. Run the WebAssembly application on the OpenYurt cluster using kubectl.

**Potential Issues:**

1. Incompatibility issues between Kubernetes versions (e.g., 1.18.9 vs. 1.20.11).
2. Configuration errors in yurtctl or runc configuration.
3. Issues with containerd or crun installation.

Overall, the code provides a comprehensive guide on how to set up and run a WebAssembly application using the OpenYurt cluster. However, it requires careful attention to detail and troubleshooting to avoid potential issues."
docs/develop/deploy/kubernetes/kubedge.md,"---
sidebar_position: 6
---

# KubeEdge

KubeEdge is an open-source system for extending native containerized application orchestration capabilities to hosts at Edge.

<!-- prettier-ignore -->
:::note
This demo is based on [crun's support](../../deploy/oci-runtime/crun.md)
:::

## 1. Setup Cloud Side (KubeEdge Master Node)

### Install Go

```bash
$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz
$ tar xzvf go1.17.3.linux-amd64.tar.gz

$ export PATH=/home/${user}/go/bin:$PATH
$ go version
go version go1.17.3 linux/amd64
```

### Install CRI-O

Please see [CRI-O Installation Instructions](https://github.com/cri-o/cri-o/blob/main/install.md#install-packaged-versions-of-cri-o).

```bash
# Create the .conf file to load the modules at bootup
cat <<EOF | sudo tee /etc/modules-load.d/crio.conf
overlay
br_netfilter
EOF

sudo modprobe overlay
sudo modprobe br_netfilter

# Set up required sysctl params; these persist across reboots.
cat <<EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf
net.bridge.bridge-nf-call-iptables  = 1
net.ipv4.ip_forward                 = 1
net.bridge.bridge-nf-call-ip6tables = 1
EOF

sudo sysctl --system
export OS=""xUbuntu_20.04""
export VERSION=""1.21""
cat <<EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /
EOF
cat <<EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list
deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /
EOF

curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers.gpg add -
curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers-cri-o.gpg add -

sudo apt-get update
sudo apt-get install cri-o cri-o-runc

sudo systemctl daemon-reload
sudo systemctl enable crio --now
sudo systemctl status cri-o
```

output:

```bash
$ sudo systemctl status cri-o
● crio.service - Container Runtime Interface for OCI (CRI-O)
     Loaded: loaded (/lib/systemd/system/crio.service; enabled; vendor preset: enabled)
     Active: active (running) since Mon 2021-12-06 13:46:29 UTC; 16h ago
       Docs: https://github.com/cri-o/cri-o
   Main PID: 6868 (crio)
      Tasks: 14
     Memory: 133.2M
     CGroup: /system.slice/crio.service
             └─6868 /usr/bin/crio

Dec 07 06:04:13 master crio[6868]: time=""2021-12-07 06:04:13.694226800Z"" level=info msg=""Checking image status: registry.k8s.io/pause:3.4.1"" id=1dbb722e-f031-410c-9f45-5d4b5760163e name=/runtime.v1alpha2.ImageServic>
Dec 07 06:04:13 master crio[6868]: time=""2021-12-07 06:04:13.695739507Z"" level=info msg=""Image status: &{0xc00047fdc0 map[]}"" id=1dbb722e-f031-410c-9f45-5d4b5760163e name=/runtime.v1alpha2.ImageService/ImageSta>
Dec 07 06:09:13 master crio[6868]: time=""2021-12-07 06:09:13.698823984Z"" level=info msg=""Checking image status: registry.k8s.io/pause:3.4.1"" id=661b754b-48a4-401b-a03f-7f7a553c7eb6 name=/runtime.v1alpha2.ImageServic>
Dec 07 06:09:13 master crio[6868]: time=""2021-12-07 06:09:13.703259157Z"" level=info msg=""Image status: &{0xc0004d98f0 map[]}"" id=661b754b-48a4-401b-a03f-7f7a553c7eb6 name=/runtime.v1alpha2.ImageService/ImageSta>
Dec 07 06:14:13 master crio[6868]: time=""2021-12-07 06:14:13.707778419Z"" level=info msg=""Checking image status: registry.k8s.io/pause:3.4.1"" id=8c7e4d36-871a-452e-ab55-707053604077 name=/runtime.v1alpha2.ImageServic>
Dec 07 06:14:13 master crio[6868]: time=""2021-12-07 06:14:13.709379469Z"" level=info msg=""Image status: &{0xc000035030 map[]}"" id=8c7e4d36-871a-452e-ab55-707053604077 name=/runtime.v1alpha2.ImageService/ImageSta>
Dec 07 06:19:13 master crio[6868]: time=""2021-12-07 06:19:13.713158978Z"" level=info msg=""Checking image status: registry.k8s.io/pause:3.4.1"" id=827b6315-f145-4f76-b8da-31653d5892a2 name=/runtime.v1alpha2.ImageServic>
Dec 07 06:19:13 master crio[6868]: time=""2021-12-07 06:19:13.714030148Z"" level=info msg=""Image status: &{0xc000162bd0 map[]}"" id=827b6315-f145-4f76-b8da-31653d5892a2 name=/runtime.v1alpha2.ImageService/ImageSta>
Dec 07 06:24:13 master crio[6868]: time=""2021-12-07 06:24:13.716746612Z"" level=info msg=""Checking image status: registry.k8s.io/pause:3.4.1"" id=1d53a917-4d98-4723-9ea8-a2951a472cff name=/runtime.v1alpha2.ImageServic>
Dec 07 06:24:13 master crio[6868]: time=""2021-12-07 06:24:13.717381882Z"" level=info msg=""Image status: &{0xc00042ce00 map[]}"" id=1d53a917-4d98-4723-9ea8-a2951a472cff name=/runtime.v1alpha2.ImageService/ImageSta>
```

### Install and Creating a cluster with kubeadm for K8s

Please see [Creating a cluster with kubeadm](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/).

#### Install K8s

```bash
sudo apt-get update
sudo apt-get install -y apt-transport-https curl
echo ""deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main"" | sudo tee /etc/apt/sources.list.d/kubernetes.list

sudo apt update
K_VER=""1.21.0-00""
sudo apt install -y kubelet=${K_VER} kubectl=${K_VER} kubeadm=${K_VER}
sudo apt-mark hold kubelet kubeadm kubectl
```

#### Create a cluster with kubeadm

```bash
#kubernetes scheduler requires this setting to be done.
$ sudo swapoff -a
$ sudo vim /etc/fstab
mark contain swapfile of row

$ cat /etc/cni/net.d/100-crio-bridge.conf
{
    ""cniVersion"": ""0.3.1"",
    ""name"": ""crio"",
    ""type"": ""bridge"",
    ""bridge"": ""cni0"",
    ""isGateway"": true,
    ""ipMasq"": true,
    ""hairpinMode"": true,
    ""ipam"": {
        ""type"": ""host-local"",
        ""routes"": [
            { ""dst"": ""0.0.0.0/0"" },
            { ""dst"": ""1100:200::1/24"" }
        ],
        ""ranges"": [
            [{ ""subnet"": ""10.85.0.0/16"" }],
            [{ ""subnet"": ""1100:200::/24"" }]
        ]
    }
}
$ export CIDR=10.85.0.0/16
$ sudo kubeadm init --apiserver-advertise-address=192.168.122.160 --pod-network-cidr=$CIDR --cri-socket=/var/run/crio/crio.sock

$ mkdir -p $HOME/.kube
$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
$ sudo chown $(id -u):$(id -g) $HOME/.kube/config
```

output:

```bash
Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a Pod network to the cluster.
Run ""kubectl apply -f [podnetwork].yaml"" with one of the options listed at:
  /docs/concepts/cluster-administration/addons/

You can now join any number of machines by running the following on each node
as root:

  kubeadm join <control-plane-host>:<control-plane-port> --token <token> --discovery-token-ca-cert-hash sha256:<hash>
```

To make kubectl work for your non-root user, run these commands, which are also part of the kubeadm init output:

```bash
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
```

### Setup KubeEdge Master Node

Please see [Deploying using Keadm](https://kubeedge.io/en/docs/setup/keadm/).

1. At least one kubeconfig or master must be configured correctly so that it can be used to verify the version and other info of the k8s cluster.
2. Please make sure the edge node can connect to the cloud node using the local IP of the cloud node, or you need to specify the public IP of the cloud node with the --advertise-address flag.
3. --advertise-address(only worked since 1.3 release) is the address exposed by the cloud side (will be added to the SANs of the CloudCore certificate); the default value is the local IP.

```bash
wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz
tar xzvf keadm-v1.8.0-linux-amd64.tar.gz
cd keadm-v1.8.0-linux-amd64/keadm/
sudo ./keadm init --advertise-address=192.168.122.160 --kube-config=/home/${user}/.kube/config
```

output:

```bash
Kubernetes version verification passed, KubeEdge installation will start...
...
KubeEdge cloudcore is running, For logs visit:  /var/log/kubeedge/cloudcore.log
```

## 2. Setup Edge Side (KubeEdge Worker Node)

You can use the CRI-O [install.sh] script to install CRI-O and `crun` on Ubuntu 20.04.

```bash
wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/install.sh | bash
```

### Install Go on Edge Side

```bash
$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz
$ tar xzvf go1.17.3.linux-amd64.tar.gz

$ export PATH=/home/${user}/go/bin:$PATH
$ go version
go version go1.17.3 linux/amd64
```

### Get Token From Cloud Side

Run keadm gettoken on the cloud side will return the token, which will be used when joining edge nodes.

```bash
$ sudo ./keadm gettoken --kube-config=/home/${user}/.kube/config
27a37ef16159f7d3be8fae95d588b79b3adaaf92727b72659eb89758c66ffda2.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTAyMTYwNzd9.JBj8LLYWXwbbvHKffJBpPd5CyxqapRQYDIXtFZErgYE
```

### Download KubeEdge and join edge nodes

Please see [Setting different container runtime with CRI](https://kubeedge.io/en/docs/advanced/cri/#cri-o) and [Deploying using Keadm](https://kubeedge.io/en/docs/setup/keadm/).

```bash
$ wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz
$ tar xzvf keadm-v1.8.0-linux-amd64.tar.gz
$ cd keadm-v1.8.0-linux-amd64/keadm/

$ sudo ./keadm join \
--cloudcore-ipport=192.168.122.160:10000 \
--edgenode-name=edge \
--token=b4550d45b773c0480446277eed1358dcd8a02a0c214646a8082d775f9c447d81.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Mzg4ODUzNzd9.A9WOYJFrgL2swVGnydpb4gMojyvyoNPCXaA4rXGowqU \
--remote-runtime-endpoint=unix:///var/run/crio/crio.sock \
--runtimetype=remote \
--cgroupdriver=systemd
```

Output:

```bash
Host has mosquit+ already installed and running. Hence skipping the installation steps !!!
...
KubeEdge edgecore is running, For logs visit:  /var/log/kubeedge/edgecore.log
```

### Get Edge Node Status From Cloud Side

Output:

```bash
kubectl get node
NAME       STATUS    ROLES                  AGE   VERSION
edge       Ready     agent,edge             10s   v1.19.3-kubeedge-v1.8.2
master     Ready     control-plane,master   68m   v1.21.0
```

## 3. Enable kubectl logs Feature

Before metrics-server deployed, kubectl logs feature must be activated, please [see here](https://kubeedge.io/en/docs/setup/keadm/#enable-kubectl-logs-feature).

## 4. Run a simple WebAssembly app

We can run the WebAssembly-based image from Docker Hub in the Kubernetes cluster.

### Cloud Side

```bash
$ kubectl run -it --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" /wasi_example_main.wasm 50000000

Random number: -1694733782
Random bytes: [6, 226, 176, 126, 136, 114, 90, 2, 216, 17, 241, 217, 143, 189, 123, 197, 17, 60, 49, 37, 71, 69, 67, 108, 66, 39, 105, 9, 6, 72, 232, 238, 102, 5, 148, 243, 249, 183, 52, 228, 54, 176, 63, 249, 216, 217, 46, 74, 88, 204, 130, 191, 182, 19, 118, 193, 77, 35, 189, 6, 139, 68, 163, 214, 231, 100, 138, 246, 185, 47, 37, 49, 3, 7, 176, 97, 68, 124, 20, 235, 145, 166, 142, 159, 114, 163, 186, 46, 161, 144, 191, 211, 69, 19, 179, 241, 8, 207, 8, 112, 80, 170, 33, 51, 251, 33, 105, 0, 178, 175, 129, 225, 112, 126, 102, 219, 106, 77, 242, 104, 198, 238, 193, 247, 23, 47, 22, 29]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
```

The WebAssembly app of the pod successfully deploys to the edge node.

```bash
$ kubectl describe pod wasi-demo

Name:         wasi-demo
Namespace:    default
Priority:     0
Node:         edge/192.168.122.229
Start Time:   Mon, 06 Dec 2021 15:45:34 +0000
Labels:       run=wasi-demo
Annotations:  module.wasm.image/variant: compat-smart
Status:       Succeeded
IP:
IPs:          <none>
Containers:
  wasi-demo:
    Container ID:  cri-o://1ae4d0d7f671050331a17e9b61b5436bf97ad35ad0358bef043ab820aed81069
    Image:         wasmedge/example-wasi:latest
    Image ID:      docker.io/wasmedge/example-wasi@sha256:525aab8d6ae8a317fd3e83cdac14b7883b92321c7bec72a545edf276bb2100d6
    Port:          <none>
    Host Port:     <none>
    Args:
      /wasi_example_main.wasm
      50000000
    State:          Terminated
      Reason:       Completed
      Exit Code:    0
      Started:      Mon, 06 Dec 2021 15:45:33 +0000
      Finished:     Mon, 06 Dec 2021 15:45:33 +0000
    Ready:          False
    Restart Count:  0
    Environment:    <none>
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-bhszr (ro)
Conditions:
  Type           Status
  Initialized    True
  Ready          False
  PodScheduled   True
Volumes:
  kube-api-access-bhszr:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    ConfigMapOptional:       <nil>
    DownwardAPI:             true
QoS Class:                   BestEffort
Node-Selectors:              <none>
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
```

### Edge Side

```bash
$ sudo crictl ps -a
CONTAINER           IMAGE                                                                                           CREATED             STATE               NAME                ATTEMPT             POD ID
1ae4d0d7f6710       0423b8eb71e312b8aaa09a0f0b6976381ff567d5b1e5729bf9b9aa87bff1c9f3                                16 minutes ago      Exited              wasi-demo           0                   2bc2ac0c32eda
1e6c7cb6bc731       registry.k8s.io/kube-proxy@sha256:2a25285ff19f9b4025c8e54dac42bb3cd9aceadc361f2570489b8d723cb77135   18 minutes ago      Running             kube-proxy          0                   8b7e7388ad866
```

That's it.

## 5. Demo Run Screen Recording

[![asciicast](https://asciinema.org/a/wkLOu6xnAOSAQdmYayumwrAvh.svg)](https://asciinema.org/a/wkLOu6xnAOSAQdmYayumwrAvh)
","Here is a concise and coherent summary of the provided code:

**Purpose:**

The code is a guide on how to set up KubeEdge, an open-source system for extending native containerized application orchestration capabilities to hosts at Edge. It provides instructions on how to install Go, CRI-O, and other required components on both cloud and edge nodes.

**Key Components:**

1. **Cloud Node:** The code sets up a Kubernetes cluster using kubeadm on the cloud node.
2. **Edge Node:** The code installs Go, CRI-O, and other required components on the edge node.
3. **KubeEdge Master Node:** The code sets up the KubeEdge master node on the cloud node.
4. **KubeEdge Edge Node:** The code sets up the KubeEdge edge node on the edge node.

**Steps:**

1. Install Go and other required components on both cloud and edge nodes.
2. Set up a Kubernetes cluster using kubeadm on the cloud node.
3. Install CRI-O and other required components on the edge node.
4. Set up the KubeEdge master node on the cloud node.
5. Set up the KubeEdge edge node on the edge node.

**Output:**

The code outputs a series of commands that can be executed to set up KubeEdge. The output includes information about the Kubernetes cluster, CRI-O installation, and other relevant details.

**Potential Issues or Areas for Improvement:**

1. The code assumes a basic understanding of containerization and Kubernetes.
2. Some steps may require manual intervention or additional configuration.
3. The code does not include error handling or troubleshooting instructions.
4. Some dependencies (e.g., CRI-O) may have specific installation requirements.

Overall, the provided code is a comprehensive guide to setting up KubeEdge on both cloud and edge nodes. However, it assumes some prior knowledge of containerization and Kubernetes, and some steps may require manual intervention or additional configuration."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubedge.md,"---
sidebar_position: 6
---

# KubeEdge

KubeEdge is an open-source system for extending native containerized application orchestration capabilities to hosts at Edge.

<!-- prettier-ignore -->
:::note
This demo is based on [crun's support](../../deploy/oci-runtime/crun.md)
:::

## 1. Setup Cloud Side (KubeEdge Master Node)

### Install Go

```bash
$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz
$ tar xzvf go1.17.3.linux-amd64.tar.gz

$ export PATH=/home/${user}/go/bin:$PATH
$ go version
go version go1.17.3 linux/amd64
```

### Install CRI-O

Please see [CRI-O Installation Instructions](https://github.com/cri-o/cri-o/blob/main/install.md#install-packaged-versions-of-cri-o).

```bash
# Create the .conf file to load the modules at bootup
cat <<EOF | sudo tee /etc/modules-load.d/crio.conf
overlay
br_netfilter
EOF

sudo modprobe overlay
sudo modprobe br_netfilter

# Set up required sysctl params; these persist across reboots.
cat <<EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf
net.bridge.bridge-nf-call-iptables  = 1
net.ipv4.ip_forward                 = 1
net.bridge.bridge-nf-call-ip6tables = 1
EOF

sudo sysctl --system
export OS=""xUbuntu_20.04""
export VERSION=""1.21""
cat <<EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /
EOF
cat <<EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list
deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /
EOF

curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers.gpg add -
curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers-cri-o.gpg add -

sudo apt-get update
sudo apt-get install cri-o cri-o-runc

sudo systemctl daemon-reload
sudo systemctl enable crio --now
sudo systemctl status cri-o
```

output:

```bash
$ sudo systemctl status cri-o
● crio.service - Container Runtime Interface for OCI (CRI-O)
     Loaded: loaded (/lib/systemd/system/crio.service; enabled; vendor preset: enabled)
     Active: active (running) since Mon 2021-12-06 13:46:29 UTC; 16h ago
       Docs: https://github.com/cri-o/cri-o
   Main PID: 6868 (crio)
      Tasks: 14
     Memory: 133.2M
     CGroup: /system.slice/crio.service
             └─6868 /usr/bin/crio

Dec 07 06:04:13 master crio[6868]: time=""2021-12-07 06:04:13.694226800Z"" level=info msg=""Checking image status: registry.k8s.io/pause:3.4.1"" id=1dbb722e-f031-410c-9f45-5d4b5760163e name=/runtime.v1alpha2.ImageServic>
Dec 07 06:04:13 master crio[6868]: time=""2021-12-07 06:04:13.695739507Z"" level=info msg=""Image status: &{0xc00047fdc0 map[]}"" id=1dbb722e-f031-410c-9f45-5d4b5760163e name=/runtime.v1alpha2.ImageService/ImageSta>
Dec 07 06:09:13 master crio[6868]: time=""2021-12-07 06:09:13.698823984Z"" level=info msg=""Checking image status: registry.k8s.io/pause:3.4.1"" id=661b754b-48a4-401b-a03f-7f7a553c7eb6 name=/runtime.v1alpha2.ImageServic>
Dec 07 06:09:13 master crio[6868]: time=""2021-12-07 06:09:13.703259157Z"" level=info msg=""Image status: &{0xc0004d98f0 map[]}"" id=661b754b-48a4-401b-a03f-7f7a553c7eb6 name=/runtime.v1alpha2.ImageService/ImageSta>
Dec 07 06:14:13 master crio[6868]: time=""2021-12-07 06:14:13.707778419Z"" level=info msg=""Checking image status: registry.k8s.io/pause:3.4.1"" id=8c7e4d36-871a-452e-ab55-707053604077 name=/runtime.v1alpha2.ImageServic>
Dec 07 06:14:13 master crio[6868]: time=""2021-12-07 06:14:13.709379469Z"" level=info msg=""Image status: &{0xc000035030 map[]}"" id=8c7e4d36-871a-452e-ab55-707053604077 name=/runtime.v1alpha2.ImageService/ImageSta>
Dec 07 06:19:13 master crio[6868]: time=""2021-12-07 06:19:13.713158978Z"" level=info msg=""Checking image status: registry.k8s.io/pause:3.4.1"" id=827b6315-f145-4f76-b8da-31653d5892a2 name=/runtime.v1alpha2.ImageServic>
Dec 07 06:19:13 master crio[6868]: time=""2021-12-07 06:19:13.714030148Z"" level=info msg=""Image status: &{0xc000162bd0 map[]}"" id=827b6315-f145-4f76-b8da-31653d5892a2 name=/runtime.v1alpha2.ImageService/ImageSta>
Dec 07 06:24:13 master crio[6868]: time=""2021-12-07 06:24:13.716746612Z"" level=info msg=""Checking image status: registry.k8s.io/pause:3.4.1"" id=1d53a917-4d98-4723-9ea8-a2951a472cff name=/runtime.v1alpha2.ImageServic>
Dec 07 06:24:13 master crio[6868]: time=""2021-12-07 06:24:13.717381882Z"" level=info msg=""Image status: &{0xc00042ce00 map[]}"" id=1d53a917-4d98-4723-9ea8-a2951a472cff name=/runtime.v1alpha2.ImageService/ImageSta>
```

### Install and Creating a cluster with kubeadm for K8s

Please see [Creating a cluster with kubeadm](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/).

#### Install K8s

```bash
sudo apt-get update
sudo apt-get install -y apt-transport-https curl
echo ""deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main"" | sudo tee /etc/apt/sources.list.d/kubernetes.list

sudo apt update
K_VER=""1.21.0-00""
sudo apt install -y kubelet=${K_VER} kubectl=${K_VER} kubeadm=${K_VER}
sudo apt-mark hold kubelet kubeadm kubectl
```

#### Create a cluster with kubeadm

```bash
#kubernetes scheduler requires this setting to be done.
$ sudo swapoff -a
$ sudo vim /etc/fstab
mark contain swapfile of row

$ cat /etc/cni/net.d/100-crio-bridge.conf
{
    ""cniVersion"": ""0.3.1"",
    ""name"": ""crio"",
    ""type"": ""bridge"",
    ""bridge"": ""cni0"",
    ""isGateway"": true,
    ""ipMasq"": true,
    ""hairpinMode"": true,
    ""ipam"": {
        ""type"": ""host-local"",
        ""routes"": [
            { ""dst"": ""0.0.0.0/0"" },
            { ""dst"": ""1100:200::1/24"" }
        ],
        ""ranges"": [
            [{ ""subnet"": ""10.85.0.0/16"" }],
            [{ ""subnet"": ""1100:200::/24"" }]
        ]
    }
}
$ export CIDR=10.85.0.0/16
$ sudo kubeadm init --apiserver-advertise-address=192.168.122.160 --pod-network-cidr=$CIDR --cri-socket=/var/run/crio/crio.sock

$ mkdir -p $HOME/.kube
$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
$ sudo chown $(id -u):$(id -g) $HOME/.kube/config
```

output:

```bash
Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a Pod network to the cluster.
Run ""kubectl apply -f [podnetwork].yaml"" with one of the options listed at:
  /docs/concepts/cluster-administration/addons/

You can now join any number of machines by running the following on each node
as root:

  kubeadm join <control-plane-host>:<control-plane-port> --token <token> --discovery-token-ca-cert-hash sha256:<hash>
```

To make kubectl work for your non-root user, run these commands, which are also part of the kubeadm init output:

```bash
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
```

### Setup KubeEdge Master Node

Please see [Deploying using Keadm](https://kubeedge.io/en/docs/setup/keadm/).

1. At least one kubeconfig or master must be configured correctly so that it can be used to verify the version and other info of the k8s cluster.
2. Please make sure the edge node can connect to the cloud node using the local IP of the cloud node, or you need to specify the public IP of the cloud node with the --advertise-address flag.
3. --advertise-address(only worked since 1.3 release) is the address exposed by the cloud side (will be added to the SANs of the CloudCore certificate); the default value is the local IP.

```bash
wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz
tar xzvf keadm-v1.8.0-linux-amd64.tar.gz
cd keadm-v1.8.0-linux-amd64/keadm/
sudo ./keadm init --advertise-address=192.168.122.160 --kube-config=/home/${user}/.kube/config
```

output:

```bash
Kubernetes version verification passed, KubeEdge installation will start...
...
KubeEdge cloudcore is running, For logs visit:  /var/log/kubeedge/cloudcore.log
```

## 2. Setup Edge Side (KubeEdge Worker Node)

You can use the CRI-O [install.sh] script to install CRI-O and `crun` on Ubuntu 20.04.

```bash
wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/install.sh | bash
```

### Install Go on Edge Side

```bash
$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz
$ tar xzvf go1.17.3.linux-amd64.tar.gz

$ export PATH=/home/${user}/go/bin:$PATH
$ go version
go version go1.17.3 linux/amd64
```

### Get Token From Cloud Side

Run keadm gettoken on the cloud side will return the token, which will be used when joining edge nodes.

```bash
$ sudo ./keadm gettoken --kube-config=/home/${user}/.kube/config
27a37ef16159f7d3be8fae95d588b79b3adaaf92727b72659eb89758c66ffda2.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTAyMTYwNzd9.JBj8LLYWXwbbvHKffJBpPd5CyxqapRQYDIXtFZErgYE
```

### Download KubeEdge and join edge nodes

Please see [Setting different container runtime with CRI](https://kubeedge.io/en/docs/advanced/cri/#cri-o) and [Deploying using Keadm](https://kubeedge.io/en/docs/setup/keadm/).

```bash
$ wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz
$ tar xzvf keadm-v1.8.0-linux-amd64.tar.gz
$ cd keadm-v1.8.0-linux-amd64/keadm/

$ sudo ./keadm join \
--cloudcore-ipport=192.168.122.160:10000 \
--edgenode-name=edge \
--token=b4550d45b773c0480446277eed1358dcd8a02a0c214646a8082d775f9c447d81.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Mzg4ODUzNzd9.A9WOYJFrgL2swVGnydpb4gMojyvyoNPCXaA4rXGowqU \
--remote-runtime-endpoint=unix:///var/run/crio/crio.sock \
--runtimetype=remote \
--cgroupdriver=systemd
```

Output:

```bash
Host has mosquit+ already installed and running. Hence skipping the installation steps !!!
...
KubeEdge edgecore is running, For logs visit:  /var/log/kubeedge/edgecore.log
```

### Get Edge Node Status From Cloud Side

Output:

```bash
kubectl get node
NAME       STATUS    ROLES                  AGE   VERSION
edge       Ready     agent,edge             10s   v1.19.3-kubeedge-v1.8.2
master     Ready     control-plane,master   68m   v1.21.0
```

## 3. Enable kubectl logs Feature

Before metrics-server deployed, kubectl logs feature must be activated, please [see here](https://kubeedge.io/en/docs/setup/keadm/#enable-kubectl-logs-feature).

## 4. Run a simple WebAssembly app

We can run the WebAssembly-based image from Docker Hub in the Kubernetes cluster.

### Cloud Side

```bash
$ kubectl run -it --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" /wasi_example_main.wasm 50000000

Random number: -1694733782
Random bytes: [6, 226, 176, 126, 136, 114, 90, 2, 216, 17, 241, 217, 143, 189, 123, 197, 17, 60, 49, 37, 71, 69, 67, 108, 66, 39, 105, 9, 6, 72, 232, 238, 102, 5, 148, 243, 249, 183, 52, 228, 54, 176, 63, 249, 216, 217, 46, 74, 88, 204, 130, 191, 182, 19, 118, 193, 77, 35, 189, 6, 139, 68, 163, 214, 231, 100, 138, 246, 185, 47, 37, 49, 3, 7, 176, 97, 68, 124, 20, 235, 145, 166, 142, 159, 114, 163, 186, 46, 161, 144, 191, 211, 69, 19, 179, 241, 8, 207, 8, 112, 80, 170, 33, 51, 251, 33, 105, 0, 178, 175, 129, 225, 112, 126, 102, 219, 106, 77, 242, 104, 198, 238, 193, 247, 23, 47, 22, 29]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
```

The WebAssembly app of the pod successfully deploys to the edge node.

```bash
$ kubectl describe pod wasi-demo

Name:         wasi-demo
Namespace:    default
Priority:     0
Node:         edge/192.168.122.229
Start Time:   Mon, 06 Dec 2021 15:45:34 +0000
Labels:       run=wasi-demo
Annotations:  module.wasm.image/variant: compat-smart
Status:       Succeeded
IP:
IPs:          <none>
Containers:
  wasi-demo:
    Container ID:  cri-o://1ae4d0d7f671050331a17e9b61b5436bf97ad35ad0358bef043ab820aed81069
    Image:         wasmedge/example-wasi:latest
    Image ID:      docker.io/wasmedge/example-wasi@sha256:525aab8d6ae8a317fd3e83cdac14b7883b92321c7bec72a545edf276bb2100d6
    Port:          <none>
    Host Port:     <none>
    Args:
      /wasi_example_main.wasm
      50000000
    State:          Terminated
      Reason:       Completed
      Exit Code:    0
      Started:      Mon, 06 Dec 2021 15:45:33 +0000
      Finished:     Mon, 06 Dec 2021 15:45:33 +0000
    Ready:          False
    Restart Count:  0
    Environment:    <none>
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-bhszr (ro)
Conditions:
  Type           Status
  Initialized    True
  Ready          False
  PodScheduled   True
Volumes:
  kube-api-access-bhszr:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    ConfigMapOptional:       <nil>
    DownwardAPI:             true
QoS Class:                   BestEffort
Node-Selectors:              <none>
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
```

### Edge Side

```bash
$ sudo crictl ps -a
CONTAINER           IMAGE                                                                                           CREATED             STATE               NAME                ATTEMPT             POD ID
1ae4d0d7f6710       0423b8eb71e312b8aaa09a0f0b6976381ff567d5b1e5729bf9b9aa87bff1c9f3                                16 minutes ago      Exited              wasi-demo           0                   2bc2ac0c32eda
1e6c7cb6bc731       registry.k8s.io/kube-proxy@sha256:2a25285ff19f9b4025c8e54dac42bb3cd9aceadc361f2570489b8d723cb77135   18 minutes ago      Running             kube-proxy          0                   8b7e7388ad866
```

That's it.

## 5. Demo Run Screen Recording

[![asciicast](https://asciinema.org/a/wkLOu6xnAOSAQdmYayumwrAvh.svg)](https://asciinema.org/a/wkLOu6xnAOSAQdmYayumwrAvh)
","**Summary**

This code is part of the KubeEdge documentation, which guides users through setting up a Kubernetes cluster on both cloud and edge nodes. The process involves installing necessary components such as CRI-O, Go, and KubeEdge.

**Key Components**

1. **CRI-O**: A container runtime interface for OCI (Open Container Initiative).
2. **Go**: A programming language used to build the KubeEdge components.
3. **KubeEdge**: An open-source system that extends native containerized application orchestration capabilities to hosts at Edge.
4. **kubectl**: The command-line tool for managing Kubernetes clusters.

**Installation Steps**

1. Cloud Side:
	* Install CRI-O and crun on Ubuntu 20.04 using the install.sh script.
	* Install Go and configure the kubeconfig file.
2. Edge Side:
	* Install CRI-O and crun on Ubuntu 20.04 using the install.sh script.
	* Get the token from the cloud side using `sudo ./keadm gettoken`.
3. Setup KubeEdge:
	* Download the keadm binary and join the edge node to the cluster using `sudo ./keadm join`.

**Demo**

The demo runs a simple WebAssembly app on the Kubernetes cluster, showcasing its functionality.

**Notes**

* The code includes links to external resources, such as Docker Hub and GitHub repositories.
* Some steps may require modifications based on specific system configurations or versions.
* This guide assumes a basic understanding of Linux, CRI-O, Go, and Kubernetes."
docs/embed/c/host_function.md,"---
sidebar_position: 3
---

# Host Functions

[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are the functions outside WebAssembly and are passed to WASM modules as imports. The following steps give an example of implementing host functions and registering a `host module` into the WasmEdge runtime.

## Host Instances

WasmEdge supports registering `host function`, `memory`, `table`, and `global` instances as imports.

### Functions

The host function body definition in WasmEdge is defined as follows:

```c
typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(
    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,
    const WasmEdge_Value *Params, WasmEdge_Value *Returns);
```

A simple host function can be defined as follows:

```c
#include <wasmedge/wasmedge.h>

/* This function can add 2 i32 values and return the result. */
WasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /*
  * Params: {i32, i32}
  * Returns: {i32}
  */

  /* Retrieve the value 1. */
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  /* Retrieve the value 2. */
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  /* Output value 1 is Val1 + Val2. */
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  /* Return the status of success. */
  return WasmEdge_Result_Success;
}
```

For adding the host function into a host module instance, developers should first create the function instance with the function type context.

```c
WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(), WasmEdge_ValTypeGenI32()};
WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};
/* Create a function type: {i32, i32} -> {i32}. */
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
/*
  * Create a function context with the function type and host function body.
  * The `Cost` parameter can be 0 if developers do not need the cost
  * measuring.
  */
WasmEdge_FunctionInstanceContext *HostFunc =
    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
  * The third parameter is the pointer to the additional data.
  * Developers should guarantee the life cycle of the data, and it can be NULL if the external data is not needed.
  */
WasmEdge_FunctionTypeDelete(HostType);
```

### Tables, Memories, and Globals

To create a `host table`, `memory`, and `global` instance, developers can use similar APIs.

```c
/* Create a host table exported as ""table"". */
WasmEdge_Limit TabLimit = {
    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};
WasmEdge_TableTypeContext *HostTType =
    WasmEdge_TableTypeCreate(WasmEdge_ValTypeGenFuncRef(), TabLimit);
WasmEdge_TableInstanceContext *HostTable =
    WasmEdge_TableInstanceCreate(HostTType);
WasmEdge_TableTypeDelete(HostTType);

/* Create a host memory exported as ""memory"". */
WasmEdge_Limit MemLimit = {.HasMax = true, .Shared = false, .Min = 1, .Max = 2};
WasmEdge_MemoryTypeContext *HostMType = WasmEdge_MemoryTypeCreate(MemLimit);
WasmEdge_MemoryInstanceContext *HostMemory =
    WasmEdge_MemoryInstanceCreate(HostMType);
WasmEdge_MemoryTypeDelete(HostMType);

/* Create a host global exported as ""global_i32"" and initialized as `666`. */
WasmEdge_GlobalTypeContext *HostGType =
    WasmEdge_GlobalTypeCreate(WasmEdge_ValTypeGenI32(), WasmEdge_Mutability_Const);
WasmEdge_GlobalInstanceContext *HostGlobal =
    WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));
WasmEdge_GlobalTypeDelete(HostGType);
```

## Host Modules

The host module is a module instance that contains `host functions`, `tables`, `memories`, and `globals`, the same as the WASM modules. Developers can use APIs to add the instances into a host module. After registering the host modules into a `VM` or `Store` context, the exported instances in that modules can be imported by WASM modules when instantiating.

### Module Instance Creation

Module instance supplies exported module name.

```c
WasmEdge_String HostName = WasmEdge_StringCreateByCString(""test"");
WasmEdge_ModuleInstanceContext *HostMod =
    WasmEdge_ModuleInstanceCreate(HostName);
WasmEdge_StringDelete(HostName);
```

### Add Instances

Developers can add the `host functions`, `tables`, `memories`, and `globals` into the module instance with the export name. After adding to the module, the ownership of the instances is moved into the module. Developers should **NOT** access or destroy them.

```c
/* Add the host function created above with the export name ""add"". */
HostName = WasmEdge_StringCreateByCString(""add"");
WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);
WasmEdge_StringDelete(HostName);

/* Add the table created above with the export name ""table"". */
HostName = WasmEdge_StringCreateByCString(""table"");
WasmEdge_ModuleInstanceAddTable(HostMod, HostName, HostTable);
WasmEdge_StringDelete(HostName);

/* Add the memory created above with the export name ""memory"". */
HostName = WasmEdge_StringCreateByCString(""memory"");
WasmEdge_ModuleInstanceAddMemory(HostMod, HostName, HostMemory);
WasmEdge_StringDelete(HostName);

/* Add the global created above with the export name ""global_i32"". */
HostName = WasmEdge_StringCreateByCString(""global_i32"");
WasmEdge_ModuleInstanceAddGlobal(HostMod, HostName, HostGlobal);
WasmEdge_StringDelete(HostName);
```

### Register Host Modules to WasmEdge

For importing the host functions in WASM, developers can register the host modules into a `VM` or `Store` context.

```c
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);

/* Register the module instance into the store. */
WasmEdge_Result Res =
    WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Host module registration failed: %s\n"",
         WasmEdge_ResultGetMessage(Res));
  return -1;
}
/*
 * Developers can register the host module into a VM context by the
 * `WasmEdge_VMRegisterModuleFromImport()` API.
 */
/*
 * The owner of the host module will not be changed. Developers can register
 * the host module into several VMs or stores.
 */

/* Although being registered, the host module should be destroyed. */
WasmEdge_StoreDelete(StoreCxt);
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_ModuleInstanceDelete(HostModCxt);
```

## Host Function Body Implementation Tips

There are some tips about implementing the host functions.

### Calling Frame Context

The `WasmEdge_CallingFrameContext` is the context to provide developers to access the module instance of the [frame on the top of the calling stack](https://webassembly.github.io/spec/core/exec/runtime.html#activations-and-frames). According to the [WASM spec](https://webassembly.github.io/spec/core/exec/instructions.html#function-calls), a frame with the module instance to which the caller function belonging is pushed into the stack when invoking a function. Therefore, the host functions can access the module instance of the top frame to retrieve the memory instances to read/write data.

```c
/* Host function body definition. */
WasmEdge_Result LoadOffset(void *Data,
                           const WasmEdge_CallingFrameContext *CallFrameCxt,
                           const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {i32} -> {} */
  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);
  uint32_t Num = 0;

  /* Get the 0th memory instance of the module of the top frame on the stack. */
  /*
   * Noticed that the `MemCxt` will be `NULL` if there's no memory instance in
   * the module instance on the top frame.
   */
  WasmEdge_MemoryInstanceContext *MemCxt =
      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);
  WasmEdge_Result Res =
      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);
  if (WasmEdge_ResultOK(Res)) {
    printf(""u32 at memory[%u]: %u\n"", Offset, Num);
  } else {
    return Res;
  }
  return WasmEdge_Result_Success;
}
```

The `WasmEdge_CallingFrameGetModuleInstance()` API can help developers to get the module instance of the top frame on the stack. With the module instance context, developers can use the module instance-related APIs to get its contents. The `WasmEdge_CallingFrameGetExecutor()` API can help developers to get the currently used executor context. Therefore developers can use the executor to recursively invoke other WASM functions without creating a new executor context.

### Return Error Codes

Usually, the host function in WasmEdge can return the `WasmEdge_Result_Success` to present the successful execution. For presenting the host function execution failed, one way is to return a trap with the error code. Then the WasmEdge runtime will cause the trap in WASM and return that error.

<!-- prettier-ignore -->
:::note
We don't recommend using system calls such as `exit()`. That will shut down the whole WasmEdge runtime._
:::

For simply generating the trap, developers can return the `WasmEdge_Result_Fail`. If developers call the `WasmEdge_ResultOK()` with the returned result, they will get `false`. If developers call the `WasmEdge_ResultGetCode()` with the returned result, they will always get `2`.

For the versions after `0.11.0`, developers can specify the error code within 24-bit (smaller than `16777216`) size.

```c
/* Host function body definition. */
WasmEdge_Result FaildFunc(void *Data,
                          const WasmEdge_CallingFrameContext *CallFrameCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* This will create a trap in WASM with the error code. */
  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);
}
```

Therefore when developers call the `WasmEdge_ResultGetCode()` with the returned result, they will get the error code `12345678`. If developers call the `WasmEdge_ResultGetMessage()`, they will always get the C string `""user defined error code""`.

### Host Data

The third parameter of the `WasmEdge_FunctionInstanceCreate()` API is for the host data as the type `void *`. Developers can pass the data into the host functions when creating. Then in the host function body, developers can access the data from the first argument. Developers should guarantee that the availability of the host data should be longer than the host functions.

```c
/* Host function body definition. */
WasmEdge_Result PrintData(void *Data,
                          const WasmEdge_CallingFrameContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {} -> {} */
  printf(""Data: %lf\n"", *(double *)Data);
  return WasmEdge_Result_Success;
}

/* The host data. */
double Number = 0.0f;

/* Create a function type: {} -> {}. */
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(NULL, 0, NULL, 0);
/* Create a function context with the function type and host function body. */
WasmEdge_FunctionInstanceContext *HostFunc =
    WasmEdge_FunctionInstanceCreate(HostFType, &PrintData, (void *)(&Number), 0);
WasmEdge_FunctionTypeDelete(HostType);
```

### Forcing Termination

Sometimes developers may want to terminate the WASM execution with the success status. WasmEdge provides a method for terminating WASM execution in host functions. Developers can return `WasmEdge_Result_Terminate` to trigger the forcing termination of the current execution. If developers call the `WasmEdge_ResultOK()` with the returned result, they will get `true`. If developers call the `WasmEdge_ResultGetCode()` with the returned result, they will always get `1`.
","The provided code is part of the WasmEdge documentation, specifically the `host_function.md` file. It explains how to implement host functions and register them in a WASM module instance.

**Purpose:** The purpose of this code snippet is to demonstrate how to create a host function and add it to a WASM module instance using the WasmEdge API.

**Functionality:**

*   The code defines a simple host function called `Add` that takes two 32-bit integer values as input, adds them together, and returns the result.
*   It shows how to create a function type context for the `Add` function using the `WasmEdge_FunctionTypeCreate` API.
*   The code then creates a function instance context from the function type context and sets up the host function body with the `WasmEdge_FunctionInstanceCreate` API.

**Key Components:**

*   **WasmEdge_HostFunc_t**: A function pointer type that represents a host function. It takes four arguments: `void *Data`, `const WasmEdge_CallingFrameContext *CallFrameCxt`, `const WasmEdge_Value *Params`, and `WasmEdge_Value *Returns`.
*   **Add**: The example host function body definition.
*   **HostFType**: A function type context created using the `WasmEdge_FunctionTypeCreate` API. It represents the input parameters and return value of the `Add` function.
*   **HostFunc**: A function instance context created from the `HostFType` using the `WasmEdge_FunctionInstanceCreate` API.

**Potential Issues or Areas for Improvement:**

*   The code does not handle errors properly. If an error occurs during function creation, it will lead to a crash or incorrect results.
*   There is no validation of the input parameters and return values of the host function. This can cause issues if the inputs are invalid or the function returns an unexpected value.
*   The example host function `Add` does not handle edge cases such as overflow when adding two large numbers together.

Overall, this code snippet provides a basic introduction to implementing host functions in WasmEdge and creating WASM module instances. However, it requires additional error handling, parameter validation, and edge case consideration for real-world applications."
i18n/zh/docusaurus-plugin-content-docs/current/embed/c/host_function.md,"---
sidebar_position: 3
---

# Host Functions

[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are the functions outside WebAssembly and are passed to WASM modules as imports. The following steps give an example of implementing host functions and registering a `host module` into the WasmEdge runtime.

## Host Instances

WasmEdge supports registering `host function`, `memory`, `table`, and `global` instances as imports.

### Functions

The host function body definition in WasmEdge is defined as follows:

```c
typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(
    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,
    const WasmEdge_Value *Params, WasmEdge_Value *Returns);
```

A simple host function can be defined as follows:

```c
#include <wasmedge/wasmedge.h>

/* This function can add 2 i32 values and return the result. */
WasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /*
  * Params: {i32, i32}
  * Returns: {i32}
  */

  /* Retrieve the value 1. */
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  /* Retrieve the value 2. */
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  /* Output value 1 is Val1 + Val2. */
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  /* Return the status of success. */
  return WasmEdge_Result_Success;
}
```

For adding the host function into a host module instance, developers should first create the function instance with the function type context.

```c
WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(), WasmEdge_ValTypeGenI32()};
WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};
/* Create a function type: {i32, i32} -> {i32}. */
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
/*
  * Create a function context with the function type and host function body.
  * The `Cost` parameter can be 0 if developers do not need the cost
  * measuring.
  */
WasmEdge_FunctionInstanceContext *HostFunc =
    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
  * The third parameter is the pointer to the additional data.
  * Developers should guarantee the life cycle of the data, and it can be NULL if the external data is not needed.
  */
WasmEdge_FunctionTypeDelete(HostType);
```

### Tables, Memories, and Globals

To create a `host table`, `memory`, and `global` instance, developers can use similar APIs.

```c
/* Create a host table exported as ""table"". */
WasmEdge_Limit TabLimit = {
    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};
WasmEdge_TableTypeContext *HostTType =
    WasmEdge_TableTypeCreate(WasmEdge_ValTypeGenFuncRef(), TabLimit);
WasmEdge_TableInstanceContext *HostTable =
    WasmEdge_TableInstanceCreate(HostTType);
WasmEdge_TableTypeDelete(HostTType);

/* Create a host memory exported as ""memory"". */
WasmEdge_Limit MemLimit = {.HasMax = true, .Shared = false, .Min = 1, .Max = 2};
WasmEdge_MemoryTypeContext *HostMType = WasmEdge_MemoryTypeCreate(MemLimit);
WasmEdge_MemoryInstanceContext *HostMemory =
    WasmEdge_MemoryInstanceCreate(HostMType);
WasmEdge_MemoryTypeDelete(HostMType);

/* Create a host global exported as ""global_i32"" and initialized as `666`. */
WasmEdge_GlobalTypeContext *HostGType =
    WasmEdge_GlobalTypeCreate(WasmEdge_ValTypeGenI32(), WasmEdge_Mutability_Const);
WasmEdge_GlobalInstanceContext *HostGlobal =
    WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));
WasmEdge_GlobalTypeDelete(HostGType);
```

## Host Modules

The host module is a module instance that contains `host functions`, `tables`, `memories`, and `globals`, the same as the WASM modules. Developers can use APIs to add the instances into a host module. After registering the host modules into a `VM` or `Store` context, the exported instances in that modules can be imported by WASM modules when instantiating.

### Module Instance Creation

Module instance supplies exported module name.

```c
WasmEdge_String HostName = WasmEdge_StringCreateByCString(""test"");
WasmEdge_ModuleInstanceContext *HostMod =
    WasmEdge_ModuleInstanceCreate(HostName);
WasmEdge_StringDelete(HostName);
```

### Add Instances

Developers can add the `host functions`, `tables`, `memories`, and `globals` into the module instance with the export name. After adding to the module, the ownership of the instances is moved into the module. Developers should **NOT** access or destroy them.

```c
/* Add the host function created above with the export name ""add"". */
HostName = WasmEdge_StringCreateByCString(""add"");
WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);
WasmEdge_StringDelete(HostName);

/* Add the table created above with the export name ""table"". */
HostName = WasmEdge_StringCreateByCString(""table"");
WasmEdge_ModuleInstanceAddTable(HostMod, HostName, HostTable);
WasmEdge_StringDelete(HostName);

/* Add the memory created above with the export name ""memory"". */
HostName = WasmEdge_StringCreateByCString(""memory"");
WasmEdge_ModuleInstanceAddMemory(HostMod, HostName, HostMemory);
WasmEdge_StringDelete(HostName);

/* Add the global created above with the export name ""global_i32"". */
HostName = WasmEdge_StringCreateByCString(""global_i32"");
WasmEdge_ModuleInstanceAddGlobal(HostMod, HostName, HostGlobal);
WasmEdge_StringDelete(HostName);
```

### Register Host Modules to WasmEdge

For importing the host functions in WASM, developers can register the host modules into a `VM` or `Store` context.

```c
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);

/* Register the module instance into the store. */
WasmEdge_Result Res =
    WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Host module registration failed: %s\n"",
         WasmEdge_ResultGetMessage(Res));
  return -1;
}
/*
 * Developers can register the host module into a VM context by the
 * `WasmEdge_VMRegisterModuleFromImport()` API.
 */
/*
 * The owner of the host module will not be changed. Developers can register
 * the host module into several VMs or stores.
 */

/* Although being registered, the host module should be destroyed. */
WasmEdge_StoreDelete(StoreCxt);
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_ModuleInstanceDelete(HostModCxt);
```

## Host Function Body Implementation Tips

There are some tips about implementing the host functions.

### Calling Frame Context

The `WasmEdge_CallingFrameContext` is the context to provide developers to access the module instance of the [frame on the top of the calling stack](https://webassembly.github.io/spec/core/exec/runtime.html#activations-and-frames). According to the [WASM spec](https://webassembly.github.io/spec/core/exec/instructions.html#function-calls), a frame with the module instance to which the caller function belonging is pushed into the stack when invoking a function. Therefore, the host functions can access the module instance of the top frame to retrieve the memory instances to read/write data.

```c
/* Host function body definition. */
WasmEdge_Result LoadOffset(void *Data,
                           const WasmEdge_CallingFrameContext *CallFrameCxt,
                           const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {i32} -> {} */
  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);
  uint32_t Num = 0;

  /* Get the 0th memory instance of the module of the top frame on the stack. */
  /*
   * Noticed that the `MemCxt` will be `NULL` if there's no memory instance in
   * the module instance on the top frame.
   */
  WasmEdge_MemoryInstanceContext *MemCxt =
      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);
  WasmEdge_Result Res =
      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);
  if (WasmEdge_ResultOK(Res)) {
    printf(""u32 at memory[%u]: %u\n"", Offset, Num);
  } else {
    return Res;
  }
  return WasmEdge_Result_Success;
}
```

The `WasmEdge_CallingFrameGetModuleInstance()` API can help developers to get the module instance of the top frame on the stack. With the module instance context, developers can use the module instance-related APIs to get its contents. The `WasmEdge_CallingFrameGetExecutor()` API can help developers to get the currently used executor context. Therefore developers can use the executor to recursively invoke other WASM functions without creating a new executor context.

### Return Error Codes

Usually, the host function in WasmEdge can return the `WasmEdge_Result_Success` to present the successful execution. For presenting the host function execution failed, one way is to return a trap with the error code. Then the WasmEdge runtime will cause the trap in WASM and return that error.

<!-- prettier-ignore -->
:::note
We don't recommend using system calls such as `exit()`. That will shut down the whole WasmEdge runtime._
:::

For simply generating the trap, developers can return the `WasmEdge_Result_Fail`. If developers call the `WasmEdge_ResultOK()` with the returned result, they will get `false`. If developers call the `WasmEdge_ResultGetCode()` with the returned result, they will always get `2`.

For the versions after `0.11.0`, developers can specify the error code within 24-bit (smaller than `16777216`) size.

```c
/* Host function body definition. */
WasmEdge_Result FaildFunc(void *Data,
                          const WasmEdge_CallingFrameContext *CallFrameCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* This will create a trap in WASM with the error code. */
  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);
}
```

Therefore when developers call the `WasmEdge_ResultGetCode()` with the returned result, they will get the error code `12345678`. If developers call the `WasmEdge_ResultGetMessage()`, they will always get the C string `""user defined error code""`.

### Host Data

The third parameter of the `WasmEdge_FunctionInstanceCreate()` API is for the host data as the type `void *`. Developers can pass the data into the host functions when creating. Then in the host function body, developers can access the data from the first argument. Developers should guarantee that the availability of the host data should be longer than the host functions.

```c
/* Host function body definition. */
WasmEdge_Result PrintData(void *Data,
                          const WasmEdge_CallingFrameContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {} -> {} */
  printf(""Data: %lf\n"", *(double *)Data);
  return WasmEdge_Result_Success;
}

/* The host data. */
double Number = 0.0f;

/* Create a function type: {} -> {}. */
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(NULL, 0, NULL, 0);
/* Create a function context with the function type and host function body. */
WasmEdge_FunctionInstanceContext *HostFunc =
    WasmEdge_FunctionInstanceCreate(HostFType, &PrintData, (void *)(&Number), 0);
WasmEdge_FunctionTypeDelete(HostType);
```

### Forcing Termination

Sometimes developers may want to terminate the WASM execution with the success status. WasmEdge provides a method for terminating WASM execution in host functions. Developers can return `WasmEdge_Result_Terminate` to trigger the forcing termination of the current execution. If developers call the `WasmEdge_ResultOK()` with the returned result, they will get `true`. If developers call the `WasmEdge_ResultGetCode()` with the returned result, they will always get `1`.
","This document provides a detailed summary of the code, which focuses on implementing host functions in WasmEdge. Host functions are functions outside WebAssembly that can be passed to WASM modules as imports.

**Purpose**

The purpose of this code is to provide an example of how to implement and register host functions in WasmEdge, along with creating a host module instance and adding instances (functions, tables, memories, and globals) to it. The goal is to enable developers to create custom functionality within WASM modules using external C functions.

**Key Components**

1. **Host Function Implementation**: The code demonstrates how to implement a simple host function in C that can be used by a WASM module.
2. **Creating Host Module Instance**: A host module instance is created, which will serve as the container for adding various instances (functions, tables, memories, and globals) that can be exported to a WASM module.
3. **Adding Instances to Host Module**: The code shows how to add different types of instances (functions, tables, memories, and globals) to the host module instance.
4. **Registering Host Modules in WasmEdge**: The final step is registering the host module instance into a WasmEdge runtime context.

**Notes and Recommendations**

* When implementing host functions, be aware that the `WasmEdge_CallingFrameContext` provides access to the current calling frame on the stack, which can help with accessing memory instances.
* Consider using system calls like `exit()` carefully, as they will shut down the entire WasmEdge runtime.
* To create a trap in WASM, return `WasmEdge_Result_Fail`, and if you want to specify an error code, use `WasmEdge_ResultGen` with an error category and a 24-bit (smaller than 16777216) error code.

Overall, this document provides a comprehensive guide for implementing host functions and creating a host module instance in WasmEdge. It also highlights important considerations for developers to keep in mind when working with host functions and WasmEdge."
docs/embed/use-case/yomo.md,"---
sidebar_position: 2
---

# YoMo Framework

[YoMo](https://yomo.run/) is a programming framework enabling developers to build a distributed cloud system (Geo-Distributed Cloud System). YoMo's communication layer is made on top of the QUIC protocol, which brings high-speed data transmission. In addition, it has a built-in Streaming Serverless ""streaming function"", which significantly improves the development experience of distributed cloud systems. The distributed cloud system built by YoMo provides an ultra-high-speed communication mechanism between near-field computing power and terminals. It has many use cases in Metaverse, VR/AR, IoT, etc.

YoMo is written in the Go language. For streaming Serverless, Golang plug-ins and shared libraries are used to load users' code dynamically, which also has certain limitations for developers. With Serverless architecture's rigid demand for isolation, WebAssembly is an excellent choice for running user-defined functions.

For example, in real-time AI inference in AR/VR devices or smart factories, the camera sends real-time unstructured data to the computing node in the near-field MEC (multi-access edge computing) device through YoMo. YoMo sends the AI computing result to the end device in real time when the AI inference is completed. Thus, the hosted AI inference function will be automatically executed.

However, a challenge for YoMo is incorporating and managing handler functions written by multiple outside developers in an edge computing node. It requires runtime isolation for those functions without sacrificing performance. Traditional software container solutions like Docker need to be updated to the task. They need to be lighter and faster to handle real-time tasks.

WebAssembly provides a lightweight and high-performance software container. It is ideally suited as a runtime for YoMo’s data processing handler functions.

This article will show you how to create a Rust function for Tensorflow-based image classification, compile it into WebAssembly, and then use YoMo to run it as a stream data handler. We use [WasmEdge](https://wasmedge.org/) as our WebAssembly runtime because it offers the highest performance and flexibility compared with other WebAssembly runtimes. It is the only WebAssembly VM that reliably supports Tensorflow. YoMo manages WasmEdge VM instances and the contained WebAssembly bytecode apps through [WasmEdge’s Golang API](../go/intro.md).

<!-- prettier-ignore -->
:::note
Source code: <https://github.com/yomorun/yomo-wasmedge-tensorflow>
:::

Checkout [the WasmEdge image classification function in action in YoMo](https://www.youtube.com/watch?v=E0ltsn6cLIU)

## Prerequisite

You will need to have [Golang installed](https://golang.org/doc/install), but I assume you already did.

<!-- prettier-ignore -->
:::note
Golang version should be newer than 1.15 for our example to work.
:::

You also need to install the YoMo CLI application. It orchestrates and coordinates data streaming and handler function invocations.

```bash
$ go install github.com/yomorun/cli/yomo@latest
$ yomo version
YoMo CLI version: v0.1.3
```

Next, please install the WasmEdge and its Tensorflow shared libraries. [WasmEdge](https://wasmedge.org/) is a leading WebAssembly runtime hosted by the CNCF. We will use it to embed and run WebAssembly programs from YoMo.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
```

Finally, since our demo WebAssembly functions are written in Rust, you need a [Rust compiler](https://www.rust-lang.org/tools/install).

For the rest of the demo, fork, and clone the [source code repository](https://github.com/yomorun/yomo-wasmedge-tensorflow).

```bash
git clone https://github.com/yomorun/yomo-wasmedge-tensorflow.git
```

## The image classification function

The [image classification function](https://github.com/yomorun/yomo-wasmedge-tensorflow/tree/main/flow/rust_mobilenet_food) to process the YoMo image stream is written in Rust. It utilizes the WasmEdge Tensorflow API to process an input image.

```rust
#[wasmedge_bindgen]
pub fn infer(image_data: Vec<u8>) -> Result<Vec<u8>, String> {
  let start = Instant::now();

  // Load the TFLite model and its metadata (the text label for each recognized object number)
  let model_data: &[u8] = include_bytes!(""lite-model_aiy_vision_classifier_food_V1_1.tflite"");
  let labels = include_str!(""aiy_food_V1_labelmap.txt"");

  // Pre-process the image to a format that this model can use
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&image_data[..], 192, 192);
  println!(""RUST: Loaded image in ... {:?}"", start.elapsed());

  // Run the TFLite model using the WasmEdge Tensorflow API
  let mut session = wasmedge_tensorflow_interface::Session::new(&model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(""input"", &flat_img, &[1, 192, 192, 3])
         .run();
  let res_vec: Vec<u8> = session.get_output(""MobilenetV1/Predictions/Softmax"");

  // Find the object index in res_vec that has the greatest probability
  // Translate the probability into a confidence level
  // Translate the object index into a label from the model metadata food_name
  let mut i = 0;
  let mut max_index: i32 = -1;
  let mut max_value: u8 = 0;
  while i < res_vec.len() {
    let cur = res_vec[i];
    if cur > max_value {
      max_value = cur;
      max_index = i as i32;
    }
    i += 1;
  }
  println!(""RUST: index {}, prob {}"", max_index, max_value);

  let confidence: String;
  if max_value > 200 {
    confidence = ""is very likely"".to_string();
  } else if max_value > 125 {
    confidence = ""is likely"".to_string();
  } else {
    confidence = ""could be"".to_string();
  }

  let ret_str: String;
  if max_value > 50 {
    let mut label_lines = labels.lines();
    for _i in 0..max_index {
      label_lines.next();
    }
    let food_name = label_lines.next().unwrap().to_string();
    ret_str = format!(
      ""It {} a <a href='https://www.google.com/search?q={}'>{}</a> in the picture"",
      confidence, food_name, food_name
    );
  } else {
    ret_str = ""It does not appears to be a food item in the picture."".to_string();
  }

  println!(
    ""RUST: Finished post-processing in ... {:?}"",
    start.elapsed()
  );
  return Ok(ret_str.as_bytes().to_vec());
}
```

You should add `wasm32-wasi` target to rust to compile this function into WebAssembly bytecode.

```bash
rustup target add wasm32-wasi

cd flow/rust_mobilenet_food
cargo build --target wasm32-wasi --release
# The output WASM will be target/wasm32-wasi/release/rust_mobilenet_food_lib.wasm

# Copy the wasm bytecode file to the flow/ directory
cp target/wasm32-wasi/release/rust_mobilenet_food_lib.wasm ../
```

To release the best performance of WasmEdge, you should enable the AOT mode by compiling the `.wasm` file to the `.so`.

```bash
wasmedge compile rust_mobilenet_food_lib.wasm rust_mobilenet_food_lib.so
```

## Integration with YoMo

On the YoMo side, we use the WasmEdge Golang API to start and run WasmEdge VM for the image classification function. The [app.go](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go) file in the source code project is as follows.

```go
package main

import (
  ""crypto/sha1""
  ""fmt""
  ""log""
  ""os""
  ""sync/atomic""

  ""github.com/second-state/WasmEdge-go/wasmedge""
  bindgen ""github.com/second-state/wasmedge-bindgen/host/go""
  ""github.com/yomorun/yomo""
)

var (
  counter uint64
)

const ImageDataKey = 0x10

func main() {
  // Connect to Zipper service
  sfn := yomo.NewStreamFunction(""image-recognition"", yomo.WithZipperAddr(""localhost:9900""))
  defer sfn.Close()

  // set only monitoring data
  sfn.SetObserveDataID(ImageDataKey)

  // set handler
  sfn.SetHandler(Handler)

  // start
  err := sfn.Connect()
  if err != nil {
    log.Print(""❌ Connect to zipper failure: "", err)
    os.Exit(1)
  }

  select {}
}

// Handler processes the data in the stream
func Handler(img []byte) (byte, []byte) {
  // Initialize WasmEdge's VM
  vmConf, vm := initVM()
  bg := bindgen.Instantiate(vm)
  defer bg.Release()
  defer vm.Release()
  defer vmConf.Release()

  // recognize the image
  res, err := bg.Execute(""infer"", img)
  if err == nil {
    fmt.Println(""GO: Run bindgen -- infer:"", string(res))
  } else {
    fmt.Println(""GO: Run bindgen -- infer FAILED"")
  }

  // print logs
  hash := genSha1(img)
  log.Printf(""✅ received image-%d hash %v, img_size=%d \n"", atomic.AddUint64(&counter, 1), hash, len(img))

  return 0x11, nil
}

// genSha1 generate the hash value of the image
func genSha1(buf []byte) string {
  h := sha1.New()
  h.Write(buf)
  return fmt.Sprintf(""%x"", h.Sum(nil))
}

// initVM initialize WasmEdge's VM
func initVM() (*wasmedge.Configure, *wasmedge.VM) {
  wasmedge.SetLogErrorLevel()
  // Set Tensorflow not to print debug info
  os.Setenv(""TF_CPP_MIN_LOG_LEVEL"", ""3"")
  os.Setenv(""TF_CPP_MIN_VLOG_LEVEL"", ""3"")

  // Create configure
  vmConf := wasmedge.NewConfigure(wasmedge.WASI)

  // Create VM with configure
  vm := wasmedge.NewVMWithConfig(vmConf)

  // Init WASI
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{"".:.""}, // The mapping directories
  )

  // Register WasmEdge-tensorflow and WasmEdge-image
  var tfobj = wasmedge.NewTensorflowImportObject()
  var tfliteobj = wasmedge.NewTensorflowLiteImportObject()
  vm.RegisterImport(tfobj)
  vm.RegisterImport(tfliteobj)
  var imgobj = wasmedge.NewImageImportObject()
  vm.RegisterImport(imgobj)

  // Instantiate wasm
  vm.LoadWasmFile(""rust_mobilenet_food_lib.so"")
  vm.Validate()

  return vmConf, vm
}
```

## In action

Finally, we can start YoMo and see the entire data processing pipeline. Start the YoMo CLI application from the project folder. The [yaml file](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/zipper/workflow.yaml) defines port YoMo should listen on and the workflow handler to trigger for incoming data. Note that the flow name `image-recognition` matches the name in the aforementioned data handler [app.go](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go).

```bash
yomo serve -c ./zipper/workflow.yaml
```

Start the handler function by running the aforementioned [app.go](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go) program.

```bash
cd flow
go run --tags ""tensorflow image"" app.go
```

[Start a simulated data source](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/source/main.go) by sending a video to YoMo. The video is a series of image frames. The WasmEdge function in [app.go](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go) will be invoked against every image frame in the video.

```bash
# Download a video file
wget -P source 'https://github.com/yomorun/yomo-wasmedge-tensorflow/releases/download/v0.1.0/hot-dog.mp4'

# Stream the video to YoMo
go run ./source/main.go ./source/hot-dog.mp4
```

You can see the output from the WasmEdge handler function in the console. It prints the names of the objects detected in each image frame in the video.

## What's next

This article shows how to use the WasmEdge Tensorflow API and Golang SDK in YoMo framework to process an image stream in near real-time.

In collaboration with YoMo, we will soon deploy WasmEdge in production in smart factories for various assembly line tasks. WasmEdge is the software runtime for edge computing!
","**Summary**

The code is an example of using the YoMo framework, a programming framework for building distributed cloud systems, to process image streams in near real-time. The code uses WasmEdge, a WebAssembly runtime, as the software container for running user-defined functions written in Rust. The article provides step-by-step instructions on how to create and deploy a data processing pipeline using YoMo, WasmEdge, and Golang.

**Key Components**

*   **YoMo Framework**: A programming framework for building distributed cloud systems.
*   **WasmEdge**: A WebAssembly runtime used as the software container for running user-defined functions written in Rust.
*   **Golang SDK**: The Go language's standard library for interacting with WasmEdge.
*   **Tensorflow API**: An open-source machine learning library that provides a framework for building and training neural networks.

**Functionality**

The code enables the following functionality:

1.  **Image Classification**: The code uses a pre-trained TensorFlow model to classify images in an image stream into different categories.
2.  **Real-time Processing**: The code processes the image stream in near real-time, with each image being processed as soon as it is received.
3.  **Edge Computing**: The code runs on edge devices, such as smart factories' assembly line equipment, to enable real-time processing of image streams.

**Potential Issues and Areas for Improvement**

1.  **Performance Optimization**: Further optimizations can be made to improve the performance of the WasmEdge runtime and reduce latency.
2.  **Model Updates**: The TensorFlow model used in this example may need to be updated periodically to ensure it remains accurate and effective in classifying images.
3.  **Error Handling**: More comprehensive error handling should be implemented to handle unexpected errors or edge cases that may arise during the processing of image streams.

**Recommendations**

1.  **Use WasmEdge's built-in debugging tools**: Utilize WasmEdge's built-in debugging tools, such as its JavaScript debugger and console API, to troubleshoot issues with the code.
2.  **Implement more robust error handling**: Implement more comprehensive error handling mechanisms to ensure that unexpected errors or edge cases are handled properly.
3.  **Continuously monitor performance**: Continuously monitor the performance of the code and make adjustments as needed to optimize its performance and reduce latency."
i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/yomo.md,"---
sidebar_position: 2
---

# YoMo Framework

[YoMo](https://yomo.run/) is a programming framework enabling developers to build a distributed cloud system (Geo-Distributed Cloud System). YoMo's communication layer is made on top of the QUIC protocol, which brings high-speed data transmission. In addition, it has a built-in Streaming Serverless ""streaming function"", which significantly improves the development experience of distributed cloud systems. The distributed cloud system built by YoMo provides an ultra-high-speed communication mechanism between near-field computing power and terminals. It has many use cases in Metaverse, VR/AR, IoT, etc.

YoMo is written in the Go language. For streaming Serverless, Golang plug-ins and shared libraries are used to load users' code dynamically, which also has certain limitations for developers. With Serverless architecture's rigid demand for isolation, WebAssembly is an excellent choice for running user-defined functions.

For example, in real-time AI inference in AR/VR devices or smart factories, the camera sends real-time unstructured data to the computing node in the near-field MEC (multi-access edge computing) device through YoMo. YoMo sends the AI computing result to the end device in real time when the AI inference is completed. Thus, the hosted AI inference function will be automatically executed.

However, a challenge for YoMo is incorporating and managing handler functions written by multiple outside developers in an edge computing node. It requires runtime isolation for those functions without sacrificing performance. Traditional software container solutions like Docker need to be updated to the task. They need to be lighter and faster to handle real-time tasks.

WebAssembly provides a lightweight and high-performance software container. It is ideally suited as a runtime for YoMo’s data processing handler functions.

This article will show you how to create a Rust function for Tensorflow-based image classification, compile it into WebAssembly, and then use YoMo to run it as a stream data handler. We use [WasmEdge](https://wasmedge.org/) as our WebAssembly runtime because it offers the highest performance and flexibility compared with other WebAssembly runtimes. It is the only WebAssembly VM that reliably supports Tensorflow. YoMo manages WasmEdge VM instances and the contained WebAssembly bytecode apps through [WasmEdge’s Golang API](../go/intro.md).

<!-- prettier-ignore -->
:::note
Source code: <https://github.com/yomorun/yomo-wasmedge-tensorflow>
:::

Checkout [the WasmEdge image classification function in action in YoMo](https://www.youtube.com/watch?v=E0ltsn6cLIU)

## Prerequisite

You will need to have [Golang installed](https://golang.org/doc/install), but I assume you already did.

<!-- prettier-ignore -->
:::note
Golang version should be newer than 1.15 for our example to work.
:::

You also need to install the YoMo CLI application. It orchestrates and coordinates data streaming and handler function invocations.

```bash
$ go install github.com/yomorun/cli/yomo@latest
$ yomo version
YoMo CLI version: v0.1.3
```

Next, please install the WasmEdge and its Tensorflow shared libraries. [WasmEdge](https://wasmedge.org/) is a leading WebAssembly runtime hosted by the CNCF. We will use it to embed and run WebAssembly programs from YoMo.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
```

Finally, since our demo WebAssembly functions are written in Rust, you need a [Rust compiler](https://www.rust-lang.org/tools/install).

For the rest of the demo, fork, and clone the [source code repository](https://github.com/yomorun/yomo-wasmedge-tensorflow).

```bash
git clone https://github.com/yomorun/yomo-wasmedge-tensorflow.git
```

## The image classification function

The [image classification function](https://github.com/yomorun/yomo-wasmedge-tensorflow/tree/main/flow/rust_mobilenet_food) to process the YoMo image stream is written in Rust. It utilizes the WasmEdge Tensorflow API to process an input image.

```rust
#[wasmedge_bindgen]
pub fn infer(image_data: Vec<u8>) -> Result<Vec<u8>, String> {
  let start = Instant::now();

  // Load the TFLite model and its metadata (the text label for each recognized object number)
  let model_data: &[u8] = include_bytes!(""lite-model_aiy_vision_classifier_food_V1_1.tflite"");
  let labels = include_str!(""aiy_food_V1_labelmap.txt"");

  // Pre-process the image to a format that this model can use
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&image_data[..], 192, 192);
  println!(""RUST: Loaded image in ... {:?}"", start.elapsed());

  // Run the TFLite model using the WasmEdge Tensorflow API
  let mut session = wasmedge_tensorflow_interface::Session::new(&model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(""input"", &flat_img, &[1, 192, 192, 3])
         .run();
  let res_vec: Vec<u8> = session.get_output(""MobilenetV1/Predictions/Softmax"");

  // Find the object index in res_vec that has the greatest probability
  // Translate the probability into a confidence level
  // Translate the object index into a label from the model metadata food_name
  let mut i = 0;
  let mut max_index: i32 = -1;
  let mut max_value: u8 = 0;
  while i < res_vec.len() {
    let cur = res_vec[i];
    if cur > max_value {
      max_value = cur;
      max_index = i as i32;
    }
    i += 1;
  }
  println!(""RUST: index {}, prob {}"", max_index, max_value);

  let confidence: String;
  if max_value > 200 {
    confidence = ""is very likely"".to_string();
  } else if max_value > 125 {
    confidence = ""is likely"".to_string();
  } else {
    confidence = ""could be"".to_string();
  }

  let ret_str: String;
  if max_value > 50 {
    let mut label_lines = labels.lines();
    for _i in 0..max_index {
      label_lines.next();
    }
    let food_name = label_lines.next().unwrap().to_string();
    ret_str = format!(
      ""It {} a <a href='https://www.google.com/search?q={}'>{}</a> in the picture"",
      confidence, food_name, food_name
    );
  } else {
    ret_str = ""It does not appears to be a food item in the picture."".to_string();
  }

  println!(
    ""RUST: Finished post-processing in ... {:?}"",
    start.elapsed()
  );
  return Ok(ret_str.as_bytes().to_vec());
}
```

You should add `wasm32-wasi` target to rust to compile this function into WebAssembly bytecode.

```bash
rustup target add wasm32-wasi

cd flow/rust_mobilenet_food
cargo build --target wasm32-wasi --release
# The output WASM will be target/wasm32-wasi/release/rust_mobilenet_food_lib.wasm

# Copy the wasm bytecode file to the flow/ directory
cp target/wasm32-wasi/release/rust_mobilenet_food_lib.wasm ../
```

To release the best performance of WasmEdge, you should enable the AOT mode by compiling the `.wasm` file to the `.so`.

```bash
wasmedge compile rust_mobilenet_food_lib.wasm rust_mobilenet_food_lib.so
```

## Integration with YoMo

On the YoMo side, we use the WasmEdge Golang API to start and run WasmEdge VM for the image classification function. The [app.go](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go) file in the source code project is as follows.

```go
package main

import (
  ""crypto/sha1""
  ""fmt""
  ""log""
  ""os""
  ""sync/atomic""

  ""github.com/second-state/WasmEdge-go/wasmedge""
  bindgen ""github.com/second-state/wasmedge-bindgen/host/go""
  ""github.com/yomorun/yomo""
)

var (
  counter uint64
)

const ImageDataKey = 0x10

func main() {
  // Connect to Zipper service
  sfn := yomo.NewStreamFunction(""image-recognition"", yomo.WithZipperAddr(""localhost:9900""))
  defer sfn.Close()

  // set only monitoring data
  sfn.SetObserveDataID(ImageDataKey)

  // set handler
  sfn.SetHandler(Handler)

  // start
  err := sfn.Connect()
  if err != nil {
    log.Print(""❌ Connect to zipper failure: "", err)
    os.Exit(1)
  }

  select {}
}

// Handler processes the data in the stream
func Handler(img []byte) (byte, []byte) {
  // Initialize WasmEdge's VM
  vmConf, vm := initVM()
  bg := bindgen.Instantiate(vm)
  defer bg.Release()
  defer vm.Release()
  defer vmConf.Release()

  // recognize the image
  res, err := bg.Execute(""infer"", img)
  if err == nil {
    fmt.Println(""GO: Run bindgen -- infer:"", string(res))
  } else {
    fmt.Println(""GO: Run bindgen -- infer FAILED"")
  }

  // print logs
  hash := genSha1(img)
  log.Printf(""✅ received image-%d hash %v, img_size=%d \n"", atomic.AddUint64(&counter, 1), hash, len(img))

  return 0x11, nil
}

// genSha1 generate the hash value of the image
func genSha1(buf []byte) string {
  h := sha1.New()
  h.Write(buf)
  return fmt.Sprintf(""%x"", h.Sum(nil))
}

// initVM initialize WasmEdge's VM
func initVM() (*wasmedge.Configure, *wasmedge.VM) {
  wasmedge.SetLogErrorLevel()
  // Set Tensorflow not to print debug info
  os.Setenv(""TF_CPP_MIN_LOG_LEVEL"", ""3"")
  os.Setenv(""TF_CPP_MIN_VLOG_LEVEL"", ""3"")

  // Create configure
  vmConf := wasmedge.NewConfigure(wasmedge.WASI)

  // Create VM with configure
  vm := wasmedge.NewVMWithConfig(vmConf)

  // Init WASI
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{"".:.""}, // The mapping directories
  )

  // Register WasmEdge-tensorflow and WasmEdge-image
  var tfobj = wasmedge.NewTensorflowImportObject()
  var tfliteobj = wasmedge.NewTensorflowLiteImportObject()
  vm.RegisterImport(tfobj)
  vm.RegisterImport(tfliteobj)
  var imgobj = wasmedge.NewImageImportObject()
  vm.RegisterImport(imgobj)

  // Instantiate wasm
  vm.LoadWasmFile(""rust_mobilenet_food_lib.so"")
  vm.Validate()

  return vmConf, vm
}
```

## In action

Finally, we can start YoMo and see the entire data processing pipeline. Start the YoMo CLI application from the project folder. The [yaml file](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/zipper/workflow.yaml) defines port YoMo should listen on and the workflow handler to trigger for incoming data. Note that the flow name `image-recognition` matches the name in the aforementioned data handler [app.go](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go).

```bash
yomo serve -c ./zipper/workflow.yaml
```

Start the handler function by running the aforementioned [app.go](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go) program.

```bash
cd flow
go run --tags ""tensorflow image"" app.go
```

[Start a simulated data source](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/source/main.go) by sending a video to YoMo. The video is a series of image frames. The WasmEdge function in [app.go](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go) will be invoked against every image frame in the video.

```bash
# Download a video file
wget -P source 'https://github.com/yomorun/yomo-wasmedge-tensorflow/releases/download/v0.1.0/hot-dog.mp4'

# Stream the video to YoMo
go run ./source/main.go ./source/hot-dog.mp4
```

You can see the output from the WasmEdge handler function in the console. It prints the names of the objects detected in each image frame in the video.

## What's next

This article shows how to use the WasmEdge Tensorflow API and Golang SDK in YoMo framework to process an image stream in near real-time.

In collaboration with YoMo, we will soon deploy WasmEdge in production in smart factories for various assembly line tasks. WasmEdge is the software runtime for edge computing!
","**Summary**

The provided code is a documentation for YoMo, a distributed cloud system framework. It explains how to use WasmEdge, a WebAssembly runtime, as a software container in the edge computing node of the framework. The code guides users through creating and running a Rust function for image classification using TensorFlow and compiling it into WebAssembly bytecode.

**Key Components**

1. **WasmEdge**: A leading WebAssembly runtime hosted by the CNCF.
2. **YoMo**: A distributed cloud system framework that utilizes WasmEdge as its software container.
3. **TensorFlow**: An open-source machine learning library used for image classification in this example.
4. **Rust**: The programming language used to write the image classification function.

**Functionality**

1. **Image Classification**: The code shows how to create a Rust function that uses TensorFlow to classify images and compiles it into WebAssembly bytecode using WasmEdge.
2. **WASM Integration**: The example demonstrates how to use WasmEdge as a software container in YoMo's edge computing node.
3. **Data Processing Pipeline**: The code sets up a data processing pipeline that takes video frames as input, processes them with the image classification function, and outputs the detected objects.

**Potential Issues/Improvements**

1. **Performance Optimization**: The code could benefit from further performance optimizations to improve execution speed in real-time edge computing scenarios.
2. **Error Handling**: Adding more comprehensive error handling mechanisms would make the code more robust and resilient.
3. **Code Organization**: The documentation is extensive, but some sections may benefit from reorganization for better readability.

**Context**

The provided code is a part of the YoMo framework documentation, which focuses on showcasing the use of WasmEdge as a software container in edge computing scenarios. It is written for developers interested in exploring WebAssembly and its applications in distributed cloud systems."
docs/develop/rust/wasinn/llm_inference.md,"---
sidebar_position: 1
---

# LLM inference

WasmEdge now supports running open-source Large Language Models (LLMs) in Rust. We will use [this example project](https://github.com/second-state/LlamaEdge/tree/main/chat) to show how to make AI inferences with the llama-3.1-8B model in WasmEdge and Rust.

Furthermore, WasmEdge can support any open-source LLMs. Please check [the supported models](https://github.com/second-state/LlamaEdge/blob/main/models.md) for details.

## Prerequisite

Besides the [regular WasmEdge and Rust requirements](../../rust/setup.md), please make sure that you have the [Wasi-NN plugin with ggml installed](../../../start/install.md#wasi-nn-plug-in-with-ggml-backend).

## Quick start

Because the example already includes a compiled WASM file from the Rust code, we could use WasmEdge CLI to execute the example directly.

First, get the latest llama-chat wasm application

```bash
curl -LO https://github.com/LlamaEdge/LlamaEdge/releases/latest/download/llama-chat.wasm
```

Next, let's get the model. In this example, we are going to use the llama-3.1-8B model in GGUF format. You can also use other kinds of LLMs, check out [here](https://github.com/second-state/llamaedge/blob/main/chat/README.md#get-model).

```bash
curl -LO https://huggingface.co/second-state/Meta-Llama-3.1-8B-Instruct-GGUF/resolve/main/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf
```

Run the inference application in WasmEdge.

```bash
wasmedge --dir .:. --nn-preload default:GGML:AUTO:Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf llama-chat.wasm -p llama-3-chat
```

After executing the command, you may need to wait a moment for the input prompt to appear. You can enter your question once you see the `[USER]:` prompt:

```bash
[USER]:
I have two apples, each costing 5 dollars. What is the total cost of these apples?
[ASSISTANT]:
The total cost of the two apples is 10 dollars.
[USER]:
How about four apples?
[ASSISTANT]:
The total cost of four apples is 20 dollars.
```

## Build and run

Let's build the wasm file from the rust source code. First, git clone the `llamaedge` repo.

```bash
git clone https://github.com/LlamaEdge/LlamaEdge.git
cd chat
```

Second, use `cargo` to build the example project.

```bash
cargo build --target wasm32-wasi --release
```

The output WASM file is `target/wasm32-wasi/release/llama-chat.wasm`. Next, use WasmEdge to load the llama-3.1-8b model and then ask the model questions.

```bash
wasmedge --dir .:. --nn-preload default:GGML:AUTO:Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf llama-chat.wasm -p llama-3-chat
```

After executing the command, you may need to wait a moment for the input prompt to appear. You can enter your question once you see the `[You]:` prompt:

```bash
[You]:
Which one is greater? 9.11 or 9.8?

[Bot]:
9.11 is greater.

[You]:
why

[Bot]:
11 is greater than 8.
```

## Options

You can configure the chat inference application through CLI options.

```bash
  -m, --model-alias <ALIAS>
          Model alias [default: default]
  -c, --ctx-size <CTX_SIZE>
          Size of the prompt context [default: 512]
  -n, --n-predict <N_PRDICT>
          Number of tokens to predict [default: 1024]
  -g, --n-gpu-layers <N_GPU_LAYERS>
          Number of layers to run on the GPU [default: 100]
  -b, --batch-size <BATCH_SIZE>
          Batch size for prompt processing [default: 512]
  -r, --reverse-prompt <REVERSE_PROMPT>
          Halt generation at PROMPT, return control.
  -s, --system-prompt <SYSTEM_PROMPT>
          System prompt message string [default: ""[Default system message for the prompt template]""]
  -p, --prompt-template <TEMPLATE>
          Prompt template. [default: llama-2-chat] [possible values: llama-2-chat, codellama-instruct, mistral-instruct-v0.1, mistrallite, openchat, belle-llama-2-chat, vicuna-chat, chatml]
      --log-prompts
          Print prompt strings to stdout
      --log-stat
          Print statistics to stdout
      --log-all
          Print all log information to stdout
      --stream-stdout
          Print the output to stdout in the streaming way
  -h, --help
          Print help
```

The `--prompt-template` option is perhaps the most interesting. It allows the application to support different open source LLM models beyond llama2. Check out more prompt templates [here](https://github.com/LlamaEdge/LlamaEdge/tree/main/api-server/chat-prompts).

The `--ctx-size` option specifies the context windows size of the application. It is limited by the model's intrinsic context window size.

The `--log-stat` tells WasmEdge to print out logs and statistics of the model at runtime.

```bash
wasmedge --dir .:. --nn-preload default:GGML:AUTO:Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf \
  llama-chat.wasm --prompt-template llama-3-chat --log-stat
..................................................................................................
llama_new_context_with_model: n_ctx      = 512
llama_new_context_with_model: freq_base  = 10000.0
llama_new_context_with_model: freq_scale = 1
llama_new_context_with_model: kv self size  =  256.00 MB
llama_new_context_with_model: compute buffer total size = 76.63 MB
[2023-11-07 02:07:44.019] [info] [WASI-NN] GGML backend: llama_system_info: AVX = 0 | AVX2 = 0 | AVX512 = 0 | AVX512_VBMI = 0 | AVX512_VNNI = 0 | FMA = 0 | NEON = 1 | ARM_FMA = 1 | F16C = 0 | FP16_VA = 1 | WASM_SIMD = 0 | BLAS = 0 | SSE3 = 0 | SSSE3 = 0 | VSX = 0 | 

llama_print_timings:        load time =   11523.19 ms
llama_print_timings:      sample time =       2.62 ms /   102 runs   (    0.03 ms per token, 38961.04 tokens per second)
llama_print_timings: prompt eval time =   11479.27 ms /    49 tokens (  234.27 ms per token,     4.27 tokens per second)
llama_print_timings:        eval time =   13571.37 ms /   101 runs   (  134.37 ms per token,     7.44 tokens per second)
llama_print_timings:       total time =   25104.57 ms
[ASSISTANT]:
Ah, a fellow Peanuts enthusiast! Snoopy is Charlie Brown's lovable and imaginative beagle, known for his wild and wacky adventures in the comic strip and television specials. He's a loyal companion to Charlie Brown and the rest of the Peanuts gang, and his antics often provide comic relief in the series. Is there anything else you'd like to know about Snoopy? 🐶
```

## Improving performance

You can make the inference program run faster by AOT compiling the wasm file first.

```bash
wasmedge compile llama-chat.wasm llama-chat.wasm
wasmedge --dir .:.  --nn-preload default:GGML:AUTO:Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf llama-chat.wasm -p llama-3-chat
```

## Understand the code

The [main.rs](https://github.com/second-state/llamaedge/blob/main/chat/src/main.rs) is the full Rust code to create an interactive chatbot using a LLM. The Rust program manages the user input, tracks the conversation history, transforms the text into the model’s chat templates, and runs the inference operations using the WASI NN standard API. The code logic for the chat interaction is somewhat complex. In this section, we will use the [simple example](https://github.com/second-state/llamaedge/tree/main/simple) to explain how to set up and perform one inference round trip. Here is how you use the simple example.

```bash
# Download the compiled simple inference wasm
curl -LO https://github.com/second-state/llamaedge/releases/latest/download/llama-simple.wasm

# Give it a prompt and ask it to use the model to complete it.
wasmedge --dir .:. --nn-preload default:GGML:AUTO:Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf llama-simple.wasm \
  --prompt 'Robert Oppenheimer most important achievement is ' --ctx-size 512

output: in 1942, when he led the team that developed the first atomic bomb, which was dropped on Hiroshima, Japan in 1945.
```

First, let's parse command line arguments to customize the chatbot's behavior using `Command` struct. It extracts the following parameters: `prompt` (a prompt that guides the conversation), `model_alias` (a list for the loaded model), and `ctx_size` (the size of the chat context).

```rust
fn main() -> Result<(), String> {
    let matches = Command::new(""Simple LLM inference"")
        .arg(
            Arg::new(""prompt"")
                .short('p')
                .long(""prompt"")
                .value_name(""PROMPT"")
                .help(""Sets the prompt."")
                .required(true),
        )
        .arg(
            Arg::new(""model_alias"")
                .short('m')
                .long(""model-alias"")
                .value_name(""ALIAS"")
                .help(""Sets the model alias"")
                .default_value(""default""),
        )
        .arg(
            Arg::new(""ctx_size"")
                .short('c')
                .long(""ctx-size"")
                .value_parser(clap::value_parser!(u32))
                .value_name(""CTX_SIZE"")
                .help(""Sets the prompt context size"")
                .default_value(DEFAULT_CTX_SIZE),
        )
        .get_matches();

    // model alias
    let model_name = matches
        .get_one::<String>(""model_alias"")
        .unwrap()
        .to_string();

    // prompt context size
    let ctx_size = matches.get_one::<u32>(""ctx_size"").unwrap();
    CTX_SIZE
        .set(*ctx_size as usize)
        .expect(""Fail to parse prompt context size"");

    // prompt
    let prompt = matches.get_one::<String>(""prompt"").unwrap().to_string();
```

After that, the program will create a new Graph using the `GraphBuilder` and loads the model specified by the `model_name` .

```rust
// load the model to wasi-nn
     let graph =
        wasi_nn::GraphBuilder::new(wasi_nn::GraphEncoding::Ggml, wasi_nn::ExecutionTarget::AUTO)
            .build_from_cache(&model_name)
            .expect(""Failed to load the model"");
```

Next, We create an execution context from the loaded Graph. The context is mutable because we will be changing it when we set the input tensor and execute the inference.

```rust
 // initialize the execution context
    let mut context = graph
        .init_execution_context()
        .expect(""Failed to init context"");
```

Next, The prompt is converted into bytes and set as the input tensor for the model inference.

```rust
 // set input tensor
    let tensor_data = prompt.as_str().as_bytes().to_vec();
    context
        .set_input(0, wasi_nn::TensorType::U8, &[1], &tensor_data)
        .expect(""Failed to set prompt as the input tensor"");
```

Next, execute the model inference.

```rust
  // execute the inference
    context.compute().expect(""Failed to complete inference"");
```

After the inference is finished, extract the result from the computation context and losing invalid UTF8 sequences handled by converting the output to a string using `String::from_utf8_lossy`.

```rust
  let mut output_buffer = vec![0u8; *CTX_SIZE.get().unwrap()];
    let mut output_size = context
        .get_output(0, &mut output_buffer)
        .expect(""Failed to get output tensor"");
    output_size = std::cmp::min(*CTX_SIZE.get().unwrap(), output_size);
    let output = String::from_utf8_lossy(&output_buffer[..output_size]).to_string();
```

Finally, print the prompt and the inference output to the console.

```rust
println!(""\nprompt: {}"", &prompt);
println!(""\noutput: {}"", output);
```

## Resources

* If you're looking for multi-turn conversations with llama models, please check out the above mentioned chat example source code [here](https://github.com/second-state/llamaedge/tree/main/chat).
* If you want to construct OpenAI-compatible APIs specifically for your llama2 model, or the Llama2 model itself, please check out the source code [for the API server](https://github.com/second-state/llamaedge/tree/main/api-server).
* To learn more, please check out [this article](https://medium.com/stackademic/fast-and-portable-llama2-inference-on-the-heterogeneous-edge-a62508e82359).
","**Summary**

The provided code is a Rust implementation of an interactive chatbot using a Large Language Model (LLM) with the WASI-NN plugin and GGML backend. The chatbot can run inference operations on various models, including Llama2, Meta-Llama3.1-8B, and others. It uses command-line arguments to customize behavior and can be compiled for AOT execution.

**Key Components**

1. `Command` struct: parses command-line arguments to set the prompt, model alias, and context size.
2. `GraphBuilder`: loads the model specified by the `model_name`.
3. `wasi_nn::Graph`: executes the inference operation on the loaded Graph.
4. `String::from_utf8_lossy`: converts the output tensor to a string.

**Potential Issues or Areas for Improvement**

1. Error handling: the code does not handle errors well, and some functions return `Result` values that are not properly handled.
2. Code organization: the code is quite long and complex; refactoring and organizing it into smaller modules might improve readability and maintainability.
3. Model support: adding support for more models would require modifying the `GraphBuilder` and `wasi_nn::Graph` implementations.
4. Performance optimization: exploring performance optimizations, such as using a faster execution target or optimizing tensor operations, could further improve inference speed.

**Resources**

* Chat example source code: https://github.com/second-state/llamaedge/tree/main/chat
* API server source code: https://github.com/second-state/llamaedge/tree/main/api-server
* Article on fast and portable Llama2 inference: https://medium.com/stackademic/fast-and-portable-llama2-inference-on-the-heterogeneous-edge-a62508e82359"
docs/contribute/contribute.md,"---
sidebar_position: 8
---

# Contributing Guide


* [New Contributor Guide](#contributing-guide)
  * [Ways to Contribute](#ways-to-contribute)
  * [Find an Issue](#find-an-issue)
  * [Ask for Help](#ask-for-help)
  * [Pull Request Lifecycle](#pull-request-lifecycle)
  * [Development Environment Setup](#development-environment-setup)
  * [Sign Your Commits](#sign-your-commits)
  * [Pull Request Checklist](#pull-request-checklist)

Welcome! We are glad that you want to contribute to our project! 💖

As you get started, you are in the best position to give us feedback on areas of
the project that we need help with includes:

* Problems found during setting up a new developer environment
* Gaps in our Quickstart Guide or documentation
* Bugs in our automation scripts

If anything doesn't make sense, or doesn't work when you run it, please open a
bug report and let us know!

## Ways to Contribute

We welcome many different types of contributions including:

* New features
* Report a bug
* Builds, CI/CD
* Bug fixes
* Documentation
* Issue Triage
* Answering questions on Slack/Mailing List/GitHub issues
* Web design
* Communications / Social Media / Blog Posts
* Release management

Not everything happens through a GitHub pull request. Please come to our
[meetings](https://docs.google.com/document/d/1iFlVl7R97Lze4RDykzElJGDjjWYDlkI8Rhf8g4dQ5Rk/edit?usp=sharing) or [contact us](https://groups.google.com/g/wasmedge) and let's discuss how we can work
together. 

### Come to Meetings


Absolutely everyone is welcome to come to any of our meetings. You never need an
invite to join us. In fact, we want you to join us, even if you don’t have
anything you feel like you want to contribute. Just being there is enough!

You can find out more about our meetings [here](https://docs.google.com/document/d/1iFlVl7R97Lze4RDykzElJGDjjWYDlkI8Rhf8g4dQ5Rk/edit?usp=sharing). You don’t have to turn on
your video. The first time you come, introducing yourself is more than enough.
Over time, we hope that you feel comfortable voicing your opinions, giving
feedback on others’ ideas, and even sharing your own ideas, and experiences.

## Find an Issue

We have good first issues for new contributors and help wanted issues suitable
for any contributor. [good first issue](https://github.com/WasmEdge/WasmEdge/labels/good%20first%20issue) has extra information to
help you make your first contribution. [help wanted](https://github.com/WasmEdge/WasmEdge/labels/help%20wanted) are issues
suitable for someone who isn't a core maintainer and is good to move onto after
your first pull request.

Sometimes there won’t be any issues with these labels. That’s ok! There is
likely still something for you to work on. If you want to contribute but 
don’t know where to start or can't find a suitable issue, you can leave a comment under this issue like ""I'd like to work on this. Can you tell XYZ (list the stuff you want to communicate)"" or send your questions to our discord server or slack channel.

Once you see an issue that you'd like to work on, please post a comment saying
that you want to work on it. Something like ""I want to work on this"" is fine.

## Ask for Help

The best way to reach us with a question when contributing is to ask on:

* The original github issue
* Mailing list: Send an email to [our email list](https://groups.google.com/g/wasmedge)
* Discord: Join the [WasmEdge Discord server](https://discord.gg/h4KDyB8XTt)
* Slack: Join the #WasmEdge channel on the [CNCF Slack](https://slack.cncf.io/)

Before opening any issue, please look up the existing [issues](https://github.com/WasmEdge/WasmEdge/issues) to avoid submitting a duplication. If you find a match, you can ""subscribe"" to it to get notified of updates. If you have additional helpful information about the issue, please leave a comment.

When reporting issues, always include:

- Version of your system
- Configuration files of WasmEdge

Because the issues are open to the public, when submitting the log and configuration files, be sure to remove any sensitive information, e.g. user name, password, IP address, and company name. You can replace those parts with ""REDACTED"" or other strings like ""\*\*\*\*"". Be sure to include the steps to reproduce the problem if applicable. It can help us understand and fix your issue faster.


## Pull Request Lifecycle

Pull requests are always welcome, even if they only contain minor fixes like typos or a few lines of code. If there will be a significant effort, please document it as an issue and get a discussion going before starting to work on it.

Please submit a pull request broken down into small changes bit by bit. A pull request consisting of many features and code changes may take a lot of work to review. It is recommended to submit pull requests incrementally.

Generally, once your pull request has been opened, it will be assigned to one or more reviewers. Those reviewers will do a thorough code review, looking for correctness, bugs, opportunities for improvement, documentation and comments, and coding style. If your PR is not ready to review, please mark your PR as a draft.

The reviewers will give you some feedback in three work days. 

After the first review is done, the PR contributor is expected to review and make some changes based on the review in 5 workdays. 

If you have finished the adjustments, mark the problem as solved, then the reviewers will review your PR again in 2 workdays.

If the PR contributor doesn't respond to the PR in 30 days, the maintainer will close the PR. The original PR contributor is welcome to open it again. 

If the PR contributor doesn't want to maintain the PR due to some reason, please enable maintainers to edit this PR if you still want this PR to be merged.

When your PR is merged, your contribution will be implemented in the next release. And we will add the contributors' GitHub name in the release note.

## Development Environment Setup

The WasmEdge is developed on Ubuntu 20.04 to take advantage of advanced LLVM features for the AOT compiler. The WasmEdge team also builds and releases statically linked WasmEdge binaries for older Linux distributions.

Our development environment requires `libLLVM-12` and `>=GLIBCXX_3.4.26`.

If you use an operating system older than Ubuntu 20.04, please use our [special docker image] to build WasmEdge. If you are looking for the pre-built binaries for the older operating system, we also provide several pre-built binaries based on the `manylinux2014` distribution.

To build WasmEdge from the source, please refer to: [Build WasmEdge from source](/category/build-wasmedge-from-source).

## Sign Your Commits

### DCO
Licensing is important to open source projects. It provides some assurances that
the software will continue to be available based under the terms that the
author(s) desired. We require that contributors sign off on commits submitted to
our project's repositories. The [Developer Certificate of Origin
(DCO)](https://probot.github.io/apps/dco/) is a way to certify that you wrote and
have the right to contribute the code you are submitting to the project.

You sign-off by adding the following to your commit messages. Your sign-off must
match the git user and email associated with the commit.

    This is my commit message

    Signed-off-by: Your Name <your.name@example.com>

Git has a `-s` command line option to do this automatically:

    git commit -s -m 'This is my commit message'

If you forgot to do this and have not yet pushed your changes to the remote
repository, you can amend your commit with the sign-off by running 

    git commit --amend -s 


## Pull Request Checklist

When you submit your pull request, or you push new commits to it, our automated
systems will run some checks on your new code. We require that your pull request
passes these checks, but we also have more criteria than just that before we can
accept and merge it. We recommend that you check the following things locally
before you submit your code:

* DCO: Did you sign off your commit
* Code of conduct: Did you follow the CNCF code of conduct


## Reporting issues


## Documenting

Update the documentation if you are creating or changing features. Good documentation is as necessary as the code itself. Documents are written with Markdown. See [Writing on GitHub](https://help.github.com/categories/writing-on-github/) for more details.

## Design new features

You can propose new designs for existing WasmEdge features. You can also design new features; please submit a proposal via the GitHub issues.

WasmEdge maintainers will review this proposal as soon as possible to ensure the overall architecture is consistent and to avoid duplicated work in the roadmap.

New features of WasmEdge will be discussed via a GitHub issue or the community meeting.
","**Summary:**

The provided code is a contributing guide for the WasmEdge project, which outlines the steps and best practices for contributors to follow when submitting changes, reporting issues, or proposing new features. The guide covers various topics such as:

1. Ways to contribute (e.g., new features, bug fixes, documentation)
2. Finding and working on issues
3. Asking for help and getting feedback from maintainers
4. Pull request lifecycle and requirements
5. Development environment setup
6. Sign-off commitments (DCO) and code of conduct
7. Reporting issues and documenting changes

**Key Components:**

1. **Contributing Guide**: An introduction to the contributing process, including ways to contribute and steps for new contributors.
2. **Ways to Contribute**: A list of ways contributors can participate in the project, including submitting new features, bug fixes, documentation, etc.
3. **Pull Request Lifecycle**: The stages a pull request goes through, from submission to review, testing, and merging.
4. **Development Environment Setup**: Information on how to set up and use the development environment, including build dependencies and special requirements (e.g., Linux distributions).
5. **Sign-Off Commitments (DCO)**: A requirement for contributors to sign off on commits, ensuring they wrote and have the right to contribute the code.
6. **Reporting Issues**: Instructions on how to report issues, including providing relevant information (e.g., version of system, configuration files) and steps to reproduce the problem.

**Potential Issues/Areas for Improvement:**

1. **Lengthy Guide**: The contributing guide is extensive and may be overwhelming for new contributors. Consider breaking it down into smaller sections or creating a more concise summary.
2. **Outdated Information**: Some sections (e.g., development environment setup) might require updates to reflect changes in the project or dependencies.
3. **DCO Enforcement**: Ensure that all contributors understand and follow the DCO, and consider adding tools or checks to automate sign-off verification.
4. **Code of Conduct**: Review the code of conduct to ensure it aligns with community standards and is clearly communicated to new contributors.

**Recommendations:**

1. Review and update the contributing guide regularly to reflect project changes and best practices.
2. Create a more concise summary or FAQ section for new contributors.
3. Add tools or checks to automate sign-off verification and enforce DCO compliance.
4. Ensure that all sections of the guide are up-to-date and relevant to the current project state."
docs/contribute/plugin/develop_plugin_c.md,"---
sidebar_position: 2
---

# Develop WasmEdge Plug-in in C API

By developing a plug-in, one can extend the functionality of WasmEdge and customize it to suit specific needs. WasmEdge provides a C based API for registering extension modules and host functions. While the WasmEdge language SDKs allow registering host functions from a host (wrapping) application, the plug-in API allows such extensions to be incorporated into WasmEdge's building and releasing process. Here is a flowchart showing all the steps needed for developing WasmEdge Plug-in -

```mermaid
graph LR;
A[Developing WasmEdge Plug-in in C]
A --> B(Set up the development environment)
A --> C(Create a WasmEdge plug-in project)
A --> D(Write the plug-in code)
A --> E(Build the plug-in)
A --> F(Test and debug the plug-in)
B --> E
C --> D
D --> E
```

This flowchart illustrates developing a WasmEdge plug-in, showcasing the steps from choosing a programming language to finalizing and releasing the plug-in.

## Set up the development environment

To start developing WasmEdge plug-ins, it is essential to correctly set up the development environment. This section provides step-by-step instructions for WasmEdge plug-in development -

**Install a WasmEdge runtime**: You can download the latest version of WasmEdge from [GitHub repository](https://github.com/wasmEdge/wasmEdge). Follow the instructions in the [installation guide](../../start/install.md) for your specific operating system.

After installing WasmEdge, you need to set up the build environment. If you're using Linux or other platforms, you can follow the instructions in the [build environment setup guide](../source/os/linux.md).

## Create a WasmEdge plug-in project

To create a WasmEdge plug-in project, follow these steps:

- **Set up the project directory**: Create a directory structure for your plug-in project. You can use a standard structure for the chosen language or create your structure. To create a project directory structure, use the following commands:

  ```bash
  mkdir testplugin
  cd testplugin
  mkdir src include build
  ```

- **Add configuration files**: Add configuration files specifying the plug-in name, version, and dependencies. The specific files and content depend on the chosen programming language and build system.

- **Add any necessary libraries or dependencies**: Include any required libraries or dependencies for your plug-in. Modify the configuration files created in the previous step to include the required dependencies.

## Write the plug-in code

To create a plug-in with host functions and modules, follow these steps:

- **Implement host function definitions**: In this step, you must define the host functions that will be imported when instantiating the WASM module. These functions will perform specific operations and return results.

  Therefore, developers can first implement their plug-in host functions, like the [host functions in WasmEdge C API](/embed/c/reference/latest.md#host-functions).

<!-- prettier-ignore -->
:::note
For more details about the [external data](/embed/c/host_function.md#host-data) and [calling frame context](/embed/c/host_function.md#calling-frame-context), please refer to the host function guide.
:::

Here's an example of two host functions, `HostFuncAdd` and `HostFuncSub`, that add and subtract two `int32_t` numbers, respectively:

```c
#include <wasmedge/wasmedge.h>

/* The host function definitions. */

/* The host function to add 2 int32_t numbers. */
WasmEdge_Result HostFuncAdd(void *Data,
                            const WasmEdge_CallingFrameContext *CallFrameCxt,
                            const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

/* The host function to sub 2 int32_t numbers. */
WasmEdge_Result HostFuncSub(void *Data,
                            const WasmEdge_CallingFrameContext *CallFrameCxt,
                            const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  Out[0] = WasmEdge_ValueGenI32(Val1 - Val2);
  return WasmEdge_Result_Success;
}
```

- **Implement the module creation functions**: In this step, you need to implement the module creation function that creates an instance of the module. This function will be called when the plug-in is loaded.

  Here's an example of a module creation function named `CreateTestModule`:

  ```c
  /* The creation function of creating the module instance. */
  WasmEdge_ModuleInstanceContext *
  CreateTestModule(const struct WasmEdge_ModuleDescriptor *Desc) {
    /*
     * The `Desc` is the const pointer to the module descriptor struct:
     *
     *   typedef struct WasmEdge_ModuleDescriptor {
     *     const char *Name;
     *     const char *Description;
     *     WasmEdge_ModuleInstanceContext *(*Create)(
     *         const struct WasmEdge_ModuleDescriptor *);
     *   } WasmEdge_ModuleDescriptor;
     *
     * Developers can get the name and description from this descriptor.
     */

    /* Exported module name of this module instance. */
    WasmEdge_String ModuleName =
        WasmEdge_StringCreateByCString(""wasmedge_plugintest_c_module"");
    WasmEdge_ModuleInstanceContext *Mod =
        WasmEdge_ModuleInstanceCreate(ModuleName);
    WasmEdge_StringDelete(ModuleName);

    WasmEdge_String FuncName;
    WasmEdge_FunctionTypeContext *FType;
    WasmEdge_FunctionInstanceContext *FuncCxt;
    WasmEdge_ValType ParamTypes[2], ReturnTypes[1];
    ParamTypes[0] = WasmEdge_ValTypeGenI32();
    ParamTypes[1] = WasmEdge_ValTypeGenI32();
    ReturnTypes[0] = WasmEdge_ValTypeGenI32();

    /* Create and add the host function instances into the module instance. */
    FType = WasmEdge_FunctionTypeCreate(ParamTypes, 2, ReturnTypes, 1);
    FuncName = WasmEdge_StringCreateByCString(""add"");
    FuncCxt = WasmEdge_FunctionInstanceCreate(FType, HostFuncAdd, NULL, 0);
    WasmEdge_ModuleInstanceAddFunction(Mod, FuncName, FuncCxt);
    WasmEdge_StringDelete(FuncName);
    FuncName = WasmEdge_StringCreateByCString(""sub"");
    FuncCxt = WasmEdge_FunctionInstanceCreate(FType, HostFuncSub, NULL, 0);
    WasmEdge_ModuleInstanceAddFunction(Mod, FuncName, FuncCxt);
    WasmEdge_StringDelete(FuncName);
    WasmEdge_FunctionTypeDelete(FType);

    return Mod;
  }
  ```

  There can be several module instances in a plug-in shared library. Here in the above code snippet, take a module named `wasmedge_plugintest_c_module` for the example.

- **Supply the plug-in descriptions**- In this step, you need to provide the descriptions of the plug-in and the modules it contains. These descriptions will be used for searching and creating the plug-in and module instances.

  Here's an example of the plug-in and module descriptors:

  ```c
  /* The module descriptor array. There can be multiple modules in a plug-in. */
  static WasmEdge_ModuleDescriptor ModuleDesc[] = {{
      /*
       * Module name. This is the name for searching and creating the module
       * instance context by the `WasmEdge_PluginCreateModule()` API.
       */
      .Name = ""wasmedge_plugintest_c_module"",
      /* Module description. */
      .Description = ""This is for the plugin tests in WasmEdge C API."",
      /* Creation function pointer. */
      .Create = CreateTestModule,
  }};

  /* The plug-in descriptor */
  static WasmEdge_PluginDescriptor Desc[] = {{
      /*
       * Plug-in name. This is the name for searching the plug-in context by the
       * `WasmEdge_PluginFind()` API.
       */
      .Name = ""wasmedge_plugintest_c"",
      /* Plug-in description. */
      .Description = """",
      /* Plug-in API version. */
      .APIVersion = WasmEdge_Plugin_CurrentAPIVersion,
      /* Plug-in version. Developers can define the version of this plug-in. */
      .Version =
          {
              .Major = 0,
              .Minor = 1,
              .Patch = 0,
              .Build = 0,
          },
      /* Module count in this plug-in. */
      .ModuleCount = 1,
      /* Plug-in option description count in this plug-in (Work in progress). */
      .ProgramOptionCount = 0,
      /* Pointer to the module description array. */
      .ModuleDescriptions = ModuleDesc,
      /* Pointer to the plug-in option description array (Work in progress). */
      .ProgramOptions = NULL,
  }};
  ```

  These descriptions define the name, description, version, and creation function of the plug-in and the name and description of the module it contains.

Remember to implement any additional functions or structures your plug-in requires to fulfill its functionality.

Following these steps and implementing the necessary functions and descriptors, you can create a plug-in with host functions and modules in WasmEdge C API. You can continue developing your plug-in by adding functionality and implementing the desired behavior.

- **Plug-in option** - _WORK IN PROGRESS. This section is reserved for the feature in the future._

## Build your plug-in

To build the WasmEdge plug-in shared library, you have two options: build it directly using the compiler or CMake. Here are the instructions for both methods:

- **Build with Command**: if you choose to build the plug-in using the command line, run the following command in the terminal:

  ```bash
  gcc -std=c11 -DWASMEDGE_PLUGIN -shared -o libwasmedgePluginTest.so testplugin.c
  ```

  This command compiles the `testplugin.c` file into a shared library named `libwasmedgePluginTest.so`. The `-std=c11` flag sets the C language standard to C11, and the `-DWASMEDGE_PLUGIN` flag defines the WASMEDGE_PLUGIN macro, which can be used in your code.

- **Build with CMake**: If you prefer to use CMake to build the plug-in, create a `CMakeLists.txt` file in the root directory of your project and add the following content to the CMakeLists.txt file:

  ```cmake
  add_library(wasmedgePluginTest
    SHARED
    testplugin.c
  )

  set_target_properties(wasmedgePluginTest PROPERTIES
    C_STANDARD 11
  )

  target_compile_options(wasmedgePluginTest
    PUBLIC
    -DWASMEDGE_PLUGIN
  )

  target_link_libraries(wasmedgePluginTest
    PRIVATE
    wasmedge
  )
  ```

  This CMake configuration sets up a build target called `wasmedgePluginTest`. It compiles the `testplugin.c` file into a shared library. The `C_STANDARD 11` property sets the C language standard to C11. The `target_compile_options` command defines the `WASMEDGE_PLUGIN` macro using the `-DWASMEDGE_PLUGIN` flag. Finally, the `target_link_libraries` command links the wasmedge library to the plug-in.

Once you have set up either the command-line build or the CMake build, you can execute the corresponding build command or generate build files using CMake, which will compile your plug-in source code and produce the shared library file `(libwasmedgePluginTest.so)`.
","**Summary**

This code is part of the WasmEdge documentation, specifically a guide to developing plugins in C API. The guide provides step-by-step instructions on setting up the development environment, creating a plugin project, writing the plugin code, and building the plugin.

**Key Components**

1. **Setup**: Setting up the development environment by installing the WasmEdge runtime and configuring the build environment.
2. **Create Plugin Project**: Creating a new plugin project using a standard directory structure and adding configuration files.
3. **Write Plugin Code**: Implementing host function definitions, module creation functions, and supplying plug-in descriptions.
4. **Build Plugin**: Compiling the plugin source code into a shared library file.

**Code Quality**

The code is well-structured and follows good practices for documentation, commenting, and readability. However, some areas could benefit from further improvement:

1. **Error Handling**: The code does not handle errors explicitly in several places, which may lead to unexpected behavior or crashes.
2. **Commenting**: While the code has some comments, more comments are needed to explain complex sections of code and make it easier for others to understand.
3. **Code Organization**: Some functions and variables have long names that can be shortened to improve readability.

**Potential Issues**

1. **Memory Management**: The code uses raw pointers and manual memory management (e.g., `WasmEdge_StringCreateByCString`), which can lead to memory leaks or crashes if not handled properly.
2. **Dependency Management**: The code assumes a specific version of WasmEdge is installed, but it does not check for compatibility issues or handle version conflicts.
3. **Build System**: The build system used (e.g., CMake) may not be suitable for all environments or platforms.

**Recommendations**

1. **Implement Error Handling**: Add explicit error handling to ensure the code can recover from errors and provide meaningful feedback.
2. **Improve Commenting**: Add more comments to explain complex sections of code, especially in areas with unclear logic or assumptions.
3. **Refactor Code Organization**: Simplify long variable and function names to improve readability and maintainability."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_c.md,"---
sidebar_position: 2
---

# Develop WasmEdge Plug-in in C API

By developing a plug-in, one can extend the functionality of WasmEdge and customize it to suit specific needs. WasmEdge provides a C based API for registering extension modules and host functions. While the WasmEdge language SDKs allow registering host functions from a host (wrapping) application, the plug-in API allows such extensions to be incorporated into WasmEdge's building and releasing process. Here is a flowchart showing all the steps needed for developing WasmEdge Plug-in -

```mermaid
graph LR;
A[Developing WasmEdge Plug-in in C]
A --> B(Set up the development environment)
A --> C(Create a WasmEdge plug-in project)
A --> D(Write the plug-in code)
A --> E(Build the plug-in)
A --> F(Test and debug the plug-in)
B --> E
C --> D
D --> E
```

This flowchart illustrates developing a WasmEdge plug-in, showcasing the steps from choosing a programming language to finalizing and releasing the plug-in.

## Set up the development environment

To start developing WasmEdge plug-ins, it is essential to correctly set up the development environment. This section provides step-by-step instructions for WasmEdge plug-in development -

**Install a WasmEdge runtime**: You can download the latest version of WasmEdge from [GitHub repository](https://github.com/wasmEdge/wasmEdge). Follow the instructions in the [installation guide](../../start/install.md) for your specific operating system.

After installing WasmEdge, you need to set up the build environment. If you're using Linux or other platforms, you can follow the instructions in the [build environment setup guide](../source/os/linux.md).

## Create a WasmEdge plug-in project

To create a WasmEdge plug-in project, follow these steps:

- **Set up the project directory**: Create a directory structure for your plug-in project. You can use a standard structure for the chosen language or create your structure. To create a project directory structure, use the following commands:

  ```bash
  mkdir testplugin
  cd testplugin
  mkdir src include build
  ```

- **Add configuration files**: Add configuration files specifying the plug-in name, version, and dependencies. The specific files and content depend on the chosen programming language and build system.

- **Add any necessary libraries or dependencies**: Include any required libraries or dependencies for your plug-in. Modify the configuration files created in the previous step to include the required dependencies.

## Write the plug-in code

To create a plug-in with host functions and modules, follow these steps:

- **Implement host function definitions**: In this step, you must define the host functions that will be imported when instantiating the WASM module. These functions will perform specific operations and return results.

  Therefore, developers can first implement their plug-in host functions, like the [host functions in WasmEdge C API](/embed/c/reference/latest.md#host-functions).

<!-- prettier-ignore -->
:::note
For more details about the [external data](/embed/c/host_function.md#host-data) and [calling frame context](/embed/c/host_function.md#calling-frame-context), please refer to the host function guide.
:::

Here's an example of two host functions, `HostFuncAdd` and `HostFuncSub`, that add and subtract two `int32_t` numbers, respectively:

```c
#include <wasmedge/wasmedge.h>

/* The host function definitions. */

/* The host function to add 2 int32_t numbers. */
WasmEdge_Result HostFuncAdd(void *Data,
                            const WasmEdge_CallingFrameContext *CallFrameCxt,
                            const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

/* The host function to sub 2 int32_t numbers. */
WasmEdge_Result HostFuncSub(void *Data,
                            const WasmEdge_CallingFrameContext *CallFrameCxt,
                            const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  Out[0] = WasmEdge_ValueGenI32(Val1 - Val2);
  return WasmEdge_Result_Success;
}
```

- **Implement the module creation functions**: In this step, you need to implement the module creation function that creates an instance of the module. This function will be called when the plug-in is loaded.

  Here's an example of a module creation function named `CreateTestModule`:

  ```c
  /* The creation function of creating the module instance. */
  WasmEdge_ModuleInstanceContext *
  CreateTestModule(const struct WasmEdge_ModuleDescriptor *Desc) {
    /*
     * The `Desc` is the const pointer to the module descriptor struct:
     *
     *   typedef struct WasmEdge_ModuleDescriptor {
     *     const char *Name;
     *     const char *Description;
     *     WasmEdge_ModuleInstanceContext *(*Create)(
     *         const struct WasmEdge_ModuleDescriptor *);
     *   } WasmEdge_ModuleDescriptor;
     *
     * Developers can get the name and description from this descriptor.
     */

    /* Exported module name of this module instance. */
    WasmEdge_String ModuleName =
        WasmEdge_StringCreateByCString(""wasmedge_plugintest_c_module"");
    WasmEdge_ModuleInstanceContext *Mod =
        WasmEdge_ModuleInstanceCreate(ModuleName);
    WasmEdge_StringDelete(ModuleName);

    WasmEdge_String FuncName;
    WasmEdge_FunctionTypeContext *FType;
    WasmEdge_FunctionInstanceContext *FuncCxt;
    WasmEdge_ValType ParamTypes[2], ReturnTypes[1];
    ParamTypes[0] = WasmEdge_ValTypeGenI32();
    ParamTypes[1] = WasmEdge_ValTypeGenI32();
    ReturnTypes[0] = WasmEdge_ValTypeGenI32();

    /* Create and add the host function instances into the module instance. */
    FType = WasmEdge_FunctionTypeCreate(ParamTypes, 2, ReturnTypes, 1);
    FuncName = WasmEdge_StringCreateByCString(""add"");
    FuncCxt = WasmEdge_FunctionInstanceCreate(FType, HostFuncAdd, NULL, 0);
    WasmEdge_ModuleInstanceAddFunction(Mod, FuncName, FuncCxt);
    WasmEdge_StringDelete(FuncName);
    FuncName = WasmEdge_StringCreateByCString(""sub"");
    FuncCxt = WasmEdge_FunctionInstanceCreate(FType, HostFuncSub, NULL, 0);
    WasmEdge_ModuleInstanceAddFunction(Mod, FuncName, FuncCxt);
    WasmEdge_StringDelete(FuncName);
    WasmEdge_FunctionTypeDelete(FType);

    return Mod;
  }
  ```

  There can be several module instances in a plug-in shared library. Here in the above code snippet, take a module named `wasmedge_plugintest_c_module` for the example.

- **Supply the plug-in descriptions**- In this step, you need to provide the descriptions of the plug-in and the modules it contains. These descriptions will be used for searching and creating the plug-in and module instances.

  Here's an example of the plug-in and module descriptors:

  ```c
  /* The module descriptor array. There can be multiple modules in a plug-in. */
  static WasmEdge_ModuleDescriptor ModuleDesc[] = {{
      /*
       * Module name. This is the name for searching and creating the module
       * instance context by the `WasmEdge_PluginCreateModule()` API.
       */
      .Name = ""wasmedge_plugintest_c_module"",
      /* Module description. */
      .Description = ""This is for the plugin tests in WasmEdge C API."",
      /* Creation function pointer. */
      .Create = CreateTestModule,
  }};

  /* The plug-in descriptor */
  static WasmEdge_PluginDescriptor Desc[] = {{
      /*
       * Plug-in name. This is the name for searching the plug-in context by the
       * `WasmEdge_PluginFind()` API.
       */
      .Name = ""wasmedge_plugintest_c"",
      /* Plug-in description. */
      .Description = """",
      /* Plug-in API version. */
      .APIVersion = WasmEdge_Plugin_CurrentAPIVersion,
      /* Plug-in version. Developers can define the version of this plug-in. */
      .Version =
          {
              .Major = 0,
              .Minor = 1,
              .Patch = 0,
              .Build = 0,
          },
      /* Module count in this plug-in. */
      .ModuleCount = 1,
      /* Plug-in option description count in this plug-in (Work in progress). */
      .ProgramOptionCount = 0,
      /* Pointer to the module description array. */
      .ModuleDescriptions = ModuleDesc,
      /* Pointer to the plug-in option description array (Work in progress). */
      .ProgramOptions = NULL,
  }};
  ```

  These descriptions define the name, description, version, and creation function of the plug-in and the name and description of the module it contains.

Remember to implement any additional functions or structures your plug-in requires to fulfill its functionality.

Following these steps and implementing the necessary functions and descriptors, you can create a plug-in with host functions and modules in WasmEdge C API. You can continue developing your plug-in by adding functionality and implementing the desired behavior.

- **Plug-in option** - _WORK IN PROGRESS. This section is reserved for the feature in the future._

## Build your plug-in

To build the WasmEdge plug-in shared library, you have two options: build it directly using the compiler or CMake. Here are the instructions for both methods:

- **Build with Command**: if you choose to build the plug-in using the command line, run the following command in the terminal:

  ```bash
  gcc -std=c11 -DWASMEDGE_PLUGIN -shared -o libwasmedgePluginTest.so testplugin.c
  ```

  This command compiles the `testplugin.c` file into a shared library named `libwasmedgePluginTest.so`. The `-std=c11` flag sets the C language standard to C11, and the `-DWASMEDGE_PLUGIN` flag defines the WASMEDGE_PLUGIN macro, which can be used in your code.

- **Build with CMake**: If you prefer to use CMake to build the plug-in, create a `CMakeLists.txt` file in the root directory of your project and add the following content to the CMakeLists.txt file:

  ```cmake
  add_library(wasmedgePluginTest
    SHARED
    testplugin.c
  )

  set_target_properties(wasmedgePluginTest PROPERTIES
    C_STANDARD 11
  )

  target_compile_options(wasmedgePluginTest
    PUBLIC
    -DWASMEDGE_PLUGIN
  )

  target_link_libraries(wasmedgePluginTest
    PRIVATE
    wasmedge
  )
  ```

  This CMake configuration sets up a build target called `wasmedgePluginTest`. It compiles the `testplugin.c` file into a shared library. The `C_STANDARD 11` property sets the C language standard to C11. The `target_compile_options` command defines the `WASMEDGE_PLUGIN` macro using the `-DWASMEDGE_PLUGIN` flag. Finally, the `target_link_libraries` command links the wasmedge library to the plug-in.

Once you have set up either the command-line build or the CMake build, you can execute the corresponding build command or generate build files using CMake, which will compile your plug-in source code and produce the shared library file `(libwasmedgePluginTest.so)`.
","**Code Analysis Summary**

This code is a documentation for developing WasmEdge plug-ins in C API. The purpose of this guide is to help developers create and build custom extensions for the WasmEdge webassembly runtime using C.

The code provides step-by-step instructions on setting up the development environment, creating a plug-in project, writing plug-in code, building the plug-in, and testing it.

**Key Components:**

1. **WasmEdge Plug-in**: A custom extension created by developers to extend the functionality of WasmEdge.
2. **C API**: The C programming language interface for developing WasmEdge plugins.
3. **Plug-in Project**: A directory structure for organizing plug-in source code, configuration files, and build scripts.
4. **Module Descriptor**: A data structure describing a single module within the plug-in, including its name, description, creation function, and API version.
5. **Plug-in Descriptor**: A data structure describing the plug-in itself, including its name, description, API version, and version information.

**Potential Issues or Areas for Improvement:**

1. The code assumes that the reader is familiar with C programming language and WasmEdge concepts, which might not be the case for beginners.
2. Some parts of the guide, such as the creation of module descriptors and plug-in options, are marked as ""work in progress,"" suggesting that they may still require updates or clarifications.

**Recommendations:**

1. Create a more comprehensive introduction to WasmEdge and C API basics for developers who are new to these technologies.
2. Provide additional examples and code snippets to illustrate the concepts presented in the guide.
3. Update the ""work in progress"" sections with new information and best practices as they become available.

By addressing these recommendations, the documentation can be even more effective in helping developers create high-quality WasmEdge plug-ins in C API."
docs/develop/rust/ssr.md,"---
sidebar_position: 12
---

# Server-side rendering

Frontend web frameworks allow developers to create web apps in a high-level language and component model. The web app is built into a static website to be rendered in the browser. While many frontend web frameworks are based on JavaScript, such as React and Vue, Rust-based frameworks are also emerging as the Rust language gains traction among developers. Those web frameworks render the HTML DOM UI using the WebAssembly, compiled from Rust source code. They use [wasm-bindgen](https://github.com/rustwasm/wasm-bindgen) to tie the Rust to the HTML DOM. While these frameworks send `.wasm` files to the browser to render the UI on the client side, some provide the additional choice for [Server-side rendering](https://en.wikipedia.org/wiki/Server-side_scripting). That is to run the WebAssembly code, build the HTML DOM UI on the server, and stream the HTML content to the browser for faster performance and startup time on slow devices and networks.

<!-- prettier-ignore -->
:::note
If you are interested in JavaScript-based Jamstack and SSR frameworks, such as React, please [check out our JavaScript SSR chapter](../javascript/ssr.md).
:::

This article will explore how to render the web UI on the server using WasmEdge. We pick [Percy](https://github.com/chinedufn/percy) as our framework because it is relatively mature in SSR and [Hydration](<https://en.wikipedia.org/wiki/Hydration_(web_development)>). Percy already provides an [example](https://github.com/chinedufn/percy/tree/master/examples/isomorphic) for SSR. It's highly recommended to read it first to understand how it works. The default SSR setup with Percy utilizes a native Rust web server. The Rust code is compiled to machine native code for the server. However, we need a sandbox to host user applications on the server. While we could run native code inside a Linux container (Docker), a far more efficient (and safer) approach is to run the compiled code in a WebAssembly VM on the server, especially considering the rendering code is already compiled into WebAssembly.

Let's go through the steps to run a Percy SSR service in a WasmEdge server.

Assuming we are in the `examples/isomorphic` directory, make a new crate beside the existing `server`.

```bash
cargo new server-wasmedge
```

You'll receive a warning to let you put the new crate into the workspace, so insert below into `members` of `[workspace]`. The file is `../../Cargo.toml`.

```toml
""examples/isomorphic/server-wasmedge""
```

With the file open, put these two lines in the bottom:

```toml
[patch.crates-io]
wasm-bindgen = { git = ""https://github.com/KernelErr/wasm-bindgen.git"", branch = ""wasi-compat"" }
```

<!-- prettier-ignore -->
:::note
Why do we need a forked `wasm-bindgen`? That is because `wasm-bindgen` is the required glue between Rust and HTML in the browser. On the server, however, we need to build the Rust code to the `wasm32-wasi` target, which is incompatible with `wasm-bindgen`. Our forked `wasm-bindgen` has conditional configs that remove browser-specific code in the generated `.wasm` file for the `wasm32-wasi` target.
:::

Then replace the crate's `Cargo.toml` with the following content.

```toml
[package]
name = ""isomorphic-server-wasmedge""
version = ""0.1.0""
edition = ""2021""

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
wasmedge_wasi_socket = ""0""
querystring = ""1.1.0""
parsed = { version = ""0.3"", features = [""http""] }
anyhow = ""1""
serde = { version = ""1.0"", features = [""derive""] }
isomorphic-app = { path = ""../app"" }
```

The `wasmedge_wasi_socket` crate is the socket API of WasmEdge. This project is under development. Next, copy the `index.html` file into the crate's root.

```bash
cp server/src/index.html server-wasmedge/src/
```

Then let's create some Rust code to start a web service in WasmEdge! The `main.rs` program listens to the request and sends the response via the stream.

```rust
use std::io::Write;
use wasmedge_wasi_socket::{Shutdown, TcpListener};

mod handler;
mod mime;
mod response;

fn main() {
    let server = TcpListener::bind(""127.0.0.1:3000"", false).unwrap();
    println!(""Server listening on 127.0.0.1:3000"");

    // Simple single-thread HTTP server
    // For server with Pool support, see https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/poll_http_server
    loop {
        let (mut stream, addr) = server.accept(0).unwrap();
        println!(""Accepted connection from {}"", addr);
        match handler::handle_req(&mut stream, addr) {
            Ok((res, binary)) => {
                let res: String = res.into();
                let bytes = res.as_bytes();
                stream.write_all(bytes).unwrap();
                if let Some(binary) = binary {
                    stream.write_all(&binary).unwrap();
                }
            }
            Err(e) => {
                println!(""Error: {:?}"", e);
            }
        };
        stream.shutdown(Shutdown::Both).unwrap();
    }
}
```

The `handler.rs` parses the received data to the path and queries objects and returns the corresponding response.

```rust
use crate::response;
use anyhow::Result;
use parsed::http::Response;
use std::io::Read;
use wasmedge_wasi_socket::{SocketAddr, TcpStream};

pub fn handle_req(stream: &mut TcpStream, addr: SocketAddr) -> Result<(Response, Option<Vec<u8>>)> {
    let mut buf = [0u8; 1024];
    let mut received_data: Vec<u8> = Vec::new();

    loop {
        let n = stream.read(&mut buf)?;
        received_data.extend_from_slice(&buf[..n]);
        if n < 1024 {
            break;
        }
    }

    let mut bs: parsed::stream::ByteStream = match String::from_utf8(received_data) {
        Ok(s) => s.into(),
        Err(_) => return Ok((response::bad_request(), None)),
    };

    let req = match parsed::http::parse_http_request(&mut bs) {
        Some(req) => req,
        None => return Ok((response::bad_request(), None)),
    };

    println!(""{:?} request: {:?} {:?}"", addr, req.method, req.path);

    let mut path_split = req.path.split(""?"");
    let path = path_split.next().unwrap_or(""/"");
    let query_str = path_split.next().unwrap_or("""");
    let query = querystring::querify(&query_str);
    let mut init_count: Option<u32> = None;
    for (k, v) in query {
        if k.eq(""init"") {
            match v.parse::<u32>() {
                Ok(v) => init_count = Some(v),
                Err(_) => return Ok((response::bad_request(), None)),
            }
        }
    }

    let (res, binary) = if path.starts_with(""/static"") {
        response::file(&path)
    } else {
        // render page
        response::ssr(&path, init_count)
    }
    .unwrap_or_else(|_| response::internal_error());

    Ok((res, binary))
}
```

The `response.rs` program packs the response object for static assets and server-rendered content. For the latter, you could see that SSR happens at `app.render().to_string()`, the result string is put into HTML by replacing the placeholder text.

```rust
use crate::mime::MimeType;
use anyhow::Result;
use parsed::http::{Header, Response};
use std::fs::{read};
use std::path::Path;
use isomorphic_app::App;

const HTML_PLACEHOLDER: &str = ""#HTML_INSERTED_HERE_BY_SERVER#"";
const STATE_PLACEHOLDER: &str = ""#INITIAL_STATE_JSON#"";

pub fn ssr(path: &str, init: Option<u32>) -> Result<(Response, Option<Vec<u8>>)> {
    let html = format!(""{}"", include_str!(""./index.html""));

    let app = App::new(init.unwrap_or(1001), path.to_string());
    let state = app.store.borrow();

    let html = html.replace(HTML_PLACEHOLDER, &app.render().to_string());
    let html = html.replace(STATE_PLACEHOLDER, &state.to_json());

    Ok((Response {
        protocol: ""HTTP/1.0"".to_string(),
        code: 200,
        message: ""OK"".to_string(),
        headers: vec![
            Header {
                name: ""content-type"".to_string(),
                value: MimeType::from_ext(""html"").get(),
            },
            Header {
                name: ""content-length"".to_string(),
                value: html.len().to_string(),
            },
        ],
        content: html.into_bytes(),
    }, None))
}

/// Get raw file content
pub fn file(path: &str) -> Result<(Response, Option<Vec<u8>>)> {
    let path = Path::new(&path);
    if path.exists() {
        let content_type: MimeType = match path.extension() {
            Some(ext) => MimeType::from_ext(ext.to_str().get_or_insert("""")),
            None => MimeType::from_ext(""""),
        };
        let content = read(path)?;

        Ok((Response {
            protocol: ""HTTP/1.0"".to_string(),
            code: 200,
            message: ""OK"".to_string(),
            headers: vec![
                Header {
                    name: ""content-type"".to_string(),
                    value: content_type.get(),
                },
                Header {
                    name: ""content-length"".to_string(),
                    value: content.len().to_string(),
                },
            ],
            content: vec![],
        }, Some(content)))
    } else {
        Ok((Response {
            protocol: ""HTTP/1.0"".to_string(),
            code: 404,
            message: ""Not Found"".to_string(),
            headers: vec![],
            content: vec![],
        }, None))
    }
}

/// Bad Request
pub fn bad_request() -> Response {
    Response {
        protocol: ""HTTP/1.0"".to_string(),
        code: 400,
        message: ""Bad Request"".to_string(),
        headers: vec![],
        content: vec![],
    }
}

/// Internal Server Error
pub fn internal_error() -> (Response, Option<Vec<u8>>) {
    (Response {
        protocol: ""HTTP/1.0"".to_owned(),
        code: 500,
        message: ""Internal Server Error"".to_owned(),
        headers: vec![],
        content: vec![],
    }, None)
}
```

The `mime.rs` program is a map for assets' extension names and the Mime type.

```rust
pub struct MimeType {
    pub r#type: String,
}

impl MimeType {
    pub fn new(r#type: &str) -> Self {
        MimeType {
            r#type: r#type.to_string(),
        }
    }

    pub fn from_ext(ext: &str) -> Self {
        match ext {
            ""html"" => MimeType::new(""text/html""),
            ""css"" => MimeType::new(""text/css""),
            ""map"" => MimeType::new(""application/json""),
            ""js"" => MimeType::new(""application/javascript""),
            ""json"" => MimeType::new(""application/json""),
            ""svg"" => MimeType::new(""image/svg+xml""),
            ""wasm"" => MimeType::new(""application/wasm""),
            _ => MimeType::new(""text/plain""),
        }
    }

    pub fn get(self) -> String {
        self.r#type
    }
}
```

That's it! Now let's build and run the web application. If you have tested the original example, you have already built the client WebAssembly.

```bash
cd client
./build-wasm.sh
```

Next, build and run the server.

```bash
cd ../server-wasmedge
cargo build --target wasm32-wasi
OUTPUT_CSS=""$(pwd)/../client/build/app.css"" wasmedge --dir /static:../client/build ../../../target/wasm32-wasi/debug/isomorphic-server-wasmedge.wasm
```

Navigate to `http://127.0.0.1:3000`, and you will see the web application in action.

Furthermore, you can place all the steps into a shell script `../start-wasmedge.sh`.

```bash
#!/bin/bash

cd $(dirname $0)

cd ./client

./build-wasm.sh

cd ../server-wasmedge

OUTPUT_CSS=""$(pwd)/../client/build/app.css"" cargo run -p isomorphic-server-wasmedge
```

Add the following to the `.cargo/config.toml` file.

```toml
[build]
target = ""wasm32-wasi""

[target.wasm32-wasi]
runner = ""wasmedge --dir /static:../client/build""
```

After that, a single CLI command `./start-wasmedge.sh` would perform all the tasks to build and run the web application!

We forked the Percy repository and made a ready-to-build [server-wasmedge](https://github.com/second-state/percy/tree/master/examples/isomorphic/server-wasmedge) example project for you. Happy coding!
","**Summary**

The provided code is an example of a server-side rendering (SSR) web application built using the Percy framework and the WasmEdge WebAssembly runtime. The application allows for fast performance and startup time on slow devices and networks.

**Key Components**

1. **Percy Framework**: A Rust-based web framework that provides a high-level abstraction for building web applications.
2. **WasmEdge WebAssembly Runtime**: A WebAssembly runtime that allows executing WASM code in the server-side environment.
3. **Server-wasmedge**: A custom WasmEdge-based server implementation that listens to incoming requests and responds with HTML content generated by the Percy framework.

**Functionality**

1. The application uses a single-threaded HTTP server implementation (TcpListener) to handle incoming requests.
2. Each request is handled by the `handle_req` function, which parses the received data to extract the path and query parameters.
3. Based on the path, the application either serves static assets or renders a page using the Percy framework's SSR capabilities.
4. The rendered HTML content is sent back to the client as a response.

**Potential Issues/Improvements**

1. **Error Handling**: The code lacks comprehensive error handling for unexpected situations, such as network errors or invalid request data.
2. **Security**: The application uses a hardcoded path to serve static assets, which may pose security risks if not properly validated.
3. **Performance**: The single-threaded server implementation may become a bottleneck under high traffic conditions.

**Next Steps**

1. Implement comprehensive error handling mechanisms.
2. Use more robust and secure methods for serving static assets (e.g., using a separate service or a more secure storage solution).
3. Consider implementing a multi-threaded server or load balancing to improve performance under heavy loads."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/ssr.md,"---
sidebar_position: 12
---

# Server-side rendering

Frontend web frameworks allow developers to create web apps in a high-level language and component model. The web app is built into a static website to be rendered in the browser. While many frontend web frameworks are based on JavaScript, such as React and Vue, Rust-based frameworks are also emerging as the Rust language gains traction among developers. Those web frameworks render the HTML DOM UI using the WebAssembly, compiled from Rust source code. They use [wasm-bindgen](https://github.com/rustwasm/wasm-bindgen) to tie the Rust to the HTML DOM. While these frameworks send `.wasm` files to the browser to render the UI on the client side, some provide the additional choice for [Server-side rendering](https://en.wikipedia.org/wiki/Server-side_scripting). That is to run the WebAssembly code, build the HTML DOM UI on the server, and stream the HTML content to the browser for faster performance and startup time on slow devices and networks.

<!-- prettier-ignore -->
:::note
If you are interested in JavaScript-based Jamstack and SSR frameworks, such as React, please [check out our JavaScript SSR chapter](../javascript/ssr.md).
:::

This article will explore how to render the web UI on the server using WasmEdge. We pick [Percy](https://github.com/chinedufn/percy) as our framework because it is relatively mature in SSR and [Hydration](<https://en.wikipedia.org/wiki/Hydration_(web_development)>). Percy already provides an [example](https://github.com/chinedufn/percy/tree/master/examples/isomorphic) for SSR. It's highly recommended to read it first to understand how it works. The default SSR setup with Percy utilizes a native Rust web server. The Rust code is compiled to machine native code for the server. However, we need a sandbox to host user applications on the server. While we could run native code inside a Linux container (Docker), a far more efficient (and safer) approach is to run the compiled code in a WebAssembly VM on the server, especially considering the rendering code is already compiled into WebAssembly.

Let's go through the steps to run a Percy SSR service in a WasmEdge server.

Assuming we are in the `examples/isomorphic` directory, make a new crate beside the existing `server`.

```bash
cargo new server-wasmedge
```

You'll receive a warning to let you put the new crate into the workspace, so insert below into `members` of `[workspace]`. The file is `../../Cargo.toml`.

```toml
""examples/isomorphic/server-wasmedge""
```

With the file open, put these two lines in the bottom:

```toml
[patch.crates-io]
wasm-bindgen = { git = ""https://github.com/KernelErr/wasm-bindgen.git"", branch = ""wasi-compat"" }
```

<!-- prettier-ignore -->
:::note
Why do we need a forked `wasm-bindgen`? That is because `wasm-bindgen` is the required glue between Rust and HTML in the browser. On the server, however, we need to build the Rust code to the `wasm32-wasi` target, which is incompatible with `wasm-bindgen`. Our forked `wasm-bindgen` has conditional configs that remove browser-specific code in the generated `.wasm` file for the `wasm32-wasi` target.
:::

Then replace the crate's `Cargo.toml` with the following content.

```toml
[package]
name = ""isomorphic-server-wasmedge""
version = ""0.1.0""
edition = ""2021""

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
wasmedge_wasi_socket = ""0""
querystring = ""1.1.0""
parsed = { version = ""0.3"", features = [""http""] }
anyhow = ""1""
serde = { version = ""1.0"", features = [""derive""] }
isomorphic-app = { path = ""../app"" }
```

The `wasmedge_wasi_socket` crate is the socket API of WasmEdge. This project is under development. Next, copy the `index.html` file into the crate's root.

```bash
cp server/src/index.html server-wasmedge/src/
```

Then let's create some Rust code to start a web service in WasmEdge! The `main.rs` program listens to the request and sends the response via the stream.

```rust
use std::io::Write;
use wasmedge_wasi_socket::{Shutdown, TcpListener};

mod handler;
mod mime;
mod response;

fn main() {
    let server = TcpListener::bind(""127.0.0.1:3000"", false).unwrap();
    println!(""Server listening on 127.0.0.1:3000"");

    // Simple single-thread HTTP server
    // For server with Pool support, see https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/poll_http_server
    loop {
        let (mut stream, addr) = server.accept(0).unwrap();
        println!(""Accepted connection from {}"", addr);
        match handler::handle_req(&mut stream, addr) {
            Ok((res, binary)) => {
                let res: String = res.into();
                let bytes = res.as_bytes();
                stream.write_all(bytes).unwrap();
                if let Some(binary) = binary {
                    stream.write_all(&binary).unwrap();
                }
            }
            Err(e) => {
                println!(""Error: {:?}"", e);
            }
        };
        stream.shutdown(Shutdown::Both).unwrap();
    }
}
```

The `handler.rs` parses the received data to the path and queries objects and returns the corresponding response.

```rust
use crate::response;
use anyhow::Result;
use parsed::http::Response;
use std::io::Read;
use wasmedge_wasi_socket::{SocketAddr, TcpStream};

pub fn handle_req(stream: &mut TcpStream, addr: SocketAddr) -> Result<(Response, Option<Vec<u8>>)> {
    let mut buf = [0u8; 1024];
    let mut received_data: Vec<u8> = Vec::new();

    loop {
        let n = stream.read(&mut buf)?;
        received_data.extend_from_slice(&buf[..n]);
        if n < 1024 {
            break;
        }
    }

    let mut bs: parsed::stream::ByteStream = match String::from_utf8(received_data) {
        Ok(s) => s.into(),
        Err(_) => return Ok((response::bad_request(), None)),
    };

    let req = match parsed::http::parse_http_request(&mut bs) {
        Some(req) => req,
        None => return Ok((response::bad_request(), None)),
    };

    println!(""{:?} request: {:?} {:?}"", addr, req.method, req.path);

    let mut path_split = req.path.split(""?"");
    let path = path_split.next().unwrap_or(""/"");
    let query_str = path_split.next().unwrap_or("""");
    let query = querystring::querify(&query_str);
    let mut init_count: Option<u32> = None;
    for (k, v) in query {
        if k.eq(""init"") {
            match v.parse::<u32>() {
                Ok(v) => init_count = Some(v),
                Err(_) => return Ok((response::bad_request(), None)),
            }
        }
    }

    let (res, binary) = if path.starts_with(""/static"") {
        response::file(&path)
    } else {
        // render page
        response::ssr(&path, init_count)
    }
    .unwrap_or_else(|_| response::internal_error());

    Ok((res, binary))
}
```

The `response.rs` program packs the response object for static assets and server-rendered content. For the latter, you could see that SSR happens at `app.render().to_string()`, the result string is put into HTML by replacing the placeholder text.

```rust
use crate::mime::MimeType;
use anyhow::Result;
use parsed::http::{Header, Response};
use std::fs::{read};
use std::path::Path;
use isomorphic_app::App;

const HTML_PLACEHOLDER: &str = ""#HTML_INSERTED_HERE_BY_SERVER#"";
const STATE_PLACEHOLDER: &str = ""#INITIAL_STATE_JSON#"";

pub fn ssr(path: &str, init: Option<u32>) -> Result<(Response, Option<Vec<u8>>)> {
    let html = format!(""{}"", include_str!(""./index.html""));

    let app = App::new(init.unwrap_or(1001), path.to_string());
    let state = app.store.borrow();

    let html = html.replace(HTML_PLACEHOLDER, &app.render().to_string());
    let html = html.replace(STATE_PLACEHOLDER, &state.to_json());

    Ok((Response {
        protocol: ""HTTP/1.0"".to_string(),
        code: 200,
        message: ""OK"".to_string(),
        headers: vec![
            Header {
                name: ""content-type"".to_string(),
                value: MimeType::from_ext(""html"").get(),
            },
            Header {
                name: ""content-length"".to_string(),
                value: html.len().to_string(),
            },
        ],
        content: html.into_bytes(),
    }, None))
}

/// Get raw file content
pub fn file(path: &str) -> Result<(Response, Option<Vec<u8>>)> {
    let path = Path::new(&path);
    if path.exists() {
        let content_type: MimeType = match path.extension() {
            Some(ext) => MimeType::from_ext(ext.to_str().get_or_insert("""")),
            None => MimeType::from_ext(""""),
        };
        let content = read(path)?;

        Ok((Response {
            protocol: ""HTTP/1.0"".to_string(),
            code: 200,
            message: ""OK"".to_string(),
            headers: vec![
                Header {
                    name: ""content-type"".to_string(),
                    value: content_type.get(),
                },
                Header {
                    name: ""content-length"".to_string(),
                    value: content.len().to_string(),
                },
            ],
            content: vec![],
        }, Some(content)))
    } else {
        Ok((Response {
            protocol: ""HTTP/1.0"".to_string(),
            code: 404,
            message: ""Not Found"".to_string(),
            headers: vec![],
            content: vec![],
        }, None))
    }
}

/// Bad Request
pub fn bad_request() -> Response {
    Response {
        protocol: ""HTTP/1.0"".to_string(),
        code: 400,
        message: ""Bad Request"".to_string(),
        headers: vec![],
        content: vec![],
    }
}

/// Internal Server Error
pub fn internal_error() -> (Response, Option<Vec<u8>>) {
    (Response {
        protocol: ""HTTP/1.0"".to_owned(),
        code: 500,
        message: ""Internal Server Error"".to_owned(),
        headers: vec![],
        content: vec![],
    }, None)
}
```

The `mime.rs` program is a map for assets' extension names and the Mime type.

```rust
pub struct MimeType {
    pub r#type: String,
}

impl MimeType {
    pub fn new(r#type: &str) -> Self {
        MimeType {
            r#type: r#type.to_string(),
        }
    }

    pub fn from_ext(ext: &str) -> Self {
        match ext {
            ""html"" => MimeType::new(""text/html""),
            ""css"" => MimeType::new(""text/css""),
            ""map"" => MimeType::new(""application/json""),
            ""js"" => MimeType::new(""application/javascript""),
            ""json"" => MimeType::new(""application/json""),
            ""svg"" => MimeType::new(""image/svg+xml""),
            ""wasm"" => MimeType::new(""application/wasm""),
            _ => MimeType::new(""text/plain""),
        }
    }

    pub fn get(self) -> String {
        self.r#type
    }
}
```

That's it! Now let's build and run the web application. If you have tested the original example, you have already built the client WebAssembly.

```bash
cd client
./build-wasm.sh
```

Next, build and run the server.

```bash
cd ../server-wasmedge
cargo build --target wasm32-wasi
OUTPUT_CSS=""$(pwd)/../client/build/app.css"" wasmedge --dir /static:../client/build ../../../target/wasm32-wasi/debug/isomorphic-server-wasmedge.wasm
```

Navigate to `http://127.0.0.1:3000`, and you will see the web application in action.

Furthermore, you can place all the steps into a shell script `../start-wasmedge.sh`.

```bash
#!/bin/bash

cd $(dirname $0)

cd ./client

./build-wasm.sh

cd ../server-wasmedge

OUTPUT_CSS=""$(pwd)/../client/build/app.css"" cargo run -p isomorphic-server-wasmedge
```

Add the following to the `.cargo/config.toml` file.

```toml
[build]
target = ""wasm32-wasi""

[target.wasm32-wasi]
runner = ""wasmedge --dir /static:../client/build""
```

After that, a single CLI command `./start-wasmedge.sh` would perform all the tasks to build and run the web application!

We forked the Percy repository and made a ready-to-build [server-wasmedge](https://github.com/second-state/percy/tree/master/examples/isomorphic/server-wasmedge) example project for you. Happy coding!
","**Summary**

The code provided is a Server-Side Rendering (SSR) example using the Percy framework, which is built on top of Rust and WebAssembly. The goal is to render web UI on the server using WasmEdge, a sandbox for hosting user applications on the server.

**Key Components**

1. `server-wasmedge` crate: A new crate created to hold the server-side code.
2. `wasm_bindgen`: Forked version of the `wasm_bindgen` library to remove browser-specific code for the `wasm32-wasi` target.
3. `main.rs`: The main program that listens to requests and sends responses via the stream.
4. `handler.rs`: Parses received data to the path and queries objects, returning the corresponding response.
5. `response.rs`: Packs the response object for static assets and server-rendered content.

**Steps to Run**

1. Build and run the client WebAssembly using `./build-wasm.sh`.
2. Build and run the server using `cargo build --target wasm32-wasi` and `wasmedge` commands.
3. Navigate to `http://127.0.0.1:3000` to see the web application in action.

**Potential Issues/ Areas for Improvement**

1. Error handling: The current implementation does not handle errors well, and it's essential to add proper error handling mechanisms.
2. Performance: The server-side rendering process might be slow due to the use of WebAssembly. Optimizations can be made to improve performance.
3. Code organization: The codebase could benefit from better organization, with clearer separation between different components and responsibilities.

**Additional Resources**

1. [Percy repository](https://github.com/chinedufn/percy)
2. [WasmEdge documentation](https://wasmedge.github.io/)

By following the steps and addressing potential issues, one can successfully run a Server-Side Rendering example using Percy and WasmEdge, demonstrating the possibilities of WebAssembly in server-side development."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_nn.md,"---
sidebar_position: 2
---

# Build with WASI-nn Plug-in

The WASI-NN plug-in is a proposed WebAssembly System Interface (WASI) API for machine learning. It allows WebAssembly programs to access host-provided machine learning functions.

## Prerequisites

Currently, WasmEdge used OpenVINO™, PyTorch, TensorFlow Lite, or llama.cpp as the WASI-NN backend implementation. For using WASI-NN on WasmEdge, you need to install [OpenVINO™](https://docs.openvino.ai/2023.0/openvino_docs_install_guides_installing_openvino_apt.html)(2023), [TensorFlow Lite](https://www.tensorflow.org/install/lang_c), or [PyTorch 1.8.2 LTS](https://pytorch.org/get-started/locally/) for the backend.

By default, we don't enable any WASI-NN backend in WasmEdge. Therefore developers should [build the WasmEdge from source](../os/linux.md) with the cmake option `WASMEDGE_PLUGIN_WASI_NN_BACKEND` to enable the backends.

## Build WasmEdge with WASI-NN OpenVINO Backend

For choosing and installing OpenVINO™ on `Ubuntu 20.04` for the backend, we recommend the following commands:

```bash
wget https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB
sudo apt-key add GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB
echo ""deb https://apt.repos.intel.com/openvino/2023 ubuntu20 main"" | sudo tee /etc/apt/sources.list.d/intel-openvino-2023.list
sudo apt update
sudo apt-get -y install openvino
ldconfig
```

Then build and install WasmEdge from source:

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""OpenVINO""
cmake --build build
# For the WASI-NN plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-NN plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_nn/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-NN with OpenVINO backend plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiNN.so` after installation.

## Build WasmEdge with WASI-NN PyTorch Backend

For choosing and installing PyTorch on `Ubuntu 20.04` for the backend, we recommend the following commands:

```bash
export PYTORCH_VERSION=""1.8.2""
curl -s -L -O --remote-name-all https://download.pytorch.org/libtorch/lts/1.8/cpu/libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip
unzip -q ""libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""
rm -f ""libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""
export LD_LIBRARY_PATH=$(pwd)/libtorch/lib:${LD_LIBRARY_PATH}
export Torch_DIR=$(pwd)/libtorch
```

For the legacy operating system such as `CentOS 7.6`, please use the `pre-cxx11-abi` version of `libtorch` instead:

```bash
export PYTORCH_VERSION=""1.8.2""
curl -s -L -O --remote-name-all https://download.pytorch.org/libtorch/lts/1.8/cpu/libtorch-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip
unzip -q ""libtorch-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""
rm -f ""libtorch-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""
export LD_LIBRARY_PATH=$(pwd)/libtorch/lib:${LD_LIBRARY_PATH}
export Torch_DIR=$(pwd)/libtorch
```

The PyTorch library will be extracted in the current directory `./libtorch`.

Then build and install WasmEdge from source:

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""PyTorch""
cmake --build build
# For the WASI-NN plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-NN plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_nn/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-NN with PyTorch backend plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiNN.so` after installation.

## Build WasmEdge with WASI-NN TensorFlow-Lite Backend

You can build and install WasmEdge from source directly (on `Linux x86_64`, `Linux aarch64`, `MacOS x86_64`, or `MacOS arm64` platforms):

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""TensorflowLite""
cmake --build build
# For the WASI-NN plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-NN plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_nn/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-NN with TensorFlow-lite backend plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiNN.so` after installation.

Installing the necessary `libtensorflowlite_c.so` and `libtensorflowlite_flex.so` on both `Ubuntu 20.04` and `manylinux2014` for the backend, we recommend the following commands:

```bash
curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
tar -zxf WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
rm -f WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
```

The shared library will be extracted in the current directory `./libtensorflowlite_c.so` and `./libtensorflowlite_flex.so`.

Then you can move the library to the installation path:

```bash
mv libtensorflowlite_c.so /usr/local/lib
mv libtensorflowlite_flex.so /usr/local/lib
```

Or set the environment variable `export LD_LIBRARY_PATH=$(pwd):${LD_LIBRARY_PATH}`.

<!-- prettier-ignore -->
:::note
We also provided the `darwin_x86_64`, `darwin_arm64`, and `manylinux_aarch64` versions of the TensorFlow-Lite pre-built shared libraries.
:::

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasi_nn).

## Build WasmEdge with WASI-NN llama.cpp Backend

You don't need to install any llama.cpp libraries. WasmEdge will download it during the building period.

Due to the acceleration frameworks being various, you will need to use different compilation options to build this plugin. Please make sure you are following the same OS section to do this.

### MacOS

#### Intel Model

If you are using the Intel Model macOS, we won't enable any acceleration framework. It is a pure CPU mode plugin.

```bash
cd <path/to/your/wasmedge/source/folder>
# Disable BLAS and METAL on x86_64 macOS.
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \
  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_METAL=OFF \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \
  .
cmake --build build
# For the WASI-NN plugin, you should install this project.
cmake --install build
```

#### Apple Silicon Model

You can build and install WasmEdge from source directly on the macOS arm64 platform. It will use the built-in GPU by default.

```bash
cd <path/to/your/wasmedge/source/folder>
# Enable METAL on arm64 macOS.
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \
  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_METAL=ON \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \
  .
cmake --build build
# For the WASI-NN plugin, you should install this project.
cmake --install build
```

### Linux

#### Ubuntu/Debian with CUDA 12

Please follow the official guide provided by NVIDIA for installing the CUDA framework: <https://developer.nvidia.com/cuda-12-2-0-download-archive>

```bash
cd <path/to/your/wasmedge/source/folder>

# You may need to install dependencies
apt update
apt install -y software-properties-common lsb-release \
  cmake unzip pkg-config

# Due to cuda-related files, it will produce some warning.
# Disable the warning as an error to avoid failures.
export CXXFLAGS=""-Wno-error""
# Please make sure you set up the correct CUDAARCHS.
# We use `60;61;70` for maximum compatibility.
export CUDAARCHS=""60;61;70""

# BLAS cannot work with CUBLAS
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \
  -DCMAKE_CUDA_ARCHITECTURES=""60;61;70"" \
  -DCMAKE_CUDA_COMPILER=/usr/local/cuda/bin/nvcc \
  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_CUBLAS=ON \
  .

cmake --build build

# For the WASI-NN plugin, you should install this project.
cmake --install build
```

#### Ubuntu on NVIDIA Jetson AGX Orin

You should use the pre-built OS image from the NVIDIA official site.

```bash
cd <path/to/your/wasmedge/source/folder>

# Due to cuda-related files, it will produce some warning.
# Disable the warning as an error to avoid failures.
export CXXFLAGS=""-Wno-error""
# Please make sure you set up the correct CUDAARCHS.
# 72 is for NVIDIA Jetson AGX Orin
export CUDAARCHS=72

# BLAS cannot work with CUBLAS
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \
  -DCMAKE_CUDA_COMPILER=/usr/local/cuda/bin/nvcc \
  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_CUBLAS=ON \
  .

cmake --build build

# For the WASI-NN plugin, you should install this project.
cmake --install build
```

#### Ubuntu/Debian with OpenBLAS

Please install OpenBLAS before building the plugin.

```bash
cd <path/to/your/wasmedge/source/folder>

# You may need to install dependencies
apt update
apt install -y software-properties-common lsb-release \
  cmake unzip pkg-config
# You must install OpenBLAS
apt install libopenblas-dev

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \
  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=ON \
  .

cmake --build build

# For the WASI-NN plugin, you should install this project.
cmake --install build
```

#### General Linux without any acceleration framework

```bash
cd <path/to/your/wasmedge/source/folder>

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \
  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \
  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \
  .

cmake --build build

# For the WASI-NN plugin, you should install this project.
cmake --install build
```

### Appendix

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-NN plugin, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plugin installation path (such as `/usr/local/lib/wasmedge/` or the built plugin path `build/plugins/wasi_nn/`) to try to fix this issue.
:::

<!-- prettier-ignore -->
:::note
We also provided the pre-built ggml plugins on the following platforms:

- darwin\_x86\_64: Intel Model macOS
- darwin\_arm64: Apple Silicon Model macOS
- ubuntu20.04\_x86\_64: x86\_64 Linux (the glibc is using Ubuntu20.04 one)
- ubuntu20.04\_aarch64: aarch64 Linux (the glibc is using Ubuntu20.04 one)
- ubuntu20.04\_blas\_x86\_64: x86\_64 Linux with OpenBLAS support (the glibc is using Ubuntu20.04 one)
- ubuntu20.04\_blas\_aarch64: aarch64 Linux with OpenBLAS support (the glibc is using Ubuntu20.04 one)
- ubuntu20.04\_cuda\_x86\_64: x86\_64 Linux with CUDA 12 support (the glibc is using Ubuntu20.04 one)
- ubuntu20.04\_cuda\_aarch64: aarch64 Linux with CUDA 11 support (the glibc is using Ubuntu20.04 one), for NVIDIA Jetson AGX Orin
- manylinux2014\_x86\_64: x86\_64 Linux (the glibc is using CentOS 7 one)
- manylinux2014\_aarch64: aarch64 Linux (the glibc is using CentOS 7 one)

:::
","This is a detailed documentation on how to build and install WasmEdge, a WebAssembly runtime, with the WASI-NN plug-in. The plug-in allows WebAssembly programs to access host-provided machine learning functions.

Here's a concise summary of the purpose, functionality, and key components:

**Purpose:**

The main goal is to enable the use of WasmEdge as a platform for running machine learning models written in WebAssembly.

**Functionality:**

The WASI-NN plug-in allows WasmEdge to access host-provided machine learning functions. It supports various acceleration frameworks, including OpenVINO, PyTorch, TensorFlow Lite, and llama.cpp (a backend using the Metal API).

**Key components:**

* `wasmedge`: The WebAssembly runtime.
* `wasi-nn`: The plug-in that enables access to host-provided machine learning functions.
* `OpenVINO`, `PyTorch`, `TensorFlow Lite`, and `llama.cpp`: Acceleration frameworks supported by the WASI-NN plug-in.

**Steps:**

1. Install the necessary dependencies, including `cmake` and `pkg-config`.
2. Build WasmEdge from source using the following commands:

```bash
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \
  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \
  .
cmake --build build
```

3. Install the WASI-NN plug-in by running:

```
cmake --install build
```

4. Set the `WASMEDGE_PLUGIN_PATH` environment variable to the plugin installation path (e.g., `/usr/local/lib/wasmedge/`) if the built `wasmedge` CLI tool cannot find the plug-in.

**Notes:**

* The documentation provides pre-built ggml plugins for various platforms, including darwin\_x86\_64, darwin\_arm64, ubuntu20.04\_x86\_64, and manylinux2014\_aarch64.
* Users can choose to install OpenBLAS or CUDA 12 support on their system.
* The documentation includes notes for troubleshooting and setting up the `WASMEDGE_PLUGIN_PATH` environment variable.

Overall, this is a comprehensive guide that covers all the necessary steps for building and installing WasmEdge with the WASI-NN plug-in. It's well-structured and easy to follow, making it accessible to developers who are new to the topic."
docs/develop/deploy/cri-runtime/crio-crun.md,"---
sidebar_position: 3
---

# CRI-O + crun

## Quick start

The [GitHub repo](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on CRI-O.

- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio.yml)
- HTTP service example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio-server.yml)

In the sections below, we will explain the steps in the quick start scripts.

- [CRI-O + crun](#cri-o--crun)
  - [Quick start](#quick-start)
  - [Install CRI-O](#install-cri-o)
  - [Configure CRI-O to use crun](#configure-cri-o-to-use-crun)
  - [Run a simple WebAssembly app](#run-a-simple-webassembly-app)
  - [Run a HTTP server app](#run-a-http-server-app)

## Install CRI-O

Use the following commands to install CRI-O on your system.

```bash
export OS=""xUbuntu_20.04""
export VERSION=""1.21""
apt update
apt install -y libseccomp2 || sudo apt update -y libseccomp2
echo ""deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /"" > /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
echo ""deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /"" > /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list

curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | apt-key add -
curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -

apt-get update
apt-get install criu libyajl2
apt-get install cri-o cri-o-runc cri-tools containernetworking-plugins
systemctl start crio
```

## Configure CRI-O to use crun

CRI-O uses the `runc` runtime by default and we need to configure it to use `crun` instead. That is done by adding to two configuration files.

<!-- prettier-ignore -->
:::note
Before starting the following steps, ensure you have [built and installed the `crun` binary with WasmEdge support](../oci-runtime/crun.md).
:::

First, create a `/etc/crio/crio.conf` file and add the following lines as its content. It tells CRI-O to use `crun` by default.

```conf
[crio.runtime]
default_runtime = ""crun""
```

The `crun` runtime is in turn defined in the `/etc/crio/crio.conf.d/01-crio-runc.conf` file.

```conf
[crio.runtime.runtimes.runc]
runtime_path = ""/usr/lib/cri-o-runc/sbin/runc""
runtime_type = ""oci""
runtime_root = ""/run/runc""
# The above is the original content

# Add our crunw runtime here
[crio.runtime.runtimes.crun]
runtime_path = ""/usr/bin/crun""
runtime_type = ""oci""
runtime_root = ""/run/crun""
```

Next, restart CRI-O to apply the configuration changes.

```bash
systemctl restart crio
```

## Run a simple WebAssembly app

Now, we can run a simple WebAssembly program using CRI-O. [A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md) explains how to compile, package, and publish the WebAssembly program as a container image to Docker hub. In this section, we will start pulling this WebAssembly-based container image from the Docker hub using CRI-O tools.

```bash
sudo crictl pull docker.io/hydai/wasm-wasi-example:with-wasm-annotation
```

Next, we must create two simple configuration files that specify how CRI-O should run this WebAssembly image in a sandbox. We already have those two files [container_wasi.json](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/container_wasi.json) and [sandbox_config.json](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json). You can download them to your local directory as follows.

```bash
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/container_wasi.json
```

Now you can use CRI-O to create a pod and a container using the specified configurations.

```bash
# Create the POD. The output will be different from the example.
$ sudo crictl runp sandbox_config.json
7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4
# Set a helper variable for later use.
$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# Create the container instance. The output will be different from the example.
$ sudo crictl create $POD_ID container_wasi.json sandbox_config.json
# Set a helper variable for later use.
CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
```

Starting the container would execute the WebAssembly program. You can see the output in the console.

```bash
# List the container; the state should be `Created`
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       wasmedge/example-wasi:latest                   About a minute ago   Created             podsandbox1-wasm-wasi   0                   7992e75df00cc

# Start the container
$ sudo crictl start $CONTAINER_ID

# recheck the container status.
# If the container is not finishing its job, you will see the Running state
# Because this example is very tiny. You may see Exited at this moment.
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       wasmedge/example-wasi:latest                   About a minute ago   Running             podsandbox1-wasm-wasi   0                   7992e75df00cc

# When the container is finished. You can see the state becomes Exited.
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       wasmedge/example-wasi:latest                   About a minute ago   Exited              podsandbox1-wasm-wasi   0                   7992e75df00cc

# Check the container's logs. It should show outputs from the WebAssembly programs
$ sudo crictl logs $CONTAINER_ID

Test 1: Print Random Number
Random number: 960251471

Test 2: Print Random Bytes
Random bytes: [50, 222, 62, 128, 120, 26, 64, 42, 210, 137, 176, 90, 60, 24, 183, 56, 150, 35, 209, 211, 141, 146, 2, 61, 215, 167, 194, 1, 15, 44, 156, 27, 179, 23, 241, 138, 71, 32, 173, 159, 180, 21, 198, 197, 247, 80, 35, 75, 245, 31, 6, 246, 23, 54, 9, 192, 3, 103, 72, 186, 39, 182, 248, 80, 146, 70, 244, 28, 166, 197, 17, 42, 109, 245, 83, 35, 106, 130, 233, 143, 90, 78, 155, 29, 230, 34, 58, 49, 234, 230, 145, 119, 83, 44, 111, 57, 164, 82, 120, 183, 194, 201, 133, 106, 3, 73, 164, 155, 224, 218, 73, 31, 54, 28, 124, 2, 38, 253, 114, 222, 217, 202, 59, 138, 155, 71, 178, 113]

Test 3: Call an echo function
Printed from wasi: This is from a main function
This is from a main function

Test 4: Print Environment Variables
The env vars are as follows.
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
TERM: xterm
HOSTNAME: crictl_host
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
The args are as follows.
/var/lib/containers/storage/overlay/006e7cf16e82dc7052994232c436991f429109edea14a8437e74f601b5ee1e83/merged/wasi_example_main.wasm
50000000

Test 5: Create a file `/tmp.txt` with content `This is in a file`

Test 6: Read the content from the previous file
File content is This is in a file

Test 7: Delete the previous file
```

Next, you can try to run the app in [Kubernetes](../kubernetes/kubernetes-cri-o.md)!

## Run a HTTP server app

Finally, we can run a simple WebAssembly-based HTTP micro-service in CRI-O. [A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md) explains how to compile, package, and publish the WebAssembly program as a container image to Docker hub. In this section, we will start off pulling this WebAssembly-based container image from Docker hub using CRI-O tools.

```bash
sudo crictl pull docker.io/avengermojo/http_server:with-wasm-annotation
```

Next, we must create two simple configuration files that specify how CRI-O should run this WebAssembly image in a sandbox. We already have those two files [container_http_server.json](https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json) and [sandbox_config.json](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json). You can download them to your local directory as follows.

<!-- prettier-ignore -->
:::note
The `sandbox_config.json` file is the same for the simple WASI and HTTP server examples. The other `container_*.json` file is application specific as it contains the application's Docker Hub URL.
:::

```bash
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json
```

Now you can use CRI-O to create a pod and a container using the specified configurations.

```bash
# Create the POD. Output will be different from example.
$ sudo crictl runp sandbox_config.json
7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4
# Set a helper variable for later use.
$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# Create the container instance. The output will be different from the example.
$ sudo crictl create $POD_ID container_http_server.json sandbox_config.json
# Set a helper variable for later use.
CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
```

Starting the container would execute the WebAssembly program. You can see the output in the console.

```bash
# Start the container
$ sudo crictl start $CONTAINER_ID

# Check the container status. It should be Running.
# If not, wait a few seconds and check again
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED                  STATE               NAME                ATTEMPT             POD ID
4eeddf8613691       wasmedge/example-wasi-http:latest              Less than a second ago   Running             http_server         0                   1d84f30e7012e

# Check the container's logs to see if the HTTP server is listening at port 1234
$ sudo crictl logs $CONTAINER_ID
new connection at 1234

# Get the IP address assigned to the container
$ sudo crictl inspect $CONTAINER_ID | grep IP.0 | cut -d: -f 2 | cut -d'""' -f 2
10.85.0.2

# Test the HTTP service at that IP address
$ curl -d ""name=WasmEdge"" -X POST http://10.85.0.2:1234
echo: name=WasmEdge
```

Next, you can run it in [Kubernetes](../kubernetes/kubernetes-cri-o.md)!
","**Summary:**

The code is a step-by-step guide to setting up and running WebAssembly applications using CRI-O (Container Runtime Interface for Open Container Initiative) and crun (a container runtime). The guide includes installing CRI-O, configuring it to use crun, and running two example applications: a simple WebAssembly app and an HTTP server app.

**Key Components:**

1. `crio-crun.md`: A Markdown file that provides instructions on how to set up and run the examples.
2. Installation scripts: The code includes several installation scripts for CRI-O, crun, and other dependencies.
3. Configuration files:
	* `/etc/crio/crio.conf` and `01-crio-runc.conf`: Config files that specify the default runtime and configure CRI-O to use crun.
	* `container_wasi.json`, `sandbox_config.json`, and `container_http_server.json`: JSON files that specify how to run the examples in a sandbox.

**Potential Issues:**

1. **Inconsistent formatting**: The code has inconsistent formatting, with some sections written in Markdown and others using Markdown syntax but without proper indentation or spacing.
2. **Outdated dependencies**: Some dependencies, such as `crio` and `crun`, may have newer versions available that are not referenced in the code.
3. **Missing error handling**: The installation scripts do not handle errors well, which could lead to confusing output if something goes wrong.

**Areas for Improvement:**

1. **Standardize formatting**: Use consistent formatting throughout the code to make it easier to read and maintain.
2. **Update dependencies**: Review and update dependencies to ensure they are up-to-date and compatible with newer versions of CRI-O and crun.
3. **Implement error handling**: Improve error handling in installation scripts to provide clear and useful output if something goes wrong.
4. **Consider using a CI/CD pipeline**: Automate the testing and deployment process using a CI/CD pipeline to ensure the code is reliable and efficient.

**Next Steps:**

1. Review and update dependencies.
2. Standardize formatting throughout the code.
3. Improve error handling in installation scripts.
4. Consider implementing a CI/CD pipeline for automated testing and deployment."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/crio-crun.md,"---
sidebar_position: 3
---

# CRI-O + crun

## Quick start

The [GitHub repo](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on CRI-O.

- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio.yml)
- HTTP service example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio-server.yml)

In the sections below, we will explain the steps in the quick start scripts.

- [CRI-O + crun](#cri-o--crun)
  - [Quick start](#quick-start)
  - [Install CRI-O](#install-cri-o)
  - [Configure CRI-O to use crun](#configure-cri-o-to-use-crun)
  - [Run a simple WebAssembly app](#run-a-simple-webassembly-app)
  - [Run a HTTP server app](#run-a-http-server-app)

## Install CRI-O

Use the following commands to install CRI-O on your system.

```bash
export OS=""xUbuntu_20.04""
export VERSION=""1.21""
apt update
apt install -y libseccomp2 || sudo apt update -y libseccomp2
echo ""deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /"" > /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
echo ""deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /"" > /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list

curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | apt-key add -
curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -

apt-get update
apt-get install criu libyajl2
apt-get install cri-o cri-o-runc cri-tools containernetworking-plugins
systemctl start crio
```

## Configure CRI-O to use crun

CRI-O uses the `runc` runtime by default and we need to configure it to use `crun` instead. That is done by adding to two configuration files.

<!-- prettier-ignore -->
:::note
Before starting the following steps, ensure you have [built and installed the `crun` binary with WasmEdge support](../oci-runtime/crun.md).
:::

First, create a `/etc/crio/crio.conf` file and add the following lines as its content. It tells CRI-O to use `crun` by default.

```conf
[crio.runtime]
default_runtime = ""crun""
```

The `crun` runtime is in turn defined in the `/etc/crio/crio.conf.d/01-crio-runc.conf` file.

```conf
[crio.runtime.runtimes.runc]
runtime_path = ""/usr/lib/cri-o-runc/sbin/runc""
runtime_type = ""oci""
runtime_root = ""/run/runc""
# The above is the original content

# Add our crunw runtime here
[crio.runtime.runtimes.crun]
runtime_path = ""/usr/bin/crun""
runtime_type = ""oci""
runtime_root = ""/run/crun""
```

Next, restart CRI-O to apply the configuration changes.

```bash
systemctl restart crio
```

## Run a simple WebAssembly app

Now, we can run a simple WebAssembly program using CRI-O. [A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md) explains how to compile, package, and publish the WebAssembly program as a container image to Docker hub. In this section, we will start pulling this WebAssembly-based container image from the Docker hub using CRI-O tools.

```bash
sudo crictl pull docker.io/hydai/wasm-wasi-example:with-wasm-annotation
```

Next, we must create two simple configuration files that specify how CRI-O should run this WebAssembly image in a sandbox. We already have those two files [container_wasi.json](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/container_wasi.json) and [sandbox_config.json](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json). You can download them to your local directory as follows.

```bash
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/container_wasi.json
```

Now you can use CRI-O to create a pod and a container using the specified configurations.

```bash
# Create the POD. The output will be different from the example.
$ sudo crictl runp sandbox_config.json
7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4
# Set a helper variable for later use.
$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# Create the container instance. The output will be different from the example.
$ sudo crictl create $POD_ID container_wasi.json sandbox_config.json
# Set a helper variable for later use.
CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
```

Starting the container would execute the WebAssembly program. You can see the output in the console.

```bash
# List the container; the state should be `Created`
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       wasmedge/example-wasi:latest                   About a minute ago   Created             podsandbox1-wasm-wasi   0                   7992e75df00cc

# Start the container
$ sudo crictl start $CONTAINER_ID

# recheck the container status.
# If the container is not finishing its job, you will see the Running state
# Because this example is very tiny. You may see Exited at this moment.
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       wasmedge/example-wasi:latest                   About a minute ago   Running             podsandbox1-wasm-wasi   0                   7992e75df00cc

# When the container is finished. You can see the state becomes Exited.
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       wasmedge/example-wasi:latest                   About a minute ago   Exited              podsandbox1-wasm-wasi   0                   7992e75df00cc

# Check the container's logs. It should show outputs from the WebAssembly programs
$ sudo crictl logs $CONTAINER_ID

Test 1: Print Random Number
Random number: 960251471

Test 2: Print Random Bytes
Random bytes: [50, 222, 62, 128, 120, 26, 64, 42, 210, 137, 176, 90, 60, 24, 183, 56, 150, 35, 209, 211, 141, 146, 2, 61, 215, 167, 194, 1, 15, 44, 156, 27, 179, 23, 241, 138, 71, 32, 173, 159, 180, 21, 198, 197, 247, 80, 35, 75, 245, 31, 6, 246, 23, 54, 9, 192, 3, 103, 72, 186, 39, 182, 248, 80, 146, 70, 244, 28, 166, 197, 17, 42, 109, 245, 83, 35, 106, 130, 233, 143, 90, 78, 155, 29, 230, 34, 58, 49, 234, 230, 145, 119, 83, 44, 111, 57, 164, 82, 120, 183, 194, 201, 133, 106, 3, 73, 164, 155, 224, 218, 73, 31, 54, 28, 124, 2, 38, 253, 114, 222, 217, 202, 59, 138, 155, 71, 178, 113]

Test 3: Call an echo function
Printed from wasi: This is from a main function
This is from a main function

Test 4: Print Environment Variables
The env vars are as follows.
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
TERM: xterm
HOSTNAME: crictl_host
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
The args are as follows.
/var/lib/containers/storage/overlay/006e7cf16e82dc7052994232c436991f429109edea14a8437e74f601b5ee1e83/merged/wasi_example_main.wasm
50000000

Test 5: Create a file `/tmp.txt` with content `This is in a file`

Test 6: Read the content from the previous file
File content is This is in a file

Test 7: Delete the previous file
```

Next, you can try to run the app in [Kubernetes](../kubernetes/kubernetes-cri-o.md)!

## Run a HTTP server app

Finally, we can run a simple WebAssembly-based HTTP micro-service in CRI-O. [A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md) explains how to compile, package, and publish the WebAssembly program as a container image to Docker hub. In this section, we will start off pulling this WebAssembly-based container image from Docker hub using CRI-O tools.

```bash
sudo crictl pull docker.io/avengermojo/http_server:with-wasm-annotation
```

Next, we must create two simple configuration files that specify how CRI-O should run this WebAssembly image in a sandbox. We already have those two files [container_http_server.json](https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json) and [sandbox_config.json](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json). You can download them to your local directory as follows.

<!-- prettier-ignore -->
:::note
The `sandbox_config.json` file is the same for the simple WASI and HTTP server examples. The other `container_*.json` file is application specific as it contains the application's Docker Hub URL.
:::

```bash
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json
```

Now you can use CRI-O to create a pod and a container using the specified configurations.

```bash
# Create the POD. Output will be different from example.
$ sudo crictl runp sandbox_config.json
7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4
# Set a helper variable for later use.
$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# Create the container instance. The output will be different from the example.
$ sudo crictl create $POD_ID container_http_server.json sandbox_config.json
# Set a helper variable for later use.
CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
```

Starting the container would execute the WebAssembly program. You can see the output in the console.

```bash
# Start the container
$ sudo crictl start $CONTAINER_ID

# Check the container status. It should be Running.
# If not, wait a few seconds and check again
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED                  STATE               NAME                ATTEMPT             POD ID
4eeddf8613691       wasmedge/example-wasi-http:latest              Less than a second ago   Running             http_server         0                   1d84f30e7012e

# Check the container's logs to see if the HTTP server is listening at port 1234
$ sudo crictl logs $CONTAINER_ID
new connection at 1234

# Get the IP address assigned to the container
$ sudo crictl inspect $CONTAINER_ID | grep IP.0 | cut -d: -f 2 | cut -d'""' -f 2
10.85.0.2

# Test the HTTP service at that IP address
$ curl -d ""name=WasmEdge"" -X POST http://10.85.0.2:1234
echo: name=WasmEdge
```

Next, you can run it in [Kubernetes](../kubernetes/kubernetes-cri-o.md)!
","This is a Markdown file that describes how to use CRI-O and crun to run WebAssembly-based containers.

**Summary**

The document explains the steps to install CRI-O, configure it to use crun, and run two simple WebAssembly-based container examples: one for printing random numbers and one for serving HTTP requests. The instructions are detailed and include code snippets for creating configuration files and running commands in the terminal.

**Key Components**

1. **CRI-O**: A Kubernetes container runtime that provides a lightweight way to run containers.
2. **crun**: A command-line tool used to manage CRI-O containers.
3. **WebAssembly**: A binary instruction format that can be executed by web browsers and other environments.
4. **WasmEdge**: A WebAssembly runtime for Linux and macOS.

**Steps**

1. Install CRI-O on the system using a script provided in the document.
2. Configure CRI-O to use crun instead of the default runc runtime.
3. Create two configuration files: `sandbox_config.json` and `container_*.json`. These files specify how CRI-O should run the container.
4. Run the CRI-O command `crictl create` to create a new container instance using the specified configurations.
5. Start the container using the `crictl start` command.
6. Check the container's logs and status using the `crictl logs` and `crictl ps -a` commands.

**Notes**

1. The document assumes that the reader has basic knowledge of Linux and containers.
2. The instructions are specific to CRI-O version 1.21 and crun version unknown.
3. The container images used in the examples are assumed to be available on Docker Hub.

Overall, this document provides a clear guide for running WebAssembly-based containers using CRI-O and crun. However, some readers may find the instructions too detailed or assume familiarity with Linux and containers."
docs/contribute/plugin/best_practice.md,"---
sidebar_position: 6
---

# Best Practice

When developing a WasmEdge plugin, it's important to follow best practices to ensure the plugin is well purformed, reliable, and efficient. Here are some key best practices to follow:

## Using the Latest Version of WasmEdge

Always use the latest version of WasmEdge to take advantage of the most recent features, improvements, and security updates.

### Installing the Latest Version

To install the latest version of WasmEdge, follow the installation instructions in the [WasmEdge documentation](https://wasmedge.org/docs/start/install/).

### Updating Existing Plugins

If you have existing plugins that were developed with an older version of WasmEdge, you may need to update them to work with the latest version. This could involve updating the plugin code to use new features or changes in the [WasmEdge API](https://wasmedge.org/docs/category/api-reference/), or updating the build process to use the latest version of WasmEdge.

Remember, using the latest version of WasmEdge not only ensures that you're leveraging the most recent features, but also provides the latest security updates to protect your applications.

## Choosing the Appropriate Programming Language

WasmEdge plugins can be developed in several languages including [C](develop_plugin_c.md), [C++](develop_plugin_cpp.md), and [Rust](develop_plugin_rustsdk.md). The choice of language depends on the specific requirements of the plugin and the developer's expertise. The C API is recommended for most use cases due to its simplicity and wide support. However, complex plugins might benefit from the enhanced features of C++ or Rust.

## Writing and Compiling the Plugin

When creating a WasmEdge plugin:

   1. **Code Writing**: While develop your plugin, write clear, maintainable code, and document it well for easy understanding and future maintenance.

   2. **Compiling to Shared Library**: Use a compiler like `gcc` for C or `g++` for C++ to compile your code into a shared library. For example, in a Linux environment, you might use `gcc -shared -fPIC -o my_plugin.so my_plugin.c` for a C plugin.

   3. **Error Handling and Input Validation**: Efficitive error handling to catch and manage potential issues. Validate all inputs thoroughly to ensure the plugin's stability and security.

## Testing the Plugin

Testing is a crucial part of the plugin development process. It ensures that the plugin behaves as expected, meets the requirements, and performs optimally. WasmEdge provides a set of tests for various plugins in its [repository](https://github.com/WasmEdge/WasmEdge/tree/master/test/plugins) that you can use as references for writing your own tests.

To run tests for the WasmEdge plugin, you'll need to follow a few steps. In this case, we'll use the `wasmedge-image` plugin as an example.

- **Step 1: Build the WasmEdge Runtime and WasmEdge-image Plugin**
   First, you need to build both the [build WasmEdge](../source/build_from_src.md) and the [wasmedge-image](../source/plugin/image.md) plugin.

- **Step 2: Run the Tests**
   The WasmEdge repository provides a set of tests for various plugins, including `wasmedge-image`. You can find the test cases in the `test/plugins/wasmedge_image` directory of the repository.

   To run these tests, you can use the `ctest` command from the build directory:

   ```bash
   cd ../../../test/plugins/wasmedge_image
   mkdir build && cd build
   cmake ..
   make
   ctest
   ```

   This will run all the unit tests and integration tests for the `wasmedge-image`plugin. These tests ensure that the plugin behaves as expected, meets the requirements, and performs optimally. They also verify that the plugin correctly integrates with the WebAssembly program and that the WebAssembly program can call the plugin's functions correctly.

- **Step 3: Analyze the Test Results**
   After running the tests, analyze the results to identify any issues or bugs. If any test fails, you should debug the issue, fix the problem, and then rerun the tests to ensure that the fix works as expected.

By following these steps, you can effectively run tests for the `wasmedge-image` plugin or any other WasmEdge plugin.

<!-- prettier-ignore -->
:::note
If you want to develop your own tests follow [Writing Tests for WasmEdge Plugins](test_plugin.md) for details.
:::

## Securing the Plugin

Security is a vital part of any software development process. It involves several aspects, including securing the code, verifying inputs, handling errors properly, and using secure coding practices. When developing a WasmEdge plugin, it's essential to follow these best practices:

- **Validate Inputs:** Always validate the inputs to your functions. This can prevent many types of attacks, including buffer overflow attacks and code injection attacks.

   ```c
   WasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,
                        const WasmEdge_Value *In, WasmEdge_Value *Out) {
      if (In[0].Type != WasmEdge_ValType_I32 || In[1].Type != WasmEdge_ValType_I32) {
      return WasmEdge_Result_Error;
      }
      // Rest of the function...
   }
   ```

- **Handle Errors:** Always handle errors properly. Don't ignore return values that indicate an error, and don't continue execution after an error occurs.

   ```c
   WasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,
                        const WasmEdge_Value *In, WasmEdge_Value *Out) {
      // Check the input types...
      int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
      int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
      if (Val1 == INT32_MIN || Val2 == INT32_MIN) {
      return WasmEdge_Result_Error;
      }
      // Rest of the function...
   }
   ```

- **Use Secure Coding Practices:** Follow secure coding practices in your chosen language. For example, avoid using unsafe functions, use strong types, and avoid using global variables.

## Publishing the Plugin

Once you have developed, tested, and documented your WasmEdge plugin, it’s time to publish it for others to use. You need to follow following steps for publishing your plugin:

## Exporting the SDKs in Rust

In addition to C and C++ SDKs, you can also create an SDK for Rust developers. This involves creating a Rust library that provides a Rust interface to your plugin's functionality.

### Creating a Rust Library

You can create a Rust library that provides a Rust interface to your plugin's functionality. This involves writing Rust code that calls the functions in your plugin and provides a Rust-friendly API.

In the [wasmedge-image](../source/plugin/image.md) plugin's case, you might have something like this:

```rust
// lib.rs
extern crate wasmedge_image;

use wasmedge_image::Image;

pub fn load_image(path: &str) -> Result<Image, wasmedge_image::Error> {
Image::open(path)
}
```

In this Rust library, a single `load_image` function is provided that calls the `open` function from the `wasmedge-image` plugin.

### Building the Rust Library

You can build your Rust library using Cargo, the Rust package manager. This will produce a `.so` file that can be loaded by the WasmEdge runtime.

```bash
cargo build --release
```

### Packaging the Rust SDK

Package the Rust library and the header file into a tarball or a similar package format. This makes it easy for other developers to download and install your SDK.

```bash
tar czvf wasmedge_image_rust_sdk.tar.gz libwasmedge_image.so wasmedge_image.h
```

With this package, other rust developers can easily use your plugin in their applications. They just need to include your header file in their code, and link against your rust library when they compile their application.

Now, when you're ready to publish your plugin and the corresponding SDK, can publish your plugin on the official WasmEdge [plugin repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins) by creating a pull request into it or any other repository of your choice. Make sure to include the documentation and any other resources (like test files) with your plugin.

## Contributing to the WasmEdge Community

As an open-source contributor, you can share your plugin with the community by submitting it to the official [WasmEdge repository](https://github.com/WasmEdge/WasmEdge). This allows others to benefit from your work.

By following these best practices, you can ensure a successful and efficient plugin development process for WasmEdge.
","**Summary**

The provided code is a Markdown document that outlines the best practices for developing WasmEdge plugins. It covers essential topics such as:

1. Using the latest version of WasmEdge
2. Choosing an appropriate programming language (C, C++, or Rust)
3. Writing and compiling the plugin
4. Testing the plugin
5. Securing the plugin
6. Publishing the plugin

The document provides detailed instructions on how to write a high-quality plugin, including:

* Writing clear, maintainable code
* Compiling to a shared library (e.g., using `gcc` or `g++`)
* Handling errors and input validation
* Running tests for the plugin (using `ctest`)
* Analyzing test results

**Key Components**

The document is divided into several sections:

1. **Using the Latest Version of WasmEdge**: This section emphasizes the importance of using the latest version of WasmEdge to take advantage of new features and security updates.
2. **Choosing an Appropriate Programming Language**: This section discusses the options for programming languages (C, C++, or Rust) and recommends C due to its simplicity and wide support.
3. **Writing and Compiling the Plugin**: This section provides instructions on writing clear, maintainable code and compiling it to a shared library using a compiler like `gcc` or `g++`.
4. **Testing the Plugin**: This section explains how to run tests for the plugin using `ctest` and analyze the results.
5. **Securing the Plugin**: This section highlights the importance of securing the plugin by validating inputs, handling errors properly, and following secure coding practices.

**Areas for Improvement**

While the document provides a comprehensive guide to developing WasmEdge plugins, there are areas that could be improved:

* Additional examples or code snippets would help illustrate key concepts and make the document more engaging.
* A more detailed discussion of the testing process and how to write effective tests would be beneficial.
* Consider adding a section on debugging and troubleshooting techniques for plugin development.

Overall, this document serves as an excellent resource for developers looking to create high-quality WasmEdge plugins."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/best_practice.md,"---
sidebar_position: 6
---

# Best Practice

When developing a WasmEdge plugin, it's important to follow best practices to ensure the plugin is well purformed, reliable, and efficient. Here are some key best practices to follow:

## Using the Latest Version of WasmEdge

Always use the latest version of WasmEdge to take advantage of the most recent features, improvements, and security updates.

### Installing the Latest Version

To install the latest version of WasmEdge, follow the installation instructions in the [WasmEdge documentation](https://wasmedge.org/docs/start/install/).

### Updating Existing Plugins

If you have existing plugins that were developed with an older version of WasmEdge, you may need to update them to work with the latest version. This could involve updating the plugin code to use new features or changes in the [WasmEdge API](https://wasmedge.org/docs/category/api-reference/), or updating the build process to use the latest version of WasmEdge.

Remember, using the latest version of WasmEdge not only ensures that you're leveraging the most recent features, but also provides the latest security updates to protect your applications.

## Choosing the Appropriate Programming Language

WasmEdge plugins can be developed in several languages including [C](develop_plugin_c.md), [C++](develop_plugin_cpp.md), and [Rust](develop_plugin_rustsdk.md). The choice of language depends on the specific requirements of the plugin and the developer's expertise. The C API is recommended for most use cases due to its simplicity and wide support. However, complex plugins might benefit from the enhanced features of C++ or Rust.

## Writing and Compiling the Plugin

When creating a WasmEdge plugin:

   1. **Code Writing**: While develop your plugin, write clear, maintainable code, and document it well for easy understanding and future maintenance.

   2. **Compiling to Shared Library**: Use a compiler like `gcc` for C or `g++` for C++ to compile your code into a shared library. For example, in a Linux environment, you might use `gcc -shared -fPIC -o my_plugin.so my_plugin.c` for a C plugin.

   3. **Error Handling and Input Validation**: Efficitive error handling to catch and manage potential issues. Validate all inputs thoroughly to ensure the plugin's stability and security.

## Testing the Plugin

Testing is a crucial part of the plugin development process. It ensures that the plugin behaves as expected, meets the requirements, and performs optimally. WasmEdge provides a set of tests for various plugins in its [repository](https://github.com/WasmEdge/WasmEdge/tree/master/test/plugins) that you can use as references for writing your own tests.

To run tests for the WasmEdge plugin, you'll need to follow a few steps. In this case, we'll use the `wasmedge-image` plugin as an example.

- **Step 1: Build the WasmEdge Runtime and WasmEdge-image Plugin**
   First, you need to build both the [build WasmEdge](../source/build_from_src.md) and the [wasmedge-image](../source/plugin/image.md) plugin.

- **Step 2: Run the Tests**
   The WasmEdge repository provides a set of tests for various plugins, including `wasmedge-image`. You can find the test cases in the `test/plugins/wasmedge_image` directory of the repository.

   To run these tests, you can use the `ctest` command from the build directory:

   ```bash
   cd ../../../test/plugins/wasmedge_image
   mkdir build && cd build
   cmake ..
   make
   ctest
   ```

   This will run all the unit tests and integration tests for the `wasmedge-image`plugin. These tests ensure that the plugin behaves as expected, meets the requirements, and performs optimally. They also verify that the plugin correctly integrates with the WebAssembly program and that the WebAssembly program can call the plugin's functions correctly.

- **Step 3: Analyze the Test Results**
   After running the tests, analyze the results to identify any issues or bugs. If any test fails, you should debug the issue, fix the problem, and then rerun the tests to ensure that the fix works as expected.

By following these steps, you can effectively run tests for the `wasmedge-image` plugin or any other WasmEdge plugin.

<!-- prettier-ignore -->
:::note
If you want to develop your own tests follow [Writing Tests for WasmEdge Plugins](test_plugin.md) for details.
:::

## Securing the Plugin

Security is a vital part of any software development process. It involves several aspects, including securing the code, verifying inputs, handling errors properly, and using secure coding practices. When developing a WasmEdge plugin, it's essential to follow these best practices:

- **Validate Inputs:** Always validate the inputs to your functions. This can prevent many types of attacks, including buffer overflow attacks and code injection attacks.

   ```c
   WasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,
                        const WasmEdge_Value *In, WasmEdge_Value *Out) {
      if (In[0].Type != WasmEdge_ValType_I32 || In[1].Type != WasmEdge_ValType_I32) {
      return WasmEdge_Result_Error;
      }
      // Rest of the function...
   }
   ```

- **Handle Errors:** Always handle errors properly. Don't ignore return values that indicate an error, and don't continue execution after an error occurs.

   ```c
   WasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,
                        const WasmEdge_Value *In, WasmEdge_Value *Out) {
      // Check the input types...
      int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
      int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
      if (Val1 == INT32_MIN || Val2 == INT32_MIN) {
      return WasmEdge_Result_Error;
      }
      // Rest of the function...
   }
   ```

- **Use Secure Coding Practices:** Follow secure coding practices in your chosen language. For example, avoid using unsafe functions, use strong types, and avoid using global variables.

## Publishing the Plugin

Once you have developed, tested, and documented your WasmEdge plugin, it’s time to publish it for others to use. You need to follow following steps for publishing your plugin:

## Exporting the SDKs in Rust

In addition to C and C++ SDKs, you can also create an SDK for Rust developers. This involves creating a Rust library that provides a Rust interface to your plugin's functionality.

### Creating a Rust Library

You can create a Rust library that provides a Rust interface to your plugin's functionality. This involves writing Rust code that calls the functions in your plugin and provides a Rust-friendly API.

In the [wasmedge-image](../source/plugin/image.md) plugin's case, you might have something like this:

```rust
// lib.rs
extern crate wasmedge_image;

use wasmedge_image::Image;

pub fn load_image(path: &str) -> Result<Image, wasmedge_image::Error> {
Image::open(path)
}
```

In this Rust library, a single `load_image` function is provided that calls the `open` function from the `wasmedge-image` plugin.

### Building the Rust Library

You can build your Rust library using Cargo, the Rust package manager. This will produce a `.so` file that can be loaded by the WasmEdge runtime.

```bash
cargo build --release
```

### Packaging the Rust SDK

Package the Rust library and the header file into a tarball or a similar package format. This makes it easy for other developers to download and install your SDK.

```bash
tar czvf wasmedge_image_rust_sdk.tar.gz libwasmedge_image.so wasmedge_image.h
```

With this package, other rust developers can easily use your plugin in their applications. They just need to include your header file in their code, and link against your rust library when they compile their application.

Now, when you're ready to publish your plugin and the corresponding SDK, can publish your plugin on the official WasmEdge [plugin repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins) by creating a pull request into it or any other repository of your choice. Make sure to include the documentation and any other resources (like test files) with your plugin.

## Contributing to the WasmEdge Community

As an open-source contributor, you can share your plugin with the community by submitting it to the official [WasmEdge repository](https://github.com/WasmEdge/WasmEdge). This allows others to benefit from your work.

By following these best practices, you can ensure a successful and efficient plugin development process for WasmEdge.
","**Summary**

This code is a documentation for best practices when developing WasmEdge plugins. It provides guidelines on how to ensure the plugin is well-performed, reliable, and efficient.

**Key Components**

1. **Using the Latest Version of WasmEdge**: The importance of using the latest version of WasmEdge to take advantage of recent features, improvements, and security updates.
2. **Choosing the Appropriate Programming Language**: Guidance on selecting the right programming language for plugin development (C, C++, or Rust).
3. **Writing and Compiling the Plugin**: Steps to write clear, maintainable code, compile it into a shared library, and perform error handling and input validation.
4. **Testing the Plugin**: Importance of testing, with instructions on how to run tests using `ctest` and analyze results.
5. **Securing the Plugin**: Best practices for securing the plugin, including validating inputs, handling errors properly, and following secure coding practices.

**Areas for Improvement**

1. The documentation could benefit from more concise language and clearer headings to improve readability.
2. Some sections feel repetitive or redundant; consider condensing similar information into a single section.
3. Adding more examples or code snippets to illustrate key concepts would enhance understanding and engagement.
4. Consider creating separate documents or chapters for advanced topics, such as performance optimization or debugging techniques.

**Code Snippets**

Several code snippets are provided throughout the document to demonstrate specific concepts, including:

1. **Error handling**: Demonstrating proper error handling in C code.
2. **Input validation**: Showing how to validate inputs in C code.
3. **Rust library creation**: Providing an example of creating a Rust library for WasmEdge plugins.

**Target Audience**

The primary audience appears to be developers interested in contributing to the WasmEdge community by developing plugins. The documentation assumes some familiarity with programming concepts and WasmEdge, but provides sufficient guidance for those new to plugin development."
docs/contribute/installer.md,"---
sidebar_position: 7
---

# Installer Guide

## Overview

WasmEdge installer is designed for installing the Core Tools (`wasmedge`, `wasmedge compile`), the Libraries (`libwasmedge`), the Extensions(`wasmedge-tensorflow`), and the Plugins(`wasi-nn`, `wasi-crytpo`).

## Dependencies

In the first version of the installer, WasmEdge provides a pure shell script implementation. However, it's not easy to maintain and unsuitable when we want to include the extensions and plugins matrix.

To reduce the maintenance cost and improve the development performance, we decided to move forward to a brand new installer written in python and compatible with both Python 2 and 3.

To be compatible with the old one, we use the same entry point, `install.sh`.

## Usage

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- ${OPTIONS}
```

## Roles

### `install.sh`

The installer entry point.

#### Process

1. Check if the `git` is installed; otherwise, exit with an error `Please install git`.
2. If `PYTHON_EXECUTABLE` is given, try to use `$PYTHON_EXECUTABLE` to execute the `install.py`. Otherwise, go to step 3.
3. If `PYTHON_EXECUTABLE` is not set, `which` command is needed to determine the python-X executable. If it is not found installer exits else, it moves on to the next step.
4. Check if the `python3` is installed. If so, go to step 6. Otherwise, go to step 5.
5. Check if the `python2` is installed. If so, go to step 6. Otherwise, go to step 6.
6. Check if the `python` is installed. If so, go to step 7. Otherwise, exit with an error `Please install python or provide python path via $PYTHON_EXECUTABLE`.
7. Print the detected python version `Using Python: $PYTHON_EXECUTABLE`.
8. Download `install.py` with `curl` or `wget`. If the URL of `install.py` is unreachable due to a network issue, exit with an error `$INSTALL_PY_URL not reachable`. If the `curl` and `wget` are unavailable, exit with an error `curl or wget could not be found`.
9. Execute the `install.py` with all received arguments.

### `install.py`

The actual installer handles all stuff. It supports python2.7 (not tested on earlier versions) and the latest python versions python3.x.

## Options

### Help Msg

- Short Option: `-h`
- Full Option: `--help`
- Description: Show this help message and exit.

### Verbose

- Short Option: `-D`
- Full Option: `--debug`
- Description: Enable verbosity debug

### Specify the version of WasmEdge to install

- Short Option: `-v VERSION`
- Full Option: `--version VERSION`
- Description: Install the given VERSION of WasmEdge
- Available Value: VERSION `{{ wasmedge_version }}` or other valid release versions.
- Note - If supplied an invalid or nonexistent version, the installer exists with an error.

### Installation path

- Short Option: `-p PATH`
- Full Option: `--path PATH`
- Description: Install WasmEdge into the given PATH. The default Path is `$HOME/.wasmedge`.
- Note - Any paths other than the ones starting with `/usr` are treated as non-system paths in the internals of the installer. The consequences are different directory structures for both.
- Note - If the path not exists, the folder will be created.

### Uninstallation

#### Run uninstaller before installing

- Short Option: `-r {yes,no}`
- Full Option: `--remove-old {yes, no}`
- Description: Run the uninstaller script before installing. Default `yes`.

#### Use a specific version of the uninstaller

- Short Option: `-u UNINSTALL_SCRIPT_TAG`
- Full Option: `--uninstall-script-tag UNINSTALL_SCRIPT_TAG`
- Description: Use the given GitHub tag to uninstall the script

### Install Extensions

- Short Option: `-e [EXTENSIONS [EXTENSIONS ...]]`
- Full Option: `--extension [EXTENSIONS [EXTENSIONS ...]]`
- Description: Install wasmedge-extension tools.
- Available Value (case sensitive): Supported Extensions `'tensorflow', 'image', 'all'`.

#### Tensorflow Extensions Library Version

- Full Option: `--tf-version TF_VERSION`
- Description: Install the given VERSION of the library of the Tensorflow and Tensorflow lite extension. Only available when the `Extensions` is set to `all` or `tensorflow`.
- Note - It's the same as the WasmEdge version if not specified.

#### Tensorflow Extensions Dependencies Version

- Full Option: `--tf-deps-version TF_DEPS_VERSION`
- Description: Install the given VERSION of the dependencies of the Tensorflow and Tensorflow lite extension. Only available when the `Extensions` is set to `all` or `tensorflow`.
- Note - It's the same as the WasmEdge version if not specified.

#### Tensorflow Extensions Tools Version

- Full Option: `--tf-tools-version TF_TOOLS_VERSION`
- Description: Install the given VERSION of the tools of the Tensorflow and Tensorflow lite extension. Only available when the `Extensions` is set to `all` or `tensorflow`.
- Note - It's the same as the WasmEdge version if not specified.

#### Image Extensions Version

- Full Option: `--image-version IMAGE_VERSION`
- Description: Install the given VERSION of the Image extension. Only available when the `Extensions` is set to `all` or `image`.
- Note - It's the same as the WasmEdge version if not specified.

### Plugins

- Note - Currently, `--plugins` is an experimental option.

- Full Option: `--plugins wasi_crypto:0.12.0`

- Note - The format for this argument is `<plugin_name>:<version_number>`. `<version_number>` is not compulsory. For example, `--plugins wasi_crypto` is a valid option.
- Note - `<plugin_name>` is cases sensitive. Allowed values are stated [here](plugin/intro.md) in the `Rust Crate` column. The logic is that the release name should be the same.
- Note - It's the same as the WasmEdge version if not specified.

### DIST

- Full Option: `--dist ubuntu20.04` or `--dist manylinux2014`
- Note - the `ubuntu20.04` and `manylinux2014` values are case insensitive and only these two are currently supported.
- Note - Specifying `--dist` value for `Darwin` has no effect.
- Note - For `Linux` platform if the distribution matches exactly as `Ubuntu 20.04`, which is checked using `lsb_release` and python's `platform.dist()` functionality is then set to `ubuntu20.04` if not specified, or it is used without questioning. However different release packages for WasmEdge are available only after `0.11.1` release, below which there is no effect of specifying this option.

### Platform and OS

- Full Option: `--platform PLATFORM` or `--os OS`
- Description: Install the given `PLATFORM` or `OS` version of WasmEdge. This value should be case insensitive to make the maximum compatibility.
- Available Value (case insensitive): ""Linux"", ""Darwin"", ""Windows"".

### Machine and Arch

- Full Option: `--machine MACHINE` or `--arch ARCH`
- Description: Install the `MACHINE` or `ARCH` version of WasmEdge.
- Available Value: ""x86_64"", ""aarch64"".

## Behavior

- If an installation exists at `$HOME/.wasmedge`, to be noted as the default installation path, it is removed with or without the uninstaller's invocation.
- WasmEdge installation appends all the files it installs to a file which is located in the installer directory named `env` with its path as `$INSTALLATION_PATH/env`.

### Shell and it's configuration

- Source string in shell configuration is given as `. $INSTALLATION_PATH/env` so that it exports the necessary environment variables for WasmEdge.
- Shell configuration file is appended with source string if it cannot find the source string in that file.
- Currently, it detects only `Bash` and `zsh` shells.
- If the above shells are found, then their respective configuration files `$HOME/.bashrc` and `$HOME/.zshrc` are updated along with `$HOME/.zprofile` and `$HOME/.bash_profile` in the case of Linux.
- In the case of `Darwin`, only `$HOME/.zprofile` is updated with the source string.
","**Summary**

The code is a Python-based installer for the WasmEdge project, which allows users to install and manage Core Tools, Libraries, Extensions, and Plugins. The installer supports various options for customization, including specifying the version of WasmEdge to install, installation path, uninstallation, extensions, plugins, and platform-specific configurations.

**Key Components**

1. **`install.sh`**: The entry point of the installer, which checks for the presence of Git, Python, and other dependencies.
2. **`install.py`**: The actual installer script that handles all the installation logic.
3. **Options**: The installer supports various options, including help messages, verbose mode, version specification, installation path, uninstallation, extensions, plugins, platform-specific configurations, and more.

**Potential Issues or Areas for Improvement**

1. **Complexity**: The installer has a lot of logic and options, which can make it difficult to maintain and debug.
2. **Error Handling**: The installer may not handle errors robustly, leading to unexpected behavior or crashes.
3. **Platform-Specific Code**: Some code is platform-specific (e.g., macOS, Linux), which may require additional maintenance efforts when updating the installer.
4. **Dependency Management**: The installer depends on external libraries and tools, such as Git and Python, which can be a potential point of failure.

**Suggestions for Improvement**

1. **Simplify the Installer Logic**: Consider breaking down the installer into smaller, more manageable modules or functions to reduce complexity.
2. **Improve Error Handling**: Enhance error handling mechanisms to provide more informative messages and robust recovery strategies.
3. **Refactor Platform-Specific Code**: Extract platform-specific code into separate files or modules to make it easier to maintain and update.
4. **Dependency Management**: Consider using a dependency management tool, such as pip or conda, to manage external dependencies and ensure they are up-to-date."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/installer.md,"---
sidebar_position: 7
---

# Installer Guide

## Overview

WasmEdge installer is designed for installing the Core Tools (`wasmedge`, `wasmedge compile`), the Libraries (`libwasmedge`), the Extensions(`wasmedge-tensorflow`), and the Plugins(`wasi-nn`, `wasi-crytpo`).

## Dependencies

In the first version of the installer, WasmEdge provides a pure shell script implementation. However, it's not easy to maintain and unsuitable when we want to include the extensions and plugins matrix.

To reduce the maintenance cost and improve the development performance, we decided to move forward to a brand new installer written in python and compatible with both Python 2 and 3.

To be compatible with the old one, we use the same entry point, `install.sh`.

## Usage

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- ${OPTIONS}
```

## Roles

### `install.sh`

The installer entry point.

#### Process

1. Check if the `git` is installed; otherwise, exit with an error `Please install git`.
2. If `PYTHON_EXECUTABLE` is given, try to use `$PYTHON_EXECUTABLE` to execute the `install.py`. Otherwise, go to step 3.
3. If `PYTHON_EXECUTABLE` is not set, `which` command is needed to determine the python-X executable. If it is not found installer exits else, it moves on to the next step.
4. Check if the `python3` is installed. If so, go to step 6. Otherwise, go to step 5.
5. Check if the `python2` is installed. If so, go to step 6. Otherwise, go to step 6.
6. Check if the `python` is installed. If so, go to step 7. Otherwise, exit with an error `Please install python or provide python path via $PYTHON_EXECUTABLE`.
7. Print the detected python version `Using Python: $PYTHON_EXECUTABLE`.
8. Download `install.py` with `curl` or `wget`. If the URL of `install.py` is unreachable due to a network issue, exit with an error `$INSTALL_PY_URL not reachable`. If the `curl` and `wget` are unavailable, exit with an error `curl or wget could not be found`.
9. Execute the `install.py` with all received arguments.

### `install.py`

The actual installer handles all stuff. It supports python2.7 (not tested on earlier versions) and the latest python versions python3.x.

## Options

### Help Msg

- Short Option: `-h`
- Full Option: `--help`
- Description: Show this help message and exit.

### Verbose

- Short Option: `-D`
- Full Option: `--debug`
- Description: Enable verbosity debug

### Specify the version of WasmEdge to install

- Short Option: `-v VERSION`
- Full Option: `--version VERSION`
- Description: Install the given VERSION of WasmEdge
- Available Value: VERSION `{{ wasmedge_version }}` or other valid release versions.
- Note - If supplied an invalid or nonexistent version, the installer exists with an error.

### Installation path

- Short Option: `-p PATH`
- Full Option: `--path PATH`
- Description: Install WasmEdge into the given PATH. The default Path is `$HOME/.wasmedge`.
- Note - Any paths other than the ones starting with `/usr` are treated as non-system paths in the internals of the installer. The consequences are different directory structures for both.
- Note - If the path not exists, the folder will be created.

### Uninstallation

#### Run uninstaller before installing

- Short Option: `-r {yes,no}`
- Full Option: `--remove-old {yes, no}`
- Description: Run the uninstaller script before installing. Default `yes`.

#### Use a specific version of the uninstaller

- Short Option: `-u UNINSTALL_SCRIPT_TAG`
- Full Option: `--uninstall-script-tag UNINSTALL_SCRIPT_TAG`
- Description: Use the given GitHub tag to uninstall the script

### Install Extensions

- Short Option: `-e [EXTENSIONS [EXTENSIONS ...]]`
- Full Option: `--extension [EXTENSIONS [EXTENSIONS ...]]`
- Description: Install wasmedge-extension tools.
- Available Value (case sensitive): Supported Extensions `'tensorflow', 'image', 'all'`.

#### Tensorflow Extensions Library Version

- Full Option: `--tf-version TF_VERSION`
- Description: Install the given VERSION of the library of the Tensorflow and Tensorflow lite extension. Only available when the `Extensions` is set to `all` or `tensorflow`.
- Note - It's the same as the WasmEdge version if not specified.

#### Tensorflow Extensions Dependencies Version

- Full Option: `--tf-deps-version TF_DEPS_VERSION`
- Description: Install the given VERSION of the dependencies of the Tensorflow and Tensorflow lite extension. Only available when the `Extensions` is set to `all` or `tensorflow`.
- Note - It's the same as the WasmEdge version if not specified.

#### Tensorflow Extensions Tools Version

- Full Option: `--tf-tools-version TF_TOOLS_VERSION`
- Description: Install the given VERSION of the tools of the Tensorflow and Tensorflow lite extension. Only available when the `Extensions` is set to `all` or `tensorflow`.
- Note - It's the same as the WasmEdge version if not specified.

#### Image Extensions Version

- Full Option: `--image-version IMAGE_VERSION`
- Description: Install the given VERSION of the Image extension. Only available when the `Extensions` is set to `all` or `image`.
- Note - It's the same as the WasmEdge version if not specified.

### Plugins

- Note - Currently, `--plugins` is an experimental option.

- Full Option: `--plugins wasi_crypto:0.12.0`

- Note - The format for this argument is `<plugin_name>:<version_number>`. `<version_number>` is not compulsory. For example, `--plugins wasi_crypto` is a valid option.
- Note - `<plugin_name>` is cases sensitive. Allowed values are stated [here](plugin/intro.md) in the `Rust Crate` column. The logic is that the release name should be the same.
- Note - It's the same as the WasmEdge version if not specified.

### DIST

- Full Option: `--dist ubuntu20.04` or `--dist manylinux2014`
- Note - the `ubuntu20.04` and `manylinux2014` values are case insensitive and only these two are currently supported.
- Note - Specifying `--dist` value for `Darwin` has no effect.
- Note - For `Linux` platform if the distribution matches exactly as `Ubuntu 20.04`, which is checked using `lsb_release` and python's `platform.dist()` functionality is then set to `ubuntu20.04` if not specified, or it is used without questioning. However different release packages for WasmEdge are available only after `0.11.1` release, below which there is no effect of specifying this option.

### Platform and OS

- Full Option: `--platform PLATFORM` or `--os OS`
- Description: Install the given `PLATFORM` or `OS` version of WasmEdge. This value should be case insensitive to make the maximum compatibility.
- Available Value (case insensitive): ""Linux"", ""Darwin"", ""Windows"".

### Machine and Arch

- Full Option: `--machine MACHINE` or `--arch ARCH`
- Description: Install the `MACHINE` or `ARCH` version of WasmEdge.
- Available Value: ""x86_64"", ""aarch64"".

## Behavior

- If an installation exists at `$HOME/.wasmedge`, to be noted as the default installation path, it is removed with or without the uninstaller's invocation.
- WasmEdge installation appends all the files it installs to a file which is located in the installer directory named `env` with its path as `$INSTALLATION_PATH/env`.

### Shell and it's configuration

- Source string in shell configuration is given as `. $INSTALLATION_PATH/env` so that it exports the necessary environment variables for WasmEdge.
- Shell configuration file is appended with source string if it cannot find the source string in that file.
- Currently, it detects only `Bash` and `zsh` shells.
- If the above shells are found, then their respective configuration files `$HOME/.bashrc` and `$HOME/.zshrc` are updated along with `$HOME/.zprofile` and `$HOME/.bash_profile` in the case of Linux.
- In the case of `Darwin`, only `$HOME/.zprofile` is updated with the source string.
","**Summary:**

This is a Python script (`install.py`) that acts as an installer for the WasmEdge project. The script supports both Python 2 and 3, and it uses a shell script (`install.sh`) as its entry point. The `install.sh` script checks if Python is installed on the system, downloads the `install.py` script using `curl` or `wget`, and then executes it with all received arguments.

**Key Components:**

1. **Entry Point:** `install.sh`: This shell script acts as the entry point of the installer.
2. **Python Script:** `install.py`: This is the actual Python script that performs the installation tasks.
3. **Arguments:** The script accepts various options, including:
	* `-h` or `--help`: Displays help message and exits.
	* `-D` or `--debug`: Enables verbosity debug.
	* `-v VERSION` or `--version VERSION`: Specifies the version of WasmEdge to install.
	* `-p PATH` or `--path PATH`: Specifies the installation path.
	* `-e [EXTENSIONS]`: Installs wasmedge-extension tools (tensorflow, image, etc.).
	* `-u UNINSTALL_SCRIPT_TAG`: Uses a specific version of the uninstaller.
	* `--plugins`: Currently an experimental option (e.g., `--plugins wasi_crypto:0.12.0`).

**Behavior:**

1. **Uninstallation:** The script removes any existing WasmEdge installation at `$HOME/.wasmedge`.
2. **Environment Variables:** The installer appends all installed files to a file in the installer directory named `env`, which is sourced in shell configuration files (e.g., `.bashrc` and `.zshrc`).
3. **Shell Detection:** The script detects only Bash and zsh shells.
4. **OS Detection:** The script uses `lsb_release` and Python's `platform.dist()` functionality to detect the OS.

**Potential Issues/Improvement Areas:**

1. **Error Handling:** The script could improve its error handling by providing more informative error messages and handling potential exceptions.
2. **Code Organization:** The script could benefit from a cleaner code organization, with separate modules or functions for different tasks (e.g., installation, uninstallation, plugin management).
3. **Shell Support:** The script only supports Bash and zsh shells; it would be beneficial to add support for other shells as well.
4. **OS Detection:** While the script uses `lsb_release` and Python's `platform.dist()` functionality, it might still have issues with some Linux distributions or versions.

Overall, the script is relatively complex due to its extensive feature set and the need to handle various options and edge cases."
docs/develop/javascript/rust.md,"---
sidebar_position: 9
---

# Native JS API in Rust

For JavaScript developers, incorporating Rust functions into JavaScript APIs is useful. That enables developers to write programs in ""pure JavaScript"" yet still use the high-performance Rust functions. You can do precisely that with the [WasmEdge Runtime](https://github.com/WasmEdge/WasmEdge).

<!-- prettier-ignore -->
:::note
The [internal_module](https://github.com/second-state/wasmedge-quickjs/tree/main/src/internal_module) folder in the official WasmEdge QuickJS distribution provides Rust-based implementations of some built-in JavaScript API functions. Those functions typically require interactions with host functions in the WasmEdge runtime (e.g., networking and TensorFlow), and hence cannot be accessed by pure JavaScript implementations in [modules](modules.md).
:::

## Prerequisites

- [Install the Rust toolchain](../rust/setup.md)
- [Install WasmEdge QuickJS and get ready](hello_world.md#prerequisites)

## Run the examples

The examples are in the `examples/embed_js` folder in the `wasmedge-quickjs` repo. You can build and run all the examples as follows.

```bash
cd examples/embed_js
cargo build --target wasm32-wasi --release
wasmedge --dir .:. target/wasm32-wasi/release/embed_js.wasm
```

## Code explanation: embed JavaScript into a Rust program

The following Rust snippet evaluates the JavaScript code in the `code` variable.

```rust
fn js_hello(ctx: &mut Context) {
    println!(""\n<----run_simple_js---->"");
    let code = r#""print('hello quickjs')""#;
    let r = ctx.eval_global_str(code);
    println!(""return value:{:?}"", r);
}

... ...

fn main() {
    let mut ctx = Context::new();
    js_hello(&mut ctx);
    ... ...
}
```

## Code explanation: create a JavaScript function API

The following code snippet defines a Rust function that can be incorporated into the JavaScript interpreter as an API.

```rust
fn run_rust_function(ctx: &mut Context) {

  struct HelloFn;
  impl JsFn for HelloFn {
    fn call(_ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {
      println!(""hello from rust"");
      println!(""argv={:?}"", argv);
      JsValue::UnDefined
    }
  }

  ...
}
```

The following code snippet shows how to add this Rust function into the JavaScript interpreter, give the name `hi()` as its JavaScript API, and then call it from JavaScript code.

```rust
fn run_rust_function(ctx: &mut Context) {
  ...

  let f = ctx.new_function::<HelloFn>(""hello"");
  ctx.get_global().set(""hi"", f.into());
  let code = r#""hi(1,2,3)""#;
  let r = ctx.eval_global_str(code);
  println!(""return value:{:?}"", r);
}

... ...

fn main() {
    let mut ctx = Context::new();
    run_rust_function(&mut ctx);
    ... ...
}
```

The execution result is as follows.

```bash
hello from rust
argv=[Int(1), Int(2), Int(3)]
return value:UnDefined
```

You can create a JavaScript interpreter with customized API functions using this approach. The interpreter runs inside WasmEdge, and can execute JavaScript code, which calls such API functions from CLI or the network.

## Code explanation: create a JavaScript object API

In the JavaScript API design, we sometimes need to provide an object that encapsulates data and function. The following example defines a Rust function for the JavaScript API.

```rust
fn rust_new_object_and_js_call(ctx: &mut Context) {
  struct ObjectFn;
  impl JsFn for ObjectFn {
    fn call(_ctx: &mut Context, this_val: JsValue, argv: &[JsValue]) -> JsValue {
      println!(""hello from rust"");
      println!(""argv={:?}"", argv);
      if let JsValue::Object(obj) = this_val {
        let obj_map = obj.to_map();
        println!(""this={:#?}"", obj_map);
      }
      JsValue::UnDefined
    }
  }

  ...
}
```

We then create an ""object"" on the Rust side, set its data fields, and then register the Rust function as a JavaScript function associated with the objects.

```rust
let mut obj = ctx.new_object();
obj.set(""a"", 1.into());
obj.set(""b"", ctx.new_string(""abc"").into());

let f = ctx.new_function::<ObjectFn>(""anything"");
obj.set(""f"", f.into());
```

Next, we make the Rust ""object"" available as a JavaScript object `test_obj` in the JavaScript interpreter.

```rust
ctx.get_global().set(""test_obj"", obj.into());
```

You can now directly use `test_obj` in the JavaScript code as part of the API.

```rust
let code = r#""
  print('test_obj keys=',Object.keys(test_obj))
  print('test_obj.a=',test_obj.a)
  print('test_obj.b=',test_obj.b)
  test_obj.f(1,2,3,""hi"")
""#;

ctx.eval_global_str(code);
```

The execution result is as follows.

```bash
test_obj keys= a,b,f
test_obj.a= 1
test_obj.b= abc
hello from rust
argv=[Int(1), Int(2), Int(3), String(JsString(hi))]
this=Ok(
  {
    ""a"": Int(
      1,
    ),
    ""b"": String(
      JsString(
        abc,
      ),
    ),
    ""f"": Function(
      JsFunction(
        function anything() {
          [native code]
        },
      ),
    ),
  },
)
```

## A complete JavaScript object API

In the previous example, we demonstrated simple examples to create JavaScript APIs from Rust. In this example, we will create a complete Rust module and make it available as a JavaScript object API.

### Run the example

The project is in the [examples/embed_rust_module](https://github.com/second-state/wasmedge-quickjs/tree/main/examples/embed_rust_module) folder. You can build and run it as a standard Rust application in WasmEdge.

```bash
cd examples/embed_rust_module
cargo build --target wasm32-wasi --release
wasmedge --dir .:. target/wasm32-wasi/release/embed_rust_module.wasm
```

### Code explanation

The Rust implementation of the object is a module as follows. It has data fields, constructor, getters and setters, and functions.

```rust
mod point {
  use wasmedge_quickjs::*;

  #[derive(Debug)]
  struct Point(i32, i32);

  struct PointDef;

  impl JsClassDef<Point> for PointDef {
    const CLASS_NAME: &'static str = ""Point\0"";
    const CONSTRUCTOR_ARGC: u8 = 2;

    fn constructor(_: &mut Context, argv: &[JsValue]) -> Option<Point> {
      println!(""rust-> new Point {:?}"", argv);
      let x = argv.get(0);
      let y = argv.get(1);
      if let ((Some(JsValue::Int(ref x)), Some(JsValue::Int(ref y)))) = (x, y) {
        Some(Point(*x, *y))
      } else {
        None
      }
    }

    fn proto_init(p: &mut JsClassProto<Point, PointDef>) {
      struct X;
      impl JsClassGetterSetter<Point> for X {
        const NAME: &'static str = ""x\0"";

        fn getter(_: &mut Context, this_val: &mut Point) -> JsValue {
          println!(""rust-> get x"");
          this_val.0.into()
        }

        fn setter(_: &mut Context, this_val: &mut Point, val: JsValue) {
          println!(""rust-> set x:{:?}"", val);
          if let JsValue::Int(x) = val {
            this_val.0 = x
          }
        }
      }

      struct Y;
      impl JsClassGetterSetter<Point> for Y {
        const NAME: &'static str = ""y\0"";

        fn getter(_: &mut Context, this_val: &mut Point) -> JsValue {
          println!(""rust-> get y"");
          this_val.1.into()
        }

        fn setter(_: &mut Context, this_val: &mut Point, val: JsValue) {
          println!(""rust-> set y:{:?}"", val);
          if let JsValue::Int(y) = val {
            this_val.1 = y
          }
        }
      }

      struct FnPrint;
      impl JsMethod<Point> for FnPrint {
        const NAME: &'static str = ""pprint\0"";
        const LEN: u8 = 0;

        fn call(_: &mut Context, this_val: &mut Point, _argv: &[JsValue]) -> JsValue {
          println!(""rust-> pprint: {:?}"", this_val);
          JsValue::Int(1)
        }
      }

      p.add_getter_setter(X);
      p.add_getter_setter(Y);
      p.add_function(FnPrint);
    }
  }

  struct PointModule;
  impl ModuleInit for PointModule {
    fn init_module(ctx: &mut Context, m: &mut JsModuleDef) {
      m.add_export(""Point\0"", PointDef::class_value(ctx));
    }
  }

  pub fn init_point_module(ctx: &mut Context) {
    ctx.register_class(PointDef);
    ctx.register_module(""point\0"", PointModule, &[""Point\0""]);
  }
}
```

In the interpreter implementation, we call `point::init_point_module` first to register the Rust module with the JavaScript context, and then we can run a JavaScript program that uses the `point` object.

```rust
use wasmedge_quickjs::*;
fn main() {
  let mut ctx = Context::new();
  point::init_point_module(&mut ctx);

  let code = r#""
    import('point').then((point)=>{
    let p0 = new point.Point(1,2)
    print(""js->"",p0.x,p0.y)
    p0.pprint()
    try{
      let p = new point.Point()
      print(""js-> p:"",p)
      print(""js->"",p.x,p.y)
      p.x=2
      p.pprint()
    } catch(e) {
      print(""An error has been caught"");
      print(e)
    }
    })
  ""#;

  ctx.eval_global_str(code);
  ctx.promise_loop_poll();
}
```

The execution result from the above application is as follows.

```bash
rust-> new Point [Int(1), Int(2)]
rust-> get x
rust-> get y
js-> 1 2
rust-> pprint: Point(1, 2)
rust-> new Point []
js-> p: undefined
An error has been caught
TypeError: cannot read property 'x' of undefined
```

## Code reuse

We could create JavaScript classes that inherit (or extend) existing classes using the Rust API. That allows developers to develop complex JavaScript APIs by building on existing solutions using Rust. You can see [an example here](https://github.com/second-state/wasmedge-quickjs/blob/main/examples/js_extend.rs).

Next, you can see the Rust code in the [internal_module](https://github.com/second-state/wasmedge-quickjs/tree/main/src/internal_module) folder for more examples of how to implement common JavaScript built-in functions, including [Node.js](nodejs.md) APIs.
","Here's a concise and coherent summary of the code:

**Purpose:**

The code is an example of creating JavaScript APIs using Rust. It demonstrates how to write Rust functions that can be incorporated into a JavaScript interpreter, allowing developers to create complex JavaScript APIs by building on existing solutions using Rust.

**Key Components:**

1. **Rust Functions:** The code defines several Rust functions that can be called from JavaScript, including:
	* `js_hello`: Evaluates JavaScript code in the `code` variable.
	* `run_rust_function`: Defines a Rust function that can be incorporated into the JavaScript interpreter as an API.
2. **JavaScript Object API:** The code demonstrates how to create a JavaScript object API using Rust, including:
	* Creating a Rust object with data fields, constructor, getters and setters, and functions.
	* Making the Rust object available as a JavaScript object in the interpreter.
3. **Complete JavaScript Object API:** The code provides an example of creating a complete Rust module that can be used to create a JavaScript object API, including:
	* Defining a Rust module with multiple classes, constructors, getters and setters, and functions.
	* Registering the Rust module with the JavaScript context.

**Potential Issues or Areas for Improvement:**

1. **Error Handling:** The code does not handle errors well, which can lead to crashes or unexpected behavior in the interpreter.
2. **Performance:** The code uses a lot of JavaScript objects and functions, which can impact performance if not optimized properly.
3. **Code Reuse:** While the code demonstrates code reuse by building on existing solutions using Rust, it could be improved by providing more examples of how to create reusable JavaScript classes.

Overall, the code is an excellent example of creating complex JavaScript APIs using Rust, and with some improvements in error handling, performance, and code reuse, it can become a valuable resource for developers."
i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/rust.md,"---
sidebar_position: 9
---

# Native JS API in Rust

For JavaScript developers, incorporating Rust functions into JavaScript APIs is useful. That enables developers to write programs in ""pure JavaScript"" yet still use the high-performance Rust functions. You can do precisely that with the [WasmEdge Runtime](https://github.com/WasmEdge/WasmEdge).

<!-- prettier-ignore -->
:::note
The [internal_module](https://github.com/second-state/wasmedge-quickjs/tree/main/src/internal_module) folder in the official WasmEdge QuickJS distribution provides Rust-based implementations of some built-in JavaScript API functions. Those functions typically require interactions with host functions in the WasmEdge runtime (e.g., networking and TensorFlow), and hence cannot be accessed by pure JavaScript implementations in [modules](modules.md).
:::

## Prerequisites

- [Install the Rust toolchain](../rust/setup.md)
- [Install WasmEdge QuickJS and get ready](hello_world.md#prerequisites)

## Run the examples

The examples are in the `examples/embed_js` folder in the `wasmedge-quickjs` repo. You can build and run all the examples as follows.

```bash
cd examples/embed_js
cargo build --target wasm32-wasi --release
wasmedge --dir .:. target/wasm32-wasi/release/embed_js.wasm
```

## Code explanation: embed JavaScript into a Rust program

The following Rust snippet evaluates the JavaScript code in the `code` variable.

```rust
fn js_hello(ctx: &mut Context) {
    println!(""\n<----run_simple_js---->"");
    let code = r#""print('hello quickjs')""#;
    let r = ctx.eval_global_str(code);
    println!(""return value:{:?}"", r);
}

... ...

fn main() {
    let mut ctx = Context::new();
    js_hello(&mut ctx);
    ... ...
}
```

## Code explanation: create a JavaScript function API

The following code snippet defines a Rust function that can be incorporated into the JavaScript interpreter as an API.

```rust
fn run_rust_function(ctx: &mut Context) {

  struct HelloFn;
  impl JsFn for HelloFn {
    fn call(_ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {
      println!(""hello from rust"");
      println!(""argv={:?}"", argv);
      JsValue::UnDefined
    }
  }

  ...
}
```

The following code snippet shows how to add this Rust function into the JavaScript interpreter, give the name `hi()` as its JavaScript API, and then call it from JavaScript code.

```rust
fn run_rust_function(ctx: &mut Context) {
  ...

  let f = ctx.new_function::<HelloFn>(""hello"");
  ctx.get_global().set(""hi"", f.into());
  let code = r#""hi(1,2,3)""#;
  let r = ctx.eval_global_str(code);
  println!(""return value:{:?}"", r);
}

... ...

fn main() {
    let mut ctx = Context::new();
    run_rust_function(&mut ctx);
    ... ...
}
```

The execution result is as follows.

```bash
hello from rust
argv=[Int(1), Int(2), Int(3)]
return value:UnDefined
```

You can create a JavaScript interpreter with customized API functions using this approach. The interpreter runs inside WasmEdge, and can execute JavaScript code, which calls such API functions from CLI or the network.

## Code explanation: create a JavaScript object API

In the JavaScript API design, we sometimes need to provide an object that encapsulates data and function. The following example defines a Rust function for the JavaScript API.

```rust
fn rust_new_object_and_js_call(ctx: &mut Context) {
  struct ObjectFn;
  impl JsFn for ObjectFn {
    fn call(_ctx: &mut Context, this_val: JsValue, argv: &[JsValue]) -> JsValue {
      println!(""hello from rust"");
      println!(""argv={:?}"", argv);
      if let JsValue::Object(obj) = this_val {
        let obj_map = obj.to_map();
        println!(""this={:#?}"", obj_map);
      }
      JsValue::UnDefined
    }
  }

  ...
}
```

We then create an ""object"" on the Rust side, set its data fields, and then register the Rust function as a JavaScript function associated with the objects.

```rust
let mut obj = ctx.new_object();
obj.set(""a"", 1.into());
obj.set(""b"", ctx.new_string(""abc"").into());

let f = ctx.new_function::<ObjectFn>(""anything"");
obj.set(""f"", f.into());
```

Next, we make the Rust ""object"" available as a JavaScript object `test_obj` in the JavaScript interpreter.

```rust
ctx.get_global().set(""test_obj"", obj.into());
```

You can now directly use `test_obj` in the JavaScript code as part of the API.

```rust
let code = r#""
  print('test_obj keys=',Object.keys(test_obj))
  print('test_obj.a=',test_obj.a)
  print('test_obj.b=',test_obj.b)
  test_obj.f(1,2,3,""hi"")
""#;

ctx.eval_global_str(code);
```

The execution result is as follows.

```bash
test_obj keys= a,b,f
test_obj.a= 1
test_obj.b= abc
hello from rust
argv=[Int(1), Int(2), Int(3), String(JsString(hi))]
this=Ok(
  {
    ""a"": Int(
      1,
    ),
    ""b"": String(
      JsString(
        abc,
      ),
    ),
    ""f"": Function(
      JsFunction(
        function anything() {
          [native code]
        },
      ),
    ),
  },
)
```

## A complete JavaScript object API

In the previous example, we demonstrated simple examples to create JavaScript APIs from Rust. In this example, we will create a complete Rust module and make it available as a JavaScript object API.

### Run the example

The project is in the [examples/embed_rust_module](https://github.com/second-state/wasmedge-quickjs/tree/main/examples/embed_rust_module) folder. You can build and run it as a standard Rust application in WasmEdge.

```bash
cd examples/embed_rust_module
cargo build --target wasm32-wasi --release
wasmedge --dir .:. target/wasm32-wasi/release/embed_rust_module.wasm
```

### Code explanation

The Rust implementation of the object is a module as follows. It has data fields, constructor, getters and setters, and functions.

```rust
mod point {
  use wasmedge_quickjs::*;

  #[derive(Debug)]
  struct Point(i32, i32);

  struct PointDef;

  impl JsClassDef<Point> for PointDef {
    const CLASS_NAME: &'static str = ""Point\0"";
    const CONSTRUCTOR_ARGC: u8 = 2;

    fn constructor(_: &mut Context, argv: &[JsValue]) -> Option<Point> {
      println!(""rust-> new Point {:?}"", argv);
      let x = argv.get(0);
      let y = argv.get(1);
      if let ((Some(JsValue::Int(ref x)), Some(JsValue::Int(ref y)))) = (x, y) {
        Some(Point(*x, *y))
      } else {
        None
      }
    }

    fn proto_init(p: &mut JsClassProto<Point, PointDef>) {
      struct X;
      impl JsClassGetterSetter<Point> for X {
        const NAME: &'static str = ""x\0"";

        fn getter(_: &mut Context, this_val: &mut Point) -> JsValue {
          println!(""rust-> get x"");
          this_val.0.into()
        }

        fn setter(_: &mut Context, this_val: &mut Point, val: JsValue) {
          println!(""rust-> set x:{:?}"", val);
          if let JsValue::Int(x) = val {
            this_val.0 = x
          }
        }
      }

      struct Y;
      impl JsClassGetterSetter<Point> for Y {
        const NAME: &'static str = ""y\0"";

        fn getter(_: &mut Context, this_val: &mut Point) -> JsValue {
          println!(""rust-> get y"");
          this_val.1.into()
        }

        fn setter(_: &mut Context, this_val: &mut Point, val: JsValue) {
          println!(""rust-> set y:{:?}"", val);
          if let JsValue::Int(y) = val {
            this_val.1 = y
          }
        }
      }

      struct FnPrint;
      impl JsMethod<Point> for FnPrint {
        const NAME: &'static str = ""pprint\0"";
        const LEN: u8 = 0;

        fn call(_: &mut Context, this_val: &mut Point, _argv: &[JsValue]) -> JsValue {
          println!(""rust-> pprint: {:?}"", this_val);
          JsValue::Int(1)
        }
      }

      p.add_getter_setter(X);
      p.add_getter_setter(Y);
      p.add_function(FnPrint);
    }
  }

  struct PointModule;
  impl ModuleInit for PointModule {
    fn init_module(ctx: &mut Context, m: &mut JsModuleDef) {
      m.add_export(""Point\0"", PointDef::class_value(ctx));
    }
  }

  pub fn init_point_module(ctx: &mut Context) {
    ctx.register_class(PointDef);
    ctx.register_module(""point\0"", PointModule, &[""Point\0""]);
  }
}
```

In the interpreter implementation, we call `point::init_point_module` first to register the Rust module with the JavaScript context, and then we can run a JavaScript program that uses the `point` object.

```rust
use wasmedge_quickjs::*;
fn main() {
  let mut ctx = Context::new();
  point::init_point_module(&mut ctx);

  let code = r#""
    import('point').then((point)=>{
    let p0 = new point.Point(1,2)
    print(""js->"",p0.x,p0.y)
    p0.pprint()
    try{
      let p = new point.Point()
      print(""js-> p:"",p)
      print(""js->"",p.x,p.y)
      p.x=2
      p.pprint()
    } catch(e) {
      print(""An error has been caught"");
      print(e)
    }
    })
  ""#;

  ctx.eval_global_str(code);
  ctx.promise_loop_poll();
}
```

The execution result from the above application is as follows.

```bash
rust-> new Point [Int(1), Int(2)]
rust-> get x
rust-> get y
js-> 1 2
rust-> pprint: Point(1, 2)
rust-> new Point []
js-> p: undefined
An error has been caught
TypeError: cannot read property 'x' of undefined
```

## Code reuse

We could create JavaScript classes that inherit (or extend) existing classes using the Rust API. That allows developers to develop complex JavaScript APIs by building on existing solutions using Rust. You can see [an example here](https://github.com/second-state/wasmedge-quickjs/blob/main/examples/js_extend.rs).

Next, you can see the Rust code in the [internal_module](https://github.com/second-state/wasmedge-quickjs/tree/main/src/internal_module) folder for more examples of how to implement common JavaScript built-in functions, including [Node.js](nodejs.md) APIs.
","This code is a comprehensive example of using Rust to create JavaScript APIs for the WebAssembly runtime Wasmedge. It covers various topics, including:

1. **Embedding JavaScript into a Rust program**: The code shows how to evaluate JavaScript code from within a Rust program.
2. **Creating a JavaScript function API**: It demonstrates how to define a Rust function that can be called as a JavaScript function API.
3. **Creating a JavaScript object API**: This example creates a Rust class that can be used as a JavaScript object, with properties and methods defined using the `JsClassDef` trait.
4. **A complete JavaScript object API**: The code shows how to create a more complex Rust module that provides a JavaScript object API, including data fields, constructor, getters, setters, and functions.

The example uses the Wasmedge QuickJS runtime, which is a WebAssembly-based implementation of the ECMAScript 2015 (ES6) standard.

**Key components:**

1. `JsClassDef`: A trait that defines how to create a JavaScript class from a Rust struct.
2. `ModuleInit`: A trait that defines how to initialize a Rust module and register its functions with the JavaScript context.
3. `Point`: A sample Rust struct that represents a point in 2D space, used as an example for creating a JavaScript object API.

**Code organization:**

The code is organized into several files, each focusing on a specific aspect of creating JavaScript APIs from Rust:

1. `rust.md`: An introduction to using Rust to create JavaScript APIs.
2. `js_hello.rs`: Demonstrates how to evaluate JavaScript code from within a Rust program.
3. `js_function_api.rs`: Shows how to define a Rust function that can be called as a JavaScript function API.
4. `js_object_api.rs`: Creates a Rust class that can be used as a JavaScript object, with properties and methods defined using the `JsClassDef` trait.
5. `point.rs`: A more complex example of creating a JavaScript object API, including data fields, constructor, getters, setters, and functions.

**Advice:**

* When working with Wasmedge QuickJS, it's essential to understand how to create and manage JavaScript contexts using the `Context` type.
* The `JsClassDef` trait provides a flexible way to define custom JavaScript classes from Rust structs. Be sure to explore its methods and attributes for creating complex class hierarchies.
* When using the `ModuleInit` trait, remember to register your functions with the JavaScript context using the `register_function` method.
* As you work on more complex projects, consider breaking down your code into smaller, reusable modules or libraries to keep your Rust codebase organized and maintainable."
docs/develop/deploy/using-wasmedge-in-docker.md,"---
sidebar_position: 5
---

# Using WasmEdge in Docker

## What is the WasmEdge DockerSlim

An easy way to run WebAssembly applications in the Docker ecosystem is to embed the WebAssembly bytecode file in a Linux container image. Precisely, we trim down the Linux OS inside the container to the point where it is just enough to support the `wasmedge` runtime. This approach has many advantages.

- It works seamlessly with any Docker or container ecosystem tool since the WebAssembly application is wrapped in a regular container.
- The memory footprint of the entire image of Linux OS and WasmEdge can be reduced to as low as 4MB.
- The attack surface of the slimmed Linux OS is dramatically reduced from a regular Linux OS.
- The overall application security is managed by the WebAssembly sandbox. The software supply chain attack risk is greatly reduced since the WebAssembly sandbox only has access to explicitly declared capabilities.
- The above three advantages are amplified if the application is complex. For example, a WasmEdge AI inference application would NOT require a Python install. A WasmEdge node.js application would NOT require a Node.js and v8 install.

However, this approach still requires starting up a Linux container. The containerized Linux OS, however slim, still takes 80% of the total image size. There is still a lot of room for optimization. The performance and security of this approach would not be as great as running WebAssembly applications directly in [crun](/develop/deploy/oci-runtime/crun.md) or in a [containerd shim](/develop/deploy/cri-runtime/containerd.md).

## WasmEdge DockerSlim

The `wasmedge/slim:{version}` Docker images provide a slim WasmEdge images built with [DockerSlim](https://dockersl.im) every release.

- Image `wasmedge/slim-runtime:{version}` includes only WasmEdge runtime with `wasmedge` command.
- Image `wasmedge/slim:{version}` includes the following command line utilities:
  - `wasmedge`
  - `wasmedgec`
- Image `wasmedge/slim-tf:{version}` includes the following command line utilities:
  - `wasmedge`
  - `wasmedgec`
  - `wasmedge-tensorflow-lite`
  - `wasmedge-tensorflow`
  - `show-tflite-tensor`
- The working directory of the release docker image is `/app`.

## Run a simple WebAssembly app

We can run a simple WebAssembly program using Docker. A slim Linux image with WasmEdge installed is only 4MB instead of 30MB for a general Linux image for natively compiled applications. The Linux + WasmEdge image is similar to a unikernel OS image. It minimizes the footprint, performance overhead, and potential attack surface for WebAssembly applications.

[The sample application is here](https://github.com/second-state/wasm-learning/tree/master/cli/wasi). First, create a `Dockerfile` based on our release image. Include the [wasm application file](https://github.com/second-state/wasm-learning/raw/master/cli/wasi/wasi_example_main.wasm) in the new image, and run the `wasmedge` command at start up.

```shell
FROM wasmedge/slim-runtime:0.10.1
ADD wasi_example_main.wasm /
CMD [""wasmedge"", ""--dir"", "".:/"", ""/wasi_example_main.wasm""]
```

Run the WebAssembly application in Docker CLI as follows.

```shell
$ docker build -t wasmedge/myapp -f Dockerfile ./
... ...
Successfully tagged wasmedge/myapp:latest

$ docker run --rm wasmedge/myapp
Random number: -807910034
Random bytes: [113, 123, 78, 85, 63, 124, 68, 66, 151, 71, 91, 249, 242, 160, 164, 133, 35, 209, 106, 143, 202, 87, 147, 87, 236, 49, 238, 165, 125, 175, 172, 114, 136, 205, 200, 176, 30, 122, 149, 21, 39, 58, 221, 102, 165, 179, 124, 13, 60, 166, 188, 127, 83, 95, 145, 0, 25, 209, 226, 190, 10, 184, 139, 191, 243, 149, 197, 85, 186, 160, 162, 156, 181, 74, 255, 99, 203, 161, 108, 153, 90, 155, 247, 183, 106, 79, 48, 255, 172, 17, 193, 36, 245, 195, 170, 202, 119, 238, 104, 254, 214, 227, 149, 20, 8, 147, 105, 227, 114, 146, 246, 153, 251, 139, 130, 1, 219, 56, 228, 154, 146, 203, 205, 56, 27, 115, 79, 254]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
wasi_example_main.wasm
File content is This is in a file
```

## Run a HTTP server app

We can run a simple WebAssembly-based HTTP micro-service using the Docker CLI. The [sample application is here](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_server). Follow the instructions to compile and build the `http_server.wasm` file.

Create a `Dockerfile` based on our release image. Include the `http_server.wasm` application file in the new image, and run the `wasmedge` command at startup.

```shell
FROM wasmedge/slim-runtime:0.10.1
ADD http_server.wasm /
CMD [""wasmedge"", ""--dir"", "".:/"", ""/http_server.wasm""]
```

Run the WebAssembly server application in Docker CLI as follows. Notice that we map the server port from the container to the host.

```shell
$ docker build -t wasmedge/myapp -f Dockerfile ./
... ...
Successfully tagged wasmedge/myapp:latest

$ docker run --rm -p 1234:1234 wasmedge/myapp
new connection at 1234
```

You can now access the server from another terminal.

```shell
$ curl -X POST http://127.0.0.1:1234 -d ""name=WasmEdge""
echo: name=WasmEdge
```

## Run a lightweight Node.js server

With WasmEdge QuickJS support for the Node.js API, we can run a lightweight and secure node.js server from Docker CLI. The slim Linux + WasmEdge + Node.js support image size is less than 15MB instead of over 350MB for a standard Node.js image. You will need to do the following.

- [Download the WasmEdge QuickJS runtime](https://github.com/second-state/wasmedge-quickjs/releases/download/v0.4.0-alpha/wasmedge_quickjs.wasm) here. You will have the `wasmedge_quickjs.wasm` file.
- [Download the modules](https://github.com/second-state/wasmedge-quickjs/tree/main/modules) directory from the WasmEdge QuickJS repo.
- Create a JavaScript file for the server. Below is an example `http_echo.js` file you can use.

```javascript
import { createServer, request, fetch } from 'http';

createServer((req, resp) => {
  req.on('data', (body) => {
    resp.write('echo:');
    resp.end(body);
  });
}).listen(8001, () => {
  print('listen 8001 ...\n');
});
```

Add those files to the Docker image and run the JavaScript file at startup.

```shell
FROM wasmedge/slim-runtime:0.10.1
ADD wasmedge_quickjs.wasm /
ADD http_echo.js /
ADD modules /modules
CMD [""wasmedge"", ""--dir"", "".:/"", ""/wasmedge_quickjs.wasm"", ""http_echo.js""]
```

Start the server from Docker CLI.

```shell
$ docker build -t wasmedge/myapp -f Dockerfile ./
... ...
Successfully tagged wasmedge/myapp:latest

$ docker run --rm -p 8001:8001 wasmedge/myapp
listen 8001 ...
```

You can now access the server from another terminal.

```shell
$ curl -X POST http://127.0.0.1:8001 -d ""WasmEdge""
echo:WasmEdge
```

## Run a lightweight Tensorflow inference application

A unique and powerful feature of the WasmEdge runtime is its support for AI frameworks. In this example, we will show you how to run an image recognition service from Docker CLI. [The sample application is here](https://github.com/WasmEdge/wasmedge_hyper_demo/tree/main/server-tflite). First, create a `Dockerfile` based on our `tensorflow` release image. Include the [wasm application file](https://github.com/WasmEdge/wasmedge_hyper_demo/raw/main/server-tflite/wasmedge_hyper_server_tflite.wasm) in the new image, and run the `wasmedge-tensorflow-lite` command at startup.

The Dockerfile is as follows. The whole package is 115MB. It is less than 1/4 of a typically Linux + Python + Tensorflow setup.

```shell
FROM wasmedge/slim-tf:0.10.1
ADD wasmedge_hyper_server_tflite.wasm /
CMD [""wasmedge-tensorflow-lite"", ""--dir"", "".:/"", ""/wasmedge_hyper_server_tflite.wasm""]
```

Start the server from Docker CLI.

```shell
$ docker build -t wasmedge/myapp -f Dockerfile ./
... ...
Successfully tagged wasmedge/myapp:latest

$ docker run --rm -p 3000:3000 wasmedge/myapp
listen 3000 ...
```

You can now access the server from another terminal.

```shell
$ curl http://localhost:3000/classify -X POST --data-binary ""@grace_hopper.jpg""
military uniform is detected with 206/255 confidence
```
","**Summary**

The code provided is a tutorial on how to use WasmEdge, a WebAssembly runtime, in a Docker container. The tutorial covers several examples of running different types of applications, including a simple WebAssembly program, an HTTP server, a lightweight Node.js server, and a TensorFlow inference application.

**Key Components**

1. **Docker Images**: The code uses several Docker images, including `wasmedge/slim-runtime`, `wasmedge/slim`, and `wasmedge/slim-tf`. These images are built with DockerSlim, which trims down the Linux OS to only include what is necessary for WasmEdge to run.
2. **Dockerfiles**: The code includes several Dockerfiles that define how to build the Docker images. Each Dockerfile includes commands to copy the WebAssembly application file into the image and set the command to run at startup.
3. **WebAssembly Applications**: The code includes several examples of WebAssembly applications, including `wasi_example_main.wasm`, `http_server.wasm`, and `wasmedge_hyper_server_tflite.wasm`. These files are copied into the Docker images using the Dockerfiles.

**Potential Issues**

1. **Security**: Running WebAssembly applications in a Docker container may introduce security risks if not properly configured. It is essential to ensure that the Docker images and containers are properly secured.
2. **Performance**: The performance of WasmEdge and the underlying Linux OS may be affected by the trimming process used by DockerSlim. This may impact the overall performance of the application.
3. **Complexity**: The code includes several examples, which can make it challenging to understand the nuances of each example.

**Areas for Improvement**

1. **Documentation**: While the code provides a comprehensive tutorial on using WasmEdge in Docker, more documentation is needed to explain the underlying concepts and configuration options.
2. **Error Handling**: The code does not include robust error handling mechanisms, which can make it difficult to diagnose issues when running the applications.
3. **Scalability**: The code may need to be adapted for larger-scale deployments, which could involve optimizing performance, security, and complexity."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/using-wasmedge-in-docker.md,"---
sidebar_position: 5
---

# Using WasmEdge in Docker

## What is the WasmEdge DockerSlim

An easy way to run WebAssembly applications in the Docker ecosystem is to embed the WebAssembly bytecode file in a Linux container image. Precisely, we trim down the Linux OS inside the container to the point where it is just enough to support the `wasmedge` runtime. This approach has many advantages.

- It works seamlessly with any Docker or container ecosystem tool since the WebAssembly application is wrapped in a regular container.
- The memory footprint of the entire image of Linux OS and WasmEdge can be reduced to as low as 4MB.
- The attack surface of the slimmed Linux OS is dramatically reduced from a regular Linux OS.
- The overall application security is managed by the WebAssembly sandbox. The software supply chain attack risk is greatly reduced since the WebAssembly sandbox only has access to explicitly declared capabilities.
- The above three advantages are amplified if the application is complex. For example, a WasmEdge AI inference application would NOT require a Python install. A WasmEdge node.js application would NOT require a Node.js and v8 install.

However, this approach still requires starting up a Linux container. The containerized Linux OS, however slim, still takes 80% of the total image size. There is still a lot of room for optimization. The performance and security of this approach would not be as great as running WebAssembly applications directly in [crun](/develop/deploy/oci-runtime/crun.md) or in a [containerd shim](/develop/deploy/cri-runtime/containerd.md).

## WasmEdge DockerSlim

The `wasmedge/slim:{version}` Docker images provide a slim WasmEdge images built with [DockerSlim](https://dockersl.im) every release.

- Image `wasmedge/slim-runtime:{version}` includes only WasmEdge runtime with `wasmedge` command.
- Image `wasmedge/slim:{version}` includes the following command line utilities:
  - `wasmedge`
  - `wasmedgec`
- Image `wasmedge/slim-tf:{version}` includes the following command line utilities:
  - `wasmedge`
  - `wasmedgec`
  - `wasmedge-tensorflow-lite`
  - `wasmedge-tensorflow`
  - `show-tflite-tensor`
- The working directory of the release docker image is `/app`.

## Run a simple WebAssembly app

We can run a simple WebAssembly program using Docker. A slim Linux image with WasmEdge installed is only 4MB instead of 30MB for a general Linux image for natively compiled applications. The Linux + WasmEdge image is similar to a unikernel OS image. It minimizes the footprint, performance overhead, and potential attack surface for WebAssembly applications.

[The sample application is here](https://github.com/second-state/wasm-learning/tree/master/cli/wasi). First, create a `Dockerfile` based on our release image. Include the [wasm application file](https://github.com/second-state/wasm-learning/raw/master/cli/wasi/wasi_example_main.wasm) in the new image, and run the `wasmedge` command at start up.

```shell
FROM wasmedge/slim-runtime:0.10.1
ADD wasi_example_main.wasm /
CMD [""wasmedge"", ""--dir"", "".:/"", ""/wasi_example_main.wasm""]
```

Run the WebAssembly application in Docker CLI as follows.

```shell
$ docker build -t wasmedge/myapp -f Dockerfile ./
... ...
Successfully tagged wasmedge/myapp:latest

$ docker run --rm wasmedge/myapp
Random number: -807910034
Random bytes: [113, 123, 78, 85, 63, 124, 68, 66, 151, 71, 91, 249, 242, 160, 164, 133, 35, 209, 106, 143, 202, 87, 147, 87, 236, 49, 238, 165, 125, 175, 172, 114, 136, 205, 200, 176, 30, 122, 149, 21, 39, 58, 221, 102, 165, 179, 124, 13, 60, 166, 188, 127, 83, 95, 145, 0, 25, 209, 226, 190, 10, 184, 139, 191, 243, 149, 197, 85, 186, 160, 162, 156, 181, 74, 255, 99, 203, 161, 108, 153, 90, 155, 247, 183, 106, 79, 48, 255, 172, 17, 193, 36, 245, 195, 170, 202, 119, 238, 104, 254, 214, 227, 149, 20, 8, 147, 105, 227, 114, 146, 246, 153, 251, 139, 130, 1, 219, 56, 228, 154, 146, 203, 205, 56, 27, 115, 79, 254]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
wasi_example_main.wasm
File content is This is in a file
```

## Run a HTTP server app

We can run a simple WebAssembly-based HTTP micro-service using the Docker CLI. The [sample application is here](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_server). Follow the instructions to compile and build the `http_server.wasm` file.

Create a `Dockerfile` based on our release image. Include the `http_server.wasm` application file in the new image, and run the `wasmedge` command at startup.

```shell
FROM wasmedge/slim-runtime:0.10.1
ADD http_server.wasm /
CMD [""wasmedge"", ""--dir"", "".:/"", ""/http_server.wasm""]
```

Run the WebAssembly server application in Docker CLI as follows. Notice that we map the server port from the container to the host.

```shell
$ docker build -t wasmedge/myapp -f Dockerfile ./
... ...
Successfully tagged wasmedge/myapp:latest

$ docker run --rm -p 1234:1234 wasmedge/myapp
new connection at 1234
```

You can now access the server from another terminal.

```shell
$ curl -X POST http://127.0.0.1:1234 -d ""name=WasmEdge""
echo: name=WasmEdge
```

## Run a lightweight Node.js server

With WasmEdge QuickJS support for the Node.js API, we can run a lightweight and secure node.js server from Docker CLI. The slim Linux + WasmEdge + Node.js support image size is less than 15MB instead of over 350MB for a standard Node.js image. You will need to do the following.

- [Download the WasmEdge QuickJS runtime](https://github.com/second-state/wasmedge-quickjs/releases/download/v0.4.0-alpha/wasmedge_quickjs.wasm) here. You will have the `wasmedge_quickjs.wasm` file.
- [Download the modules](https://github.com/second-state/wasmedge-quickjs/tree/main/modules) directory from the WasmEdge QuickJS repo.
- Create a JavaScript file for the server. Below is an example `http_echo.js` file you can use.

```javascript
import { createServer, request, fetch } from 'http';

createServer((req, resp) => {
  req.on('data', (body) => {
    resp.write('echo:');
    resp.end(body);
  });
}).listen(8001, () => {
  print('listen 8001 ...\n');
});
```

Add those files to the Docker image and run the JavaScript file at startup.

```shell
FROM wasmedge/slim-runtime:0.10.1
ADD wasmedge_quickjs.wasm /
ADD http_echo.js /
ADD modules /modules
CMD [""wasmedge"", ""--dir"", "".:/"", ""/wasmedge_quickjs.wasm"", ""http_echo.js""]
```

Start the server from Docker CLI.

```shell
$ docker build -t wasmedge/myapp -f Dockerfile ./
... ...
Successfully tagged wasmedge/myapp:latest

$ docker run --rm -p 8001:8001 wasmedge/myapp
listen 8001 ...
```

You can now access the server from another terminal.

```shell
$ curl -X POST http://127.0.0.1:8001 -d ""WasmEdge""
echo:WasmEdge
```

## Run a lightweight Tensorflow inference application

A unique and powerful feature of the WasmEdge runtime is its support for AI frameworks. In this example, we will show you how to run an image recognition service from Docker CLI. [The sample application is here](https://github.com/WasmEdge/wasmedge_hyper_demo/tree/main/server-tflite). First, create a `Dockerfile` based on our `tensorflow` release image. Include the [wasm application file](https://github.com/WasmEdge/wasmedge_hyper_demo/raw/main/server-tflite/wasmedge_hyper_server_tflite.wasm) in the new image, and run the `wasmedge-tensorflow-lite` command at startup.

The Dockerfile is as follows. The whole package is 115MB. It is less than 1/4 of a typically Linux + Python + Tensorflow setup.

```shell
FROM wasmedge/slim-tf:0.10.1
ADD wasmedge_hyper_server_tflite.wasm /
CMD [""wasmedge-tensorflow-lite"", ""--dir"", "".:/"", ""/wasmedge_hyper_server_tflite.wasm""]
```

Start the server from Docker CLI.

```shell
$ docker build -t wasmedge/myapp -f Dockerfile ./
... ...
Successfully tagged wasmedge/myapp:latest

$ docker run --rm -p 3000:3000 wasmedge/myapp
listen 3000 ...
```

You can now access the server from another terminal.

```shell
$ curl http://localhost:3000/classify -X POST --data-binary ""@grace_hopper.jpg""
military uniform is detected with 206/255 confidence
```
","**Summary**

The code is a documentation for using WasmEdge in Docker. It explains how to run WebAssembly applications in the Docker ecosystem by embedding the bytecode file in a Linux container image. The code includes examples of running simple WebAssembly apps, HTTP servers, lightweight Node.js servers, and TensorFlow inference applications.

**Key Components**

1. **WasmEdge DockerSlim**: A slim WasmEdge image built with DockerSlim every release.
2. **Dockerfile**: A configuration file for building a Docker image that includes the necessary dependencies and files to run the application.
3. **`wasmedge/slim-runtime`:** A base image with only the WasmEdge runtime and `wasmedge` command.
4. **`wasmedge/slim`:** An image including the `wasmedge`, `wasmedgec` commands, and more.
5. **`wasmedge/slim-tf`:** An image including the TensorFlow Lite support.

**Example Use Cases**

1. Running a simple WebAssembly app using Docker.
2. Creating an HTTP server app with Docker CLI.
3. Running a lightweight Node.js server using WasmEdge QuickJS support.
4. Running a lightweight TensorFlow inference application.

**Potential Issues and Areas for Improvement**

1. **Security**: The code uses `docker run --rm` to remove the container after running, which may not be suitable for production environments where security is a concern.
2. **Portability**: The code assumes a specific Docker setup, which may not work on all systems or environments.
3. **Complexity**: The examples are relatively simple and may not be representative of more complex use cases that require additional dependencies and configurations."
docs/contribute/plugin/develop_plugin_cpp.md,"---
sidebar_position: 3
---

# Develop WasmEdge Plug-in in C++ API

By developing a plug-in, one can extend the functionality of WasmEdge and customize it to suit specific needs. WasmEdge provides a C based API for registering extension modules and host functions. While the WasmEdge language SDKs allow registering host functions from a host (wrapping) application, the plug-in API allows such extensions to be incorporated into WasmEdge's building and releasing process.

<!-- prettier-ignore -->
:::note
It is recommended that developers choose the WasmEdge [C API](develop_plugin_c.md) for plug-in development because of the support, compatibility, and flexibility the WasmEdge runtime provides.
:::

Here is a flowchart showing all the steps needed for developing WasmEdge Plug-in -

```mermaid
graph TD;
A[Develop WasmEdge Plug-in in C++ API]
A --> B(Set up development environment)
B --> C(Create project directory)
C --> D(Add configuration files)
D --> E(Install necessary tools and dependencies)
E --> F(Enable specific backends or components)
F --> G(Write plug-in code)
G --> H(Build plug-in)
C --> I(Define plug-in API)
H --> I
I --> J(Compile WasmEdge plug-in)
J --> K(Test and debug plug-in)
```

This flowchart illustrates developing a WasmEdge plug-in, showcasing the steps from choosing a programming language to finalizing and releasing the plug-in.

## Set up a development environment

To start developing WasmEdge plug-ins, it is essential to correctly set up the development environment. This section provides step-by-step instructions for WasmEdge plug-in development -

**Build WasmEdge from source**: For developing the WasmEdge plug-in in C++, you must build WasmEdge from source. Follow the[build WasmEdge from source](../source/build_from_src.md) for instructions.

After installing WasmEdge, you need to set up the build environment. If you're using Linux or other platforms, you can follow the instructions in the [build environment setup guide](../source/os/linux.md).

## Create a WasmEdge plug-in project

To create a WasmEdge plug-in project, follow these steps:

- **Set up the project directory**: Create a directory structure for your plug-in project. You can use a standard structure for the chosen language or create your structure. To create a project directory structure, use the following commands:

  ```bash
  mkdir testplugin
  cd testplugin
  mkdir src include build
  ```

- **Add necessary libraries or dependencies**: Include any required libraries or dependencies for your plug-in. Modify the configuration files created in the previous step to include the required dependencies.

## Write plug-in code

To create a plug-in with host functions and modules, follow these steps:

- **Host Functions and Modules**: The plug-in aims to provide the host functions that can be imported when instantiating WASM. Therefore, developers should first implement their plug-in host functions in WasmEdge internal C++. Assume that the host function implementations are in the `testplugin.h`.

  ```cpp
  #pragma once

  #include ""plugin/plugin.h""

  #include <cstdint>
  #include <string>

  namespace WasmEdge {
  namespace Host {

  // The environment class. For the register object.
  class WasmEdgePluginTestEnv {
  public:
    WasmEdgePluginTestEnv() noexcept = default;

    static Plugin::PluginRegister Register;
  };

  // The host function base template class. For inheriting the environment class
  // reference.
  template <typename T>
  class WasmEdgePluginTestFunc : public Runtime::HostFunction<T> {
  public:
    WasmEdgePluginTestFunc(WasmEdgePluginTestEnv &HostEnv)
        : Runtime::HostFunction<T>(0), Env(HostEnv) {}

  protected:
    WasmEdgePluginTestEnv &Env;
  };

  // The host function to add 2 int32_t numbers.
  class WasmEdgePluginTestFuncAdd
      : public WasmEdgePluginTestFunc<WasmEdgePluginTestFuncAdd> {
  public:
    WasmEdgePluginTestFuncAdd(WasmEdgePluginTestEnv &HostEnv)
        : WasmEdgePluginTestFunc(HostEnv) {}
    Expect<uint32_t> body(const Runtime::CallingFrame &, uint32_t A, uint32_t B) {
      return A + B;
    }
  };

  // The host function to sub 2 int32_t numbers.
  class WasmEdgePluginTestFuncSub
      : public WasmEdgePluginTestFunc<WasmEdgePluginTestFuncSub> {
  public:
    WasmEdgePluginTestFuncSub(WasmEdgePluginTestEnv &HostEnv)
        : WasmEdgePluginTestFunc(HostEnv) {}
    Expect<uint32_t> body(const Runtime::CallingFrame &, uint32_t A, uint32_t B) {
      return A - B;
    }
  };

  // The host module class. There can be several modules in a plug-in.
  class WasmEdgePluginTestModule : public Runtime::Instance::ModuleInstance {
  public:
    WasmEdgePluginTestModule()
        : Runtime::Instance::ModuleInstance(""wasmedge_plugintest_cpp_module"") {
      addHostFunc(""add"", std::make_unique<WasmEdgePluginTestFuncAdd>(Env));
      addHostFunc(""sub"", std::make_unique<WasmEdgePluginTestFuncSub>(Env));
    }

    WasmEdgePluginTestEnv &getEnv() { return Env; }

  private:
    WasmEdgePluginTestEnv Env;
  };

  } // namespace Host
  } // namespace WasmEdge
  ```

- **Creation Functions for Modules**: Then developers should implement the module creation functions. Assume the following implementations are all in the `testplugin.cpp`.

  ```cpp
  #include ""testplugin.h""

  namespace WasmEdge {
  namespace Host {
  namespace {

  Runtime::Instance::ModuleInstance *
  create(const Plugin::PluginModule::ModuleDescriptor *) noexcept {
    // There can be several modules in a plug-in. For that, developers should
    // implement several `create` functions for each module.
    return new WasmEdgePluginTestModule;
  }

  } // namespace
  } // namespace Host
  } // namespace WasmEdge
  ```

- **Plug-in Descriptions**: For constructing the plug-in, developers should supply the descriptions of this plug-in and the modules.

  ```cpp
  namespace WasmEdge {
  namespace Host {
  namespace {

  Plugin::Plugin::PluginDescriptor Descriptor{
      //Plug-in name - for searching the plug-in context by the
      // `WasmEdge_PluginFind()` C API.
      .Name = ""wasmedge_plugintest_cpp"",
      //Plug-in description.
      .Description = """",
      //Plug-in API version.
      .APIVersion = Plugin::Plugin::CurrentAPIVersion,
      //Plug-in version.
      .Version = {0, 10, 0, 0},
      // Module count in this plug-in.
      .ModuleCount = 1,
      // Pointer to module description array.
      .ModuleDescriptions =
          // The module descriptor array.
          (Plugin::PluginModule::ModuleDescriptor[]){
              {
                  // Module name. This is the name for searching and creating the
                  // module instance context by the
                  // `WasmEdge_PluginCreateModule()` C API.
                  .Name = ""wasmedge_plugintest_cpp_module"",
                  // Module description.
                  .Description = ""This is for the plugin tests in WasmEdge."",
                  // Creation function pointer.
                  .Create = create,
              },
          },
      //Plug-in options (Work in progress).
      .AddOptions = nullptr,
  };

  } // namespace
  } // namespace Host
  } // namespace WasmEdge
  ```

- **Plug-in Options**: WORK IN PROGRESS. This section is reserved for the feature in the future.

- **Implement Plug-in Descriptor Registration**: The final step is to implement the `Plugin::PluginRegister` initialization with the plug-in descriptor.

```cpp
namespace WasmEdge {
namespace Host {

Plugin::PluginRegister WasmEdgePluginTestEnv::Register(&Descriptor);

} // namespace Host
} // namespace WasmEdge
```

Remember to implement any additional functions or structures your plug-in requires to fulfill its functionality.

Following these steps and implementing the necessary functions and descriptors, you can create a plug-in with host functions and modules in WasmEdge C++ API. You can continue developing your plug-in by adding functionality and implementing the desired behavior.

## Build plug-in

To build the plug-in shared library, developers should build in CMake with the WasmEdge source.

- Assume that the' test' folder is created under the `<PATH_TO_WASMEDGE_SOURCE>/plug-ins`. Add this line in the `<PATH_TO_WASMEDGE_SOURCE>/plugins/CMakeLists.txt`:

  ```cmake
  add_subdirectory(test)
  ```

- Copy the `testplugin.h` and `testplugin.cpp` into the `<PATH_TO_WASMEDGE_SOURCE>/plugins/test` directory. And then edit the file `<PATH_TO_WASMEDGE_SOURCE>/plugins/test/CMakeLists.txt`:

  ```cmake
  wasmedge_add_library(wasmedgePluginTest
    SHARED
    testplugin.cpp
  )

  target_compile_options(wasmedgePluginTest
    PUBLIC
    -DWASMEDGE_PLUGIN
  )

  target_include_directories(wasmedgePluginTest
    PUBLIC
    $<TARGET_PROPERTY:wasmedgePlugin,INCLUDE_DIRECTORIES>
    ${CMAKE_CURRENT_SOURCE_DIR}
  )

  if(WASMEDGE_LINK_PLUGINS_STATIC)
    target_link_libraries(wasmedgePluginTest
      PRIVATE
      wasmedgeCAPI
    )
  else()
    target_link_libraries(wasmedgePluginTest
      PRIVATE
      wasmedge_shared
    )
  endif()

  install(TARGETS wasmedgePluginTest DESTINATION ${CMAKE_INSTALL_LIBDIR}/wasmedge)
  ```

Follow the guide to [build WasmEdge from source](../source/os/linux.md), according to your specific operating system (e.g., Linux), which will include building the plug-in shared library along with WasmEdge.
","**Summary**

The code provided is a guide for developing WasmEdge plug-ins using the C++ API. It covers the steps to create a WasmEdge plug-in project, write plug-in code, build and install the plug-in shared library, and register the plug-in with WasmEdge.

**Key Components**

1. **Plug-in Project Structure**: The guide creates a standard project structure for the plug-in.
2. **Plugin Code**: The plug-in code includes host functions and modules, which are implemented using C++ classes.
3. **Module Creation Functions**: The module creation functions are used to create instances of the host modules.
4. **Plug-in Descriptions**: The guide provides descriptions for the plug-in and its modules.
5. **Build and Installation**: The guide explains how to build and install the plug-in shared library using CMake.

**Potential Issues and Areas for Improvement**

1. **Complexity**: The code provided is quite complex, making it difficult for beginners to understand and follow.
2. **Lack of Documentation**: While the guide provides explanations, more detailed documentation would be helpful for users who are new to WasmEdge and plug-in development.
3. **Error Handling**: Error handling mechanisms should be implemented to ensure that the plug-in can handle errors gracefully.
4. **Code Organization**: The code could benefit from better organization, with clear separation of concerns between different parts of the plug-in.

**Recommendations**

1. **Simplify the Code**: Break down the complex code into smaller, more manageable pieces, making it easier to understand and maintain.
2. **Improve Documentation**: Provide detailed documentation for each part of the code, including explanations of the purpose, functionality, and any assumptions made.
3. **Implement Error Handling**: Add error handling mechanisms to ensure that the plug-in can handle errors gracefully.
4. **Refactor Code Organization**: Improve the organization of the code, with clear separation of concerns between different parts of the plug-in."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_cpp.md,"---
sidebar_position: 3
---

# Develop WasmEdge Plug-in in C++ API

By developing a plug-in, one can extend the functionality of WasmEdge and customize it to suit specific needs. WasmEdge provides a C based API for registering extension modules and host functions. While the WasmEdge language SDKs allow registering host functions from a host (wrapping) application, the plug-in API allows such extensions to be incorporated into WasmEdge's building and releasing process.

<!-- prettier-ignore -->
:::note
It is recommended that developers choose the WasmEdge [C API](develop_plugin_c.md) for plug-in development because of the support, compatibility, and flexibility the WasmEdge runtime provides.
:::

Here is a flowchart showing all the steps needed for developing WasmEdge Plug-in -

```mermaid
graph TD;
A[Develop WasmEdge Plug-in in C++ API]
A --> B(Set up development environment)
B --> C(Create project directory)
C --> D(Add configuration files)
D --> E(Install necessary tools and dependencies)
E --> F(Enable specific backends or components)
F --> G(Write plug-in code)
G --> H(Build plug-in)
C --> I(Define plug-in API)
H --> I
I --> J(Compile WasmEdge plug-in)
J --> K(Test and debug plug-in)
```

This flowchart illustrates developing a WasmEdge plug-in, showcasing the steps from choosing a programming language to finalizing and releasing the plug-in.

## Set up a development environment

To start developing WasmEdge plug-ins, it is essential to correctly set up the development environment. This section provides step-by-step instructions for WasmEdge plug-in development -

**Build WasmEdge from source**: For developing the WasmEdge plug-in in C++, you must build WasmEdge from source. Follow the[build WasmEdge from source](../source/build_from_src.md) for instructions.

After installing WasmEdge, you need to set up the build environment. If you're using Linux or other platforms, you can follow the instructions in the [build environment setup guide](../source/os/linux.md).

## Create a WasmEdge plug-in project

To create a WasmEdge plug-in project, follow these steps:

- **Set up the project directory**: Create a directory structure for your plug-in project. You can use a standard structure for the chosen language or create your structure. To create a project directory structure, use the following commands:

  ```bash
  mkdir testplugin
  cd testplugin
  mkdir src include build
  ```

- **Add necessary libraries or dependencies**: Include any required libraries or dependencies for your plug-in. Modify the configuration files created in the previous step to include the required dependencies.

## Write plug-in code

To create a plug-in with host functions and modules, follow these steps:

- **Host Functions and Modules**: The plug-in aims to provide the host functions that can be imported when instantiating WASM. Therefore, developers should first implement their plug-in host functions in WasmEdge internal C++. Assume that the host function implementations are in the `testplugin.h`.

  ```cpp
  #pragma once

  #include ""plugin/plugin.h""

  #include <cstdint>
  #include <string>

  namespace WasmEdge {
  namespace Host {

  // The environment class. For the register object.
  class WasmEdgePluginTestEnv {
  public:
    WasmEdgePluginTestEnv() noexcept = default;

    static Plugin::PluginRegister Register;
  };

  // The host function base template class. For inheriting the environment class
  // reference.
  template <typename T>
  class WasmEdgePluginTestFunc : public Runtime::HostFunction<T> {
  public:
    WasmEdgePluginTestFunc(WasmEdgePluginTestEnv &HostEnv)
        : Runtime::HostFunction<T>(0), Env(HostEnv) {}

  protected:
    WasmEdgePluginTestEnv &Env;
  };

  // The host function to add 2 int32_t numbers.
  class WasmEdgePluginTestFuncAdd
      : public WasmEdgePluginTestFunc<WasmEdgePluginTestFuncAdd> {
  public:
    WasmEdgePluginTestFuncAdd(WasmEdgePluginTestEnv &HostEnv)
        : WasmEdgePluginTestFunc(HostEnv) {}
    Expect<uint32_t> body(const Runtime::CallingFrame &, uint32_t A, uint32_t B) {
      return A + B;
    }
  };

  // The host function to sub 2 int32_t numbers.
  class WasmEdgePluginTestFuncSub
      : public WasmEdgePluginTestFunc<WasmEdgePluginTestFuncSub> {
  public:
    WasmEdgePluginTestFuncSub(WasmEdgePluginTestEnv &HostEnv)
        : WasmEdgePluginTestFunc(HostEnv) {}
    Expect<uint32_t> body(const Runtime::CallingFrame &, uint32_t A, uint32_t B) {
      return A - B;
    }
  };

  // The host module class. There can be several modules in a plug-in.
  class WasmEdgePluginTestModule : public Runtime::Instance::ModuleInstance {
  public:
    WasmEdgePluginTestModule()
        : Runtime::Instance::ModuleInstance(""wasmedge_plugintest_cpp_module"") {
      addHostFunc(""add"", std::make_unique<WasmEdgePluginTestFuncAdd>(Env));
      addHostFunc(""sub"", std::make_unique<WasmEdgePluginTestFuncSub>(Env));
    }

    WasmEdgePluginTestEnv &getEnv() { return Env; }

  private:
    WasmEdgePluginTestEnv Env;
  };

  } // namespace Host
  } // namespace WasmEdge
  ```

- **Creation Functions for Modules**: Then developers should implement the module creation functions. Assume the following implementations are all in the `testplugin.cpp`.

  ```cpp
  #include ""testplugin.h""

  namespace WasmEdge {
  namespace Host {
  namespace {

  Runtime::Instance::ModuleInstance *
  create(const Plugin::PluginModule::ModuleDescriptor *) noexcept {
    // There can be several modules in a plug-in. For that, developers should
    // implement several `create` functions for each module.
    return new WasmEdgePluginTestModule;
  }

  } // namespace
  } // namespace Host
  } // namespace WasmEdge
  ```

- **Plug-in Descriptions**: For constructing the plug-in, developers should supply the descriptions of this plug-in and the modules.

  ```cpp
  namespace WasmEdge {
  namespace Host {
  namespace {

  Plugin::Plugin::PluginDescriptor Descriptor{
      //Plug-in name - for searching the plug-in context by the
      // `WasmEdge_PluginFind()` C API.
      .Name = ""wasmedge_plugintest_cpp"",
      //Plug-in description.
      .Description = """",
      //Plug-in API version.
      .APIVersion = Plugin::Plugin::CurrentAPIVersion,
      //Plug-in version.
      .Version = {0, 10, 0, 0},
      // Module count in this plug-in.
      .ModuleCount = 1,
      // Pointer to module description array.
      .ModuleDescriptions =
          // The module descriptor array.
          (Plugin::PluginModule::ModuleDescriptor[]){
              {
                  // Module name. This is the name for searching and creating the
                  // module instance context by the
                  // `WasmEdge_PluginCreateModule()` C API.
                  .Name = ""wasmedge_plugintest_cpp_module"",
                  // Module description.
                  .Description = ""This is for the plugin tests in WasmEdge."",
                  // Creation function pointer.
                  .Create = create,
              },
          },
      //Plug-in options (Work in progress).
      .AddOptions = nullptr,
  };

  } // namespace
  } // namespace Host
  } // namespace WasmEdge
  ```

- **Plug-in Options**: WORK IN PROGRESS. This section is reserved for the feature in the future.

- **Implement Plug-in Descriptor Registration**: The final step is to implement the `Plugin::PluginRegister` initialization with the plug-in descriptor.

```cpp
namespace WasmEdge {
namespace Host {

Plugin::PluginRegister WasmEdgePluginTestEnv::Register(&Descriptor);

} // namespace Host
} // namespace WasmEdge
```

Remember to implement any additional functions or structures your plug-in requires to fulfill its functionality.

Following these steps and implementing the necessary functions and descriptors, you can create a plug-in with host functions and modules in WasmEdge C++ API. You can continue developing your plug-in by adding functionality and implementing the desired behavior.

## Build plug-in

To build the plug-in shared library, developers should build in CMake with the WasmEdge source.

- Assume that the' test' folder is created under the `<PATH_TO_WASMEDGE_SOURCE>/plug-ins`. Add this line in the `<PATH_TO_WASMEDGE_SOURCE>/plugins/CMakeLists.txt`:

  ```cmake
  add_subdirectory(test)
  ```

- Copy the `testplugin.h` and `testplugin.cpp` into the `<PATH_TO_WASMEDGE_SOURCE>/plugins/test` directory. And then edit the file `<PATH_TO_WASMEDGE_SOURCE>/plugins/test/CMakeLists.txt`:

  ```cmake
  wasmedge_add_library(wasmedgePluginTest
    SHARED
    testplugin.cpp
  )

  target_compile_options(wasmedgePluginTest
    PUBLIC
    -DWASMEDGE_PLUGIN
  )

  target_include_directories(wasmedgePluginTest
    PUBLIC
    $<TARGET_PROPERTY:wasmedgePlugin,INCLUDE_DIRECTORIES>
    ${CMAKE_CURRENT_SOURCE_DIR}
  )

  if(WASMEDGE_LINK_PLUGINS_STATIC)
    target_link_libraries(wasmedgePluginTest
      PRIVATE
      wasmedgeCAPI
    )
  else()
    target_link_libraries(wasmedgePluginTest
      PRIVATE
      wasmedge_shared
    )
  endif()

  install(TARGETS wasmedgePluginTest DESTINATION ${CMAKE_INSTALL_LIBDIR}/wasmedge)
  ```

Follow the guide to [build WasmEdge from source](../source/os/linux.md), according to your specific operating system (e.g., Linux), which will include building the plug-in shared library along with WasmEdge.
","**Summary**

The provided code is a documentation for developing WasmEdge plug-ins in C++ API. It covers the steps to set up a development environment, create a WasmEdge plug-in project, write plug-in code, build the plug-in, and finally test and debug it.

**Key Components**

1.  **WasmEdge Plug-in Development Environment**: The code provides step-by-step instructions for setting up the development environment, including building WasmEdge from source.
2.  **Plugin Project Structure**: It explains how to create a standard project directory structure for your plug-in project and add necessary libraries or dependencies.
3.  **Writing Plug-in Code**: The code includes an example of how to create a plug-in with host functions and modules, including the implementation of the host function base template class and the creation of host functions and modules.
4.  **Plugin Descriptions**: It shows how to provide descriptions for the plug-in and its modules.
5.  **Building Plug-in**: The code explains how to build the plug-in shared library using CMake with the WasmEdge source.

**Potential Issues or Areas for Improvement**

1.  **Code Organization**: The provided documentation is quite extensive, but some sections could be better organized for easier navigation.
2.  **CMake Configuration**: The CMake configuration file seems a bit complex; simplifying it could make it more maintainable and easier to understand.
3.  **Plug-in Options (Work in Progress)**: This section appears to be incomplete or a placeholder, which might lead to confusion or issues if not properly addressed.

**Recommendations**

To improve the code, consider:

1.  Simplify the CMake configuration file for better maintainability.
2.  Complete and refine the plug-in options section (if applicable).
3.  Provide more comprehensive documentation for creating WasmEdge plug-ins, including best practices and common pitfalls to avoid."
i18n/zh/docusaurus-plugin-content-docs/current/start/build-and-run/cli.md,"---
sidebar_position: 1
---

# `wasmedge` 命令行工具

在安装了 WasmEdge 后，你可以使用 `wasmedge` 来执行 WASM 文件。我们将介绍如何在你的机器和 Docker 镜像上使用 WasmEdge 运行 WASM 文件。

`wasmedge` 二进制文件是一个命令行界面（CLI）程序，用于运行 WebAssembly 程序。

- 如果 WebAssembly 程序包含 `main()` 函数，`wasmedge` 将把它作为独立程序以命令模式执行。
- 如果 WebAssembly 程序包含一个或多个导出的公共函数，`wasmedge` 可以在反应器模式中调用单个函数。

默认情况下，`wasmedge` 将以解释器模式执行 WebAssembly 程序，并在 AOT 模式下执行 AOT 编译的 `.so`、`.dylib`、`.dll` 或 `.wasm`（通用输出格式）。如果要加速 WASM 执行，我们建议首先使用 [AOT 编译器对 WebAssembly 进行编译](aot.md)。

<!-- prettier-ignore -->
:::note
原始的 `wasmedgec` 工具已更改为 `wasmedge compile`。[`wasmedge compile` CLI 工具](aot.md) 是用于将 WebAssembly 文件编译为本机代码的预先编译器。
:::

```bash
$ wasmedge -v
wasmedge version {{ wasmedge_version }}
```

用户可以运行 `wasmedge -h` 快速了解命令行选项，或者[在这里查看详细的 `wasmedge` CLI 选项](#选项)。`wasmedge` 工具的用法将是：

```bash
$ wasmedge -h
USAGE
   wasmedge [OPTIONS] [--] WASM_OR_SO [ARG ...]

...
```

`wasmedge` CLI 工具将以预先编译（AOT）模式或解释器模式执行 WASM 文件。如果文件已使用 `wasmedge compile` 编译，则 WasmEdge 将以 AOT 模式执行它，否则将以解释器模式执行。

## 选项

`wasmedge` 命令行工具的选项如下：

1. `-v|--version`：显示版本信息。将忽略下面的其他参数。
2. `-h|--help`：显示帮助信息。将忽略下面的其他参数。
3. （可选）`--reactor`：启用反应器模式。
   - 在反应器模式下，`wasmedge` 运行 WebAssembly 程序中导出的特定函数。
   - WasmEdge 将执行函数，函数名应作为 `ARG[0]` 给出。
   - 如果一个导出函数名为 `_initialize`，该函数将首先以空参数执行。
4. （可选）`--dir`：将目录绑定到 WASI 虚拟文件系统。
   - 使用 `--dir guest_path:host_path` 将主机路径绑定到 WASI 虚拟系统中的客户端路径。
5. （可选）`--env`：在 WASI 中分配环境变量。
   - 使用 `--env ENV_NAME=VALUE` 分配环境变量。
6. （可选）统计信息：
   - 使用 `--enable-time-measuring` 显示执行时间。
   - 使用 `--enable-gas-measuring` 显示消耗的 gas 量。
   - 使用 `--enable-instruction-count` 显示执行的指令数量。
   - 或者使用 `--enable-all-statistics` 启用所有统计选项。
7. （可选）资源限制：
   - 使用 `--time-limit MILLISECOND_TIME` 限制执行时间。默认值为 `0`，表示无限制。
   - 使用 `--gas-limit GAS_LIMIT` 限制执行成本。
   - 使用 `--memory-page-limit PAGE_COUNT` 设置每个内存实例中页面（64 KiB 大小）的限制。
8. （可选）WebAssembly 提案：
   - 使用 `--disable-import-export-mut-globals` 禁用[可变全局变量的导入/导出](https://github.com/WebAssembly/mutable-global) 提案（默认为 `ON`）。
   - 使用 `--disable-non-trap-float-to-int` 禁用[非陷阱浮点到整数转换](https://github.com/WebAssembly/nontrapping-float-to-int-conversions) 提案（默认为 `ON`）。
   - 使用 `--disable-sign-extension-operators` 禁用[符号扩展运算符](https://github.com/WebAssembly/sign-extension-ops) 提案（默认为 `ON`）。
   - 使用 `--disable-multi-value` 禁用[多值](https://github.com/WebAssembly/multi-value) 提案（默认为 `ON`）。
   - 使用 `--disable-bulk-memory` 禁用[批量内存操作](https://github.com/WebAssembly/bulk-memory-operations) 提案（默认为 `ON`）。
   - 使用 `--disable-reference-types` 禁用[引用类型](https://github.com/WebAssembly/reference-types) 提案（默认为 `ON`）。
   - 使用 `--disable-simd` 禁用[固定宽度 SIMD](https://github.com/webassembly/simd) 提案（默认为 `ON`）。
   - 使用 `--enable-multi-memory` 启用[多内存](https://github.com/WebAssembly/multi-memory) 提案（默认为 `OFF`）。
   - 使用 `--enable-tail-call` 启用[尾调用](https://github.com/WebAssembly/tail-call) 提案（默认为 `OFF`）。
   - 使用 `--enable-extended-const` 启用[扩展常量表达式](https://github.com/WebAssembly/extended-const) 提案（默认为 `OFF`）。
   - 使用 `--enable-threads` 启用[线程](https://github.com/webassembly/threads) 提案（默认为 `OFF`）。
   - 使用 `--enable-all` 启用以上所有提案。
9. WASM 文件（`/path/to/wasm/file`）。
10. （可选）`ARG` 命令行参数数组。
    - 在反应器模式下，第一个参数将是函数名，`ARG[0]` 之后的参数将是 WASM 函数 `ARG[0]` 的参数。
    - 在命令模式下，参数将是 WASI `_start` 函数的命令行参数。它们也被称为独立的 C/C++ 程序的命令行参数（`argv`）。

## TensorFlow 工具

<!-- prettier-ignore -->
:::note
在 0.12.1 版本之后，`WasmEdge-tensorflow-tools` 已被弃用，并在 0.13.0 版本之后由插件替代。
:::

如果用户使用安装脚本并选择 `-e tf,image` 选项安装 WasmEdge，那么 WasmEdge CLI 工具将会安装 TensorFlow 和 TensorFlow-Lite 扩展。

- `wasmedge-tensorflow` CLI 工具
  - 包含 TensorFlow、TensorFlow-Lite 和 `wasmedge-image` 扩展的 `wasmedge` 工具。
  - 仅支持 `x86_64` 和 `aarch64` Linux 平台以及 `x86_64` MacOS。
- `wasmedge-tensorflow-lite` CLI 工具
  - 包含 TensorFlow-Lite 和 `wasmedge-image` 扩展的 `wasmedge` 工具。
  - 仅支持 `x86_64` 和 `aarch64` Linux 平台、Android 和 `x86_64` MacOS。

## 示例

### 构建和运行独立的 WebAssembly 应用

Hello World 示例是一个独立的 Rust 应用程序，可以通过 [WasmEdge 命令行工具](../build-and-run/cli)执行。它的源代码和构建说明可以在[此处](https://github.com/second-state/rust-examples/tree/main/hello)找到。

你需要安装 [Rust 编译器](https://github.com/second-state/rust-examples/blob/main/README.md#prerequisites)，然后使用以下命令从 Rust 源代码构建 WASM 字节码文件。

```bash
cargo build --target wasm32-wasi --release
```

你可以使用 `wasmedge` 指令运行这个程序：

```bash
$ wasmedge target/wasm32-wasi/release/hello.wasm
Hello WasmEdge!
```

#### 开启 `statistics` 并执行

命令行支持 `--enable-all-statistics` 参数，用于启用所有统计选项。

你可以运行：

```bash
wasmedge --enable-all-statistics hello.wasm
```

输出为：

```bash
Hello WasmEdge!
[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================
[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns
[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns
[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns
[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425
[2021-12-09 16:03:33.261] [info]  Gas costs: 20425
[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218
[2021-12-09 16:03:33.261] [info] =======================   End   ======================
```

#### 开启 `gas-limit` 并执行

命令行支持 `--gas-limit`参数，用于控制执行成本。

下面是提供足够的 Gas 的示例：

```bash
wasmedge --enable-all-statistics --gas-limit 20425 hello.wasm
```

输出为：

```bash
Hello WasmEdge!
[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================
[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns
[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns
[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns
[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425
[2021-12-09 16:03:33.261] [info]  Gas costs: 20425
[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218
[2021-12-09 16:03:33.261] [info] =======================   End   ======================
```

下面是提供不足的 Gas 的示例：

```bash
wasmedge --enable-all-statistics --gas-limit 20 hello.wasm
```

输出为：

```bash
Hello WasmEdge!
[2021-12-23 15:19:06.690] [error] Cost exceeded limit. Force terminate the execution.
[2021-12-23 15:19:06.690] [error]     In instruction: ref.func (0xd2) , Bytecode offset: 0x00000000
[2021-12-23 15:19:06.690] [error]     At AST node: expression
[2021-12-23 15:19:06.690] [error]     At AST node: element segment
[2021-12-23 15:19:06.690] [error]     At AST node: element section
[2021-12-23 15:19:06.690] [error]     At AST node: module
[2021-12-23 15:19:06.690] [info] ====================  Statistics  ====================
[2021-12-23 15:19:06.690] [info]  Total execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Wasm instructions execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Host functions execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Executed wasm instructions count: 21
[2021-12-23 15:19:06.690] [info]  Gas costs: 20
```

### 调用从 Rust 编译的 WebAssembly 函数

[add](https://github.com/second-state/wasm-learning/tree/master/cli/add) 程序是用 Rust 编写的，包含一个导出的 `add()` 函数。你可以将其编译为 WebAssembly，并使用 `wasmedge` 调用 `add()` 函数。在这个示例中，你将看到如何从 CLI 进行此操作。通常在将 WasmEdge 嵌入到另一个主机应用程序中时，需要从主机调用 WASM 函数。

你需要安装 [Rust 编译器](https://github.com/second-state/rust-examples/blob/main/README.md#prerequisites)，然后使用以下命令从 Rust 源代码构建 WASM 字节码文件。

```bash
cargo build --target wasm32-wasi --release
```

你可以在反应器模式下执行 `wasmedge`，以调用具有两个 `i32` 整数输入参数的 `add()` 函数。

```bash
wasmedge --reactor add.wasm add 2 2
```

输出为：

```bash
4
```

### 调用用 WAT 编写的 WebAssembly 函数

我们创建了纯手工编写的 [fibonacci.wat](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wat) 文件，并使用 [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) 工具将其转换为名为 `fibonacci.wasm` 的 WebAssembly 程序。它导出了一个 `fib()` 函数，该函数以单个 `i32` 整数作为输入参数。我们可以在反应器模式下执行 `wasmedge` 来调用导出的函数。

你可以运行：

```bash
wasmedge --reactor fibonacci.wasm fib 10
```

输出为：

```bash
89
```

### JavaScript 示例

使用 WasmEdge 作为高性能、安全、可扩展、易于部署的、符合 [Kubernetes](https://github.com/second-state/wasmedge-containers-examples) 标准的 JavaScript 运行时是可能的。无需构建 JavaScript 应用程序。你需要下载适用于 Node.js 的 WasmEdge JavaScript 运行时。

- [在此处下载 wasmedge_quickjs.wasm 文件](https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm)
- [在此处下载 modules.zip 文件](https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip)，然后解压到当前文件夹中并确保名称为 `./modules/`。

```bash
wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm
wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip
unzip modules.zip
```

以一个简单的 JavaScript 文件为例。将以下代码保存为 `hello.js`：

```javascript
args = args.slice(1);
print('Hello', ...args);
```

你可以使用下面的命令运行：

```bash
wasmedge --dir .:. wasmedge_quickjs.wasm hello.js 1 2 3
```

输出为：

```bash
Hello 1 2 3
```

[qjs_tf.wasm](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/js/qjs_tf.wasm) 是一个被贬意为 WebAssembly 的包含 [WasmEdge Tensorflow 扩展](https://www.secondstate.io/articles/wasi-tensorflow/) 的 JavaScript 解释器。要运行 [qjs_tf.wasm](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/js/qjs_tf.wasm)，你必须使用 `wasmedge-tensorflow-lite` CLI 工具，这是一个内置了 Tensorflow-Lite 扩展的 WasmEdge 构建版本。你可以下载一个完整的[基于 Tensorflow 的 JavaScript 示例](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo) 进行图像分类。

```bash
# Download the Tensorflow example
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js

$ wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js
label: Hot dog
confidence: 0.8941176470588236
```

## CLI 工具的 Docker 镜像

本节中的 Docker 镜像主要用于开发目的。它允许你在容器化的 Linux 环境中使用 WasmEdge 工具。如果你想要容器化 WASM 应用程序，请查看[此处](../getting-started/quick_start_docker.md)的内容。

`wasmedge/slim:{version}` Docker 镜像提供了使用 [DockerSlim](https://dockersl.im) 构建的精简 WasmEdge 镜像，每次发布都会更新。

- 镜像 `wasmedge/slim-runtime:{version}` 仅包含具有 `wasmedge` 命令的 WasmEdge runtime。
- 镜像 `wasmedge/slim:{version}` 包含以下命令行实用程序：
  - `wasmedge`
  - `wasmedge compile`
- 镜像 `wasmedge/slim-tf:{version}` 包含以下命令行实用程序 (在 0.13.0 版本之后不再推荐使用)：
  - `wasmedge`
  - `wasmedge compile`
  - `wasmedge-tensorflow-lite`
  - `wasmedge-tensorflow`
  - `show-tflite-tensor`
- 发布 Docker 镜像的工作目录是 `/app`。

### Dockerslim 示例

成功拉取 Docker 镜像后，你可以使用 `wasmedge compile` 和 `wasmedge` 进行 AOT 编译 WASM 文件和运行 WASM 应用程序。

```bash
$ docker pull wasmedge/slim:{{ wasmedge_version }}

$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge compile hello.wasm hello.aot.wasm
[2022-07-07 08:15:49.154] [info] compile start
[2022-07-07 08:15:49.163] [info] verify start
[2022-07-07 08:15:49.169] [info] optimize start
[2022-07-07 08:15:49.808] [info] codegen start
[2022-07-07 08:15:50.419] [info] output start
[2022-07-07 08:15:50.421] [info] compile done
[2022-07-07 08:15:50.422] [info] output start

$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge hello.aot.wasm world
hello
world
```

使用 `wasmedge-tensorflow-lite` ([link](https://github.com/WasmEdge/WasmEdge/tree/master/examples/js)):

<!-- prettier-ignore -->
:::note
`WasmEdge-tensorflow-tools` 已在 0.12.1 版本之后被弃用。我们将在未来更新使用 WasmEdge 插件。
:::

```bash
$ docker pull wasmedge/slim-tf:0.12.1
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js

$ docker run -it --rm -v $PWD:/app wasmedge/slim-tf:0.12.1 wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js
label:
Hot dog
confidence:
0.8941176470588236
```
","This code appears to be a documentation for the WasmEdge CLI tool, which is used to execute WebAssembly (WASM) files. The code snippet provides an overview of the tool's features and usage.

Here is a concise summary:

**Purpose:** The WasmEdge CLI tool allows users to execute WASM files on their local machine or in a containerized environment.

**Key Features:**

1. Execution modes: The tool can execute WASM files in two modes - AOT (Ahead-of-Time) compilation and Interpreted mode.
2. Command-line interface: Users can use the CLI tool to execute WASM files with various options, including reactor mode, directory binding, environment variable setting, statistics collection, and resource limits.
3. Docker image support: The tool provides a Docker image that allows users to run WasmEdge in a containerized environment.
4. Integration with TensorFlow Lite: The tool includes a TensorFlow Lite extension for executing machine learning models.

**Usage Examples:**

1. Running a simple WASM file:
```
wasmedge hello.wasm
```
2. Executing a WASM file in reactor mode:
```bash
wasmedge --reactor hello.wasm
```
3. Binding directories using the `--dir` option:
```bash
wasmedge --dir ./guest_path:host_path hello.wasm
```

**Potential Issues:**

1. Incompatibility issues with certain operating systems or WASM file formats.
2. Limited support for advanced features like multi-threading and SIMD instructions.

Overall, the WasmEdge CLI tool appears to be a powerful and flexible tool for executing WebAssembly files on various platforms."
docs/develop/deploy/kubernetes/knative.md,"---
sidebar_position: 8
---

# Knative

Knative is a platform-agnostic solution for running serverless deployments.

## Quick start

You can refer to [Kubernetes + containerd] to build a Kubernetes cluster. However, as the default runtime is replaced from runc to crun in this document, it is not suitable for the existing k8s cluster.

Here we set up crun as a runtimeClass in the kubernetes cluster, **rather than replace the default runtime**. Then deploy Knative serving service and run a WASM serverless service.

## Compile crun

Please refer to the document [crun](../../deploy/oci-runtime/crun.md) to build and compile crun with WasmEdge support.

```bash
# Install dependencies
$ sudo apt update
$ sudo apt install -y make git gcc build-essential pkgconf libtool \
    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
    go-md2man libtool autoconf python3 automake

# Compile crun
$ git clone https://github.com/containers/crun
$ cd crun
$ ./autogen.sh
$ ./configure --with-wasmedge
$ make
$ sudo make install
```

## Install and setup Containerd

To make things easy, we use apt to install containerd. Here is the [document for ubuntu](https://docs.docker.com/engine/install/ubuntu/) Once you have installed the containerd, edit the configuration `/etc/containerd/config.toml`.

```bash
$ cat /etc/containerd/config.toml

# comment this line to make cri wokrs
# disabled_plugins = [""cri""]

# add the following section to setup crun runtime, make sure the BinaryName equal to your crun binary path
[plugins]
  [plugins.cri]
    [plugins.cri.containerd]
      [plugins.cri.containerd.runtimes]
...
        [plugins.cri.containerd.runtimes.crun]
           runtime_type = ""io.containerd.runc.v2""
           pod_annotations = [""*.wasm.*"", ""wasm.*"", ""module.wasm.image/*"", ""*.module.wasm.image"", ""module.wasm.image/variant.*""]
           privileged_without_host_devices = false
           [plugins.cri.containerd.runtimes.crun.options]
             BinaryName = ""/usr/local/bin/crun""
...

# restart containerd service
$ sudo systemctl restart containerd

# check if crun works
$ ctr image pull docker.io/wasmedge/example-wasi:latest
$ ctr run --rm --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest wasm-example /wasi_example_main.wasm 50000000
Creating POD ...
Random number: -1678124602
Random bytes: [12, 222, 246, 184, 139, 182, 97, 3, 74, 155, 107, 243, 20, 164, 175, 250, 60, 9, 98, 25, 244, 92, 224, 233, 221, 196, 112, 97, 151, 155, 19, 204, 54, 136, 171, 93, 204, 129, 177, 163, 187, 52, 33, 32, 63, 104, 128, 20, 204, 60, 40, 183, 236, 220, 130, 41, 74, 181, 103, 178, 43, 231, 92, 211, 219, 47, 223, 137, 70, 70, 132, 96, 208, 126, 142, 0, 133, 166, 112, 63, 126, 164, 122, 49, 94, 80, 26, 110, 124, 114, 108, 90, 62, 250, 195, 19, 189, 203, 175, 189, 236, 112, 203, 230, 104, 130, 150, 39, 113, 240, 17, 252, 115, 42, 12, 185, 62, 145, 161, 3, 37, 161, 195, 138, 232, 39, 235, 222]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
```

## Creating a cluster with kubeadm

Refering to the tree documents [Installing kubeadm](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/), [Creating a cluster with kubeadm](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/) and [Install flannel cni](https://github.com/flannel-io/flannel#deploying-flannel-manually), to create a kubernetes cluster.

```bash
# install kubeadm
$ sudo apt-get update
$ sudo apt-get install -y apt-transport-https ca-certificates curl
$ sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
$ echo ""deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main"" | sudo tee /etc/apt/sources.list.d/kubernetes.list
$ sudo apt-get update
$ sudo apt-get install -y kubelet kubeadm kubectl
$ sudo apt-mark hold kubelet kubeadm kubectl

# create kubernetes cluster
$ swapoff -a
$ kubeadm init --pod-network-cidr=10.244.0.0/16 --cri-socket unix:///var/run/containerd/containerd.sock
$ export KUBECONFIG=/etc/kubernetes/admin.conf

# install cni
$ kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml

# untaint master node
$ kubectl taint nodes --all node-role.kubernetes.io/control-plane-

# add crun runtimeClass
$ cat > runtime.yaml <<EOF
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: crun
handler: crun
EOF
$ kubectl apply -f runtime.yaml

# Verify if the configuration works
$ kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" --overrides='{""kind"":""Pod"", ""apiVersion"":""v1"", ""spec"": {""hostNetwork"": true, ""runtimeClassName"": ""crun""}}' /wasi_example_main.wasm 50000000
Random number: 1534679888
Random bytes: [88, 170, 82, 181, 231, 47, 31, 34, 195, 243, 134, 247, 211, 145, 28, 30, 162, 127, 234, 208, 213, 192, 205, 141, 83, 161, 121, 206, 214, 163, 196, 141, 158, 96, 137, 151, 49, 172, 88, 234, 195, 137, 44, 152, 7, 130, 41, 33, 85, 144, 197, 25, 104, 236, 201, 91, 210, 17, 59, 248, 80, 164, 19, 10, 46, 116, 182, 111, 112, 239, 140, 16, 6, 249, 89, 176, 55, 6, 41, 62, 236, 132, 72, 70, 170, 7, 248, 176, 209, 218, 214, 160, 110, 93, 232, 175, 124, 199, 33, 144, 2, 147, 219, 236, 255, 95, 47, 15, 95, 192, 239, 63, 157, 103, 250, 200, 85, 237, 44, 119, 98, 211, 163, 26, 157, 248, 24, 0]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod ""wasi-demo"" deleted
```

## Setting up Knative Serving

Referring to [Installing Knative Serving using YAML files](https://knative.dev/docs/install/yaml-install/serving/install-serving-with-yaml/), install the knative serving service.

```bash
# install the Knative Serving component
$ kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.7.2/serving-crds.yaml
$ kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.7.2/serving-core.yaml

# install a networking layer
$ kubectl apply -f https://github.com/knative/net-kourier/releases/download/knative-v1.7.0/kourier.yaml
$ kubectl patch configmap/config-network \
  --namespace knative-serving \
  --type merge \
  --patch '{""data"":{""ingress-class"":""kourier.ingress.networking.knative.dev""}}'
$ kubectl --namespace kourier-system get service kourier

# verify the installation
$ kubectl get pods -n knative-serving

# open runtimeClass feature gate in Knative
$ kubectl patch configmap/config-features -n knative-serving --type merge --patch '{""data"":{""kubernetes.podspec-runtimeclassname"":""enabled""}}'
```

## WASM cases in Knative Serving

Now we can run a WASM serverless service.

```bash
# apply the serverless service configuration
# We need setup annotations, runtimeClassName, and ports.
$ cat > http-wasm-serverless.yaml <<EOF
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: http-wasm
  namespace: default
spec:
  template:
    metadata:
      annotations:
        module.wasm.image/variant: compat-smart
    spec:
      runtimeClassName: crun
      timeoutSeconds: 1
      containers:
      - name: http-server
        image: docker.io/wasmedge/example-wasi-http:latest
        ports:
        - containerPort: 1234
          protocol: TCP
        livenessProbe:
          tcpSocket:
            port: 1234
EOF

$ kubectl apply -f http-wasm-serverless.yaml

# wait for a while, and check if the serverless service is available
$ kubectl get ksvc http-wasm
NAME          URL                                              LATESTCREATED       LATESTREADY         READY   REASON
http-wasm     http://http-wasm.default.knative.example.com     http-wasm-00001     http-wasm-00001     True

# Try to call the service
# As we do not set up DNS, we can only call the service via Kourier, Knative Serving ingress port.
# get Kourier port which is 31997 in following example
$ kubectl --namespace kourier-system get service kourier
NAME      TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)                      AGE
kourier   LoadBalancer   10.105.58.134                     80:31997/TCP,443:31019/TCP   53d
$ curl -H ""Host: http-wasm.default.knative.example.com"" -d ""name=WasmEdge"" -X POST http://localhost:31997

# check the new start pod
$ kubectl get pods
NAME                                           READY   STATUS    RESTARTS   AGE
http-wasm-00001-deployment-748bdc7cf-96l4r     2/2     Running   0          19s
```
","The provided code is a document that describes the steps to set up and deploy Knative serving service on a Kubernetes cluster. The code snippet appears to be a guide for installing and configuring Knative, Containerd, and WasmEdge on a Ubuntu-based system.

Here's a concise summary of the purpose, functionality, and key components:

**Purpose:** This document provides a step-by-step guide to setting up a Kubernetes cluster with Containerd and Knative serving service, enabling WASM (WebAssembly) serverless deployments.

**Functionality:**

1. **Install Containerd**: Installs Containerd, a container runtime for Linux.
2. **Configure Containerd**: Configures Containerd to use the crun runtime.
3. **Create Kubernetes cluster with kubeadm**: Creates a Kubernetes cluster using kubeadm.
4. **Install Knative serving service**: Installs the Knative serving service on the Kubernetes cluster.
5. **Enable WASM support in Knative**: Configures Knative to enable WASM support.

**Key components:**

1. **Knative**: A platform-agnostic solution for running serverless deployments.
2. **Containerd**: A container runtime for Linux.
3. **Crun**: A lightweight container runtime.
4. **WasmEdge**: A WebAssembly runtime for Linux.
5. **Kubeadm**: A tool for creating Kubernetes clusters.

**Potential issues or areas for improvement:**

1. The document assumes a basic understanding of Docker and containerization concepts.
2. Some steps may require manual intervention, which could be automated in a more robust deployment script.
3. The document does not provide error handling mechanisms, which could lead to issues if something goes wrong during the setup process.
4. The document is specific to Ubuntu-based systems; it would be beneficial to provide instructions for other Linux distributions as well.

Overall, this document provides a comprehensive guide for setting up Knative serving service with WASM support on a Kubernetes cluster. However, some additional error handling mechanisms and automated deployment scripts could improve the robustness of the setup process."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/knative.md,"---
sidebar_position: 8
---

# Knative

Knative is a platform-agnostic solution for running serverless deployments.

## Quick start

You can refer to [Kubernetes + containerd] to build a Kubernetes cluster. However, as the default runtime is replaced from runc to crun in this document, it is not suitable for the existing k8s cluster.

Here we set up crun as a runtimeClass in the kubernetes cluster, **rather than replace the default runtime**. Then deploy Knative serving service and run a WASM serverless service.

## Compile crun

Please refer to the document [crun](../../deploy/oci-runtime/crun.md) to build and compile crun with WasmEdge support.

```bash
# Install dependencies
$ sudo apt update
$ sudo apt install -y make git gcc build-essential pkgconf libtool \
    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
    go-md2man libtool autoconf python3 automake

# Compile crun
$ git clone https://github.com/containers/crun
$ cd crun
$ ./autogen.sh
$ ./configure --with-wasmedge
$ make
$ sudo make install
```

## Install and setup Containerd

To make things easy, we use apt to install containerd. Here is the [document for ubuntu](https://docs.docker.com/engine/install/ubuntu/) Once you have installed the containerd, edit the configuration `/etc/containerd/config.toml`.

```bash
$ cat /etc/containerd/config.toml

# comment this line to make cri wokrs
# disabled_plugins = [""cri""]

# add the following section to setup crun runtime, make sure the BinaryName equal to your crun binary path
[plugins]
  [plugins.cri]
    [plugins.cri.containerd]
      [plugins.cri.containerd.runtimes]
...
        [plugins.cri.containerd.runtimes.crun]
           runtime_type = ""io.containerd.runc.v2""
           pod_annotations = [""*.wasm.*"", ""wasm.*"", ""module.wasm.image/*"", ""*.module.wasm.image"", ""module.wasm.image/variant.*""]
           privileged_without_host_devices = false
           [plugins.cri.containerd.runtimes.crun.options]
             BinaryName = ""/usr/local/bin/crun""
...

# restart containerd service
$ sudo systemctl restart containerd

# check if crun works
$ ctr image pull docker.io/wasmedge/example-wasi:latest
$ ctr run --rm --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest wasm-example /wasi_example_main.wasm 50000000
Creating POD ...
Random number: -1678124602
Random bytes: [12, 222, 246, 184, 139, 182, 97, 3, 74, 155, 107, 243, 20, 164, 175, 250, 60, 9, 98, 25, 244, 92, 224, 233, 221, 196, 112, 97, 151, 155, 19, 204, 54, 136, 171, 93, 204, 129, 177, 163, 187, 52, 33, 32, 63, 104, 128, 20, 204, 60, 40, 183, 236, 220, 130, 41, 74, 181, 103, 178, 43, 231, 92, 211, 219, 47, 223, 137, 70, 70, 132, 96, 208, 126, 142, 0, 133, 166, 112, 63, 126, 164, 122, 49, 94, 80, 26, 110, 124, 114, 108, 90, 62, 250, 195, 19, 189, 203, 175, 189, 236, 112, 203, 230, 104, 130, 150, 39, 113, 240, 17, 252, 115, 42, 12, 185, 62, 145, 161, 3, 37, 161, 195, 138, 232, 39, 235, 222]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
```

## Creating a cluster with kubeadm

Refering to the tree documents [Installing kubeadm](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/), [Creating a cluster with kubeadm](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/) and [Install flannel cni](https://github.com/flannel-io/flannel#deploying-flannel-manually), to create a kubernetes cluster.

```bash
# install kubeadm
$ sudo apt-get update
$ sudo apt-get install -y apt-transport-https ca-certificates curl
$ sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
$ echo ""deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main"" | sudo tee /etc/apt/sources.list.d/kubernetes.list
$ sudo apt-get update
$ sudo apt-get install -y kubelet kubeadm kubectl
$ sudo apt-mark hold kubelet kubeadm kubectl

# create kubernetes cluster
$ swapoff -a
$ kubeadm init --pod-network-cidr=10.244.0.0/16 --cri-socket unix:///var/run/containerd/containerd.sock
$ export KUBECONFIG=/etc/kubernetes/admin.conf

# install cni
$ kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml

# untaint master node
$ kubectl taint nodes --all node-role.kubernetes.io/control-plane-

# add crun runtimeClass
$ cat > runtime.yaml <<EOF
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: crun
handler: crun
EOF
$ kubectl apply -f runtime.yaml

# Verify if the configuration works
$ kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" --overrides='{""kind"":""Pod"", ""apiVersion"":""v1"", ""spec"": {""hostNetwork"": true, ""runtimeClassName"": ""crun""}}' /wasi_example_main.wasm 50000000
Random number: 1534679888
Random bytes: [88, 170, 82, 181, 231, 47, 31, 34, 195, 243, 134, 247, 211, 145, 28, 30, 162, 127, 234, 208, 213, 192, 205, 141, 83, 161, 121, 206, 214, 163, 196, 141, 158, 96, 137, 151, 49, 172, 88, 234, 195, 137, 44, 152, 7, 130, 41, 33, 85, 144, 197, 25, 104, 236, 201, 91, 210, 17, 59, 248, 80, 164, 19, 10, 46, 116, 182, 111, 112, 239, 140, 16, 6, 249, 89, 176, 55, 6, 41, 62, 236, 132, 72, 70, 170, 7, 248, 176, 209, 218, 214, 160, 110, 93, 232, 175, 124, 199, 33, 144, 2, 147, 219, 236, 255, 95, 47, 15, 95, 192, 239, 63, 157, 103, 250, 200, 85, 237, 44, 119, 98, 211, 163, 26, 157, 248, 24, 0]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod ""wasi-demo"" deleted
```

## Setting up Knative Serving

Referring to [Installing Knative Serving using YAML files](https://knative.dev/docs/install/yaml-install/serving/install-serving-with-yaml/), install the knative serving service.

```bash
# install the Knative Serving component
$ kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.7.2/serving-crds.yaml
$ kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.7.2/serving-core.yaml

# install a networking layer
$ kubectl apply -f https://github.com/knative/net-kourier/releases/download/knative-v1.7.0/kourier.yaml
$ kubectl patch configmap/config-network \
  --namespace knative-serving \
  --type merge \
  --patch '{""data"":{""ingress-class"":""kourier.ingress.networking.knative.dev""}}'
$ kubectl --namespace kourier-system get service kourier

# verify the installation
$ kubectl get pods -n knative-serving

# open runtimeClass feature gate in Knative
$ kubectl patch configmap/config-features -n knative-serving --type merge --patch '{""data"":{""kubernetes.podspec-runtimeclassname"":""enabled""}}'
```

## WASM cases in Knative Serving

Now we can run a WASM serverless service.

```bash
# apply the serverless service configuration
# We need setup annotations, runtimeClassName, and ports.
$ cat > http-wasm-serverless.yaml <<EOF
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: http-wasm
  namespace: default
spec:
  template:
    metadata:
      annotations:
        module.wasm.image/variant: compat-smart
    spec:
      runtimeClassName: crun
      timeoutSeconds: 1
      containers:
      - name: http-server
        image: docker.io/wasmedge/example-wasi-http:latest
        ports:
        - containerPort: 1234
          protocol: TCP
        livenessProbe:
          tcpSocket:
            port: 1234
EOF

$ kubectl apply -f http-wasm-serverless.yaml

# wait for a while, and check if the serverless service is available
$ kubectl get ksvc http-wasm
NAME          URL                                              LATESTCREATED       LATESTREADY         READY   REASON
http-wasm     http://http-wasm.default.knative.example.com     http-wasm-00001     http-wasm-00001     True

# Try to call the service
# As we do not set up DNS, we can only call the service via Kourier, Knative Serving ingress port.
# get Kourier port which is 31997 in following example
$ kubectl --namespace kourier-system get service kourier
NAME      TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)                      AGE
kourier   LoadBalancer   10.105.58.134                     80:31997/TCP,443:31019/TCP   53d
$ curl -H ""Host: http-wasm.default.knative.example.com"" -d ""name=WasmEdge"" -X POST http://localhost:31997

# check the new start pod
$ kubectl get pods
NAME                                           READY   STATUS    RESTARTS   AGE
http-wasm-00001-deployment-748bdc7cf-96l4r     2/2     Running   0          19s
```
","**Summary**

The provided code is a series of steps to deploy a Kubernetes cluster with Knative Serving using `kubeadm` and run a WASM (WebAssembly) serverless service. The deployment process involves:

1. Setting up a Kubernetes cluster using `kubeadm`.
2. Installing the `crun` runtime, which allows for running WASM applications.
3. Creating a `RuntimeClass` to enable crun as a runtime option.
4. Deploying Knative Serving and Kourier networking layer.
5. Configuring the WASM service with annotations and ports.
6. Running the WASM serverless service using Knative Serving.

**Key Components**

1. **Kubeadm**: Used for setting up the Kubernetes cluster.
2. **Crun**: A runtime that allows running WASM applications.
3. **Knative Serving**: A platform for deploying serverless functions.
4. **Kourier**: A networking layer used in Knative Serving.

**Potential Issues and Areas for Improvement**

1. The deployment process assumes a clean slate, but in a real-world scenario, you might need to consider existing dependencies, conflicts, or configuration issues.
2. The code assumes that the user has already installed `kubeadm` and related tools.
3. The `crun` runtime installation is complex and requires careful handling of dependencies.
4. The Knative Serving deployment involves several steps, which can be prone to errors if not executed correctly.
5. The WASM service configuration may require additional considerations for security, scalability, and performance.

**Recommendations**

1. Simplify the deployment process by using a more streamlined approach or tooling.
2. Consider using a managed Kubernetes platform or a cloud provider's offering to reduce administrative burden.
3. Provide more detailed documentation on potential issues and troubleshooting steps.
4. Optimize the configuration for security, scalability, and performance considerations.
5. Use automated testing and validation tools to ensure consistency and reliability in the deployment process."
docs/develop/rust/http_service/client.md,"---
sidebar_position: 1
---

# HTTP client

WasmEdge allows Rust developers to use APIs they are already familiar with to access the Internet via the HTTP or HTTPS protocols. This chapter will cover HTTP client APIs and libraries to access external web services from your WasmEdge app. For HTTP servers in WasmEdge, please see [the next chapter](server).

<!-- prettier-ignore -->
:::note
Before we start, [you need to have Rust and WasmEdge installed](../setup.md).
Make sure that you read the [special notes on networking apps](../setup#special-notes-for-networking-apps) especially if you are compiling Rust programs on a Mac.
:::

We will discuss HTTP and HTTPS clients using popular Rust APIs.

- [The reqwest API](#the-reqwest-api)
- [The hyper API](#the-hyper-api)

## The reqwest API

The `reqwest` crate is a popular Rust library to create asynchronous HTTP clients. It is built on top of the `hyper` and `tokio` APIs. Many developers find it easier to use. But perhaps more importantly, many existing Rust applications use `reqwest`, and you can make them work in WasmEdge by simply patching the `reqwest` crate in `Cargo.toml` with simple patches! Build and run [the example](https://github.com/WasmEdge/wasmedge_reqwest_demo/) in WasmEdge as follows.

<!-- prettier-ignore -->
:::note
Non-blocking I/O means that the application program can keep multiple connections open simultaneously, and process data in and out of those connections as they come in. The program can either alternatingly poll those open connections or wait for incoming data to trigger async functions. That allows I/O intensive programs to run much faster, even in a single-threaded environment.
:::

```bash
git clone https://github.com/WasmEdge/wasmedge_reqwest_demo
cd wasmedge_reqwest_demo

# Build the Rust code
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release
# Use the AoT compiler to get better performance
wasmedge compile target/wasm32-wasi/release/http.wasm http.wasm
wasmedge compile target/wasm32-wasi/release/https.wasm https.wasm

# Run the HTTP GET and POST examples
wasmedge http.wasm

# Run the HTTPS GET and POST examples
wasmedge https.wasm
```

In your Rust application, import the standard [reqwest](https://crates.io/crates/reqwest) and [tokio](https://crates.io/crates/tokio) crates. You will also patch a few dependency crates to make them aware of the WasmEdge socket API. Just add the following lines to your `Cargo.toml`.

```toml
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }
socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }
hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }
reqwest = { git = ""https://github.com/second-state/wasi_reqwest.git"", branch = ""0.11.x"" }

[dependencies]
reqwest = { version = ""0.11"", default-features = false, features = [""rustls-tls""] }
tokio = { version = ""1"", features = [""rt"", ""macros"", ""net"", ""time""] }
```

<!-- prettier-ignore -->
:::note
The `Cargo.toml` here shows that TLS is enabled. If you need to compile it on the MacOS, you will need the [wasi-sdk version of clang](../setup#tls-on-macos).
:::

The [example Rust code](https://github.com/WasmEdge/wasmedge_reqwest_demo/blob/main/src/http.rs) below shows an HTTP GET request.

```rust
use std::collections::HashMap;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let resp = reqwest::get(""http://eu.httpbin.org/ip"")
        .await?
        .json::<HashMap<String, String>>()
        .await?;
    println!(""{:#?}"", resp);
    Ok(())
}
```

And here is an HTTP POST request.

```rust
    let client = reqwest::Client::new();

    let res = client
        .post(""http://eu.httpbin.org/post"")
        .body(""msg=WasmEdge"")
        .send()
        .await?;
    let body = res.text().await?;

    println!(""POST: {}"", body);
```

## The hyper API

The [hyper crate](https://crates.io/crates/hyper) is a widely used Rust library to create HTTP and HTTPS networking applications for both clients and servers. A key feature of the `hyper` crate is that it is based on the `tokio` runtime, which supports asynchronous network connections. Asynchronous HTTP or HTTPS requests do not block the execution of the calling application. It allows an application to make multiple concurrent HTTP requests and to process responses as they are received. That enables high-performance networking applications in WasmEdge. Build and run [the hyper example](https://github.com/WasmEdge/wasmedge_hyper_demo/) in WasmEdge as follows.

```bash
git clone https://github.com/WasmEdge/wasmedge_hyper_demo
cd wasmedge_hyper_demo/client

# Build the Rust code
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release
# Use the AoT compiler to get better performance
wasmedge compile target/wasm32-wasi/release/wasmedge_hyper_client.wasm wasmedge_hyper_client.wasm

# Run the example
wasmedge wasmedge_hyper_client.wasm
```

In your Rust application, import the [hyper](https://crates.io/crates/hyper) crate,
and patch it with WasmEdge sockets patches.
Just add the following line to your `Cargo.toml`.

```toml
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }
socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }
hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }

[dependencies]
hyper = { version = ""0.14"", features = [""full""] }
tokio = { version = ""1"", features = [ ""rt"", ""macros"", ""net"", ""time"", ""io-util"" ] }
```

The HTTPS version of the demo is as follows.

```bash
// Build
cd wasmedge_hyper_demo/client-https
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release
wasmedge compile target/wasm32-wasi/release/wasmedge_hyper_client_https.wasm wasmedge_hyper_client_https.wasm

// Run
wasmedge wasmedge_hyper_client_https.wasm
```

In the HTTPS version of `Cargo.toml`, you just need to import the standard [hyper-rustls](https://crates.io/crates/hyper-rustls), [rustls](https://crates.io/crates/rustls) and [webpki-roots](https://crates.io/crates/webpki-roots) crates with the same patches as above.

```toml
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }
socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }
hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }

[dependencies]
hyper = { version = ""0.14"", features = [""full""]}
hyper-rustls = { version = ""0.25"", default-features = false, features = [ ""http1"", ""tls12"", ""logging"", ""ring"", ""webpki-tokio"" ] }
rustls = { version = ""0.22"", default-features = false }
webpki-roots = ""0.26.1""

tokio = { version = ""1"", features = [""rt"", ""macros"", ""net"", ""time"", ""io-util""]}
pretty_env_logger = ""0.4.0""
```

<!-- prettier-ignore -->
:::note
If you need to compile `rustls` as shown in the `Cargo.toml` above on the MacOS, you will need the [wasi-sdk version of clang](../setup#tls-on-macos).
:::

The [Rust example code](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/client/src/main.rs) below shows an HTTP GET request.

```rust
async fn fetch_url_return_str (url: hyper::Uri) -> Result<()> {
    let client = Client::new();
    let mut res = client.get(url).await?;

    let mut resp_data = Vec::new();
    while let Some(next) = res.data().await {
        let chunk = next?;
        resp_data.extend_from_slice(&chunk);
    }
    println!(""{}"", String::from_utf8_lossy(&resp_data));
```

The [HTTPS example](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/client-https/src/main.rs) is slightly more complex.

```rust
async fn fetch_https_url(url: hyper::Uri) -> Result<()> {
    let https = wasmedge_hyper_rustls::connector::new_https_connector(
        wasmedge_rustls_api::ClientConfig::default(),
    );
    let client = Client::builder().build::<_, hyper::Body>(https);
    let res = client.get(url).await?;

    let body = hyper::body::to_bytes(res.into_body()).await.unwrap();
    println!(""{}"", String::from_utf8(body.into()).unwrap());
    Ok(())
}
```

And here is an HTTP POST request.

```rust
async fn post_url_return_str (url: hyper::Uri, post_body: &'static [u8]) -> Result<()> {
    let client = Client::new();
    let req = Request::builder()
        .method(Method::POST)
        .uri(url)
        .body(Body::from(post_body))?;
    let mut res = client.request(req).await?;

    let mut resp_data = Vec::new();
    while let Some(next) = res.data().await {
        let chunk = next?;
        resp_data.extend_from_slice(&chunk);
    }
    println!(""{}"", String::from_utf8_lossy(&resp_data));

    Ok(())
}
```
","**Summary**

The code provides an overview of creating HTTP clients in Rust using popular APIs: `reqwest` and `hyper`. It includes examples for making HTTP GET and POST requests, both with and without HTTPS encryption. The code assumes the use of WasmEdge, a WebAssembly runtime.

**Key Components**

1. **Reqwest API**: A popular Rust library for creating asynchronous HTTP clients.
2. **Hyper API**: A widely used Rust library for creating HTTP and HTTPS networking applications.
3. **Cargo.toml**: A file used to manage dependencies in a Rust project.
4. **WasmEdge patches**: Custom patches applied to certain crates (e.g., `reqwest`, `hyper`) to make them compatible with WasmEdge.

**Potential Issues**

1. **Dependencies**: The code assumes the use of specific versions of crates, which may not be compatible with future releases.
2. **Platform-specific issues**: The code includes notes about using WASI-sdk version of clang on MacOS for compiling certain dependencies.
3. **Compatibility**: The code may require modifications to work correctly with other WebAssembly runtimes.

**Areas for Improvement**

1. **Simplify dependency management**: Consider using a more robust dependency manager, such as cargo-workspaces or cargo-sub.
2. **Improve error handling**: Add more robust error handling and debugging mechanisms to the examples.
3. **Provide more documentation**: Include comments and documentation in the code to explain its purpose, usage, and potential edge cases."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/client.md,"---
sidebar_position: 1
---

# HTTP client

WasmEdge allows Rust developers to use APIs they are already familiar with to access the Internet via the HTTP or HTTPS protocols. This chapter will cover HTTP client APIs and libraries to access external web services from your WasmEdge app. For HTTP servers in WasmEdge, please see [the next chapter](server).

<!-- prettier-ignore -->
:::note
Before we start, [you need to have Rust and WasmEdge installed](../setup.md).
Make sure that you read the [special notes on networking apps](../setup#special-notes) especially if you are compiling Rust programs on a Mac.
:::

We will discuss HTTP and HTTPS clients using popular Rust APIs.

- [The reqwest API](#the-reqwest-api)
- [The hyper API](#the-hyper-api)

## The reqwest API

The `reqwest` crate is a popular Rust library to create asynchronous HTTP clients. It is built on top of the `hyper` and `tokio` APIs. Many developers find it easier to use. But perhaps more importantly, many existing Rust applications use `reqwest`, and you can make them work in WasmEdge by simply patching the `reqwest` crate in `Cargo.toml` with simple patches! Build and run [the example](https://github.com/WasmEdge/wasmedge_reqwest_demo/) in WasmEdge as follows.

<!-- prettier-ignore -->
:::note
Non-blocking I/O means that the application program can keep multiple connections open simultaneously, and process data in and out of those connections as they come in. The program can either alternatingly poll those open connections or wait for incoming data to trigger async functions. That allows I/O intensive programs to run much faster, even in a single-threaded environment.
:::

```bash
git clone https://github.com/WasmEdge/wasmedge_reqwest_demo
cd wasmedge_reqwest_demo

# Build the Rust code
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release
# Use the AoT compiler to get better performance
wasmedge compile target/wasm32-wasi/release/http.wasm http.wasm
wasmedge compile target/wasm32-wasi/release/https.wasm https.wasm

# Run the HTTP GET and POST examples
wasmedge http.wasm

# Run the HTTPS GET and POST examples
wasmedge https.wasm
```

In your Rust application, import the standard [reqwest](https://crates.io/crates/reqwest) and [tokio](https://crates.io/crates/tokio) crates. You will also patch a few dependency crates to make them aware of the WasmEdge socket API. Just add the following lines to your `Cargo.toml`.

```toml
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }
socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }
hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }
reqwest = { git = ""https://github.com/second-state/wasi_reqwest.git"", branch = ""0.11.x"" }

[dependencies]
reqwest = { version = ""0.11"", default-features = false, features = [""rustls-tls""] }
tokio = { version = ""1"", features = [""rt"", ""macros"", ""net"", ""time""] }
```

<!-- prettier-ignore -->
:::note
The `Cargo.toml` here shows that TLS is enabled. If you need to compile it on the MacOS, you will need the [wasi-sdk version of clang](../setup#tls-on-macos).
:::

The [example Rust code](https://github.com/WasmEdge/wasmedge_reqwest_demo/blob/main/src/http.rs) below shows an HTTP GET request.

```rust
use std::collections::HashMap;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let resp = reqwest::get(""http://eu.httpbin.org/ip"")
        .await?
        .json::<HashMap<String, String>>()
        .await?;
    println!(""{:#?}"", resp);
    Ok(())
}
```

And here is an HTTP POST request.

```rust
    let client = reqwest::Client::new();

    let res = client
        .post(""http://eu.httpbin.org/post"")
        .body(""msg=WasmEdge"")
        .send()
        .await?;
    let body = res.text().await?;

    println!(""POST: {}"", body);
```

## The hyper API

The [hyper crate](https://crates.io/crates/hyper) is a widely used Rust library to create HTTP and HTTPS networking applications for both clients and servers. A key feature of the `hyper` crate is that it is based on the `tokio` runtime, which supports asynchronous network connections. Asynchronous HTTP or HTTPS requests do not block the execution of the calling application. It allows an application to make multiple concurrent HTTP requests and to process responses as they are received. That enables high-performance networking applications in WasmEdge. Build and run [the hyper example](https://github.com/WasmEdge/wasmedge_hyper_demo/) in WasmEdge as follows.

```bash
git clone https://github.com/WasmEdge/wasmedge_hyper_demo
cd wasmedge_hyper_demo/client

# Build the Rust code
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release
# Use the AoT compiler to get better performance
wasmedge compile target/wasm32-wasi/release/wasmedge_hyper_client.wasm wasmedge_hyper_client.wasm

# Run the example
wasmedge wasmedge_hyper_client.wasm
```

In your Rust application, import the [hyper](https://crates.io/crates/hyper) crate, 
and patch it with WasmEdge sockets patches.
Just add the following line to your `Cargo.toml`.

```toml
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }
socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }
hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }

[dependencies]
hyper = { version = ""0.14"", features = [""full""] }
tokio = { version = ""1"", features = [ ""rt"", ""macros"", ""net"", ""time"", ""io-util"" ] }
```

The HTTPS version of the demo is as follows.

```bash
// Build
cd wasmedge_hyper_demo/client-https
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release
wasmedge compile target/wasm32-wasi/release/wasmedge_hyper_client_https.wasm wasmedge_hyper_client_https.wasm

// Run
wasmedge wasmedge_hyper_client_https.wasm
```

In the HTTPS version of `Cargo.toml`, you just need to import the standard [hyper-rustls](https://crates.io/crates/hyper-rustls), [rustls](https://crates.io/crates/rustls) and [webpki-roots](https://crates.io/crates/webpki-roots) crates with the same patches as above.

```
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }
socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }
hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }

[dependencies]
hyper = { version = ""0.14"", features = [""full""]}
hyper-rustls = { version = ""0.25"", default-features = false, features = [ ""http1"", ""tls12"", ""logging"", ""ring"", ""webpki-tokio"" ] }
rustls = { version = ""0.22"", default-features = false }
webpki-roots = ""0.26.1""

tokio = { version = ""1"", features = [""rt"", ""macros"", ""net"", ""time"", ""io-util""]}
pretty_env_logger = ""0.4.0""
```

<!-- prettier-ignore -->
:::note
If you need to compile `rustls` as shown in the `Cargo.toml` above on the MacOS, you will need the [wasi-sdk version of clang](../setup#compile-rust-tls-on-macos).
:::

The [Rust example code](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/client/src/main.rs) below shows an HTTP GET request.

```rust
async fn fetch_url_return_str (url: hyper::Uri) -> Result<()> {
    let client = Client::new();
    let mut res = client.get(url).await?;

    let mut resp_data = Vec::new();
    while let Some(next) = res.data().await {
        let chunk = next?;
        resp_data.extend_from_slice(&chunk);
    }
    println!(""{}"", String::from_utf8_lossy(&resp_data));
```

The [HTTPS example](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/client-https/src/main.rs) is slightly more complex.

```rust
async fn fetch_https_url(url: hyper::Uri) -> Result<()> {
    let https = wasmedge_hyper_rustls::connector::new_https_connector(
        wasmedge_rustls_api::ClientConfig::default(),
    );
    let client = Client::builder().build::<_, hyper::Body>(https);
    let res = client.get(url).await?;

    let body = hyper::body::to_bytes(res.into_body()).await.unwrap();
    println!(""{}"", String::from_utf8(body.into()).unwrap());
    Ok(())
}
```

And here is an HTTP POST request.

```rust
async fn post_url_return_str (url: hyper::Uri, post_body: &'static [u8]) -> Result<()> {
    let client = Client::new();
    let req = Request::builder()
        .method(Method::POST)
        .uri(url)
        .body(Body::from(post_body))?;
    let mut res = client.request(req).await?;

    let mut resp_data = Vec::new();
    while let Some(next) = res.data().await {
        let chunk = next?;
        resp_data.extend_from_slice(&chunk);
    }
    println!(""{}"", String::from_utf8_lossy(&resp_data));

    Ok(())
}
```

","**Summary**

This document provides an overview of using HTTP clients in Rust programming for WasmEdge, a WebAssembly runtime. It covers two popular libraries: `reqwest` and `hyper`, which are used to create asynchronous HTTP clients.

The document explains how to use these libraries with WasmEdge by:

1. Installing the required dependencies (e.g., Tokio, Hyper, and Rustls)
2. Patching the libraries to work with WasmEdge's socket API
3. Importing the patched libraries into your Rust project

It also provides example code for using these libraries to make HTTP GET and POST requests.

**Key Components**

1. `reqwest`: A popular Rust library for creating asynchronous HTTP clients.
2. `hyper`: A widely used Rust library for creating HTTP and HTTPS networking applications.
3. WasmEdge: A WebAssembly runtime that allows you to run Rust code in a sandboxed environment.
4. Tokio: A Rust async framework used by both `reqwest` and `hyper`.
5. Rustls: A Rust implementation of the TLS protocol used by `hyper-rustls`.

**Potential Issues**

1. Compatibility issues between WasmEdge's socket API and the patched libraries
2. Performance overhead due to patching and compatibility checks
3. Potential security risks if not properly patched or configured

Overall, this document provides a good starting point for using HTTP clients in Rust programming with WasmEdge, but it requires careful attention to compatibility and configuration details to ensure smooth operation."
docs/embed/c/reference/upgrade_to_0.14.0.md,"---
sidebar_position: 2
---

# Upgrade to WasmEdge 0.14.0

Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the `0.13.5` to the `0.14.0` version.

## Concepts

1. Introduced new APIs for `WasmEdge_ValType` struct and integrated with WASM values.

   The `WasmEdge_ValType` becomes a struct for supporting the [typed function reference proposal](https://github.com/WebAssembly/function-references) and [GC proposal](https://github.com/WebAssembly/gc).

   The enumerations `enum WasmEdge_ValType` and `enum WasmEdge_RefType` are renamed as `enum WasmEdge_ValTypeCode` and `enum WasmEdge_RefTypeCode`. Developers should use the following APIs to generate the `WasmEdge_ValType` structures:

   - `WasmEdge_ValTypeGenI32()`
   - `WasmEdge_ValTypeGenI64()`
   - `WasmEdge_ValTypeGenF32()`
   - `WasmEdge_ValTypeGenF64()`
   - `WasmEdge_ValTypeGenV128()`
   - `WasmEdge_ValTypeGenFuncRef()`
   - `WasmEdge_ValTypeGenExternRef()`

   And there's new APIs for checking the value types from the `WasmEdge_ValType` struct:

   - `WasmEdge_ValTypeIsEqual()`
   - `WasmEdge_ValTypeIsI32()`
   - `WasmEdge_ValTypeIsI64()`
   - `WasmEdge_ValTypeIsF32()`
   - `WasmEdge_ValTypeIsF64()`
   - `WasmEdge_ValTypeIsV128()`
   - `WasmEdge_ValTypeIsFuncRef()` for checking whether a type is a nullable or non-nullable function reference.
   - `WasmEdge_ValTypeIsExternRef()` for checking whether a type is a nullable or non-nullable external reference.
   - `WasmEdge_ValTypeIsRef()` for checking whether a type is a nullable or non-nullable reference.
   - `WasmEdge_ValTypeIsRefNull()` for checking whether a type is a nullable reference.

   The following APIs using value types as parameters and return values are affected:

   - `WasmEdge_FunctionTypeCreate()`
   - `WasmEdge_FunctionTypeGetParameters()`
   - `WasmEdge_FunctionTypeGetReturns()`
   - `WasmEdge_TableTypeCreate()`
   - `WasmEdge_TableTypeGetRefType()`: returns a `WasmEdge_ValType`, which is guaranteed as a reference type.
   - `WasmEdge_GlobalTypeCreate()`
   - `WasmEdge_GlobalTypeGetValType()`

   The following API is deleted:

   - `WasmEdge_ValueGenNullRef()`: please use `WasmEdge_ValueGenFuncRef()` or `WasmEdge_ValueGenExternRef()` instead.

2. Introduced `WasmEdge_Bytes` for loading and serialization.

   Rathar than the raw buffer, we recommand developers to use `WasmEdge_Bytes` and related APIs to manage the input and output buffer for loading and serializing a WASM binary.

   - `WasmEdge_BytesCreate()`: create a `WasmEdge_Bytes` and copy from buffer with size.
   - `WasmEdge_BytesWrap()`: wrap a `WasmEdge_Bytes` onto a buffer with size.
   - `WasmEdge_BytesDelete()`: delete a allocated `WasmEdge_Bytes`.

   For the old APIs, we also introduced the `WasmEdge_Bytes` version. The old APIs will be deprecated in the future.

   - `WasmEdge_CompilerCompileFromBytes()`: this API has the same behavior as `WasmEdge_CompilerCompileFromBuffer()`.
   - `WasmEdge_LoaderParseFromBytes()`: this API has the same behavior as `WasmEdge_LoaderParseFromBuffer()`.
   - `WasmEdge_LoaderSerializeASTModule()`: this API outputs a `WasmEdge_Bytes`, and the result should be deleted by the caller.
   - `WasmEdge_VMRegisterModuleFromBytes()`: this API has the same behavior as `WasmEdge_VMRegisterModuleFromBuffer()`.
   - `WasmEdge_VMRunWasmFromBytes()`: this API has the same behavior as `WasmEdge_VMRunWasmFromBuffer()`.
   - `WasmEdge_VMAsyncRunWasmFromBytes()`: this API has the same behavior as `WasmEdge_VMAsyncRunWasmFromBuffer()`.
   - `WasmEdge_VMLoadWasmFromBytes()`: this API has the same behavior as `WasmEdge_VMLoadWasmFromBuffer()`.

3. APIs of instances changed for the new proposal.

   For supporting the [typed function reference proposal](https://github.com/WebAssembly/function-references) and [GC proposal](https://github.com/WebAssembly/gc) proposal, the new API of table instance is needed for the defaultable reference values.

   - `WasmEdge_TableInstanceCreateWithInit()`: developers can use this API to create a table instance with default value.

   Furthermore, for type matching and mutation checking, the result error is needed.

   - `WasmEdge_GlobalInstanceSetValue()`: returns `WasmEdge_Result` for result, and error occurs when type not matched or mutation failed.

## Value type creation and checking

Before the version `0.13.5`, the `WasmEdge_ValType` is an `enum`:

```c
enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,
                                      WasmEdge_ValType_I32};
enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};
/* Create a function type: {i32, i32} -> {i32}. */
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

WasmEdge_FunctionTypeDelete(HostType);
```

After `0.14.0`, developers should use the APIs to generate the `WasmEdge_ValType`. This affects the APIs list above.

```c
WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(), WasmEdge_ValTypeGenI32()};
WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};
/* Create a function type: {i32, i32} -> {i32}. */
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

WasmEdge_FunctionTypeDelete(HostType);
```

## Use packaged buffer for loading

Before the version `0.13.5`, developers can use the raw buffer to load WASM binary:

```c
uint8_t WASM[] = {/* WASM header */
                  0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
                  /* Type section */
                  0x01, 0x07, 0x01,
                  /* function type {i32, i32} -> {i32} */
                  0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
                  /* Import section */
                  0x02, 0x13, 0x01,
                  /* module name: ""extern"" */
                  0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
                  /* extern name: ""func-add"" */
                  0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
                  /* import desc: func 0 */
                  0x00, 0x00,
                  /* Function section */
                  0x03, 0x02, 0x01, 0x00,
                  /* Export section */
                  0x07, 0x0A, 0x01,
                  /* export name: ""addTwo"" */
                  0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
                  /* export desc: func 0 */
                  0x00, 0x01,
                  /* Code section */
                  0x0A, 0x0A, 0x01,
                  /* code body */
                  0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};

WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
WasmEdge_ASTModuleContext *ASTCxt = NULL;
WasmEdge_Result Res;

/* Load WASM or compiled-WASM from the buffer. */
Res = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, WASM, sizeof(WASM));
if (!WasmEdge_ResultOK(Res)) {
  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
}
/* The output AST module context should be destroyed. */
WasmEdge_ASTModuleDelete(ASTCxt);

WasmEdge_LoaderDelete(LoadCxt);
```

After `0.14.0`, we recommanded developers use the `WasmEdge_Bytes` related APIs instead. The old APIs still work, but will be deprecated in the future.

```c
uint8_t WASM[] = {/* WASM header */
                  0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
                  /* Type section */
                  0x01, 0x07, 0x01,
                  /* function type {i32, i32} -> {i32} */
                  0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
                  /* Import section */
                  0x02, 0x13, 0x01,
                  /* module name: ""extern"" */
                  0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
                  /* extern name: ""func-add"" */
                  0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
                  /* import desc: func 0 */
                  0x00, 0x00,
                  /* Function section */
                  0x03, 0x02, 0x01, 0x00,
                  /* Export section */
                  0x07, 0x0A, 0x01,
                  /* export name: ""addTwo"" */
                  0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
                  /* export desc: func 0 */
                  0x00, 0x01,
                  /* Code section */
                  0x0A, 0x0A, 0x01,
                  /* code body */
                  0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};

WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
WasmEdge_ASTModuleContext *ASTCxt = NULL;
WasmEdge_Result Res;
/* Wrap onto the `WASM`. */
WasmEdge_Bytes Bytes = WasmEdge_BytesWrap(WASM, sizeof(WASM));
/*
 * If developers want to copy from buffer, use the `WasmEdge_BytesCreate()`
 * instead. The created `WasmEdge_Bytes` should be destroyed.
 */

/* Load WASM or compiled-WASM from the buffer. */
Res = WasmEdge_LoaderParseFromBytes(LoadCxt, &ASTCxt, Bytes);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
}
/* The output AST module context should be destroyed. */
WasmEdge_ASTModuleDelete(ASTCxt);

WasmEdge_LoaderDelete(LoadCxt);
```
","**Upgrade to WasmEdge 0.14.0**

The provided documentation outlines the changes and guidelines for upgrading from WasmEdge version 0.13.5 to 0.14.0. The upgrade focuses on breaking changes in the C API, new APIs for value type creation and checking, and improved buffer management using `WasmEdge_Bytes`.

**Key Changes:**

1. **Value Type Creation and Checking:** The `WasmEdge_ValType` enum has been replaced with a struct. Developers must use the new APIs to create and check value types, such as `WasmEdge_ValTypeGenI32()` and `WasmEdge_ValTypeIsEqual()`.
2. **Buffer Management:** WasmEdge 0.14.0 introduces `WasmEdge_Bytes` for loading and serialization of WASM binaries. Developers should use `WasmEdge_BytesCreate()`, `WasmEdge_BytesWrap()`, or `WasmEdge_BytesCopy()` instead of raw buffers.
3. **API Changes:** Some APIs, like `WasmEdge_TableInstanceCreateWithInit()`, have been added to support the typed function reference and GC proposals.

**Recommendations:**

1. Update code that uses `WasmEdge_ValType` enum values to use the new value type creation and checking APIs.
2. Replace raw buffers with `WasmEdge_Bytes` for loading and serialization of WASM binaries.
3. Review code that uses deprecated APIs, such as `WasmEdge_ValueGenNullRef()`, and update it to use the recommended replacements.

**Code Example:**

The example code demonstrates how to create a Wasm module using `WasmEdge_Bytes` instead of a raw buffer:
```c
// Create a WasmEdge Bytes object from a raw buffer
uint8_t wasm[] = {/* WASM binary data */};
WasmEdge_Bytes bytes = WasmEdge_BytesWrap(wasm, sizeof(wasm));

// Load the Wasm module from the Bytes object
WasmEdge_LoaderContext *loaderCxt = WasmEdge_LoaderCreate(NULL);
WasmEdge_ASTModuleContext *astCxt = NULL;
WasmEdge_Result res;

res = WasmEdge_LoaderParseFromBytes(loaderCxt, &astCxt, bytes);
if (!WasmEdge_ResultOK(res)) {
    printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(res));
}
```
**Conclusion:**

Upgrading to WasmEdge 0.14.0 requires careful consideration of the breaking changes in the C API and adoption of new APIs for value type creation and checking, as well as improved buffer management using `WasmEdge_Bytes`. By following these guidelines, developers can ensure a smooth transition to the latest version of WasmEdge."
i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.14.0.md,"---
sidebar_position: 2
---

# Upgrade to WasmEdge 0.14.0

Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the `0.13.5` to the `0.14.0` version.

## Concepts

1. Introduced new APIs for `WasmEdge_ValType` struct and integrated with WASM values.

   The `WasmEdge_ValType` becomes a struct for supporting the [typed function reference proposal](https://github.com/WebAssembly/function-references) and [GC proposal](https://github.com/WebAssembly/gc).

   The enumerations `enum WasmEdge_ValType` and `enum WasmEdge_RefType` are renamed as `enum WasmEdge_ValTypeCode` and `enum WasmEdge_RefTypeCode`. Developers should use the following APIs to generate the `WasmEdge_ValType` structures:

   - `WasmEdge_ValTypeGenI32()`
   - `WasmEdge_ValTypeGenI64()`
   - `WasmEdge_ValTypeGenF32()`
   - `WasmEdge_ValTypeGenF64()`
   - `WasmEdge_ValTypeGenV128()`
   - `WasmEdge_ValTypeGenFuncRef()`
   - `WasmEdge_ValTypeGenExternRef()`

   And there's new APIs for checking the value types from the `WasmEdge_ValType` struct:

   - `WasmEdge_ValTypeIsEqual()`
   - `WasmEdge_ValTypeIsI32()`
   - `WasmEdge_ValTypeIsI64()`
   - `WasmEdge_ValTypeIsF32()`
   - `WasmEdge_ValTypeIsF64()`
   - `WasmEdge_ValTypeIsV128()`
   - `WasmEdge_ValTypeIsFuncRef()` for checking whether a type is a nullable or non-nullable function reference.
   - `WasmEdge_ValTypeIsExternRef()` for checking whether a type is a nullable or non-nullable external reference.
   - `WasmEdge_ValTypeIsRef()` for checking whether a type is a nullable or non-nullable reference.
   - `WasmEdge_ValTypeIsRefNull()` for checking whether a type is a nullable reference.

   The following APIs using value types as parameters and return values are affected:

   - `WasmEdge_FunctionTypeCreate()`
   - `WasmEdge_FunctionTypeGetParameters()`
   - `WasmEdge_FunctionTypeGetReturns()`
   - `WasmEdge_TableTypeCreate()`
   - `WasmEdge_TableTypeGetRefType()`: returns a `WasmEdge_ValType`, which is guaranteed as a reference type.
   - `WasmEdge_GlobalTypeCreate()`
   - `WasmEdge_GlobalTypeGetValType()`

   The following API is deleted:

   - `WasmEdge_ValueGenNullRef()`: please use `WasmEdge_ValueGenFuncRef()` or `WasmEdge_ValueGenExternRef()` instead.

2. Introduced `WasmEdge_Bytes` for loading and serialization.

   Rathar than the raw buffer, we recommand developers to use `WasmEdge_Bytes` and related APIs to manage the input and output buffer for loading and serializing a WASM binary.

   - `WasmEdge_BytesCreate()`: create a `WasmEdge_Bytes` and copy from buffer with size.
   - `WasmEdge_BytesWrap()`: wrap a `WasmEdge_Bytes` onto a buffer with size.
   - `WasmEdge_BytesDelete()`: delete a allocated `WasmEdge_Bytes`.

   For the old APIs, we also introduced the `WasmEdge_Bytes` version. The old APIs will be deprecated in the future.

   - `WasmEdge_CompilerCompileFromBytes()`: this API has the same behavior as `WasmEdge_CompilerCompileFromBuffer()`.
   - `WasmEdge_LoaderParseFromBytes()`: this API has the same behavior as `WasmEdge_LoaderParseFromBuffer()`.
   - `WasmEdge_LoaderSerializeASTModule()`: this API outputs a `WasmEdge_Bytes`, and the result should be deleted by the caller.
   - `WasmEdge_VMRegisterModuleFromBytes()`: this API has the same behavior as `WasmEdge_VMRegisterModuleFromBuffer()`.
   - `WasmEdge_VMRunWasmFromBytes()`: this API has the same behavior as `WasmEdge_VMRunWasmFromBuffer()`.
   - `WasmEdge_VMAsyncRunWasmFromBytes()`: this API has the same behavior as `WasmEdge_VMAsyncRunWasmFromBuffer()`.
   - `WasmEdge_VMLoadWasmFromBytes()`: this API has the same behavior as `WasmEdge_VMLoadWasmFromBuffer()`.

3. APIs of instances changed for the new proposal.

   For supporting the [typed function reference proposal](https://github.com/WebAssembly/function-references) and [GC proposal](https://github.com/WebAssembly/gc) proposal, the new API of table instance is needed for the defaultable reference values.

   - `WasmEdge_TableInstanceCreateWithInit()`: developers can use this API to create a table instance with default value.

   Furthermore, for type matching and mutation checking, the result error is needed.

   - `WasmEdge_GlobalInstanceSetValue()`: returns `WasmEdge_Result` for result, and error occurs when type not matched or mutation failed.

## Value type creation and checking

Before the version `0.13.5`, the `WasmEdge_ValType` is an `enum`:

```c
enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,
                                      WasmEdge_ValType_I32};
enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};
/* Create a function type: {i32, i32} -> {i32}. */
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

WasmEdge_FunctionTypeDelete(HostType);
```

After `0.14.0`, developers should use the APIs to generate the `WasmEdge_ValType`. This affects the APIs list above.

```c
WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(), WasmEdge_ValTypeGenI32()};
WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};
/* Create a function type: {i32, i32} -> {i32}. */
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

WasmEdge_FunctionTypeDelete(HostType);
```

## Use packaged buffer for loading

Before the version `0.13.5`, developers can use the raw buffer to load WASM binary:

```c
uint8_t WASM[] = {/* WASM header */
                  0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
                  /* Type section */
                  0x01, 0x07, 0x01,
                  /* function type {i32, i32} -> {i32} */
                  0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
                  /* Import section */
                  0x02, 0x13, 0x01,
                  /* module name: ""extern"" */
                  0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
                  /* extern name: ""func-add"" */
                  0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
                  /* import desc: func 0 */
                  0x00, 0x00,
                  /* Function section */
                  0x03, 0x02, 0x01, 0x00,
                  /* Export section */
                  0x07, 0x0A, 0x01,
                  /* export name: ""addTwo"" */
                  0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
                  /* export desc: func 0 */
                  0x00, 0x01,
                  /* Code section */
                  0x0A, 0x0A, 0x01,
                  /* code body */
                  0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};

WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
WasmEdge_ASTModuleContext *ASTCxt = NULL;
WasmEdge_Result Res;

/* Load WASM or compiled-WASM from the buffer. */
Res = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, WASM, sizeof(WASM));
if (!WasmEdge_ResultOK(Res)) {
  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
}
/* The output AST module context should be destroyed. */
WasmEdge_ASTModuleDelete(ASTCxt);

WasmEdge_LoaderDelete(LoadCxt);
```

After `0.14.0`, we recommanded developers use the `WasmEdge_Bytes` related APIs instead. The old APIs still work, but will be deprecated in the future.

```c
uint8_t WASM[] = {/* WASM header */
                  0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
                  /* Type section */
                  0x01, 0x07, 0x01,
                  /* function type {i32, i32} -> {i32} */
                  0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
                  /* Import section */
                  0x02, 0x13, 0x01,
                  /* module name: ""extern"" */
                  0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
                  /* extern name: ""func-add"" */
                  0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
                  /* import desc: func 0 */
                  0x00, 0x00,
                  /* Function section */
                  0x03, 0x02, 0x01, 0x00,
                  /* Export section */
                  0x07, 0x0A, 0x01,
                  /* export name: ""addTwo"" */
                  0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
                  /* export desc: func 0 */
                  0x00, 0x01,
                  /* Code section */
                  0x0A, 0x0A, 0x01,
                  /* code body */
                  0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};

WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
WasmEdge_ASTModuleContext *ASTCxt = NULL;
WasmEdge_Result Res;
/* Wrap onto the `WASM`. */
WasmEdge_Bytes Bytes = WasmEdge_BytesWrap(WASM, sizeof(WASM));
/*
 * If developers want to copy from buffer, use the `WasmEdge_BytesCreate()`
 * instead. The created `WasmEdge_Bytes` should be destroyed.
 */

/* Load WASM or compiled-WASM from the buffer. */
Res = WasmEdge_LoaderParseFromBytes(LoadCxt, &ASTCxt, Bytes);
if (!WasmEdge_ResultOK(Res)) {
  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));
}
/* The output AST module context should be destroyed. */
WasmEdge_ASTModuleDelete(ASTCxt);

WasmEdge_LoaderDelete(LoadCxt);
```
","**Upgrade to WasmEdge 0.14.0**

This document guides developers on upgrading their code from WasmEdge 0.13.5 to 0.14.0, focusing on the breaking changes in the C API.

**Breaking Changes:**

1. **Value Type Creation and Checking**: The `WasmEdge_ValType` struct has been redesigned for supporting typed function references and garbage collection proposals. Developers should use new APIs to generate `WasmEdge_ValType` structures.
2. **APIs of Instances Changed**: For type matching and mutation checking, the result error is needed. The `WasmEdge_GlobalInstanceSetValue()` API now returns a `WasmEdge_Result`.
3. **Packaged Buffer for Loading**: Instead of using raw buffers, developers are encouraged to use `WasmEdge_Bytes` related APIs to load WASM binaries.

**Key Changes:**

* Replaced `enum WasmEdge_ValType` with a struct
* Introduced new APIs for generating `WasmEdge_ValType` structures
* Added error handling for type matching and mutation checking in `WasmEdge_GlobalInstanceSetValue()`
* Encouraged use of `WasmEdge_Bytes` related APIs for loading WASM binaries

**Example Code:**

```c
// Before 0.14.0:
enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32, WasmEdge_ValType_I32};
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

// After 0.14.0:
WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(), WasmEdge_ValTypeGenI32()};
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
```

**Best Practices:**

* Use `WasmEdge_Bytes` related APIs for loading WASM binaries
* Handle errors returned by new APIs (e.g., `WasmEdge_GlobalInstanceSetValue()`)
* Update code to use new APIs for generating `WasmEdge_ValType` structures"
docs/contribute/source/build_from_src.md,"---
sidebar_position: 1
---

# Build Guide

Please follow this guide to build and test WasmEdge from the source code.

- [Linux](os/linux.md)
- [MacOS](os/macos.md)
- [Windows](os/windows.md)
- [Android](/category/build-and-run-wasmedge-on-android)
- [OpenWrt](os/openwrt.md)
- [RISC-V](os/riscv64.md)
- [OpenHarmony](os/openharmony.md)
- [seL4](os/sel4)
- [Raspberry Pi](os/raspberrypi.md)

<!-- prettier-ignore -->
:::note
If you just want the latest builds from the `HEAD` of the `master` branch, and do not want to build it yourself, you can download the release package directly from our Github Action's CI artifact. [Here is an example](https://github.com/WasmEdge/WasmEdge/actions/runs/1521549504#artifacts).
:::

## What Will Be Built

WasmEdge provides various tools for enabling different runtime environments for optimal performance. You can find that there are several wasmedge related tools:

1. `wasmedge` is the general wasm runtime.
   - `wasmedge` executes a `WASM` file in the interpreter mode or a compiled `WASM` file in the ahead-of-time compilation mode.
   - To disable building all tools, you can set the CMake option `WASMEDGE_BUILD_TOOLS` to `OFF`.
2. `wasmedgec` is the ahead-of-time `WASM` compiler.

   - `wasmedgec` compiles a general `WASM` file into a compiled `WASM` file.
   - To disable building the ahead-of-time compiler only, you can set the CMake option `WASMEDGE_BUILD_AOT_RUNTIME` to `OFF`.

   <!-- prettier-ignore -->
   :::note
   The usage of `wasmedgec` is equal to `wasmedge compile`. We decide to deprecate `wasmedgec` in the future.
   :::

3. `libwasmedge.so` is the WasmEdge C API shared library. (`libwasmedge.dylib` on MacOS and `wasmedge.dll` on Windows)
   - `libwasmedge.so`, `libwasmedge.dylib`, or `wasmedge.dll` provides the C API for the ahead-of-time compiler and the WASM runtime.
   - The APIs related to the ahead-of-time compiler will always fail if the CMake option `WASMEDGE_BUILD_AOT_RUNTIME` is set as `OFF`.
   - To disable building just the shared library, you can set the CMake option `WASMEDGE_BUILD_SHARED_LIB` to `OFF`.
4. `ssvm-qitc` is for AI applications and supports the ONNC runtime for AI models in the ONNX format.
   - If you want to try `ssvm-qitc`, please refer to [ONNC-Wasm](https://github.com/ONNC/onnc-wasm) project to set up the working environment and tryout several examples.
   - And here is our [tutorial for ONNC-WASM project(YouTube Video)](https://www.youtube.com/watch?v=cbiPuHMS-iQ).

## CMake Building Options

Developers can set the CMake options to customize the WasmEdge building.

1. `WASMEDGE_BUILD_TESTS`: build the WasmEdge tests. Default is `OFF`.
2. `WASMEDGE_USE_LLVM`: build with LLVM-based runtime for supporting Ahead-of-Time and Just-In-Time compiler. Default is `ON`.
3. `WASMEDGE_BUILD_SHARED_LIB`: build the WasmEdge shared library (`libwasmedge.so`, `libwasmedge.dylib`, or `wasmedge.dll`). Default is `ON`.
   - By default, the WasmEdge shared library will link to the LLVM shared library.
4. `WASMEDGE_BUILD_STATIC_LIB`: build the WasmEdge static library (`libwasmedge.a`, Linux and MacOS platforms, experimental). Default is `OFF`.
   - If this option is set as `ON`, the option `WASMEDGE_FORCE_DISABLE_LTO` will forcefully be set as `ON`.
   - If this option is set as `ON`, the `libz` and `libtinfo` on Linux platforms will be statically linked.
   - For linking with `libwasmedge.a`, developers should also add the `-ldl`, `-pthread`, `-lm`, and `-lstdc++` linker options on both Linux and MacOS platforms, and `-lrt` on Linux platforms.
5. `WASMEDGE_BUILD_TOOLS`: build the `wasmedge` and `wasmedgec` tools. Default is `ON`.
   - The `wasmedge` and `wasmedgec` tools will link to the WasmEdge shared library by default.
   - If this option is set as `ON` and `WASMEDGE_USE_LLVM` is set as `OFF`, the `wasmedgec` tool for the AOT compiler will not be built.
   - If this option is set as `ON` but the option `WASMEDGE_LINK_TOOLS_STATIC` is set as `OFF`, the option `WASMEDGE_BUILD_SHARED_LIB` will forcefully be set as `ON`.
   - If this option and the option `WASMEDGE_LINK_TOOLS_STATIC` are both set as `ON`, the `WASMEDGE_LINK_LLVM_STATIC` and `WASMEDGE_BUILD_STATIC_LIB` will both be set as `ON`, and the `wasmedge` and `wasmedgec` tools will link to the WasmEdge static library instead. In this case, the plug-ins will not work in tools.
6. `WASMEDGE_BUILD_PLUGINS`: build the WasmEdge plug-ins. Default is `ON`.
7. `WASMEDGE_BUILD_EXAMPLE`: build the WasmEdge examples. Default is `OFF`.
8. `WASMEDGE_FORCE_DISABLE_LTO`: forcefully turn off the link time optimization. Default is `OFF`.
9. `WASMEDGE_LINK_LLVM_STATIC`: link the LLVM and lld libraries statically (Linux and MacOS platforms only). Default is `OFF`.
10. `WASMEDGE_LINK_TOOLS_STATIC`: make the `wasmedge` and `wasmedgec` tools to link the WasmEdge library and LLVM libraries statically (Linux and MacOS platforms only). Default is `OFF`.
    - If the option `WASMEDGE_BUILD_TOOLS` and this option are both set as `ON`, the `WASMEDGE_LINK_LLVM_STATIC` will be set as `ON`.
11. `WASMEDGE_ENABLE_UB_SANITIZER`: enable the undefined behavior sanitizer. Default is `OFF`.
12. `WASMEDGE_PLUGIN_WASI_NN_BACKEND`: build the WasmEdge WASI-NN plug-in (Linux platforms only). Default is empty.
    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.
    - To build the WASI-NN plug-in with backend, please use `-DWASMEDGE_PLUGIN_WASI_NN_BACKEND=<backend_name>`.
    - To build the WASI-NN plug-in with multiple backends, please use `-DWASMEDGE_PLUGIN_WASI_NN_BACKEND=<backend_name1>,<backend_name2>`.
13. `WASMEDGE_PLUGIN_WASI_CRYPTO`: build the WasmEdge WASI-Crypto plug-in (Linux and MacOS platforms only). Default is `OFF`.
    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.
14. `WASMEDGE_PLUGIN_WASI_LOGGING`: build the WasmEdge WASI-Logging plug-in (Linux and MacOS platforms only). Default is `OFF`.
    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.
15. `WASMEDGE_PLUGIN_WASM_BPF`: build the WasmEdge wasm_bpf plugin (Linux platforms only). Default is `OFF`.
    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.
16. `WASMEDGE_PLUGIN_IMAGE`: build the WasmEdge image plugin (Linux and MacOS platforms only). Default is `OFF`.
    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.
17. `WASMEDGE_PLUGIN_TENSORFLOW`: build the WasmEdge TensorFlow plugin (Linux and MacOS platforms only). Default is `OFF`.
    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.
18. `WASMEDGE_PLUGIN_TENSORFLOWLITE`: build the WasmEdge TensorFlow-Lite plug-in (Linux and MacOS platforms only). Default is `OFF`.
    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.

## Build WasmEdge with Plug-ins

Developers can follow the steps to build WasmEdge with plug-ins from source.

- [WASI-NN (OpenVINO, PyTorch, or TensorFlow-Lite backends)](plugin/wasi_nn.md)
- [WASI-Crypto](plugin/wasi_crypto.md)
- [WasmEdge-Image](plugin/image.md)
- [WasmEdge-TensorFlow](plugin/tensorflow.md)
- [WasmEdge-TensorFlowLite](plugin/tensorflowlite.md)
- [WASI-Logging](plugin/wasi_logging.md)

## Run Tests

The tests are only available when the build option `WASMEDGE_BUILD_TESTS` is set to `ON`.

Users can use these tests to verify the correctness of WasmEdge binaries built.

```bash
cd <path/to/wasmedge/build_folder>
LD_LIBRARY_PATH=$(pwd)/lib/api ctest
```
","**Summary**

This document is a build guide for WasmEdge, a general-purpose WebAssembly runtime. It provides step-by-step instructions on how to build and test WasmEdge from source code. The guide covers various platforms, including Linux, MacOS, Windows, Android, OpenWrt, RISC-V, and others.

**Key Components**

1. **`wasmedge`**: the general wasm runtime, which executes WASM files in interpreter or ahead-of-time compilation modes.
2. **`wasmedgec`**: the ahead-of-time WASM compiler, which compiles general WASM files into compiled WASM files.
3. **`libwasmedge.so`** (or `libwasmedge.dylib` on MacOS, `wasmedge.dll` on Windows): the WasmEdge C API shared library.

**CMake Building Options**

WASMEdge provides various CMake options to customize its building process. Some notable options include:

1. **`WASMEDGE_BUILD_TESTS`**: build the WasmEdge tests.
2. **`WASMEDGE_USE_LLVM`**: use LLVM-based runtime for supporting Ahead-of-Time and Just-In-Time compilation.
3. **`WASMEDGE_BUILD_SHARED_LIB`**: build the WasmEdge shared library.
4. **`WASMEDGE_FORCE_DISABLE_LTO`**: forcefully turn off link time optimization.

**Building with Plug-ins**

The guide also provides instructions on how to build WasmEdge with various plug-ins, such as WASI-NN, WASI-Crypto, and WasmEdge-Image.

**Testing**

Tests are available when the `WASMEDGE_BUILD_TESTS` option is set to ON. Users can use these tests to verify the correctness of WasmEdge binaries built.

**Code Quality and Issues**

The code appears well-structured and follows best practices for maintainability. However, there might be issues with:

1. **Complexity**: Some parts of the code seem complex and difficult to understand.
2. **Error handling**: Error handling could be improved in certain places.
3. **Testing**: While tests are available, they may not cover all possible scenarios.

**Areas for Improvement**

Based on the analysis, areas for improvement include:

1. Simplifying complex code sections
2. Improving error handling mechanisms
3. Enhancing test coverage and scenario testing"
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/build_from_src.md,"---
sidebar_position: 1
---

# Build Guide

Please follow this guide to build and test WasmEdge from the source code.

- [Linux](os/linux.md)
- [MacOS](os/macos.md)
- [Windows](os/windows.md)
- [Android](/category/build-and-run-wasmedge-on-android)
- [OpenWrt](os/openwrt.md)
- [RISC-V](os/riscv64.md)
- [OpenHarmony](os/openharmony.md)
- [seL4](os/sel4)
- [Raspberry Pi](os/raspberrypi.md)

<!-- prettier-ignore -->
:::note
If you just want the latest builds from the `HEAD` of the `master` branch, and do not want to build it yourself, you can download the release package directly from our Github Action's CI artifact. [Here is an example](https://github.com/WasmEdge/WasmEdge/actions/runs/1521549504#artifacts).
:::

## What Will Be Built

WasmEdge provides various tools for enabling different runtime environments for optimal performance. You can find that there are several wasmedge related tools:

1. `wasmedge` is the general wasm runtime.
   - `wasmedge` executes a `WASM` file in the interpreter mode or a compiled `WASM` file in the ahead-of-time compilation mode.
   - To disable building all tools, you can set the CMake option `WASMEDGE_BUILD_TOOLS` to `OFF`.
2. `wasmedgec` is the ahead-of-time `WASM` compiler.

   - `wasmedgec` compiles a general `WASM` file into a compiled `WASM` file.
   - To disable building the ahead-of-time compiler only, you can set the CMake option `WASMEDGE_BUILD_AOT_RUNTIME` to `OFF`.

   <!-- prettier-ignore -->
   :::note
   The usage of `wasmedgec` is equal to `wasmedge compile`. We decide to deprecate `wasmedgec` in the future.
   :::

3. `libwasmedge.so` is the WasmEdge C API shared library. (`libwasmedge.dylib` on MacOS and `wasmedge.dll` on Windows)
   - `libwasmedge.so`, `libwasmedge.dylib`, or `wasmedge.dll` provides the C API for the ahead-of-time compiler and the WASM runtime.
   - The APIs related to the ahead-of-time compiler will always fail if the CMake option `WASMEDGE_BUILD_AOT_RUNTIME` is set as `OFF`.
   - To disable building just the shared library, you can set the CMake option `WASMEDGE_BUILD_SHARED_LIB` to `OFF`.
4. `ssvm-qitc` is for AI applications and supports the ONNC runtime for AI models in the ONNX format.
   - If you want to try `ssvm-qitc`, please refer to [ONNC-Wasm](https://github.com/ONNC/onnc-wasm) project to set up the working environment and tryout several examples.
   - And here is our [tutorial for ONNC-WASM project(YouTube Video)](https://www.youtube.com/watch?v=cbiPuHMS-iQ).

## CMake Building Options

Developers can set the CMake options to customize the WasmEdge building.

1. `WASMEDGE_BUILD_TESTS`: build the WasmEdge tests. Default is `OFF`.
2. `WASMEDGE_USE_LLVM`: build with LLVM-based runtime for supporting Ahead-of-Time and Just-In-Time compiler. Default is `ON`.
3. `WASMEDGE_BUILD_SHARED_LIB`: build the WasmEdge shared library (`libwasmedge.so`, `libwasmedge.dylib`, or `wasmedge.dll`). Default is `ON`.
   - By default, the WasmEdge shared library will link to the LLVM shared library.
4. `WASMEDGE_BUILD_STATIC_LIB`: build the WasmEdge static library (`libwasmedge.a`, Linux and MacOS platforms, experimental). Default is `OFF`.
   - If this option is set as `ON`, the option `WASMEDGE_FORCE_DISABLE_LTO` will forcefully be set as `ON`.
   - If this option is set as `ON`, the `libz` and `libtinfo` on Linux platforms will be statically linked.
   - For linking with `libwasmedge.a`, developers should also add the `-ldl`, `-pthread`, `-lm`, and `-lstdc++` linker options on both Linux and MacOS platforms, and `-lrt` on Linux platforms.
5. `WASMEDGE_BUILD_TOOLS`: build the `wasmedge` and `wasmedgec` tools. Default is `ON`.
   - The `wasmedge` and `wasmedgec` tools will link to the WasmEdge shared library by default.
   - If this option is set as `ON` and `WASMEDGE_USE_LLVM` is set as `OFF`, the `wasmedgec` tool for the AOT compiler will not be built.
   - If this option is set as `ON` but the option `WASMEDGE_LINK_TOOLS_STATIC` is set as `OFF`, the option `WASMEDGE_BUILD_SHARED_LIB` will forcefully be set as `ON`.
   - If this option and the option `WASMEDGE_LINK_TOOLS_STATIC` are both set as `ON`, the `WASMEDGE_LINK_LLVM_STATIC` and `WASMEDGE_BUILD_STATIC_LIB` will both be set as `ON`, and the `wasmedge` and `wasmedgec` tools will link to the WasmEdge static library instead. In this case, the plug-ins will not work in tools.
6. `WASMEDGE_BUILD_PLUGINS`: build the WasmEdge plug-ins. Default is `ON`.
7. `WASMEDGE_BUILD_EXAMPLE`: build the WasmEdge examples. Default is `OFF`.
8. `WASMEDGE_FORCE_DISABLE_LTO`: forcefully turn off the link time optimization. Default is `OFF`.
9. `WASMEDGE_LINK_LLVM_STATIC`: link the LLVM and lld libraries statically (Linux and MacOS platforms only). Default is `OFF`.
10. `WASMEDGE_LINK_TOOLS_STATIC`: make the `wasmedge` and `wasmedgec` tools to link the WasmEdge library and LLVM libraries statically (Linux and MacOS platforms only). Default is `OFF`.
    - If the option `WASMEDGE_BUILD_TOOLS` and this option are both set as `ON`, the `WASMEDGE_LINK_LLVM_STATIC` will be set as `ON`.
11. `WASMEDGE_ENABLE_UB_SANITIZER`: enable the undefined behavior sanitizer. Default is `OFF`.
12. `WASMEDGE_PLUGIN_WASI_NN_BACKEND`: build the WasmEdge WASI-NN plug-in (Linux platforms only). Default is empty.
    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.
    - To build the WASI-NN plug-in with backend, please use `-DWASMEDGE_PLUGIN_WASI_NN_BACKEND=<backend_name>`.
    - To build the WASI-NN plug-in with multiple backends, please use `-DWASMEDGE_PLUGIN_WASI_NN_BACKEND=<backend_name1>,<backend_name2>`.
13. `WASMEDGE_PLUGIN_WASI_CRYPTO`: build the WasmEdge WASI-Crypto plug-in (Linux and MacOS platforms only). Default is `OFF`.
    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.
14. `WASMEDGE_PLUGIN_WASI_LOGGING`: build the WasmEdge WASI-Logging plug-in (Linux and MacOS platforms only). Default is `OFF`.
    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.
15. `WASMEDGE_PLUGIN_WASM_BPF`: build the WasmEdge wasm_bpf plugin (Linux platforms only). Default is `OFF`.
    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.
16. `WASMEDGE_PLUGIN_IMAGE`: build the WasmEdge image plugin (Linux and MacOS platforms only). Default is `OFF`.
    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.
17. `WASMEDGE_PLUGIN_TENSORFLOW`: build the WasmEdge TensorFlow plugin (Linux and MacOS platforms only). Default is `OFF`.
    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.
18. `WASMEDGE_PLUGIN_TENSORFLOWLITE`: build the WasmEdge TensorFlow-Lite plug-in (Linux and MacOS platforms only). Default is `OFF`.
    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.

## Build WasmEdge with Plug-ins

Developers can follow the steps to build WasmEdge with plug-ins from source.

- [WASI-NN (OpenVINO, PyTorch, or TensorFlow-Lite backends)](plugin/wasi_nn.md)
- [WASI-Crypto](plugin/wasi_crypto.md)
- [WasmEdge-Image](plugin/image.md)
- [WasmEdge-TensorFlow](plugin/tensorflow.md)
- [WasmEdge-TensorFlowLite](plugin/tensorflowlite.md)
- [WASI-Logging](plugin/wasi_logging.md)

## Run Tests

The tests are only available when the build option `WASMEDGE_BUILD_TESTS` is set to `ON`.

Users can use these tests to verify the correctness of WasmEdge binaries built.

```bash
cd <path/to/wasmedge/build_folder>
LD_LIBRARY_PATH=$(pwd)/lib/api ctest
```
","Here is a concise summary of the provided code:

**Purpose:** The code provides a build guide for WasmEdge, a WebAssembly runtime, from source.

**Key Components:**

1. **Build Guide**: A step-by-step guide to building and testing WasmEdge on various platforms (Linux, MacOS, Windows, Android, OpenWrt, RISC-V, OpenHarmony, seL4, Raspberry Pi).
2. **CMake Building Options**: A list of CMake options that can be set to customize the build process.
3. **Tools and Libraries**: WasmEdge provides various tools and libraries, including `wasmedge` (wasm runtime), `wasmedgec` (aot compiler), `libwasmedge.so` (C API shared library).
4. **Plug-ins**: WasmEdge supports various plug-ins, such as WASI-NN, WASI-Crypto, WASM BPF, Image, TensorFlow, and TensorFlow-Lite.

**Potential Issues or Areas for Improvement:**

1. **Documentation**: The code is well-documented, but some sections could benefit from more detailed explanations.
2. **CMake Options**: The number of CMake options is extensive (18). Consider providing a summary or categorization to help users understand the available options and their impact on the build process.
3. **Plug-in Support**: The code provides support for various plug-ins, but some sections could benefit from more detailed information on how to use these plug-ins effectively.

**Recommendations:**

1. **Improve Code Organization**: Consider reorganizing the code to separate concerns (e.g., build guide, CMake options, tools and libraries, plug-ins).
2. **Enhance Search Functionality**: Provide a search function or index to help users quickly find specific information within the documentation.
3. **Provide Additional Examples**: Consider adding more examples or tutorials to illustrate how to use WasmEdge effectively with various platforms and plug-ins."
docs/start/usage/serverless/vercel.md,"---
sidebar_position: 5
---

# Rust and WebAssembly Serverless functions in Vercel

In this article, we will show you two serverless functions in Rust and WasmEdge deployed on Vercel. One is the image processing function, the other one is the TensorFlow inference function.

> For more insights on why WasmEdge on Vercel, please refer to the article [Rust and WebAssembly Serverless Functions in Vercel](https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/).

## Prerequisite

Since our demo WebAssembly functions are written in Rust, you will need a [Rust compiler](https://www.rust-lang.org/tools/install). Make sure that you install the `wasm32-wasi` compiler target as follows, in order to generate WebAssembly bytecode.

```bash
rustup target add wasm32-wasi
```

The demo application front end is written in [Next.js](https://nextjs.org/), and deployed on Vercel. We will assume that you already have the basic knowledge of how to work with Vercel.

## Example 1: Image processing

Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A [live demo](https://vercel-wasm-runtime.vercel.app/) deployed on Vercel is available.

Fork the [demo application’s GitHub repo](https://github.com/second-state/vercel-wasm-runtime) to get started. To deploy the application on Vercel, just [import the Github repo](https://vercel.com/docs/git#deploying-a-git-repository) from [Vercel for Github](https://vercel.com/docs/git/vercel-for-github) web page.

This repo is a standard Next.js application for the Vercel platform. The backend serverless function is in the [`api/functions/image_grayscale`](https://github.com/second-state/vercel-wasm-runtime/tree/main/api/functions/image-grayscale) folder. The [`src/main.rs`](https://github.com/second-state/vercel-wasm-runtime/blob/main/api/functions/image-grayscale/src/main.rs) file contains the Rust program’s source code. The Rust program reads image data from the `STDIN`, and then outputs the black-white image to the `STDOUT`.

```rust
use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&buf).unwrap();
  let img = image::load_from_memory(&buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif => {
      filtered.write_to(&mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ => {
      filtered.write_to(&mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&buf).unwrap();
  io::stdout().flush().unwrap();
}
```

You can use Rust’s `cargo` tool to build the Rust program into WebAssembly bytecode or native code.

```bash
cd api/functions/image-grayscale/
cargo build --release --target wasm32-wasi
```

Copy the build artifacts to the `api` folder.

```bash
cp target/wasm32-wasi/release/grayscale.wasm ../../
```

> Vercel runs [`api/pre.sh`](https://github.com/second-state/vercel-wasm-runtime/blob/main/api/pre.sh) upon setting up the serverless environment. It installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native `so` library for faster execution.

The [`api/hello.js`](https://github.com/second-state/vercel-wasm-runtime/blob/main/api/hello.js) file conforms Vercel serverless specification. It loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via `STDIN`. Notice [`api/hello.js`](https://github.com/second-state/vercel-wasm-runtime/blob/main/api/hello.js) runs the compiled `grayscale.so` file generated by [`api/pre.sh`](https://github.com/second-state/vercel-wasm-runtime/blob/main/api/pre.sh) for better performance.

```javascript
const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) => {
  const wasmedge = spawn(path.join(__dirname, 'wasmedge'), [
    path.join(__dirname, 'grayscale.so'),
  ]);

  let d = [];
  wasmedge.stdout.on('data', (data) => {
    d.push(data);
  });

  wasmedge.on('close', (code) => {
    let buf = Buffer.concat(d);

    res.setHeader('Content-Type', req.headers['image-type']);
    res.send(buf);
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
};
```

That's it. [Deploy the repo to Vercel](https://vercel.com/docs/git#deploying-a-git-repository) and you now have a Vercel Jamstack app with a high-performance Rust and WebAssembly based serverless backend.

## Example 2: AI inference

The [second demo](https://vercel-wasm-runtime.vercel.app/) application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.

It is in [the same GitHub repo](https://github.com/second-state/vercel-wasm-runtime) as the previous example but in the `tensorflow` branch. Note: when you [import this GitHub repo](https://vercel.com/docs/git#deploying-a-git-repository) on the Vercel website, it will create a [preview URL](https://vercel.com/docs/platform/deployments#preview) for each branch. The `tensorflow` branch would have its own deployment URL.

The backend serverless function for image classification is in the [`api/functions/image-classification`](https://github.com/second-state/vercel-wasm-runtime/tree/tensorflow/api/functions/image-classification) folder in the `tensorflow` branch. The [`src/main.rs`](https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/functions/image-classification/src/main.rs) file contains the Rust program’s source code. The Rust program reads image data from the `STDIN`, and then outputs the text output to the `STDOUT`. It utilizes the WasmEdge Tensorflow API to run the AI inference.

```rust
pub fn main() {
  // Step 1: Load the TFLite model
  let model_data: &[u8] = include_bytes!(""models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite"");
  let labels = include_str!(""models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt"");

  // Step 2: Read image from STDIN
  let mut buf = Vec::new();
  io::stdin().read_to_end(&mut buf).unwrap();

  // Step 3: Resize the input image for the tensorflow model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&buf, 224, 224);

  // Step 4: AI inference
  let mut session = wasmedge_tensorflow_interface::Session::new(&model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(""input"", &flat_img, &[1, 224, 224, 3])
         .run();
  let res_vec: Vec<u8> = session.get_output(""MobilenetV1/Predictions/Reshape_1"");

  // Step 5: Find the food label that responds to the highest probability in res_vec
  // ... ...
  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }

  // Step 6: Generate the output text
  let class_name = label_lines.next().unwrap().to_string();
  if max_value > 50 {
    println!(""It {} a <a href='https://www.google.com/search?q={}'>{}</a> in the picture"", confidence.to_string(), class_name, class_name);
  } else {
    println!(""It does not appears to be any food item in the picture."");
  }
}
```

You can use the `cargo` tool to build the Rust program into WebAssembly bytecode or native code.

```bash
cd api/functions/image-classification/
cargo build --release --target wasm32-wasi
```

Copy the build artifacts to the `api` folder.

```bash
cp target/wasm32-wasi/release/classify.wasm ../../
```

Again, the [`api/pre.sh`](https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/pre.sh) script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the `classify.wasm` bytecode program to the `classify.so` native shared library at the time of deployment.

The [`api/hello.js`](https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/hello.js) file conforms Vercel serverless specification. It loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via `STDIN`. Notice [`api/hello.js`](https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/hello.js) runs the compiled `classify.so` file generated by [`api/pre.sh`](https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/pre.sh) for better performance.

```javascript
const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) => {
  const wasmedge = spawn(
    path.join(__dirname, 'wasmedge-tensorflow-lite'),
    [path.join(__dirname, 'classify.so')],
    { env: { LD_LIBRARY_PATH: __dirname } },
  );

  let d = [];
  wasmedge.stdout.on('data', (data) => {
    d.push(data);
  });

  wasmedge.on('close', (code) => {
    res.setHeader('Content-Type', `text/plain`);
    res.send(d.join(''));
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
};
```

You can now [deploy your forked repo to Vercel](https://vercel.com/docs/git#deploying-a-git-repository) and have a web app for subject classification.

Next, it's your turn to use [the vercel-wasm-runtime repo](https://github.com/second-state/vercel-wasm-runtime) as a template to develop your own Rust serverless functions in Vercel. Looking forward to your great work.
","**Summary**

This documentation provides a tutorial on deploying Rust serverless functions on Vercel using the WasmEdge runtime. The tutorial covers two examples:

1. Image processing: a serverless function that turns an uploaded image into black and white.
2. AI inference: a serverless function that classifies the main subject in an uploaded image.

The code is written in Rust and compiled to WebAssembly bytecode, which is then executed by the WasmEdge runtime.

**Key components**

1. `wasm32-wasi` target: a compiler target for generating WebAssembly bytecode.
2. `cargo`: a build tool for building Rust projects.
3. `wasmedge-tensorflow-lite`: a runtime for executing Tensorflow models in WasmEdge.
4. `classify.so` and `grayscale.so`: native shared libraries generated by the `api/pre.sh` script.

**Potential issues and areas for improvement**

1. Error handling: the code does not handle errors well, especially when dealing with file input/output operations.
2. Performance optimization: the code can be optimized for better performance, such as using multi-threading or parallel processing.
3. Code organization: the code is organized in a single file, which makes it hard to maintain and extend.
4. Documentation: while the documentation provides a good overview of the tutorial, it lacks detailed explanations of the code.

**Recommendations**

1. Use a more robust error handling mechanism, such as `try-catch` blocks or error propagation using `Result`.
2. Optimize performance by utilizing multi-threading or parallel processing techniques.
3. Organize the code into separate modules and files to improve maintainability and scalability.
4. Provide additional documentation for the code, including explanations of complex algorithms and data structures."
docs/start/usage/serverless/netlify.md,"---
sidebar_position: 2
---

# WebAssembly Serverless Functions in Netlify

In this article we will show you two serverless functions in Rust and WasmEdge deployed on Netlify. One is the image processing function, the other one is the TensorFlow inference function.

> For more insights on why WasmEdge on Netlify, please refer to the article [WebAssembly Serverless Functions in Netlify](https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/).

## Prerequisite

Since our demo WebAssembly functions are written in Rust, you will need a [Rust compiler](https://www.rust-lang.org/tools/install). Make sure that you install the `wasm32-wasi` compiler target as follows, in order to generate WebAssembly bytecode.

```bash
rustup target add wasm32-wasi
```

The demo application front end is written in [Next.js](https://nextjs.org/), and deployed on Netlify. We will assume that you already have the basic knowledge of how to work with Next.js and Netlify.

## Example 1: Image processing

Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A [live demo](https://60fe22f9ff623f0007656040--reverent-hodgkin-dc1f51.netlify.app/) deployed on Netlify is available.

Fork the [demo application’s GitHub repo](https://github.com/second-state/netlify-wasm-runtime) to get started. To deploy the application on Netlify, just [add your github repo to Netlify](https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/).

This repo is a standard Next.js application for the Netlify platform. The backend serverless function is in the [`api/functions/image_grayscale`](https://github.com/second-state/netlify-wasm-runtime/tree/main/api/functions/image-grayscale) folder. The [`src/main.rs`](https://github.com/second-state/netlify-wasm-runtime/blob/main/api/functions/image-grayscale/src/main.rs) file contains the Rust program’s source code. The Rust program reads image data from the `STDIN`, and then outputs the black-white image to the `STDOUT`.

```rust
use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&buf).unwrap();
  let img = image::load_from_memory(&buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif => {
      filtered.write_to(&mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ => {
      filtered.write_to(&mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&buf).unwrap();
  io::stdout().flush().unwrap();
}
```

You can use Rust’s `cargo` tool to build the Rust program into WebAssembly bytecode or native code.

```bash
cd api/functions/image-grayscale/
cargo build --release --target wasm32-wasi
```

Copy the build artifacts to the `api` folder.

```bash
cp target/wasm32-wasi/release/grayscale.wasm ../../
```

> The Netlify function runs [`api/pre.sh`](https://github.com/second-state/netlify-wasm-runtime/blob/main/api/pre.sh) upon setting up the serverless environment. It installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native `so` library for faster execution.

The [`api/hello.js`](https://github.com/second-state/netlify-wasm-runtime/blob/main/api/hello.js) script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via `STDIN`. Notice [`api/hello.js`](https://github.com/second-state/netlify-wasm-runtime/blob/main/api/hello.js) runs the compiled `grayscale.so` file generated by [`api/pre.sh`](https://github.com/second-state/netlify-wasm-runtime/blob/main/api/pre.sh) for better performance.

```javascript
const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) => {
  const wasmedge = spawn(path.join(__dirname, 'wasmedge'), [
    path.join(__dirname, 'grayscale.so'),
  ]);

  let d = [];
  wasmedge.stdout.on('data', (data) => {
    d.push(data);
  });

  wasmedge.on('close', (code) => {
    let buf = Buffer.concat(d);

    res.setHeader('Content-Type', req.headers['image-type']);
    res.send(buf);
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
};
```

That's it. [Deploy the repo to Netlify](https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/) and you now have a Netlify Jamstack app with a high-performance Rust and WebAssembly based serverless backend.

## Example 2: AI inference

The [second demo](https://60ff7e2d10fe590008db70a9--reverent-hodgkin-dc1f51.netlify.app/) application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.

It is in [the same GitHub repo](https://github.com/second-state/netlify-wasm-runtime/tree/tensorflow) as the previous example but in the `tensorflow` branch. The backend serverless function for image classification is in the [`api/functions/image-classification`](https://github.com/second-state/netlify-wasm-runtime/tree/tensorflow/api/functions/image-classification) folder in the `tensorflow` branch. The [`src/main.rs`](https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/functions/image-classification/src/main.rs) file contains the Rust program’s source code. The Rust program reads image data from the `STDIN`, and then outputs the text output to the `STDOUT`. It utilizes the WasmEdge Tensorflow API to run the AI inference.

```rust
pub fn main() {
  // Step 1: Load the TFLite model
  let model_data: &[u8] = include_bytes!(""models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite"");
  let labels = include_str!(""models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt"");

  // Step 2: Read image from STDIN
  let mut buf = Vec::new();
  io::stdin().read_to_end(&mut buf).unwrap();

  // Step 3: Resize the input image for the tensorflow model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&buf, 224, 224);

  // Step 4: AI inference
  let mut session = wasmedge_tensorflow_interface::Session::new(&model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(""input"", &flat_img, &[1, 224, 224, 3])
         .run();
  let res_vec: Vec<u8> = session.get_output(""MobilenetV1/Predictions/Reshape_1"");

  // Step 5: Find the food label that responds to the highest probability in res_vec
  // ... ...
  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }

  // Step 6: Generate the output text
  let class_name = label_lines.next().unwrap().to_string();
  if max_value > 50 {
    println!(""It {} a <a href='https://www.google.com/search?q={}'>{}</a> in the picture"", confidence.to_string(), class_name, class_name);
  } else {
    println!(""It does not appears to be any food item in the picture."");
  }
}
```

You can use the `cargo` tool to build the Rust program into WebAssembly bytecode or native code.

```bash
cd api/functions/image-classification/
cargo build --release --target wasm32-wasi
```

Copy the build artifacts to the `api` folder.

```bash
cp target/wasm32-wasi/release/classify.wasm ../../
```

Again, the [`api/pre.sh`](https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/pre.sh) script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the `classify.wasm` bytecode program to the `classify.so` native shared library at the time of deployment.

The [`api/hello.js`](https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/hello.js) script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via `STDIN`. Notice [`api/hello.js`](https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/hello.js) runs the compiled `classify.so` file generated by [`api/pre.sh`](https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/pre.sh) for better performance.

```javascript
const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) => {
  const wasmedge = spawn(
    path.join(__dirname, 'wasmedge-tensorflow-lite'),
    [path.join(__dirname, 'classify.so')],
    { env: { LD_LIBRARY_PATH: __dirname } },
  );

  let d = [];
  wasmedge.stdout.on('data', (data) => {
    d.push(data);
  });

  wasmedge.on('close', (code) => {
    res.setHeader('Content-Type', `text/plain`);
    res.send(d.join(''));
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
};
```

You can now [deploy your forked repo to Netlify](https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/) and have a web app for subject classification.

Next, it's your turn to develop Rust serverless functions in Netlify using the [netlify-wasm-runtime repo](https://github.com/second-state/netlify-wasm-runtime) as a template. Looking forward to your great work.
","**Summary:**

The code provides a step-by-step guide on deploying WebAssembly (Wasm) serverless functions in Netlify using Rust and WasmEdge. The article covers two examples:

1.  **Image Processing:** An example of how to create a serverless function that turns an uploaded image into black and white.
2.  **AI Inference:** Another example of how to classify the main subject on an uploaded image using a machine learning model.

**Key Components:**

*   **Rust Code:** The Rust code is used to implement the serverless functions. It reads input from `STDIN`, processes it, and writes the output to `STDOUT`.
*   **WasmEdge Runtime:** WasmEdge is used as the runtime environment for the WebAssembly bytecode generated by the Rust compiler.
*   **TensorFlow API:** The TensorFlow API is used in the AI inference example to run a machine learning model on the input image.
*   **Netlify Function:** The Netlify function is responsible for loading the WasmEdge runtime, starting the compiled WebAssembly program in WasmEdge, and passing the uploaded image data via `STDIN`.

**Potential Issues:**

*   The code assumes that the Rust compiler and WasmEdge runtime are installed and configured correctly.
*   The code does not handle errors or exceptions properly, which can lead to unexpected behavior.
*   The code uses `include_bytes!` and `include_str!` macros to include binary data in the Rust code, which may not be secure.
*   The code assumes that the input image is valid and can be processed correctly.

**Areas for Improvement:**

*   Error handling and exception handling should be improved to handle unexpected errors and provide meaningful error messages.
*   Security measures should be implemented to prevent potential security vulnerabilities, such as using `include_bytes!` and `include_str!` macros safely.
*   The code can be optimized for better performance by reducing the number of memory allocations and improving data processing efficiency."
docs/embed/go/function.md,"---
sidebar_position: 3
---

# Embed WASM Functions

In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs), we will demonstrate how to call a few simple WebAssembly functions from a Go app. The [functions](https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs) are written in Rust, and require complex call parameters and return values. The `#[wasmedge_bindgen]` macro is needed for the compiler tools to auto-generate the correct code to pass call parameters from Go to WebAssembly.

## The WASM app in Rust

As we [described](../data/intro.md) here, the WebAssembly spec only supports a few simple data types out of the box. It [does not support](https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333) types such as string and array. To pass rich types in Go to WebAssembly, the compiler needs to convert them to simple integers. For example, it converts a string into an integer memory address and an integer length. The `wasmedge_bindgen` tool does this conversion automatically.

```rust
use num_integer::lcm;
use serde::{Deserialize, Serialize};
use sha3::{Digest, Keccak256, Sha3_256};
#[allow(unused_imports)]
use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;

#[derive(Serialize, Deserialize, Debug)]
struct Point {
    x: f32,
    y: f32,
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
    points: Vec<Point>,
    valid: bool,
    length: f32,
    desc: String,
}

#[wasmedge_bindgen]
pub fn create_line(p1: String, p2: String, desc: String) -> String {
    let point1: Point = serde_json::from_str(&p1).unwrap();
    let point2: Point = serde_json::from_str(&p2).unwrap();
    let length = ((point1.x - point2.x) * (point1.x - point2.x)
        + (point1.y - point2.y) * (point1.y - point2.y))
        .sqrt();

    let valid = if length == 0.0 { false } else { true };

    let line = Line {
        points: vec![point1, point2],
        valid: valid,
        length: length,
        desc: desc,
    };

    return serde_json::to_string(&line).unwrap();
}

#[wasmedge_bindgen]
pub fn say(s: String) -> String {
    let r = String::from(""hello "");
    return r + &s;
}

#[wasmedge_bindgen]
pub fn obfusticate(s: String) -> String {
    (&s).chars()
        .map(|c| match c {
            'A'..='M' | 'a'..='m' => ((c as u8) + 13) as char,
            'N'..='Z' | 'n'..='z' => ((c as u8) - 13) as char,
            _ => c,
        })
        .collect()
}

#[wasmedge_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -> i32 {
    let r = lcm(a, b);
    return r;
}

#[wasmedge_bindgen]
pub fn sha3_digest(v: Vec<u8>) -> Vec<u8> {
    return Sha3_256::digest(&v).as_slice().to_vec();
}

#[wasmedge_bindgen]
pub fn keccak_digest(s: Vec<u8>) -> Vec<u8> {
    return Keccak256::digest(&s).as_slice().to_vec();
}
```

## Compile the Rust code to Wasm

First, we will compile the Rust source code into WebAssembly bytecode functions.

```bash
git clone https://github.com/second-state/WasmEdge-go-examples.git
cd rust_bindgen_funcs
cargo build --release --target wasm32-wasi
# The output WASM will be target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm
```

## The Go host app

The [Go source code](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/bindgen_funcs.go) to run the WebAssembly function in WasmEdge is as follows. The `Execute()` function calls the WebAssembly function and passes the call parameters using the `#[wasmedge_bindgen]` convention.

```go
package main

import (
  ""fmt""
  ""os""

  ""github.com/second-state/WasmEdge-go/wasmedge""
  bindgen ""github.com/second-state/wasmedge-bindgen/host/go""
)

func main() {
  // Expected Args[0]: program name (./bindgen_funcs)
  // Expected Args[1]: wasm or wasm-so file (rust_bindgen_funcs_lib.wasm))

  // Set not to print debug info
  wasmedge.SetLogErrorLevel()

  // Create configure
  var conf = wasmedge.NewConfigure(wasmedge.WASI)

  // Create VM with configure
  var vm = wasmedge.NewVMWithConfig(conf)

  // Init WASI
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{"".:.""}, // The mapping preopens
  )

  vm.LoadWasmFile(os.Args[1])
  vm.Validate()
  // Instantiate the bindgen and vm
  bg := bindgen.New(vm)
  bg.Instantiate()

  // Run bindgen functions
  var res []interface{}
  var err error
  // create_line: array, array, array -> array (inputs are JSON stringified)
  res, _, err = bg.Execute(""create_line"", ""{\""x\"":1.5,\""y\"":3.8}"", ""{\""x\"":2.5,\""y\"":5.8}"", ""A thin red line"")
  if err == nil {
    fmt.Println(""Run bindgen -- create_line:"", res[0].(string))
  } else {
    fmt.Println(""Run bindgen -- create_line FAILED"")
  }
  // say: array -> array
  res, _, err = bg.Execute(""say"", ""bindgen funcs test"")
  if err == nil {
    fmt.Println(""Run bindgen -- say:"", res[0].(string))
  } else {
    fmt.Println(""Run bindgen -- say FAILED"")
  }
  // obfusticate: array -> array
  res, _, err = bg.Execute(""obfusticate"", ""A quick brown fox jumps over the lazy dog"")
  if err == nil {
    fmt.Println(""Run bindgen -- obfusticate:"", res[0].(string))
  } else {
    fmt.Println(""Run bindgen -- obfusticate FAILED"")
  }
  // lowest_common_multiple: i32, i32 -> i32
  res, _, err = bg.Execute(""lowest_common_multiple"", int32(123), int32(2))
  if err == nil {
    fmt.Println(""Run bindgen -- lowest_common_multiple:"", res[0].(int32))
  } else {
    fmt.Println(""Run bindgen -- lowest_common_multiple FAILED"")
  }
  // sha3_digest: array -> array
  res, _, err = bg.Execute(""sha3_digest"", []byte(""This is an important message""))
  if err == nil {
    fmt.Println(""Run bindgen -- sha3_digest:"", res[0].([]byte))
  } else {
    fmt.Println(""Run bindgen -- sha3_digest FAILED"")
  }
  // keccak_digest: array -> array
  res, _, err = bg.Execute(""keccak_digest"", []byte(""This is an important message""))
  if err == nil {
    fmt.Println(""Run bindgen -- keccak_digest:"", res[0].([]byte))
  } else {
    fmt.Println(""Run bindgen -- keccak_digest FAILED"")
  }

  bg.Release()
  conf.Release()
}
```

## Build and run the WASM app from your Go host app

::note Make sure you have installed [Go, WasmEdge, and WasmEdge Go SDK](intro.md). ::

Next, let's build the Go application with the WasmEdge Go SDK.

```bash
go build
```

Run the Go application, and it will run the WebAssembly functions embedded in the WasmEdge runtime.

```bash
$ ./bindgen_funcs rust_bindgen_funcs/target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm
Run bindgen -- create_line: {""points"":[{""x"":1.5,""y"":3.8},{""x"":2.5,""y"":5.8}],""valid"":true,""length"":2.2360682,""desc"":""A thin red line""}
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
```
","Here is a concise and coherent summary of the provided code:

**Summary**

This code demonstrates how to embed WebAssembly (WASM) functions in a Go application using WasmEdge, a WASM runtime. The code consists of two main parts: a Rust module that contains the WASM functions, and a Go host application that loads and executes these functions.

**Key Components**

1. **Rust Module**: This part defines several WASM functions in Rust, including `create_line`, `say`, `obfusticate`, `lowest_common_multiple`, `sha3_digest`, and `keccak_digest`. These functions are annotated with the `#[wasmedge_bindgen]` macro to enable auto-generation of Go bindings.
2. **Go Host Application**: This part loads the Rust module into WasmEdge, instantiates it, and executes the WASM functions using a custom API.

**Functionality**

The code demonstrates how to call various WASM functions from a Go application, including:

* `create_line`: creates a line given two points and a description
* `say`: concatenates a string with ""hello ""
* `obfusticate`: applies a simple Caesar cipher to a string
* `lowest_common_multiple`: calculates the LCM of two integers
* `sha3_digest` and `keccak_digest`: hash input data using Keccak-256 and SHA-3 respectively

**Potential Issues**

1. **WasmEdge Version**: The code uses WasmEdge version 0.10, which may not be compatible with future versions.
2. **Rust Module Compilation**: The Rust module needs to be compiled with the `wasi` target to generate the correct WASM file.
3. **Go Host Application**: The Go host application assumes that the WasmEdge Go SDK is installed and configured correctly.

Overall, this code provides a working example of embedding WASM functions in a Go application using WasmEdge. However, users should ensure they have the necessary dependencies and configurations to run the code successfully."
i18n/zh/docusaurus-plugin-content-docs/current/embed/go/function.md,"---
sidebar_position: 3
---

# Embed WASM Functions

In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs), we will demonstrate how to call a few simple WebAssembly functions from a Go app. The [functions](https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs) are written in Rust, and require complex call parameters and return values. The `#[wasmedge_bindgen]` macro is needed for the compiler tools to auto-generate the correct code to pass call parameters from Go to WebAssembly.

## The WASM app in Rust

As we [described](../data/intro.md) here, the WebAssembly spec only supports a few simple data types out of the box. It [does not support](https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333) types such as string and array. To pass rich types in Go to WebAssembly, the compiler needs to convert them to simple integers. For example, it converts a string into an integer memory address and an integer length. The `wasmedge_bindgen` tool does this conversion automatically.

```rust
use num_integer::lcm;
use serde::{Deserialize, Serialize};
use sha3::{Digest, Keccak256, Sha3_256};
#[allow(unused_imports)]
use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;

#[derive(Serialize, Deserialize, Debug)]
struct Point {
    x: f32,
    y: f32,
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
    points: Vec<Point>,
    valid: bool,
    length: f32,
    desc: String,
}

#[wasmedge_bindgen]
pub fn create_line(p1: String, p2: String, desc: String) -> String {
    let point1: Point = serde_json::from_str(&p1).unwrap();
    let point2: Point = serde_json::from_str(&p2).unwrap();
    let length = ((point1.x - point2.x) * (point1.x - point2.x)
        + (point1.y - point2.y) * (point1.y - point2.y))
        .sqrt();

    let valid = if length == 0.0 { false } else { true };

    let line = Line {
        points: vec![point1, point2],
        valid: valid,
        length: length,
        desc: desc,
    };

    return serde_json::to_string(&line).unwrap();
}

#[wasmedge_bindgen]
pub fn say(s: String) -> String {
    let r = String::from(""hello "");
    return r + &s;
}

#[wasmedge_bindgen]
pub fn obfusticate(s: String) -> String {
    (&s).chars()
        .map(|c| match c {
            'A'..='M' | 'a'..='m' => ((c as u8) + 13) as char,
            'N'..='Z' | 'n'..='z' => ((c as u8) - 13) as char,
            _ => c,
        })
        .collect()
}

#[wasmedge_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -> i32 {
    let r = lcm(a, b);
    return r;
}

#[wasmedge_bindgen]
pub fn sha3_digest(v: Vec<u8>) -> Vec<u8> {
    return Sha3_256::digest(&v).as_slice().to_vec();
}

#[wasmedge_bindgen]
pub fn keccak_digest(s: Vec<u8>) -> Vec<u8> {
    return Keccak256::digest(&s).as_slice().to_vec();
}
```

## Compile the Rust code to Wasm

First, we will compile the Rust source code into WebAssembly bytecode functions.

```bash
git clone https://github.com/second-state/WasmEdge-go-examples.git
cd rust_bindgen_funcs
cargo build --release --target wasm32-wasi
# The output WASM will be target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm
```

## The Go host app

The [Go source code](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/bindgen_funcs.go) to run the WebAssembly function in WasmEdge is as follows. The `Execute()` function calls the WebAssembly function and passes the call parameters using the `#[wasmedge_bindgen]` convention.

```go
package main

import (
  ""fmt""
  ""os""

  ""github.com/second-state/WasmEdge-go/wasmedge""
  bindgen ""github.com/second-state/wasmedge-bindgen/host/go""
)

func main() {
  // Expected Args[0]: program name (./bindgen_funcs)
  // Expected Args[1]: wasm or wasm-so file (rust_bindgen_funcs_lib.wasm))

  // Set not to print debug info
  wasmedge.SetLogErrorLevel()

  // Create configure
  var conf = wasmedge.NewConfigure(wasmedge.WASI)

  // Create VM with configure
  var vm = wasmedge.NewVMWithConfig(conf)

  // Init WASI
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{"".:.""}, // The mapping preopens
  )

  vm.LoadWasmFile(os.Args[1])
  vm.Validate()
  // Instantiate the bindgen and vm
  bg := bindgen.New(vm)
  bg.Instantiate()

  // Run bindgen functions
  var res []interface{}
  var err error
  // create_line: array, array, array -> array (inputs are JSON stringified)
  res, _, err = bg.Execute(""create_line"", ""{\""x\"":1.5,\""y\"":3.8}"", ""{\""x\"":2.5,\""y\"":5.8}"", ""A thin red line"")
  if err == nil {
    fmt.Println(""Run bindgen -- create_line:"", res[0].(string))
  } else {
    fmt.Println(""Run bindgen -- create_line FAILED"")
  }
  // say: array -> array
  res, _, err = bg.Execute(""say"", ""bindgen funcs test"")
  if err == nil {
    fmt.Println(""Run bindgen -- say:"", res[0].(string))
  } else {
    fmt.Println(""Run bindgen -- say FAILED"")
  }
  // obfusticate: array -> array
  res, _, err = bg.Execute(""obfusticate"", ""A quick brown fox jumps over the lazy dog"")
  if err == nil {
    fmt.Println(""Run bindgen -- obfusticate:"", res[0].(string))
  } else {
    fmt.Println(""Run bindgen -- obfusticate FAILED"")
  }
  // lowest_common_multiple: i32, i32 -> i32
  res, _, err = bg.Execute(""lowest_common_multiple"", int32(123), int32(2))
  if err == nil {
    fmt.Println(""Run bindgen -- lowest_common_multiple:"", res[0].(int32))
  } else {
    fmt.Println(""Run bindgen -- lowest_common_multiple FAILED"")
  }
  // sha3_digest: array -> array
  res, _, err = bg.Execute(""sha3_digest"", []byte(""This is an important message""))
  if err == nil {
    fmt.Println(""Run bindgen -- sha3_digest:"", res[0].([]byte))
  } else {
    fmt.Println(""Run bindgen -- sha3_digest FAILED"")
  }
  // keccak_digest: array -> array
  res, _, err = bg.Execute(""keccak_digest"", []byte(""This is an important message""))
  if err == nil {
    fmt.Println(""Run bindgen -- keccak_digest:"", res[0].([]byte))
  } else {
    fmt.Println(""Run bindgen -- keccak_digest FAILED"")
  }

  bg.Release()
  conf.Release()
}
```

## Build and run the WASM app from your Go host app

::note Make sure you have installed [Go, WasmEdge, and WasmEdge Go SDK](intro.md). ::

Next, let's build the Go application with the WasmEdge Go SDK.

```bash
go build
```

Run the Go application, and it will run the WebAssembly functions embedded in the WasmEdge runtime.

```bash
$ ./bindgen_funcs rust_bindgen_funcs/target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm
Run bindgen -- create_line: {""points"":[{""x"":1.5,""y"":3.8},{""x"":2.5,""y"":5.8}],""valid"":true,""length"":2.2360682,""desc"":""A thin red line""}
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
```
","**Summary**

This code demonstrates how to embed WebAssembly (WASM) functions in a Go application using the WasmEdge runtime. The WASM app is written in Rust and uses the `wasmedge_bindgen` tool to auto-generate code for passing call parameters from Go to WebAssembly.

**Key Components**

1. **Rust Code**: The WASM app is written in Rust, with functions implemented using the `#[wasmedge_bindgen]` macro.
2. **WasmEdge Runtime**: The WasmEdge runtime is used to execute the WASM functions embedded in the Go application.
3. **Go Host App**: The Go host app uses the WasmEdge Go SDK to load and run the WASM functions.

**Functionality**

The Go host app demonstrates how to call various WASM functions, including:

1. `create_line`: Creates a line between two points.
2. `say`: Returns a greeting message.
3. `obfusticate`: Encrypts a string using Caesar cipher.
4. `lowest_common_multiple`: Calculates the lowest common multiple of two numbers.
5. `sha3_digest` and `keccak_digest`: Computes the SHA-3 and Keccak hashes of a byte array.

**Potential Issues/Improvement Areas**

1. **Error Handling**: The code does not handle errors properly. For example, if an error occurs while running a WASM function, it is not caught or handled.
2. **Type Safety**: The code uses the `interface{}` type to represent different types of data, which can lead to type-related issues at runtime.
3. **Performance**: Running multiple WASM functions in the Go host app may impact performance due to overheads associated with loading and running WASM functions.
4. **Code Organization**: The code could benefit from a more modular structure, separating the Rust code into its own module or library.

By addressing these areas, the code can be improved for better error handling, type safety, performance, and maintainability."
docs/embed/go/bindgen.md,"---
sidebar_position: 6
---

# Embed a bindgen function

In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_BindgenFuncs), we will demonstrate how to call a few simple WebAssembly functions from a Go app. The [functions](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs) are written in Rust, and require complex call parameters and return values. The `#[wasmedge_bindgen]` macro is needed for the compiler tools to auto-generate the correct code to pass call parameters from Go to WebAssembly.

## The WASM app in Rust

The WebAssembly spec only supports a few simple data types out of the box. It [does not support](https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333) types such as string and array. To pass rich types in Go to WebAssembly, the compiler needs to convert them to simple integers. For example, it converts a string into an integer memory address and an integer length. The `wasmedge_bindgen` tool does this conversion automatically.

```rust
use num_integer::lcm;
use serde::{Deserialize, Serialize};
use sha3::{Digest, Keccak256, Sha3_256};
#[allow(unused_imports)]
use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;

#[derive(Serialize, Deserialize, Debug)]
struct Point {
    x: f32,
    y: f32,
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
    points: Vec<Point>,
    valid: bool,
    length: f32,
    desc: String,
}

#[wasmedge_bindgen]
pub fn create_line(p1: String, p2: String, desc: String) -> String {
    let point1: Point = serde_json::from_str(&p1).unwrap();
    let point2: Point = serde_json::from_str(&p2).unwrap();
    let length = ((point1.x - point2.x) * (point1.x - point2.x)
        + (point1.y - point2.y) * (point1.y - point2.y))
        .sqrt();

    let valid = if length == 0.0 { false } else { true };

    let line = Line {
        points: vec![point1, point2],
        valid: valid,
        length: length,
        desc: desc,
    };

    return serde_json::to_string(&line).unwrap();
}

#[wasmedge_bindgen]
pub fn say(s: String) -> String {
    let r = String::from(""hello "");
    return r + &s;
}

#[wasmedge_bindgen]
pub fn obfusticate(s: String) -> String {
    (&s).chars()
        .map(|c| match c {
            'A'..='M' | 'a'..='m' => ((c as u8) + 13) as char,
            'N'..='Z' | 'n'..='z' => ((c as u8) - 13) as char,
            _ => c,
        })
        .collect()
}

#[wasmedge_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -> i32 {
    let r = lcm(a, b);
    return r;
}

#[wasmedge_bindgen]
pub fn sha3_digest(v: Vec<u8>) -> Vec<u8> {
    return Sha3_256::digest(&v).as_slice().to_vec();
}

#[wasmedge_bindgen]
pub fn keccak_digest(s: Vec<u8>) -> Vec<u8> {
    return Keccak256::digest(&s).as_slice().to_vec();
}
```

## Compile the Rust code to Wasm

First, we will compile the Rust source code into WebAssembly bytecode functions.

```bash
git clone https://github.com/second-state/WasmEdge-go-examples.git
cd rust_bindgen_funcs
$cargo build --release --target wasm32-wasi
# The output WASM will be target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm
```

## The Go host app

The [Go source code](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/bindgen_funcs.go) to run the WebAssembly function in WasmEdge is as follows. The `Execute()` function calls the WebAssembly function and passes the call parameters using the `#[wasmedge_bindgen]` convention.

```go
package main

import (
  ""fmt""
  ""os""

  ""github.com/second-state/WasmEdge-go/wasmedge""
  bindgen ""github.com/second-state/wasmedge-bindgen/host/go""
)

func main() {
  // Expected Args[0]: program name (./bindgen_funcs)
  // Expected Args[1]: wasm or wasm-so file (rust_bindgen_funcs_lib.wasm))

  // Set not to print debug info
  wasmedge.SetLogErrorLevel()

  // Create configure
  var conf = wasmedge.NewConfigure(wasmedge.WASI)

  // Create VM with configure
  var vm = wasmedge.NewVMWithConfig(conf)

  // Init WASI
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{"".:.""}, // The mapping preopens
  )

  vm.LoadWasmFile(os.Args[1])
  vm.Validate()
  // Instantiate the bindgen and vm
  bg := bindgen.New(vm)
  bg.Instantiate()

  // Run bindgen functions
  var res []interface{}
  var err error
  // create_line: array, array, array -> array (inputs are JSON stringified)
  res, _, err = bg.Execute(""create_line"", ""{\""x\"":1.5,\""y\"":3.8}"", ""{\""x\"":2.5,\""y\"":5.8}"", ""A thin red line"")
  if err == nil {
    fmt.Println(""Run bindgen -- create_line:"", res[0].(string))
  } else {
    fmt.Println(""Run bindgen -- create_line FAILED"")
  }
  // say: array -> array
  res, _, err = bg.Execute(""say"", ""bindgen funcs test"")
  if err == nil {
    fmt.Println(""Run bindgen -- say:"", res[0].(string))
  } else {
    fmt.Println(""Run bindgen -- say FAILED"")
  }
  // obfusticate: array -> array
  res, _, err = bg.Execute(""obfusticate"", ""A quick brown fox jumps over the lazy dog"")
  if err == nil {
    fmt.Println(""Run bindgen -- obfusticate:"", res[0].(string))
  } else {
    fmt.Println(""Run bindgen -- obfusticate FAILED"")
  }
  // lowest_common_multiple: i32, i32 -> i32
  res, _, err = bg.Execute(""lowest_common_multiple"", int32(123), int32(2))
  if err == nil {
    fmt.Println(""Run bindgen -- lowest_common_multiple:"", res[0].(int32))
  } else {
    fmt.Println(""Run bindgen -- lowest_common_multiple FAILED"")
  }
  // sha3_digest: array -> array
  res, _, err = bg.Execute(""sha3_digest"", []byte(""This is an important message""))
  if err == nil {
    fmt.Println(""Run bindgen -- sha3_digest:"", res[0].([]byte))
  } else {
    fmt.Println(""Run bindgen -- sha3_digest FAILED"")
  }
  // keccak_digest: array -> array
  res, _, err = bg.Execute(""keccak_digest"", []byte(""This is an important message""))
  if err == nil {
    fmt.Println(""Run bindgen -- keccak_digest:"", res[0].([]byte))
  } else {
    fmt.Println(""Run bindgen -- keccak_digest FAILED"")
  }

  bg.Release()
  conf.Release()
}
```

## Build and run the WASM app from your go host

::note Make sure you have installed [Go, WasmEdge, and WasmEdge Go SDK](intro.md). ::

Next, let's build the Go application with the WasmEdge Go SDK.

```bash
go build
```

Run the Go application and it will run the WebAssembly functions embedded in the WasmEdge runtime.

```bash
$ ./bindgen_funcs rust_bindgen_funcs/target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm
Run bindgen -- create_line: {""points"":[{""x"":1.5,""y"":3.8},{""x"":2.5,""y"":5.8}],""valid"":true,""length"":2.2360682,""desc"":""A thin red line""}
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
```
","**Summary**

The code demonstrates how to embed WebAssembly (WASM) functions in a Go application using the `wasmedge` and `wasmedge-bindgen` libraries. The WASM functions are written in Rust, compiled into bytecode, and run within the WasmEdge runtime.

**Key Components**

1. **Rust Code**: Written using the `wasm32-wasi` target to generate WebAssembly bytecode.
2. **WasmEdge Runtime**: Used to execute the WebAssembly functions.
3. **Wasmedge-go SDK**: A Go library for interacting with the WasmEdge runtime.
4. **Bindgen Functions**: Generated by the `wasmedge-bindgen` tool, these functions wrap the Rust WASM functions and allow them to be called from Go.

**Functionality**

The code showcases five bindgen functions:

1. `create_line`: Creates a line given two points and a description.
2. `say`: Returns a greeting with a provided name.
3. `obfusticate`: Encrypts the input string using Caesar cipher.
4. `lowest_common_multiple`: Calculates the lowest common multiple of two integers.
5. `sha3_digest` and `keccak_digest`: Computes the SHA-3 and Keccak-256 digests of a byte slice.

**Potential Issues**

1. **Error Handling**: While error handling is implemented for individual function calls, it's essential to consider edge cases and provide robust error handling mechanisms.
2. **Security**: When working with cryptographic functions (e.g., `sha3_digest` and `keccak_digest`), ensure proper usage and follow security best practices to prevent vulnerabilities.
3. **Performance**: Profile the application for performance bottlenecks, particularly when executing complex WebAssembly functions.

Overall, this code serves as a solid foundation for integrating WASM functions with a Go application using WasmEdge and the Wasmedge-go SDK."
i18n/zh/docusaurus-plugin-content-docs/current/embed/go/bindgen.md,"---
sidebar_position: 6
---

# Embed a bindgen function

In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_BindgenFuncs), we will demonstrate how to call a few simple WebAssembly functions from a Go app. The [functions](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs) are written in Rust, and require complex call parameters and return values. The `#[wasmedge_bindgen]` macro is needed for the compiler tools to auto-generate the correct code to pass call parameters from Go to WebAssembly.

## The WASM app in Rust

The WebAssembly spec only supports a few simple data types out of the box. It [does not support](https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333) types such as string and array. To pass rich types in Go to WebAssembly, the compiler needs to convert them to simple integers. For example, it converts a string into an integer memory address and an integer length. The `wasmedge_bindgen` tool does this conversion automatically.

```rust
use num_integer::lcm;
use serde::{Deserialize, Serialize};
use sha3::{Digest, Keccak256, Sha3_256};
#[allow(unused_imports)]
use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;

#[derive(Serialize, Deserialize, Debug)]
struct Point {
    x: f32,
    y: f32,
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
    points: Vec<Point>,
    valid: bool,
    length: f32,
    desc: String,
}

#[wasmedge_bindgen]
pub fn create_line(p1: String, p2: String, desc: String) -> String {
    let point1: Point = serde_json::from_str(&p1).unwrap();
    let point2: Point = serde_json::from_str(&p2).unwrap();
    let length = ((point1.x - point2.x) * (point1.x - point2.x)
        + (point1.y - point2.y) * (point1.y - point2.y))
        .sqrt();

    let valid = if length == 0.0 { false } else { true };

    let line = Line {
        points: vec![point1, point2],
        valid: valid,
        length: length,
        desc: desc,
    };

    return serde_json::to_string(&line).unwrap();
}

#[wasmedge_bindgen]
pub fn say(s: String) -> String {
    let r = String::from(""hello "");
    return r + &s;
}

#[wasmedge_bindgen]
pub fn obfusticate(s: String) -> String {
    (&s).chars()
        .map(|c| match c {
            'A'..='M' | 'a'..='m' => ((c as u8) + 13) as char,
            'N'..='Z' | 'n'..='z' => ((c as u8) - 13) as char,
            _ => c,
        })
        .collect()
}

#[wasmedge_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -> i32 {
    let r = lcm(a, b);
    return r;
}

#[wasmedge_bindgen]
pub fn sha3_digest(v: Vec<u8>) -> Vec<u8> {
    return Sha3_256::digest(&v).as_slice().to_vec();
}

#[wasmedge_bindgen]
pub fn keccak_digest(s: Vec<u8>) -> Vec<u8> {
    return Keccak256::digest(&s).as_slice().to_vec();
}
```

## Compile the Rust code to Wasm

First, we will compile the Rust source code into WebAssembly bytecode functions.

```bash
git clone https://github.com/second-state/WasmEdge-go-examples.git
cd rust_bindgen_funcs
$cargo build --release --target wasm32-wasi
# The output WASM will be target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm
```

## The Go host app

The [Go source code](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/bindgen_funcs.go) to run the WebAssembly function in WasmEdge is as follows. The `Execute()` function calls the WebAssembly function and passes the call parameters using the `#[wasmedge_bindgen]` convention.

```go
package main

import (
  ""fmt""
  ""os""

  ""github.com/second-state/WasmEdge-go/wasmedge""
  bindgen ""github.com/second-state/wasmedge-bindgen/host/go""
)

func main() {
  // Expected Args[0]: program name (./bindgen_funcs)
  // Expected Args[1]: wasm or wasm-so file (rust_bindgen_funcs_lib.wasm))

  // Set not to print debug info
  wasmedge.SetLogErrorLevel()

  // Create configure
  var conf = wasmedge.NewConfigure(wasmedge.WASI)

  // Create VM with configure
  var vm = wasmedge.NewVMWithConfig(conf)

  // Init WASI
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{"".:.""}, // The mapping preopens
  )

  vm.LoadWasmFile(os.Args[1])
  vm.Validate()
  // Instantiate the bindgen and vm
  bg := bindgen.New(vm)
  bg.Instantiate()

  // Run bindgen functions
  var res []interface{}
  var err error
  // create_line: array, array, array -> array (inputs are JSON stringified)
  res, _, err = bg.Execute(""create_line"", ""{\""x\"":1.5,\""y\"":3.8}"", ""{\""x\"":2.5,\""y\"":5.8}"", ""A thin red line"")
  if err == nil {
    fmt.Println(""Run bindgen -- create_line:"", res[0].(string))
  } else {
    fmt.Println(""Run bindgen -- create_line FAILED"")
  }
  // say: array -> array
  res, _, err = bg.Execute(""say"", ""bindgen funcs test"")
  if err == nil {
    fmt.Println(""Run bindgen -- say:"", res[0].(string))
  } else {
    fmt.Println(""Run bindgen -- say FAILED"")
  }
  // obfusticate: array -> array
  res, _, err = bg.Execute(""obfusticate"", ""A quick brown fox jumps over the lazy dog"")
  if err == nil {
    fmt.Println(""Run bindgen -- obfusticate:"", res[0].(string))
  } else {
    fmt.Println(""Run bindgen -- obfusticate FAILED"")
  }
  // lowest_common_multiple: i32, i32 -> i32
  res, _, err = bg.Execute(""lowest_common_multiple"", int32(123), int32(2))
  if err == nil {
    fmt.Println(""Run bindgen -- lowest_common_multiple:"", res[0].(int32))
  } else {
    fmt.Println(""Run bindgen -- lowest_common_multiple FAILED"")
  }
  // sha3_digest: array -> array
  res, _, err = bg.Execute(""sha3_digest"", []byte(""This is an important message""))
  if err == nil {
    fmt.Println(""Run bindgen -- sha3_digest:"", res[0].([]byte))
  } else {
    fmt.Println(""Run bindgen -- sha3_digest FAILED"")
  }
  // keccak_digest: array -> array
  res, _, err = bg.Execute(""keccak_digest"", []byte(""This is an important message""))
  if err == nil {
    fmt.Println(""Run bindgen -- keccak_digest:"", res[0].([]byte))
  } else {
    fmt.Println(""Run bindgen -- keccak_digest FAILED"")
  }

  bg.Release()
  conf.Release()
}
```

## Build and run the WASM app from your go host

::note Make sure you have installed [Go, WasmEdge, and WasmEdge Go SDK](intro.md). ::

Next, let's build the Go application with the WasmEdge Go SDK.

```bash
go build
```

Run the Go application and it will run the WebAssembly functions embedded in the WasmEdge runtime.

```bash
$ ./bindgen_funcs rust_bindgen_funcs/target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm
Run bindgen -- create_line: {""points"":[{""x"":1.5,""y"":3.8},{""x"":2.5,""y"":5.8}],""valid"":true,""length"":2.2360682,""desc"":""A thin red line""}
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
```
","**Summary**

This code is a tutorial on how to embed WebAssembly (WASM) functions in a Go application using the WasmEdge runtime and WASM bindings. The tutorial consists of three main components:

1. **Rust Code**: This is the source code for a set of WASM functions written in Rust, which will be compiled into WASM bytecode.
2. **Go Host App**: This is the Go application that loads the WASM functions and executes them using the WasmEdge runtime.
3. **Build and Run**: This step involves building the Go application and running it to execute the embedded WASM functions.

**Key Components**

* `wasmedge_bindgen_macro`: A macro used in Rust code to define WASM bindings for the function.
* `WASMEdge Go SDK`: The WasmEdge Go SDK is used to interface with the WasmEdge runtime from Go code.
* `bindgen`: A tool used to create a bridge between the Go application and the Wasm functions.

**Potential Issues**

* **Error Handling**: Error handling is not explicitly handled in some parts of the code. This may lead to crashes or unexpected behavior if errors occur during execution.
* **Code Organization**: The Rust code and Go host app are tightly coupled, making it harder to modify or maintain each component independently.
* **Performance**: Executing WASM functions through a runtime can introduce performance overhead due to interpretation or just-in-time compilation.

**Areas for Improvement**

* Add explicit error handling in the Go host app to handle potential errors during Wasm function execution.
* Improve code organization by separating the Rust code and Go host app into different modules or packages.
* Optimize performance by using native compilation or caching WASM functions to reduce runtime overhead."
docs/develop/rust/os.md,"---
sidebar_position: 3
---

# Access OS services

The WASI (WebAssembly Systems Interface) standard is designed to allow WebAssembly applications to access operating system services. The `wasm32-wasi` target in the Rust compiler supports WASI. This section will use [an example project](https://github.com/second-state/rust-examples/tree/main/wasi) to show how to use Rust standard APIs to access operating system services.

<!-- prettier-ignore -->
:::note
Before we start, ensure [you have Rust and WasmEdge installed](setup.md).
:::

## Random numbers

The WebAssembly VM is a pure software construct. It does not have a hardware entropy source for random numbers. That's why WASI defines a function for WebAssembly programs to call its host operating system to get a random seed. As a Rust developer, you only need to use the popular (de facto standard) `rand` and/or `getrandom` crates. With the `wasm32-wasi` compiler backend, these crates generate the correct WASI calls in the WebAssembly bytecode. The `Cargo.toml` dependencies are as follows.

```toml
[dependencies]
rand = ""0.7.3""
getrandom = ""0.1.14""
```

The Rust code to get random numbers from WebAssembly is this.

```rust
use rand::prelude::*;

pub fn get_random_i32() -> i32 {
  let x: i32 = random();
  return x;
}

pub fn get_random_bytes() -> Vec<u8> {
  let mut rng = thread_rng();
  let mut arr = [0u8; 128];
  rng.fill(&mut arr[..]);
  return arr.to_vec();
}
```

## Printing and debugging from Rust

The Rust `println!` marco works in WASI. The statements print to the `STDOUT` of the process that runs the WasmEdge.

```rust
pub fn echo(content: &str) -> String {
  println!(""Printed from wasi: {}"", content);
  return content.to_string();
}
```

## Arguments and environment variables

Passing CLI arguments to and accessing OS environment variables in a WasmEdge application is possible. They are just `env::args()` and `env::vars()` arrays in Rust.

```rust
use std::env;

pub fn print_env() {
  println!(""The env vars are as follows."");
  for (key, value) in env::vars() {
    println!(""{}: {}"", key, value);
  }

  println!(""The args are as follows."");
  for argument in env::args() {
    println!(""{}"", argument);
  }
}
```

## Reading and writing files

WASI allows your Rust functions to access the host computer's file system through the standard Rust `std::fs` API. In the Rust program, you operate on files through a relative path. The relative path's root is specified when you start the WasmEdge runtime.

```rust
use std::fs;
use std::fs::File;
use std::io::{Write, Read};

pub fn create_file(path: &str, content: &str) {
  let mut output = File::create(path).unwrap();
  output.write_all(content.as_bytes()).unwrap();
}

pub fn read_file(path: &str) -> String {
  let mut f = File::open(path).unwrap();
  let mut s = String::new();
  match f.read_to_string(&mut s) {
    Ok(_) => s,
    Err(e) => e.to_string(),
  }
}

pub fn del_file(path: &str) {
  fs::remove_file(path).expect(""Unable to delete"");
}
```

## A main() app

With a `main()` function, the Rust program can be compiled into a standalone WebAssembly program.

```rust
fn main() {
  println!(""Random number: {}"", get_random_i32());
  println!(""Random bytes: {:?}"", get_random_bytes());
  println!(""{}"", echo(""This is from a main function""));
  print_env();
  create_file(""tmp.txt"", ""This is in a file"");
  println!(""File content is {}"", read_file(""tmp.txt""));
  del_file(""tmp.txt"");
}
```

Use the command below to compile [the Rust project](https://github.com/second-state/rust-examples/blob/main/wasi/).

```bash
cargo build --target wasm32-wasi --release
```

To run it in `wasmedge`, do the following. The `--dir` option maps the current directory of the command shell to the file system's current directory inside the WebAssembly app.

```bash
$ wasmedge --dir .:. target/wasm32-wasi/release/wasi.wasm
Random number: -1157533356
Random bytes: [159, 159, 9, 119, 106, 172, 207, 82, 173, 145, 233, 214, 104, 35, 23, 53, 155, 12, 102, 231, 117, 67, 192, 215, 207, 202, 128, 198, 213, 41, 235, 57, 89, 223, 138, 70, 185, 137, 74, 162, 42, 20, 226, 177, 114, 170, 172, 39, 149, 99, 122, 68, 115, 205, 155, 202, 4, 48, 178, 224, 124, 42, 24, 56, 215, 90, 203, 150, 106, 128, 127, 201, 177, 187, 20, 195, 172, 56, 72, 28, 53, 163, 59, 36, 129, 160, 69, 203, 196, 72, 113, 61, 46, 249, 81, 134, 94, 134, 159, 51, 233, 247, 253, 116, 202, 210, 100, 75, 74, 95, 197, 44, 81, 87, 89, 115, 20, 226, 143, 139, 50, 60, 196, 59, 206, 105, 161, 226]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
wasi.wasm
File content is This is in a file
```

## Functions

As [we have seen](hello_world.md#a-simple-function), you can create WebAssembly functions in a Rust `lib.rs` project. You can also use WASI functions in those functions. However, an important caveat is that, without a `main()` function, you will need to explicitly call a helper function to initialize the environment for WASI functions to work properly.

Add a helper crate in Cargo.toml in the Rust program so that the WASI initialization code can be applied to your exported public library functions.

```toml
[dependencies]
... ...
wasmedge-wasi-helper = ""=0.2.0""
```

In the Rust function, we need to call `_initialize()` before we access any arguments and environment variables or operate any files.

```rust
pub fn print_env() -> i32 {
  _initialize();
  ... ...
}

pub fn create_file(path: &str, content: &str) -> String {
  _initialize();
  ... ...
}

pub fn read_file(path: &str) -> String {
  _initialize();
  ... ...
}

pub fn del_file(path: &str) -> String {
  _initialize();
  ... ...
}
```
","**Summary**

The provided code is an example of using the WASI (WebAssembly Systems Interface) standard to access operating system services from a WebAssembly program written in Rust. The example demonstrates how to use various WASI APIs, including generating random numbers, printing and debugging output, passing command-line arguments, accessing environment variables, reading and writing files, and creating a standalone WebAssembly application.

**Key Components**

1. **Random Numbers**: The `rand` and `getrandom` crates are used to generate random numbers.
2. **Printing and Debugging**: The `println!` macro is used to print output to the console.
3. **Arguments and Environment Variables**: The `env::args()` and `env::vars()` functions are used to access command-line arguments and environment variables.
4. **Reading and Writing Files**: The `std::fs` API is used to read and write files on the host file system.
5. **A Main() App**: A standalone WebAssembly application is created by defining a `main()` function.

**Potential Issues or Areas for Improvement**

1. **Security**: When reading and writing files, ensure that proper security measures are taken to prevent vulnerabilities such as privilege escalation or data tampering.
2. **Error Handling**: Improve error handling mechanisms to handle potential errors when interacting with the file system or accessing environment variables.
3. **Performance Optimization**: Optimize performance by minimizing unnecessary function calls and optimizing code for faster execution.
4. **Code Organization**: Consider improving code organization by separating concerns into different modules or files, such as a separate module for WASI initialization.

Overall, the provided code provides a solid example of using WASI to access operating system services from a WebAssembly program written in Rust. However, there are opportunities for improvement and optimization to make it more robust and efficient."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/os.md,"---
sidebar_position: 3
---

# Access OS services

The WASI (WebAssembly Systems Interface) standard is designed to allow WebAssembly applications to access operating system services. The `wasm32-wasi` target in the Rust compiler supports WASI. This section will use [an example project](https://github.com/second-state/rust-examples/tree/main/wasi) to show how to use Rust standard APIs to access operating system services.

<!-- prettier-ignore -->
:::note
Before we start, ensure [you have Rust and WasmEdge installed](setup.md).
:::

## Random numbers

The WebAssembly VM is a pure software construct. It does not have a hardware entropy source for random numbers. That's why WASI defines a function for WebAssembly programs to call its host operating system to get a random seed. As a Rust developer, you only need to use the popular (de facto standard) `rand` and/or `getrandom` crates. With the `wasm32-wasi` compiler backend, these crates generate the correct WASI calls in the WebAssembly bytecode. The `Cargo.toml` dependencies are as follows.

```toml
[dependencies]
rand = ""0.7.3""
getrandom = ""0.1.14""
```

The Rust code to get random numbers from WebAssembly is this.

```rust
use rand::prelude::*;

pub fn get_random_i32() -> i32 {
  let x: i32 = random();
  return x;
}

pub fn get_random_bytes() -> Vec<u8> {
  let mut rng = thread_rng();
  let mut arr = [0u8; 128];
  rng.fill(&mut arr[..]);
  return arr.to_vec();
}
```

## Printing and debugging from Rust

The Rust `println!` marco works in WASI. The statements print to the `STDOUT` of the process that runs the WasmEdge.

```rust
pub fn echo(content: &str) -> String {
  println!(""Printed from wasi: {}"", content);
  return content.to_string();
}
```

## Arguments and environment variables

Passing CLI arguments to and accessing OS environment variables in a WasmEdge application is possible. They are just `env::args()` and `env::vars()` arrays in Rust.

```rust
use std::env;

pub fn print_env() {
  println!(""The env vars are as follows."");
  for (key, value) in env::vars() {
    println!(""{}: {}"", key, value);
  }

  println!(""The args are as follows."");
  for argument in env::args() {
    println!(""{}"", argument);
  }
}
```

## Reading and writing files

WASI allows your Rust functions to access the host computer's file system through the standard Rust `std::fs` API. In the Rust program, you operate on files through a relative path. The relative path's root is specified when you start the WasmEdge runtime.

```rust
use std::fs;
use std::fs::File;
use std::io::{Write, Read};

pub fn create_file(path: &str, content: &str) {
  let mut output = File::create(path).unwrap();
  output.write_all(content.as_bytes()).unwrap();
}

pub fn read_file(path: &str) -> String {
  let mut f = File::open(path).unwrap();
  let mut s = String::new();
  match f.read_to_string(&mut s) {
    Ok(_) => s,
    Err(e) => e.to_string(),
  }
}

pub fn del_file(path: &str) {
  fs::remove_file(path).expect(""Unable to delete"");
}
```

## A main() app

With a `main()` function, the Rust program can be compiled into a standalone WebAssembly program.

```rust
fn main() {
  println!(""Random number: {}"", get_random_i32());
  println!(""Random bytes: {:?}"", get_random_bytes());
  println!(""{}"", echo(""This is from a main function""));
  print_env();
  create_file(""tmp.txt"", ""This is in a file"");
  println!(""File content is {}"", read_file(""tmp.txt""));
  del_file(""tmp.txt"");
}
```

Use the command below to compile [the Rust project](https://github.com/second-state/rust-examples/blob/main/wasi/).

```bash
cargo build --target wasm32-wasi --release
```

To run it in `wasmedge`, do the following. The `--dir` option maps the current directory of the command shell to the file system's current directory inside the WebAssembly app.

```bash
$ wasmedge --dir .:. target/wasm32-wasi/release/wasi.wasm
Random number: -1157533356
Random bytes: [159, 159, 9, 119, 106, 172, 207, 82, 173, 145, 233, 214, 104, 35, 23, 53, 155, 12, 102, 231, 117, 67, 192, 215, 207, 202, 128, 198, 213, 41, 235, 57, 89, 223, 138, 70, 185, 137, 74, 162, 42, 20, 226, 177, 114, 170, 172, 39, 149, 99, 122, 68, 115, 205, 155, 202, 4, 48, 178, 224, 124, 42, 24, 56, 215, 90, 203, 150, 106, 128, 127, 201, 177, 187, 20, 195, 172, 56, 72, 28, 53, 163, 59, 36, 129, 160, 69, 203, 196, 72, 113, 61, 46, 249, 81, 134, 94, 134, 159, 51, 233, 247, 253, 116, 202, 210, 100, 75, 74, 95, 197, 44, 81, 87, 89, 115, 20, 226, 143, 139, 50, 60, 196, 59, 206, 105, 161, 226]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
wasi.wasm
File content is This is in a file
```

## Functions

As [we have seen](hello_world.md#a-simple-function), you can create WebAssembly functions in a Rust `lib.rs` project. You can also use WASI functions in those functions. However, an important caveat is that, without a `main()` function, you will need to explicitly call a helper function to initialize the environment for WASI functions to work properly.

Add a helper crate in Cargo.toml in the Rust program so that the WASI initialization code can be applied to your exported public library functions.

```toml
[dependencies]
... ...
wasmedge-wasi-helper = ""=0.2.0""
```

In the Rust function, we need to call `_initialize()` before we access any arguments and environment variables or operate any files.

```rust
pub fn print_env() -> i32 {
  _initialize();
  ... ...
}

pub fn create_file(path: &str, content: &str) -> String {
  _initialize();
  ... ...
}

pub fn read_file(path: &str) -> String {
  _initialize();
  ... ...
}

pub fn del_file(path: &str) -> String {
  _initialize();
  ... ...
}
```
","**Code Summary**

The provided code is a Rust tutorial on using the WebAssembly Systems Interface (WASI) to access operating system services. The example project demonstrates how to use Rust standard APIs to access random numbers, print and debug from Rust, pass CLI arguments and environment variables, read and write files, and create a main() function.

**Key Components**

1. **Random numbers**: The code uses the `rand` and `getrandom` crates to generate random numbers in WebAssembly.
2. **Printing and debugging**: The `println!` macro works in WASI, allowing Rust programs to print to the `STDOUT` of the process running WasmEdge.
3. **Arguments and environment variables**: The code demonstrates how to pass CLI arguments and access OS environment variables using `env::args()` and `env::vars()`.
4. **File system**: WASI allows Rust functions to access the host computer's file system through the standard Rust `std::fs` API.
5. **Main function**: With a `main()` function, the Rust program can be compiled into a standalone WebAssembly program.

**Potential Issues**

1. **Error handling**: The code does not handle errors properly in some cases, such as when reading from files or accessing environment variables. It's essential to add proper error handling mechanisms.
2. **Security**: When using WASI functions, it's crucial to ensure that the code is secure and follows best practices for sensitive operations like file I/O and environment variable access.

**Areas for Improvement**

1. **Code organization**: The provided code is a tutorial example, but in a production setting, consider organizing the code into separate modules or libraries for better maintainability.
2. **Testing**: Adding unit tests or integration tests would help ensure that the code works correctly across various scenarios and edge cases.

By addressing these potential issues and areas for improvement, you can create more robust and secure WebAssembly applications using the WASI standard with Rust."
docs/develop/rust/socket_networking/server.md,"---
sidebar_position: 2
---

# Socket server

As we described in the [client](client.md) chapter, with the WasmEdge socket API, it is possible for Rust developers to work directly on the TCP and UDP socket level. In this chapter, we will show how to create HTTP servers with the TCP socket API. We chose HTTP here for demonstration purposes due to the simplicity of the HTTP protocol. If you need a production-ready HTTP server, check out the [HTTP server](../http_service/server.md) chapter.

- [An HTTP server example](#an-http-server-example)
- [A non-blocking HTTP server example](#a-non-blocking-http-server-example)

<!-- prettier-ignore -->
:::note
Before we start, ensure [you have Rust and WasmEdge installed](../setup.md).
:::

## An HTTP server example

Build and run [the example](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_server) in WasmEdge.

```bash
git clone https://github.com/second-state/wasmedge_wasi_socket
cd wasmedge_wasi_socket/http_server

# Build the Rust code
cargo build --target wasm32-wasi --release
# Use the AoT compiler for better performance
wasmedge compile target/wasm32-wasi/release/http_server.wasm http_server.wasm

# Run the example
$wasmedge http_server.wasm
new connection at 1234
```

To test the HTTP server, you can submit an HTTP request via `curl`.

```bash
$ curl -d ""name=WasmEdge"" -X POST http://127.0.0.1:1234
echo: name=WasmEdge
```

The [source code](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_server) for the HTTP server application is available as follows. The example below shows an HTTP server that echoes back any incoming request.

```rust
use bytecodec::DecodeExt;
use httpcodec::{HttpVersion, ReasonPhrase, Request, RequestDecoder, Response, StatusCode};
use std::io::{Read, Write};
#[cfg(feature = ""std"")]
use std::net::{Shutdown, TcpListener, TcpStream};
#[cfg(not(feature = ""std""))]
use wasmedge_wasi_socket::{Shutdown, TcpListener, TcpStream};

fn handle_http(req: Request<String>) -> bytecodec::Result<Response<String>> {
  Ok(Response::new(
    HttpVersion::V1_0,
    StatusCode::new(200)?,
    ReasonPhrase::new("""")?,
    format!(""echo: {}"", req.body()),
  ))
}

fn handle_client(mut stream: TcpStream) -> std::io::Result<()> {
  let mut buff = [0u8; 1024];
  let mut data = Vec::new();

  loop {
    let n = stream.read(&mut buff)?;
    data.extend_from_slice(&buff[0..n]);
    if n < 1024 {
      break;
    }
  }

  let mut decoder =
    RequestDecoder::<httpcodec::BodyDecoder<bytecodec::bytes::Utf8Decoder>>::default();

  let req = match decoder.decode_from_bytes(data.as_slice()) {
    Ok(req) => handle_http(req),
    Err(e) => Err(e),
  };

  let r = match req {
    Ok(r) => r,
    Err(e) => {
      let err = format!(""{:?}"", e);
      Response::new(
        HttpVersion::V1_0,
        StatusCode::new(500).unwrap(),
        ReasonPhrase::new(err.as_str()).unwrap(),
        err.clone(),
      )
    }
  };

  let write_buf = r.to_string();
  stream.write(write_buf.as_bytes())?;
  stream.shutdown(Shutdown::Both)?;
  Ok(())
}

fn main() -> std::io::Result<()> {
  let port = std::env::var(""PORT"").unwrap_or(1234.to_string());
  println!(""new connection at {}"", port);
  let listener = TcpListener::bind(format!(""0.0.0.0:{}"", port))?;
  loop {
    let _ = handle_client(listener.accept()?.0);
  }
}
```

## A non-blocking HTTP server example

Build and run [the example](https://github.com/second-state/wasmedge_wasi_socket/) in WasmEdge as follows.

```bash
git clone https://github.com/second-state/wasmedge_wasi_socket
cd wasmedge_wasi_socket

# Build the Rust code
cargo build --target wasm32-wasi --release
# Use the AoT compiler for better performance
wasmedge compile target/wasm32-wasi/release/poll_tcp_listener.wasm poll_tcp_listener.wasm

# Run the example
wasmedge poll_tcp_listener.wasm
```

You can submit an HTTP request via `curl` to test the HTTP server.

```bash
$ curl -d ""name=WasmEdge"" -X POST http://127.0.0.1:1234
echo: name=WasmEdge
```

The [source code](https://github.com/second-state/wasmedge_wasi_socket/blob/main/examples/poll_tcp_listener.rs) for a non-blocking HTTP server application is available. The following `main()` function starts an HTTP server. It receives events from multiple open connections and processes them as they are received by calling the async handler functions registered to each connection. This server can process events from multiple open connections concurrently.

```rust
fn main() -> std::io::Result<()> {
    let mut connects = Connects::new();
    let server = TcpListener::bind(""127.0.0.1:1234"", true)?;
    connects.add(NetConn::Server(server));

    loop {
        let subs = connects_to_subscriptions(&connects);
        let events = poll::poll(&subs)?;

        for event in events {
            let conn_id = event.userdata as usize;
            match connects.get_mut(conn_id) {
                Some(NetConn::Server(server)) => match event.event_type {
                    poll::EventType::Timeout => unreachable!(),
                    poll::EventType::Error(e) => {
                        return Err(e);
                    }
                    poll::EventType::Read => {
                        let (mut tcp_client, addr) = server.accept(true)?;
                        println!(""accept from {}"", addr);

                        match tcp_client.write(DATA) {
                            Ok(n) if n < DATA.len() => {
                                println!(
                                    ""write hello error: {}"",
                                    io::Error::from(io::ErrorKind::WriteZero)
                                );
                                continue;
                            }
                            Ok(_) => {}
                            Err(ref err) if would_block(err) => {}
                            Err(ref err) if interrupted(err) => {}
                            Err(err) => {
                                println!(""write hello error: {}"", err);
                                continue;
                            }
                        }

                        let id = connects.add(NetConn::Client(tcp_client));
                        println!(""add conn[{}]"", id);
                    }
                    poll::EventType::Write => unreachable!(),
                },
                Some(NetConn::Client(client)) => {
                    match event.event_type {
                        poll::EventType::Timeout => {
                            // if Subscription timeout is not None.
                            unreachable!()
                        }
                        poll::EventType::Error(e) => {
                            println!(""tcp_client[{}] recv a io error: {}"", conn_id, e);
                            connects.remove(conn_id);
                        }
                        poll::EventType::Read => match handle_connection_read(client) {
                            Ok(true) => {
                                println!(""tcp_client[{}] is closed"", conn_id);
                                connects.remove(conn_id);
                            }
                            Err(e) => {
                                println!(""tcp_client[{}] recv a io error: {}"", conn_id, e);
                                connects.remove(conn_id);
                            }
                            _ => {}
                        },
                        poll::EventType::Write => unreachable!(),
                    }
                }
                _ => {}
            }
        }
    }
}
```

The `handle_connection()` function processes the data from those open connections. In this case, it just writes the request body into the response. It is also done asynchronously -- meaning that the `handle_connection()` function creates an event for the response and puts it in the queue. The main application loop processes the event and sends the response while waiting for data from other connections.

```rust
fn handle_connection_read(connection: &mut TcpStream) -> io::Result<bool> {
    let mut connection_closed = false;
    let mut received_buff = [0u8; 2048];

    let mut received_data = Vec::with_capacity(2048);
    loop {
        match connection.read(&mut received_buff) {
            Ok(0) => {
                connection_closed = true;
                break;
            }
            Ok(n) => {
                received_data.extend_from_slice(&received_buff[0..n]);
            }
            Err(ref err) if would_block(err) => break,
            Err(ref err) if interrupted(err) => continue,
            Err(err) => return Err(err),
        }
    }

    if !received_data.is_empty() {
        if let Ok(str_buf) = std::str::from_utf8(&received_data) {
            println!(""Received data: {}"", str_buf.trim_end());
        } else {
            println!(""Received (none UTF-8) data: {:?}"", received_data);
        }
    }

    if connection_closed {
        return Ok(true);
    }

    Ok(false)
}
```
","**Socket Server Overview**

The provided code is an implementation of a socket server in Rust, utilizing the WasmEdge API for WebAssembly (WASM) development. The server supports both HTTP and non-blocking TCP connections.

**Key Components**

1. **HTTP Server**: The `http_server` module contains an example of an HTTP server that echoes back any incoming request.
2. **Non-Blocking TCP Server**: The `poll_tcp_listener` module demonstrates a non-blocking TCP server using the WasmEdge API for WebAssembly.
3. **Connects and Subscriptions**: The `connects` data structure manages active connections, while the `subs` function generates subscriptions from connects.

**Functionality**

1. **TCP Listener**: The TCP listener is responsible for accepting new connections and registering them with the `connects` data structure.
2. **Connection Handling**: When a connection is established, the server processes events from that connection using the `poll` function, which handles reads and writes asynchronously.
3. **Data Processing**: The `handle_connection_read` function processes incoming data from connections, handling errors and sending responses.

**Potential Issues and Areas for Improvement**

1. **Error Handling**: While error handling is implemented in various places, it could be improved with more comprehensive error checking and reporting mechanisms.
2. **Code Organization**: Some functions, such as `handle_connection_read`, perform multiple responsibilities (data processing, error handling). Consider refactoring to improve code organization and reusability.
3. **Performance Optimization**: The use of synchronous I/O operations might impact server performance. Consider using asynchronous I/O or concurrency mechanisms like Tokio or async-std for better performance.
4. **Security**: As with any network-facing code, ensure proper security measures are implemented, such as input validation and sanitization, to prevent potential security vulnerabilities.

**Example Use Cases**

1. **HTTP Server Example**: Run the `http_server` example to demonstrate a basic HTTP server that echoes back incoming requests.
2. **Non-Blocking TCP Server Example**: Run the `poll_tcp_listener` example to showcase a non-blocking TCP server that processes connections and events asynchronously."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/socket_networking/server.md,"---
sidebar_position: 2
---

# Socket server

As we described in the [client](client.md) chapter, with the WasmEdge socket API, it is possible for Rust developers to work directly on the TCP and UDP socket level. In this chapter, we will show how to create HTTP servers with the TCP socket API. We chose HTTP here for demonstration purposes due to the simplicity of the HTTP protocol. If you need a production-ready HTTP server, check out the [HTTP server](../http_service/server.md) chapter.

- [An HTTP server example](#an-http-server-example)
- [A non-blocking HTTP server example](#a-non-blocking-http-server-example)

<!-- prettier-ignore -->
:::note
Before we start, ensure [you have Rust and WasmEdge installed](../setup.md).
:::

## An HTTP server example

Build and run [the example](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_server) in WasmEdge.

```bash
git clone https://github.com/second-state/wasmedge_wasi_socket
cd wasmedge_wasi_socket/http_server

# Build the Rust code
cargo build --target wasm32-wasi --release
# Use the AoT compiler for better performance
wasmedge compile target/wasm32-wasi/release/http_server.wasm http_server.wasm

# Run the example
$wasmedge http_server.wasm
new connection at 1234
```

To test the HTTP server, you can submit an HTTP request via `curl`.

```bash
$ curl -d ""name=WasmEdge"" -X POST http://127.0.0.1:1234
echo: name=WasmEdge
```

The [source code](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_server) for the HTTP server application is available as follows. The example below shows an HTTP server that echoes back any incoming request.

```rust
use bytecodec::DecodeExt;
use httpcodec::{HttpVersion, ReasonPhrase, Request, RequestDecoder, Response, StatusCode};
use std::io::{Read, Write};
#[cfg(feature = ""std"")]
use std::net::{Shutdown, TcpListener, TcpStream};
#[cfg(not(feature = ""std""))]
use wasmedge_wasi_socket::{Shutdown, TcpListener, TcpStream};

fn handle_http(req: Request<String>) -> bytecodec::Result<Response<String>> {
  Ok(Response::new(
    HttpVersion::V1_0,
    StatusCode::new(200)?,
    ReasonPhrase::new("""")?,
    format!(""echo: {}"", req.body()),
  ))
}

fn handle_client(mut stream: TcpStream) -> std::io::Result<()> {
  let mut buff = [0u8; 1024];
  let mut data = Vec::new();

  loop {
    let n = stream.read(&mut buff)?;
    data.extend_from_slice(&buff[0..n]);
    if n < 1024 {
      break;
    }
  }

  let mut decoder =
    RequestDecoder::<httpcodec::BodyDecoder<bytecodec::bytes::Utf8Decoder>>::default();

  let req = match decoder.decode_from_bytes(data.as_slice()) {
    Ok(req) => handle_http(req),
    Err(e) => Err(e),
  };

  let r = match req {
    Ok(r) => r,
    Err(e) => {
      let err = format!(""{:?}"", e);
      Response::new(
        HttpVersion::V1_0,
        StatusCode::new(500).unwrap(),
        ReasonPhrase::new(err.as_str()).unwrap(),
        err.clone(),
      )
    }
  };

  let write_buf = r.to_string();
  stream.write(write_buf.as_bytes())?;
  stream.shutdown(Shutdown::Both)?;
  Ok(())
}

fn main() -> std::io::Result<()> {
  let port = std::env::var(""PORT"").unwrap_or(1234.to_string());
  println!(""new connection at {}"", port);
  let listener = TcpListener::bind(format!(""0.0.0.0:{}"", port))?;
  loop {
    let _ = handle_client(listener.accept()?.0);
  }
}
```

## A non-blocking HTTP server example

Build and run [the example](https://github.com/second-state/wasmedge_wasi_socket/) in WasmEdge as follows.

```bash
git clone https://github.com/second-state/wasmedge_wasi_socket
cd wasmedge_wasi_socket

# Build the Rust code
cargo build --target wasm32-wasi --release
# Use the AoT compiler for better performance
wasmedge compile target/wasm32-wasi/release/poll_tcp_listener.wasm poll_tcp_listener.wasm

# Run the example
wasmedge poll_tcp_listener.wasm
```

You can submit an HTTP request via `curl` to test the HTTP server.

```bash
$ curl -d ""name=WasmEdge"" -X POST http://127.0.0.1:1234
echo: name=WasmEdge
```

The [source code](https://github.com/second-state/wasmedge_wasi_socket/blob/main/examples/poll_tcp_listener.rs) for a non-blocking HTTP server application is available. The following `main()` function starts an HTTP server. It receives events from multiple open connections and processes them as they are received by calling the async handler functions registered to each connection. This server can process events from multiple open connections concurrently.

```rust
fn main() -> std::io::Result<()> {
    let mut connects = Connects::new();
    let server = TcpListener::bind(""127.0.0.1:1234"", true)?;
    connects.add(NetConn::Server(server));

    loop {
        let subs = connects_to_subscriptions(&connects);
        let events = poll::poll(&subs)?;

        for event in events {
            let conn_id = event.userdata as usize;
            match connects.get_mut(conn_id) {
                Some(NetConn::Server(server)) => match event.event_type {
                    poll::EventType::Timeout => unreachable!(),
                    poll::EventType::Error(e) => {
                        return Err(e);
                    }
                    poll::EventType::Read => {
                        let (mut tcp_client, addr) = server.accept(true)?;
                        println!(""accept from {}"", addr);

                        match tcp_client.write(DATA) {
                            Ok(n) if n < DATA.len() => {
                                println!(
                                    ""write hello error: {}"",
                                    io::Error::from(io::ErrorKind::WriteZero)
                                );
                                continue;
                            }
                            Ok(_) => {}
                            Err(ref err) if would_block(err) => {}
                            Err(ref err) if interrupted(err) => {}
                            Err(err) => {
                                println!(""write hello error: {}"", err);
                                continue;
                            }
                        }

                        let id = connects.add(NetConn::Client(tcp_client));
                        println!(""add conn[{}]"", id);
                    }
                    poll::EventType::Write => unreachable!(),
                },
                Some(NetConn::Client(client)) => {
                    match event.event_type {
                        poll::EventType::Timeout => {
                            // if Subscription timeout is not None.
                            unreachable!()
                        }
                        poll::EventType::Error(e) => {
                            println!(""tcp_client[{}] recv a io error: {}"", conn_id, e);
                            connects.remove(conn_id);
                        }
                        poll::EventType::Read => match handle_connection_read(client) {
                            Ok(true) => {
                                println!(""tcp_client[{}] is closed"", conn_id);
                                connects.remove(conn_id);
                            }
                            Err(e) => {
                                println!(""tcp_client[{}] recv a io error: {}"", conn_id, e);
                                connects.remove(conn_id);
                            }
                            _ => {}
                        },
                        poll::EventType::Write => unreachable!(),
                    }
                }
                _ => {}
            }
        }
    }
}
```

The `handle_connection()` function processes the data from those open connections. In this case, it just writes the request body into the response. It is also done asynchronously -- meaning that the `handle_connection()` function creates an event for the response and puts it in the queue. The main application loop processes the event and sends the response while waiting for data from other connections.

```rust
fn handle_connection_read(connection: &mut TcpStream) -> io::Result<bool> {
    let mut connection_closed = false;
    let mut received_buff = [0u8; 2048];

    let mut received_data = Vec::with_capacity(2048);
    loop {
        match connection.read(&mut received_buff) {
            Ok(0) => {
                connection_closed = true;
                break;
            }
            Ok(n) => {
                received_data.extend_from_slice(&received_buff[0..n]);
            }
            Err(ref err) if would_block(err) => break,
            Err(ref err) if interrupted(err) => continue,
            Err(err) => return Err(err),
        }
    }

    if !received_data.is_empty() {
        if let Ok(str_buf) = std::str::from_utf8(&received_data) {
            println!(""Received data: {}"", str_buf.trim_end());
        } else {
            println!(""Received (none UTF-8) data: {:?}"", received_data);
        }
    }

    if connection_closed {
        return Ok(true);
    }

    Ok(false)
}
```
","**Code Summary**

The provided code is a part of a larger documentation on creating a socket server using WasmEdge and Rust. The code snippet includes two examples: an HTTP server example and a non-blocking HTTP server example.

**Key Components**

1. **HTTP Server Example**: This example demonstrates how to create a simple HTTP server that echoes back any incoming request. It uses the `httpcodec` library for encoding and decoding HTTP requests and responses.
2. **Non-Blocking HTTP Server Example**: This example shows how to create a non-blocking HTTP server using WasmEdge's polling mechanism. The server can receive events from multiple open connections concurrently.

**Potential Issues or Areas for Improvement**

1. **Error Handling**: While the code handles some potential errors, such as `WouldBlock` and `Interrupted`, it could benefit from more comprehensive error handling mechanisms.
2. **Code Duplication**: Some parts of the code, such as the `handle_connection_read()` function, are duplicated in both examples. This can be refactored to reduce code duplication and improve maintainability.
3. **Commenting**: While some parts of the code have comments, additional comments could be added to explain complex logic or assumptions made in the code.

**Code Structure**

The code is well-organized into separate functions and modules for each example. However, it might benefit from a more modular structure, where common functionality is extracted into separate modules or libraries.

Overall, the provided code demonstrates a good understanding of creating socket servers using WasmEdge and Rust. With some improvements in error handling, code duplication, commenting, and modularity, it could be even more effective and maintainable."
docs/develop/javascript/networking.md,"---
sidebar_position: 3
---

# Networking

The QuickJS WasmEdge Runtime supports Node.js's `http` and `fetch` APIs via the WasmEdge [networking socket extension](https://github.com/second-state/wasmedge_wasi_socket). That enables WasmEdge developers to create HTTP server and client, as well as TCP/IP server and client, applications in JavaScript.

The networking API in WasmEdge is non-blocking and hence supports asynchronous I/O-intensive applications. With this API, the JavaScript program can open multiple connections concurrently. It polls those connections or registers async callback functions to process data whenever data comes in, without waiting for any one connection to complete its data transfer. That allows the single-threaded application to handle multiple, multiple concurrent requests.

- [Prerequisites](#prerequisites)
- [Fetch client](#fetch-client)
- [HTTP server](#http-server)
- [TCP server and client](#tcp-server-and-client)

## Prerequisites

[Install WasmEdge](../../start/install.md). To make HTTPS requests, install the [WasmEdge TLS plug-in](../../start/install.md#tls-plug-in).

[Install WasmEdge-QuickJS](./hello_world#prerequisites). Make sure that the `modules` directory is located in your local directory where you want to execute the `wasmedge` command.

## Fetch client

The `fetch` API is widely used in browser and node-based JavaScript applications to fetch content over the network. Building on top of its non-blocking async network socket API, the WasmEdge QuickJS runtime supports the `fetch` API. That makes many JS APIs and modules reusable out of the box.

The [example_js/wasi_http_fetch.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js) example demonstrates how to use the `fetch` API in WasmEdge.

```bash
wasmedge --dir .:. wasmedge_quickjs.wasm example_js/wasi_http_fetch.js
```

It takes a few seconds to complete all the HTTP requests in the program. Once they are done, you will see the HTTP responses printed to the console. Let's look into how the `wasi_http_fetch.js` JavaScript program works.

The code snippet below shows an async HTTP GET from the `httpbin.org` test server. While the program waits for and processes the GET content, it can start another request.

```javascript
async function test_fetch() {
  try {
    let r = await fetch('http://httpbin.org/get?id=1');
    print('test_fetch\n', await r.text());
  } catch (e) {
    print(e);
  }
}
test_fetch();
```

The code snippet below shows how to an sync HTTP POST to a remote server.

```javascript
async function test_fetch_post() {
  try {
    let r = await fetch('http://httpbin.org/post', {
      method: 'post',
      body: 'post_body',
    });
    print('test_fetch_post\n', await r.text());
  } catch (e) {
    print(e);
  }
}
test_fetch_post();
```

An async HTTP PUT request is as follows.

```javascript
async function test_fetch_put() {
  try {
    let r = await fetch('http://httpbin.org/put', {
      method: 'put',
      body: JSON.stringify({ a: 1 }),
      headers: { 'Context-type': 'application/json' },
    });
    print('test_fetch_put\n', await r.text());
  } catch (e) {
    print(e);
  }
}
test_fetch_put();
```

## HTTP server

If you want to run microservices in the WasmEdge runtime, you must create an HTTP server with it. The [example_js/wasi_http_echo.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_server.js) example shows you how to create an HTTP server listening on port 8001 using Node.js compatible APIs.

```bash
wasmedge --dir .:. wasmedge_quickjs.wasm example_js/wasi_http_server.js
```

Use the following `curl` command to send an HTTP POST request to the server. It prepends ""echo:"" to any incoming request and sends it back as a response.

```bash
$ curl -d ""WasmEdge"" -X POST http://localhost:8001/
echo:WasmEdge
```

The JavaScript source code of the HTTP server is as follows.

```javascript
import { createServer, request, fetch } from 'http';

createServer((req, resp) => {
  req.on('data', (body) => {
    resp.write('echo:');
    resp.end(body);
  });
}).listen(8001, () => {
  print('listen 8001 ...\n');
});
```

## TCP server and client

The WasmEdge runtime goes beyond the Node.js API. The `WasiTcpServer` API can create a server that accepts non-HTTP requests. The [example_js/wasi_net_echo.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_net_echo.js) example shows you how to create a TCP server and then create a TCP client to send a request to it.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/wasi_net_echo.js
listen 8000 ...
server accept: 127.0.0.1:49040
server recv: hello
client recv: echo:hello
```

The TCP server in `wasi_net_echo.js` is as follows.

```javascript
import * as net from 'wasi_net';
import { TextDecoder } from 'util';

async function server_start() {
  print('listen 8000 ...');
  try {
    let s = new net.WasiTcpServer(8000);
    for (var i = 0; i < 100; i++) {
      let cs = await s.accept();
      handle_client(cs);
    }
  } catch (e) {
    print('server accept error:', e);
  }
}

server_start();
```

The `handle_client()` function contains the logic for processing and responding to incoming requests. You will need to read and parse the data stream in the request yourself in this function. In this example, it simply echoes the data back with a prefix.

```javascript
async function handle_client(cs) {
  print('server accept:', cs.peer());
  try {
    while (true) {
      let d = await cs.read();
      if (d == undefined || d.byteLength <= 0) {
        break;
      }
      let s = new TextDecoder().decode(d);
      print('server recv:', s);
      cs.write('echo:' + s);
    }
  } catch (e) {
    print('server handle_client error:', e);
  }
  print('server: conn close');
}
```

The TCP client uses WasmEdge's `WasiTcpConn` API to send in a request and receive the echoed response.

```javascript
async function connect_test() {
  try {
    let ss = await net.WasiTcpConn.connect('127.0.0.1:8000');
    ss.write('hello');
    let msg = (await ss.read()) || '';
    print('client recv:', new TextDecoder().decode(msg));
  } catch (e) {
    print('client catch:', e);
  } finally {
    nextTick(() => {
      exit(0);
    });
  }
}

connect_test();
```

With async HTTP networking, developers can create I/O intensive applications, such as database-driven microservices, in JavaScript and run them safely and efficiently in WasmEdge.
","**Summary**

The provided code is a comprehensive guide to using the `http` and `fetch` APIs in WasmEdge, a JavaScript runtime that supports Node.js's networking socket extension. The code includes examples of creating HTTP servers, clients, TCP servers, and clients, as well as using async callbacks for processing data.

**Key Components**

1. **HTTP Client**: Uses the `fetch` API to send HTTP requests and receive responses.
2. **HTTP Server**: Creates an HTTP server listening on port 8001 using Node.js-compatible APIs.
3. **TCP Server and Client**: Uses WasmEdge's `WasiTcpServer` and `WasiTcpConn` APIs to create a TCP server and client, respectively.

**Example Use Cases**

1. Creating I/O-intensive applications in JavaScript for database-driven microservices.
2. Using async HTTP networking to process data streams efficiently.
3. Developing microservices that communicate with each other using TCP connections.

**Potential Issues or Areas for Improvement**

1. Error handling: The code could benefit from more robust error handling and logging mechanisms.
2. Security: The examples use default ports and do not implement any authentication or authorization mechanisms.
3. Performance: The code does not optimize performance, which may be a concern for high-traffic applications.
4. Code organization: The examples mix JavaScript code with comments and explanations, making it hard to follow.

**Best Practices**

1. Follow standard naming conventions and coding style guidelines.
2. Use async/await syntax consistently throughout the code.
3. Implement robust error handling and logging mechanisms.
4. Optimize performance for high-traffic applications.
5. Keep code organized and modular for easier maintenance and updates."
docs/start/build-and-run/aot.md,"---
sidebar_position: 3
---

# The AoT Compiler

After [installation](../install.md#install), users can execute the `wasmedge compile` command.

The usage of the `wasmedge compile` command will be:

```bash
$ wasmedge compile -h
USAGE
   wasmedge compile [OPTIONS] [--] WASM WASM_SO

...
```

The `wasmedge compile` command can compile WebAssembly into native machine code (i.e., the AOT compiler). For the pure WebAssembly, the `wasmedge` tool will execute the WASM in interpreter mode. After compiling with the `wasmedge compile` AOT compiler, the `wasmedge` tool can execute the WASM in AOT mode, which is much faster.

## Options

The options of the `wasmedge compile` command are as follows.

1. `-h|--help`: Show the help messages. Will ignore the other arguments below.
2. _(Optional)_ `--dump`: Dump the LLVM IR to `wasm.ll` and `wasm-opt.ll`.
3. _(Optional)_ `--interruptible`: Generate the binary which supports interruptible execution.
   - By default, the AOT-compiled WASM not supports [interruptions in asynchronous executions](../../embed/c/reference/0.12.x#async).
4. _(Optional)_ Statistics information:
   - By default, the AOT-compiled WASM does not support all statistics even if the options are turned on when running the `wasmedge` tool.
   - Use `--enable-time-measuring` to generate code for enabling time-measuring statistics in execution.
   - Use `--enable-gas-measuring` to generate code for enabling the statistics of gas measuring in execution.
   - Use `--enable-instruction-count` to generate code for enabling the statistics of counting WebAssembly instructions.
   - Or use `--enable-all-statistics` to generate code for enabling all of the statistics.
5. _(Optional)_ `--generic-binary`: Generate the generic binary of the current host CPU architecture.
6. _(Optional)_ WebAssembly proposals:
   - Use `--disable-import-export-mut-globals` to disable the [Import/Export of Mutable Globals](https://github.com/WebAssembly/mutable-global) proposal (Default `ON`).
   - Use `--disable-non-trap-float-to-int` to disable the [Non-Trapping Float-to-Int Conversions](https://github.com/WebAssembly/nontrapping-float-to-int-conversions) proposal (Default `ON`).
   - Use `--disable-sign-extension-operators` to disable the [Sign-Extension Operators](https://github.com/WebAssembly/sign-extension-ops) proposal (Default `ON`).
   - Use `--disable-multi-value` to disable the [Multi-value](https://github.com/WebAssembly/multi-value) proposal (Default `ON`).
   - Use `--disable-bulk-memory` to disable the [Bulk Memory Operations](https://github.com/WebAssembly/bulk-memory-operations) proposal (Default `ON`).
   - Use `--disable-reference-types` to disable the [Reference Types](https://github.com/WebAssembly/reference-types) proposal (Default `ON`).
   - Use `--disable-simd` to disable the [Fixed-width SIMD](https://github.com/webassembly/simd) proposal (Default `ON`).
   - Use `--enable-multi-memory` to enable the [Multiple Memories](https://github.com/WebAssembly/multi-memory) proposal (Default `OFF`).
   - Use `--enable-tail-call` to enable the [Tail call](https://github.com/WebAssembly/tail-call) proposal (Default `OFF`).
   - Use `--enable-extended-const` to enable the [Extended Constant Expressions](https://github.com/WebAssembly/extended-const) proposal (Default `OFF`).
   - Use `--enable-threads` to enable the [Threads](https://github.com/webassembly/threads) proposal (Default `OFF`).
   - Use `--enable-function-reference` to enable the [Typed-Function References](https://github.com/WebAssembly/function-references) proposal (Default `OFF`).
   - Use `--enable-all` to enable ALL proposals above.
7. _(Optional)_ `--optimize`: Select the LLVM optimization level.
   - Use `--optimize LEVEL` to set the optimization level. The `LEVEL` should be one of `0`, `1`, `2`, `3`, `s`, or `z`.
   - The default value will be `2`, which means `O2`.
8. Input WASM file (`/path/to/wasm/file`).
9. Output path (`/path/to/output/file`).
   - By default, the `wasmedge compile` command will output the [universal WASM format](#output-format-universal-wasm).
   - If the specific file extension (`.so` on Linux, `.dylib` on MacOS, and `.dll` on Windows) is assigned in the output path, the `wasmedge compile` command will output the [shared library format](#output-format-shared-library).

## Example

We created the hand-written [fibonacci.wat](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wat) and used the [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) tool to convert it into the `fibonacci.wasm` WebAssembly program. Take it, for example. It exported a `fib()` function, which takes a single `i32` integer as the input parameter.

You can run:

```bash
wasmedge compile fibonacci.wasm fibonacci_aot.wasm
```

or:

```bash
wasmedge compile fibonacci.wasm fibonacci_aot.so # On Linux.
```

The output will be:

```bash
[2022-09-09 14:22:10.540] [info] compile start
[2022-09-09 14:22:10.541] [info] verify start
[2022-09-09 14:22:10.542] [info] optimize start
[2022-09-09 14:22:10.547] [info] codegen start
[2022-09-09 14:22:10.552] [info] output start
[2022-09-09 14:22:10.600] [info] compile done
```

Then you can execute the output file with `wasmedge` and measure the execution time:

```bash
time wasmedge --reactor fibonacci_aot.wasm fib 30
```

The output will be:

```bash
1346269

real    0m0.029s
user    0m0.012s
sys     0m0.014s
```

Then you can compare it with the interpreter mode:

```bash
time wasmedge --reactor fibonacci.wasm fib 30
```

The output shows that the AOT-compiled WASM is much faster than the interpreter mode:

```bash
1346269

real    0m0.442s
user    0m0.427s
sys     0m0.012s
```

## Output Format: Universal WASM

By default, the `wasmedge compile` AOT compiler tool could wrap the AOT-compiled native binary into a custom section in the origin WASM file. We call this the universal WASM binary format.

This AOT-compiled WASM file is compatible with any WebAssembly runtime. However, when this WASM file is executed by the WasmEdge runtime, WasmEdge will extract the native binary from the custom section and execute it in AOT mode.

<!-- prettier-ignore -->
:::note
On MacOS platforms, the universal WASM format will `bus error` in execution. By default, the `wasmedge compile` tool optimizes the WASM in the `O2` level. We are trying to fix this issue. For working around, please use the shared library output format instead.
:::

```bash
wasmedge compile app.wasm app_aot.wasm
wasmedge app_aot.wasm
```

## Output Format: Shared Library

Users can assign the shared library extension for the output files (`.so` on Linux, `.dylib` on MacOS, and `.dll` on Windows) to generate the shared library output format output.

This AOT-compiled WASM file is only for WasmEdge use and cannot be used by other WebAssembly runtimes.

```bash
wasmedge compile app.wasm app_aot.so
wasmedge app_aot.so
```
","**Summary**

The provided code is a documentation of the `wasmedge compile` command, which is used to compile WebAssembly (WASM) into native machine code using the AOT (Ahead-of-Time) compiler. The command has various options that allow users to customize the compilation process.

**Key Components**

1. **Compile Command**: The main component is the `wasmedge compile` command, which takes two arguments: the input WASM file and the output path.
2. **Options**: The command has several options that can be used to customize the compilation process, including:
	* `-h|--help`: Displays help messages.
	* `--dump`: Dumps the LLVM IR to `wasm.ll` and `wasm-opt.ll`.
	* `--interruptible`: Generates a binary that supports interruptible execution.
	* Statistics options (`--enable-time-measuring`, `--enable-gas-measuring`, etc.).
	* Proposal options (`--disable-import-export-mut-globals`, etc.).
	* Optimization level (`--optimize`).
3. **Output Formats**: The command can produce two types of output formats:
	+ Universal WASM format: A custom section in the origin WASM file that contains the native binary.
	+ Shared library format: A shared library file (`.so` on Linux, `.dylib` on MacOS, and `.dll` on Windows) that contains the native binary.

**Example Use Case**

The documentation provides an example of compiling a hand-written WebAssembly program (`fibonacci.wat`) to a native binary using the `wasmedge compile` command. The output is a file named `fibonacci_aot.wasm`, which can be executed using the WasmEdge runtime.

**Potential Issues and Areas for Improvement**

1. **Compatibility**: The universal WASM format may not work correctly on MacOS platforms.
2. **Optimization**: The default optimization level may not produce optimal results for certain use cases.
3. **Proposal Options**: Some proposal options may not be fully implemented or may require additional configuration.

Overall, the `wasmedge compile` command provides a powerful tool for compiling WebAssembly into native machine code, but users should be aware of the potential issues and areas for improvement to get the best results."
i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/networking.md,"---
sidebar_position: 3
---

# Networking

The QuickJS WasmEdge Runtime supports Node.js's `http` and `fetch` APIs via the WasmEdge [networking socket extension](https://github.com/second-state/wasmedge_wasi_socket). That enables WasmEdge developers to create HTTP server and client, as well as TCP/IP server and client, applications in JavaScript.

The networking API in WasmEdge is non-blocking and hence supports asynchronous I/O-intensive applications. With this API, the JavaScript program can open multiple connections concurrently. It polls those connections or registers async callback functions to process data whenever data comes in, without waiting for any one connection to complete its data transfer. That allows the single-threaded application to handle multiple, multiple concurrent requests.

- [Prerequisites](#prerequisites)
- [Fetch client](#fetch-client)
- [HTTP server](#http-server)
- [TCP server and client](#tcp-server-and-client)

## Prerequisites

[Install WasmEdge](../../start/install.md). To make HTTPS requests, install the [WasmEdge TLS plug-in](../../start/install.md#tls-plug-in).

[Install WasmEdge-QuickJS](./hello_world#prerequisites). Make sure that the `modules` directory is located in your local directory where you want to execute the `wasmedge` command.

## Fetch client

The `fetch` API is widely used in browser and node-based JavaScript applications to fetch content over the network. Building on top of its non-blocking async network socket API, the WasmEdge QuickJS runtime supports the `fetch` API. That makes many JS APIs and modules reusable out of the box.

The [example_js/wasi_http_fetch.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js) example demonstrates how to use the `fetch` API in WasmEdge.

```bash
wasmedge --dir .:. wasmedge_quickjs.wasm example_js/wasi_http_fetch.js
```

It takes a few seconds to complete all the HTTP requests in the program. Once they are done, you will see the HTTP responses printed to the console. Let's look into how the `wasi_http_fetch.js` JavaScript program works.

The code snippet below shows an async HTTP GET from the `httpbin.org` test server. While the program waits for and processes the GET content, it can start another request.

```javascript
async function test_fetch() {
  try {
    let r = await fetch('http://httpbin.org/get?id=1');
    print('test_fetch\n', await r.text());
  } catch (e) {
    print(e);
  }
}
test_fetch();
```

The code snippet below shows how to an sync HTTP POST to a remote server.

```javascript
async function test_fetch_post() {
  try {
    let r = await fetch('http://httpbin.org/post', {
      method: 'post',
      body: 'post_body',
    });
    print('test_fetch_post\n', await r.text());
  } catch (e) {
    print(e);
  }
}
test_fetch_post();
```

An async HTTP PUT request is as follows.

```javascript
async function test_fetch_put() {
  try {
    let r = await fetch('http://httpbin.org/put', {
      method: 'put',
      body: JSON.stringify({ a: 1 }),
      headers: { 'Context-type': 'application/json' },
    });
    print('test_fetch_put\n', await r.text());
  } catch (e) {
    print(e);
  }
}
test_fetch_put();
```

## HTTP server

If you want to run microservices in the WasmEdge runtime, you must create an HTTP server with it. The [example_js/wasi_http_echo.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_server.js) example shows you how to create an HTTP server listening on port 8001 using Node.js compatible APIs.

```bash
wasmedge --dir .:. wasmedge_quickjs.wasm example_js/wasi_http_server.js
```

Use the following `curl` command to send an HTTP POST request to the server. It prepends ""echo:"" to any incoming request and sends it back as a response.

```bash
$ curl -d ""WasmEdge"" -X POST http://localhost:8001/
echo:WasmEdge
```

The JavaScript source code of the HTTP server is as follows.

```javascript
import { createServer, request, fetch } from 'http';

createServer((req, resp) => {
  req.on('data', (body) => {
    resp.write('echo:');
    resp.end(body);
  });
}).listen(8001, () => {
  print('listen 8001 ...\n');
});
```

## TCP server and client

The WasmEdge runtime goes beyond the Node.js API. The `WasiTcpServer` API can create a server that accepts non-HTTP requests. The [example_js/wasi_net_echo.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_net_echo.js) example shows you how to create a TCP server and then create a TCP client to send a request to it.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/wasi_net_echo.js
listen 8000 ...
server accept: 127.0.0.1:49040
server recv: hello
client recv: echo:hello
```

The TCP server in `wasi_net_echo.js` is as follows.

```javascript
import * as net from 'wasi_net';
import { TextDecoder } from 'util';

async function server_start() {
  print('listen 8000 ...');
  try {
    let s = new net.WasiTcpServer(8000);
    for (var i = 0; i < 100; i++) {
      let cs = await s.accept();
      handle_client(cs);
    }
  } catch (e) {
    print('server accept error:', e);
  }
}

server_start();
```

The `handle_client()` function contains the logic for processing and responding to incoming requests. You will need to read and parse the data stream in the request yourself in this function. In this example, it simply echoes the data back with a prefix.

```javascript
async function handle_client(cs) {
  print('server accept:', cs.peer());
  try {
    while (true) {
      let d = await cs.read();
      if (d == undefined || d.byteLength <= 0) {
        break;
      }
      let s = new TextDecoder().decode(d);
      print('server recv:', s);
      cs.write('echo:' + s);
    }
  } catch (e) {
    print('server handle_client error:', e);
  }
  print('server: conn close');
}
```

The TCP client uses WasmEdge's `WasiTcpConn` API to send in a request and receive the echoed response.

```javascript
async function connect_test() {
  try {
    let ss = await net.WasiTcpConn.connect('127.0.0.1:8000');
    ss.write('hello');
    let msg = (await ss.read()) || '';
    print('client recv:', new TextDecoder().decode(msg));
  } catch (e) {
    print('client catch:', e);
  } finally {
    nextTick(() => {
      exit(0);
    });
  }
}

connect_test();
```

With async HTTP networking, developers can create I/O intensive applications, such as database-driven microservices, in JavaScript and run them safely and efficiently in WasmEdge.
","**Summary**

The provided code is a documentation for the QuickJS WasmEdge Runtime's networking capabilities. It supports Node.js's `http` and `fetch` APIs, enabling developers to create HTTP servers and clients, as well as TCP/IP servers and clients, in JavaScript.

The code covers various aspects of networking, including:

1. **Prerequisites**: Installing WasmEdge, WasmEdge-QuickJS, and the TLS plug-in.
2. **Fetch client**: Using the `fetch` API to make HTTP requests in a non-blocking manner.
3. **HTTP server**: Creating an HTTP server using Node.js-compatible APIs.
4. **TCP server and client**: Implementing a TCP server and client using WasmEdge's `WasiTcpServer` and `WasiTcpConn` APIs.

**Key Components**

1. **Example code**: The code includes example JavaScript programs for each networking scenario, demonstrating how to use the APIs to perform specific tasks.
2. **API documentation**: The documentation provides an overview of each API and its usage.
3. **Error handling**: The code includes error handling mechanisms to ensure that applications can recover from errors and exceptions.

**Potential Issues or Areas for Improvement**

1. **Documentation completeness**: Some sections, such as the TCP server and client examples, could benefit from more detailed explanations and examples.
2. **Code organization**: The example code is scattered throughout the documentation, which may make it difficult to follow and understand.
3. **API consistency**: The `WasiTcpServer` and `WasiTcpConn` APIs have different usage patterns, which may cause confusion for developers.

**Recommendations**

1. **Improve API documentation**: Provide more detailed explanations, examples, and usage notes for each API.
2. **Organize example code**: Group related example code together to make it easier to follow and understand.
3. **Consolidate APIs**: Consider merging or refactoring the `WasiTcpServer` and `WasiTcpConn` APIs to reduce complexity and improve consistency."
docs/embed/c/reference/upgrade_to_0.12.0.md,"---
sidebar_position: 6
---

# Upgrade to WasmEdge 0.12.0

Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the `0.11.2` to the `0.12.0` version.

## Concepts

1. Removed the members of the `WasmEdge_HostRegistration` enumeration.

   The following members of the `WasmEdge_HostRegistration` enumeration are removed:

   - `WasmEdge_HostRegistration_WasmEdge_Process`
   - `WasmEdge_HostRegistration_WasiNN`
   - `WasmEdge_HostRegistration_WasiCrypto_Common`
   - `WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon`
   - `WasmEdge_HostRegistration_WasiCrypto_Kx`
   - `WasmEdge_HostRegistration_WasiCrypto_Signatures`
   - `WasmEdge_HostRegistration_WasiCrypto_Symmetric`

   The `WasmEdge_VMContext` will create and register the host modules automatically now. If the plug-ins are not loaded, the `WasmEdge_VMContext` will create and register the mock modules to prevent from import failed.

2. Removed the module instance creation functions of the plug-ins.

   The following APIs are removed:

   - `WasmEdge_ModuleInstanceCreateWasiNN()`
   - `WasmEdge_ModuleInstanceCreateWasiCryptoCommon()`
   - `WasmEdge_ModuleInstanceCreateWasiCryptoAsymmetricCommon()`
   - `WasmEdge_ModuleInstanceCreateWasiCryptoKx()`
   - `WasmEdge_ModuleInstanceCreateWasiCryptoSignatures()`
   - `WasmEdge_ModuleInstanceCreateWasiCryptoSymmetric()`
   - `WasmEdge_ModuleInstanceCreateWasmEdgeProcess()`

   For the new examples for creating the module instances from plug-ins, please refer to [the example below](#creating-the-module-instance-from-a-plug-in).

3. New module instance retrieving API of `VM` context.

   - Added `WasmEdge_VMGetRegisteredModule()` for retrieving registered named module in VM context quickly.
   - Added `WasmEdge_VMListRegisteredModuleLength()` and `WasmEdge_VMListRegisteredModule()` for listing registered named modules in VM context quickly.

## The `WasmEdge_HostRegistration` for plug-ins is not necessary in VM contexts

Before the version `0.11.2`, developers should add the configurations when they want to load the plug-ins in VM:

```c
/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */
WasmEdge_PluginLoadWithDefaultPaths();
WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(
    Conf, WasmEdge_HostRegistration_WasiCrypto_Common);
WasmEdge_ConfigureAddHostRegistration(
    Conf, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);
WasmEdge_ConfigureAddHostRegistration(Conf,
                                      WasmEdge_HostRegistration_WasiCrypto_Kx);
WasmEdge_ConfigureAddHostRegistration(
    Conf, WasmEdge_HostRegistration_WasiCrypto_Signatures);
WasmEdge_ConfigureAddHostRegistration(
    Conf, WasmEdge_HostRegistration_WasiCrypto_Symmetric);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);
WasmEdge_ConfigureDelete(Conf);

WasmEdge_String Names[32];
WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);
uint32_t ModuleLen = WasmEdge_StoreListModule(StoreCxt, Names, 32);
for (uint32_t I = 0; I < ModuleLen; I++) {
  printf(""%s\n"", Names[I].Buf);
}
/*
 * Will print:
 * wasi_ephemeral_crypto_asymmetric_common
 * wasi_ephemeral_crypto_common
 * wasi_ephemeral_crypto_kx
 * wasi_ephemeral_crypto_signatures
 * wasi_ephemeral_crypto_symmetric
 */
WasmEdge_VMDelete(VMCxt);
```

After `0.12.0`, the plug-ins will automatically loaded after the `WasmEdge_PluginLoadWithDefaultPaths()` called or the specific path given into the `WasmEdge_PluginLoadFromPath()` API.

For the plug-ins not installed, the mocked modules will be registered into VM context and will print the error message when invoking the host functions to notice the users to install the plug-in.

```c
WasmEdge_PluginLoadWithDefaultPaths();
WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();
/* The `WasmEdge_HostRegistration_Wasi` is still needed. */
WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);
WasmEdge_ConfigureDelete(Conf);

WasmEdge_String Names[32];
uint32_t ModuleLen = WasmEdge_VMListRegisteredModule(VMCxt, Names, 32);
for (uint32_t I = 0; I < ModuleLen; I++) {
  printf(""%s\n"", Names[I].Buf);
}
/*
 * Will print:
 * wasi_ephemeral_crypto_asymmetric_common
 * wasi_ephemeral_crypto_common
 * wasi_ephemeral_crypto_kx
 * wasi_ephemeral_crypto_signatures
 * wasi_ephemeral_crypto_symmetric
 * wasi_ephemeral_nn
 * wasi_snapshot_preview1
 * wasmedge_httpsreq
 * wasmedge_process
 */
WasmEdge_VMDelete(VMCxt);
```

<!-- prettier-ignore -->
:::note
The `WasmEdge_HostRegistration_Wasi` configuration is still needed if developers want to use the WASI.
:::

## Creating the module instance from a plug-in

When developers didn't use the VM context to load the plug-ins, they can use the creation functions before the `0.11.2` versions:

```c
/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */
WasmEdge_PluginLoadWithDefaultPaths();

WasmEdge_ModuleInstance *WasiCryptoCommonCxt =
    WasmEdge_ModuleInstanceCreateWasiCryptoCommon();

WasmEdge_ModuleInstanceDelete(WasiCryptoCommonCxt);
```

But it not make sense and not extensionable if developers should use different APIs for the different plug-ins.

After the `0.12.0` version, the `WasmEdge_PluginContext` is added, and developers can use the general API to create the module instances:

```c
/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */
WasmEdge_PluginLoadWithDefaultPaths();

const char CryptoPName[] = ""wasi_crypto"";
const char CryptoMName[] = ""wasi_crypto_common"";
WasmEdge_String PluginName =
    WasmEdge_StringWrap(CryptoPName, strlen(CryptoPName));
WasmEdge_String ModuleName =
    WasmEdge_StringWrap(CryptoMName, strlen(CryptoMName));
const WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(PluginName);

WasmEdge_ModuleInstance *ModCxt =
    WasmEdge_PluginCreateModule(PluginCxt, ModuleName);

WasmEdge_ModuleInstanceDelete(ModCxt);
```

## Retrieving the module instances from the VM context

Before the version `0.11.2`, developers can retrieve the `WASI` or the modules from plug-ins with the `WasmEdge_HostRegistration` values, or retrieve the registered modules from the store context.

```c
/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */
WasmEdge_PluginLoadWithDefaultPaths();
WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();
/* Add the WASI-Crypto related configurations. */
WasmEdge_ConfigureAddHostRegistration(
    Conf, WasmEdge_HostRegistration_WasiCrypto_Common);
WasmEdge_ConfigureAddHostRegistration(
    Conf, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);
WasmEdge_ConfigureAddHostRegistration(Conf,
                                      WasmEdge_HostRegistration_WasiCrypto_Kx);
WasmEdge_ConfigureAddHostRegistration(
    Conf, WasmEdge_HostRegistration_WasiCrypto_Signatures);
WasmEdge_ConfigureAddHostRegistration(
    Conf, WasmEdge_HostRegistration_WasiCrypto_Symmetric);
/* Add the WASI configurations. */
WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);
WasmEdge_ConfigureDelete(Conf);

/* Get the WASI module instance. */
WasmEdge_ModuleInstance *WASIModInst =
    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
/* Get the WASI-crypto-common module instance. */
WasmEdge_ModuleInstance *WASICryptoCommonModInst =
    WasmEdge_VMGetImportModuleContext(
        VMCxt, WasmEdge_HostRegistration_WasiCrypto_Common);

/* Get the registered module instance by name. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);
WasmEdge_String ModName =
    WasmEdge_StringCreateByCString(""wasi_ephemeral_crypto_kx"");
const WasmEdge_ModuleInstance *WASICryptoKxModInst =
    WasmEdge_StoreFindModule(StoreCxt, ModName);
WasmEdge_StringDelete(ModName);

WasmEdge_VMDelete(VMCxt);
```

After the `0.12.0` version, due to removing the plug-in related configurations and automatically registering the plug-ins into VM contexts, developers cannot use the `WasmEdge_VMGetImportModuleContext()` API to retrieve the module instances except the built-in host modules (`WASI` currently).

However, developers can use the new APIs to retrieve the registered module instances more quickly.

```c
/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */
WasmEdge_PluginLoadWithDefaultPaths();
WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();
/* Add the WASI configurations. */
WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);
WasmEdge_ConfigureDelete(Conf);

/* Get the WASI module instance. */
WasmEdge_ModuleInstance *WASIModInst =
    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
/* Get the registered WASI-crypto-common module instance by name. */
WasmEdge_String ModName =
    WasmEdge_StringCreateByCString(""wasi_ephemeral_crypto_common"");
const WasmEdge_ModuleInstance *WASICryptoKxModInst =
    WasmEdge_VMGetImportModuleContext(VMCxt, ModName);
WasmEdge_StringDelete(ModName);

WasmEdge_VMDelete(VMCxt);
```
","**Summary**

The provided code is a documentation for upgrading from WasmEdge 0.11.2 to 0.12.0. The key changes include:

1. Removal of `WasmEdge_HostRegistration` enumeration members related to specific plug-ins (e.g., `WasiNN`, `WasiCrypto_Common`, etc.).
2. Deletion of module instance creation functions for individual plug-ins.
3. Introduction of new APIs for retrieving registered named modules in VM contexts: `WasmEdge_VMGetRegisteredModule()`, `WasmEdge_VMListRegisteredModuleLength()`, and `WasmEdge_VMListRegisteredModule()`.

**New Features**

1. **Automated registration**: Plug-ins are automatically loaded after calling `WasmEdge_PluginLoadWithDefaultPaths()` or providing a specific path using `WasmEdge_PluginLoadFromPath()`.
2. **Mocked modules**: If plug-ins are not installed, mocked modules are registered into the VM context to prevent import failures.
3. **Generalized module creation**: A new API `WasmEdge_PluginCreateModule()` is introduced for creating module instances from plug-ins, eliminating the need for individual creation functions.

**Key APIs**

1. `WasmEdge_VMGetRegisteredModule()`: Retrieves a registered named module in VM context.
2. `WasmEdge_VMListRegisteredModuleLength()`: Returns the number of registered named modules in VM context.
3. `WasmEdge_VMListRegisteredModule()`: Lists all registered named modules in VM context.
4. `WasmEdge_PluginFind()`: Finds a plug-in instance by name.
5. `WasmEdge_PluginCreateModule()`: Creates a module instance from a plug-in.

**Code Example**

```c
WasmEdge_PluginLoadWithDefaultPaths();
WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);
WasmEdge_ConfigureDelete(Conf);

WasmEdge_ModuleInstance *WASIModInst =
    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
```

This code demonstrates the usage of new APIs for retrieving a registered named module in VM context."
i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.12.0.md,"---
sidebar_position: 6
---

# Upgrade to WasmEdge 0.12.0

Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the `0.11.2` to the `0.12.0` version.

## Concepts

1. Removed the members of the `WasmEdge_HostRegistration` enumeration.

   The following members of the `WasmEdge_HostRegistration` enumeration are removed:

   - `WasmEdge_HostRegistration_WasmEdge_Process`
   - `WasmEdge_HostRegistration_WasiNN`
   - `WasmEdge_HostRegistration_WasiCrypto_Common`
   - `WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon`
   - `WasmEdge_HostRegistration_WasiCrypto_Kx`
   - `WasmEdge_HostRegistration_WasiCrypto_Signatures`
   - `WasmEdge_HostRegistration_WasiCrypto_Symmetric`

   The `WasmEdge_VMContext` will create and register the host modules automatically now. If the plug-ins are not loaded, the `WasmEdge_VMContext` will create and register the mock modules to prevent from import failed.

2. Removed the module instance creation functions of the plug-ins.

   The following APIs are removed:

   - `WasmEdge_ModuleInstanceCreateWasiNN()`
   - `WasmEdge_ModuleInstanceCreateWasiCryptoCommon()`
   - `WasmEdge_ModuleInstanceCreateWasiCryptoAsymmetricCommon()`
   - `WasmEdge_ModuleInstanceCreateWasiCryptoKx()`
   - `WasmEdge_ModuleInstanceCreateWasiCryptoSignatures()`
   - `WasmEdge_ModuleInstanceCreateWasiCryptoSymmetric()`
   - `WasmEdge_ModuleInstanceCreateWasmEdgeProcess()`

   For the new examples for creating the module instances from plug-ins, please refer to [the example below](#creating-the-module-instance-from-a-plug-in).

3. New module instance retrieving API of `VM` context.

   - Added `WasmEdge_VMGetRegisteredModule()` for retrieving registered named module in VM context quickly.
   - Added `WasmEdge_VMListRegisteredModuleLength()` and `WasmEdge_VMListRegisteredModule()` for listing registered named modules in VM context quickly.

## The `WasmEdge_HostRegistration` for plug-ins is not necessary in VM contexts

Before the version `0.11.2`, developers should add the configurations when they want to load the plug-ins in VM:

```c
/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */
WasmEdge_PluginLoadWithDefaultPaths();
WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(
    Conf, WasmEdge_HostRegistration_WasiCrypto_Common);
WasmEdge_ConfigureAddHostRegistration(
    Conf, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);
WasmEdge_ConfigureAddHostRegistration(Conf,
                                      WasmEdge_HostRegistration_WasiCrypto_Kx);
WasmEdge_ConfigureAddHostRegistration(
    Conf, WasmEdge_HostRegistration_WasiCrypto_Signatures);
WasmEdge_ConfigureAddHostRegistration(
    Conf, WasmEdge_HostRegistration_WasiCrypto_Symmetric);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);
WasmEdge_ConfigureDelete(Conf);

WasmEdge_String Names[32];
WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);
uint32_t ModuleLen = WasmEdge_StoreListModule(StoreCxt, Names, 32);
for (uint32_t I = 0; I < ModuleLen; I++) {
  printf(""%s\n"", Names[I].Buf);
}
/*
 * Will print:
 * wasi_ephemeral_crypto_asymmetric_common
 * wasi_ephemeral_crypto_common
 * wasi_ephemeral_crypto_kx
 * wasi_ephemeral_crypto_signatures
 * wasi_ephemeral_crypto_symmetric
 */
WasmEdge_VMDelete(VMCxt);
```

After `0.12.0`, the plug-ins will automatically loaded after the `WasmEdge_PluginLoadWithDefaultPaths()` called or the specific path given into the `WasmEdge_PluginLoadFromPath()` API.

For the plug-ins not installed, the mocked modules will be registered into VM context and will print the error message when invoking the host functions to notice the users to install the plug-in.

```c
WasmEdge_PluginLoadWithDefaultPaths();
WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();
/* The `WasmEdge_HostRegistration_Wasi` is still needed. */
WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);
WasmEdge_ConfigureDelete(Conf);

WasmEdge_String Names[32];
uint32_t ModuleLen = WasmEdge_VMListRegisteredModule(VMCxt, Names, 32);
for (uint32_t I = 0; I < ModuleLen; I++) {
  printf(""%s\n"", Names[I].Buf);
}
/*
 * Will print:
 * wasi_ephemeral_crypto_asymmetric_common
 * wasi_ephemeral_crypto_common
 * wasi_ephemeral_crypto_kx
 * wasi_ephemeral_crypto_signatures
 * wasi_ephemeral_crypto_symmetric
 * wasi_ephemeral_nn
 * wasi_snapshot_preview1
 * wasmedge_httpsreq
 * wasmedge_process
 */
WasmEdge_VMDelete(VMCxt);
```

<!-- prettier-ignore -->
:::note
The `WasmEdge_HostRegistration_Wasi` configuration is still needed if developers want to use the WASI.
:::

## Creating the module instance from a plug-in

When developers didn't use the VM context to load the plug-ins, they can use the creation functions before the `0.11.2` versions:

```c
/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */
WasmEdge_PluginLoadWithDefaultPaths();

WasmEdge_ModuleInstance *WasiCryptoCommonCxt =
    WasmEdge_ModuleInstanceCreateWasiCryptoCommon();

WasmEdge_ModuleInstanceDelete(WasiCryptoCommonCxt);
```

But it not make sense and not extensionable if developers should use different APIs for the different plug-ins.

After the `0.12.0` version, the `WasmEdge_PluginContext` is added, and developers can use the general API to create the module instances:

```c
/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */
WasmEdge_PluginLoadWithDefaultPaths();

const char CryptoPName[] = ""wasi_crypto"";
const char CryptoMName[] = ""wasi_crypto_common"";
WasmEdge_String PluginName =
    WasmEdge_StringWrap(CryptoPName, strlen(CryptoPName));
WasmEdge_String ModuleName =
    WasmEdge_StringWrap(CryptoMName, strlen(CryptoMName));
const WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(PluginName);

WasmEdge_ModuleInstance *ModCxt =
    WasmEdge_PluginCreateModule(PluginCxt, ModuleName);

WasmEdge_ModuleInstanceDelete(ModCxt);
```

## Retrieving the module instances from the VM context

Before the version `0.11.2`, developers can retrieve the `WASI` or the modules from plug-ins with the `WasmEdge_HostRegistration` values, or retrieve the registered modules from the store context.

```c
/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */
WasmEdge_PluginLoadWithDefaultPaths();
WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();
/* Add the WASI-Crypto related configurations. */
WasmEdge_ConfigureAddHostRegistration(
    Conf, WasmEdge_HostRegistration_WasiCrypto_Common);
WasmEdge_ConfigureAddHostRegistration(
    Conf, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);
WasmEdge_ConfigureAddHostRegistration(Conf,
                                      WasmEdge_HostRegistration_WasiCrypto_Kx);
WasmEdge_ConfigureAddHostRegistration(
    Conf, WasmEdge_HostRegistration_WasiCrypto_Signatures);
WasmEdge_ConfigureAddHostRegistration(
    Conf, WasmEdge_HostRegistration_WasiCrypto_Symmetric);
/* Add the WASI configurations. */
WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);
WasmEdge_ConfigureDelete(Conf);

/* Get the WASI module instance. */
WasmEdge_ModuleInstance *WASIModInst =
    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
/* Get the WASI-crypto-common module instance. */
WasmEdge_ModuleInstance *WASICryptoCommonModInst =
    WasmEdge_VMGetImportModuleContext(
        VMCxt, WasmEdge_HostRegistration_WasiCrypto_Common);

/* Get the registered module instance by name. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);
WasmEdge_String ModName =
    WasmEdge_StringCreateByCString(""wasi_ephemeral_crypto_kx"");
const WasmEdge_ModuleInstance *WASICryptoKxModInst =
    WasmEdge_StoreFindModule(StoreCxt, ModName);
WasmEdge_StringDelete(ModName);

WasmEdge_VMDelete(VMCxt);
```

After the `0.12.0` version, due to removing the plug-in related configurations and automatically registering the plug-ins into VM contexts, developers cannot use the `WasmEdge_VMGetImportModuleContext()` API to retrieve the module instances except the built-in host modules (`WASI` currently).

However, developers can use the new APIs to retrieve the registered module instances more quickly.

```c
/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */
WasmEdge_PluginLoadWithDefaultPaths();
WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();
/* Add the WASI configurations. */
WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);
WasmEdge_ConfigureDelete(Conf);

/* Get the WASI module instance. */
WasmEdge_ModuleInstance *WASIModInst =
    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
/* Get the registered WASI-crypto-common module instance by name. */
WasmEdge_String ModName =
    WasmEdge_StringCreateByCString(""wasi_ephemeral_crypto_common"");
const WasmEdge_ModuleInstance *WASICryptoKxModInst =
    WasmEdge_VMGetImportModuleContext(VMCxt, ModName);
WasmEdge_StringDelete(ModName);

WasmEdge_VMDelete(VMCxt);
```
","**Upgrade to WasmEdge 0.12.0**

The provided code is a Markdown document that serves as a guide for upgrading from WasmEdge version 0.11.2 to 0.12.0. It covers changes in the C API, plugin loading, and module instance creation.

**Key Changes:**

1. **Removed `WasmEdge_HostRegistration` enum members**: Members like `WasmEdge_HostRegistration_WasiNN`, `WasmEdge_HostRegistration_WasiCrypto_Common`, etc., are removed.
2. **No need to register plugins in VM context**: In 0.12.0, plugins will be loaded automatically after calling `WasmEdge_PluginLoadWithDefaultPaths()` or providing a specific path using `WasmEdge_PluginLoadFromPath()`. If not installed, mocked modules will be registered.
3. **New API for retrieving module instances**: `WasmEdge_VMGetRegisteredModule()`, `WasmEdge_VMListRegisteredModuleLength()`, and `WasmEdge_VMListRegisteredModule()` are added to quickly retrieve registered named modules in VM context.

**Plugin Loading:**

* In 0.11.2, plugins were loaded by adding configurations using `WasmEdge_ConfigureAddHostRegistration()`.
* In 0.12.0, plugins will be loaded automatically after calling `WasmEdge_PluginLoadWithDefaultPaths()` or providing a specific path using `WasmEdge_PluginLoadFromPath()`.

**Module Instance Creation:**

* Before 0.11.2, module instances were created using functions like `WasmEdge_ModuleInstanceCreateWasiNN()`.
* In 0.12.0, the `WasmEdge_PluginContext` is added, and developers can use the general API `WasmEdge_PluginCreateModule()` to create module instances.

**Retrieving Module Instances:**

* Before 0.11.2, module instances were retrieved using `WasmEdge_VMGetImportModuleContext()`.
* In 0.12.0, due to removing plugin-related configurations and automatic registration of plugins in VM contexts, developers cannot use `WasmEdge_VMGetImportModuleContext()` to retrieve module instances except built-in host modules (currently `WASI`). However, they can use the new APIs to retrieve registered module instances more quickly.

Overall, this document provides a comprehensive guide for upgrading from WasmEdge 0.11.2 to 0.12.0, highlighting changes in plugin loading and module instance creation."
i18n/zh/docusaurus-plugin-content-docs/current/start/usage/serverless/aws.md,"---
sidebar_position: 1
---

# 在 AWS Lambda 中使用 WebAssembly Serverless Functions

在本文中，我们将展示在 AWS Lambda 上部署的两个使用 Rust 和 WasmEdge 编写的无服务器函数。一个是图像处理函数，另一个是 TensorFlow 推理函数。

> 想了解为什么要在 AWS Lambda 上使用 WasmEdge，请参阅文章 [WebAssembly Serverless Functions in AWS Lambda](https://www.secondstate.io/articles/webassembly-serverless-functions-in-aws-lambda/)。

## 环境

由于我们的演示 WebAssembly 函数是用 Rust 编写的，你需要安装 [Rust 编译器](https://www.rust-lang.org/tools/install)。确保你按照以下方式安装 `wasm32-wasi` 编译目标，以生成 WebAssembly 字节码。

```bash
rustup target add wasm32-wasi
```

演示应用的前端是用 [Next.js](https://nextjs.org/) 编写的，并部署在 AWS Lambda 上。我们假设你已经对如何使用 Next.js 和 Lambda 有基本的了解。

## 示例1：图像处理

我们的第一个演示应用允许用户上传图像，然后调用一个无服务器函数将其转换为黑白图像。通过 GitHub Pages 部署了一个[实时演示](https://second-state.github.io/aws-lambda-wasm-runtime/)。

首先 Fork [demo 应用的 GitHub 存储库](https://github.com/second-state/aws-lambda-wasm-runtime)。要在 AWS Lambda 上部署应用程序，请按照存储库 [README](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md)中的指南进行操作。

### 创建函数

此存储库是一个标准的 Next.js 应用程序。后端无服务器函数位于 `api/functions/image_grayscale` 文件夹中。`src/main.rs` 文件包含了 Rust 程序的源代码。Rust 程序从 `STDIN` 读取图像数据，然后将黑白图像输出到 `STDOUT`。

```rust
use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&buf).unwrap();
  let img = image::load_from_memory(&buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif => {
      filtered.write_to(&mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ => {
      filtered.write_to(&mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&buf).unwrap();
  io::stdout().flush().unwrap();
}
```

你可以使用 Rust 的 `cargo` 工具将 Rust 程序构建成 WebAssembly 字节码或本机代码。

```bash
cd api/functions/image-grayscale/
cargo build --release --target wasm32-wasi
```

将构建出结果复制到 `api` 文件夹。

```bash
cp target/wasm32-wasi/release/grayscale.wasm ../../
```

> 在构建 Docker 镜像时，将执行 `api/pre.sh`。`pre.sh` 安装 WasmEdge 运行时，然后将每个 WebAssembly 字节码程序编译成本地 `so` 库，以实现更快的执行。

### 创建服务脚本以加载函数

[`api/hello.js`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/hello.js) 脚本加载 WasmEdge 运行时，在 WasmEdge 中启动编译后的 WebAssembly 程序，并通过 `STDIN` 传递上传的图像数据。请注意，为了实现更好的性能，[`api/hello.js`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/hello.js) 运行的由 [`api/pre.sh`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/pre.sh) 生成的编译后的 `grayscale.so` 文件。

```javascript
const { spawn } = require('child_process');
const path = require('path');

function _runWasm(reqBody) {
  return new Promise((resolve) => {
    const wasmedge = spawn(path.join(__dirname, 'wasmedge'), [
      path.join(__dirname, 'grayscale.so'),
    ]);

    let d = [];
    wasmedge.stdout.on('data', (data) => {
      d.push(data);
    });

    wasmedge.on('close', (code) => {
      let buf = Buffer.concat(d);
      resolve(buf);
    });

    wasmedge.stdin.write(reqBody);
    wasmedge.stdin.end('');
  });
}
```

`hello.js` 中的 `exports.handler` 部分导出了一个异步函数处理程序，用于处理每次调用无服务器函数时的不同事件。在本例中，我们简单地通过调用上述函数处理图像并返回结果，但可以根据你的需求定义更复杂的事件处理行为。此外，我们还需要返回一些 `Access-Control-Allow` 标头以避免在从浏览器调用无服务器函数时出现 [跨源资源共享（CORS）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS) 错误。如果你在复制我们的示例时遇到 CORS 错误，可以在[这里](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS/Errors)了解更多关于 CORS 错误的信息。

```javascript
exports.handler = async function (event, context) {
  var typedArray = new Uint8Array(
    event.body.match(/[\da-f]{2}/gi).map(function (h) {
      return parseInt(h, 16);
    }),
  );
  let buf = await _runWasm(typedArray);
  return {
    statusCode: 200,
    headers: {
      'Access-Control-Allow-Headers':
        'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods':
        'DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT',
    },
    body: buf.toString('hex'),
  };
};
```

### 构建用于 Lambda 部署的 Docker 镜像

现在我们拥有了 WebAssembly 字节码函数以及加载和连接到网络请求的脚本。为了将它们部署为 AWS Lambda 上的函数服务，你仍然需要将整个内容打包成一个 Docker 镜像。

我们不会详细介绍如何构建 Docker 镜像并在 AWS Lambda 上部署，因为在[存储库 README 的部署部分](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md#deploy)中有详细的步骤。然而，我们将为你突出显示 [`Dockerfile`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/Dockerfile) 中的一些行，以避免一些问题。

```dockerfile
FROM public.ecr.aws/lambda/nodejs:14

# Change directory to /var/task
WORKDIR /var/task

RUN yum update -y && yum install -y curl tar gzip

# Bundle and pre-compile the wasm files
COPY *.wasm ./
COPY pre.sh ./
RUN chmod +x pre.sh
RUN ./pre.sh

# Bundle the JS files
COPY *.js ./

CMD [ ""hello.handler"" ]
```

首先，我们是从 [AWS Lambda 的 Node.js 基础镜像](https://hub.docker.com/r/amazon/aws-lambda-nodejs)构建镜像。使用 AWS Lambda 基础镜像的优势在于它包含了[Lambda Runtime Interface Client (RIC)](https://github.com/aws/aws-lambda-nodejs-runtime-interface-client)，这是 Lambda 运行环境中所需的依赖。Amazon Linux 使用 `yum` 作为包管理器。

> 这些基础镜像包含了 Amazon Linux Base 操作系统、特定语言的运行时、依赖项和 Lambda Runtime Interface Client (RIC)，该客户端实现了 Lambda [运行时 API](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html)。Lambda Runtime Interface Client 允许你的运行时接收来自 Lambda 服务的请求并发送请求。

其次，我们需要将我们的函数及其所有依赖项放在 `/var/task` 目录中。其他文件夹中的文件将不会被AWS Lambda执行。

第三，我们需要定义启动容器时的默认命令。`CMD [ ""hello.handler"" ]` 表示在调用无服务器函数时，我们将调用 `hello.js` 中的 `handler` 函数。请回想我们在之前的步骤中通过 `exports.handler = ...` 在 `hello.js` 中定义并导出了处理程序函数。

### 可选：本地测试 Docker 镜像

从 AWS Lambda 的基础镜像构建的 Docker 镜像可以按照[此指南](https://docs.aws.amazon.com/lambda/latest/dg/images-test.html)在本地进行测试。本地测试需要 [AWS Lambda Runtime Interface Emulator (RIE)](https://github.com/aws/aws-lambda-runtime-interface-emulator)，它已经安装在所有 AWS Lambda 的基础镜像中。要测试你的镜像，首先运行以下命令启动 Docker 容器：

```bash
docker run -p 9000:8080  myfunction:latest
```

此命令在本地机器上设置一个函数接口，地址为 `http://localhost:9000/2015-03-31/functions/function/invocations`。

然后，从另一个终端窗口运行：

```bash
curl -XPOST ""http://localhost:9000/2015-03-31/functions/function/invocations"" -d '{}'
```

你应该在终端中获得你期望的输出。

如果你不想使用 AWS Lambda 的基础镜像，你也可以使用自己的基础镜像，并在构建 Docker 镜像时安装 RIC 和/或 RIE。只需按照[此指南](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html)中的 **Create an image from an alternative base image** 部分进行操作。

准备就绪！在构建完 Docker 镜像后，可以参考存储库 [README](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md#deploy)中简述的步骤将其部署到 AWS Lambda。然后你的无服务器函数就可以开始工作了！

## 示例 2：AI 推理

[第二个演示](https://github.com/second-state/aws-lambda-wasm-runtime/tree/tensorflow) 应用允许用户上传图像，然后调用一个无服务器函数对图像的主要对象进行分类。

它位于与之前示例相同的 [GitHub 存储库](https://github.com/second-state/aws-lambda-wasm-runtime/tree/tensorflow)，但在 `tensorflow` 分支中。用于图像分类的后端无服务器函数位于 `tensorflow` 分支中的 `api/functions/image-classification` 文件夹中。`src/main.rs` 文件包含了 Rust 程序的源代码。Rust 程序从 `STDIN` 读取图像数据，然后将文本输出到 `STDOUT`。它利用了 WasmEdge Tensorflow API 来运行AI推理。

```rust
pub fn main() {
  // Step 1: Load the TFLite model
  let model_data: &[u8] = include_bytes!(""models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite"");
  let labels = include_str!(""models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt"");

  // Step 2: Read image from STDIN
  let mut buf = Vec::new();
  io::stdin().read_to_end(&mut buf).unwrap();

  // Step 3: Resize the input image for the tensorflow model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&buf, 224, 224);

  // Step 4: AI inference
  let mut session = wasmedge_tensorflow_interface::Session::new(&model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(""input"", &flat_img, &[1, 224, 224, 3])
         .run();
  let res_vec: Vec<u8> = session.get_output(""MobilenetV1/Predictions/Reshape_1"");

  // Step 5: Find the food label that responds to the highest probability in res_vec
  // ... ...
  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }

  // Step 6: Generate the output text
  let class_name = label_lines.next().unwrap().to_string();
  if max_value > 50 {
    println!(""It {} a <a href='https://www.google.com/search?q={}'>{}</a> in the picture"", confidence.to_string(), class_name, class_name);
  } else {
    println!(""It does not appears to be any food item in the picture."");
  }
}
```

你可以使用 `cargo` 工具将 Rust 程序构建成 WebAssembly 字节码或本机代码。

```bash
cd api/functions/image-classification/
cargo build --release --target wasm32-wasi
```

将构建产物复制到 `api` 文件夹。

```bash
cp target/wasm32-wasi/release/classify.wasm ../../
```

同样，`api/pre.sh` 脚本在此应用程序中安装了 WasmEdge 运行时及其 TensorFlow 依赖项。它还在部署时将 `classify.wasm` 字节码程序编译为 `classify.so` 本机共享库。

[`api/hello.js`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/hello.js) 脚本加载 WasmEdge 运行时，在 WasmEdge 中启动编译后的 WebAssembly 程序，并通过 `STDIN` 传递上传的图像数据。请注意，[`api/hello.js`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/hello.js) 运行由 [`api/pre.sh`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/pre.sh) 生成的编译后的 `classify.so` 文件，以获得更好的性能。处理函数类似于我们之前的示例，在此省略。

```javascript
const { spawn } = require('child_process');
const path = require('path');

function _runWasm(reqBody) {
  return new Promise(resolve => {
    const wasmedge = spawn(
      path.join(__dirname, 'wasmedge-tensorflow-lite'),
      [path.join(__dirname, 'classify.so')],
      {env: {'LD_LIBRARY_PATH': __dirname}}
    );

    let d = [];
    wasmedge.stdout.on('data', (data) => {
      d.push(data);
    });

    wasmedge.on('close', (code) => {
      resolve(d.join(''));
    });

    wasmedge.stdin.write(reqBody);
    wasmedge.stdin.end('');
  });
}

exports.handler = ... // _runWasm(reqBody) is called in the handler
```

你可以按照之前的示例中概述的方式构建你的 Docker 镜像并部署函数。现在你已经创建了一个用于主题分类的 Web 应用！

接下来，轮到你使用 [aws-lambda-wasm-runtime 存储库](https://github.com/second-state/aws-lambda-wasm-runtime/tree/main) 作为模板，在 AWS Lambda 上开发 Rust 无服务器函数了。期待着你的出色工作。
","该代码是关于使用 WasmEdge 在 AWS Lambda 上部署 Rust 编写的无服务器函数。具体来说，这个项目展示了两个示例：

1. 第一个示例是一个图像处理应用程序，可以从本地上传图片，然后将其转换为黑白图片。
2. 第二个示例是用于 AI 推理的应用程序，允许用户上传图像并在此图像中识别出主要对象。

以下是这两个示例所共有的主要组件：

*   `Dockerfile`：这是构建 Docker 镜像所需的指令。
*   Rust 程序：这是两个示例中的核心代码，使用 WasmEdge 运行时来执行 WebAssembly 字节码或本机代码。它们从 STDIN 读取输入数据，并输出结果到 STDOUT。
*   `wasmedge-tensorflow-lite`：这是 WasmEdge 的 TensorFlow Lite runtime，它用于在 Rust 程序中执行 TensorFlow Lite 模型的 AI 推理。
*   `pre.sh` 脚本：这是用于安装 WasmEdge 运行时及其依赖项的脚本，在 Docker 镜像部署期间运行。

使用 AWS Lambda 和 WasmEdge 的好处包括：

*   高性能：WasmEdge 是一个高性能 WebAssembly runtime，能够在 AWS Lambda 上实现更快速、更有效地执行 Rust 无服务器函数。
*   易用性：AWS Lambda 提供了一个易用的无服务器函数服务，让开发人员可以轻松部署和管理代码。
*   安全性：AWS Lambda 和 WasmEdge 都提供了多层安全性，确保您的代码在 AWS 上安全运行。

总的来说，这个项目展示了使用 WasmEdge 在 AWS Lambda 上部署 Rust 无服务器函数的可能性以及其好处。"
docs/embed/c/reference/upgrade_to_0.11.0.md,"---
sidebar_position: 8
---

# Upgrade to WasmEdge 0.11.0

Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the `0.10.1` to the `0.11.0` version.

## Concepts

1. Supported the user-defined error code in host functions.

   Developers can use the new API `WasmEdge_ResultGen()` to generate a `WasmEdge_Result` struct with `WasmEdge_ErrCategory_UserLevelError` and the error code. With this support, developers can specify the host function error code when failed by themselves. For the examples to specify the user-defined error code, please refer to [the example below](#user-defined-error-code-in-host-functions).

2. Calling frame for the host function extension

   In the previous versions, host functions only pass the memory instance into the function body. For supporting the WASM multiple memories proposal and providing the recursive invocation in host functions, the new context `WasmEdge_CallingFrameContext` replaced the memory instance in the second argument of the host function definition. For the examples of the new host function definition, please refer to [the example below](#calling-frame-in-host-functions).

3. Apply the SONAME and SOVERSION.

   When linking the WasmEdge shared library, please notice that `libwasmedge_c.so` is renamed to `libwasmedge.so` after the 0.11.0 release. Please use `-lwasmedge` instead of `-lwasmedge_c` for the linker option.

## User Defined Error Code In Host Functions

Assume that we want to specify that the host function failed in the versions before `0.10.1`:

```c
/* Host function body definition. */
WasmEdge_Result FaildFunc(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* This will create a trap in WASM. */
  return WasmEdge_Result_Fail;
}
```

When the execution is finished, developers will get the `WasmEdge_Result`. If developers call the `WasmEdge_ResultOK()` with the returned result, they will get `false`. If developers call the `WasmEdge_ResultGetCode()` with the returned result, they will always get `2`.

For the versions after `0.11.0`, developers can specify the error code within 24-bit (smaller than `16777216`) size.

```c
/* Host function body definition. */
WasmEdge_Result FaildFunc(void *Data,
                          const WasmEdge_CallingFrameContext *CallFrameCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* This will create a trap in WASM with the error code. */
  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);
}
```

Therefore when developers call the `WasmEdge_ResultGetCode()` with the returned result, they will get the error code `12345678`. Noticed that if developers call the `WasmEdge_ResultGetMessage()`, they will always get the C string `""user defined error code""`.

## Calling Frame In Host Functions

When implementing the host functions, developers usually use the input memory instance to load or store data. In the WasmEdge versions before `0.10.1`, the argument before the input and return value list of the host function definition is the memory instance context, so that developers can access the data in the memory instance.

```c
/* Host function body definition. */
WasmEdge_Result LoadOffset(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                           const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {i32} -> {} */
  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);
  uint32_t Num = 0;
  WasmEdge_Result Res =
      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);
  if (WasmEdge_ResultOK(Res)) {
    printf(""u32 at memory[%u]: %u\n"", Offset, Num);
  } else {
    return Res;
  }
  return WasmEdge_Result_Success;
}
```

The input memory instance is the one that belongs to the module instance on the top calling frame of the stack. However, after applying the WASM multiple memories proposal, there may be more than 1 memory instance in a WASM module. Furthermore, there may be requests for accessing the module instance on the top frame of the stack to get the exported WASM functions, such as recursive invocation in host functions. To support these, the `WasmEdge_CallingFrameContext` is designed to replace the memory instance input of the host function.

In the WasmEdge versions after `0.11.0`, the host function definitions are changed:

```c
typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(
    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,
    const WasmEdge_Value *Params, WasmEdge_Value *Returns);

typedef WasmEdge_Result (*WasmEdge_WrapFunc_t)(
    void *This, void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,
    const WasmEdge_Value *Params, const uint32_t ParamLen,
    WasmEdge_Value *Returns, const uint32_t ReturnLen);
```

Developers need to change to use the `WasmEdge_CallingFrameContext` related APIs to access the memory instance:

```c
/* Host function body definition. */
WasmEdge_Result LoadOffset(void *Data,
                           const WasmEdge_CallingFrameContext *CallFrameCxt,
                           const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {i32} -> {} */
  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);
  uint32_t Num = 0;

  /* Get the 0th memory instance of the module of the top frame on the stack. */
  WasmEdge_MemoryInstanceContext *MemCxt =
      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);
  WasmEdge_Result Res =
      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);
  if (WasmEdge_ResultOK(Res)) {
    printf(""u32 at memory[%u]: %u\n"", Offset, Num);
  } else {
    return Res;
  }
  return WasmEdge_Result_Success;
}
```

The `WasmEdge_CallingFrameGetModuleInstance()` API can help developers to get the module instance of the top frame on the stack. With the module instance context, developers can use the module instance-related APIs to get its contents.

The `WasmEdge_CallingFrameGetExecutor()` API can help developers to get the currently used executor context. Therefore developers can use the executor to recursively invoke other WASM functions without creating a new executor context.
","**Upgrade to WasmEdge 0.11.0**

The provided code snippet is a guide for upgrading from WasmEdge 0.10.1 to 0.11.0. This upgrade introduces breaking changes in the C API.

**Key Changes:**

1. **User-Defined Error Codes**: The `WasmEdge_ResultGen()` function allows developers to generate a result with a user-defined error code.
2. **Calling Frame Context**: In versions before 0.10.1, host functions passed a memory instance context as an argument. In 0.11.0 and later, the calling frame context is used instead, which provides access to multiple memories in a WASM module.

**User-Defined Error Code Example**

Before 0.10.1:
```c
WasmEdge_Result FaildFunc(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  return WasmEdge_Result_Fail;
}
```
After 0.11.0:
```c
WasmEdge_Result FaildFunc(void *Data,
                          const WasmEdge_CallingFrameContext *CallFrameCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);
}
```
**Calling Frame Context Example**

Before 0.10.1:
```c
WasmEdge_Result LoadOffset(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                           const WasmEdge_Value *In, WasmEdge_Value *Out) {
  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);
  uint32_t Num = 0;
  WasmEdge_Result Res =
      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);
  if (WasmEdge_ResultOK(Res)) {
    printf(""u32 at memory[%u]: %u\n"", Offset, Num);
  } else {
    return Res;
  }
  return WasmEdge_Result_Success;
}
```
After 0.11.0:
```c
WasmEdge_Result LoadOffset(void *Data,
                           const WasmEdge_CallingFrameContext *CallFrameCxt,
                           const WasmEdge_Value *In, WasmEdge_Value *Out) {
  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);
  uint32_t Num = 0;
  WasmEdge_MemoryInstanceContext *MemCxt =
      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);
  WasmEdge_Result Res =
      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);
  if (WasmEdge_ResultOK(Res)) {
    printf(""u32 at memory[%u]: %u\n"", Offset, Num);
  } else {
    return Res;
  }
  return WasmEdge_Result_Success;
}
```
**Recommendations**

* Review the documentation for breaking changes in the C API.
* Update host function definitions to use the new calling frame context.
* Use the `WasmEdge_CallingFrameGetMemoryInstance()` and `WasmEdge_MemoryInstanceGetData()` APIs to access memory instances.
* Consider using the `WasmEdge_ResultGen()` function to generate user-defined error codes."
docs/embed/go/reference/upgrade_to_0.11.0.md,"---
sidebar_position: 6
---

# Upgrade to WasmEdge-Go v0.11.0

Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the `v0.10.1` to the `v0.11.0` version.

## Concepts

1. Supported the user-defined error code in host functions.

   Developers can use the new API `WasmEdge_ResultGen()` to generate a `WasmEdge_Result` struct with `WasmEdge_ErrCategory_UserLevelError` and the error code. With this support, developers can specify the host function error code when failed by themselves. For the examples to specify the user-defined error code, please refer to [the example below](#user-defined-error-code-in-host-functions).

2. Calling frame for the host function extension

   In the previous versions, host functions only pass the memory instance into the function body. For supporting the WASM multiple memories proposal and providing the recursive invocation in host functions, the new context `WasmEdge_CallingFrameContext` replaced the memory instance in the second argument of the host function definition. For the examples of the new host function definition, please refer to [the example below](#calling-frame-in-host-functions).

3. Apply the SONAME and SOVERSION.

   When linking the WasmEdge shared library, please notice that `libwasmedge_c.so` is renamed to `libwasmedge.so` after the 0.11.0 release. Please use `-lwasmedge` instead of `-lwasmedge_c` for the linker option.

## User Defined Error Code In Host Functions

Assume that we want to specify that the host function failed in the versions before `0.10.1`:

```c
/* Host function body definition. */
WasmEdge_Result FaildFunc(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* This will create a trap in WASM. */
  return WasmEdge_Result_Fail;
}
```

When the execution is finished, developers will get the `WasmEdge_Result`. If developers call the `WasmEdge_ResultOK()` with the returned result, they will get `false`. If developers call the `WasmEdge_ResultGetCode()` with the returned result, they will always get `2`.

For the versions after `0.11.0`, developers can specify the error code within 24-bit (smaller than `16777216`) size.

```c
/* Host function body definition. */
WasmEdge_Result FaildFunc(void *Data,
                          const WasmEdge_CallingFrameContext *CallFrameCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* This will create a trap in WASM with the error code. */
  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);
}
```

Therefore when developers call the `WasmEdge_ResultGetCode()` with the returned result, they will get the error code `12345678`. Noticed that if developers call the `WasmEdge_ResultGetMessage()`, they will always get the C string `""user defined error code""`.

## Calling Frame In Host Functions

When implementing the host functions, developers usually use the input memory instance to load or store data. In the WasmEdge versions before `0.10.1`, the argument before the input and return value list of the host function definition is the memory instance context, so that developers can access the data in the memory instance.

```c
/* Host function body definition. */
WasmEdge_Result LoadOffset(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                           const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {i32} -> {} */
  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);
  uint32_t Num = 0;
  WasmEdge_Result Res =
      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);
  if (WasmEdge_ResultOK(Res)) {
    printf(""u32 at memory[%u]: %u\n"", Offset, Num);
  } else {
    return Res;
  }
  return WasmEdge_Result_Success;
}
```

The input memory instance is the one that belongs to the module instance on the top calling frame of the stack. However, after applying the WASM multiple memories proposal, there may be more than 1 memory instance in a WASM module. Furthermore, there may be requests for accessing the module instance on the top frame of the stack to get the exported WASM functions, such as recursive invocation in host functions. To support these, the `WasmEdge_CallingFrameContext` is designed to replace the memory instance input of the host function.

In the WasmEdge versions after `0.11.0`, the host function definitions are changed:

```c
typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(
    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,
    const WasmEdge_Value *Params, WasmEdge_Value *Returns);

typedef WasmEdge_Result (*WasmEdge_WrapFunc_t)(
    void *This, void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,
    const WasmEdge_Value *Params, const uint32_t ParamLen,
    WasmEdge_Value *Returns, const uint32_t ReturnLen);
```

Developers need to change to use the `WasmEdge_CallingFrameContext` related APIs to access the memory instance:

```c
/* Host function body definition. */
WasmEdge_Result LoadOffset(void *Data,
                           const WasmEdge_CallingFrameContext *CallFrameCxt,
                           const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {i32} -> {} */
  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);
  uint32_t Num = 0;

  /* Get the 0th memory instance of the module of the top frame on the stack. */
  WasmEdge_MemoryInstanceContext *MemCxt =
      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);
  WasmEdge_Result Res =
      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);
  if (WasmEdge_ResultOK(Res)) {
    printf(""u32 at memory[%u]: %u\n"", Offset, Num);
  } else {
    return Res;
  }
  return WasmEdge_Result_Success;
}
```

The `WasmEdge_CallingFrameGetModuleInstance()` API can help developers to get the module instance of the top frame on the stack. With the module instance context, developers can use the module instance-related APIs to get its contents.

The `WasmEdge_CallingFrameGetExecutor()` API can help developers to get the currently used executor context. Therefore developers can use the executor to recursively invoke other WASM functions without creating a new executor context.
","**Upgrade to WasmEdge-Go v0.11.0**

This document provides guidelines for upgrading from WasmEdge C API version `v0.10.1` to `v0.11.0`. The main changes include:

1. **User-defined error code support**: Developers can now specify a user-defined error code when a host function fails.
2. **Calling frame context**: The `WasmEdge_CallingFrameContext` API has replaced the memory instance input in host function definitions to support WASM multiple memories proposal and recursive invocation.

**Key Changes**

*   In version `v0.11.0`, the `WasmEdge_ResultGen()` API is used to generate a `WasmEdge_Result` struct with a user-defined error code.
*   The `WasmEdge_CallingFrameContext` API provides access to the memory instance and module instance of the top frame on the stack.
*   Host function definitions now use the `WasmEdge_HostFunc_t` type, which includes the `WasmEdge_CallingFrameContext` parameter.

**Example Code**

*   The `FaildFunc()` example demonstrates how to specify a user-defined error code in version `v0.11.0`.
*   The `LoadOffset()` example shows how to use the `WasmEdge_CallingFrameContext` API to access memory instances and module instances.

**Recommendations**

1.  Update host function definitions to use the new `WasmEdge_HostFunc_t` type.
2.  Use the `WasmEdge_ResultGen()` API to generate user-defined error codes in version `v0.11.0`.
3.  Familiarize yourself with the `WasmEdge_CallingFrameContext` API and its related functions.

**Notes**

*   The `libwasmedge_c.so` library is now renamed to `libwasmedge.so` after the 0.11.0 release.
*   Use the `-lwasmedge` linker option instead of `-lwasmedge_c`."
i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.11.0.md,"---
sidebar_position: 8
---

# Upgrade to WasmEdge 0.11.0

Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the `0.10.1` to the `0.11.0` version.

## Concepts

1. Supported the user-defined error code in host functions.

   Developers can use the new API `WasmEdge_ResultGen()` to generate a `WasmEdge_Result` struct with `WasmEdge_ErrCategory_UserLevelError` and the error code. With this support, developers can specify the host function error code when failed by themselves. For the examples to specify the user-defined error code, please refer to [the example below](#user-defined-error-code-in-host-functions).

2. Calling frame for the host function extension

   In the previous versions, host functions only pass the memory instance into the function body. For supporting the WASM multiple memories proposal and providing the recursive invocation in host functions, the new context `WasmEdge_CallingFrameContext` replaced the memory instance in the second argument of the host function definition. For the examples of the new host function definition, please refer to [the example below](#calling-frame-in-host-functions).

3. Apply the SONAME and SOVERSION.

   When linking the WasmEdge shared library, please notice that `libwasmedge_c.so` is renamed to `libwasmedge.so` after the 0.11.0 release. Please use `-lwasmedge` instead of `-lwasmedge_c` for the linker option.

## User Defined Error Code In Host Functions

Assume that we want to specify that the host function failed in the versions before `0.10.1`:

```c
/* Host function body definition. */
WasmEdge_Result FaildFunc(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* This will create a trap in WASM. */
  return WasmEdge_Result_Fail;
}
```

When the execution is finished, developers will get the `WasmEdge_Result`. If developers call the `WasmEdge_ResultOK()` with the returned result, they will get `false`. If developers call the `WasmEdge_ResultGetCode()` with the returned result, they will always get `2`.

For the versions after `0.11.0`, developers can specify the error code within 24-bit (smaller than `16777216`) size.

```c
/* Host function body definition. */
WasmEdge_Result FaildFunc(void *Data,
                          const WasmEdge_CallingFrameContext *CallFrameCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* This will create a trap in WASM with the error code. */
  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);
}
```

Therefore when developers call the `WasmEdge_ResultGetCode()` with the returned result, they will get the error code `12345678`. Noticed that if developers call the `WasmEdge_ResultGetMessage()`, they will always get the C string `""user defined error code""`.

## Calling Frame In Host Functions

When implementing the host functions, developers usually use the input memory instance to load or store data. In the WasmEdge versions before `0.10.1`, the argument before the input and return value list of the host function definition is the memory instance context, so that developers can access the data in the memory instance.

```c
/* Host function body definition. */
WasmEdge_Result LoadOffset(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                           const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {i32} -> {} */
  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);
  uint32_t Num = 0;
  WasmEdge_Result Res =
      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);
  if (WasmEdge_ResultOK(Res)) {
    printf(""u32 at memory[%u]: %u\n"", Offset, Num);
  } else {
    return Res;
  }
  return WasmEdge_Result_Success;
}
```

The input memory instance is the one that belongs to the module instance on the top calling frame of the stack. However, after applying the WASM multiple memories proposal, there may be more than 1 memory instance in a WASM module. Furthermore, there may be requests for accessing the module instance on the top frame of the stack to get the exported WASM functions, such as recursive invocation in host functions. To support these, the `WasmEdge_CallingFrameContext` is designed to replace the memory instance input of the host function.

In the WasmEdge versions after `0.11.0`, the host function definitions are changed:

```c
typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(
    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,
    const WasmEdge_Value *Params, WasmEdge_Value *Returns);

typedef WasmEdge_Result (*WasmEdge_WrapFunc_t)(
    void *This, void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,
    const WasmEdge_Value *Params, const uint32_t ParamLen,
    WasmEdge_Value *Returns, const uint32_t ReturnLen);
```

Developers need to change to use the `WasmEdge_CallingFrameContext` related APIs to access the memory instance:

```c
/* Host function body definition. */
WasmEdge_Result LoadOffset(void *Data,
                           const WasmEdge_CallingFrameContext *CallFrameCxt,
                           const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {i32} -> {} */
  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);
  uint32_t Num = 0;

  /* Get the 0th memory instance of the module of the top frame on the stack. */
  WasmEdge_MemoryInstanceContext *MemCxt =
      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);
  WasmEdge_Result Res =
      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);
  if (WasmEdge_ResultOK(Res)) {
    printf(""u32 at memory[%u]: %u\n"", Offset, Num);
  } else {
    return Res;
  }
  return WasmEdge_Result_Success;
}
```

The `WasmEdge_CallingFrameGetModuleInstance()` API can help developers to get the module instance of the top frame on the stack. With the module instance context, developers can use the module instance-related APIs to get its contents.

The `WasmEdge_CallingFrameGetExecutor()` API can help developers to get the currently used executor context. Therefore developers can use the executor to recursively invoke other WASM functions without creating a new executor context.
","**Summary**

The provided code is a documentation for upgrading from WasmEdge 0.10.1 to 0.11.0. It highlights the breaking changes in the C API and provides guidelines on how to use the new APIs.

**Key Components**

1. **User-defined error codes**: Developers can now specify custom error codes using `WasmEdge_ResultGen()` function.
2. **Calling frame for host functions**: The `WasmEdge_CallingFrameContext` replaces the memory instance in the second argument of the host function definition to support multiple memories and recursive invocations.
3. **SONAME and SOVERSION changes**: The linker option is changed from `-lwasmedge_c` to `-lwasmedge`.

**Changes**

1. Host function body definition:
	* `WasmEdge_MemoryInstanceContext *MemCxt` replaced by `const WasmEdge_CallingFrameContext *CallFrameCxt`
	* `WasmEdge_ValueGetI32` and `WasmEdge_ValueGetU32` replaced by `WasmEdge_ValueGetI32` and `WasmEdge_ValueGetU32`
2. New APIs:
	* `WasmEdge_ResultGen()`: generates a result with user-defined error code
	* `WasmEdge_CallingFrameContext`: provides access to the calling frame context, including the memory instance and executor

**Best Practices**

1. When using new APIs, always check for breaking changes in subsequent versions.
2. Be aware of changes in SONAME and SOVERSION when linking WasmEdge shared library.
3. Use `WasmEdge_CallingFrameContext` to access the calling frame context and its related APIs.

**Potential Issues**

1. Unhandled error codes: ensure that custom error codes are handled properly.
2. Memory instance management: be cautious when working with multiple memory instances.
3. Executor usage: use `WasmEdge_CallingFrameGetExecutor()` API to get the currently used executor context."
i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.11.0.md,"---
sidebar_position: 6
---

# Upgrade to WasmEdge-Go v0.11.0

Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the `v0.10.1` to the `v0.11.0` version.

## Concepts

1. Supported the user-defined error code in host functions.

   Developers can use the new API `WasmEdge_ResultGen()` to generate a `WasmEdge_Result` struct with `WasmEdge_ErrCategory_UserLevelError` and the error code. With this support, developers can specify the host function error code when failed by themselves. For the examples to specify the user-defined error code, please refer to [the example below](#user-defined-error-code-in-host-functions).

2. Calling frame for the host function extension

   In the previous versions, host functions only pass the memory instance into the function body. For supporting the WASM multiple memories proposal and providing the recursive invocation in host functions, the new context `WasmEdge_CallingFrameContext` replaced the memory instance in the second argument of the host function definition. For the examples of the new host function definition, please refer to [the example below](#calling-frame-in-host-functions).

3. Apply the SONAME and SOVERSION.

   When linking the WasmEdge shared library, please notice that `libwasmedge_c.so` is renamed to `libwasmedge.so` after the 0.11.0 release. Please use `-lwasmedge` instead of `-lwasmedge_c` for the linker option.

## User Defined Error Code In Host Functions

Assume that we want to specify that the host function failed in the versions before `0.10.1`:

```c
/* Host function body definition. */
WasmEdge_Result FaildFunc(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* This will create a trap in WASM. */
  return WasmEdge_Result_Fail;
}
```

When the execution is finished, developers will get the `WasmEdge_Result`. If developers call the `WasmEdge_ResultOK()` with the returned result, they will get `false`. If developers call the `WasmEdge_ResultGetCode()` with the returned result, they will always get `2`.

For the versions after `0.11.0`, developers can specify the error code within 24-bit (smaller than `16777216`) size.

```c
/* Host function body definition. */
WasmEdge_Result FaildFunc(void *Data,
                          const WasmEdge_CallingFrameContext *CallFrameCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* This will create a trap in WASM with the error code. */
  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);
}
```

Therefore when developers call the `WasmEdge_ResultGetCode()` with the returned result, they will get the error code `12345678`. Noticed that if developers call the `WasmEdge_ResultGetMessage()`, they will always get the C string `""user defined error code""`.

## Calling Frame In Host Functions

When implementing the host functions, developers usually use the input memory instance to load or store data. In the WasmEdge versions before `0.10.1`, the argument before the input and return value list of the host function definition is the memory instance context, so that developers can access the data in the memory instance.

```c
/* Host function body definition. */
WasmEdge_Result LoadOffset(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                           const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {i32} -> {} */
  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);
  uint32_t Num = 0;
  WasmEdge_Result Res =
      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);
  if (WasmEdge_ResultOK(Res)) {
    printf(""u32 at memory[%u]: %u\n"", Offset, Num);
  } else {
    return Res;
  }
  return WasmEdge_Result_Success;
}
```

The input memory instance is the one that belongs to the module instance on the top calling frame of the stack. However, after applying the WASM multiple memories proposal, there may be more than 1 memory instance in a WASM module. Furthermore, there may be requests for accessing the module instance on the top frame of the stack to get the exported WASM functions, such as recursive invocation in host functions. To support these, the `WasmEdge_CallingFrameContext` is designed to replace the memory instance input of the host function.

In the WasmEdge versions after `0.11.0`, the host function definitions are changed:

```c
typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(
    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,
    const WasmEdge_Value *Params, WasmEdge_Value *Returns);

typedef WasmEdge_Result (*WasmEdge_WrapFunc_t)(
    void *This, void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,
    const WasmEdge_Value *Params, const uint32_t ParamLen,
    WasmEdge_Value *Returns, const uint32_t ReturnLen);
```

Developers need to change to use the `WasmEdge_CallingFrameContext` related APIs to access the memory instance:

```c
/* Host function body definition. */
WasmEdge_Result LoadOffset(void *Data,
                           const WasmEdge_CallingFrameContext *CallFrameCxt,
                           const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {i32} -> {} */
  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);
  uint32_t Num = 0;

  /* Get the 0th memory instance of the module of the top frame on the stack. */
  WasmEdge_MemoryInstanceContext *MemCxt =
      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);
  WasmEdge_Result Res =
      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);
  if (WasmEdge_ResultOK(Res)) {
    printf(""u32 at memory[%u]: %u\n"", Offset, Num);
  } else {
    return Res;
  }
  return WasmEdge_Result_Success;
}
```

The `WasmEdge_CallingFrameGetModuleInstance()` API can help developers to get the module instance of the top frame on the stack. With the module instance context, developers can use the module instance-related APIs to get its contents.

The `WasmEdge_CallingFrameGetExecutor()` API can help developers to get the currently used executor context. Therefore developers can use the executor to recursively invoke other WASM functions without creating a new executor context.
","**Summary**

The provided code is a documentation of changes and guidelines for upgrading WasmEdge-Go from version 0.10.1 to 0.11.0. The main topics covered are:

* User-defined error codes in host functions
* Calling frames for host function extensions
* SONAME and SOVERSION changes

**Key Components**

1. **User-Defined Error Codes**: Introduced a new API `WasmEdge_ResultGen()` to generate user-defined error codes.
2. **Calling Frames**: Replaced memory instance context with calling frame context in host function definitions.
3. **SONAME and SOVERSION**: Updated linker options due to changes in WasmEdge shared library naming.

**Examples**

The code includes example host functions demonstrating the usage of:

* User-defined error codes
* Calling frames for host function extensions

**Potential Issues**

1. **Compatibility Breaks**: The introduction of new APIs may break existing code that relies on older versions.
2. **Confusing Naming Conventions**: The renaming of `libwasmedge_c.so` to `libwasmedge.so` might cause confusion when upgrading.

**Recommendations**

1. **Thoroughly Test Upgraded Code**: Ensure all code using WasmEdge-Go has been updated and tested for compatibility.
2. **Update Linker Options**: Change linker options according to the SONAME and SOVERSION changes."
i18n/zh/docusaurus-plugin-content-docs/current/start/build-and-run/docker_wasm.md,"---
sidebar_position: 4
---

# Docker + WASM

Docker Desktop 分发了内置的 WasmEdge 运行时。这使开发人员可以通过 Docker 工具构建、分享和运行非常轻量的容器（即，只包含 `.wasm` 文件的 `scratch` 空容器，没有任何 Linux 操作系统库或文件）。这些“WASM 容器”完全符合 OCI 标准，因此可以由 Docker Hub 进行管理。它们是跨平台的，可以在 Docker 支持的任何操作系统/CPU 上运行（操作系统和 CPU 平台为 `wasi/wasm`）。但更重要的是，相较于 Linux 容器，它们的体积是其十分之一，因为 WASM 容器不需要捆绑和启动 Linux 库和服务，所以启动时间也是十分之一。

结合 Docker 能够将开发环境和部署环境容器化的能力，你可以创建和部署复杂的应用程序，而无需安装任何依赖。例如，你可以在本地开发机器上设置完整的 Rust 和 WasmEdge 开发环境，而无需安装任何工具。你还可以部署一个复杂的 WasmEdge 应用，该应用需要连接到 MySQL 数据库，而无需在本地安装 MySQL。

在本指南中，我们将介绍如何：

- [创建并运行 Rust 程序](#创建并运行-Rust-程序)
- [创建并运行 Node.js 服务器](#创建并运行-Node.js-服务器)
- [在 Rust 中创建并部署数据库驱动的微服务](#在-Rust-中创建并部署数据库驱动的微服务)

## 环境要求

安装 [Docker Desktop](https://www.docker.com/products/docker-desktop/) 并在 Docker Desktop 设置中打开 containerd 镜像存储功能。

![Docker config](docker_config.png)

## 创建并运行 Rust 程序

使用 Docker + WASM，你可以在 Docker 容器中使用完整的 Rust 工具链构建 WASM 字节码应用程序，并发布和运行 WASM 应用程序。[这里提供了示例 Rust 源代码和构建说明](https://github.com/second-state/rust-examples/tree/main/hello)。

### 构建 Rust 示例

在项目目录中，运行以下命令，将 Rust 源代码构建为 WASM，并将 WASM 文件打包到一个空容器镜像中。请注意，你无需在此安装 Rust 编译器工具链。

```bash
docker buildx build --platform wasi/wasm -t secondstate/rust-example-hello .
```

[Dockerfile](https://github.com/second-state/rust-examples/blob/main/hello/Dockerfile) 中显示了构建方式。Dockerfile 由三部分组成。第一部分设置了用于 Rust 构建环境的 Docker 容器。

```dockerfile
FROM --platform=$BUILDPLATFORM rust:1.64 AS buildbase
WORKDIR /src
RUN <<EOT bash
    set -ex
    apt-get update
    apt-get install -y \
        git \
        clang
    rustup target add wasm32-wasi
EOT
```

第二部分使用 Rust 构建环境编译 Rust 源代码并生成 WASM 文件。

```dockerfile
FROM buildbase AS build
COPY Cargo.toml .
COPY src ./src
# Build the WASM binary
RUN cargo build --target wasm32-wasi --release
```

第三部分是关键部分。它将 WASM 文件复制到一个空的 `scratch` 容器中，然后将 WASM 文件设置为容器的 `ENTRYPOINT`。`rust-example-hello` 是由本节中的命令构建的容器镜像。

```dockerfile
FROM scratch
ENTRYPOINT [ ""hello.wasm"" ]
COPY --link --from=build /src/target/wasm32-wasi/release/hello.wasm /hello.wasm
```

WASM 容器镜像仅为 0.5MB。它比最小 Linux 容器中原生编译的 Rust 程序要小得多。

### 发布 Rust 示例

要将 WASM 容器镜像发布到 Docker Hub，请执行以下操作。

```bash
docker push secondstate/rust-example-hello
```

### 运行 Rust 示例

你可以使用常规的 Docker 的 `run` 命令来运行 WASM 容器应用程序。请注意，你确实需要指定 `runtime` 和 `platform` 标志，告知 Docker 这是一个非 Linux 容器，并且需要 WasmEdge 来运行它。

```bash
$ docker run --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/rust-example-hello:latest
Hello WasmEdge!
```

如上。

### 关于 Rust 示例的更多阅读

要查看更多针对 WasmEdge 的 Docker 化 Rust 示例应用程序，请查看以下内容。

- [使用 Rust 标准库](https://github.com/second-state/rust-examples/tree/main/wasi)
- [在 hyper 和 tokio 中创建 HTTP 服务器](https://github.com/second-state/rust-examples/tree/main/server)

### 创建并运行 Node.js 服务器

WasmEdge 提供与 Node.js 兼容的 JavaScript 运行时。你可以创建轻量级的 WASM 容器镜像来运行 Node.js 应用程序。与标准的 Node.js Linux 容器镜像相比，WASM 镜像体积仅为其 1/100、完全可移植，并且启动时间是其 1/10。

在本指南中，示例应用是一个用 Node.js 编写的 HTTP Web 服务器。其[源代码和构建说明在此处](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/docker_wasm/server)。

### 构建 Node.js 示例

在项目目录中，运行以下命令，将 WasmEdge JavaScript 运行时和 JS HTTP 服务器程序打包进空容器镜像。

```bash
docker buildx build --platform wasi/wasm -t secondstate/node-example-hello .
```

[Dockerfile](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/docker_wasm/server/Dockerfile) 中展示了操作是如何完成的。Dockerfile 由三个部分组成。第一部分设置了一个用于构建环境的 Docker 容器，其中包含 `wget` 和 `unzip` 实用程序。

```dockerfile
FROM --platform=$BUILDPLATFORM rust:1.64 AS buildbase
WORKDIR /src
RUN <<EOT bash
    set -ex
    apt-get update
    apt-get install -y \
        wget unzip
EOT
```

第二部分使用 `wget` 和 `unzip` 来下载和解压 WasmEdge JavaScript 运行时文件和 JS 应用文件到用于构建的容器中。

```dockerfile
FROM buildbase AS build
COPY server.js .
RUN wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm
RUN wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip
RUN unzip modules.zip
```

第三部分是关键。它将 WasmEdge JavaScript 运行时文件和 JS 应用文件复制到空的 `scratch` 容器中，并将 `wasmedge_quickjs.wasm` 设置为 `ENTRYPOINT`。 `node-example-hello` 是本部分的命令构建得到的容器镜像。

```dockerfile
FROM scratch
ENTRYPOINT [ ""wasmedge_quickjs.wasm"", ""server.js"" ]
COPY --link --from=build /src/wasmedge_quickjs.wasm /wasmedge_quickjs.wasm
COPY --link --from=build /src/server.js /server.js
COPY --link --from=build /src/modules /modules
```

整个 Node.js 应用的 WASM 容器镜像仅为 1MB。它远比标准 Node.js 镜像小，标准 Node.js 镜像体积为 300+MB。

### 发布 Node.js 示例

要将 WASM 容器镜像发布到 Docker Hub，请执行以下操作。

```bash
docker push secondstate/node-example-hello
```

### 运行和测试 Node.js 示例

你可以使用常规的 Docker 的 `run` 命令来运行 WASM 容器应用程序。请注意，你确实需要指定 `runtime` 和 `platform` 标志，告知 Docker 这是一个非 Linux 容器，并且需要 WasmEdge 来运行它。由于这是一个 HTTP 服务器应用，还需要将容器的端口 8080 映射到主机，以便你可以从主机访问服务器。

```bash
$ docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/node-example-server:latest
listen 8080 ...
```

启动另一个终端，测试服务器应用。

```bash
$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

以上。

### Node.js 示例相关的进一步阅读

- [使用 fetch() API](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js)
- [使用 Tensorflow Lite 进行图像分类](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo)

### 创建和部署 Rust 驱动的数据库微服务

Docker + WASM 允许我们构建和运行 WASM 容器。然而，在大多数复杂应用中，WASM 容器只是应用的一部分。它需要与系统中的其他 Linux 容器协同工作。[Docker compose](https://docs.docker.com/compose/) 工具广泛用于组合和管理多容器部署，它与 Docker Desktop 一起安装。

在我们的[示例微服务应用程序](https://github.com/second-state/microservice-rust-mysql) 中，包括一个 Nginx Web 服务器和一个 MySQL 数据库。WASM 容器仅用于 Rust 应用，用于访问数据库和处理 HTTP 请求（即应用服务器）。

<!-- prettier-ignore -->
:::note
要了解更多 Docker compose 示例，包括 Linux 容器 + WASM 容器混合部署，请查看 [awesome-compose](https://github.com/docker/awesome-compose) 仓库。
:::

### 构建微服务示例

在项目目录中，运行以下命令以构建所有三个容器：`client`、`server` 和 `db`。

```bash
docker compose up
```

在 [docker-compose.yml](https://github.com/second-state/microservice-rust-mysql/blob/main/docker-compose.yml) 文件中定义了本应用中所需的 3 个容器。

```yaml
services:
  client:
    image: nginx:alpine
    ports:
      - 8090:80
    volumes:
      - ./client:/usr/share/nginx/html
  server:
    image: demo-microservice
    platform: wasi/wasm
    build:
      context: .
    ports:
      - 8080:8080
    environment:
      DATABASE_URL: mysql://root:whalehello@db:3306/mysql
      RUST_BACKTRACE: full
    restart: unless-stopped
    runtime: io.containerd.wasmedge.v1
  db:
    image: mariadb:10.9
    environment:
      MYSQL_ROOT_PASSWORD: whalehello
```

- `client` 容器是一个 Nginx Web 服务器
  - 一个 Linux 容器，映射了 HTTP 端口和用于放置静态 HTML/JS 文件的 Volume
- `server` 容器是一个用于业务逻辑的 Rust 容器
  - 一个 WASM 容器，通过使用此 [Dockerfile](https://github.com/second-state/microservice-rust-mysql/blob/main/Dockerfile) 构建的构建该 [Rust 源码](https://github.com/second-state/microservice-rust-mysql/blob/main/src/main.rs)生成 
  - WASM 容器映射了 Web 服务端口，并设定了用于连接数据库连的环境变量
- `db` 容器是一个 MySQL 数据库
  - 一个 Linux 容器，预设了数据库密码

### 部署微服务示例

使用 `up` 指令依次启动和运行所有三个容器。

```bash
docker compose up
```

返回 Docker Desktop 管理后台，你将看到三个容器正在运行。

![Docker](docker.jpeg)

### CRUD 测试

打开另一个终端，你可以使用 `curl` 命令与 Web 服务交互。

当微服务接收到 `/init` 终点的 `GET` 请求时，它将用 `orders` 表初始化数据库。

```bash
curl http://localhost:8080/init
```

当微服务接收到 `/create_order` 的 `POST` 请求时，它将从 `POST` 主体中提取 JSON 数据，并将 `Order` 记录插入到数据库表中。对于多个记录，请访问 `/create_orders` 接口，并以 POST 一个 JSON 数组格式的 `Order` 对象。

```bash
curl http://localhost:8080/create_orders -X POST -d @orders.json
```

当微服务接收到 `/orders` 的 `GET` 请求时，它将从 `orders` 表中获取所有行，并在 HTTP 响应中以 JSON 数组的形式返回结果集。

```bash
curl http://localhost:8080/orders
```

当微服务接收到 `/update_order` 的 `POST` 请求时，它将从 `POST` 主体中提取 JSON 数据，并更新数据库表中与输入数据中的 `order_id` 匹配的 `Order` 记录。

```bash
curl http://localhost:8080/update_order -X POST -d @update_order.json
```

当微服务接收到 `/delete_order` 终点的 `GET` 请求时，它将删除与 `id` `GET` 参数匹配的 `orders` 表中的行。

```bash
curl http://localhost:8080/delete_order?id=2
```

以上。

你可以基于此项目创造自己轻量级微服务的模板！

### 微服务示例的进一步阅读

要了解 Docker + WASM 在内部是如何工作的，请访问 [containerd](../../develop/deploy/cri-runtime/containerd.md) 章节了解更多详情。
","本文分析了使用 Docker + WASM 构建、部署和管理微服务应用程序的指南。该指南介绍了如何使用 Rust 和 Node.js 构建微服务应用程序，并将其与 Docker 容器化。

以下是总结：

* **Docker Desktop**: 提供一个内置 WasmEdge 运行时的 Docker Desktop 分发，使开发人员可以通过 Docker 工具构建、分享和运行非常轻量的容器（仅包含`.wasm`文件的 `scratch`空容器，没有任何 Linux 操作系统库或文件）。
* **Rust 应用程序**: 使用 Docker + WASM 构建 Rust 服务，访问 MySQL 数据库，并处理 HTTP 请求。该示例应用是一个 RESTful API，提供 CRUD 操作（创建、读取、更新和删除）来操作 `orders` 表。
* **Node.js 应用程序**: 使用 WasmEdge JavaScript 运行时构建轻量级的 WASM 容器镜像，以运行 Node.js 服务。示例应用是一个 HTTP Web 服务器，提供 RESTful API 来处理 GET、POST 等请求。
* **Docker Compose**: 使用 Docker Compose 将多个容器组合在一起来管理微服务部署。

该指南还提供了各个步骤的具体命令和示例代码，以帮助用户了解如何使用 Docker + WASM 构建和部署微服务应用程序。"
docs/contribute/users.md,"---
sidebar_position: 11
---

# WasmEdge Users and Collaborators

This list is constantly being updated. Please submit a PR to add your own item if we missed your use case. We appreciate our community members' contributions. Thank you!

| Name | Desciption | PR or Docs |
| --- | --- | --- |
| WebAssembly Languages Runtime maintained by VMWare | Use WasmEdge to run PHP and python programs | <https://github.com/vmware-labs/webassembly-language-runtimes/pull/19> |
| Cocos AI | WasmEdge is used for Confidential Computing inference of AI workloads in a secure TEE enclave | <https://github.com/ultravioletrs/cocos/pull/189> |
| WikiFunctions | Use WasmEdge to execute serverless functions to be embedded in Wikipedia | <https://www.wikifunctions.org/wiki/Wikifunctions:Status_updates/2024-08-23> |
| LF Edge eKuiper | Use WasmEdge to process data streamed from IoT devices | <https://github.com/lf-edge/ekuiper/pull/1449/> |
| crun | Use WasmEdge to run WASM containers | <https://github.com/containers/crun/pull/774> |
| youki | Use WasmEdge to run WASM containers | <https://github.com/containers/youki/pull/1320> |
| containerd and runwasi | Use WasmEdge to run WASM containers | <https://github.com/containerd/runwasi> |
| Kuasar | Use WasmEdge to run WASM containers | <https://github.com/kuasar-io/kuasar#wasm-sandboxer> |
| Proxy-wasm | Use WASM to process the proxy rules | <https://github.com/proxy-wasm/proxy-wasm-cpp-host/pull/193> |
| OpenYurt | Use WasmEdge to run WASM containers side by side with Linux containers in an OpenYurt network. | <https://www.cncf.io/blog/2022/02/07/wasmedge-and-openyurt-bring-cloud-computing-to-the-edge/> |
| SuperEdge | Use WasmEdge to run WASM containers side by side with Linux containers in a SuperEdge network. | <https://github.com/WasmEdge/WasmEdge/pull/1272> |
| OpenGauss | Use WasmEdge to support user-defined functions (UDF) in a database | <https://hub.docker.com/r/opengauss/wasmedge> |
| Essa-ra | Use WasmEdge to execute serverless functions on the essa-rs platform. | <https://github.com/essa-project/essa-rs> |
| Fedora Linux | Incorporated WasmEdge as an official RPM package since Fedora 37. | <https://packages.fedoraproject.org/pkgs/wasmedge/wasmedge/index.html> |
| Polkadot | Provide WasmEdge as a smart contract runtime for parachains, and support WasmEdge as an alternative runtime for substrate nodes. | <https://github.com/second-state/substrate-wasmedge> |
| Apache Traffic Server | Use WasmEdge as a plug-in to process the traffic flow | <https://github.com/apache/trafficserver/pull/9390> |
| Enovy | Use WasmEdge as a plug-in to process the traffic flow | <https://github.com/envoyproxy/envoy/pull/24817/files> |
| Liquid Reply | Kubernetes operators for managing WasmEdge workloads for customers | <https://kwasm.sh/> |
| Docker | Use WasmEdge to support wasm containers in Docker Desktop tools | <https://www.docker.com/blog/docker-wasm-technical-preview/> |
| ByteDance | Use WasmEdge to run custom logic in service mesh proxies and sidecars | Internal use case |
| ByteDance | Use WasmEdge to run serverless functions | Internal use case |
| ByteDance | Use WasmEdge as a Ray node | <https://github.com/ray-project/enhancements/blob/main/reps/2023-02-01-wasm-on-ray.md> |
| Huawei Cloud | Use WasmEdge to run Serverless functions | Internal use case |
| 5miles | Use WasmEdge to run internal microservices | Internal use case |
| Bytetrade | Use WasmEdge to run microservices for automated crypto trading and marketing automation | Internal use case |
| FutureWei | Use WasmEdge on automobile and OpenHarmony | <https://github.com/WasmEdge/WasmEdge/pull/902> |
| WinSoft | Use WasmEdge to improve IDE’s user experience | <https://winsoft.sk/webassembly.htm> |
| ParaState | Use WasmEdge to execute smart contracts on the ParaState blockchain | <https://www.parastate.io/> |
| Plurigrid | Use WasmEdge to run client-side / edge simulations | <https://twitter.com/bmorphism/status/1606237485037674499> |
| XRPL Labs | Use WasmEdge to execute smart contracts on the Ripple blockchain | <https://github.com/XRPL-Labs/xrpld-hooks> |
| API7 | Run WasmEdge in OpenResty/Nginx | <https://github.com/api7/wasm-nginx-module> |
| YoMo | Use WasmEdge to support user-defined functions (UDF) in streaming data pipelines | [https://github.com/yomorun/yomo-wasmedge-tensorflow](https://github.com/yomorun/yomo) |
| libsql | Use WasmEdge to support user-defined functions (UDF) in a database | <https://github.com/libsql/libsql/pull/131> |
| Shifu | Use WasmEdge to support user-defined functions (UDF) in data streams from edge devices | <https://github.com/Edgenesis/wasm-shifu-demo> |
| Lnjoying | Offers WasmEdge as part of its edge cloud service. | Internal use case |
| Red Hat EPEL 9 | Offers support for wasmedge packages for Red Hat Linux 9 users | <https://packages.fedoraproject.org/pkgs/wasmedge/wasmedge/index.html> |
| Open Interpreter| Use WasmEdge as the LLM runtime | <https://github.com/OpenInterpreter/01/tree/main/software/source/server/services/llm/llamaedge> |
| GaiaNet| Use WasmEdge as LLM runtime | <https://github.com/GaiaNet-AI/gaianet-node> |
| EigenLayer | Use WasmEdge to run an LLM that validates user submitted content | <https://x.com/sreeramkannan/status/1834313576133394438> |
| MoXin| Use WasmEdge as the LLM runtime | <https://github.com/project-robius/moxin> |
| CODA Bridge| Use WasmEdge as the container to run microservices | Internal use case |
| CloudEvents | Support the Rust SDK to be compiled into Wasm so that a Wasm app can send and receive cloud events | <https://github.com/cloudevents/sdk-rust/pull/202> |
| Kagome | A C++ implementation of Polkadot host which runs Wasm smart contracts on WasmEdge | <https://github.com/qdrvm/kagome/tree/master/core/runtime> |
| Sealos | A Cloud Operating System designed for managing cloud-native applications. It uses WasmEdge to run LLMs locally in its cluster | <https://github.com/labring-actions/cluster-image/blob/main/applications/runwasi-wasmedge/latest/install.sh> |
","**Summary**

This code is a Markdown file (`users.md`) that lists various projects, companies, and individuals using the WasmEdge WebAssembly runtime. The list includes descriptions of each use case, along with links to related GitHub pull requests or documentation.

**Key Components**

1. **Project List**: A table listing various projects, companies, and individuals using WasmEdge.
2. **Description Column**: A brief description of each project's use case.
3. **PR/Docs Column**: Links to relevant GitHub pull requests or documentation for each project.

**Functionality**

The purpose of this code is to:

1. Provide a comprehensive list of projects using WasmEdge.
2. Allow users to easily find and explore various applications of WasmEdge.
3. Facilitate community engagement by encouraging users to submit their own use cases.

**Potential Issues/Areas for Improvement**

1. **Maintenance**: As new projects emerge, the list will need to be updated regularly to ensure its accuracy and relevance.
2. **Organization**: With over 50 entries, the list may become unwieldy. Consider categorizing or grouping related projects together.
3. **Link Rot**: Links to external resources (e.g., GitHub pull requests) may break over time, making it essential to monitor and update these links regularly.

Overall, this code provides a valuable resource for the WasmEdge community, showcasing its versatility and widespread adoption in various industries and domains."
docs/develop/deploy/gpu/docker_wasm_gpu.md,"---
sidebar_position: 5
---

# Docker + WASM + GPU

This is a completely new approach, adopting Docker + Crun with Wasmedge + [CDI](https://github.com/cncf-tags/container-device-interface) to enable the usage of host GPU devices. The reason for not continuing with the use of runwasi as the wasm runtime within Docker from the previous chapter is due to considerations of the current stage of support for CDI and the compatibility approach.

## Prerequisite

Before we start, you need

- GPU device (Here we will take NVIDIA graphics cards as our example and we have only conducted tests on NVIDIA GPUs on linux for now)
  - Install NVIDIA GPU Driver
  - Install either the NVIDIA Container Toolkit or you installed the nvidia-container-toolkit-base package.
- Docker version > 4.29 (which includes Moby 25)

Regarding the installation of the NVIDIA driver and toolkit, we won't go into detail here, but we could provide a few reference documents and the ways to verify your environment is ok.

[Nvidia drivers installation on ubuntu](https://ubuntu.com/server/docs/nvidia-drivers-installation), [Toolkit install guide](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html), [Nvidia CDI supoort reference](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/cdi-support.html)

```bash
# check your driver and device
> nvidia-smi -L

# Check your toolkit
> nvidia-ctk --version
```

Install latest docker-ce

```bash
> curl -fsSL https://get.docker.com -o get-docker.sh
> sh get-docker.sh

# Check your docker
> docker --version
```

## CDI setup

[Generate the CDI specification file](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/cdi-support.html#procedure)

```bash
> sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml

# Check you cdi config is good
> nvidia-ctk cdi list

# Example output
INFO[0000] Found 2 CDI devices
nvidia.com/gpu=0
nvidia.com/gpu=all
```

[Enable CDI in docker config](https://docs.docker.com/reference/cli/dockerd/#enable-cdi-devices) (/etc/docker/daemon.json)

```json
{
  ""features"": {
     ""cdi"": true
  },
  ""cdi-spec-dirs"": [""/etc/cdi/"", ""/var/run/cdi""]
}
```

```bash
# Reload docker daemon
> sudo systemctl reload docker

# Test your cdi setup good
> docker run --rm --device nvidia.com/gpu=all ubuntu:22.04 nvidia-smi -L

# Example output 
GPU 0: NVIDIA GeForce GTX 1080 (UUID: GPU-********-****-****-****-************)
```

## Setup your container runtime (crun + wasmedge + plugin system)

Build crun with wasmedge enable

```bash
> sudo apt install -y make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake

> git clone https://github.com/containers/crun
> cd crun
> ./autogen.sh
> ./configure --with-wasmedge
> make

# Check your crun
> ./crun --version
```

Replace container run time

```json
{
  ""runtimes"": {
    ""crun"": {
      ""path"": ""<The crun binary path is built by yourself>""
    }
  },
  ""features"": {
    ""cdi"": true
  },
  ""cdi-spec-dirs"": [""/etc/cdi/"", ""/var/run/cdi""]
}
```

```bash
# Reload docker daemon
> sudo systemctl reload docker
```

Download ggml plugin into host

```bash
> curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-ggml

# Make sure all your plugin dependencies is good
> ldd ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so
```

## Demo llama with our wasm application

> The demo image is built the Wasm application from [here](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/wasmedge-ggml/llama), and upload it to [here](https://github.com/captainvincent/runwasi/pkgs/container/runwasi-demo/195178675?tag=wasmedge-ggml-llama).

Download inference model

```bash
> curl -LO https://huggingface.co/second-state/Llama-2-7B-Chat-GGUF/resolve/main/llama-2-7b-chat.Q5_K_M.gguf
```

Docker run llama2 inference

```bash
docker run -v ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so:/.wasmedge/plugin/libwasmedgePluginWasiNN.so \
  -v /usr/local/cuda/targets/x86_64-linux/lib/libcudart.so.12:/lib/x86_64-linux-gnu/libcudart.so.12 \
  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublas.so.12:/lib/x86_64-linux-gnu/libcublas.so.12 \
  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublasLt.so.12:/lib/x86_64-linux-gnu/libcublasLt.so.12 \
  -v /lib/x86_64-linux-gnu/libcuda.so.1:/lib/x86_64-linux-gnu/libcuda.so.1 \
  -v .:/resource \
  --env WASMEDGE_PLUGIN_PATH=/.wasmedge/plugin \
  --env WASMEDGE_WASINN_PRELOAD=default:GGML:AUTO:/resource/llama-2-7b-chat.Q5_K_M.gguf \
  --env n_gpu_layers=100 \
  --rm --device nvidia.com/gpu=all --runtime=crun --annotation=module.wasm.image/variant=compat-smart --platform wasip1/wasm \
  ghcr.io/captainvincent/runwasi-demo:wasmedge-ggml-llama default \
  $'[INST] <<SYS>>\nYou are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you do not know the answer to a question, please do not share false information.\n<</SYS>>\nWhat is the capital of Japan?[/INST]'
```

Example Result

```bash
ggml_init_cublas: GGML_CUDA_FORCE_MMQ:   no
ggml_init_cublas: CUDA_USE_TENSOR_CORES: yes
ggml_init_cublas: found 1 CUDA devices:
  Device 0: NVIDIA GeForce GTX 1080, compute capability 6.1, VMM: yes
Prompt:
[INST] <<SYS>>
You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you do not know the answer to a question, please do not share false information.
<</SYS>>
What is the capital of Japan?[/INST]
Response:
[INFO] llama_commit: ""4ffcdce2""
[INFO] llama_build_number: 2334
[INFO] Number of input tokens: 140
Thank you for asking! The capital of Japan is Tokyo. I'm glad you asked! It's important to be informed and curious about different countries and their capitals. Is there anything else I can help you with?
[INFO] Number of input tokens: 140
[INFO] Number of output tokens: 48
```
","**Summary**

This document outlines the steps to deploy a Docker container on a GPU-enabled machine using WASM (WebAssembly) and Crun. The setup involves installing NVIDIA drivers, Crun with WASmedge, and CDI (Container Device Interface). Additionally, it covers configuring the container runtime, downloading plugins, and running a demo application.

**Key Components**

1. **Docker**: Latest version 4.29 or later is required.
2. **Crun**: Container run time with WASmedge enable.
3. **WASmedge**: WebAssembly runtime for Crun.
4. **CDI (Container Device Interface)**: Enables GPU access within containers.
5. **NVIDIA Drivers**: Required for GPU acceleration.
6. **Plugin System**: ggml plugin is required for demo application.

**Setup Steps**

1. Install NVIDIA drivers and CDI on the host machine.
2. Build Crun with WASmedge enable.
3. Configure the container runtime to use Crun.
4. Download and install the ggml plugin.
5. Run the demo application using Docker.

**Potential Issues**

1. **GPU compatibility**: The setup requires an NVIDIA GPU, which may not be available on all machines.
2. **Crun installation**: Building Crun with WASmedge enable may require additional dependencies or configuration.
3. **Plugin system**: Installing the ggml plugin may require administrative privileges.
4. **Demo application**: The demo application may have specific requirements for the input data and environment variables.

**Conclusion**

This setup enables running Docker containers on a GPU-enabled machine using WASM and Crun. It provides a foundation for deploying AI and ML applications on Kubernetes clusters with GPU acceleration. However, it requires careful planning and testing to ensure compatibility and optimal performance."
i18n/zh/docusaurus-plugin-content-docs/current/start/build-and-run/docker_wasm_gpu.md,"---
sidebar_position: 5
---

# Docker + WASM + GPU

This is a completely new approach, adopting Docker + Crun with Wasmedge + [CDI](https://github.com/cncf-tags/container-device-interface) to enable the usage of host GPU devices. The reason for not continuing with the use of runwasi as the wasm runtime within Docker from the previous chapter is due to considerations of the current stage of support for CDI and the compatibility approach.

## Prerequisite

Before we start, you need

- GPU device (Here we will take NVIDIA graphics cards as our example and we have only conducted tests on NVIDIA GPUs on linux for now)
  - Install NVIDIA GPU Driver
  - Install either the NVIDIA Container Toolkit or you installed the nvidia-container-toolkit-base package.
- Docker version > 4.29 (which includes Moby 25)

Regarding the installation of the NVIDIA driver and toolkit, we won't go into detail here, but we could provide a few reference documents and the ways to verify your environment is ok.

[Nvidia drivers installation on ubuntu](https://ubuntu.com/server/docs/nvidia-drivers-installation), [Toolkit install guide](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html), [Nvidia CDI supoort reference](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/cdi-support.html)

```bash
# check your driver and device
> nvidia-smi -L

# Check your toolkit
> nvidia-ctk --version
```

Install latest docker-ce

```bash
> curl -fsSL https://get.docker.com -o get-docker.sh
> sh get-docker.sh

# Check your docker
> docker --version
```

## CDI setup

[Generate the CDI specification file](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/cdi-support.html#procedure)

```bash
> sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml

# Check you cdi config is good
> nvidia-ctk cdi list

# Example output
INFO[0000] Found 2 CDI devices
nvidia.com/gpu=0
nvidia.com/gpu=all
```

[Enable CDI in docker config](https://docs.docker.com/reference/cli/dockerd/#enable-cdi-devices) (/etc/docker/daemon.json)

```json
{
  ""features"": {
     ""cdi"": true
  },
  ""cdi-spec-dirs"": [""/etc/cdi/"", ""/var/run/cdi""]
}
```

```bash
# Reload docker daemon
> sudo systemctl reload docker

# Test your cdi setup good
> docker run --rm --device nvidia.com/gpu=all ubuntu:22.04 nvidia-smi -L

# Example output 
GPU 0: NVIDIA GeForce GTX 1080 (UUID: GPU-********-****-****-****-************)
```

## Setup your container runtime (crun + wasmedge + plugin system)

Build crun with wasmedge enable

```bash
> sudo apt install -y make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake

> git clone https://github.com/containers/crun
> cd crun
> ./autogen.sh
> ./configure --with-wasmedge
> make

# Check your crun
> ./crun --version
```

Replace container run time

```json
{
  ""runtimes"": {
    ""crun"": {
      ""path"": ""<The crun binary path is built by yourself>""
    }
  },
  ""features"": {
    ""cdi"": true
  },
  ""cdi-spec-dirs"": [""/etc/cdi/"", ""/var/run/cdi""]
}
```

```bash
# Reload docker daemon
> sudo systemctl reload docker
```

Download ggml plugin into host

```bash
> curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-ggml

# Make sure all your plugin dependencies is good
> ldd ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so
```

## Demo llama with our wasm application

> The demo image is built the Wasm application from [here](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/wasmedge-ggml/llama), and upload it to [here](https://github.com/captainvincent/runwasi/pkgs/container/runwasi-demo/195178675?tag=wasmedge-ggml-llama).

Download inference model

```bash
> curl -LO https://huggingface.co/second-state/Llama-2-7B-Chat-GGUF/resolve/main/llama-2-7b-chat.Q5_K_M.gguf
```

Docker run llama2 inference

```bash
docker run -v ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so:/.wasmedge/plugin/libwasmedgePluginWasiNN.so \
  -v /usr/local/cuda/targets/x86_64-linux/lib/libcudart.so.12:/lib/x86_64-linux-gnu/libcudart.so.12 \
  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublas.so.12:/lib/x86_64-linux-gnu/libcublas.so.12 \
  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublasLt.so.12:/lib/x86_64-linux-gnu/libcublasLt.so.12 \
  -v /lib/x86_64-linux-gnu/libcuda.so.1:/lib/x86_64-linux-gnu/libcuda.so.1 \
  -v .:/resource \
  --env WASMEDGE_PLUGIN_PATH=/.wasmedge/plugin \
  --env WASMEDGE_WASINN_PRELOAD=default:GGML:AUTO:/resource/llama-2-7b-chat.Q5_K_M.gguf \
  --env n_gpu_layers=100 \
  --rm --device nvidia.com/gpu=all --runtime=crun --annotation=module.wasm.image/variant=compat-smart --platform wasip1/wasm \
  ghcr.io/captainvincent/runwasi-demo:wasmedge-ggml-llama default \
  $'[INST] <<SYS>>\nYou are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you do not know the answer to a question, please do not share false information.\n<</SYS>>\nWhat is the capital of Japan?[/INST]'
```

Example Result

```bash
ggml_init_cublas: GGML_CUDA_FORCE_MMQ:   no
ggml_init_cublas: CUDA_USE_TENSOR_CORES: yes
ggml_init_cublas: found 1 CUDA devices:
  Device 0: NVIDIA GeForce GTX 1080, compute capability 6.1, VMM: yes
Prompt:
[INST] <<SYS>>
You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you do not know the answer to a question, please do not share false information.
<</SYS>>
What is the capital of Japan?[/INST]
Response:
[INFO] llama_commit: ""4ffcdce2""
[INFO] llama_build_number: 2334
[INFO] Number of input tokens: 140
Thank you for asking! The capital of Japan is Tokyo. I'm glad you asked! It's important to be informed and curious about different countries and their capitals. Is there anything else I can help you with?
[INFO] Number of input tokens: 140
[INFO] Number of output tokens: 48
```
","**Summary:**

This guide outlines a comprehensive approach to building and running a Docker container that utilizes the GPU (Graphics Processing Unit) for accelerated computing. The process involves:

1. **Prerequisites**: Installing an NVIDIA GPU driver, NVIDIA Container Toolkit, and Docker version > 4.29.
2. **CDI setup**: Generating a CDI specification file using `nvidia-ctk cdi generate`, enabling CDI in the Docker config (`/etc/docker/daemon.json`), and reloading the Docker daemon.
3. **Setup container runtime**: Building CRUN with WASMEDGE enable, replacing the default container runtime, and downloading the ggml plugin.
4. **Demo llama with wasm application**: Running a WasmEdge-WASINN example (llama) in a Docker container with GPU acceleration.

**Key components:**

1. `nvidia-smi` for checking GPU driver and device information
2. `nvidia-ctk` for managing CDI (Container Device Interface)
3. CRUN (Container Runtime) with WASMEDGE enable
4. ggml plugin for WasmEdge-WASINN (Wasm-based AI inference)

**Potential issues or areas for improvement:**

1. The guide assumes an NVIDIA GPU driver is installed and configured correctly.
2. CDI setup requires a deep understanding of the underlying technology and potential pitfalls.
3. Building CRUN with WASMEDGE enable can be complex and error-prone.
4. ggml plugin installation and configuration may require additional troubleshooting.
5. The demo llama example uses a specific WasmEdge-WASINN version, which might not be compatible with future releases.

**Recommendations:**

1. Carefully follow the guide to ensure correct setup and configuration of CDI, CRUN, and ggml plugin.
2. Verify GPU driver and device information before proceeding.
3. Monitor system logs for potential errors or warnings during installation and runtime.
4. Consider using a more stable and widely supported container runtime (e.g., Docker Desktop).
5. Familiarize yourself with WasmEdge-WASINN documentation and examples to better understand the technology."
docs/contribute/plugin/intro.md,"---
sidebar_position: 1
---

# WasmEdge Plug-in System Introduction

While the WasmEdge language SDKs allow registering host functions from a host (wrapping) application, developers should implement the host functions before compilation. However, for a more flexible and dynamic extension of the host functions, WasmEdge provides a plug-in architecture to load the plug-in shared library.

A WasmEdge plug-in is a software component that extends the functionality of the WasmEdge runtime. Currently, developers can follow the guides to implement the plug-ins in [C API](develop_plugin_c.md) (recommended), [C++](develop_plugin_cpp.md) and [Rust](develop_plugin_rustsdk.md). With the help of the WasmEdge SDKs in the supported languages, developers can load and register the host functions from the plug-in shared libraries, allowing them to seamlessly integrate the plug-ins into the WasmEdge runtime as if they were part of the core runtime.

```mermaid
graph LR
    A((Host Application)) -- Loads --> B((Plug-in Shared Library))
    B -- Registers --> C((Wasmedge Runtime))
```

## Benefits of Using WasmEdge Plug-in

WasmEdge plug-ins are designed to extend the functionality of the WasmEdge runtime and can be helpful for developers and end-users in several ways:

- **Customization:** WasmEdge plug-ins can be customized to suit the specific needs of a project. Developers can create plug-ins that integrate with other systems or tools or provide unique functionality unavailable in the core WasmEdge runtime.

- **Performance:** WasmEdge plug-ins are designed to work seamlessly with the core runtime, minimizing overhead and maximizing performance, which means they can provide additional functionality without sacrificing performance.

- **Ease of use:** WasmEdge plug-ins are easy to use and integrate with the WasmEdge runtime. Developers can load the plug-in into the runtime and use its functions as part of the core runtime.

- **Scalability:** Developers can compile their compute-intensive functions into host functions and package them into a plug-in to provide the better performance as running in native code.

WasmEdge plug-ins can provide developers and users with a versatile, customizable, high-performance, and secure way to extend the functionality of the WasmEdge runtime. WasmEdge plug-ins can also improve scalability and ease of use, making it easier to build and deploy complex applications on edge devices.

## Loadable Plug-in

Loadable plug-ins are standalone shared libraries (`.so`/`.dylib`/`.dll` files) that the WasmEdge runtime environment can load at runtime. These plug-ins can provide additional functionality to the WasmEdge runtime environment, such as new modules that can be imported by WebAssembly modules.

### Creating Loadable Plug-in

To create a loadable plug-in for WasmEdge, developers can use the WasmEdge Plug-in SDK, which provides a set of Rust, C, and C++ APIs for creating and registering plug-ins. The SDK also includes [example code](https://github.com/WasmEdge/WasmEdge/tree/master/examples/plugin/get-string) that demonstrates creating a simple plug-in that returns a string. By following the provided examples and leveraging the SDK's APIs, developers can quickly build custom plug-ins tailored to their specific needs.

### Loading plug-in from paths

To use the loadable plug-ins, developers need to load them from specific paths into the WasmEdge runtime environment. The loading process involves the following steps:

- Loadable plug-ins can be loaded from default paths by calling the `WasmEdge_PluginLoadWithDefaultPaths()` API. The default paths include:

  - The path specified in the environment variable `WASMEDGE_PLUGIN_PATH`.
  - The `./plugin/` directory relative to the WasmEdge installation path.
  - The `./wasmedge/` directory is located under the library path if WasmEdge is installed in a system directory such as `/usr` and `/usr/local`.

- If the plug-ins are located in a specific path or directory, developers can use the `WasmEdge_PluginLoadFromPath(""PATH_TO_PLUGIN/plug-in.so"")` API to load the plug-ins from that particular location.

The WasmEdge runtime environment will search for the loadable plug-ins in the specified paths and load them if found.

The following flowchart shows the process of loading loadable plug-ins into the WasmEdge runtime environment from specific paths:

```mermaid
graph LR
    A((Start)) --> B(Loadable Plug-ins)
    B --> C{Load Plug-ins}
    C --> D[Load from Default Paths]
    C --> E[Load from Specific Path]
    C --> F[Load from Specific Directory]
    D --> G{Is Plug-in Found?}
    E --> G
    F --> G
    G -- Yes --> H(Load Plug-in)
    H --> I(End)
    G -- No --> I
```

The flowchart shows loading loadable plug-ins into the WasmEdge runtime environment. The process involves searching for plug-ins in default paths, a specific path, or a specific directory. If a plug-in is found in any of these locations, it is loaded into the runtime environment. The flowchart enables developers to quickly load plug-ins and extend the capabilities of the WasmEdge runtime.

By following this flowchart, developers can effectively load loadable plug-ins into the WasmEdge runtime environment from specific paths, expanding the runtime's functionality according to their requirements.

## WasmEdge Currently Released Plug-ins

Users can install the [WasmEdge official released plug-ins](../../start/wasmedge/extensions/plugins.md) from the installer, or build them from source.
","**Summary**

WasmEdge is a web assembly runtime that provides a plug-in architecture for developers to extend its functionality. The plug-ins are standalone shared libraries (.so/.dylib/.dll files) that can be loaded at runtime, providing additional features such as new modules, host functions, and integration with other systems or tools.

**Key Components**

1. **Loadable Plug-in**: A plug-in is a shared library (e.g., .so file) that can be loaded into the WasmEdge runtime environment.
2. **WasmEdge Plugin SDK**: The SDK provides APIs for creating and registering plug-ins, with example code available in Rust, C, and C++.
3. **Default Paths**: Plug-ins can be loaded from default paths specified by the `WASMEDGE_PLUGIN_PATH` environment variable or the `./plugin/` directory relative to the WasmEdge installation path.

**Benefits**

1. **Customization**: Plug-ins allow developers to extend the functionality of WasmEdge and integrate with other systems or tools.
2. **Performance**: Loadable plug-ins can provide additional functionality without sacrificing performance, thanks to their seamless integration with the core runtime.
3. **Ease of Use**: Developing and loading plug-ins is made easier by the provided SDK and example code.

**Flowchart**

The flowchart illustrates the process of loading loadable plug-ins into the WasmEdge runtime environment from specific paths:

```mermaid
graph LR
    A((Start)) --> B(Loadable Plug-ins)
    B --> C{Load Plug-ins}
    C --> D[Load from Default Paths]
    C --> E[Load from Specific Path]
    C --> F[Load from Specific Directory]
    D --> G{Is Plug-in Found?}
    E --> G
    F --> G
    G -- Yes --> H(Load Plug-in)
    H --> I(End)
    G -- No --> I
```

**Potential Issues and Areas for Improvement**

1. **Limited Support**: While WasmEdge provides support for various programming languages (e.g., Rust, C, C++), its plug-in architecture might not be as robust or widely adopted as other solutions.
2. **Performance Overhead**: Depending on the complexity of the plug-in and its implementation, there may be performance overhead associated with loading and executing them.
3. **Security Risks**: As with any shared library-based approach, there is a risk of security vulnerabilities if not properly handled.

By understanding these components, benefits, flowchart, and potential issues, developers can effectively utilize WasmEdge's plug-in architecture to extend its functionality and build more robust web assembly applications."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/intro.md,"---
sidebar_position: 1
---

# WasmEdge Plug-in System Introduction

While the WasmEdge language SDKs allow registering host functions from a host (wrapping) application, developers should implement the host functions before compilation. However, for a more flexible and dynamic extension of the host functions, WasmEdge provides a plug-in architecture to load the plug-in shared library.

A WasmEdge plug-in is a software component that extends the functionality of the WasmEdge runtime. Currently, developers can follow the guides to implement the plug-ins in [C API](develop_plugin_c.md) (recommended), [C++](develop_plugin_cpp.md) and [Rust](develop_plugin_rustsdk.md). With the help of the WasmEdge SDKs in the supported languages, developers can load and register the host functions from the plug-in shared libraries, allowing them to seamlessly integrate the plug-ins into the WasmEdge runtime as if they were part of the core runtime.

```mermaid
graph LR
    A((Host Application)) -- Loads --> B((Plug-in Shared Library))
    B -- Registers --> C((Wasmedge Runtime))
```

## Benefits of Using WasmEdge Plug-in

WasmEdge plug-ins are designed to extend the functionality of the WasmEdge runtime and can be helpful for developers and end-users in several ways:

- **Customization:** WasmEdge plug-ins can be customized to suit the specific needs of a project. Developers can create plug-ins that integrate with other systems or tools or provide unique functionality unavailable in the core WasmEdge runtime.

- **Performance:** WasmEdge plug-ins are designed to work seamlessly with the core runtime, minimizing overhead and maximizing performance, which means they can provide additional functionality without sacrificing performance.

- **Ease of use:** WasmEdge plug-ins are easy to use and integrate with the WasmEdge runtime. Developers can load the plug-in into the runtime and use its functions as part of the core runtime.

- **Scalability:** Developers can compile their compute-intensive functions into host functions and package them into a plug-in to provide the better performance as running in native code.

WasmEdge plug-ins can provide developers and users with a versatile, customizable, high-performance, and secure way to extend the functionality of the WasmEdge runtime. WasmEdge plug-ins can also improve scalability and ease of use, making it easier to build and deploy complex applications on edge devices.

## Loadable Plug-in

Loadable plug-ins are standalone shared libraries (`.so`/`.dylib`/`.dll` files) that the WasmEdge runtime environment can load at runtime. These plug-ins can provide additional functionality to the WasmEdge runtime environment, such as new modules that can be imported by WebAssembly modules.

### Creating Loadable Plug-in

To create a loadable plug-in for WasmEdge, developers can use the WasmEdge Plug-in SDK, which provides a set of Rust, C, and C++ APIs for creating and registering plug-ins. The SDK also includes [example code](https://github.com/WasmEdge/WasmEdge/tree/master/examples/plugin/get-string) that demonstrates creating a simple plug-in that returns a string. By following the provided examples and leveraging the SDK's APIs, developers can quickly build custom plug-ins tailored to their specific needs.

### Loading plug-in from paths

To use the loadable plug-ins, developers need to load them from specific paths into the WasmEdge runtime environment. The loading process involves the following steps:

- Loadable plug-ins can be loaded from default paths by calling the `WasmEdge_PluginLoadWithDefaultPaths()` API. The default paths include:

  - The path specified in the environment variable `WASMEDGE_PLUGIN_PATH`.
  - The `./plugin/` directory relative to the WasmEdge installation path.
  - The `./wasmedge/` directory is located under the library path if WasmEdge is installed in a system directory such as `/usr` and `/usr/local`.

- If the plug-ins are located in a specific path or directory, developers can use the `WasmEdge_PluginLoadFromPath(""PATH_TO_PLUGIN/plug-in.so"")` API to load the plug-ins from that particular location.

The WasmEdge runtime environment will search for the loadable plug-ins in the specified paths and load them if found.

The following flowchart shows the process of loading loadable plug-ins into the WasmEdge runtime environment from specific paths:

```mermaid
graph LR
    A((Start)) --> B(Loadable Plug-ins)
    B --> C{Load Plug-ins}
    C --> D[Load from Default Paths]
    C --> E[Load from Specific Path]
    C --> F[Load from Specific Directory]
    D --> G{Is Plug-in Found?}
    E --> G
    F --> G
    G -- Yes --> H(Load Plug-in)
    H --> I(End)
    G -- No --> I
```

The flowchart shows loading loadable plug-ins into the WasmEdge runtime environment. The process involves searching for plug-ins in default paths, a specific path, or a specific directory. If a plug-in is found in any of these locations, it is loaded into the runtime environment. The flowchart enables developers to quickly load plug-ins and extend the capabilities of the WasmEdge runtime.

By following this flowchart, developers can effectively load loadable plug-ins into the WasmEdge runtime environment from specific paths, expanding the runtime's functionality according to their requirements.

## WasmEdge Currently Released Plug-ins

Users can install the [WasmEdge official released plug-ins](../../start/wasmedge/extensions/plugins.md) from the installer, or build them from source.
","**Summary**

The provided code is a documentation for the WasmEdge Plug-in System. It explains how to create and use plug-ins for the WasmEdge runtime, which provides a flexible and dynamic extension of host functions.

**Key Components**

1. **WasmEdge Plug-in Architecture**: The WasmEdge runtime provides a plug-in architecture that allows developers to load and register host functions from plug-in shared libraries.
2. **Loadable Plug-in**: Loadable plug-ins are standalone shared libraries (`.so`/`.dylib`/`.dll` files) that the WasmEdge runtime environment can load at runtime, providing additional functionality to the runtime environment.
3. **Creating Loadable Plug-in**: Developers can use the WasmEdge Plug-in SDK, which provides APIs for creating and registering plug-ins, to create a loadable plug-in.
4. **Loading plug-in from paths**: The loading process involves searching for plug-ins in default paths or specific paths, and loading them if found.

**Benefits**

1. **Customization**: WasmEdge plug-ins can be customized to suit the specific needs of a project.
2. **Performance**: WasmEdge plug-ins are designed to work seamlessly with the core runtime, minimizing overhead and maximizing performance.
3. **Ease of use**: WasmEdge plug-ins are easy to use and integrate with the WasmEdge runtime.
4. **Scalability**: Developers can compile their compute-intensive functions into host functions and package them into a plug-in to provide better performance as running in native code.

**Potential Issues or Areas for Improvement**

1. **Documentation**: While the documentation is detailed, it may be overwhelming for new users who are not familiar with WasmEdge.
2. **Error handling**: There is no clear guidance on how to handle errors that may occur during plug-in loading and execution.
3. **Plug-in compatibility**: The documentation does not provide information on ensuring plug-ins are compatible with the WasmEdge runtime environment.
4. **Security**: There is no mention of security considerations when developing and deploying plug-ins.

Overall, the code provides a comprehensive overview of the WasmEdge Plug-in System, including its architecture, benefits, and usage guidelines. However, there are areas that can be improved for better user experience and to ensure the system's stability and security."
docs/develop/deploy/kubernetes/kubernetes-cri-o.md,"---
sidebar_position: 2
---

# Kubernetes + CRI-O + crun

## Quick start

The [WasmEdge Containers Example](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on Kubernetes + CRI-O + crun.

- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio.yml)
- WebAssembly-based HTTP service [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio-server.yml)

In the rest of this section, we will explain the steps in detail. We assume you have already [installed and configured CRI-O](../../deploy/oci-runtime/crun.md) to work with WasmEdge container images.

## Install and start Kubernetes

Run the following commands from a terminal window. It sets up Kubernetes for local development.

```bash
# Install go
$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz
$ sudo rm -rf /usr/local/go
sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz
source /home/${USER}/.profile

# Clone k8s
git clone https://github.com/kubernetes/kubernetes.git
cd kubernetes
git checkout v1.22.2

# Install etcd with hack script in k8s
sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/install-etcd.sh
export PATH=""/home/${USER}/kubernetes/third_party/etcd:${PATH}""
sudo cp third_party/etcd/etcd* /usr/local/bin/

# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl

# Build and run k8s with CRI-O
sudo apt-get install -y build-essential
sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/local-up-cluster.sh

... ...
Local Kubernetes cluster is running. Press Ctrl-C to shut it down.
```

Do NOT close your terminal window. Kubernetes is running!

## Run WebAssembly container images in Kubernetes

Finally, we can run WebAssembly programs in Kubernetes as containers in pods. In this section, we will start from **another terminal window** and start using the cluster.

```bash
export KUBERNETES_PROVIDER=local

sudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt
sudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt
sudo cluster/kubectl.sh config set-context local --cluster=local --user=myself
sudo cluster/kubectl.sh config use-context local
sudo cluster/kubectl.sh
```

Let's check the status to make sure that the cluster is running.

```bash
$ sudo cluster/kubectl.sh cluster-info

# Expected output
Cluster ""local"" set.
User ""myself"" set.
Context ""local"" created.
Switched to context ""local"".
Kubernetes control plane is running at https://localhost:6443
CoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
```

### A simple WebAssembly app

[A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md) explains how to compile, package, and publish a simple WebAssembly WASI program as a container image to Docker hub. Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.

```bash
sudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" /wasi_example_main.wasm 50000000
```

The output from the containerized application is printed into the console.

```bash
Random number: 401583443
Random bytes: [192, 226, 162, 92, 129, 17, 186, 164, 239, 84, 98, 255, 209, 79, 51, 227, 103, 83, 253, 31, 78, 239, 33, 218, 68, 208, 91, 56, 37, 200, 32, 12, 106, 101, 241, 78, 161, 16, 240, 158, 42, 24, 29, 121, 78, 19, 157, 185, 32, 162, 95, 214, 175, 46, 170, 100, 212, 33, 27, 190, 139, 121, 121, 222, 230, 125, 251, 21, 210, 246, 215, 127, 176, 224, 38, 184, 201, 74, 76, 133, 233, 129, 48, 239, 106, 164, 190, 29, 118, 71, 79, 203, 92, 71, 68, 96, 33, 240, 228, 62, 45, 196, 149, 21, 23, 143, 169, 163, 136, 206, 214, 244, 26, 194, 25, 101, 8, 236, 247, 5, 164, 117, 40, 220, 52, 217, 92, 179]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod ""wasi-demo-2"" deleted
```

### A WebAssembly-based HTTP service

[A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md) explains how to compile, package, and publish a simple WebAssembly HTTP service application as a container image to Docker hub. Since the HTTP service container requires networking support provided by Kubernetes, we will use a [k8s-http_server.yaml](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/http_server/k8s-http_server.yaml) file to specify its exact configuration.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: http-server
  namespace: default
  annotations:
    module.wasm.image/variant: compat-smart
spec:
  hostNetwork: true
  containers:
    - name: http-server
      image: wasmedge/example-wasi-http:latest
      command: ['/http_server.wasm']
      ports:
        - containerPort: 1234
          protocol: TCP
      livenessProbe:
        tcpSocket:
          port: 1234
        initialDelaySeconds: 3
        periodSeconds: 30
```

Run the WebAssembly-based image from Docker Hub using the above `k8s-http_server.yaml` file in the Kubernetes cluster as follows.

```bash
sudo ./kubernetes/cluster/kubectl.sh apply -f k8s-http_server.yaml
```

The following command shows the running container applications and their IP addresses. Since we are using `hostNetwork` in the yaml configuration, the HTTP server image is running on the local network with IP address `127.0.0.1`.

```bash
$ sudo cluster/kubectl.sh get pod --all-namespaces -o wide

NAMESPACE     NAME                       READY   STATUS             RESTARTS      AGE   IP          NODE        NOMINATED NODE   READINESS GATES
default       http-server                1/1     Running            1 (26s ago)     60s     127.0.0.1   127.0.0.1   <none>           <none>
```

Now, you can use the `curl` command to access the HTTP service.

```bash
$ curl -d ""name=WasmEdge"" -X POST http://127.0.0.1:1234
echo: name=WasmEdge
```

That's it!
","**Summary**

The provided code is a Kubernetes setup for running WebAssembly containers using CRI-O and crun. It guides users through installing and configuring Kubernetes, setting up a local development environment, and running WebAssembly container images.

**Key Components**

1. **Kubernetes Setup**: The code sets up a Kubernetes cluster using the `hack/local-up-cluster.sh` script.
2. **CRI-O Configuration**: It configures CRI-O to work with WasmEdge container images.
3. **WebAssembly Container Images**: It provides instructions for running WebAssembly container images from Docker Hub in the Kubernetes cluster.

**Potential Issues**

1. **Deprecation of `hack/local-up-cluster.sh` script**: The `hack/local-up-cluster.sh` script is deprecated and may not work with newer versions of Kubernetes.
2. **Outdated Docker Images**: The code uses outdated Docker images, which may not be compatible with the latest versions of Kubernetes and CRI-O.
3. **Security Risks**: Running containers with `hostNetwork` enabled can pose security risks if not properly configured.

**Improvement Suggestions**

1. **Update to newer Kubernetes version**: Update the code to use a newer version of Kubernetes that supports the latest features and bug fixes.
2. **Use more secure container configurations**: Use more secure container configurations, such as using pod-level network policies instead of `hostNetwork`.
3. **Test with latest Docker images**: Test the code with the latest Docker images to ensure compatibility and security."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-cri-o.md,"---
sidebar_position: 2
---

# Kubernetes + CRI-O + crun

## Quick start

The [WasmEdge Containers Example](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on Kubernetes + CRI-O + crun.

- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio.yml)
- WebAssembly-based HTTP service [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio-server.yml)

In the rest of this section, we will explain the steps in detail. We assume you have already [installed and configured CRI-O](../../deploy/oci-runtime/crun.md) to work with WasmEdge container images.

## Install and start Kubernetes

Run the following commands from a terminal window. It sets up Kubernetes for local development.

```bash
# Install go
$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz
$ sudo rm -rf /usr/local/go
sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz
source /home/${USER}/.profile

# Clone k8s
git clone https://github.com/kubernetes/kubernetes.git
cd kubernetes
git checkout v1.22.2

# Install etcd with hack script in k8s
sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/install-etcd.sh
export PATH=""/home/${USER}/kubernetes/third_party/etcd:${PATH}""
sudo cp third_party/etcd/etcd* /usr/local/bin/

# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl

# Build and run k8s with CRI-O
sudo apt-get install -y build-essential
sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/local-up-cluster.sh

... ...
Local Kubernetes cluster is running. Press Ctrl-C to shut it down.
```

Do NOT close your terminal window. Kubernetes is running!

## Run WebAssembly container images in Kubernetes

Finally, we can run WebAssembly programs in Kubernetes as containers in pods. In this section, we will start from **another terminal window** and start using the cluster.

```bash
export KUBERNETES_PROVIDER=local

sudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt
sudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt
sudo cluster/kubectl.sh config set-context local --cluster=local --user=myself
sudo cluster/kubectl.sh config use-context local
sudo cluster/kubectl.sh
```

Let's check the status to make sure that the cluster is running.

```bash
$ sudo cluster/kubectl.sh cluster-info

# Expected output
Cluster ""local"" set.
User ""myself"" set.
Context ""local"" created.
Switched to context ""local"".
Kubernetes control plane is running at https://localhost:6443
CoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
```

### A simple WebAssembly app

[A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md) explains how to compile, package, and publish a simple WebAssembly WASI program as a container image to Docker hub. Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.

```bash
sudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" /wasi_example_main.wasm 50000000
```

The output from the containerized application is printed into the console.

```bash
Random number: 401583443
Random bytes: [192, 226, 162, 92, 129, 17, 186, 164, 239, 84, 98, 255, 209, 79, 51, 227, 103, 83, 253, 31, 78, 239, 33, 218, 68, 208, 91, 56, 37, 200, 32, 12, 106, 101, 241, 78, 161, 16, 240, 158, 42, 24, 29, 121, 78, 19, 157, 185, 32, 162, 95, 214, 175, 46, 170, 100, 212, 33, 27, 190, 139, 121, 121, 222, 230, 125, 251, 21, 210, 246, 215, 127, 176, 224, 38, 184, 201, 74, 76, 133, 233, 129, 48, 239, 106, 164, 190, 29, 118, 71, 79, 203, 92, 71, 68, 96, 33, 240, 228, 62, 45, 196, 149, 21, 23, 143, 169, 163, 136, 206, 214, 244, 26, 194, 25, 101, 8, 236, 247, 5, 164, 117, 40, 220, 52, 217, 92, 179]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod ""wasi-demo-2"" deleted
```

### A WebAssembly-based HTTP service

[A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md) explains how to compile, package, and publish a simple WebAssembly HTTP service application as a container image to Docker hub. Since the HTTP service container requires networking support provided by Kubernetes, we will use a [k8s-http_server.yaml](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/http_server/k8s-http_server.yaml) file to specify its exact configuration.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: http-server
  namespace: default
  annotations:
    module.wasm.image/variant: compat-smart
spec:
  hostNetwork: true
  containers:
    - name: http-server
      image: wasmedge/example-wasi-http:latest
      command: ['/http_server.wasm']
      ports:
        - containerPort: 1234
          protocol: TCP
      livenessProbe:
        tcpSocket:
          port: 1234
        initialDelaySeconds: 3
        periodSeconds: 30
```

Run the WebAssembly-based image from Docker Hub using the above `k8s-http_server.yaml` file in the Kubernetes cluster as follows.

```bash
sudo ./kubernetes/cluster/kubectl.sh apply -f k8s-http_server.yaml
```

The following command shows the running container applications and their IP addresses. Since we are using `hostNetwork` in the yaml configuration, the HTTP server image is running on the local network with IP address `127.0.0.1`.

```bash
$ sudo cluster/kubectl.sh get pod --all-namespaces -o wide

NAMESPACE     NAME                       READY   STATUS             RESTARTS      AGE   IP          NODE        NOMINATED NODE   READINESS GATES
default       http-server                1/1     Running            1 (26s ago)     60s     127.0.0.1   127.0.0.1   <none>           <none>
```

Now, you can use the `curl` command to access the HTTP service.

```bash
$ curl -d ""name=WasmEdge"" -X POST http://127.0.0.1:1234
echo: name=WasmEdge
```

That's it!
","**Summary**

The provided code is a tutorial on how to deploy and run WebAssembly (Wasm) programs in a Kubernetes cluster using CRI-O as the container runtime. The tutorial covers the installation and configuration of Kubernetes, running Wasm applications as containers in pods, and accessing the HTTP service provided by one of the examples.

**Key Components**

1. **Kubernetes**: A container orchestration system that automates the deployment, scaling, and management of containerized applications.
2. **CRI-O**: A container runtime that allows Kubernetes to manage containers.
3. **WasmEdge**: A WebAssembly runtime that executes Wasm programs in a Kubernetes cluster.

**Steps**

1. Install and configure CRI-O on your system.
2. Set up a Kubernetes cluster using `local-up-cluster.sh` script.
3. Clone the Kubernetes repository and checkout a specific version (e.g., v1.22.2).
4. Build and run a Kubernetes cluster with CRI-O using `hack/local-up-cluster.sh`.
5. Run a WebAssembly program as a container in a pod using `kubectl run` command.
6. Access the HTTP service provided by one of the examples.

**Potential Issues and Areas for Improvement**

1. **CRI-O version compatibility**: Make sure to use a compatible version of CRI-O with your Kubernetes cluster.
2. **Kubernetes configuration**: Be cautious when modifying Kubernetes configuration files (e.g., `k8s-http_server.yaml`).
3. **WebAssembly program execution**: Ensure that the WebAssembly program is properly compiled and linked before running it as a container in the pod.
4. **Networking and security**: Consider the networking requirements of your WebAssembly application and ensure proper security configurations are in place.

**Additional Resources**

For more information on Kubernetes, CRI-O, and WebAssembly, refer to the following resources:

* Kubernetes documentation: <https://kubernetes.io/docs/home/>
* CRI-O documentation: <https://cri-o.io/documentation/latest/>
* WebAssembly documentation: <https://webassembly.org/>"
i18n/zh/docusaurus-plugin-content-docs/current/contribute/contribute.md,"---
sidebar_position: 8
---

# Contributing Steps

## Setup Development Environment

The WasmEdge is developed on Ubuntu 20.04 to take advantage of advanced LLVM features for the AOT compiler. The WasmEdge team also builds and releases statically linked WasmEdge binaries for older Linux distributions.

Our development environment requires `libLLVM-12` and `>=GLIBCXX_3.4.26`.

If you use an operating system older than Ubuntu 20.04, please use our [special docker image] to build WasmEdge. If you are looking for the pre-built binaries for the older operating system, we also provide several pre-built binaries based on the `manylinux2014` distribution.

To build WasmEdge from the source, please refer to: [Build WasmEdge from source](/category/build-wasmedge-from-source).

## Contribution Workflow

Pull requests are always welcome, even if they only contain minor fixes like typos or a few lines of code. If there will be a significant effort, please document it as an issue and get a discussion going before starting to work on it.

Please submit a pull request broken down into small changes bit by bit. A pull request consisting of many features and code changes may take a lot of work to review. It is recommended to submit pull requests incrementally.

<!-- prettier-ignore -->
:::note
If you split your pull request into small changes, please ensure any changes that go to the main branch will not break anything. Otherwise, it can only be merged once this feature is complete.
:::

### Fork and Clone the Repository

Fork [the WasmEdge repository](https://github.com/WasmEdge/WasmEdge) and clone the code to your local workspace

### Branches and Commits

Changes should be made on your own fork in a new branch. Pull requests should be rebased on the top of the main branch.

The WasmEdge project adopts [DCO](https://www.secondstate.io/articles/dco/) to manage all contributions. Please ensure you add your `sign-off-statement` through the `-s` or `--signoff` flag or the GitHub Web UI before committing the pull request message.

### Develop, Build, and Test

Write code on the new branch in your fork, and [build from source code](/category/build-wasmedge-from-source) with the option `-DWASMEDGE_BUILD_TESTS=ON`.

Then you can use these tests to verify the correctness of WasmEdge binaries.

```bash
cd <path/to/wasmedge/build_folder>
LD_LIBRARY_PATH=$(pwd)/lib/api ctest
```

### Push and Create A Pull Request

When ready for review, push your branch to your fork repository on github.

Then visit your fork at <https://github.com/$user/WasmEdge> and click the `Compare & Pull Request` button next to your branch to create a new pull request. The pull request description should refer to all the issues it addresses. Remember to reference issues (such as Closes #XXX and Fixes #XXX) in the comment so that the issues can be closed when the PR is merged. After creating a pull request, please check that the CI passes with your code changes.

Once your pull request has been opened, it will be assigned to one or more reviewers. Those reviewers will do a thorough code review, looking for correctness, bugs, opportunities for improvement, documentation and comments, and coding style.

Commit changes made in response to review comments to the same branch on your fork.

## Reporting issues

It is a great way to contribute to WasmEdge by reporting an issue. Well-written and complete bug reports are always welcome! Please open an issue on GitHub.

Before opening any issue, please look up the existing [issues](https://github.com/WasmEdge/WasmEdge/issues) to avoid submitting a duplication. If you find a match, you can ""subscribe"" to it to get notified of updates. If you have additional helpful information about the issue, please leave a comment.

When reporting issues, always include:

- Version of your system
- Configuration files of WasmEdge

Because the issues are open to the public, when submitting the log and configuration files, be sure to remove any sensitive information, e.g. user name, password, IP address, and company name. You can replace those parts with ""REDACTED"" or other strings like ""\*\*\*\*"". Be sure to include the steps to reproduce the problem if applicable. It can help us understand and fix your issue faster.

## Documenting

Update the documentation if you are creating or changing features. Good documentation is as necessary as the code itself. Documents are written with Markdown. See [Writing on GitHub](https://help.github.com/categories/writing-on-github/) for more details.

## Design new features

You can propose new designs for existing WasmEdge features. You can also design new features; please submit a proposal via the GitHub issues.

WasmEdge maintainers will review this proposal as soon as possible to ensure the overall architecture is consistent and to avoid duplicated work in the roadmap.
","**Summary**

The code provided is a contribution guide for the WasmEdge project. It outlines the steps and best practices for contributing to the project, including setting up the development environment, contribution workflow, and guidelines for reporting issues.

**Key Components**

1. **Development Environment**: The guide specifies that the development environment requires `libLLVM-12` and `>=GLIBCXX_3.4.26`. If using an operating system older than Ubuntu 20.04, users can use a special Docker image or pre-built binaries.
2. **Contribution Workflow**: Contributions are welcome in the form of pull requests, which should be broken down into small changes. Reviewers will ensure that the code is correct, bug-free, and follows coding standards.
3. **Reporting Issues**: Reporting issues is encouraged through the GitHub issue tracker. Users should include version information, configuration files, and steps to reproduce the problem.
4. **Documentation**: Updating documentation is crucial when creating or changing features.

**Potential Issues**

1. **Inconsistent guidelines**: The guide mentions different guidelines for setting up the development environment depending on the operating system used.
2. **Complexity of contribution workflow**: The contribution workflow may be overwhelming for new contributors due to its complexity.
3. **Lack of clear guidelines for design proposals**: The guide only mentions that maintainers will review design proposals but does not provide more details.

**Improvement Suggestions**

1. **Simplify the contribution workflow**: Consider breaking down the contribution process into smaller, more manageable steps.
2. **Clarify guidelines for setting up development environment**: Provide a single set of guidelines for all operating systems or include clear instructions for each specific case.
3. **Add more details on design proposals**: Include information on how to submit a proposal, what type of feedback to expect from maintainers, and any relevant deadlines."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/my_sql_driver.md,"---
sidebar_position: 1
---

# MySQL driver

The database connection is necessary for today's enterprise development. WasmEdge provides a MySQL driver for Rust developers, enabling developers to build database applications in Rust and then running in WasmEdge.

<!-- prettier-ignore -->
:::note
Before we start, [you need to have Rust and WasmEdge installed](../setup.md).
Make sure that you read the [special notes on networking apps](../setup#special-notes) especially if you are compiling Rust programs on a Mac.
:::

## Run the example

The [wasmedge-db-example/mysql_async](https://github.com/WasmEdge/wasmedge-db-examples/tree/main/mysql_async) is a MySQL connector example written in Rust.

```bash
git clone https://github.com/WasmEdge/wasmedge-db-examples
cd wasmedge-db-examples/mysql_async

# Compile the rust code into WASM
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release

# Execute MySQL statements against a MySQL database at mysql://user:passwd@127.0.0.1:3306
wasmedge --env ""DATABASE_URL=mysql://user:passwd@127.0.0.1:3306/mysql"" target/wasm32-wasi/release/crud.wasm
```

<!-- prettier-ignore -->
:::note
Since we have TLS enabled by default in this example, you will need the [wasi-sdk version of clang](../setup#tls-on-macos) for compiling it on MacOS.
:::

To use TLS, you will need to turn on the `default-rustls` feature on the `mysql_async` crate in `Cargo.toml`.
Then, run the application as follows.

```toml
# Execute MySQL statements against an AWS RDS database that requires TLS
wasmedge --env ""DATABASE_SSL=1"" --env ""DATABASE_URL=mysql://user:passwd@mydb.123456789012.us-east-1.rds.amazonaws.com:3306/mysql"" crud.wasm
```

## Configuration

In order to compile the `mysql_async` and `tokio` crates, we will need to apply two patches to add
WasmEdge-specific socket APIs to those crates. The following example shows that the TLS connection is enabled.

```
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }
socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }

[dependencies]
mysql_async = { version = ""0.34"", default-features=false, features = [ ""default-rustls"" ], git=""https://github.com/blackbeam/mysql_async.git"" }
zstd-sys = ""=2.0.9""
tokio = { version = ""1"", features = [ ""io-util"", ""fs"", ""net"", ""time"", ""rt"", ""macros""] }
```

## Code example

The following code shows how to connect to a MySQL database server, and then insert, update, and delete records using SQL
statements.

Connect to a MySQL database.

```
    // Below we create a customized connection pool
    let opts = Opts::from_url(&*get_url()).unwrap();
    let mut builder = OptsBuilder::from_opts(opts);
    if std::env::var(""DATABASE_SSL"").is_ok() {
        builder = builder.ssl_opts(SslOpts::default());
    }
    // The connection pool will have a min of 5 and max of 10 connections.
    let constraints = PoolConstraints::new(5, 10).unwrap();
    let pool_opts = PoolOpts::default().with_constraints(constraints);

    let pool = Pool::new(builder.pool_opts(pool_opts));
    let mut conn = pool.get_conn().await.unwrap();
```

Create a table on the connected database.

```
    // create table if no tables exist
    let result = r""SHOW TABLES LIKE 'orders';""
        .with(())
        .map(&mut conn, |s: String| String::from(s))
        .await?;

    if result.len() == 0 {
        // table doesn't exist, create a new one
        r""CREATE TABLE orders (order_id INT, production_id INT, quantity INT, amount FLOAT, shipping FLOAT, tax FLOAT, shipping_address VARCHAR(20));"".ignore(&mut conn).await?;
        println!(""create new table"");
    } else {
        // delete all data from the table.
        println!(""delete all from orders"");
        r""DELETE FROM orders;"".ignore(&mut conn).await?;
    }
```

Insert some records into the MySQL database using SQL.

```
    let orders = vec![
        Order::new(1, 12, 2, 56.0, 15.0, 2.0, String::from(""Mataderos 2312"")),
        Order::new(2, 15, 3, 256.0, 30.0, 16.0, String::from(""1234 NW Bobcat"")),
        Order::new(3, 11, 5, 536.0, 50.0, 24.0, String::from(""20 Havelock"")),
        Order::new(4, 8, 8, 126.0, 20.0, 12.0, String::from(""224 Pandan Loop"")),
        Order::new(5, 24, 1, 46.0, 10.0, 2.0, String::from(""No.10 Jalan Besar"")),
    ];

    r""INSERT INTO orders (order_id, production_id, quantity, amount, shipping, tax, shipping_address)
      VALUES (:order_id, :production_id, :quantity, :amount, :shipping, :tax, :shipping_address)""
        .with(orders.iter().map(|order| {
            params! {
                ""order_id"" => order.order_id,
                ""production_id"" => order.production_id,
                ""quantity"" => order.quantity,
                ""amount"" => order.amount,
                ""shipping"" => order.shipping,
                ""tax"" => order.tax,
                ""shipping_address"" => &order.shipping_address,
            }
        }))
        .batch(&mut conn)
        .await?;
```

Query the database.

```
    // query data
    let loaded_orders = ""SELECT * FROM orders""
        .with(())
        .map(
            &mut conn,
            |(order_id, production_id, quantity, amount, shipping, tax, shipping_address)| {
                Order::new(
                    order_id,
                    production_id,
                    quantity,
                    amount,
                    shipping,
                    tax,
                    shipping_address,
                )
            },
        )
        .await?;
    dbg!(loaded_orders.len());
    dbg!(loaded_orders);
```

Delete some records from the database.

```
    // // delete some data
    r""DELETE FROM orders WHERE order_id=4;""
        .ignore(&mut conn)
        .await?;

    // query data
    let loaded_orders = ""SELECT * FROM orders""
        .with(())
        .map(
            &mut conn,
            |(order_id, production_id, quantity, amount, shipping, tax, shipping_address)| {
                Order::new(
                    order_id,
                    production_id,
                    quantity,
                    amount,
                    shipping,
                    tax,
                    shipping_address,
                )
            },
        )
        .await?;
    dbg!(loaded_orders.len());
    dbg!(loaded_orders);
```

Update records in the MySQL database.

```
    // // update some data
    r""UPDATE orders
    SET shipping_address = '8366 Elizabeth St.'
    WHERE order_id = 2;""
        .ignore(&mut conn)
        .await?;
    // query data
    let loaded_orders = ""SELECT * FROM orders""
        .with(())
        .map(
            &mut conn,
            |(order_id, production_id, quantity, amount, shipping, tax, shipping_address)| {
                Order::new(
                    order_id,
                    production_id,
                    quantity,
                    amount,
                    shipping,
                    tax,
                    shipping_address,
                )
            },
        )
        .await?;
    dbg!(loaded_orders.len());
    dbg!(loaded_orders);
```

Close the database connection.

```
    drop(conn);
    pool.disconnect().await.unwrap();
```

","**Summary**

The provided code is an example of a MySQL driver for Rust, enabling developers to build database applications in Rust and run them on the WasmEdge platform. The code provides instructions on how to connect to a MySQL database, create tables, insert records, query data, update records, and delete records.

**Key Components**

1. **MySQL Driver**: The code uses the `mysql_async` crate, which is a MySQL driver for Rust that supports asynchronous connections.
2. **WasmEdge**: The code runs on the WasmEdge platform, which allows developers to run Rust applications in WebAssembly (WASM).
3. **TLS Support**: The code includes TLS support using the `default-rustls` feature of the `mysql_async` crate.

**Configuration**

The code requires configuration changes to apply two patches to add WasmEdge-specific socket APIs to the `tokio` and `socket2` crates.

**Code Example**

The code provides a detailed example of how to connect to a MySQL database, create tables, insert records, query data, update records, and delete records using SQL statements. The example uses the `Order` struct to represent a record in the database.

**Potential Issues**

1. **TLS Configuration**: The code assumes that TLS is enabled by default, but this may not be the case for all environments.
2. **Socket API Patches**: The code requires patches to apply WasmEdge-specific socket APIs to the `tokio` and `socket2` crates, which may cause issues if not properly configured.

**Areas for Improvement**

1. **Error Handling**: The code could benefit from improved error handling, such as using a more robust error handling mechanism.
2. **Code Organization**: The code is organized into multiple sections, but it would be beneficial to reorganize the code into separate modules or files to improve readability and maintainability."
docs/develop/rust/database/my_sql_driver.md,"---
sidebar_position: 1
---

# MySQL driver

The database connection is necessary for today's enterprise development. WasmEdge provides a MySQL driver for Rust developers, enabling developers to build database applications in Rust and then running in WasmEdge.

<!-- prettier-ignore -->
:::note
Before we start, [you need to have Rust and WasmEdge installed](../setup.md).
Make sure that you read the [special notes on networking apps](../setup#special-notes-for-networking-apps) especially if you are compiling Rust programs on a Mac.
:::

## Run the example

The [wasmedge-db-example/mysql_async](https://github.com/WasmEdge/wasmedge-db-examples/tree/main/mysql_async) is a MySQL connector example written in Rust.

```bash
git clone https://github.com/WasmEdge/wasmedge-db-examples
cd wasmedge-db-examples/mysql_async

# Compile the rust code into WASM
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release

# Execute MySQL statements against a MySQL database at mysql://user:passwd@127.0.0.1:3306
wasmedge --env ""DATABASE_URL=mysql://user:passwd@127.0.0.1:3306/mysql"" target/wasm32-wasi/release/crud.wasm
```

<!-- prettier-ignore -->
:::note
Since we have TLS enabled by default in this example, you will need the [wasi-sdk version of clang](../setup#tls-on-macos) for compiling it on MacOS.
:::

To use TLS, you will need to turn on the `default-rustls` feature on the `mysql_async` crate in `Cargo.toml`.
Then, run the application as follows.

```toml
# Execute MySQL statements against an AWS RDS database that requires TLS
wasmedge --env ""DATABASE_SSL=1"" --env ""DATABASE_URL=mysql://user:passwd@mydb.123456789012.us-east-1.rds.amazonaws.com:3306/mysql"" crud.wasm
```

## Configuration

In order to compile the `mysql_async` and `tokio` crates, we will need to apply two patches to add
WasmEdge-specific socket APIs to those crates. The following example shows that the TLS connection is enabled.

```toml
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }
socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }

[dependencies]
mysql_async = { version = ""0.34"", default-features=false, features = [ ""default-rustls"" ], git=""https://github.com/blackbeam/mysql_async.git"" }
zstd-sys = ""=2.0.9""
tokio = { version = ""1"", features = [ ""io-util"", ""fs"", ""net"", ""time"", ""rt"", ""macros""] }
```

## Code example

The following code shows how to connect to a MySQL database server, and then insert, update, and delete records using SQL
statements.

Connect to a MySQL database.

```rust
    // Below we create a customized connection pool
    let opts = Opts::from_url(&*get_url()).unwrap();
    let mut builder = OptsBuilder::from_opts(opts);
    if std::env::var(""DATABASE_SSL"").is_ok() {
        builder = builder.ssl_opts(SslOpts::default());
    }
    // The connection pool will have a min of 5 and max of 10 connections.
    let constraints = PoolConstraints::new(5, 10).unwrap();
    let pool_opts = PoolOpts::default().with_constraints(constraints);

    let pool = Pool::new(builder.pool_opts(pool_opts));
    let mut conn = pool.get_conn().await.unwrap();
```

Create a table on the connected database.

```rust
    // create table if no tables exist
    let result = r""SHOW TABLES LIKE 'orders';""
        .with(())
        .map(&mut conn, |s: String| String::from(s))
        .await?;

    if result.len() == 0 {
        // table doesn't exist, create a new one
        r""CREATE TABLE orders (order_id INT, production_id INT, quantity INT, amount FLOAT, shipping FLOAT, tax FLOAT, shipping_address VARCHAR(20));"".ignore(&mut conn).await?;
        println!(""create new table"");
    } else {
        // delete all data from the table.
        println!(""delete all from orders"");
        r""DELETE FROM orders;"".ignore(&mut conn).await?;
    }
```

Insert some records into the MySQL database using SQL.

```rust
    let orders = vec![
        Order::new(1, 12, 2, 56.0, 15.0, 2.0, String::from(""Mataderos 2312"")),
        Order::new(2, 15, 3, 256.0, 30.0, 16.0, String::from(""1234 NW Bobcat"")),
        Order::new(3, 11, 5, 536.0, 50.0, 24.0, String::from(""20 Havelock"")),
        Order::new(4, 8, 8, 126.0, 20.0, 12.0, String::from(""224 Pandan Loop"")),
        Order::new(5, 24, 1, 46.0, 10.0, 2.0, String::from(""No.10 Jalan Besar"")),
    ];

    r""INSERT INTO orders (order_id, production_id, quantity, amount, shipping, tax, shipping_address)
      VALUES (:order_id, :production_id, :quantity, :amount, :shipping, :tax, :shipping_address)""
        .with(orders.iter().map(|order| {
            params! {
                ""order_id"" => order.order_id,
                ""production_id"" => order.production_id,
                ""quantity"" => order.quantity,
                ""amount"" => order.amount,
                ""shipping"" => order.shipping,
                ""tax"" => order.tax,
                ""shipping_address"" => &order.shipping_address,
            }
        }))
        .batch(&mut conn)
        .await?;
```

Query the database.

```rust
    // query data
    let loaded_orders = ""SELECT * FROM orders""
        .with(())
        .map(
            &mut conn,
            |(order_id, production_id, quantity, amount, shipping, tax, shipping_address)| {
                Order::new(
                    order_id,
                    production_id,
                    quantity,
                    amount,
                    shipping,
                    tax,
                    shipping_address,
                )
            },
        )
        .await?;
    dbg!(loaded_orders.len());
    dbg!(loaded_orders);
```

Delete some records from the database.

```rust
    // delete some data
    r""DELETE FROM orders WHERE order_id=4;""
        .ignore(&mut conn)
        .await?;

    // query data
    let loaded_orders = ""SELECT * FROM orders""
        .with(())
        .map(
            &mut conn,
            |(order_id, production_id, quantity, amount, shipping, tax, shipping_address)| {
                Order::new(
                    order_id,
                    production_id,
                    quantity,
                    amount,
                    shipping,
                    tax,
                    shipping_address,
                )
            },
        )
        .await?;
    dbg!(loaded_orders.len());
    dbg!(loaded_orders);
```

Update records in the MySQL database.

```rust
    // update some data
    r""UPDATE orders
    SET shipping_address = '8366 Elizabeth St.'
    WHERE order_id = 2;""
        .ignore(&mut conn)
        .await?;
    // query data
    let loaded_orders = ""SELECT * FROM orders""
        .with(())
        .map(
            &mut conn,
            |(order_id, production_id, quantity, amount, shipping, tax, shipping_address)| {
                Order::new(
                    order_id,
                    production_id,
                    quantity,
                    amount,
                    shipping,
                    tax,
                    shipping_address,
                )
            },
        )
        .await?;
    dbg!(loaded_orders.len());
    dbg!(loaded_orders);
```

Close the database connection.

```rust
    drop(conn);
    pool.disconnect().await.unwrap();
```
","**Summary**

The provided code is an example of a MySQL driver written in Rust that can be used to connect to a MySQL database server and perform various operations such as inserting, updating, and deleting records. The code uses the `mysql_async` crate and the `tokio` crate for asynchronous programming.

**Key Components**

1. **Database Connection**: The code establishes a connection to a MySQL database server using the `Opts` struct from the `mysql_async` crate.
2. **SQL Operations**: The code performs various SQL operations such as creating a table, inserting records, querying data, deleting records, and updating records using the `r` macro from the `mysql_async` crate.
3. **Connection Pooling**: The code uses connection pooling to manage multiple connections to the database server, which improves performance and reduces overhead.

**Potential Issues**

1. **Error Handling**: The code does not handle errors properly in some places, which can lead to unexpected behavior or crashes.
2. **Resource Management**: The code does not properly close resources such as database connections, which can lead to resource leaks.
3. **Security**: The code uses hardcoded database credentials, which is a security risk.

**Areas for Improvement**

1. **Code Organization**: The code can be organized into separate modules or functions to improve maintainability and reusability.
2. **Error Handling**: Implement proper error handling using techniques such as try-catch blocks or error types to handle unexpected errors.
3. **Security**: Use environment variables or secure storage to store database credentials instead of hardcoded values.

**Best Practices**

1. **Follow the Principle of Least Surprise**: The code should be designed to follow the principle of least surprise, which means that the code should behave as expected by users and other developers.
2. **Use Clear and Concise Variable Names**: Use clear and concise variable names to improve readability and maintainability.
3. **Document Code**: Document code using comments or documentation tools such as Doxygen to improve understandability and maintainability.

Overall, the code provides a good starting point for building a MySQL driver in Rust, but it requires improvements in error handling, resource management, and security to make it more robust and reliable."
docs/develop/c/bpf.md,"---
sidebar_position: 5
---

# Bpf userspace program example with wasm_bpf plug-in

There is a WasmEdge plug-in called `wasm_bpf`, which provided APIs to perform operations on eBPF program, such as loading, attaching and polling.

The detailed description can be found at [https://github.com/WasmEdge/WasmEdge/blob/master/plugins/wasm_bpf/README.md](https://github.com/WasmEdge/WasmEdge/blob/master/plugins/wasm_bpf/README.md).

Here we will provide several examples to demonstrate the `wasm_bpf` plug-in.

## Prerequisites

For simplicity, we will reuse the `Makefile` of [wasm-bpf](https://github.com/eunomia-bpf/wasm-bpf), since `wasmEdge_bpfPlugin` has the precisely same API as `wasm-bpf`

1. Clone the [`wasm-bpf`](https://github.com/eunomia-bpf/wasm-bpf) repo.
2. Run `make install-deps` and `make /opt/wasi-sdk` at the project's root. This will install the build prerequisites.
3. [Install WasmEdge](../../start/install.md#install)
4. Build and install the `wasm_bpf` plug-in. Currently, we have to build `wasm_bpf` plug-in manually. The building instructions could be found at [https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasm_bpf#build-wasm_bpf-plug-in](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasm_bpf#build-wasm_bpf-plug-in)

## The bootstrap example

`bootstrap` is a simple eBPF program to track the entry and exit of all processes. It will print a line of message when there is an entry of an exiting event of a process.

Run `make` in `wasm-bpf/examples/bootstrap`, and you will find the `bootstrap.wasm`, which can be executed by `WasmEdge`.

```bash
WASMEDGE_PLUGIN_PATH=./build/plugins/wasm_bpf/ wasmedge bootstrap.wasm
```

`WASMEDGE_PLUGIN_PATH` should be changed due to your build directory of the plug-in.

Example output:

```bash
TIME     EVENT COMM             PID     PPID    FILENAME/EXIT CODE
13:38:00 EXEC  bash             121487  40189   /usr/bin/bash
13:38:00 EXEC  groups           121489  121487  /usr/bin/groups
13:38:00 EXIT  groups           121489  121487  [0] (3ms)
13:38:00 EXEC  lesspipe         121490  121487  /usr/bin/lesspipe
13:38:00 EXEC  basename         121491  121490  /usr/bin/basename
13:38:00 EXIT  basename         121491  121490  [0] (8ms)
13:38:00 EXEC  dirname          121493  121492  /usr/bin/dirname
13:38:00 EXIT  dirname          121493  121492  [0] (1ms)
13:38:00 EXIT  lesspipe         121492  121490  [0]
```

### Details of `bootstrap`

`bootstrap` was created in a similar spirit as libbpf-tools from BCC package but is designed to be more stand-alone and with a simpler Makefile to simplify adoption to users' particular needs. It demonstrates the use of typical BPF features:

Cooperating BPF programs (tracepoint handlers for process `exec` and `exit` events, in this particular case); BPF map for maintaining the state; BPF ring buffer for sending data to userspace; global variables for application behavior parameterization. It utilizes BPF CO-RE and vmlinux.h to read extra process information from kernel's struct task_struct.

#### Some code snippets

A bpf program from `bootstrap.bpf.c`. It tracks the execution of processes, wraps the event in a struct, and sends the struct to the userspace program through ringbuf.

```c
SEC(""tp/sched/sched_process_exec"")
int handle_exec(struct trace_event_raw_sched_process_exec* ctx) {
    struct task_struct* task;
    unsigned fname_off;
    struct event* e;
    pid_t pid;
    u64 ts;

    /* remember time exec() was executed for this PID */
    pid = bpf_get_current_pid_tgid() >> 32;
    ts = bpf_ktime_get_ns();
    bpf_map_update_elem(&exec_start, &pid, &ts, BPF_ANY);

    /* don't emit exec events when minimum duration is specified */
    if (min_duration_ns)
        return 0;

    /* reserve sample from BPF ringbuf */
    e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
    if (!e)
        return 0;

    /* fill out the sample with data */
    task = (struct task_struct*)bpf_get_current_task();

    e->exit_event = false;
    e->pid = pid;
    e->ppid = BPF_CORE_READ(task, real_parent, tgid);
    bpf_get_current_comm(&e->comm, sizeof(e->comm));

    fname_off = ctx->__data_loc_filename & 0xFFFF;
    bpf_probe_read_str(&e->filename, sizeof(e->filename),
                       (void*)ctx + fname_off);

    /* successfully submit it to user-space for post-processing */
    bpf_ringbuf_submit(e, 0);
    return 0;
}
```

The userspace program's core process (compiled to Wasm). It invokes APIs from `wasm_bpf` to open, load, attach the bpf program, and poll data from the ringbuf.

```c
/* Load and verify BPF application */
    skel = bootstrap_bpf__open();
    if (!skel) {
        fprintf(stderr, ""Failed to open and load BPF skeleton\n"");
        return 1;
    }

    /* Parameterize BPF code with minimum duration parameter */
    skel->rodata->min_duration_ns = env.min_duration_ms * 1000000ULL;

    /* Load & verify BPF programs */
    err = bootstrap_bpf__load(skel);
    if (err) {
        fprintf(stderr, ""Failed to load and verify BPF skeleton\n"");
        goto cleanup;
    }

    /* Attach tracepoints */
    err = bootstrap_bpf__attach(skel);
    if (err) {
        fprintf(stderr, ""Failed to attach BPF skeleton\n"");
        goto cleanup;
    }

    /* Set up ring buffer polling */
    rb = bpf_buffer__open(skel->maps.rb, handle_event, NULL);
    if (!rb) {
        err = -1;
        fprintf(stderr, ""Failed to create ring buffer\n"");
        goto cleanup;
    }
    /* Process events */
    printf(""%-8s %-5s %-16s %-7s %-7s %s\n"", ""TIME"", ""EVENT"", ""COMM"", ""PID"",
           ""PPID"", ""FILENAME/EXIT CODE"");
    while (!exiting) {
        // poll buffer
        err = bpf_buffer__poll(rb, 100 /* timeout, ms */);
        /* Ctrl-C will cause -EINTR */
        if (err == -EINTR) {
            err = 0;
            break;
        }
        if (err < 0) {
            printf(""Error polling perf buffer: %d\n"", err);
            break;
        }
    }
```

## Other examples

Each directory under `wasm-bpf/examples` represents an example able to be run using `WasmEdge`. You can run `make` in their directory and run the corresponding WASM with `WasmEdge`.
","**Summary**

The provided code is a collection of examples for the `wasm_bpf` plug-in, which is a WasmEdge plug-in that provides APIs to perform operations on eBPF (Extended Berkeley Packet Filter) programs. The examples demonstrate how to create and run BPF programs using the `wasm_bpf` plug-in.

**Key Components**

1. **Bootstrap example**: A simple eBPF program that tracks the entry and exit of all processes, printing a line of message when there is an event.
2. **WasmEdge integration**: The examples demonstrate how to use WasmEdge to run BPF programs compiled from C code using the `wasm_bpf` plug-in.
3. **APIs for loading, attaching, and polling**: The examples show how to use the APIs provided by `wasm_bpf` to open, load, attach, and poll data from BPF ring buffers.

**Code Snippets**

1. **BPF program (bootstrap.bpf.c)**: A BPF program that tracks the execution of processes, wraps events in a struct, and sends the struct to userspace through a ring buffer.
2. **Userspace code (main.c)**: The main entry point for the example, which loads and verifies the BPF application using `wasm_bpf` APIs.

**Potential Issues**

1. **Error handling**: Some examples do not handle errors properly, which may lead to unexpected behavior or crashes.
2. **Memory safety**: The code uses manual memory management (e.g., `bpf_probe_read_str`) without proper bounds checking, which can lead to buffer overflows and security issues.

**Improvement Opportunities**

1. **Add more examples**: Expand the collection of examples to cover different use cases and scenarios for the `wasm_bpf` plug-in.
2. **Improve error handling**: Enhance the code to handle errors properly, providing meaningful error messages and returning consistent error codes.
3. **Enhance memory safety**: Use safer API calls (e.g., `bpf_probe_read`) or consider using a memory-safe programming language like Rust to ensure robustness and security."
i18n/zh/docusaurus-plugin-content-docs/current/develop/c/bpf.md,"---
sidebar_position: 5
---

# Bpf userspace program example with wasm_bpf plug-in

There is a WasmEdge plug-in called `wasm_bpf`, which provided APIs to perform operations on eBPF program, such as loading, attaching and polling.

The detailed description can be found at [https://github.com/WasmEdge/WasmEdge/blob/master/plugins/wasm_bpf/README.md](https://github.com/WasmEdge/WasmEdge/blob/master/plugins/wasm_bpf/README.md).

Here we will provide several examples to demonstrate the `wasm_bpf` plug-in.

## Prerequisites

For simplicity, we will reuse the `Makefile` of [wasm-bpf](https://github.com/eunomia-bpf/wasm-bpf), since `wasmEdge_bpfPlugin` has the precisely same API as `wasm-bpf`

1. Clone the [`wasm-bpf`](https://github.com/eunomia-bpf/wasm-bpf) repo.
2. Run `make install-deps` and `make /opt/wasi-sdk` at the project's root. This will install the build prerequisites.
3. [Install WasmEdge](../../start/install.md#install)
4. Build and install the `wasm_bpf` plug-in. Currently, we have to build `wasm_bpf` plug-in manually. The building instructions could be found at [https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasm_bpf#build-wasm_bpf-plug-in](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasm_bpf#build-wasm_bpf-plug-in)

## The bootstrap example

`bootstrap` is a simple eBPF program to track the entry and exit of all processes. It will print a line of message when there is an entry of an exiting event of a process.

Run `make` in `wasm-bpf/examples/bootstrap`, and you will find the `bootstrap.wasm`, which can be executed by `WasmEdge`.

```bash
WASMEDGE_PLUGIN_PATH=./build/plugins/wasm_bpf/ wasmedge bootstrap.wasm
```

`WASMEDGE_PLUGIN_PATH` should be changed due to your build directory of the plug-in.

Example output:

```bash
TIME     EVENT COMM             PID     PPID    FILENAME/EXIT CODE
13:38:00 EXEC  bash             121487  40189   /usr/bin/bash
13:38:00 EXEC  groups           121489  121487  /usr/bin/groups
13:38:00 EXIT  groups           121489  121487  [0] (3ms)
13:38:00 EXEC  lesspipe         121490  121487  /usr/bin/lesspipe
13:38:00 EXEC  basename         121491  121490  /usr/bin/basename
13:38:00 EXIT  basename         121491  121490  [0] (8ms)
13:38:00 EXEC  dirname          121493  121492  /usr/bin/dirname
13:38:00 EXIT  dirname          121493  121492  [0] (1ms)
13:38:00 EXIT  lesspipe         121492  121490  [0]
```

### Details of `bootstrap`

`bootstrap` was created in a similar spirit as libbpf-tools from BCC package but is designed to be more stand-alone and with a simpler Makefile to simplify adoption to users' particular needs. It demonstrates the use of typical BPF features:

Cooperating BPF programs (tracepoint handlers for process `exec` and `exit` events, in this particular case); BPF map for maintaining the state; BPF ring buffer for sending data to userspace; global variables for application behavior parameterization. It utilizes BPF CO-RE and vmlinux.h to read extra process information from kernel's struct task_struct.

#### Some code snippets

A bpf program from `bootstrap.bpf.c`. It tracks the execution of processes, wraps the event in a struct, and sends the struct to the userspace program through ringbuf.

```c
SEC(""tp/sched/sched_process_exec"")
int handle_exec(struct trace_event_raw_sched_process_exec* ctx) {
    struct task_struct* task;
    unsigned fname_off;
    struct event* e;
    pid_t pid;
    u64 ts;

    /* remember time exec() was executed for this PID */
    pid = bpf_get_current_pid_tgid() >> 32;
    ts = bpf_ktime_get_ns();
    bpf_map_update_elem(&exec_start, &pid, &ts, BPF_ANY);

    /* don't emit exec events when minimum duration is specified */
    if (min_duration_ns)
        return 0;

    /* reserve sample from BPF ringbuf */
    e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
    if (!e)
        return 0;

    /* fill out the sample with data */
    task = (struct task_struct*)bpf_get_current_task();

    e->exit_event = false;
    e->pid = pid;
    e->ppid = BPF_CORE_READ(task, real_parent, tgid);
    bpf_get_current_comm(&e->comm, sizeof(e->comm));

    fname_off = ctx->__data_loc_filename & 0xFFFF;
    bpf_probe_read_str(&e->filename, sizeof(e->filename),
                       (void*)ctx + fname_off);

    /* successfully submit it to user-space for post-processing */
    bpf_ringbuf_submit(e, 0);
    return 0;
}
```

The userspace program's core process (compiled to Wasm). It invokes APIs from `wasm_bpf` to open, load, attach the bpf program, and poll data from the ringbuf.

```c
/* Load and verify BPF application */
    skel = bootstrap_bpf__open();
    if (!skel) {
        fprintf(stderr, ""Failed to open and load BPF skeleton\n"");
        return 1;
    }

    /* Parameterize BPF code with minimum duration parameter */
    skel->rodata->min_duration_ns = env.min_duration_ms * 1000000ULL;

    /* Load & verify BPF programs */
    err = bootstrap_bpf__load(skel);
    if (err) {
        fprintf(stderr, ""Failed to load and verify BPF skeleton\n"");
        goto cleanup;
    }

    /* Attach tracepoints */
    err = bootstrap_bpf__attach(skel);
    if (err) {
        fprintf(stderr, ""Failed to attach BPF skeleton\n"");
        goto cleanup;
    }

    /* Set up ring buffer polling */
    rb = bpf_buffer__open(skel->maps.rb, handle_event, NULL);
    if (!rb) {
        err = -1;
        fprintf(stderr, ""Failed to create ring buffer\n"");
        goto cleanup;
    }
    /* Process events */
    printf(""%-8s %-5s %-16s %-7s %-7s %s\n"", ""TIME"", ""EVENT"", ""COMM"", ""PID"",
           ""PPID"", ""FILENAME/EXIT CODE"");
    while (!exiting) {
        // poll buffer
        err = bpf_buffer__poll(rb, 100 /* timeout, ms */);
        /* Ctrl-C will cause -EINTR */
        if (err == -EINTR) {
            err = 0;
            break;
        }
        if (err < 0) {
            printf(""Error polling perf buffer: %d\n"", err);
            break;
        }
    }
```

## Other examples

Each directory under `wasm-bpf/examples` represents an example able to be run using `WasmEdge`. You can run `make` in their directory and run the corresponding WASM with `WasmEdge`.
","**Code Summary**

The provided code is a documentation and example for using the `wasm_bpf` plug-in with WasmEdge, a WebAssembly runtime. The `wasm_bpf` plug-in provides APIs to perform operations on eBPF (Extended Berkeley Packet Filter) programs.

**Key Components**

1. **Prerequisites**: The code requires several prerequisites to be installed and set up:
	* Clone the `wasm-bpf` repository.
	* Run `make install-deps` and `make /opt/wasi-sdk` at the project's root.
	* Install WasmEdge.
2. **The Bootstrap Example**: This example demonstrates how to use the `wasm_bpf` plug-in with a simple eBPF program called `bootstrap`. The `bootstrap` program tracks the entry and exit of all processes.
3. **Details of `bootstrap`**: The code provides an explanation of the features used in the `bootstrap` program, including:
	* Cooperating BPF programs (tracepoint handlers for process events).
	* BPF map for maintaining state.
	* BPF ring buffer for sending data to userspace.
4. **Code Snippets**: Two code snippets are provided:
	* A bpf program from `bootstrap.bpf.c` that tracks the execution of processes and sends structs to the userspace program through a ringbuf.
	* The userspace program's core process (compiled to Wasm) that invokes APIs from `wasm_bpf` to open, load, attach the bpf program, and poll data from the ringbuf.

**Potential Issues and Areas for Improvement**

1. **Error Handling**: The code could benefit from improved error handling, especially when dealing with complex operations like loading and verifying BPF programs.
2. **Code Organization**: The code has a mix of C and Wasm code, which can make it harder to understand and maintain. A clearer separation between the two would be beneficial.
3. **Documentation**: While the code provides some explanations, more detailed documentation on how to use the `wasm_bpf` plug-in with WasmEdge could be helpful.
4. **Testing**: The code lacks any testing framework or unit tests, making it harder to ensure that the code is correct and works as expected.

Overall, the provided code is a good starting point for exploring the `wasm_bpf` plug-in with WasmEdge. However, with some improvements in error handling, code organization, documentation, and testing, it could become an even more valuable resource for developers working with WebAssembly and eBPF programs."
docs/contribute/source/os/sel4.md,"---
sidebar_position: 8
---

# Build on seL4 RTOS

[Video demo](https://youtu.be/2Qu-Trtkspk) | [Build logs](https://github.com/second-state/wasmedge-seL4/runs/3982081148?check_suite_focus=true) | [Build artifact](https://github.com/second-state/wasmedge-seL4/actions/runs/1374510169)

In this article, we demonstrate how to run WasmEdge on the seL4 RTOS, there are two parts:

1. Guest Linux OS on seL4: This is the controller of WasmEdge runtime, which will send wasm program to WasmEdge runner that is a agent on seL4 to execute.
2. WasmEdge runner on seL4: This is the wasm program runtime, which will execute the given wasm program from Guest Linux OS.

The figure below illustrates the architecture of the system.

![wasmedge-sel4](wasmedge-sel4.png)

This demo is based on the seL4 simulator on Linux.

## Getting Started

### System requirements

Hardware:

- at least 4GB of RAM
- at least 20GB of disk storage (the wasmedge_sel4 directory will contain over 11 GB of data after the following installation completes)

Software: Ubuntu 20.04 with dev tools packages (ep. Python) installed. We recommend the [GitHub Actions Ubuntu 20.04 VM](https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md) (See a list of [installed apt packages](https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md#installed-apt-packages)). Or, you could use our Docker image (see the [Dockerfile](https://github.com/second-state/wasmedge-seL4/blob/main/docs/Dockerfile.sel4_build)).

```bash
$ docker pull wasmedge/sel4_build
$ docker run --rm -v $(pwd):/app -it wasmedge/sel4_build
(docker) root#
```

<!-- prettier-ignore -->
:::note
If you do not want to build the seL4 system simulator yourself, you can download the [build artifact](https://github.com/second-state/wasmedge-seL4/actions/runs/1374510169) from our GitHub Actions, and skip directly to [Boot wasmedge-seL4](#boot-wasmedge-sel4)
:::

### Automatic installation: all-in-one script

Use our all-in-one build script:

```bash
wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-seL4/main/build.sh | bash
```

And this will clone and build our wasmedge on seL4 to an image.

After finishing the build script, you will have a folder `sel4_wasmedge`.

If this automatic installation completed successfully, skip over the manual installation information and proceed to [boot wasmedge-sel4](https://github.com/second-state/wasmedge-seL4#boot-wasmedge-sel4)

### Manual installation: managing memory usage

The above all-in-one script will work in most cases. However, if your system resources were stressed and you encountered an error such as `ninja: build stopped: subcommand failed` please note that you can decrease the parallelization of the install by explicitly passing in a `-j` parameter to the `ninja` command (on the last line of the `build.sh` file). You see, Ninja runs the most amount of parallel processes by default and so the following procedure is a way to explicitly set/reduce parallelization.

Manually fetch the `wasmedge-sel4 repository.

```bash
cd ~
git clone https://github.com/second-state/wasmedge-seL4.git
cd wasmedge-seL4
```

Manually edit the `build.sh` file.

```bash
vi build.sh
```

Add the following `-j` parameter to the last line of the file i.e.

```bash
ninja -j 2
```

Make the `build.sh` file executable.

```bash
sudo chmod a+x build.sh
```

Run the edited `build.sh file.

```bash
./build.sh
```

Once this manual installation is complete, follow along with the following steps; boot wasmedge-sel4

### Boot wasmedge-seL4

```bash
cd sel4_wasmedge/build
./simulate
```

Expected output:

```bash
$ ./simulate: qemu-system-aarch64 -machine virt,virtualization=on,highmem=off,secure=off -cpu cortex-a53 -nographic  -m size=2048  -kernel images/capdl-loader-image-arm-qemu-arm-virt
ELF-loader started on CPU: ARM Ltd. Cortex-A53 r0p4
  paddr=[6abd8000..750cf0af]
No DTB passed in from boot loader.
Looking for DTB in CPIO archive...found at 6ad18f58.
Loaded DTB from 6ad18f58.
   paddr=[60243000..60244fff]
ELF-loading image 'kernel' to 60000000
  paddr=[60000000..60242fff]
  vaddr=[ff8060000000..ff8060242fff]
  virt_entry=ff8060000000
ELF-loading image 'capdl-loader' to 60245000
  paddr=[60245000..6a7ddfff]
  vaddr=[400000..a998fff]
  virt_entry=408f38
Enabling hypervisor MMU and paging
Jumping to kernel-image entry point...

Bootstrapping kernel
Warning: Could not infer GIC interrupt target ID, assuming 0.
Booting all finished, dropped to user space
<<seL4(CPU 0) [decodeUntypedInvocation/205 T0xff80bf85d400 ""rootserver"" @4006f8]: Untyped Retype: Insufficient memory (1 * 2097152 bytes needed, 0 bytes available).>>
Loading Linux: 'linux' dtb: 'linux-dtb'

...(omitted)...

Starting syslogd: OK
Starting klogd: OK
Running sysctl: OK
Initializing random number generator... [    3.512482] random: dd: uninitialized urandom read (512 bytes read)
done.
Starting network: OK
[    4.086059] connection: loading out-of-tree module taints kernel.
[    4.114686] Event Bar (dev-0) initalised
[    4.123771] 2 Dataports (dev-0) initalised
[    4.130626] Event Bar (dev-1) initalised
[    4.136096] 2 Dataports (dev-1) initalised

Welcome to Buildroot
buildroot login:
```

### Login on guest linux

Enter `root` to login

```bash
buildroot login: root
```

Expected output:

```bash
buildroot login: root
#
```

### Execute wasm examples

#### Example A: nbody-c.wasm

Run nbody simulation.

```bash
wasmedge_emit /usr/bin/nbody-c.wasm 10
```

Expected output:

```bash
[1900-01-00 00:00:00.000] [info] executing wasm file
-0.169075164
-0.169073022
[1900-01-00 00:00:00.000] [info] execution success, exit code:0
```

#### Example B: hello.wasm

Run an easy application to print `hello, sel4` and a simple calculation.

```bash
wasmedge_emit /usr/bin/hello.wasm
```

Expected output:

```bash
[1900-01-00 00:00:00.000] [info] executing wasm file
hello, sel4
1+2-3*4 = -9
[1900-01-00 00:00:00.000] [info] execution success, exit code:0
```
","**Summary**

This code provides a step-by-step guide for building and running WasmEdge on the seL4 Real-Time Operating System (RTOS). It involves installing dependencies, cloning and building the wasmedge-sel4 repository, and booting the seL4 system. The code also includes examples of executing WasmEdge applications, such as the nbody-c.wasm and hello.wasm files.

**Key Components**

1. `build.sh` script: A Bash script that clones and builds the wasmedge-sel4 repository.
2. `wasmedge_emit` command: A command used to execute WasmEdge applications on the seL4 system.
3. `simulate` command: A command used to boot the seL4 system.
4. Examples (nbody-c.wasm, hello.wasm): WasmEdge applications used for demonstration purposes.

**Potential Issues and Areas for Improvement**

1. **Error handling**: The code does not handle errors properly. For example, if the `build.sh` script fails, it will exit with a non-zero status, but there is no mechanism to catch or handle this error.
2. **System dependencies**: The code assumes that the system has certain dependencies installed (e.g., Ubuntu 20.04, dev tools packages). If these dependencies are not met, the build process may fail.
3. **Memory usage**: The `ninja` command is used with a default parallelization setting, which may cause memory issues on systems with limited resources.
4. **Code organization**: The code is organized into multiple sections (e.g., installation, building, executing WasmEdge applications). It would be beneficial to refactor the code into separate scripts or modules for each section.

**Recommendations**

1. Improve error handling by adding try-except blocks and logging mechanisms.
2. Use more robust dependency management techniques (e.g., `apt` or `pip`) to ensure that system dependencies are met.
3. Provide options to adjust parallelization settings in the `build.sh` script for systems with limited resources.
4. Refactor the code into separate scripts or modules for each section to improve maintainability and reusability."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/sel4.md,"---
sidebar_position: 8
---

# Build on seL4 RTOS

[Video demo](https://youtu.be/2Qu-Trtkspk) | [Build logs](https://github.com/second-state/wasmedge-seL4/runs/3982081148?check_suite_focus=true) | [Build artifact](https://github.com/second-state/wasmedge-seL4/actions/runs/1374510169)

In this article, we demonstrate how to run WasmEdge on the seL4 RTOS, there are two parts:

1. Guest Linux OS on seL4: This is the controller of WasmEdge runtime, which will send wasm program to WasmEdge runner that is a agent on seL4 to execute.
2. WasmEdge runner on seL4: This is the wasm program runtime, which will execute the given wasm program from Guest Linux OS.

The figure below illustrates the architecture of the system.

![wasmedge-sel4](wasmedge-sel4.png)

This demo is based on the seL4 simulator on Linux.

## Getting Started

### System requirements

Hardware:

- at least 4GB of RAM
- at least 20GB of disk storage (the wasmedge_sel4 directory will contain over 11 GB of data after the following installation completes)

Software: Ubuntu 20.04 with dev tools packages (ep. Python) installed. We recommend the [GitHub Actions Ubuntu 20.04 VM](https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md) (See a list of [installed apt packages](https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md#installed-apt-packages)). Or, you could use our Docker image (see the [Dockerfile](https://github.com/second-state/wasmedge-seL4/blob/main/docs/Dockerfile.sel4_build)).

```bash
$ docker pull wasmedge/sel4_build
$ docker run --rm -v $(pwd):/app -it wasmedge/sel4_build
(docker) root#
```

<!-- prettier-ignore -->
:::note
If you do not want to build the seL4 system simulator yourself, you can download the [build artifact](https://github.com/second-state/wasmedge-seL4/actions/runs/1374510169) from our GitHub Actions, and skip directly to [Boot wasmedge-seL4](#boot-wasmedge-sel4)
:::

### Automatic installation: all-in-one script

Use our all-in-one build script:

```bash
wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-seL4/main/build.sh | bash
```

And this will clone and build our wasmedge on seL4 to an image.

After finishing the build script, you will have a folder `sel4_wasmedge`.

If this automatic installation completed successfully, skip over the manual installation information and proceed to [boot wasmedge-sel4](https://github.com/second-state/wasmedge-seL4#boot-wasmedge-sel4)

### Manual installation: managing memory usage

The above all-in-one script will work in most cases. However, if your system resources were stressed and you encountered an error such as `ninja: build stopped: subcommand failed` please note that you can decrease the parallelization of the install by explicitly passing in a `-j` parameter to the `ninja` command (on the last line of the `build.sh` file). You see, Ninja runs the most amount of parallel processes by default and so the following procedure is a way to explicitly set/reduce parallelization.

Manually fetch the `wasmedge-sel4 repository.

```bash
cd ~
git clone https://github.com/second-state/wasmedge-seL4.git
cd wasmedge-seL4
```

Manually edit the `build.sh` file.

```bash
vi build.sh
```

Add the following `-j` parameter to the last line of the file i.e.

```bash
ninja -j 2
```

Make the `build.sh` file executable.

```bash
sudo chmod a+x build.sh
```

Run the edited `build.sh file.

```bash
./build.sh
```

Once this manual installation is complete, follow along with the following steps; boot wasmedge-sel4

### Boot wasmedge-seL4

```bash
cd sel4_wasmedge/build
./simulate
```

Expected output:

```bash
$ ./simulate: qemu-system-aarch64 -machine virt,virtualization=on,highmem=off,secure=off -cpu cortex-a53 -nographic  -m size=2048  -kernel images/capdl-loader-image-arm-qemu-arm-virt
ELF-loader started on CPU: ARM Ltd. Cortex-A53 r0p4
  paddr=[6abd8000..750cf0af]
No DTB passed in from boot loader.
Looking for DTB in CPIO archive...found at 6ad18f58.
Loaded DTB from 6ad18f58.
   paddr=[60243000..60244fff]
ELF-loading image 'kernel' to 60000000
  paddr=[60000000..60242fff]
  vaddr=[ff8060000000..ff8060242fff]
  virt_entry=ff8060000000
ELF-loading image 'capdl-loader' to 60245000
  paddr=[60245000..6a7ddfff]
  vaddr=[400000..a998fff]
  virt_entry=408f38
Enabling hypervisor MMU and paging
Jumping to kernel-image entry point...

Bootstrapping kernel
Warning: Could not infer GIC interrupt target ID, assuming 0.
Booting all finished, dropped to user space
<<seL4(CPU 0) [decodeUntypedInvocation/205 T0xff80bf85d400 ""rootserver"" @4006f8]: Untyped Retype: Insufficient memory (1 * 2097152 bytes needed, 0 bytes available).>>
Loading Linux: 'linux' dtb: 'linux-dtb'

...(omitted)...

Starting syslogd: OK
Starting klogd: OK
Running sysctl: OK
Initializing random number generator... [    3.512482] random: dd: uninitialized urandom read (512 bytes read)
done.
Starting network: OK
[    4.086059] connection: loading out-of-tree module taints kernel.
[    4.114686] Event Bar (dev-0) initalised
[    4.123771] 2 Dataports (dev-0) initalised
[    4.130626] Event Bar (dev-1) initalised
[    4.136096] 2 Dataports (dev-1) initalised

Welcome to Buildroot
buildroot login:
```

### Login on guest linux

Enter `root` to login

```bash
buildroot login: root
```

Expected output:

```bash
buildroot login: root
#
```

### Execute wasm examples

#### Example A: nbody-c.wasm

Run nbody simulation.

```bash
wasmedge_emit /usr/bin/nbody-c.wasm 10
```

Expected output:

```bash
[1900-01-00 00:00:00.000] [info] executing wasm file
-0.169075164
-0.169073022
[1900-01-00 00:00:00.000] [info] execution success, exit code:0
```

#### Example B: hello.wasm

Run an easy application to print `hello, sel4` and a simple calculation.

```bash
wasmedge_emit /usr/bin/hello.wasm
```

Expected output:

```bash
[1900-01-00 00:00:00.000] [info] executing wasm file
hello, sel4
1+2-3*4 = -9
[1900-01-00 00:00:00.000] [info] execution success, exit code:0
```
","**Summary**

This document describes how to build and run WasmEdge on the seL4 RTOS (Real-Time Operating System) using a combination of Linux Guest OS and WasmEdge runner on seL4. The system architecture is illustrated, and detailed instructions are provided for getting started, including hardware and software requirements.

**Key Components**

1. **Linux Guest OS**: This is the controller of WasmEdge runtime, responsible for sending wasm programs to WasmEdge runner.
2. **WasmEdge Runner on seL4**: This is the wasm program runtime, executing given wasm programs from Linux Guest OS.
3. **seL4 Simulator**: This simulator runs on top of a Linux system and simulates the seL4 RTOS.

**Instructions**

The document provides step-by-step instructions for building WasmEdge on seL4:

1. **Automatic Installation**: Use the `build.sh` script to clone, build, and create an image.
2. **Manual Installation**: Fetch the repository, edit the `build.sh` file, make it executable, and run it manually.

**Boot WasmEdge-seL4**

After building WasmEdge on seL4, follow these steps:

1. Change into the `sel4_wasmedge/build` directory.
2. Run `./simulate` to start the simulation.

**Login and Execute WASM Examples**

To login and execute wasm examples, follow these steps:

1. Enter `root` to login.
2. Use the `wasmedge_emit` command to run the following wasm examples: `nbody-c.wasm` and `hello.wasm`.

**Potential Issues or Areas for Improvement**

* The document assumes a high level of technical expertise in building and running WasmEdge on seL4.
* The instructions may be unclear or incomplete, leading to errors during the build process.
* The use of outdated tools or versions may result in compatibility issues.
* Additional error handling mechanisms should be implemented to handle unexpected errors during simulation."
docs/develop/rust/http_service/server.md,"---
sidebar_position: 2
---

# Server

For WasmEdge to become a cloud-native runtime for microservices, it needs to support HTTP servers. By its very nature, the HTTP server is always asynchronous (non-blocking -- so that it can handle concurrent requests). This chapter will cover HTTP servers using popular Rust APIs.

- [The axum API](#the-warp-api)
- [The hyper API](#the-hyper-api)

<!-- prettier-ignore -->
:::note
Before we start, [you need to have Rust and WasmEdge installed](../setup.md).
Make sure that you read the [special notes on networking apps](../setup#special-notes-for-networking-apps) especially if you are compiling Rust programs on a Mac.
:::

## The axum API

The [axum](https://github.com/tokio-rs/axum) crate is the most popular HTTP server framework in the Rust Tokio ecosystem.
It is also the web framework for many popular services such as the [flows.network](https://flows.network) serverless platform for workflow functions.

Use the axum API to create an asynchronous HTTP server. Build and run [the example](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/server-axum/) in WasmEdge as follows.

```bash
git clone https://github.com/WasmEdge/wasmedge_hyper_demo
cd wasmedge_hyper_demo/server-axum

# Build the Rust code
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release
# Use the AoT compiler for better performance
wasmedge compile target/wasm32-wasi/release/wasmedge_axum_server.wasm wasmedge_axum_server.wasm

# Run the example
wasmedge wasmedge_axum_server.wasm
```

Then from another terminal, you can request the server. The HTTP server echoes the request data and sends back the response.

```bash
$ curl http://localhost:8080/echo -X POST -d ""WasmEdge""
WasmEdge
```

In your Rust application, you will apply a few patches developed by the WasmEdge community to replace
POSIX sockets with WasmEdge sockets in standard libraries. With those patches, you can then
use the official `tokio` and `axum` crates.

```
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }
socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }
hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }

[dependencies]
axum = ""0.6""
bytes = ""1""
futures-util = ""0.3.30""
tokio = { version = ""1"", features = [""rt"", ""macros"", ""net"", ""time"", ""io-util""]}
```

The [Rust example code](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/server-axum/src/main.rs) below shows an HTTP server that responds to incoming requests for the `/` and `/echo` URL endpoints.

```rust
#[tokio::main(flavor = ""current_thread"")]
async fn main() {
    // build our application with a route
    let app = Router::new()
        .route(""/"", get(help))
        .route(""/echo"", post(echo));

    // run it
    let addr = ""0.0.0.0:8080"";
    let tcp_listener = TcpListener::bind(addr).await.unwrap();
    println!(""listening on {}"", addr);
    axum::Server::from_tcp(tcp_listener.into_std().unwrap())
        .unwrap()
        .serve(app.into_make_service())
        .await
        .unwrap();
}
```

The  `echo()` function is called when a `POST` request is received at `/echo`. The function receives and processes
the request body and returns bytes that are sent back as the response message.

```rust
async fn echo(mut stream: BodyStream) -> Bytes {
    if let Some(Ok(s)) = stream.next().await {
        s
    } else {
        Bytes::new()
    }
}
```

## The hyper API

The `hyper` crate is an excellent library for building HTTP servers using customizable low level APIs. Build and run [the example](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/server/) in WasmEdge as follows.

```bash
git clone https://github.com/WasmEdge/wasmedge_hyper_demo
cd wasmedge_hyper_demo/server

# Build the Rust code
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release
# Use the AoT compiler to get better performance
wasmedge compile target/wasm32-wasi/release/wasmedge_hyper_server.wasm wasmedge_hyper_server.wasm

# Run the example
wasmedge wasmedge_hyper_server.wasm
```

Then from another terminal, you can request the server. The HTTP server echoes the request data and sends back the response.

```bash
$ curl http://localhost:8080/echo -X POST -d ""WasmEdge""
WasmEdge
```

In your Rust application, import the [hyper](https://crates.io/crates/hyper) and [tokio](https://crates.io/crates/tokio) crates, as well as the WasmEdge patches. Just add the following lines to your `Cargo.toml`.

```toml
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }
socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }
hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }

[dependencies]
hyper = { version = ""0.14"", features = [""full""]}
tokio = { version = ""1"", features = [""rt"", ""macros"", ""net"", ""time"", ""io-util""]}
```

The [Rust example code](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/server/src/main.rs) below shows an HTTP server that echoes back any incoming request.

```rust
async fn echo(req: Request<Body>) -> Result<Response<Body>, hyper::Error> {
    match (req.method(), req.uri().path()) {
        // Serve some instructions at /
        (&Method::GET, ""/"") => Ok(Response::new(Body::from(
            ""Try POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`"",
        ))),

        // Simply echo the body back to the client.
        (&Method::POST, ""/echo"") => Ok(Response::new(req.into_body())),

        (&Method::POST, ""/echo/reversed"") => {
            let whole_body = hyper::body::to_bytes(req.into_body()).await?;

            let reversed_body = whole_body.iter().rev().cloned().collect::<Vec<u8>>();
            Ok(Response::new(Body::from(reversed_body)))
        }

        // Return the 404 Not Found for other routes.
        _ => {
            let mut not_found = Response::default();
            *not_found.status_mut() = StatusCode::NOT_FOUND;
            Ok(not_found)
        }
    }
}
```
","**Summary**

The provided code is a set of examples and guides for creating HTTP servers using the axum and hyper APIs in Rust. The examples demonstrate how to build and run HTTP servers that respond to incoming requests, with a focus on handling concurrent requests and networking.

**Key Components**

1. **Axum API**: The axum crate is used to create an asynchronous HTTP server. The example code shows how to build and run an HTTP server using the axum API.
2. **Hyper API**: The hyper crate is another popular library for building HTTP servers in Rust. The example code demonstrates how to use the hyper API to create a simple HTTP server.
3. **WasmEdge Patches**: To replace POSIX sockets with WasmEdge sockets, patches are developed by the WasmEdge community and applied to standard libraries. These patches enable the use of official tokio and axum crates.

**Example Code**

The example code provides two examples:

1. **Axum API Example**: The code shows how to create an HTTP server using the axum API. It includes a simple `echo` function that handles POST requests and returns the request body as the response.
2. **Hyper API Example**: The code demonstrates how to use the hyper API to create a simple HTTP server. It includes a similar `echo` function that handles POST requests.

**Potential Issues**

1. **Concurrency**: Both examples demonstrate how to handle concurrent requests using asynchronous programming. However, it's essential to ensure that the concurrency model is properly implemented and tested.
2. **Networking**: The code assumes a simple networking setup, but in real-world scenarios, network errors and edge cases may occur.
3. **Error Handling**: While both examples include basic error handling, more comprehensive error handling mechanisms should be implemented in production code.

**Improvement Suggestions**

1. **Add More Error Handling**: Implement more robust error handling mechanisms to handle various types of errors that may occur during networking and concurrency.
2. **Optimize Performance**: Optimize the performance of the HTTP servers by using caching, load balancing, or other techniques as needed.
3. **Test Thoroughly**: Thoroughly test the code in different scenarios to ensure it handles concurrent requests and network edge cases correctly."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/users.md,"---
sidebar_position: 11
---

# WasmEdge Users and Collaborators

This list is constantly being updated. Please submit a PR to add your own item if we missed your use case. We appreciate our community members' contributions. Thank you!

| Name | Desciption | PR or Docs |
| --- | --- | --- |
| WebAssembly Languages Runtime maintained by VMWare | Use WasmEdge to run PHP and python programs | <https://github.com/vmware-labs/webassembly-language-runtimes/pull/19> |
| LF Edge eKuiper | Use WasmEdge to process data streamed from IoT devices | <https://github.com/lf-edge/ekuiper/pull/1449/> |
| crun | Use WasmEdge to run WASM containers | <https://github.com/containers/crun/pull/774> |
| youki | Use WasmEdge to run WASM containers | <https://github.com/containers/youki/pull/1320> |
| containerd and runwasi | Use WasmEdge to run WASM containers | <https://github.com/containerd/runwasi> |
| Kuasar | Use WasmEdge to run WASM containers | <https://github.com/kuasar-io/kuasar#wasm-sandboxer> |
| Proxy-wasm | Use WASM to process the proxy rules | <https://github.com/proxy-wasm/proxy-wasm-cpp-host/pull/193> |
| OpenYurt | Use WasmEdge to run WASM containers side by side with Linux containers in an OpenYurt network. | <https://www.cncf.io/blog/2022/02/07/wasmedge-and-openyurt-bring-cloud-computing-to-the-edge/> |
| SuperEdge | Use WasmEdge to run WASM containers side by side with Linux containers in a SuperEdge network. | <https://github.com/WasmEdge/WasmEdge/pull/1272> |
| OpenGauss | Use WasmEdge to support user-defined functions (UDF) in a database | <https://hub.docker.com/r/opengauss/wasmedge> |
| Essa-ra | Use WasmEdge to execute serverless functions on the essa-rs platform. | <https://github.com/essa-project/essa-rs> |
| Fedora Linux | Incorporated WasmEdge as an official RPM package since Fedora 37. | <https://packages.fedoraproject.org/pkgs/wasmedge/wasmedge/index.html> |
| Polkadot | Provide WasmEdge as a smart contract runtime for parachains, and support WasmEdge as an alternative runtime for substrate nodes. | <https://github.com/second-state/substrate-wasmedge> |
| Apache Traffic Server | Use WasmEdge as a plug-in to process the traffic flow | <https://github.com/apache/trafficserver/pull/9390> |
| Enovy | Use WasmEdge as a plug-in to process the traffic flow | <https://github.com/envoyproxy/envoy/pull/24817/files> |
| Liquid Reply | Kubernetes operators for managing WasmEdge workloads for customers | <https://kwasm.sh/> |
| Docker | Use WasmEdge to support wasm containers in Docker Desktop tools | <https://www.docker.com/blog/docker-wasm-technical-preview/> |
| ByteDance | Use WasmEdge to run custom logic in service mesh proxies and sidecars | Internal use case |
| ByteDance | Use WasmEdge to run serverless functions | Internal use case |
| ByteDance | Use WasmEdge as a Ray node | <https://github.com/ray-project/enhancements/blob/main/reps/2023-02-01-wasm-on-ray.md> |
| Huawei Cloud | Use WasmEdge to run Serverless functions | Internal use case |
| 5miles | Use WasmEdge to run internal microservices | Internal use case |
| Bytetrade | Use WasmEdge to run microservices for automated crypto trading and marketing automation. | Internal use case |
| FutureWei | Use WasmEdge on automobile and OpenHarmony | <https://github.com/WasmEdge/WasmEdge/pull/902> |
| WinSoft | Use WasmEdge to improve IDE’s user experience | <https://winsoft.sk/webassembly.htm> |
| ParaState | Use WasmEdge to execute smart contracts on the ParaState blockchain | <https://www.parastate.io/> |
| Plurigrid | Use WasmEdge to run client-side / edge simulations | <https://twitter.com/bmorphism/status/1606237485037674499> |
| XRPL Labs | Use WasmEdge to execute smart contracts on the Ripple blockchain | <https://github.com/XRPL-Labs/xrpld-hooks> |
| API7 | Run WasmEdge in OpenResty/Nginx | <https://github.com/api7/wasm-nginx-module> |
| YoMo | Use WasmEdge to support user-defined functions (UDF) in streaming data pipelines | [https://github.com/yomorun/yomo-wasmedge-tensorflow](https://github.com/yomorun/yomo) |
| libsql | Use WasmEdge to support user-defined functions (UDF) in a database | <https://github.com/libsql/libsql/pull/131> |
| Shifu | Use WasmEdge to support user-defined functions (UDF) in data streams from edge devices | <https://github.com/Edgenesis/wasm-shifu-demo> |
| Lnjoying | Offers WasmEdge as part of its edge cloud service. | Internal use case |
| Red Hat EPEL 9 | Offers support for wasmedge packages for Red Hat Linux 9 users. | <https://packages.fedoraproject.org/pkgs/wasmedge/wasmedge/index.html> |
| Open Interpreter| Use WasmEdge as the LLM runtime | <https://github.com/OpenInterpreter/01/tree/main/software/source/server/services/llm/llamaedge> |
| GaiaNet| Use WasmEdge as LLM runtime | <https://github.com/GaiaNet-AI/gaianet-node> |
| MoXin| Use WasmEdge as the LLM runtime | <https://github.com/project-robius/moxin> |
| CODA Bridge| Use WasmEdge as the container to run microservices | Internal use case |
| CloudEvents | Support the Rust SDK to be compiled into Wasm so that a Wasm app can send and receive cloud events | <https://github.com/cloudevents/sdk-rust/pull/202> |
| Kagome | A C++ implementation of Polkadot host which runs Wasm smart contracts on WasmEdge | <https://github.com/qdrvm/kagome/tree/master/core/runtime> |
| Sealos | A Cloud Operating System designed for managing cloud-native applications. It uses WasmEdge to run LLMs locally in its cluster. | <https://github.com/labring-actions/cluster-image/blob/main/applications/runwasi-wasmedge/latest/install.sh> |
","**Summary**

The provided code is a Markdown file (`users.md`) that lists various users and collaborators of the WasmEdge project. Each user or organization is associated with a description, a link to their relevant GitHub repository or issue tracker, and sometimes additional context.

**Purpose and Functionality**

This document serves as a showcase for the diverse use cases and applications of the WasmEdge technology, highlighting its potential for innovation in various industries and domains.

**Key Components**

1. **List of users and organizations**: The file contains an exhaustive list of entities that have incorporated or are using WasmEdge in their projects.
2. **GitHub links**: Each entry includes a link to a relevant GitHub repository, pull request, or issue tracker, providing additional context and allowing users to explore the project further.
3. **Brief descriptions**: Short summaries provide insight into how each entity uses WasmEdge.

**Potential Issues and Areas for Improvement**

1. **Maintainability**: The list may become difficult to maintain as new projects emerge, and existing ones evolve.
2. **Organization**: The file's structure is mostly flat, which might make it hard to categorize or group related entities together.
3. **Readability**: While the Markdown format makes the document easy to read, some entries could benefit from more context or concise descriptions.

**Recommendations**

1. Consider creating a database or structured repository to store and manage user information, making it easier to maintain and update the list.
2. Develop a categorization system to group entities by industry, use case, or technology domain, enhancing the document's usability.
3. Refine entry descriptions to provide more context and highlight specific WasmEdge features being utilized."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/http_service/server.md,"---
sidebar_position: 2
---

# Server

For WasmEdge to become a cloud-native runtime for microservices, it needs to support HTTP servers. By its very nature, the HTTP server is always asynchronous (non-blocking -- so that it can handle concurrent requests). This chapter will cover HTTP servers using popular Rust APIs.

- [The axum API](#the-warp-api)
- [The hyper API](#the-hyper-api)

<!-- prettier-ignore -->
:::note
Before we start, [you need to have Rust and WasmEdge installed](../setup.md).
Make sure that you read the [special notes on networking apps](../setup#special-notes) especially if you are compiling Rust programs on a Mac.
:::

## The axum API

The [axum](https://github.com/tokio-rs/axum) crate is the most popular HTTP server framework in the Rust Tokio ecosystem.
It is also the web framework for many popular services such as the [flows.network](https://flows.network) serverless platform for workflow functions.

Use the axum API to create an asynchronous HTTP server. Build and run [the example](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/server-axum/) in WasmEdge as follows.

```bash
git clone https://github.com/WasmEdge/wasmedge_hyper_demo
cd wasmedge_hyper_demo/server-axum

# Build the Rust code
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release
# Use the AoT compiler for better performance
wasmedge compile target/wasm32-wasi/release/wasmedge_axum_server.wasm wasmedge_axum_server.wasm

# Run the example
wasmedge wasmedge_axum_server.wasm
```

Then from another terminal, you can request the server. The HTTP server echoes the request data and sends back the response.

```bash
$ curl http://localhost:8080/echo -X POST -d ""WasmEdge""
WasmEdge
```

In your Rust application, you will apply a few patches developed by the WasmEdge community to replace
POSIX sockets with WasmEdge sockets in standard libraries. With those patches, you can then
use the official `tokio` and `axum` crates.

```
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }
socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }
hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }

[dependencies]
axum = ""0.6""
bytes = ""1""
futures-util = ""0.3.30""
tokio = { version = ""1"", features = [""rt"", ""macros"", ""net"", ""time"", ""io-util""]}
```

The [Rust example code](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/server-axum/src/main.rs) below shows an HTTP server that responds to incoming requests for the `/` and `/echo` URL endpoints.

```rust
#[tokio::main(flavor = ""current_thread"")]
async fn main() {
    // build our application with a route
    let app = Router::new()
        .route(""/"", get(help))
        .route(""/echo"", post(echo));

    // run it
    let addr = ""0.0.0.0:8080"";
    let tcp_listener = TcpListener::bind(addr).await.unwrap();
    println!(""listening on {}"", addr);
    axum::Server::from_tcp(tcp_listener.into_std().unwrap())
        .unwrap()
        .serve(app.into_make_service())
        .await
        .unwrap();
}
```

The  `echo()` function is called when a `POST` request is received at `/echo`. The function receives and processes
the request body and returns bytes that are sent back as the response message.

```rust
async fn echo(mut stream: BodyStream) -> Bytes {
    if let Some(Ok(s)) = stream.next().await {
        s
    } else {
        Bytes::new()
    }
}
```

## The hyper API

The `hyper` crate is an excellent library for building HTTP servers using customizable low level APIs. Build and run [the example](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/server/) in WasmEdge as follows.

```bash
git clone https://github.com/WasmEdge/wasmedge_hyper_demo
cd wasmedge_hyper_demo/server

# Build the Rust code
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release
# Use the AoT compiler to get better performance
wasmedge compile target/wasm32-wasi/release/wasmedge_hyper_server.wasm wasmedge_hyper_server.wasm

# Run the example
wasmedge wasmedge_hyper_server.wasm
```

Then from another terminal, you can request the server. The HTTP server echoes the request data and sends back the response.

```bash
$ curl http://localhost:8080/echo -X POST -d ""WasmEdge""
WasmEdge
```

In your Rust application, import the [hyper](https://crates.io/crates/hyper) and [tokio](https://crates.io/crates/tokio) crates, as well as the WasmEdge patches. Just add the following lines to your `Cargo.toml`.

```toml
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }
socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }
hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }

[dependencies]
hyper = { version = ""0.14"", features = [""full""]}
tokio = { version = ""1"", features = [""rt"", ""macros"", ""net"", ""time"", ""io-util""]}
```

The [Rust example code](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/server/src/main.rs) below shows an HTTP server that echoes back any incoming request.

```rust
async fn echo(req: Request<Body>) -> Result<Response<Body>, hyper::Error> {
    match (req.method(), req.uri().path()) {
        // Serve some instructions at /
        (&Method::GET, ""/"") => Ok(Response::new(Body::from(
            ""Try POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`"",
        ))),

        // Simply echo the body back to the client.
        (&Method::POST, ""/echo"") => Ok(Response::new(req.into_body())),

        (&Method::POST, ""/echo/reversed"") => {
            let whole_body = hyper::body::to_bytes(req.into_body()).await?;

            let reversed_body = whole_body.iter().rev().cloned().collect::<Vec<u8>>();
            Ok(Response::new(Body::from(reversed_body)))
        }

        // Return the 404 Not Found for other routes.
        _ => {
            let mut not_found = Response::default();
            *not_found.status_mut() = StatusCode::NOT_FOUND;
            Ok(not_found)
        }
    }
}
```
","**Summary**

The provided code is a tutorial on building HTTP servers in Rust using two popular frameworks: Axum and Hyper. The tutorial covers setting up the environment, creating an asynchronous HTTP server, handling requests and responses, and reversing request bodies.

**Key Components**

1. **Axum API**: A popular HTTP server framework in the Rust Tokio ecosystem.
2. **Hyper API**: A customizable low-level library for building HTTP servers.
3. **WasmEdge**: A cloud-native runtime for microservices that supports HTTP servers.
4. **Tokio**: A runtime for asynchronous I/O operations.
5. **Cargo.toml**: The file that contains the dependencies and configuration for the Rust project.

**Functionality**

The code demonstrates how to:

1. Create an asynchronous HTTP server using Axum.
2. Handle requests and responses using Axum's routing system.
3. Reverse request bodies using Hyper's `to_bytes` method.
4. Serve instructions and echo back incoming requests using various routes.
5. Use WasmEdge patches to replace POSIX sockets with WasmEdge sockets.

**Potential Issues or Areas for Improvement**

1. **Error Handling**: The code does not handle errors well, especially when dealing with asynchronous operations.
2. **Code Organization**: The example code could be refactored to separate concerns and make it easier to maintain.
3. **Testing**: The tutorial does not include any tests for the HTTP server or its functionality.

**Recommendations**

1. Improve error handling using Rust's `Result` and `Option` types.
2. Organize code into separate modules or functions for better modularity.
3. Write unit tests for the HTTP server and its components to ensure correct behavior."
docs/develop/deploy/gpu/podman_wasm_gpu.md,"---
sidebar_position: 6
---

# Podman + WASM + GPU

Podman + Crun with Wasmedge + [CDI](https://github.com/cncf-tags/container-device-interface) to enable the usage of host GPU devices. Most of the steps are the same with [docker + wasm + gpu](./docker_wasm_gpu.md), except for the installation of Podman and execution command. If the following steps have already been executed before, you could just skip them.

## Prerequisite

Before we start, you need

- GPU device (Here we will take NVIDIA graphics cards as our example and we have only conducted tests on NVIDIA GPUs on linux for now)
  - Install NVIDIA GPU Driver
  - Install either the NVIDIA Container Toolkit or you installed the nvidia-container-toolkit-base package.
- Podman >= 4.x

Regarding the installation of the NVIDIA driver and toolkit, we won't go into detail here, but we could provide a few reference documents and the ways to verify your environment is ok.

[Nvidia drivers installation on ubuntu](https://ubuntu.com/server/docs/nvidia-drivers-installation), [Toolkit install guide](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html), [Nvidia CDI supoort reference](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/cdi-support.html)

```bash
# check your driver and device
> nvidia-smi -L

# Check your toolkit
> nvidia-ctk --version
```

Install podman >= 4.0

The current testing phase involves directly installing Podman from Linuxbrew to meet version requirements. There may be more elegant methods in the future, and we will update the documentation accordingly.

```bash
> brew install podman

# Check your podman version and you could add it to your $PATH, too.
> $HOME/.linuxbrew/opt/podman/bin/podman --version
```

## CDI setup

[Generate the CDI specification file](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/cdi-support.html#procedure)

```bash
> sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml

# Check you cdi config is good
> nvidia-ctk cdi list

# Example output
INFO[0000] Found 2 CDI devices
nvidia.com/gpu=0
nvidia.com/gpu=all
```

## Setup your container runtime (crun + wasmedge + plugin system)

Build crun with wasmedge enable

```bash
> sudo apt install -y make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake

> git clone https://github.com/containers/crun
> cd crun
> ./autogen.sh
> ./configure --with-wasmedge
> make

# Check your crun
> ./crun --version
```

Download ggml plugin into host

```bash
> curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-ggml

# Make sure all your plugin dependencies is good
> ldd ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so
```

## Demo llama with our wasm application

> The demo image is built the Wasm application from [here](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/wasmedge-ggml/llama), and upload it to [here](https://github.com/captainvincent/runwasi/pkgs/container/runwasi-demo/195178675?tag=wasmedge-ggml-llama).

Download inference model

```bash
> curl -LO https://huggingface.co/second-state/Llama-2-7B-Chat-GGUF/resolve/main/llama-2-7b-chat.Q5_K_M.gguf
```

Podman run llama2 inference

> You need to replace the  `<podman path>` and `<crun path>` with your binary path in the following command.

```bash
sudo <podman path> run -v ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so:/.wasmedge/plugin/libwasmedgePluginWasiNN.so \
  -v /usr/local/cuda/targets/x86_64-linux/lib/libcudart.so.12:/lib/x86_64-linux-gnu/libcudart.so.12 \
  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublas.so.12:/lib/x86_64-linux-gnu/libcublas.so.12 \
  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublasLt.so.12:/lib/x86_64-linux-gnu/libcublasLt.so.12 \
  -v /lib/x86_64-linux-gnu/libcuda.so.1:/lib/x86_64-linux-gnu/libcuda.so.1 \
  -v .:/resource \
  --env WASMEDGE_PLUGIN_PATH=/.wasmedge/plugin \
  --env WASMEDGE_WASINN_PRELOAD=default:GGML:AUTO:/resource/llama-2-7b-chat.Q5_K_M.gguf \
  --env n_gpu_layers=100 \
  --rm --device nvidia.com/gpu=all --runtime <crun path> --annotation module.wasm.image/variant=compat-smart --platform wasip1/wasm \
  ghcr.io/captainvincent/runwasi-demo:wasmedge-ggml-llama default \
  $'[INST] <<SYS>>\nYou are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you do not know the answer to a question, please do not share false information.\n<</SYS>>\nWhat is the capital of Japan?[/INST]'
```

Example Result

```bash
ggml_init_cublas: GGML_CUDA_FORCE_MMQ:   no
ggml_init_cublas: CUDA_USE_TENSOR_CORES: yes
ggml_init_cublas: found 1 CUDA devices:
  Device 0: NVIDIA GeForce GTX 1080, compute capability 6.1, VMM: yes
Prompt:
[INST] <<SYS>>
You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you do not know the answer to a question, please do not share false information.
<</SYS>>
What is the capital of Japan?[/INST]
Response:
[INFO] llama_commit: ""4ffcdce2""
[INFO] llama_build_number: 2334
[INFO] Number of input tokens: 140
Thank you for your kind request! The capital of Japan is Tokyo. I'm glad to help! Please let me know if you have any other questions.
[INFO] Number of input tokens: 140
[INFO] Number of output tokens: 34
```
","**Podman + WASM + GPU**

This document outlines the steps to enable the use of host GPU devices with Podman, Crun, and Wasmedge.

**Prerequisites:**

*   A GPU device (NVIDIA graphics cards are used as examples)
*   Installation of NVIDIA GPU Driver
*   Installation of either the NVIDIA Container Toolkit or nvidia-container-toolkit-base package
*   Podman >= 4.x

**Installation Steps:**

1.  **Verify NVIDIA driver and toolkit installation**

    ```
    > nvidia-smi -L
    > nvidia-ctk --version
    ```

2.  **Install podman >= 4.0**

    ```bash
    > brew install podman
    > $HOME/.linuxbrew/opt/podman/bin/podman --version
    ```
3.  **CDI setup**

    *   Generate CDI specification file using `nvidia-ctk cdi generate`

        ```
        > sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml
        > nvidia-ctk cdi list
        ```
4.  **Setup container runtime (crun + wasmedge + plugin system)**

    *   Build crun with Wasmedge enabled using `./configure --with-wasmedge`

        ```
        > git clone https://github.com/containers/crun
        > cd crun
        > ./autogen.sh
        > ./configure --with-wasmedge
        > make
        > ./crun --version
        ```
    *   Download ggml plugin using `curl -sSf`

        ```bash
        > curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-ggml
        > ldd ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so
        ```
5.  **Demo llama with our wasm application**

    *   Download inference model using `curl`

        ```bash
        > curl -LO https://huggingface.co/second-state/Llama-2-7B-Chat-GGUF/resolve/main/llama-2-7b-chat.Q5_K_M.gguf
        ```
    *   Run llama2 inference using podman

        ```bash
        sudo <podman path> run -v ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so:/.wasmedge/plugin/libwasmedgePluginWasiNN.so \
          -v /usr/local/cuda/targets/x86_64-linux/lib/libcudart.so.12:/lib/x86_64-linux-gnu/libcudart.so.12 \
          -v /usr/local/cuda/targets/x86_64-linux/lib/libcublas.so.12:/lib/x86_64-linux-gnu/libcublas.so.12 \
          -v /usr/local/cuda/targets/x86_64-linux/lib/libcublasLt.so.12:/lib/x86_64-linux-gnu/libcublasLt.so.12 \
          -v /lib/x86_64-linux-gnu/libcuda.so.1:/lib/x86_64-linux-gnu/libcuda.so.1 \
          -v .:/resource \
          --env WASMEDGE_PLUGIN_PATH=/.wasmedge/plugin \
          --env WASMEDGE_WASINN_PRELOAD=default:GGML:AUTO:/resource/llama-2-7b-chat.Q5_K_M.gguf \
          --env n_gpu_layers=100 \
          --rm --device nvidia.com/gpu=all --runtime <crun path> --annotation module.wasm.image/variant=compat-smart --platform wasip1/wasm \
          ghcr.io/captainvincent/runwasi-demo:wasmedge-ggml-llama default \
          $'[INST] <<SYS>>\nYou are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you do not know the answer to a question, please do not share false information.\n<</SYS>>\nWhat is the capital of Japan?[/INST]'
        ```

The code provided is a comprehensive guide for setting up Podman with WASM and GPU on an NVIDIA graphics card. It includes installation steps for necessary packages, configuration files, and sample use cases to get started with running machine learning models using this setup.

**Potential Issues:**

*   **Inconsistent package versions**: Make sure all the installed packages are compatible with each other.
*   **Incorrect plugin configurations**: Double-check the WASM plugin configuration in `~/.wasmedge/plugin/libwasmedgePluginWasiNN.so` to ensure it points to the correct location.
*   **GPU device availability**: Ensure that there is a working NVIDIA GPU available on your system before attempting to run the demo.

**Improvement Suggestions:**

*   **Simplify package installation process**: Consider using automated package management tools like `pip` or `conda` to install necessary packages instead of manually downloading and installing them.
*   **Provide detailed logs for debugging**: Include verbose logging options in the code to make it easier to diagnose issues during execution.
*   **Update documentation with recent versions**: Keep the documentation up-to-date with the latest package versions and configuration files.

With these suggestions, you can create a more robust and user-friendly guide for setting up Podman with WASM and GPU on an NVIDIA graphics card."
i18n/zh/docusaurus-plugin-content-docs/current/start/build-and-run/podman_wasm_gpu.md,"---
sidebar_position: 6
---

# Podman + WASM + GPU

Podman + Crun with Wasmedge + [CDI](https://github.com/cncf-tags/container-device-interface) to enable the usage of host GPU devices. Most of the steps are the same with [docker + wasm + gpu](./docker_wasm_gpu.md), except for the installation of Podman and execution command. If the following steps have already been executed before, you could just skip them.

## Prerequisite

Before we start, you need

- GPU device (Here we will take NVIDIA graphics cards as our example and we have only conducted tests on NVIDIA GPUs on linux for now)
  - Install NVIDIA GPU Driver
  - Install either the NVIDIA Container Toolkit or you installed the nvidia-container-toolkit-base package.
- Podman >= 4.x

Regarding the installation of the NVIDIA driver and toolkit, we won't go into detail here, but we could provide a few reference documents and the ways to verify your environment is ok.

[Nvidia drivers installation on ubuntu](https://ubuntu.com/server/docs/nvidia-drivers-installation), [Toolkit install guide](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html), [Nvidia CDI supoort reference](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/cdi-support.html)

```bash
# check your driver and device
> nvidia-smi -L

# Check your toolkit
> nvidia-ctk --version
```

Install podman >= 4.0

The current testing phase involves directly installing Podman from Linuxbrew to meet version requirements. There may be more elegant methods in the future, and we will update the documentation accordingly.

```bash
> brew install podman

# Check your podman version and you could add it to your $PATH, too.
> $HOME/.linuxbrew/opt/podman/bin/podman --version
```

## CDI setup

[Generate the CDI specification file](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/cdi-support.html#procedure)

```bash
> sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml

# Check you cdi config is good
> nvidia-ctk cdi list

# Example output
INFO[0000] Found 2 CDI devices
nvidia.com/gpu=0
nvidia.com/gpu=all
```

## Setup your container runtime (crun + wasmedge + plugin system)

Build crun with wasmedge enable

```bash
> sudo apt install -y make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake

> git clone https://github.com/containers/crun
> cd crun
> ./autogen.sh
> ./configure --with-wasmedge
> make

# Check your crun
> ./crun --version
```

Download ggml plugin into host

```bash
> curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-ggml

# Make sure all your plugin dependencies is good
> ldd ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so
```

## Demo llama with our wasm application

> The demo image is built the Wasm application from [here](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/wasmedge-ggml/llama), and upload it to [here](https://github.com/captainvincent/runwasi/pkgs/container/runwasi-demo/195178675?tag=wasmedge-ggml-llama).

Download inference model

```bash
> curl -LO https://huggingface.co/second-state/Llama-2-7B-Chat-GGUF/resolve/main/llama-2-7b-chat.Q5_K_M.gguf
```

Podman run llama2 inference

> You need to replace the  `<podman path>` and `<crun path>` with your binary path in the following command.

```bash
sudo <podman path> run -v ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so:/.wasmedge/plugin/libwasmedgePluginWasiNN.so \
  -v /usr/local/cuda/targets/x86_64-linux/lib/libcudart.so.12:/lib/x86_64-linux-gnu/libcudart.so.12 \
  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublas.so.12:/lib/x86_64-linux-gnu/libcublas.so.12 \
  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublasLt.so.12:/lib/x86_64-linux-gnu/libcublasLt.so.12 \
  -v /lib/x86_64-linux-gnu/libcuda.so.1:/lib/x86_64-linux-gnu/libcuda.so.1 \
  -v .:/resource \
  --env WASMEDGE_PLUGIN_PATH=/.wasmedge/plugin \
  --env WASMEDGE_WASINN_PRELOAD=default:GGML:AUTO:/resource/llama-2-7b-chat.Q5_K_M.gguf \
  --env n_gpu_layers=100 \
  --rm --device nvidia.com/gpu=all --runtime <crun path> --annotation module.wasm.image/variant=compat-smart --platform wasip1/wasm \
  ghcr.io/captainvincent/runwasi-demo:wasmedge-ggml-llama default \
  $'[INST] <<SYS>>\nYou are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you do not know the answer to a question, please do not share false information.\n<</SYS>>\nWhat is the capital of Japan?[/INST]'
```

Example Result

```bash
ggml_init_cublas: GGML_CUDA_FORCE_MMQ:   no
ggml_init_cublas: CUDA_USE_TENSOR_CORES: yes
ggml_init_cublas: found 1 CUDA devices:
  Device 0: NVIDIA GeForce GTX 1080, compute capability 6.1, VMM: yes
Prompt:
[INST] <<SYS>>
You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you do not know the answer to a question, please do not share false information.
<</SYS>>
What is the capital of Japan?[/INST]
Response:
[INFO] llama_commit: ""4ffcdce2""
[INFO] llama_build_number: 2334
[INFO] Number of input tokens: 140
Thank you for your kind request! The capital of Japan is Tokyo. I'm glad to help! Please let me know if you have any other questions.
[INFO] Number of input tokens: 140
[INFO] Number of output tokens: 34
```
","**Summary**

This document provides a step-by-step guide to setting up and running a Wasm (WebAssembly) application on a Podman container using NVIDIA GPU acceleration. The setup involves installing the necessary tools, including Podman, Crun, Wasmedge, and the ggml plugin system.

**Key Components**

1. **Podman**: A daemonless container engine that allows users to run containers on a Linux system.
2. **Crun**: A lightweight runtime for running containers on Linux.
3. **Wasmedge**: A WebAssembly runtime that provides GPU acceleration for Wasm applications.
4. **ggml plugin system**: A set of plugins that enable Wasmedge to run ggml (Geometric General Matrix Library) applications.

**Prerequisites**

1. NVIDIA GPU device
2. NVIDIA driver installed
3. NVIDIA Container Toolkit or nvidia-container-toolkit-base package installed

**Steps**

1. Install Podman 4.x
2. Configure the container runtime (Crun + Wasmedge + plugin system)
	* Build Crun with Wasmedge enable
	* Download and install ggml plugin into host
3. Set up CDI (Container Device Interface) for GPU acceleration
	* Generate the CDI specification file using nvidia-ctk cdi generate command
4. Create a Wasm application using the ggml library
5. Push the application to a container registry (e.g., ghcr.io)
6. Run the container with NVIDIA GPU acceleration

**Potential Issues**

1. **GPU device not detected**: Make sure the NVIDIA driver is installed and configured properly.
2. **Wasmedge plugin not found**: Check that the ggml plugin has been installed correctly.
3. **Crun not working**: Try rebuilding Crun with Wasmedge enable or reinstalling Crun.
4. **Podman version issue**: Ensure that Podman 4.x is installed.

**Improvement Suggestions**

1. Simplify the installation process for users who are not familiar with Linux containerization.
2. Provide more detailed documentation on troubleshooting GPU acceleration issues.
3. Consider using a more user-friendly interface for configuring CDI and Wasmedge settings.
4. Improve performance by optimizing the ggml plugin system for better memory management."
docs/develop/rust/wasinn/tf_plugin.md,"---
sidebar_position: 5
---

# TensorFlow Plug-in For WasmEdge

Developers can use [WASI-NN](https://github.com/WebAssembly/wasi-nn) to inference the models. However, for the TensorFlow and TensorFlow-Lite users, the WASI-NN APIs could be more friendly to retrieve the input and output tensors. Therefore WasmEdge provides the TensorFlow-related plug-in and rust SDK for inferencing models in WASM.

<!-- prettier-ignore -->
:::info
This is not a WASI-NN compatible plug-in. If you are finding the plug-ins working with the [WASI-NN crate](https://crates.io/crates/wasi-nn), please follow the [tensorflow-lite backend](tensorflow_lite.md) instead.
:::

## Prerequisite

Please ensure that you [Rust and WasmEdge installed](../setup.md).

Developers will add the [`wasmedge_tensorflow_interface` crate](https://crates.io/crates/wasmedge_tensorflow_interface) as a dependency to their `Rust -> Wasm` applications. For example, add the following line to the application's `Cargo.toml` file.

```toml
[dependencies]
wasmedge_tensorflow_interface = ""0.3.0""
```

Developers will bring the functions of `wasmedge_tensorflow_interface` into scope within their `Rust -> Wasm` application's code. For example, adding the following code to the top of their `main.rs`.

```rust
use wasmedge_tensorflow_interface;
```

## Image Loading And Conversion

In this crate, we provide several functions to decode and convert images into tensors using the `WasmEdge-Image` host functions.

To use these functions in WASM and execute in WasmEdge, users should [install WasmEdge with WasmEdge-Image plug-in](../../../start/install.md#wasmedge-image-plug-in).

For decoding the `JPEG` images, there are:

```rust
// Function to decode JPEG from buffer and resize to RGB8 format.
pub fn load_jpg_image_to_rgb8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>
// Function to decode JPEG from buffer and resize to BGR8 format.
pub fn load_jpg_image_to_bgr8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>
// Function to decode JPEG from buffer and resize to RGB32F format.
pub fn load_jpg_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>
// Function to decode JPEG from buffer and resize to BGR32F format.
pub fn load_jpg_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>
```

For decoding the `PNG` images, there are:

```rust
// Function to decode PNG from buffer and resize to RGB8 format.
pub fn load_png_image_to_rgb8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>
// Function to decode PNG from buffer and resize to BGR8 format.
pub fn load_png_image_to_bgr8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>
// Function to decode PNG from buffer and resize to RGB32F format.
pub fn load_png_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>
// Function to decode PNG from buffer and resize to BGR32F format.
pub fn load_png_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>
```

Developers can load, decode, and resize image as following:

```rust
let mut file_img = File::open(""sample.jpg"").unwrap();
let mut img_buf = Vec::new();
file_img.read_to_end(&mut img_buf).unwrap();
let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb32f(&img_buf, 224, 224);
// The flat_img is a vec<f32> which contains normalized image in rgb32f format and resized to 224x224.
```

## Inferring TensorFlow And TensorFlow-Lite Models

For using the `TFSession` struct to inference the TensorFlow models and executing in WasmEdge, users should install the [WasmEdge-TensorFlow plug-in with dependencies](../../../start/install.md#wasmedge-tensorflow-plug-in).

For using the `TFLiteSession` struct and to inference the TensorFlow-Lite models executing in WasmEdge, users should install the [WasmEdge-TensorFlowLite plug-in with dependencies](../../../start/install.md#wasmedge-tensorflow-lite-plug-in).

### Create Session

First, developers should create a session to load the TensorFlow or TensorFlow-Lite model.

```rust
// The mod_buf is a vec<u8> which contains the model data.
let mut session = wasmedge_tensorflow_interface::TFSession::new(&mod_buf);
```

The above function creates the session for TensorFlow frozen models. Developers can use the `new_from_saved_model` function to create from saved-models:

```rust
// The mod_path is a &str which is the path to saved-model directory.
// The second argument is the list of tags.
let mut session = wasmedge_tensorflow_interface::TFSession::new_from_saved_model(model_path, &[""serve""]);
```

Or use the `TFLiteSession` to create a session for inferring the `tflite` models.

```rust
// The mod_buf is a vec<u8> which contains the model data.
let mut session = wasmedge_tensorflow_interface::TFLiteSession::new(&mod_buf);
```

### Prepare Input Tensors

```rust
// The flat_img is a vec<f32> which contains normalized image in rgb32f format.
session.add_input(""input"", &flat_img, &[1, 224, 224, 3])
       .add_output(""MobilenetV2/Predictions/Softmax"");
```

### Run TensorFlow Models

```rust
session.run();
```

### Convert Output Tensors

```rust
let res_vec: Vec<f32> = session.get_output(""MobilenetV2/Predictions/Softmax"");
```

## Build And Execution

After completing your code, you can follow the command to compile into WASM.

```bash
cargo build --target=wasm32-wasi
```

The output WASM file will be at `target/wasm32-wasi/debug/` or `target/wasm32-wasi/release`.

Please refer to [WasmEdge CLI](../../../start/build-and-run/cli.md) for WASM execution.

## Examples

<!-- prettier-ignore -->
:::info
Work in Progress
:::

## Old WasmEdge TensorFlow extension

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Summary**

The provided code is a TensorFlow plug-in for WasmEdge, which provides an interface for inference of models using the TensorFlow and TensorFlow-Lite frameworks. The plug-in includes functions to load and decode images, create sessions for model inference, prepare input tensors, run models, and convert output tensors.

**Key Components**

1. **Image Loading and Conversion**: The code provides functions to load and decode images in various formats (JPEG and PNG) into tensors using the WasmEdge-Image host functions.
2. **Session Creation**: The code includes functions to create sessions for model inference using the `TFSession` struct for TensorFlow frozen models and the `TFLiteSession` struct for TensorFlow-Lite models.
3. **Input Tensor Preparation**: The code provides a function to add input tensors to the session using the `add_input` method.
4. **Model Inference**: The code includes a function to run the model using the `run` method.
5. **Output Tensor Conversion**: The code provides a function to convert output tensors from the session using the `get_output` method.

**Potential Issues and Areas for Improvement**

1. **Compatibility**: The code is specific to WasmEdge and may not be compatible with other WebAssembly runtimes.
2. **Error Handling**: The code lacks robust error handling, which could lead to crashes or unexpected behavior in case of errors.
3. **Code Organization**: The code is organized into multiple files, but the file structure and organization could be improved for better maintainability.
4. **Documentation**: While the code includes some documentation, it would benefit from more detailed explanations and examples.

**Best Practices**

1. **Follow naming conventions**: The code follows Rust naming conventions, which makes it easier to read and understand.
2. **Use comments and documentation**: The code includes some comments and documentation, but could benefit from more comprehensive explanations.
3. **Keep functions short and focused**: The code includes long functions that perform multiple tasks, which can make them harder to understand and maintain.

**Recommendations**

1. **Improve error handling**: Add robust error handling mechanisms to handle unexpected errors and exceptions.
2. **Refactor code organization**: Reorganize the code into more manageable modules or packages for better maintainability.
3. **Add more documentation**: Provide more detailed explanations, examples, and use cases for each function and module.
4. **Test the code**: Add comprehensive unit tests to ensure the correctness and reliability of the code."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tf_plugin.md,"---
sidebar_position: 5
---

# TensorFlow Plug-in For WasmEdge

Developers can use [WASI-NN](https://github.com/WebAssembly/wasi-nn) to inference the models. However, for the TensorFlow and TensorFlow-Lite users, the WASI-NN APIs could be more friendly to retrieve the input and output tensors. Therefore WasmEdge provides the TensorFlow-related plug-in and rust SDK for inferencing models in WASM.

<!-- prettier-ignore -->
:::info
This is not a WASI-NN compatible plug-in. If you are finding the plug-ins working with the [WASI-NN crate](https://crates.io/crates/wasi-nn), please follow the [tensorflow-lite backend](tensorflow_lite.md) instead.
:::

## Prerequisite

Please ensure that you [Rust and WasmEdge installed](../setup.md).

Developers will add the [`wasmedge_tensorflow_interface` crate](https://crates.io/crates/wasmedge_tensorflow_interface) as a dependency to their `Rust -> Wasm` applications. For example, add the following line to the application's `Cargo.toml` file.

```toml
[dependencies]
wasmedge_tensorflow_interface = ""0.3.0""
```

Developers will bring the functions of `wasmedge_tensorflow_interface` into scope within their `Rust -> Wasm` application's code. For example, adding the following code to the top of their `main.rs`.

```rust
use wasmedge_tensorflow_interface;
```

## Image Loading And Conversion

In this crate, we provide several functions to decode and convert images into tensors using the `WasmEdge-Image` host functions.

To use these functions in WASM and execute in WasmEdge, users should [install WasmEdge with WasmEdge-Image plug-in](../../../start/install.md#wasmedge-image-plug-in).

For decoding the `JPEG` images, there are:

```rust
// Function to decode JPEG from buffer and resize to RGB8 format.
pub fn load_jpg_image_to_rgb8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>
// Function to decode JPEG from buffer and resize to BGR8 format.
pub fn load_jpg_image_to_bgr8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>
// Function to decode JPEG from buffer and resize to RGB32F format.
pub fn load_jpg_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>
// Function to decode JPEG from buffer and resize to BGR32F format.
pub fn load_jpg_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>
```

For decoding the `PNG` images, there are:

```rust
// Function to decode PNG from buffer and resize to RGB8 format.
pub fn load_png_image_to_rgb8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>
// Function to decode PNG from buffer and resize to BGR8 format.
pub fn load_png_image_to_bgr8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>
// Function to decode PNG from buffer and resize to RGB32F format.
pub fn load_png_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>
// Function to decode PNG from buffer and resize to BGR32F format.
pub fn load_png_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>
```

Developers can load, decode, and resize image as following:

```rust
let mut file_img = File::open(""sample.jpg"").unwrap();
let mut img_buf = Vec::new();
file_img.read_to_end(&mut img_buf).unwrap();
let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb32f(&img_buf, 224, 224);
// The flat_img is a vec<f32> which contains normalized image in rgb32f format and resized to 224x224.
```

## Inferring TensorFlow And TensorFlow-Lite Models

For using the `TFSession` struct to inference the TensorFlow models and executing in WasmEdge, users should install the [WasmEdge-TensorFlow plug-in with dependencies](../../../start/install.md#wasmedge-tensorflow-plug-in).

For using the `TFLiteSession` struct and to inference the TensorFlow-Lite models executing in WasmEdge, users should install the [WasmEdge-TensorFlowLite plug-in with dependencies](../../../start/install.md#wasmedge-tensorflow-lite-plug-in).

### Create Session

First, developers should create a session to load the TensorFlow or TensorFlow-Lite model.

```rust
// The mod_buf is a vec<u8> which contains the model data.
let mut session = wasmedge_tensorflow_interface::TFSession::new(&mod_buf);
```

The above function creates the session for TensorFlow frozen models. Developers can use the `new_from_saved_model` function to create from saved-models:

```rust
// The mod_path is a &str which is the path to saved-model directory.
// The second argument is the list of tags.
let mut session = wasmedge_tensorflow_interface::TFSession::new_from_saved_model(model_path, &[""serve""]);
```

Or use the `TFLiteSession` to create a session for inferring the `tflite` models.

```rust
// The mod_buf is a vec<u8> which contains the model data.
let mut session = wasmedge_tensorflow_interface::TFLiteSession::new(&mod_buf);
```

### Prepare Input Tensors

```rust
// The flat_img is a vec<f32> which contains normalized image in rgb32f format.
session.add_input(""input"", &flat_img, &[1, 224, 224, 3])
       .add_output(""MobilenetV2/Predictions/Softmax"");
```

### Run TensorFlow Models

```rust
session.run();
```

### Convert Output Tensors

```rust
let res_vec: Vec<f32> = session.get_output(""MobilenetV2/Predictions/Softmax"");
```

## Build And Execution

After completing your code, you can follow the command to compile into WASM.

```bash
cargo build --target=wasm32-wasi
```

The output WASM file will be at `target/wasm32-wasi/debug/` or `target/wasm32-wasi/release`.

Please refer to [WasmEdge CLI](../../../start/build-and-run/cli.md) for WASM execution.

## Examples

<!-- prettier-ignore -->
:::info
Work in Progress
:::

## Old WasmEdge TensorFlow extension

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Summary**

The provided code is a documentation for the TensorFlow plug-in and Rust SDK for WasmEdge, which allows developers to infer models in WASM. The code includes examples of loading images, creating sessions, preparing input tensors, running TensorFlow models, and converting output tensors.

**Key Components**

1. **Image Loading**: The code provides functions to decode JPEG and PNG images from buffers and resize them to different formats.
2. **Creating Sessions**: Developers can create a session to load the TensorFlow or TensorFlow-Lite model using the `TFSession` or `TFLiteSession` struct.
3. **Preparing Input Tensors**: The code demonstrates how to add input tensors to the session and specify their shape and data type.
4. **Running TensorFlow Models**: After creating the session and preparing the input tensors, developers can run the TensorFlow model using the `run()` method.
5. **Converting Output Tensors**: The code shows how to retrieve the output tensor from the session and convert it into a Vec of f32 values.

**Potential Issues or Areas for Improvement**

1. **Code Organization**: The documentation includes multiple examples, which can make it difficult to navigate. Consider organizing the code and examples in separate sections.
2. **Error Handling**: The provided code does not include error handling mechanisms. Developers should add try-catch blocks to handle potential errors when working with the WasmEdge TensorFlow extension.
3. **Code Readability**: Some parts of the code, such as the example code, can be improved for readability by using more descriptive variable names and comments.

**Additional Comments**

* The documentation mentions that the code is ""Work in Progress"" for both the old WasmEdge TensorFlow extension and the new examples section. Consider providing a clear plan or timeline for completing these sections.
* The code includes multiple links to external resources, such as the WasmEdge CLI and installation instructions. While this can be helpful, consider including a brief summary of the relevant information in the documentation itself."
docs/embed/go/reference/upgrade_to_0.12.0.md,"---
sidebar_position: 4
---

# Upgrade to WasmEdge-Go v0.12.0

Due to the WasmEdge-Go API breaking changes, this document shows the guideline of programming with WasmEdge-Go API to upgrade from the `v0.11.2` to the `v0.12.0` version.

## Concepts

1. Removed the members of the `wasmedge.HostRegistration` related const values.

   The following const values are removed:

   - `wasmedge.WasmEdge_Process`
   - `wasmedge.WasiNN`
   - `wasmedge.WasiCrypto_Common`
   - `wasmedge.WasiCrypto_AsymmetricCommon`
   - `wasmedge.WasiCrypto_Kx`
   - `wasmedge.WasiCrypto_Signatures`
   - `wasmedge.WasiCrypto_Symmetric`

   The `wasmedge.VM` objects will create and register the host modules automatically now. If the plug-ins are not loaded, the `VM` objects will create and register the mock modules to prevent from import failed.

2. Removed the module instance creation functions of the plug-ins.

   The following APIs are removed:

   - `wasmedge.NewWasiNNModule()`
   - `wasmedge.NewWasiCryptoCommonModule()`
   - `wasmedge.NewWasiCryptoAsymmetricCommonModule()`
   - `wasmedge.NewWasiCryptoKxModule()`
   - `wasmedge.NewWasiCryptoSignaturesModule()`
   - `wasmedge.NewWasiCryptoSymmetricModule()`
   - `wasmedge.NewWasmEdgeProcessModule()`

   For the new examples for creating the module instances from plug-ins, please refer to [the example below](#creating-the-module-instance-from-a-plug-in).

3. New module instance retrieving API of `VM` objects.

   - Added `(*wasmedge.VM).GetRegisteredModule()` for retrieving registered named module in `VM` objects quickly.
   - Added `(*wasmedge.VM).ListRegisteredModule()` for listing registered named modules in `VM` objects quickly.

## The `wasmedge.HostRegistration` const values for plug-ins are not necessary in VM objects

Before the version `v0.11.2`, developers should add the configurations when they want to load the plug-ins in VM:

```go
// Assume that wasi_crypto plug-in is installed in the default plug-in path.
wasmedge.LoadPluginDefaultPaths()

conf := wasmedge.NewConfigure(wasmedge.WASI)
comf.AddConfig(wasmedge.WasiCrypto_Common)
comf.AddConfig(wasmedge.WasiCrypto_AsymmetricCommon)
comf.AddConfig(wasmedge.WasiCrypto_Kx)
comf.AddConfig(wasmedge.WasiCrypto_Signatures)
comf.AddConfig(wasmedge.WasiCrypto_Symmetric)
vm := wasmedge.NewVMWithConfig(conf)
conf.Release()

store := vm.GetStore()
modulelist := store.ListModule()
for _, name := range modulelist {
  fmt.Println(name)
}
// Will print:
//   wasi_ephemeral_crypto_asymmetric_common
//   wasi_ephemeral_crypto_common
//   wasi_ephemeral_crypto_kx
//   wasi_ephemeral_crypto_signatures
//   wasi_ephemeral_crypto_symmetric
vm.Release()
```

After `v0.12.0`, the plug-ins will automatically loaded after the `wasmedge.LoadPluginDefaultPaths()` called or the specific path given into the `wasmedge.LoadPluginFromPath()` API.

For the plug-ins not installed, the mocked modules will be registered into `VM` objects and will print the error message when invoking the host functions to notice the users to install the plug-in.

```go
wasmedge.LoadPluginDefaultPaths()
// The `wasmedge.WASI` is still needed.
conf := wasmedge.NewConfigure(wasmedge.WASI)
vm := wasmedge.NewVMWithConfig(conf)
conf.Release()

modulelist := vm.ListRegisteredModule()
for _, name := range modulelist {
  fmt.Println(name)
}
// Will print:
//   wasi_ephemeral_crypto_asymmetric_common
//   wasi_ephemeral_crypto_common
//   wasi_ephemeral_crypto_kx
//   wasi_ephemeral_crypto_signatures
//   wasi_ephemeral_crypto_symmetric
//   wasi_ephemeral_nn
//   wasi_snapshot_preview1
//   wasmedge_httpsreq
//   wasmedge_process
vm.Release()
```

<!-- prettier-ignore -->
:::note
The `wasmedge.WASI` configuration is still needed if developers want to use the WASI.
:::

## Creating the module instance from a plug-in

When developers didn't use the VM objects to load the plug-ins, they can use the creation functions before the `v0.11.2` versions:

```go
// Assume that wasi_crypto plug-in is installed in the default plug-in path.
wasmedge.LoadPluginDefaultPaths()

cryptocommonmod := wasmedge.NewWasiCryptoCommonModule()

cryptocommonmod.Release()
```

But it not make sense and not extensionable if developers should use different APIs for the different plug-ins.

After the `v0.12.0` version, the `wasmedge.Plugin` struct is added, and developers can use the general API to create the module instances:

```go
// Assume that wasi_crypto plug-in is installed in the default plug-in path.
wasmedge.LoadPluginDefaultPaths()

cryptoplugin := wasmedge.FindPlugin(""wasi_crypto"")
if ctyptoplugin == nil {
  fmt.Println(""FAIL: Cannot find the wasi_crypto plugin."")
  return
}

cryptocommonmod := cryptoplugin.CreateModule(""wasi_crypto_common"")

cryptocommonmod.Release()
```

## Retrieving the module instances from the VM context

Before the version `v0.11.2`, developers can retrieve the `WASI` or the modules from plug-ins with the `wasmedge.HostRegistration` const values, or retrieve the registered modules from the `store` object.

```go
// Assume that wasi_crypto plug-in is installed in the default plug-in path.
wasmedge.LoadPluginDefaultPaths()
conf := wasmedge.NewConfigure(wasmedge.WASI)
comf.AddConfig(wasmedge.WasiCrypto_Common)
comf.AddConfig(wasmedge.WasiCrypto_AsymmetricCommon)
comf.AddConfig(wasmedge.WasiCrypto_Kx)
comf.AddConfig(wasmedge.WasiCrypto_Signatures)
comf.AddConfig(wasmedge.WasiCrypto_Symmetric)
vm := wasmedge.NewVMWithConfig(conf)
conf.Release()

// Get the WASI module instance.
wasimod := vm.GetImportModule(wasmedge.WASI)
// Get the WASI-crypto-common module instance.
cryptocommonmod := vm.GetImportModule(wasmedge.WasiCrypto_Common)

// Get the registered module instance by name.
store := vm.GetStore()
cryptokxmod := store.FindModule(""wasi_ephemeral_crypto_kx"")

vm.Release()
```

After the `v0.12.0` version, due to removing the plug-in related configurations and automatically registering the plug-ins into VM objects, developers cannot use the `(*wasmedge.VM).GetImportModule()` API to retrieve the module instances except the built-in host modules (`WASI` currently).

However, developers can use the new APIs to retrieve the registered module instances more quickly.

```go
// Assume that wasi_crypto plug-in is installed in the default plug-in path.
wasmedge.LoadPluginDefaultPaths()
// Add the WASI configurations.
conf := wasmedge.NewConfigure(wasmedge.WASI)
vm := wasmedge.NewVMWithConfig(conf)
conf.Release()

// Get the WASI module instance.
wasimod := vm.GetImportModule(wasmedge.WASI)
// Get the registered WASI-crypto-common module instance by name.
cryptocommonmod := vm.GetRegisteredModule(""wasi_ephemeral_crypto_common"")

vm.Release()
```
","**Upgrade Guide for WasmEdge-Go v0.12.0**

This guide outlines the changes and improvements in WasmEdge-Go version 0.12.0, specifically focusing on breaking changes to the API.

**Removed Constants and Functions**

The following constants and functions have been removed from the `wasmedge.HostRegistration` struct:

*   `WasmEdge_Process`
*   `WasiNN`
*   `WasiCrypto_Common`
*   `WasiCrypto_AsymmetricCommon`
*   `WasiCrypto_Kx`
*   `WasiCrypto_Signatures`
*   `WasiCrypto_Symmetric`

The corresponding module instance creation functions have also been removed:

*   `NewWasmEdgeProcessModule()`
*   `NewWasiNNModule()`
*   `NewWasiCryptoCommonModule()`
*   `NewWasiCryptoAsymmetricCommonModule()`
*   `NewWasiCryptoKxModule()`
*   `NewWasiCryptoSignaturesModule()`
*   `NewWasiCryptoSymmetricModule()`

**Changes in Loading Plug-ins**

Prior to version 0.11.2, developers needed to add specific configurations when loading plug-ins into VM objects using the following code:
```go
wasmedge.LoadPluginDefaultPaths()
conf := wasmedge.NewConfigure(wasmedge.WASI)
comf.AddConfig(wasmedge.WasiCrypto_Common)
vm := wasmedge.NewVMWithConfig(conf)
```
After version 0.12.0, plug-ins are automatically loaded after calling `wasmedge.LoadPluginDefaultPaths()` or specifying a path in `wasmedge.LoadPluginFromPath()`. If the plug-in is not installed, mocked modules will be registered into VM objects, and an error message will be printed when invoking host functions.

**New APIs for Creating Module Instances**

The new `wasmedge.Plugin` struct provides a general API to create module instances. Before version 0.12.0, different creation functions were needed for each plug-in.

Here's an example:
```go
cryptoplugin := wasmedge.FindPlugin(""wasi_crypto"")
if cryptoplugin == nil {
    fmt.Println(""FAIL: Cannot find the wasi_crypto plugin."")
    return
}

cryptocommonmod := cryptoplugin.CreateModule(""wasi_crypto_common"")
```
**Changes in Retrieving Module Instances**

Prior to version 0.11.2, developers could retrieve WASI or module instances from plug-ins using `wasmedge.HostRegistration` constants or the `store` object.

After version 0.12.0, due to removing plug-in related configurations and automatically registering plug-ins into VM objects, developers cannot use `(*wasmedge.VM).GetImportModule()` to retrieve module instances except built-in host modules (WASI currently).

However, new APIs provide a way to quickly retrieve registered module instances.

Here's an example:
```go
vm := wasmedge.NewVMWithConfig(wasmedge.NewConfigure(wasmedge.WASI))
cryptocommonmod := vm.GetRegisteredModule(""wasi_ephemeral_crypto_common"")
```
Note that these are just some of the key changes and improvements in WasmEdge-Go version 0.12.0. It's recommended to review the complete changelog and documentation for a thorough understanding of all the updates."
i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.12.0.md,"---
sidebar_position: 4
---

# Upgrade to WasmEdge-Go v0.12.0

Due to the WasmEdge-Go API breaking changes, this document shows the guideline of programming with WasmEdge-Go API to upgrade from the `v0.11.2` to the `v0.12.0` version.

## Concepts

1. Removed the members of the `wasmedge.HostRegistration` related const values.

   The following const values are removed:

   - `wasmedge.WasmEdge_Process`
   - `wasmedge.WasiNN`
   - `wasmedge.WasiCrypto_Common`
   - `wasmedge.WasiCrypto_AsymmetricCommon`
   - `wasmedge.WasiCrypto_Kx`
   - `wasmedge.WasiCrypto_Signatures`
   - `wasmedge.WasiCrypto_Symmetric`

   The `wasmedge.VM` objects will create and register the host modules automatically now. If the plug-ins are not loaded, the `VM` objects will create and register the mock modules to prevent from import failed.

2. Removed the module instance creation functions of the plug-ins.

   The following APIs are removed:

   - `wasmedge.NewWasiNNModule()`
   - `wasmedge.NewWasiCryptoCommonModule()`
   - `wasmedge.NewWasiCryptoAsymmetricCommonModule()`
   - `wasmedge.NewWasiCryptoKxModule()`
   - `wasmedge.NewWasiCryptoSignaturesModule()`
   - `wasmedge.NewWasiCryptoSymmetricModule()`
   - `wasmedge.NewWasmEdgeProcessModule()`

   For the new examples for creating the module instances from plug-ins, please refer to [the example below](#creating-the-module-instance-from-a-plug-in).

3. New module instance retrieving API of `VM` objects.

   - Added `(*wasmedge.VM).GetRegisteredModule()` for retrieving registered named module in `VM` objects quickly.
   - Added `(*wasmedge.VM).ListRegisteredModule()` for listing registered named modules in `VM` objects quickly.

## The `wasmedge.HostRegistration` const values for plug-ins are not necessary in VM objects

Before the version `v0.11.2`, developers should add the configurations when they want to load the plug-ins in VM:

```go
// Assume that wasi_crypto plug-in is installed in the default plug-in path.
wasmedge.LoadPluginDefaultPaths()

conf := wasmedge.NewConfigure(wasmedge.WASI)
comf.AddConfig(wasmedge.WasiCrypto_Common)
comf.AddConfig(wasmedge.WasiCrypto_AsymmetricCommon)
comf.AddConfig(wasmedge.WasiCrypto_Kx)
comf.AddConfig(wasmedge.WasiCrypto_Signatures)
comf.AddConfig(wasmedge.WasiCrypto_Symmetric)
vm := wasmedge.NewVMWithConfig(conf)
conf.Release()

store := vm.GetStore()
modulelist := store.ListModule()
for _, name := range modulelist {
  fmt.Println(name)
}
// Will print:
//   wasi_ephemeral_crypto_asymmetric_common
//   wasi_ephemeral_crypto_common
//   wasi_ephemeral_crypto_kx
//   wasi_ephemeral_crypto_signatures
//   wasi_ephemeral_crypto_symmetric
vm.Release()
```

After `v0.12.0`, the plug-ins will automatically loaded after the `wasmedge.LoadPluginDefaultPaths()` called or the specific path given into the `wasmedge.LoadPluginFromPath()` API.

For the plug-ins not installed, the mocked modules will be registered into `VM` objects and will print the error message when invoking the host functions to notice the users to install the plug-in.

```go
wasmedge.LoadPluginDefaultPaths()
// The `wasmedge.WASI` is still needed.
conf := wasmedge.NewConfigure(wasmedge.WASI)
vm := wasmedge.NewVMWithConfig(conf)
conf.Release()

modulelist := vm.ListRegisteredModule()
for _, name := range modulelist {
  fmt.Println(name)
}
// Will print:
//   wasi_ephemeral_crypto_asymmetric_common
//   wasi_ephemeral_crypto_common
//   wasi_ephemeral_crypto_kx
//   wasi_ephemeral_crypto_signatures
//   wasi_ephemeral_crypto_symmetric
//   wasi_ephemeral_nn
//   wasi_snapshot_preview1
//   wasmedge_httpsreq
//   wasmedge_process
vm.Release()
```

<!-- prettier-ignore -->
:::note
The `wasmedge.WASI` configuration is still needed if developers want to use the WASI.
:::

## Creating the module instance from a plug-in

When developers didn't use the VM objects to load the plug-ins, they can use the creation functions before the `v0.11.2` versions:

```go
// Assume that wasi_crypto plug-in is installed in the default plug-in path.
wasmedge.LoadPluginDefaultPaths()

cryptocommonmod := wasmedge.NewWasiCryptoCommonModule()

cryptocommonmod.Release()
```

But it not make sense and not extensionable if developers should use different APIs for the different plug-ins.

After the `v0.12.0` version, the `wasmedge.Plugin` struct is added, and developers can use the general API to create the module instances:

```go
// Assume that wasi_crypto plug-in is installed in the default plug-in path.
wasmedge.LoadPluginDefaultPaths()

cryptoplugin := wasmedge.FindPlugin(""wasi_crypto"")
if ctyptoplugin == nil {
  fmt.Println(""FAIL: Cannot find the wasi_crypto plugin."")
  return
}

cryptocommonmod := cryptoplugin.CreateModule(""wasi_crypto_common"")

cryptocommonmod.Release()
```

## Retrieving the module instances from the VM context

Before the version `v0.11.2`, developers can retrieve the `WASI` or the modules from plug-ins with the `wasmedge.HostRegistration` const values, or retrieve the registered modules from the `store` object.

```go
// Assume that wasi_crypto plug-in is installed in the default plug-in path.
wasmedge.LoadPluginDefaultPaths()
conf := wasmedge.NewConfigure(wasmedge.WASI)
comf.AddConfig(wasmedge.WasiCrypto_Common)
comf.AddConfig(wasmedge.WasiCrypto_AsymmetricCommon)
comf.AddConfig(wasmedge.WasiCrypto_Kx)
comf.AddConfig(wasmedge.WasiCrypto_Signatures)
comf.AddConfig(wasmedge.WasiCrypto_Symmetric)
vm := wasmedge.NewVMWithConfig(conf)
conf.Release()

// Get the WASI module instance.
wasimod := vm.GetImportModule(wasmedge.WASI)
// Get the WASI-crypto-common module instance.
cryptocommonmod := vm.GetImportModule(wasmedge.WasiCrypto_Common)

// Get the registered module instance by name.
store := vm.GetStore()
cryptokxmod := store.FindModule(""wasi_ephemeral_crypto_kx"")

vm.Release()
```

After the `v0.12.0` version, due to removing the plug-in related configurations and automatically registering the plug-ins into VM objects, developers cannot use the `(*wasmedge.VM).GetImportModule()` API to retrieve the module instances except the built-in host modules (`WASI` currently).

However, developers can use the new APIs to retrieve the registered module instances more quickly.

```go
// Assume that wasi_crypto plug-in is installed in the default plug-in path.
wasmedge.LoadPluginDefaultPaths()
// Add the WASI configurations.
conf := wasmedge.NewConfigure(wasmedge.WASI)
vm := wasmedge.NewVMWithConfig(conf)
conf.Release()

// Get the WASI module instance.
wasimod := vm.GetImportModule(wasmedge.WASI)
// Get the registered WASI-crypto-common module instance by name.
cryptocommonmod := vm.GetRegisteredModule(""wasi_ephemeral_crypto_common"")

vm.Release()
```
","**Summary**

The provided code is a guide for upgrading to WasmEdge-Go v0.12.0 from version v0.11.2. It highlights the changes in API, including removed constants and functions, and introduces new APIs for creating module instances from plug-ins.

**Key Components**

1. **Removed Constants**: The `wasmedge.HostRegistration` related const values are removed, which includes `WasmEdge_Process`, `WasiNN`, `WasiCrypto_Common`, etc.
2. **New Module Instance Retrieval API**: Two new APIs are added to retrieve registered named modules in VM objects quickly: `(*wasmedge.VM).GetRegisteredModule()` and `(*wasmedge.VM).ListRegisteredModule()`.
3. **Automatic Plug-in Loading**: After v0.12.0, plug-ins will be automatically loaded after calling `wasmedge.LoadPluginDefaultPaths()` or specifying a path in `wasmedge.LoadPluginFromPath()`. Mocked modules will be registered into VM objects for uninstalled plugins.
4. **Creating Module Instance from Plug-in**: The new `wasmedge.Plugin` struct is introduced to create module instances from plug-ins using general APIs.

**Areas for Improvement**

1. **Documentation**: More detailed documentation and examples would be beneficial for developers upgrading from v0.11.2 to v0.12.0.
2. **Code Examples**: Additional code examples in the guide would help clarify how to use new APIs and best practices for upgrading.
3. **Error Handling**: The guide assumes that plug-ins are installed correctly; however, error handling should be included for scenarios where plugins are not installed or loading fails.
4. **API Consistency**: While the new `wasmedge.Plugin` struct aims to provide a more consistent API, additional consideration should be given to ensure that all APIs are consistent and easy to use.

**Recommendations**

1. Review the guide carefully before upgrading to v0.12.0.
2. Test your application thoroughly after upgrading to ensure compatibility with the new API.
3. Use the new APIs for creating module instances from plug-ins to maintain consistency and ease of use."
docs/develop/deploy/kubernetes/superedge.md,"---
sidebar_position: 5
---

# SuperEdge

SuperEdge is an open-source container management system for edge computing. It extends native Kubernetes to the edge in a non-intrusive way.

<!-- prettier-ignore -->
:::note
This demo is based on containerd + crun.
:::

## Install Superedge

- Download the installation package

<!-- prettier-ignore -->
:::note
Choose an installation package according to your installation node CPU architecture (amd64 or arm64).
:::

```bash
arch=amd64 version=v0.6.0 && rm -rf edgeadm-linux-* && wget https://superedge-1253687700.cos.ap-guangzhou.myqcloud.com/$version/$arch/edgeadm-linux-containerd-$arch-$version.tgz && tar -xzvf edgeadm-linux-* && cd edgeadm-linux-$arch-$version && ./edgeadm
```

- Install edge Kubernetes master node with containerd runtime

```bash
./edgeadm init --kubernetes-version=1.18.2 --image-repository superedge.tencentcloudcr.com/superedge --service-cidr=10.96.0.0/12 --pod-network-cidr=192.168.0.0/16 --install-pkg-path ./kube-linux-*.tar.gz --apiserver-cert-extra-sans=<Master Public IP> --apiserver-advertise-address=<Master Intranet IP> --enable-edge=true --runtime=containerd
```

- Join edge node with containerd runtime

```bash
./edgeadm join <Master Public/Intranet IP Or Domain>:Port --token xxxx --discovery-token-ca-cert-hash sha256:xxxxxxxxxx --install-pkg-path <edgeadm kube-* install package address path> --enable-edge=true --runtime=containerd
```

For other installation, deployment, and administration, see our [**Tutorial**](https://superedge.io/docs/installation/)

## Install WasmEdge

Use the simple install script to install WasmEdge on your edge node.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
```

## Build and install Crun with WasmEdge

The [crun](https://github.com/containers/crun) project has WasmEdge support baked in. For now, the easiest approach is to build it yourself from source. First, let's ensure crun dependencies are installed on your Ubuntu 20.04. For other Linux distributions, please see [here](https://github.com/containers/crun#readme).

```bash
sudo apt update
sudo apt install -y make git gcc build-essential pkgconf libtool \
    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
    go-md2man libtool autoconf python3 automake
```

Next, configure, build, and install a crun binary with WasmEdge support.

```bash
git clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
```

## Reconfigure containerd with crun runtime

Superedge containerd node has default config. We should modify the configuration file(/etc/containerd/config.toml) according to the following steps.

Firstly, we generate `config.toml.diff` diff file and patch it.

```bash
cat > config.toml.diff << EOF
--- /etc/containerd/config.toml 2022-02-14 15:05:40.061562127 +0800
+++ /etc/containerd/config.toml.crun    2022-02-14 15:03:35.846052853 +0800
@@ -24,17 +24,23 @@
   max_concurrent_downloads = 10

   [plugins.cri.containerd]
-        default_runtime_name = ""runc""
-    [plugins.cri.containerd.runtimes.runc]
+        default_runtime_name = ""crun""
+    [plugins.cri.containerd.runtimes.crun]
       runtime_type = ""io.containerd.runc.v2""
-      pod_annotations = []
+      pod_annotations = [""*.wasm.*"", ""wasm.*"", ""module.wasm.image/*"", ""*.module.wasm.image"", ""module.wasm.image/variant.*""]
       container_annotations = []
       privileged_without_host_devices = false
-      [plugins.cri.containerd.runtimes.runc.options]
-        BinaryName = ""runc""
+      [plugins.cri.containerd.runtimes.crun.options]
+        BinaryName = ""crun""
   # cni
   [plugins.cri.cni]
     bin_dir = ""/opt/cni/bin""
     conf_dir = ""/etc/cni/net.d""
     conf_template = """"

+  [plugins.""io.containerd.runtime.v1.linux""]
+    no_shim = false
+    runtime = ""crun""
+    runtime_root = """"
+    shim = ""containerd-shim""
+    shim_debug = false
EOF
```

```bash
sudo patch -d/ -p0 < config.toml.diff
sudo systemctl restart containerd
```

## Create Wasmedge application in Superedge

We can run a wasm image pushed to [dockerhub](https://hub.docker.com/r/hydai/wasm-wasi-example). If you want to learn how to compile, package, and publish the WebAssembly program as a container image to the Docker hub, please refer to [here](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md).

```bash
cat > wasmedge-app.yaml << EOF
apiVersion: v1
kind: Pod
metadata:
  annotations:
    module.wasm.image/variant: compat-smart
  labels:
    run: wasi-demo
  name: wasi-demo
spec:
  containers:
  - args:
    - /wasi_example_main.wasm
    - ""50000000""
    image: wasmedge/example-wasi:latest
    imagePullPolicy: IfNotPresent
    name: wasi-demo
  hostNetwork: true
  restartPolicy: Never
EOF

kubectl create -f wasmedge-app.yaml
```

The output will show by executing `kubectl logs wasi-demo` command.

```bash
Random number: -1643170076
Random bytes: [15, 223, 242, 238, 69, 114, 217, 106, 80, 214, 44, 225, 20, 182, 2, 189, 226, 184, 97, 40, 154, 6, 56, 202, 45, 89, 184, 80, 5, 89, 73, 222, 143, 132, 17, 79, 145, 64, 33, 17, 250, 102, 91, 94, 26, 200, 28, 161, 46, 93, 123, 36, 100, 167, 43, 159, 82, 112, 255, 165, 37, 232, 17, 139, 97, 14, 28, 169, 225, 156, 147, 22, 174, 148, 209, 57, 82, 213, 19, 215, 11, 18, 32, 217, 188, 142, 54, 127, 237, 237, 230, 137, 86, 162, 185, 66, 88, 95, 226, 53, 174, 76, 226, 25, 151, 186, 156, 16, 62, 63, 230, 148, 133, 102, 33, 138, 20, 83, 31, 60, 246, 90, 167, 189, 103, 238, 106, 51]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
```
","**SuperEdge: An Open-Source Container Management System for Edge Computing**

**Overview**

SuperEdge is an open-source container management system designed to extend native Kubernetes to the edge in a non-intrusive way. It provides a comprehensive solution for deploying and managing applications on edge devices, including support for WebAssembly (Wasm) applications.

**Key Features**

1. **Kubernetes Support**: SuperEdge extends Kubernetes to the edge by providing a container runtime environment that can run on edge devices.
2. **WebAssembly Support**: SuperEdge supports Wasm applications through its integration with WasmEdge, a high-performance Wasm runtime.
3. **Containerd Integration**: SuperEdge uses containerd as its default container runtime, which provides improved performance and security features.

**Installation**

To install SuperEdge, follow these steps:

1. Download the installation package for your CPU architecture (amd64 or arm64).
2. Run the installation script to initialize the edge Kubernetes master node with containerd runtime.
3. Join additional edge nodes by running the `edgeadm join` command.

**WasmEdge Installation**

To install WasmEdge, run the following command:
```
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
```
This will download and install WasmEdge on your edge node.

**Building Crun with WasmEdge Support**

To build and install Crun with WasmEdge support, follow these steps:

1. Clone the Crun repository: `git clone https://github.com/containers/crun`.
2. Configure, build, and install Crun with WasmEdge support: `./autogen.sh`, `./configure --with-wasmedge`, `make`, and `sudo make install`.

**Reconfiguring containerd**

To reconfigure containerd to use the Crun runtime, follow these steps:

1. Generate a `config.toml.diff` file containing the necessary changes.
2. Patch the containerd configuration file: `sudo patch -d/ -p0 < config.toml.diff`.
3. Restart the containerd service: `sudo systemctl restart containerd`.

**Creating a Wasm Application in SuperEdge**

To create a Wasm application in SuperEdge, follow these steps:

1. Create a YAML file defining the pod with the Wasm image: `cat > wasmedge-app.yaml << EOF`.
2. Apply the YAML file to create the pod: `kubectl create -f wasmedge-app.yaml`.

This will deploy the Wasm application on the edge node using the SuperEdge container runtime environment.

Note that this is a high-level summary of the installation and configuration process for SuperEdge with Wasm support. For more detailed instructions, please refer to the official documentation and repository resources."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/superedge.md,"---
sidebar_position: 5
---

# SuperEdge

SuperEdge is an open-source container management system for edge computing. It extends native Kubernetes to the edge in a non-intrusive way.

<!-- prettier-ignore -->
:::note
This demo is based on containerd + crun.
:::

## Install Superedge

- Download the installation package

<!-- prettier-ignore -->
:::note
Choose an installation package according to your installation node CPU architecture (amd64 or arm64).
:::

```bash
arch=amd64 version=v0.6.0 && rm -rf edgeadm-linux-* && wget https://superedge-1253687700.cos.ap-guangzhou.myqcloud.com/$version/$arch/edgeadm-linux-containerd-$arch-$version.tgz && tar -xzvf edgeadm-linux-* && cd edgeadm-linux-$arch-$version && ./edgeadm
```

- Install edge Kubernetes master node with containerd runtime

```bash
./edgeadm init --kubernetes-version=1.18.2 --image-repository superedge.tencentcloudcr.com/superedge --service-cidr=10.96.0.0/12 --pod-network-cidr=192.168.0.0/16 --install-pkg-path ./kube-linux-*.tar.gz --apiserver-cert-extra-sans=<Master Public IP> --apiserver-advertise-address=<Master Intranet IP> --enable-edge=true --runtime=containerd
```

- Join edge node with containerd runtime

```bash
./edgeadm join <Master Public/Intranet IP Or Domain>:Port --token xxxx --discovery-token-ca-cert-hash sha256:xxxxxxxxxx --install-pkg-path <edgeadm kube-* install package address path> --enable-edge=true --runtime=containerd
```

For other installation, deployment, and administration, see our [**Tutorial**](https://superedge.io/docs/installation/)

## Install WasmEdge

Use the simple install script to install WasmEdge on your edge node.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
```

## Build and install Crun with WasmEdge

The [crun](https://github.com/containers/crun) project has WasmEdge support baked in. For now, the easiest approach is to build it yourself from source. First, let's ensure crun dependencies are installed on your Ubuntu 20.04. For other Linux distributions, please see [here](https://github.com/containers/crun#readme).

```bash
sudo apt update
sudo apt install -y make git gcc build-essential pkgconf libtool \
    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
    go-md2man libtool autoconf python3 automake
```

Next, configure, build, and install a crun binary with WasmEdge support.

```bash
git clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
```

## Reconfigure containerd with crun runtime

Superedge containerd node has default config. We should modify the configuration file(/etc/containerd/config.toml) according to the following steps.

Firstly, we generate `config.toml.diff` diff file and patch it.

```bash
cat > config.toml.diff << EOF
--- /etc/containerd/config.toml 2022-02-14 15:05:40.061562127 +0800
+++ /etc/containerd/config.toml.crun    2022-02-14 15:03:35.846052853 +0800
@@ -24,17 +24,23 @@
   max_concurrent_downloads = 10

   [plugins.cri.containerd]
-        default_runtime_name = ""runc""
-    [plugins.cri.containerd.runtimes.runc]
+        default_runtime_name = ""crun""
+    [plugins.cri.containerd.runtimes.crun]
       runtime_type = ""io.containerd.runc.v2""
-      pod_annotations = []
+      pod_annotations = [""*.wasm.*"", ""wasm.*"", ""module.wasm.image/*"", ""*.module.wasm.image"", ""module.wasm.image/variant.*""]
       container_annotations = []
       privileged_without_host_devices = false
-      [plugins.cri.containerd.runtimes.runc.options]
-        BinaryName = ""runc""
+      [plugins.cri.containerd.runtimes.crun.options]
+        BinaryName = ""crun""
   # cni
   [plugins.cri.cni]
     bin_dir = ""/opt/cni/bin""
     conf_dir = ""/etc/cni/net.d""
     conf_template = """"

+  [plugins.""io.containerd.runtime.v1.linux""]
+    no_shim = false
+    runtime = ""crun""
+    runtime_root = """"
+    shim = ""containerd-shim""
+    shim_debug = false
EOF
```

```bash
sudo patch -d/ -p0 < config.toml.diff
sudo systemctl restart containerd
```

## Create Wasmedge application in Superedge

We can run a wasm image pushed to [dockerhub](https://hub.docker.com/r/hydai/wasm-wasi-example). If you want to learn how to compile, package, and publish the WebAssembly program as a container image to the Docker hub, please refer to [here](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md).

```bash
cat > wasmedge-app.yaml << EOF
apiVersion: v1
kind: Pod
metadata:
  annotations:
    module.wasm.image/variant: compat-smart
  labels:
    run: wasi-demo
  name: wasi-demo
spec:
  containers:
  - args:
    - /wasi_example_main.wasm
    - ""50000000""
    image: wasmedge/example-wasi:latest
    imagePullPolicy: IfNotPresent
    name: wasi-demo
  hostNetwork: true
  restartPolicy: Never
EOF

kubectl create -f wasmedge-app.yaml
```

The output will show by executing `kubectl logs wasi-demo` command.

```bash
Random number: -1643170076
Random bytes: [15, 223, 242, 238, 69, 114, 217, 106, 80, 214, 44, 225, 20, 182, 2, 189, 226, 184, 97, 40, 154, 6, 56, 202, 45, 89, 184, 80, 5, 89, 73, 222, 143, 132, 17, 79, 145, 64, 33, 17, 250, 102, 91, 94, 26, 200, 28, 161, 46, 93, 123, 36, 100, 167, 43, 159, 82, 112, 255, 165, 37, 232, 17, 139, 97, 14, 28, 169, 225, 156, 147, 22, 174, 148, 209, 57, 82, 213, 19, 215, 11, 18, 32, 217, 188, 142, 54, 127, 237, 237, 230, 137, 86, 162, 185, 66, 88, 95, 226, 53, 174, 76, 226, 25, 151, 186, 156, 16, 62, 63, 230, 148, 133, 102, 33, 138, 20, 83, 31, 60, 246, 90, 167, 189, 103, 238, 106, 51]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
```
","**Summary**

This document describes the installation and deployment of SuperEdge, a container management system for edge computing. It provides instructions on how to install Superedge and its dependencies, including WasmEdge, a WebAssembly runtime. The document also outlines the steps to create a Wasmedge application in Superedge.

**Key Components**

1. **Superedge**: A container management system for edge computing that extends native Kubernetes.
2. **WasmEdge**: A WebAssembly runtime that allows developers to run WebAssembly applications on various platforms, including containers.
3. **crun**: A command-line tool for managing container processes that is used in conjunction with WasmEdge.

**Installation Steps**

1. Install Superedge using the provided installation package.
2. Initialize the edge Kubernetes master node with the specified runtime (containerd).
3. Join an edge node to the cluster and enable it as a containerd node.
4. Build and install crun with WasmEdge support.
5. Configure containerd to use crun as the default runtime.
6. Create a Wasmedge application in Superedge using a YAML file.

**Potential Issues**

1. **Dependency conflicts**: The installation process may encounter dependency conflicts between different packages, which can be resolved by carefully managing package versions and dependencies.
2. **Configuration errors**: Incorrect configuration of containerd or crun may result in errors during the installation process or application deployment.
3. **Security considerations**: Ensure that sensitive information such as API keys and tokens are handled securely during the installation process.

**Improvement Suggestions**

1. **Simplify the installation process**: Consider creating a streamlined installation process that includes automated dependency management and configuration setup.
2. **Improve documentation**: Provide more detailed step-by-step instructions for each component installation, including troubleshooting tips and common issues.
3. **Enhance security features**: Integrate additional security measures, such as encryption and access controls, to ensure the secure deployment of Wasmedge applications in Superedge."
docs/develop/deploy/kubernetes/kubernetes-containerd-crun.md,"---
sidebar_position: 1
---

# Kubernetes + containerd + crun

## Quick start

The [GitHub repo](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on Kubernetes + containerd + crun.

- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd.yml)
- WebAssembly-based HTTP service [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd-server.yml)

In the rest of this section, we will explain the steps in detail.

We assume you have already [installed and configured containerd](../../deploy/cri-runtime/containerd-crun.md) to work with WasmEdge container images.

## Install and start Kubernetes

Run the following commands from a terminal window. It sets up Kubernetes for local development.

```bash
# Install go
$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz
$ sudo rm -rf /usr/local/go
$ sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz
$ source /home/${USER}/.profile

# Clone k8s
$ git clone https://github.com/kubernetes/kubernetes.git
$ cd kubernetes
$ git checkout v1.22.2

# Install etcd with hack script in k8s
$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/install-etcd.sh
$ export PATH=""/home/${USER}/kubernetes/third_party/etcd:${PATH}""
$ sudo cp third_party/etcd/etcd* /usr/local/bin/

# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl

# Build and run k8s with containerd
$ sudo apt-get install -y build-essential
$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/local-up-cluster.sh

... ...
Local Kubernetes cluster is running. Press Ctrl-C to shut it down.
```

Do NOT close your terminal window. Kubernetes is running!

## Run WebAssembly container images in Kubernetes

Finally, we can run WebAssembly programs in Kubernetes as containers in pods. In this section, we will start from **another terminal window** and start using the cluster.

```bash
export KUBERNETES_PROVIDER=local

sudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt
sudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt
sudo cluster/kubectl.sh config set-context local --cluster=local --user=myself
sudo cluster/kubectl.sh config use-context local
sudo cluster/kubectl.sh
```

Let's check the status to make sure that the cluster is running.

```bash
$ sudo cluster/kubectl.sh cluster-info

# Expected output
Cluster ""local"" set.
User ""myself"" set.
Context ""local"" created.
Switched to context ""local"".
Kubernetes control plane is running at https://localhost:6443
CoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
```

### A simple WebAssembly app

[A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md) explains how to compile, package, and publish a simple WebAssembly WASI program as a container image to Docker hub. Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.

```bash
sudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" --overrides='{""kind"":""Pod"", ""apiVersion"":""v1"", ""spec"": {""hostNetwork"": true}}' /wasi_example_main.wasm 50000000
```

The output from the containerized application is printed into the console.

```bash
Random number: 401583443
Random bytes: [192, 226, 162, 92, 129, 17, 186, 164, 239, 84, 98, 255, 209, 79, 51, 227, 103, 83, 253, 31, 78, 239, 33, 218, 68, 208, 91, 56, 37, 200, 32, 12, 106, 101, 241, 78, 161, 16, 240, 158, 42, 24, 29, 121, 78, 19, 157, 185, 32, 162, 95, 214, 175, 46, 170, 100, 212, 33, 27, 190, 139, 121, 121, 222, 230, 125, 251, 21, 210, 246, 215, 127, 176, 224, 38, 184, 201, 74, 76, 133, 233, 129, 48, 239, 106, 164, 190, 29, 118, 71, 79, 203, 92, 71, 68, 96, 33, 240, 228, 62, 45, 196, 149, 21, 23, 143, 169, 163, 136, 206, 214, 244, 26, 194, 25, 101, 8, 236, 247, 5, 164, 117, 40, 220, 52, 217, 92, 179]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod ""wasi-demo-2"" deleted
```

### A WebAssembly-based HTTP service

[A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md) explains how to compile, package, and publish a simple WebAssembly HTTP service application as a container image to Docker hub. Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.

```bash
sudo cluster/kubectl.sh run --restart=Never http-server --image=wasmedge/example-wasi-http:latest --annotations=""module.wasm.image/variant=compat-smart"" --overrides='{""kind"":""Pod"", ""apiVersion"":""v1"", ""spec"": {""hostNetwork"": true}}'
```

Since we are using `hostNetwork` in the `kubectl run` command, the HTTP server image is running on the local network with IP address `127.0.0.1`. Now, you can use the `curl` command to access the HTTP service.

```bash
$ curl -d ""name=WasmEdge"" -X POST http://127.0.0.1:1234
echo: name=WasmEdge
```

That's it!
","**Summary**

This document provides a tutorial on deploying and running WebAssembly containers in a Kubernetes cluster using containerd and crun. It guides the reader through installing and setting up Kubernetes, building and running WebAssembly-based images from Docker Hub, and accessing their outputs.

**Key Components**

1. **Kubernetes**: A container orchestration system for automating deployment, scaling, and management of containers.
2. **containerd**: A low-level container runtime that manages the execution of containers.
3. **crun**: A Linux capability to run processes in user namespaces without needing a full-featured kernel.
4. **WebAssembly**: A binary format for executing code on web browsers or other environments.

**Steps**

1. Install and configure containerd.
2. Set up Kubernetes for local development.
3. Clone the k8s repository and checkout a specific version (v1.22.2).
4. Build and run a local Kubernetes cluster using `./hack/local-up-cluster.sh`.
5. Run WebAssembly containers in Kubernetes as follows:

```bash
sudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" --overrides='{""kind"":""Pod"", ""apiVersion"":""v1"", ""spec"": {""hostNetwork"": true}}' /wasi_example_main.wasm 50000000
```

6. Run a WebAssembly-based HTTP service in Kubernetes as follows:

```bash
sudo cluster/kubectl.sh run --restart=Never http-server --image=wasmedge/example-wasi-http:latest --annotations=""module.wasm.image/variant=compat-smart"" --overrides='{""kind"":""Pod"", ""apiVersion"":""v1"", ""spec"": {""hostNetwork"": true}}'
```

**Potential Issues and Areas for Improvement**

1. **Kubernetes version**: The document uses a specific Kubernetes version (v1.22.2). It's essential to verify that the instructions are compatible with newer or older versions.
2. **Container runtime compatibility**: Containerd and crun might have compatibility issues with newer container runtimes like CRI-O or Docker Desktop.
3. **Kubernetes configuration**: The document assumes a specific Kubernetes configuration, which may not be suitable for all environments.
4. **WebAssembly image availability**: The WebAssembly images used in the tutorial might not be available in public registries or may have compatibility issues with newer WebAssembly versions.
5. **Security considerations**: Running WebAssembly containers in a Kubernetes cluster raises security concerns, such as allowing untrusted code execution.

**Additional Resources**

1. Kubernetes documentation: <https://kubernetes.io/docs/>
2. Containerd documentation: <https://containerd.io/>
3. crun documentation: <https://crun.dev/>
4. WebAssembly documentation: <https://webassembly.org/>"
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-crun.md,"---
sidebar_position: 1
---

# Kubernetes + containerd + crun

## Quick start

The [GitHub repo](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on Kubernetes + containerd + crun.

- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd.yml)
- WebAssembly-based HTTP service [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd-server.yml)

In the rest of this section, we will explain the steps in detail.

We assume you have already [installed and configured containerd](../../deploy/cri-runtime/containerd-crun.md) to work with WasmEdge container images.

## Install and start Kubernetes

Run the following commands from a terminal window. It sets up Kubernetes for local development.

```bash
# Install go
$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz
$ sudo rm -rf /usr/local/go
$ sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz
$ source /home/${USER}/.profile

# Clone k8s
$ git clone https://github.com/kubernetes/kubernetes.git
$ cd kubernetes
$ git checkout v1.22.2

# Install etcd with hack script in k8s
$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/install-etcd.sh
$ export PATH=""/home/${USER}/kubernetes/third_party/etcd:${PATH}""
$ sudo cp third_party/etcd/etcd* /usr/local/bin/

# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl

# Build and run k8s with containerd
$ sudo apt-get install -y build-essential
$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/local-up-cluster.sh

... ...
Local Kubernetes cluster is running. Press Ctrl-C to shut it down.
```

Do NOT close your terminal window. Kubernetes is running!

## Run WebAssembly container images in Kubernetes

Finally, we can run WebAssembly programs in Kubernetes as containers in pods. In this section, we will start from **another terminal window** and start using the cluster.

```bash
export KUBERNETES_PROVIDER=local

sudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt
sudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt
sudo cluster/kubectl.sh config set-context local --cluster=local --user=myself
sudo cluster/kubectl.sh config use-context local
sudo cluster/kubectl.sh
```

Let's check the status to make sure that the cluster is running.

```bash
$ sudo cluster/kubectl.sh cluster-info

# Expected output
Cluster ""local"" set.
User ""myself"" set.
Context ""local"" created.
Switched to context ""local"".
Kubernetes control plane is running at https://localhost:6443
CoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
```

### A simple WebAssembly app

[A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md) explains how to compile, package, and publish a simple WebAssembly WASI program as a container image to Docker hub. Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.

```bash
sudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" --overrides='{""kind"":""Pod"", ""apiVersion"":""v1"", ""spec"": {""hostNetwork"": true}}' /wasi_example_main.wasm 50000000
```

The output from the containerized application is printed into the console.

```bash
Random number: 401583443
Random bytes: [192, 226, 162, 92, 129, 17, 186, 164, 239, 84, 98, 255, 209, 79, 51, 227, 103, 83, 253, 31, 78, 239, 33, 218, 68, 208, 91, 56, 37, 200, 32, 12, 106, 101, 241, 78, 161, 16, 240, 158, 42, 24, 29, 121, 78, 19, 157, 185, 32, 162, 95, 214, 175, 46, 170, 100, 212, 33, 27, 190, 139, 121, 121, 222, 230, 125, 251, 21, 210, 246, 215, 127, 176, 224, 38, 184, 201, 74, 76, 133, 233, 129, 48, 239, 106, 164, 190, 29, 118, 71, 79, 203, 92, 71, 68, 96, 33, 240, 228, 62, 45, 196, 149, 21, 23, 143, 169, 163, 136, 206, 214, 244, 26, 194, 25, 101, 8, 236, 247, 5, 164, 117, 40, 220, 52, 217, 92, 179]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod ""wasi-demo-2"" deleted
```

### A WebAssembly-based HTTP service

[A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md) explains how to compile, package, and publish a simple WebAssembly HTTP service application as a container image to Docker hub. Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.

```bash
sudo cluster/kubectl.sh run --restart=Never http-server --image=wasmedge/example-wasi-http:latest --annotations=""module.wasm.image/variant=compat-smart"" --overrides='{""kind"":""Pod"", ""apiVersion"":""v1"", ""spec"": {""hostNetwork"": true}}'
```

Since we are using `hostNetwork` in the `kubectl run` command, the HTTP server image is running on the local network with IP address `127.0.0.1`. Now, you can use the `curl` command to access the HTTP service.

```bash
$ curl -d ""name=WasmEdge"" -X POST http://127.0.0.1:1234
echo: name=WasmEdge
```

That's it!
","**Summary**

This document provides a step-by-step guide to deploying a Kubernetes cluster with containerd and crun, and running WebAssembly (WasmEdge) programs as containers in pods. The guide covers the following topics:

1. Installing and configuring containerd
2. Setting up Kubernetes for local development
3. Building and running k8s with containerd
4. Running WasmEdge programs in Kubernetes as containers in pods
5. Deploying a simple WebAssembly app and a WebAssembly-based HTTP service

**Key Components**

* `containerd`: a lightweight, open-source container runtime
* `kubernetes`: a container orchestration system
* `wasi`: the WASI (WebAssembly System Interface) API for running WebAssembly programs in a Linux environment
* `wasmedge`: a WasmEdge runtime for running WebAssembly programs

**Potential Issues and Areas for Improvement**

* The guide assumes a specific version of Kubernetes, containerd, and WasmEdge. Users may need to modify the instructions if they are using different versions.
* The guide does not cover error handling and debugging techniques for complex deployments.
* The example applications (simple WebAssembly app and WebAssembly-based HTTP service) may require additional configuration or dependencies that are not covered in this guide.

**Code Analysis**

The provided code is written in Markdown format and consists of several sections, including:

1. An introduction to Kubernetes + containerd + crun
2. A quick start section with links to GitHub repositories for example applications
3. A detailed step-by-step guide to installing and configuring containerd and kubernetes
4. A guide to running WasmEdge programs in Kubernetes as containers in pods
5. Examples of deploying a simple WebAssembly app and a WebAssembly-based HTTP service

The code is well-structured and easy to follow, with clear headings and concise explanations. However, some sections may benefit from additional screenshots or diagrams to illustrate complex concepts."
docs/develop/rust/socket_networking/client.md,"---
sidebar_position: 1
---

# Socket client

It is possible for WasmEdge applications to open TCP/IP or UDP network sockets in the host system to communicate directly with external applications. One of the key features of WasmEdge is that it supports non-blocking sockets. That allows even a single-threaded WASM application to handle concurrent network requests. For example, while the program is waiting for data to stream in from one connection, it can start or handle another connection. The [wasmedge_wasi_socket](https://github.com/second-state/wasmedge_wasi_socket) crate enables Rust developers to work on the network socket level.

In this chapter, we will show you how to build HTTP clients on TCP sockets. The reason is that the HTTP protocol is relatively simple and could be demonstrated easily. If you use HTTP clients in production, we recommend checking out the [HTTP client](../http_service/client.md) chapter in this book.

- [A simple HTTP client based on TCP sockets](#a-simple-http-client)
- [A non-blocking HTTP client based on TCP sockets](#a-non-blocking-http-client-example)

<!-- prettier-ignore -->
:::note
Before we start, ensure [you have Rust and WasmEdge installed](../setup.md).
:::

## A Simple HTTP Client

You can build and run [the example](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_client) in WasmEdge as follows.

```bash
git clone https://github.com/second-state/wasmedge_wasi_socket.git
cd wasmedge_wasi_socket/http_client/

# Build the Rust Code
cargo build --target wasm32-wasi --release
# Use the AoT compiler to get better performance
wasmedge compile target/wasm32-wasi/release/http_client.wasm http_client.wasm

# Run the example
wasmedge http_client.wasm
```

The [source code](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_client) for the HTTP client is available as follows.

```rust
use wasmedge_http_req::request;

fn main() {
  let mut writer = Vec::new(); //container for body of a response
  let res = request::get(""http://127.0.0.1:1234/get"", &mut writer).unwrap();

  println!(""GET"");
  println!(""Status: {} {}"", res.status_code(), res.reason());
  println!(""Headers {}"", res.headers());
  println!(""{}"", String::from_utf8_lossy(&writer));

  let mut writer = Vec::new(); //container for body of a response
  const BODY: &[u8; 27] = b""field1=value1&field2=value2"";
  // let res = request::post(""https://httpbin.org/post"", BODY, &mut writer).unwrap();
  // no https , no dns
  let res = request::post(""http://127.0.0.1:1234/post"", BODY, &mut writer).unwrap();

  println!(""POST"");
  println!(""Status: {} {}"", res.status_code(), res.reason());
  println!(""Headers {}"", res.headers());
  println!(""{}"", String::from_utf8_lossy(&writer));
}
```

## A non-blocking HTTP client example

You can build and run [the example](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/nonblock_http_client) in WasmEdge as follows.

```bash
git clone https://github.com/second-state/wasmedge_wasi_socket
cd wasmedge_wasi_socket/nonblock_http_client/

# Build the Rust Code
cargo build --target wasm32-wasi --release
# Use the AoT compiler for better performance
wasmedge compile target/wasm32-wasi/release/nonblock_http_client.wasm nonblock_http_client.wasm

# Run the example
wasmedge nonblock_http_client.wasm
```

<!-- prettier-ignore -->
:::note
Non-blocking I/O means that the application program can keep multiple connections open simultaneously, and process data in and out of those connections as they come in. The program can either alternatingly poll those open connections or wait for incoming data to trigger async functions. That allows I/O intensive programs to run faster, even in a single-threaded environment.
:::

The [source code](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/nonblock_http_client) for a non-blocking HTTP client application is available. The following `main()` function starts two HTTP connections. The program keeps both connections open and alternatingly checks for incoming data. In other words, the two connections are not blocking each other. Their data are handled concurrently (or alternatingly) as the data comes in.

```rust
use httparse::{Response, EMPTY_HEADER};
use std::io::{self, Read, Write};
use std::str::from_utf8;
use wasmedge_wasi_socket::TcpStream;

fn main() {
    let req = ""GET / HTTP/1.0\n\n"";
    let mut first_connection = TcpStream::connect(""127.0.0.1:80"").unwrap();
    first_connection.set_nonblocking(true).unwrap();
    first_connection.write_all(req.as_bytes()).unwrap();

    let mut second_connection = TcpStream::connect(""127.0.0.1:80"").unwrap();
    second_connection.set_nonblocking(true).unwrap();
    second_connection.write_all(req.as_bytes()).unwrap();

    let mut first_buf = vec![0; 4096];
    let mut first_bytes_read = 0;
    let mut second_buf = vec![0; 4096];
    let mut second_bytes_read = 0;

    loop {
        let mut first_complete = false;
        let mut second_complete = false;
        if !first_complete {
            match read_data(&mut first_connection, &mut first_buf, first_bytes_read) {
                Ok((bytes_read, false)) => {
                    first_bytes_read = bytes_read;
                }
                Ok((bytes_read, true)) => {
                    println!(""First connection completed"");
                    if bytes_read != 0 {
                        parse_data(&first_buf, bytes_read);
                    }
                    first_complete = true;
                }
                Err(e) => {
                    println!(""First connection error: {}"", e);
                    first_complete = true;
                }
            }
        }
        if !second_complete {
            match read_data(&mut second_connection, &mut second_buf, second_bytes_read) {
                Ok((bytes_read, false)) => {
                    second_bytes_read = bytes_read;
                }
                Ok((bytes_read, true)) => {
                    println!(""Second connection completed"");
                    if bytes_read != 0 {
                        parse_data(&second_buf, bytes_read);
                    }
                    second_complete = true;
                }
                Err(e) => {
                    println!(""Second connection error: {}"", e);
                    second_complete = true;
                }
            }
        }
        if first_complete && second_complete {
            break;
        }
    }
}
```
","**Summary**

The provided code demonstrates how to build HTTP clients using TCP sockets in WasmEdge, a WebAssembly runtime. The code consists of two examples: a simple HTTP client and a non-blocking HTTP client.

**Key Components**

1. **WasmEdge**: A WebAssembly runtime that supports running WASM applications on the host system.
2. **wasmedge_wasi_socket**: A Rust crate that enables working with network sockets in WasmEdge.
3. **httparse**: A library for parsing HTTP responses.
4. **TcpStream**: A type from wasmedge_wasi_socket used to create TCP connections.

**Functionality**

1. **Simple HTTP Client**: The code demonstrates a simple HTTP client that sends GET and POST requests to a server using the request::get() and request::post() functions, respectively.
2. **Non-Blocking HTTP Client**: The code demonstrates a non-blocking HTTP client that starts two concurrent connections to a server and alternately checks for incoming data using the read_data() function.

**Potential Issues**

1. **Error Handling**: The provided code does not handle errors well. For example, it prints error messages to the console without providing any further information.
2. **Concurrency**: While the non-blocking HTTP client demonstrates concurrency, it does not use a more advanced approach like asynchronous programming or threads.
3. **Resource Leaks**: The code assumes that the connections are properly closed after use, but this is not guaranteed.

**Improvement Suggestions**

1. **Error Handling**: Improve error handling by providing more information about the errors and using more robust error types.
2. **Concurrency**: Use a more advanced concurrency approach like asynchronous programming or threads to handle concurrent connections.
3. **Resource Management**: Ensure that resources, such as connections, are properly released after use."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/socket_networking/client.md,"---
sidebar_position: 1
---

# Socket client

It is possible for WasmEdge applications to open TCP/IP or UDP network sockets in the host system to communicate directly with external applications. One of the key features of WasmEdge is that it supports non-blocking sockets. That allows even a single-threaded WASM application to handle concurrent network requests. For example, while the program is waiting for data to stream in from one connection, it can start or handle another connection. The [wasmedge_wasi_socket](https://github.com/second-state/wasmedge_wasi_socket) crate enables Rust developers to work on the network socket level.

In this chapter, we will show you how to build HTTP clients on TCP sockets. The reason is that the HTTP protocol is relatively simple and could be demonstrated easily. If you use HTTP clients in production, we recommend checking out the [HTTP client](../http_service/client.md) chapter in this book.

- [A simple HTTP client based on TCP sockets](#a-simple-http-client)
- [A non-blocking HTTP client based on TCP sockets](#a-non-blocking-http-client-example)

<!-- prettier-ignore -->
:::note
Before we start, ensure [you have Rust and WasmEdge installed](../setup.md).
:::

## A Simple HTTP Client

You can build and run [the example](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_client) in WasmEdge as follows.

```bash
git clone https://github.com/second-state/wasmedge_wasi_socket.git
cd wasmedge_wasi_socket/http_client/

# Build the Rust Code
cargo build --target wasm32-wasi --release
# Use the AoT compiler to get better performance
wasmedge compile target/wasm32-wasi/release/http_client.wasm http_client.wasm

# Run the example
wasmedge http_client.wasm
```

The [source code](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_client) for the HTTP client is available as follows.

```rust
use wasmedge_http_req::request;

fn main() {
  let mut writer = Vec::new(); //container for body of a response
  let res = request::get(""http://127.0.0.1:1234/get"", &mut writer).unwrap();

  println!(""GET"");
  println!(""Status: {} {}"", res.status_code(), res.reason());
  println!(""Headers {}"", res.headers());
  println!(""{}"", String::from_utf8_lossy(&writer));

  let mut writer = Vec::new(); //container for body of a response
  const BODY: &[u8; 27] = b""field1=value1&field2=value2"";
  // let res = request::post(""https://httpbin.org/post"", BODY, &mut writer).unwrap();
  // no https , no dns
  let res = request::post(""http://127.0.0.1:1234/post"", BODY, &mut writer).unwrap();

  println!(""POST"");
  println!(""Status: {} {}"", res.status_code(), res.reason());
  println!(""Headers {}"", res.headers());
  println!(""{}"", String::from_utf8_lossy(&writer));
}
```

## A non-blocking HTTP client example

You can build and run [the example](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/nonblock_http_client) in WasmEdge as follows.

```bash
git clone https://github.com/second-state/wasmedge_wasi_socket
cd wasmedge_wasi_socket/nonblock_http_client/

# Build the Rust Code
cargo build --target wasm32-wasi --release
# Use the AoT compiler for better performance
wasmedge compile target/wasm32-wasi/release/nonblock_http_client.wasm nonblock_http_client.wasm

# Run the example
wasmedge nonblock_http_client.wasm
```

<!-- prettier-ignore -->
:::note
Non-blocking I/O means that the application program can keep multiple connections open simultaneously, and process data in and out of those connections as they come in. The program can either alternatingly poll those open connections or wait for incoming data to trigger async functions. That allows I/O intensive programs to run faster, even in a single-threaded environment.
:::

The [source code](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/nonblock_http_client) for a non-blocking HTTP client application is available. The following `main()` function starts two HTTP connections. The program keeps both connections open and alternatingly checks for incoming data. In other words, the two connections are not blocking each other. Their data are handled concurrently (or alternatingly) as the data comes in.

```rust
use httparse::{Response, EMPTY_HEADER};
use std::io::{self, Read, Write};
use std::str::from_utf8;
use wasmedge_wasi_socket::TcpStream;

fn main() {
    let req = ""GET / HTTP/1.0\n\n"";
    let mut first_connection = TcpStream::connect(""127.0.0.1:80"").unwrap();
    first_connection.set_nonblocking(true).unwrap();
    first_connection.write_all(req.as_bytes()).unwrap();

    let mut second_connection = TcpStream::connect(""127.0.0.1:80"").unwrap();
    second_connection.set_nonblocking(true).unwrap();
    second_connection.write_all(req.as_bytes()).unwrap();

    let mut first_buf = vec![0; 4096];
    let mut first_bytes_read = 0;
    let mut second_buf = vec![0; 4096];
    let mut second_bytes_read = 0;

    loop {
        let mut first_complete = false;
        let mut second_complete = false;
        if !first_complete {
            match read_data(&mut first_connection, &mut first_buf, first_bytes_read) {
                Ok((bytes_read, false)) => {
                    first_bytes_read = bytes_read;
                }
                Ok((bytes_read, true)) => {
                    println!(""First connection completed"");
                    if bytes_read != 0 {
                        parse_data(&first_buf, bytes_read);
                    }
                    first_complete = true;
                }
                Err(e) => {
                    println!(""First connection error: {}"", e);
                    first_complete = true;
                }
            }
        }
        if !second_complete {
            match read_data(&mut second_connection, &mut second_buf, second_bytes_read) {
                Ok((bytes_read, false)) => {
                    second_bytes_read = bytes_read;
                }
                Ok((bytes_read, true)) => {
                    println!(""Second connection completed"");
                    if bytes_read != 0 {
                        parse_data(&second_buf, bytes_read);
                    }
                    second_complete = true;
                }
                Err(e) => {
                    println!(""Second connection error: {}"", e);
                    second_complete = true;
                }
            }
        }
        if first_complete && second_complete {
            break;
        }
    }
}
```
","**Summary**

The provided code is a documentation for creating Socket clients in Rust using the WasmEdge runtime. It covers two examples: a simple HTTP client and a non-blocking HTTP client.

**Key Components**

1. **Simple HTTP Client**: Demonstrates how to build an HTTP client that sends GET and POST requests to a local server.
2. **Non-Blocking HTTP Client Example**: Shows how to create a non-blocking HTTP client that can handle multiple connections simultaneously using async I/O operations.
3. **Wasmedge Wasi Socket Crate**: A Rust library for working with network sockets in WebAssembly (WASM) environments, specifically designed for use with the WasmEdge runtime.

**Functionality**

The code provides examples of how to create:

1. **TCP Sockets**: Establish connections with external applications using TCP/IP or UDP networks.
2. **HTTP Clients**: Send HTTP requests to a server and parse responses.
3. **Non-Blocking I/O**: Use async operations to handle multiple connections simultaneously, allowing for concurrent data processing.

**Potential Issues/Improvements**

1. **Error Handling**: The code could benefit from more robust error handling mechanisms to ensure that errors are properly propagated and handled.
2. **Code Organization**: The examples are written in a single file, which can make it difficult to maintain and extend the codebase. Consider organizing the code into separate modules or files for better organization.
3. **Comments and Documentation**: While the code has some comments and documentation, consider adding more explanations and examples to improve readability and understanding of the code.

**Best Practices**

1. **Use async/await syntax**: The non-blocking example uses async/await syntax, which is a best practice in Rust for writing asynchronous code.
2. **Use Try blocks**: Consider using try blocks to handle errors and propagate them up the call stack instead of using unwraps or panicking.
3. **Follow coding conventions**: Make sure to follow established coding conventions and guidelines for Rust development."
docs/develop/rust/dapr.md,"---
sidebar_position: 8
---

# Dapr services

Second State launched a new [WebAssembly-based SDK for the Dapr API](https://github.com/second-state/dapr-sdk-wasi), which provides an easy way for Rust-based microservices in WasmEdge to interact with Dapr APIs and sidecar services.

The figure below shows a Dapr-enabled microservice running inside the WasmEdge sandbox.

![Dapr WASM rust API](dapr_wasm_rust_api.png)

## Prerequisites

Before we start, ensure [you have Rust and WasmEdge installed](setup.md).

You also need to install the following tools.

- [Dapr CLI installed](https://docs.dapr.io/getting-started/install-dapr-cli/)
- An [MySQL](https://dev.mysql.com/doc/mysql-installation-excerpt/5.7/en/) or [MariaDB](https://mariadb.com/kb/en/getting-installing-and-upgrading-mariadb/) or [TiDB](https://docs.pingcap.com/tidb/dev/quick-start-with-tidb) database installed

## The template project explanation

The template application showcases how [Dapr](https://dapr.io/) and [WasmEdge](https://github.com/WasmEdge/) work together to support [lightweight WebAssembly-based microservices](https://github.com/second-state/microservice-rust-mysql) in a cloud-native environment. The microservices are all written in Rust and compiled into WebAssembly.

This application consists of three microservices and a standalone web page that enables users to interact with the microservices using an HTML+JavaScript UI. It is a very typical JAMstack setup. Each microservice is attached to a Dapr sidecar, which provides a suite of valuable services commonly required by cloud-native microservices.

![Dapr and WasmEdge](dapr-wasmedge.png)

The WasmEdge's Dapr SDK is used to access Dapr sidecars from the microservice apps. Specifically, the [grayscale](https://github.com/second-state/dapr-wasm/tree/main/image-api-grayscale) microservice takes an image from an HTTP POST, turns it into grayscale, and returns the result image data in the HTTP response.

- It uses Dapr to discover and invoke the [events](https://github.com/second-state/dapr-wasm/tree/main/events-service) microservice to record every successful user request.
- It also stores each user’s IP address and last timestamp data in its Dapr sidecar’s state database. That allows the service to rate limit users if needed.

The [classify](https://github.com/second-state/dapr-wasm/tree/main/image-api-classify) microservices takes an image from an HTTP POST, runs a Tensorflow model against it to classify the object on the image, and returns the result as a text label in the HTTP response. You can learn more about AI inference in Rust and WasmEdge [here](/category/ai-inference). It uses its own Dapr sidecar like the [grayscale](https://github.com/second-state/dapr-wasm/tree/main/image-api-grayscale) microservice.

The [events](https://github.com/second-state/dapr-wasm/tree/main/events-service) microservice takes JSON data from an HTTP POST and saves it to an external MySQL database for later analysis.

- It uses Dapr to make itself discoverable by name by other microservices that need to record events.
- It also uses its Dapr sidecar to store secrets such as MySQL database credentials.

Ok, enough concepts for the template project. Let's go ahead.

[Live Demo](http://dapr-demo.secondstate.co) | [Tutorial video](https://www.youtube.com/watch?v=3v37pAT9iK8)

## Build and deploy these microservices in Dapr

First, start the database and place the connection string in the [config/secrets.json](https://github.com/second-state/dapr-wasm/blob/main/config/secrets.json) file under `DB_URL:MYSQL`.

Next, start Dapr with the following commands.

```bash
dapr init
```

### The image grayscale microservice

Build.

```bash
cd image-api-grayscale
cargo build --target wasm32-wasi --release
wasmedgec ./target/wasm32-wasi/release/image-api-grayscale.wasm image-api-grayscale.wasm
```

Deploy.

```bash
dapr run --app-id image-api-grayscale \
        --app-protocol http \
        --app-port 9005 \
        --dapr-http-port 3503 \
        --components-path ../config \
        --log-level debug \
 wasmedge image-api-grayscale.wasm
```

### The image classification microservice

Build.

```bash
cd image-api-classify
cargo build --target wasm32-wasi --release
wasmedgec target/wasm32-wasi/release/wasmedge_hyper_server_tflite.wasm wasmedge_hyper_server_tflite.wasm
```

Deploy.

```bash
dapr run --app-id image-api-classify \
        --app-protocol http \
        --app-port 9006 \
        --dapr-http-port 3504 \
        --log-level debug \
        --components-path ../config \
        wasmedge-tensorflow-lite wasmedge_hyper_server_tflite.wasm
```

### The events recorder microservice

Build.

```bash
cd events-service
cargo build --target wasm32-wasi --release
wasmedgec target/wasm32-wasi/release/events_service.wasm events_service.wasm
```

Deploy.

```bash
dapr run --app-id events-service \
        --app-protocol http \
        --app-port 9007 \
        --dapr-http-port 3505 \
        --log-level debug \
        --components-path ../config \
        wasmedge events_service.wasm
```

## Test

To test the services, you can use the [static web page UI](http://dapr-demo.secondstate.co/) or `curl`.

Initialize the events database table.

```bash
$ curl http://localhost:9007/init
{""status"":true}

$ curl http://localhost:9007/events
[]
```

Use the grayscale microservice. The return data is base64 encoded grayscale image.

```bash
$ cd docs
$ curl http://localhost:9005/grayscale -X POST --data-binary '@food.jpg'
ABCDEFG ...
```

Use the image classification microservice.

```bash
$ cd docs
$ curl http://localhost:9006/classify -X POST --data-binary '@food.jpg'
hotdog is detected with 255/255 confidence
```

Query the events database again.

```bash
$ curl http://localhost:9007/events
[{""id"":1,""event_ts"":1665358852918,""op_type"":""grayscale"",""input_size"":68016},{""id"":2,""event_ts"":1665358853114,""op_type"":""classify"",""input_size"":68016}]
```

Next, you could use WasmEdge and WasmEdge's Dapr Rust API to create lightweight microservices with better security, faster performance, and smaller footprints.
","**Summary:**

The provided code is a template project for creating lightweight WebAssembly-based microservices in Rust, utilizing the Dapr (Distributed Application Runtime) and WasmEdge platforms. The project consists of three microservices:

1. `image-api-grayscale`: converts an image to grayscale using Dapr's sidecar services.
2. `image-api-classify`: uses Tensorflow Lite for object classification on images.
3. `events-service`: records events in a MySQL database.

**Key Components:**

* **Dapr**: provides a suite of services commonly required by cloud-native microservices, such as discovery, invocation, and state management.
* **WasmEdge**: a WebAssembly runtime that enables execution of Rust code on the edge, with features like small footprint, fast performance, and secure sandboxing.
* **Rust**: used for developing the microservices.

**Build and Deploy:**

The project provides instructions for building and deploying the microservices using `cargo`, `wasmedgec`, and Dapr's `run` command. Each microservice is built as a separate WasmEdge module, which is then deployed to a Dapr sidecar.

**Testing:**

The provided code includes example usage of each microservice using `curl`. The events database table can be initialized and queried to verify the functionality of the `events-service`.

**Potential Issues/Areas for Improvement:**

1. **Error handling**: while the code provides basic error handling, it may benefit from more robust error handling mechanisms, such as logging and retry strategies.
2. **Security**: ensure that sensitive data (e.g., database credentials) is properly secured in production environments.
3. **Scalability**: consider implementing load balancing or other scaling strategies to handle increased traffic or resource demands.
4. **Monitoring and debugging**: add monitoring tools and debugging mechanisms, such as logging, metrics, and tracing, to facilitate easier issue identification and resolution.

Overall, this project demonstrates the potential of WasmEdge and Dapr for building lightweight, scalable, and secure microservices in Rust."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/dapr.md,"---
sidebar_position: 8
---

# Dapr services

Second State launched a new [WebAssembly-based SDK for the Dapr API](https://github.com/second-state/dapr-sdk-wasi), which provides an easy way for Rust-based microservices in WasmEdge to interact with Dapr APIs and sidecar services.

The figure below shows a Dapr-enabled microservice running inside the WasmEdge sandbox.

![Dapr WASM rust API](dapr_wasm_rust_api.png)

## Prerequisites

Before we start, ensure [you have Rust and WasmEdge installed](setup.md).

You also need to install the following tools.

- [Dapr CLI installed](https://docs.dapr.io/getting-started/install-dapr-cli/)
- An [MySQL](https://dev.mysql.com/doc/mysql-installation-excerpt/5.7/en/) or [MariaDB](https://mariadb.com/kb/en/getting-installing-and-upgrading-mariadb/) or [TiDB](https://docs.pingcap.com/tidb/dev/quick-start-with-tidb) database installed

## The template project explanation

The template application showcases how [Dapr](https://dapr.io/) and [WasmEdge](https://github.com/WasmEdge/) work together to support [lightweight WebAssembly-based microservices](https://github.com/second-state/microservice-rust-mysql) in a cloud-native environment. The microservices are all written in Rust and compiled into WebAssembly.

This application consists of three microservices and a standalone web page that enables users to interact with the microservices using an HTML+JavaScript UI. It is a very typical JAMstack setup. Each microservice is attached to a Dapr sidecar, which provides a suite of valuable services commonly required by cloud-native microservices.

![Dapr and WasmEdge](dapr-wasmedge.png)

The WasmEdge's Dapr SDK is used to access Dapr sidecars from the microservice apps. Specifically, the [grayscale](https://github.com/second-state/dapr-wasm/tree/main/image-api-grayscale) microservice takes an image from an HTTP POST, turns it into grayscale, and returns the result image data in the HTTP response.

- It uses Dapr to discover and invoke the [events](https://github.com/second-state/dapr-wasm/tree/main/events-service) microservice to record every successful user request.
- It also stores each user’s IP address and last timestamp data in its Dapr sidecar’s state database. That allows the service to rate limit users if needed.

The [classify](https://github.com/second-state/dapr-wasm/tree/main/image-api-classify) microservices takes an image from an HTTP POST, runs a Tensorflow model against it to classify the object on the image, and returns the result as a text label in the HTTP response. You can learn more about AI inference in Rust and WasmEdge [here](/category/ai-inference). It uses its own Dapr sidecar like the [grayscale](https://github.com/second-state/dapr-wasm/tree/main/image-api-grayscale) microservice.

The [events](https://github.com/second-state/dapr-wasm/tree/main/events-service) microservice takes JSON data from an HTTP POST and saves it to an external MySQL database for later analysis.

- It uses Dapr to make itself discoverable by name by other microservices that need to record events.
- It also uses its Dapr sidecar to store secrets such as MySQL database credentials.

Ok, enough concepts for the template project. Let's go ahead.

[Live Demo](http://dapr-demo.secondstate.co) | [Tutorial video](https://www.youtube.com/watch?v=3v37pAT9iK8)

## Build and deploy these microservices in Dapr

First, start the database and place the connection string in the [config/secrets.json](https://github.com/second-state/dapr-wasm/blob/main/config/secrets.json) file under `DB_URL:MYSQL`.

Next, start Dapr with the following commands.

```bash
dapr init
```

### The image grayscale microservice

Build.

```bash
cd image-api-grayscale
cargo build --target wasm32-wasi --release
wasmedgec ./target/wasm32-wasi/release/image-api-grayscale.wasm image-api-grayscale.wasm
```

Deploy.

```bash
dapr run --app-id image-api-grayscale \
        --app-protocol http \
        --app-port 9005 \
        --dapr-http-port 3503 \
        --components-path ../config \
        --log-level debug \
 wasmedge image-api-grayscale.wasm
```

### The image classification microservice

Build.

```bash
cd image-api-classify
cargo build --target wasm32-wasi --release
wasmedgec target/wasm32-wasi/release/wasmedge_hyper_server_tflite.wasm wasmedge_hyper_server_tflite.wasm
```

Deploy.

```bash
dapr run --app-id image-api-classify \
        --app-protocol http \
        --app-port 9006 \
        --dapr-http-port 3504 \
        --log-level debug \
        --components-path ../config \
        wasmedge-tensorflow-lite wasmedge_hyper_server_tflite.wasm
```

### The events recorder microservice

Build.

```bash
cd events-service
cargo build --target wasm32-wasi --release
wasmedgec target/wasm32-wasi/release/events_service.wasm events_service.wasm
```

Deploy.

```bash
dapr run --app-id events-service \
        --app-protocol http \
        --app-port 9007 \
        --dapr-http-port 3505 \
        --log-level debug \
        --components-path ../config \
        wasmedge events_service.wasm
```

## Test

To test the services, you can use the [static web page UI](http://dapr-demo.secondstate.co/) or `curl`.

Initialize the events database table.

```bash
$ curl http://localhost:9007/init
{""status"":true}

$ curl http://localhost:9007/events
[]
```

Use the grayscale microservice. The return data is base64 encoded grayscale image.

```bash
$ cd docs
$ curl http://localhost:9005/grayscale -X POST --data-binary '@food.jpg'
ABCDEFG ...
```

Use the image classification microservice.

```bash
$ cd docs
$ curl http://localhost:9006/classify -X POST --data-binary '@food.jpg'
hotdog is detected with 255/255 confidence
```

Query the events database again.

```bash
$ curl http://localhost:9007/events
[{""id"":1,""event_ts"":1665358852918,""op_type"":""grayscale"",""input_size"":68016},{""id"":2,""event_ts"":1665358853114,""op_type"":""classify"",""input_size"":68016}]
```

Next, you could use WasmEdge and WasmEdge's Dapr Rust API to create lightweight microservices with better security, faster performance, and smaller footprints.
","**Summary**

This documentation is for a Dapr-enabled microservices template project that showcases the interaction between Dapr and WasmEdge. The project consists of three microservices (grayscale, classify, and events) written in Rust and compiled into WebAssembly using WasmEdge. These microservices use Dapr to access sidecars, store state data, and discover other services.

**Key Components**

1. **Dapr**: A distributed application runtime that provides a set of building blocks for creating cloud-native applications.
2. **WasmEdge**: A high-performance, secure WebAssembly runtime that allows developers to run Rust code in the browser or on edge devices.
3. **Microservices**: Three WasmEdge-based microservices (grayscale, classify, and events) written in Rust that interact with each other using Dapr.
4. **Dapr SDK for Rust**: A library that provides a set of APIs for interacting with Dapr services from Rust code.

**Prerequisites**

1. **Rust**: Installed on the development machine.
2. **WasmEdge**: Installed on the development machine.
3. **Dapr CLI**: Installed and configured.
4. **Database**: An instance of MySQL, MariaDB, or TiDB is required for storing data.

**Code Structure**

The code consists of three microservices:

1. **Grayscale**: A microservice that takes an image as input, converts it to grayscale, and returns the result.
2. **Classify**: A microservice that classifies objects in an image using a Tensorflow model.
3. **Events**: A microservice that records events and stores data in a database.

**Deployment**

To deploy the microservices, follow these steps:

1. Build each microservice individually using the provided instructions.
2. Start Dapr and configure it to use the necessary components (e.g., database connection).
3. Run the microservices using the `dapr run` command.

**Testing**

To test the microservices, you can use the static web page UI or `curl` commands to interact with each service individually."
docs/start/getting-started/quick_start.md,"---
sidebar_position: 1
---

# Quick start on Linux

In this guide, we will walk you through how to quickly install and run the WasmEdge Runtime on a generic Linux distribution (such as Ubuntu, Debian, Raspberry OS or WSL on Windows). Comprehensive and OS-specific installation instructions can be found [here](../install.md#install).

<!-- prettier-ignore -->
:::note
If you have Docker Desktop 4.15 and above, you can skip this and [get started here](quick_start_docker.md). For Fedora Linux / Red Hat Linux / OpenShift / Podman users, [get started here](quick_start_redhat.md).
:::

We will cover the following examples:

- [How to run a standalone WASM app](#how-to-run-a-standalone-wasm-app)
- [How to run an HTTP server](#how-to-run-an-http-server)
- [How to run a JavaScript server (node.js)](#how-to-run-a-javascript-based-server)

## One-liner Installation of WasmEdge

The easiest way to install WasmEdge is to run the following command. You should have root or at least `sudo` privilege. Your system should have `git` and `curl` installed as prerequisites.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | sudo bash -s -- -p /usr/local
```

If you do not have root or `sudo` rights, use the following line to install WasmEdge in your `$HOME/.wasmedge` directory:

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
```

## How to run a standalone WASM app

The Hello world example is a standalone Rust application that can be executed by the [WasmEdge CLI](../build-and-run/cli.md). Its source code and build instructions are available [here](https://github.com/second-state/rust-examples/tree/main/hello).

Download the hello.wasm file [here](https://github.com/second-state/rust-examples/releases/latest/download/hello.wasm), or run the following command:

```bash
wget https://github.com/second-state/rust-examples/releases/latest/download/hello.wasm
```

Use the `wasmedge` command to run the program.

```bash
$ wasmedge hello.wasm
Hello WasmEdge!
```

Use the AoT compiler `wasmedgec` to get much better performance.

```bash
$ wasmedgec hello.wasm hello_aot.wasm
$ wasmedge hello_aot.wasm
Hello WasmEdge!
```

To learn more about how to create WASM apps in Rust

- [Basic Rust examples for WasmEdge](https://github.com/second-state/rust-examples)
- [Rust developer guides](/category/develop-wasm-apps-in-rust)
  - WASI-NN with [PyTorch](../../develop/rust/wasinn/pytorch.md), [OpenVINO](../../develop/rust/wasinn/openvino.md), or [Tensorflow Lite](../../develop/rust/wasinn/tensorflow_lite.md) backends
  - [HTTP and HTTPS client](../../develop/rust/http_service/client.md)
  - [MySQL database client](../../develop/rust/database/my_sql_driver.md)
  - Redis client
  - Kafka client

## How to run an HTTP server

This example is a standalone HTTP server written in Rust. It demonstrates that Rust + WasmEdge as a lightweight stack for microservices. Its source code and build instructions are available [here](https://github.com/second-state/rust-examples/tree/main/server).

Download the server.wasm file [here](https://github.com/second-state/rust-examples/releases/latest/download/server.wasm), or run the following command:

```bash
wget https://github.com/second-state/rust-examples/releases/latest/download/server.wasm
```

Use the `wasmedge` command to run the program.

```bash
$ wasmedge server.wasm
Listening on http://0.0.0.0:8080
```

From another terminal window, do the following.

```bash
$ curl http://localhost:8080/
Try POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`

$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

To learn more about how to create WASM services in Rust

- [Rust developer guides](/category/develop-wasm-apps-in-rust)
- [HTTP application examples](https://github.com/WasmEdge/wasmedge_hyper_demo)
- [Database application examples](https://github.com/WasmEdge/wasmedge-db-examples)
- Lightweight microservices in Rust and WasmEdge
  - [WasmEdge + Nginx + MySQL](https://github.com/second-state/microservice-rust-mysql)
  - [WasmEdge + Kafka + MySQL](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql)
  - [Dapr + WasmEdge](https://github.com/second-state/dapr-wasm)

## How to run a JavaScript-based server

This example is a standalone HTTP server written in JavaScript using the node.js API. It demonstrates WasmEdge as a lightweight runtime for node.js applications. Its source code is available [here](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/docker_wasm/server).

- Download the wasmedge_quickjs.wasm file [here](https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm), or run the following command:

```bash
wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm
```

- Download the modules.zip file [here](https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip), or run the following command:

```bash
wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip
```

Unzip the modules.zip file into the current folder as `./modules/`.

```bash
unzip modules.zip
```

- Download the server.js file [here](https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/docker_wasm/server/server.js).

```bash
wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/docker_wasm/server/server.js
```

Use the `wasmedge` command to run the program.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm server.js
listen 8080 ...
```

From another terminal window, do the following.

```bash
$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

To learn more about how to run JavaScript apps in WasmEdge.

- [The WasmEdge QuickJS runtime](https://github.com/second-state/wasmedge-quickjs)
- [AI inference application examples](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo)
- [Web service client examples with fetch()](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js)

## Next steps

- Check out all available [WasmEdge CLI options](../build-and-run/cli.md) to explore WasmEdge's features.
- Write WASM apps in your favorite languages, like [Rust](/category/develop-wasm-apps-in-rust), [C/C++](/category/develop-wasm-apps-in-cc), [JavaScript](/category/develop-wasm-apps-in-javascript), [Go](/category/develop-wasm-apps-in-go), and many other languages.
","**Summary:**

This is a quick start guide for installing and running the WasmEdge Runtime on Linux. The guide covers three examples:

1. Running a standalone WASM app
2. Running an HTTP server
3. Running a JavaScript-based server

The guide provides step-by-step instructions, including downloading and building sample applications.

**Key Components:**

1. WasmEdge CLI
2. Standalone WASM app (Hello World example)
3. HTTP server (Rust-based example)
4. JavaScript-based server (using the node.js API)

**Potential Issues or Areas for Improvement:**

1. The guide assumes that users have root or `sudo` privileges, which may not be the case in all environments.
2. Some instructions assume that users are familiar with command-line interfaces and terminal commands.
3. The examples provided may require additional setup or dependencies to run successfully.
4. There is no clear indication of what resources (e.g., memory, CPU) are required to run the examples.

**Recommendations:**

1. Provide more detailed instructions for users who do not have root or `sudo` privileges.
2. Include a troubleshooting section that addresses common issues and provides solutions.
3. Consider adding a ""getting started"" section that covers the basics of WasmEdge, including its features and use cases.
4. Provide clear indications of resource requirements for each example.

Overall, this is a well-structured guide that provides step-by-step instructions for installing and running the WasmEdge Runtime on Linux. However, there are areas where additional clarity, detail, and guidance would be beneficial to ensure success for users with varying levels of experience."
docs/start/getting-started/quick_start_docker.md,"---
sidebar_position: 2
---

# Quick start with Docker

In this guide, we will walk you through how to quickly run WasmEdge apps in Docker Desktop. There is no additional dependencies as the entire development and runtime environments are managed by Docker Desktop.

<!-- prettier-ignore -->
:::note
If you are not using Docker Desktop, [get started here](quick_start.md).
:::

We will cover the following examples.

- [Run a standalone WASM app](#run-a-standalone-wasm-app)
- [Run an HTTP server](#run-an-http-server)
- [Run a JavaScript server (node.js)](#run-a-javascript-based-server)

In this quick start guide, we cover how to run WASM container apps using Docker commands. If you are interested in how to build, publish, and compose WASM container apps from source code, check out the [Docker + wasm chapter](../build-and-run/docker_wasm.md).

## Prerequisite

You must have Docker Desktop 4.15+ installed. Make sure you have turned on the containerd image store feature in your Docker Desktop.

![Docker config](docker_config.png)

## Run a standalone WASM app

The Hello world example is a standalone Rust application. Its source code and build instructions are available [here](https://github.com/second-state/rust-examples/tree/main/hello).

Use Docker to run the containerized WASM app. The WASM container image is stored in Docker Hub, and its image size is only 500KB. This image can run on any OS and CPU platform Docker supports.

```bash
$ docker run --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/rust-example-hello:latest
Hello WasmEdge!
```

To learn more about how to create WASM apps in Rust

- [Basic Rust examples for WasmEdge](https://github.com/second-state/rust-examples)
- [Rust developer guides](/category/develop-wasm-apps-in-rust)
  - WASI-NN with [PyTorch](../../develop/rust/wasinn/pytorch.md), [OpenVINO](../../develop/rust/wasinn/openvino.md), or [Tensorflow Lite](../../develop/rust/wasinn/tensorflow_lite.md) backends
  - [HTTP and HTTPS client](../../develop/rust/http_service/client.md)
  - [MySQL database client](../../develop/rust/database/my_sql_driver.md)
  - Redis client
  - Kafka client

## Run an HTTP server

This example is a standalone HTTP server written in Rust. It demonstrates that Rust + WasmEdge as a lightweight stack for microservices. Its source code and build instructions are available [here](https://github.com/second-state/rust-examples/tree/main/server).

Use Docker to pull the container image (around 800KB) from Docker Hub and then run it in a WasmEdge container. The container starts as a server. Note how we map the container's port 8080 to the local host's port 8080 so that the server becomes accessible from outside of the WASM container.

```bash
$ docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/rust-example-server:latest
Listening on http://0.0.0.0:8080
```

From another terminal window, do the following.

```bash
$ curl http://localhost:8080/
Try POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`

$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

To learn more about how to create WASM services in Rust

- [Rust developer guides](/category/develop-wasm-apps-in-rust)
- [HTTP application examples](https://github.com/WasmEdge/wasmedge_hyper_demo)
- [Database application examples](https://github.com/WasmEdge/wasmedge-db-examples)
- Lightweight microservices in Rust and WasmEdge
  - [WasmEdge + Nginx + MySQL](https://github.com/second-state/microservice-rust-mysql)
  - [WasmEdge + Kafka + MySQL](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql)
  - [Dapr + WasmEdge](https://github.com/second-state/dapr-wasm)

## Run a JavaScript-based server

This example is a standalone HTTP server written in JavaScript using the node.js API. It demonstrates WasmEdge as a lightweight runtime for zero-dependency and portable node.js applications. Its source code is available [here](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/docker_wasm/server).

```bash
$ docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/node-example-server:latest
... ...
```

From another terminal window, do the following.

```bash
$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

To learn more about how to run JavaScript apps in WasmEdge.

- [The WasmEdge QuickJS runtime](https://github.com/second-state/wasmedge-quickjs)
- [AI inference application examples](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo)
- [Web service client examples with fetch()](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js)

## Next steps

- [Learn more about building and managing WASM containers in Docker](../build-and-run/docker_wasm.md)
- [Basic Rust examples for WasmEdge](https://github.com/second-state/rust-examples)
- Use Docker Compose to build and Rust-based microservices
  - [WasmEdge / MySQL / Nginx](https://github.com/docker/awesome-compose/tree/master/wasmedge-mysql-nginx) - Sample Wasm-based web application with a static HTML frontend, using a MySQL (MariaDB) database. The frontend connects to a WASM microservice written in Rust, that runs using the WasmEdge runtime.
  - [WasmEdge / Kafka / MySQL](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql) - Sample Wasm-based microservice that subscribes to a Kafka (Redpanda) queue topic, and transforms and saves any incoming message into a MySQL (MariaDB) database.
- Write WASM apps in your favorite languages, like [Rust](/category/develop-wasm-apps-in-rust), [C/C++](/category/develop-wasm-apps-in-cc), [JavaScript](/category/develop-wasm-apps-in-javascript), [Go](/category/develop-wasm-apps-in-go), and many other languages.
","**Quick Start with Docker**

The provided code is a quick start guide for running WasmEdge apps in Docker Desktop. It covers three examples:

1. **Run a Standalone WASM App**: The first example is a standalone Rust application that demonstrates how to run a WASM container app using Docker commands.
2. **Run an HTTP Server**: The second example is a standalone HTTP server written in Rust, showcasing the lightweight stack for microservices.
3. **Run a JavaScript-Based Server**: The third example is a standalone HTTP server written in JavaScript using the node.js API.

**Key Components**

1. **Prerequisites**: Docker Desktop 4.15+ and containerd image store feature enabled.
2. **Docker Commands**: `docker run` and `docker pull` commands are used to run and pull WasmEdge containers respectively.
3. **WASM Container Images**: The WASM container images are stored in Docker Hub, with sizes around 500KB.

**Potential Issues**

1. **Compatibility**: Make sure the system meets the prerequisites for running Docker Desktop.
2. **Network Configuration**: Ensure that the network is configured correctly to access the WasmEdge containers.
3. **Image Sizes**: Be aware of the image sizes and adjust accordingly based on the use case.

**Recommendations**

1. **Explore WASM Development**: Learn more about building and managing WASM containers in Docker, and basic Rust examples for WasmEdge.
2. **Use Docker Compose**: Use Docker Compose to build and manage complex microservices using WasmEdge.
3. **Experiment with Different Languages**: Write WASM apps in your favorite languages, like Rust, C/C++, JavaScript, Go, and many others."
docs/develop/deploy/cri-runtime/containerd-crun.md,"---
sidebar_position: 2
---

# containerd + crun

## Quick start

The [GitHub repo](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on containerd.

- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd.yml)
- HTTP service example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd-server.yml)

In the sections below, we will explain the steps in the quick start scripts.

- [containerd + crun](#containerd--crun)
  - [Quick start](#quick-start)
  - [Install containerd](#install-containerd)
  - [Run a simple WebAssembly app](#run-a-simple-webassembly-app)
  - [Run a HTTP server app](#run-a-http-server-app)

## Install containerd

Use the following commands to install containerd on your system.

```bash
export VERSION=""1.5.7""
echo -e ""Version: $VERSION""
echo -e ""Installing libseccomp2 ...""
sudo apt install -y libseccomp2
echo -e ""Installing wget""
sudo apt install -y wget

wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum
sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum

sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
sudo systemctl daemon-reload
```

Configure containerd to use `crun` as the underlying OCI runtime. It changes the `/etc/containerd/config.toml` file.

```bash
sudo mkdir -p /etc/containerd/
sudo bash -c ""containerd config default > /etc/containerd/config.toml""
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff
sudo patch -d/ -p0 < containerd_config.diff
```

Start the containerd service.

```bash
sudo systemctl start containerd
```

Next, make sure that you have [built and installed the `crun` binary with WasmEdge support](../oci-runtime/crun.md) before running the following examples.

## Run a simple WebAssembly app

Now, we can run a simple WebAssembly program using containerd. [A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md) explains how to compile, package, and publish the WebAssembly program as a container image to Docker hub. This section will start pulling this WebAssembly-based container image from the Docker hub using containerd tools.

```bash
sudo ctr i pull docker.io/wasmedge/example-wasi:latest
```

Now, you can run the example in just one line with ctr (the containerd cli).

```bash
sudo ctr run --rm --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest wasm-example /wasi_example_main.wasm 50000000
```

Starting the container would execute the WebAssembly program. You can see the output in the console.

```bash
Creating POD ...
Random number: -1678124602
Random bytes: [12, 222, 246, 184, 139, 182, 97, 3, 74, 155, 107, 243, 20, 164, 175, 250, 60, 9, 98, 25, 244, 92, 224, 233, 221, 196, 112, 97, 151, 155, 19, 204, 54, 136, 171, 93, 204, 129, 177, 163, 187, 52, 33, 32, 63, 104, 128, 20, 204, 60, 40, 183, 236, 220, 130, 41, 74, 181, 103, 178, 43, 231, 92, 211, 219, 47, 223, 137, 70, 70, 132, 96, 208, 126, 142, 0, 133, 166, 112, 63, 126, 164, 122, 49, 94, 80, 26, 110, 124, 114, 108, 90, 62, 250, 195, 19, 189, 203, 175, 189, 236, 112, 203, 230, 104, 130, 150, 39, 113, 240, 17, 252, 115, 42, 12, 185, 62, 145, 161, 3, 37, 161, 195, 138, 232, 39, 235, 222]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
```

Next, you can run it in [Kubernetes](../kubernetes/kubernetes-containerd-crun.md#a-simple-webassembly-app)!

## Run a HTTP server app

Finally, we can run a simple WebAssembly-based HTTP micro-service in containerd. [A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md) explains how to compile, package, and publish the WebAssembly program as a container image to Docker hub. This section will start pulling this WebAssembly-based container image from the Docker hub using containerd tools.

```bash
sudo ctr i pull docker.io/wasmedge/example-wasi-http:latest
```

Now, you can run the example in just one line with ctr (the containerd cli). Notice that we are running the container with `--net-host` so that the HTTP server inside the WasmEdge container is accessible from the outside shell.

```bash
sudo ctr run --rm --net-host --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi-http:latest http-server-example /http_server.wasm
```

Starting the container would execute the WebAssembly program. You can see the output in the console.

```bash
new connection at 1234

# Test the HTTP service at that IP address
curl -d ""name=WasmEdge"" -X POST http://127.0.0.1:1234
echo: name=WasmEdge
```

Next, you can run it in [Kubernetes](../kubernetes/kubernetes-containerd-crun.md#a-webassembly-based-http-service)!
","**Summary**

The code provided is a documentation on how to deploy containerd with crun, an OCI runtime. The process involves installing containerd, configuring it to use crun as the underlying runtime, and then running simple WebAssembly apps and a HTTP server app using containerd tools.

**Key Components**

* `containerd`: An open-source container runtimes that provides a daemon for managing the lifecycle of containers.
* `crun`: An OCI-compatible container runtime that allows you to run containers with WasmEdge support.
* `ctr` (Container Runtime): A command-line tool for interacting with containerd.

**Installation Steps**

1. Install dependencies (`libseccomp2`, `wget`)
2. Download and install containerd
3. Configure containerd to use crun as the underlying runtime

**Running Examples**

1. Run a simple WebAssembly app using ctr (the containerd CLI)
	* Pull the Docker image from Docker Hub
	* Run the container with WasmEdge support
2. Run a HTTP server app using ctr (the containerd CLI)
	* Pull the Docker image from Docker Hub
	* Run the container with WasmEdge support and host networking

**Potential Issues/Improvements**

1. The code assumes that you have already built and installed the `crun` binary with WasmEdge support.
2. The instructions for running the examples assume that you have a basic understanding of containerd and crun.
3. The code does not provide any error handling or logging, which may make it difficult to debug issues.

Overall, the code provides a clear and concise guide on how to deploy containerd with crun and run simple WebAssembly apps and a HTTP server app using containerd tools. However, there are some potential improvements that could be made to make the code more robust and user-friendly."
docs/develop/deploy/kubernetes/kubernetes-containerd-runwasi.md,"---
sidebar_position: 3
---

# Kubernetes + Containerd + Runwasi

## Quick start

The [GitHub repo](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on Kubernetes + containerd + runwasi.

- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd.yml)
- WebAssembly-based HTTP service [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd-server.yml)

In the rest of this section, we will explain the steps in detail.

## Prerequisites for this setup

Please ensure that you have completed the following steps before proceeding with this setup.

- Install the latest version of [Wasmedge](../../../start/install.md)
- Ensure that you have containerd setup following the [instructions here](../../deploy/cri-runtime/containerd-crun.md). 
- Ensure that you have installed and [setup runwasi](../../deploy/cri-runtime/containerd.md) for containerd-shim-wasmedge



## Install and start Kubernetes

Run the following commands from a terminal window. It sets up Kubernetes for local development.

```bash
# Install go
$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz
$ sudo rm -rf /usr/local/go
$ sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz
$ source /home/${USER}/.profile

# Clone k8s
$ git clone https://github.com/kubernetes/kubernetes.git
$ cd kubernetes
$ git checkout v1.22.2

# Install etcd with hack script in k8s
$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/install-etcd.sh
$ export PATH=""/home/${USER}/kubernetes/third_party/etcd:${PATH}""
$ sudo cp third_party/etcd/etcd* /usr/local/bin/

# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl

# Build and run k8s with containerd
$ sudo apt-get install -y build-essential
$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/local-up-cluster.sh

... ...
Local Kubernetes cluster is running. Press Ctrl-C to shut it down.
```

Do NOT close your terminal window. Kubernetes is running!


## Run and test the Kubernetes Cluster

Finally, we can run WebAssembly programs in Kubernetes as containers in pods. In this section, we will start from **another terminal window** and start using the cluster.

```bash
export KUBERNETES_PROVIDER=local

sudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt
sudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt
sudo cluster/kubectl.sh config set-context local --cluster=local --user=myself
sudo cluster/kubectl.sh config use-context local
sudo cluster/kubectl.sh
```

Let's check the status to make sure that the cluster is running.

```bash
$ sudo cluster/kubectl.sh cluster-info

# Expected output
Cluster ""local"" set.
User ""myself"" set.
Context ""local"" created.
Switched to context ""local"".
Kubernetes control plane is running at https://localhost:6443
CoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
```

## Configure containerd and Kubernetes for Wasmedge Runtime 

Next we will configure containerd to add support for the containerd-shim-wasmedge.
Please ensure that you have [setup runwasi](../../deploy/cri-runtime/containerd.md) to work with WasmEdge container images.
```bash
# Run the following command as root user
sudo bash -c ""containerd config default > /etc/containerd/config.toml""
echo '[plugins.""io.containerd.grpc.v1.cri"".containerd.runtimes.wasmedge] runtime_type = ""io.containerd.wasmedge.v1""' | sudo tee -a /etc/containerd/config.toml > /dev/null
sudo systemctl restart containerd
```

Next we will create a RuntimeClass in Kubernetes to specify usage of wasmedge runtime for objects labeled as `runtime=wasm`

```bash
sudo cluster/kubectl.sh apply -f - <<< '{""apiVersion"":""node.k8s.io/v1"",""kind"":""RuntimeClass"",""metadata"":{""name"":""wasm""},""scheduling"":{""nodeSelector"":{""runtime"":""wasm""}},""handler"":""wasmedge""}'
```

Now we will label the kubernetes node as `runtime=wasm`. Note that the node where we changed the containerd configurations will be the one which we will label.

An example of how we can label the node is given below:

```bash
sudo cluster/kubectl.sh get nodes
# Sample output from the command above
NAME        STATUS     ROLES    AGE    VERSION
127.0.0.1   Ready   <none>   3h4m   v1.22.2
# Run the following command to label the node 
sudo cluster/kubectl.sh label nodes 127.0.0.1 runtime=wasm
# A successful output from the above command looks like this
node/127.0.0.1 labeled
```
### A WebAssembly-based HTTP service

[A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md) explains how to compile, package, and publish a simple WebAssembly HTTP service application as a container image to Docker hub. Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.

```bash
sudo cluster/kubectl.sh apply -f - <<< '{""apiVersion"":""apps/v1"",""kind"":""Deployment"",""metadata"":{""name"":""http-server-deployment""},""spec"":{""replicas"":1,""selector"":{""matchLabels"":{""app"":""http-server""}},""template"":{""metadata"":{""labels"":{""app"":""http-server""}},""spec"":{""hostNetwork"":true,""runtimeClassName"":""wasm"",""containers"":[{""name"":""http-server"",""image"":""wasmedge/example-wasi-http:latest"",""ports"":[{""containerPort"":1234}]}]}}}}'
```

Since we are using `hostNetwork` in the `kubectl run` command, the HTTP server image is running on the local network with IP address `127.0.0.1`. Now, you can use the `curl` command to access the HTTP service.

```bash
$ curl -d ""name=WasmEdge"" -X POST http://127.0.0.1:1234
echo: name=WasmEdge
```

That's it!











","Here is a concise and coherent summary of the purpose, functionality, and key components of the code:

**Purpose:** This code provides a step-by-step guide to setting up Kubernetes on local development with Containerd as the container runtime and Runwasi for WebAssembly applications.

**Functionality:**

1. Installs Go and sets up the environment.
2. Clones the Kubernetes repository and checks out a specific version.
3. Installs etcd, a distributed key-value store, using the `hack` script in the Kubernetes repository.
4. Builds and runs Kubernetes with Containerd.
5. Sets up Containerd to use Runwasi for WebAssembly applications.
6. Configures Kubernetes to use the Containerd-shim-wasmedge runtime class.

**Key Components:**

1. `go1.17.1.linux-amd64.tar.gz` - Go installer package.
2. `kubernetes/kubernetes.git` - Kubernetes repository clone.
3. `hack/install-etcd.sh` - etcd installation script in the Kubernetes repository.
4. `containerd` - Container runtime management tool.
5. `runwasi` - WebAssembly runtime for Runwasi applications.

**Potential Issues or Areas for Improvement:**

1. The code assumes a specific version of Go and Kubernetes, which may not be compatible with other versions.
2. The installation process for etcd is specific to the `hack` script in the Kubernetes repository, which may not work for other configurations.
3. The configuration for Containerd-shim-wasmedge is specific to Runwasi applications, which may not be applicable for other types of applications.
4. The code assumes a local development environment with a single node cluster, which may not be suitable for production environments.

Overall, this code provides a comprehensive guide to setting up Kubernetes on local development with Containerd and Runwasi, but requires careful consideration of compatibility and configuration issues."
docs/embed/use-case/plugin/c_sdk.md,"---
sidebar_position: 1
---

# Using Plug-ins to Extend the Runtime in C

The WasmEdge plug-ins are the shared libraries to provide the WasmEdge runtime to load and create host module instances. With the plug-ins, the WasmEdge runtime can be extended more easily.

## Loading Plug-ins from Paths

Developers can start using WasmEdge plug-ins by loading them from specific paths. To load plug-ins from the default paths, the following API can be used:

```c
WasmEdge_PluginLoadWithDefaultPaths();
```

Once this API is called, plug-ins from the default paths will be loaded. The default paths include:

- The path specified in the `WASMEDGE_PLUGIN_PATH` environment variable.
- The `../plugin/` directory relative to the WasmEdge installation path.
- The `./wasmedge/` directory under the library path if WasmEdge is installed in a system directory (e.g., `/usr` and `/usr/local`).

Developers can also load plug-ins from specific paths using this API:

```c
WasmEdge_PluginLoadFromPath(""PATH_TO_PLUGIN/plugin.so"");
```

## Listing Loaded Plug-ins

Once plug-ins are loaded, developers can list the loaded plug-in names using the following approach:

```c
WasmEdge_PluginLoadWithDefaultPaths();
printf(""Number of loaded plug-ins: %d\n"", WasmEdge_PluginListPluginsLength());

WasmEdge_String Names[20];
uint32_t NumPlugins = WasmEdge_PluginListPlugins(Names, 20);
for (int I = 0; I < NumPlugins; I++) {
  printf(""Plug-in %d name: %s\n"", I, Names[I].Buf);
}
```

## Getting Plug-in Context by Name

Developers can obtain the plug-in context by its name using the following method:

```c
/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */
WasmEdge_PluginLoadWithDefaultPaths();

const char PluginName[] = ""wasi_crypto"";
WasmEdge_String NameString =
    WasmEdge_StringWrap(PluginName, strlen(PluginName));
const WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(NameString);
```

## Creating Module Instances from Plug-ins

With the plug-in context, developers can create module instances by providing the module name:

```c
/* Assume that the `PluginCxt` is the context to the wasi_crypto plug-in. */

/* List the available host modules in the plug-in. */
WasmEdge_String Names[20];
uint32_t ModuleLen = WasmEdge_PluginListModule(PluginCxt, Names, 20);
for (uint32_t I = 0; I < ModuleLen; I++) {
  /* Will print the available host module names in the plug-in. */
  printf(""%s\n"", Names[I].Buf);
}
/* Will print here for the WASI-Crypto plug-in here:
 * wasi_ephemeral_crypto_asymmetric_common
 * wasi_ephemeral_crypto_common
 * wasi_ephemeral_crypto_kx
 * wasi_ephemeral_crypto_signatures
 * wasi_ephemeral_crypto_symmetric
 */

/* Create a module instance from the plug-in by the module name. */
const char ModuleName[] = ""wasi_ephemeral_crypto_common"";
WasmEdge_String NameString =
    WasmEdge_StringWrap(ModuleName, strlen(ModuleName));
WasmEdge_ModuleInstance *ModCxt =
    WasmEdge_PluginCreateModule(PluginCxt, NameString);

WasmEdge_ModuleInstanceDelete(ModCxt);
```

There may be several plug-ins in the default plug-in paths if users [installed WasmEdge plug-ins by the installer](/contribute/installer.md#plugins).

Before using the plug-ins, developers should [Loading Plug-ins from Paths](#loading-plug-ins-from-paths).

## Automatic Module Creation and Mocking

Upon creating a `VM` context, the WasmEdge runtime will automatically create and register the modules of loaded plug-ins. In cases where specific plug-ins are not loaded, WasmEdge will provide mock implementations for certain host modules. These mocked modules include:

- `wasi_ephemeral_crypto_asymmetric_common` (for the `WASI-Crypto`)
- `wasi_ephemeral_crypto_common` (for the `WASI-Crypto`)
- `wasi_ephemeral_crypto_kx` (for the `WASI-Crypto`)
- `wasi_ephemeral_crypto_signatures` (for the `WASI-Crypto`)
- `wasi_ephemeral_crypto_symmetric` (for the `WASI-Crypto`)
- `wasi_ephemeral_nn`
- `wasi_snapshot_preview1`
- `wasmedge_httpsreq`
- `wasmedge_process`

## Handling Missing Plug-ins and Error Messages

When the WASM want to invoke these host functions but the corresponding plug-in is not installed, WasmEdge will print the error message and return an error.

```c
/* Load the plug-ins in the default paths first. */
WasmEdge_PluginLoadWithDefaultPaths();
/* Create the configure context and add the WASI configuration. */
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt,
                                        WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
WasmEdge_ConfigureDelete(ConfCxt);
/* The following API can retrieve the registered modules in the VM context,
* includes the built-in WASI and the plug-ins.
*/
/*
* This API will return `NULL` if the module instance is not found.
*/
WasmEdge_String WasiName =
    WasmEdge_StringCreateByCString(""wasi_snapshot_preview1"");
/* The `WasiModule` will not be `NULL` because the configuration was set. */
const WasmEdge_ModuleInstanceContext *WasiModule =
    WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);
WasmEdge_StringDelete(WasiName);
WasmEdge_String WasiNNName =
    WasmEdge_StringCreateByCString(""wasi_ephemeral_nn"");
/* The `WasiNNModule` will not be `NULL` even if the wasi_nn plug-in is not
* installed, because the VM context will mock and register the host
* modules.
*/
const WasmEdge_ModuleInstanceContext *WasiNNModule =
    WasmEdge_VMGetRegisteredModule(VMCxt, WasiNNName);
WasmEdge_StringDelete(WasiNNName);

WasmEdge_VMDelete(VMCxt);
```
","**Summary**

The code provides an overview of how to use WasmEdge plug-ins in C programming language. Plug-ins are shared libraries that can extend the functionality of the WasmEdge runtime. The code covers various aspects, including:

1. **Loading plug-ins**: How to load plug-ins from specific paths using `WasmEdge_PluginLoadWithDefaultPaths()` or by passing a path as an argument.
2. **Listing loaded plug-ins**: How to list the names of loaded plug-ins using `WasmEdge_PluginListPlugins()`.
3. **Getting plug-in context by name**: How to obtain the plug-in context by its name using `WasmEdge_PluginFind()`.
4. **Creating module instances from plug-ins**: How to create module instances from a specific plug-in context using `WasmEdge_PluginCreateModule()`.

**Key Components**

1. `WasmEdge_PluginLoadWithDefaultPaths()`: Loads plug-ins from the default paths.
2. `WasmEdge_PluginListPlugins()`: Lists the names of loaded plug-ins.
3. `WasmEdge_PluginFind()`: Finds a plug-in context by its name.
4. `WasmEdge_PluginCreateModule()`: Creates a module instance from a specific plug-in context.

**Potential Issues**

1. **Missing plug-ins**: If a plug-in is not installed, WasmEdge will print an error message and return an error.
2. **Incorrect path**: Passing an incorrect path to load a plug-in may result in an error.
3. **Plugin version compatibility**: Using a plug-in with an incompatible version of WasmEdge may lead to errors.

**Improvement Suggestions**

1. **Error handling**: Implement more robust error handling mechanisms, such as providing detailed error messages and returning error codes.
2. **Documentation**: Improve documentation for the plug-ins and their usage in C programming language.
3. **Testing**: Conduct thorough testing of the plug-ins with different scenarios to ensure compatibility and functionality."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/containerd-crun.md,"---
sidebar_position: 2
---

# containerd + crun

## Quick start

The [GitHub repo](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on containerd.

- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd.yml)
- HTTP service example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd-server.yml)

In the sections below, we will explain the steps in the quick start scripts.

- [containerd + crun](#containerd--crun)
  - [Quick start](#quick-start)
  - [Install containerd](#install-containerd)
  - [Run a simple WebAssembly app](#run-a-simple-webassembly-app)
  - [Run a HTTP server app](#run-a-http-server-app)

## Install containerd

Use the following commands to install containerd on your system.

```bash
export VERSION=""1.5.7""
echo -e ""Version: $VERSION""
echo -e ""Installing libseccomp2 ...""
sudo apt install -y libseccomp2
echo -e ""Installing wget""
sudo apt install -y wget

wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum
sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum

sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
sudo systemctl daemon-reload
```

Configure containerd to use `crun` as the underlying OCI runtime. It changes the `/etc/containerd/config.toml` file.

```bash
sudo mkdir -p /etc/containerd/
sudo bash -c ""containerd config default > /etc/containerd/config.toml""
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff
sudo patch -d/ -p0 < containerd_config.diff
```

Start the containerd service.

```bash
sudo systemctl start containerd
```

Next, make sure that you have [built and installed the `crun` binary with WasmEdge support](../oci-runtime/crun.md) before running the following examples.

## Run a simple WebAssembly app

Now, we can run a simple WebAssembly program using containerd. [A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md) explains how to compile, package, and publish the WebAssembly program as a container image to Docker hub. This section will start pulling this WebAssembly-based container image from the Docker hub using containerd tools.

```bash
sudo ctr i pull docker.io/wasmedge/example-wasi:latest
```

Now, you can run the example in just one line with ctr (the containerd cli).

```bash
sudo ctr run --rm --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest wasm-example /wasi_example_main.wasm 50000000
```

Starting the container would execute the WebAssembly program. You can see the output in the console.

```bash
Creating POD ...
Random number: -1678124602
Random bytes: [12, 222, 246, 184, 139, 182, 97, 3, 74, 155, 107, 243, 20, 164, 175, 250, 60, 9, 98, 25, 244, 92, 224, 233, 221, 196, 112, 97, 151, 155, 19, 204, 54, 136, 171, 93, 204, 129, 177, 163, 187, 52, 33, 32, 63, 104, 128, 20, 204, 60, 40, 183, 236, 220, 130, 41, 74, 181, 103, 178, 43, 231, 92, 211, 219, 47, 223, 137, 70, 70, 132, 96, 208, 126, 142, 0, 133, 166, 112, 63, 126, 164, 122, 49, 94, 80, 26, 110, 124, 114, 108, 90, 62, 250, 195, 19, 189, 203, 175, 189, 236, 112, 203, 230, 104, 130, 150, 39, 113, 240, 17, 252, 115, 42, 12, 185, 62, 145, 161, 3, 37, 161, 195, 138, 232, 39, 235, 222]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
```

Next, you can run it in [Kubernetes](../kubernetes/kubernetes-containerd-crun.md#a-simple-webassembly-app)!

## Run a HTTP server app

Finally, we can run a simple WebAssembly-based HTTP micro-service in containerd. [A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md) explains how to compile, package, and publish the WebAssembly program as a container image to Docker hub. This section will start pulling this WebAssembly-based container image from the Docker hub using containerd tools.

```bash
sudo ctr i pull docker.io/wasmedge/example-wasi-http:latest
```

Now, you can run the example in just one line with ctr (the containerd cli). Notice that we are running the container with `--net-host` so that the HTTP server inside the WasmEdge container is accessible from the outside shell.

```bash
sudo ctr run --rm --net-host --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi-http:latest http-server-example /http_server.wasm
```

Starting the container would execute the WebAssembly program. You can see the output in the console.

```bash
new connection at 1234

# Test the HTTP service at that IP address
curl -d ""name=WasmEdge"" -X POST http://127.0.0.1:1234
echo: name=WasmEdge
```

Next, you can run it in [Kubernetes](../kubernetes/kubernetes-containerd-crun.md#a-webassembly-based-http-service)!
","**Code Analysis Summary**

This is a Markdown documentation file for a containerized WebAssembly runtime using containerd and crun. The code provides instructions on how to install containerd, configure it to use crun as the underlying OCI runtime, and run simple WebAssembly applications.

**Key Components:**

1. **Installation of containerd**: The code includes shell commands to download and install the latest version of containerd.
2. **Configuration of containerd**: The `containerd_config.diff` file is used to patch the `/etc/containerd/config.toml` file to use crun as the underlying OCI runtime.
3. **Starting containerd service**: The code uses `systemctl start` to start the containerd service.
4. **Running WebAssembly applications**: Two examples are provided: a simple WebAssembly program and an HTTP server application.

**Potential Issues or Areas for Improvement:**

1. **Dependency management**: The code assumes that crun is built with WasmEdge support, but this might not be the case in all environments. Consider adding instructions on how to build and install crun with WasmEdge support.
2. **Error handling**: The code does not include error handling mechanisms for potential issues during installation or execution of containerd or WebAssembly applications.
3. **Security considerations**: Running containerized applications requires careful consideration of security measures, such as network isolation, access control, and secure communication between containers.

**Best Practices:**

1. **Use versioned dependencies**: Use specific versions of dependencies (e.g., `containerd` and `crun`) to ensure reproducibility and compatibility.
2. **Document assumptions and prerequisites**: Clearly document assumptions and prerequisites for the code to run successfully, such as required software or hardware configurations.
3. **Test and verify**: Include automated testing and verification mechanisms to ensure that the code works as expected in different environments.

Overall, this code provides a good starting point for containerized WebAssembly development using containerd and crun, but requires further refinement and validation to handle potential issues and improve robustness."
i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/c_sdk.md,"---
sidebar_position: 1
---

# Using Plug-ins to Extend the Runtime in C

The WasmEdge plug-ins are the shared libraries to provide the WasmEdge runtime to load and create host module instances. With the plug-ins, the WasmEdge runtime can be extended more easily.

## Loading Plug-ins from Paths

Developers can start using WasmEdge plug-ins by loading them from specific paths. To load plug-ins from the default paths, the following API can be used:

```c
WasmEdge_PluginLoadWithDefaultPaths();
```

Once this API is called, plug-ins from the default paths will be loaded. The default paths include:

- The path specified in the `WASMEDGE_PLUGIN_PATH` environment variable.
- The `../plugin/` directory relative to the WasmEdge installation path.
- The `./wasmedge/` directory under the library path if WasmEdge is installed in a system directory (e.g., `/usr` and `/usr/local`).

Developers can also load plug-ins from specific paths using this API:

```c
WasmEdge_PluginLoadFromPath(""PATH_TO_PLUGIN/plugin.so"");
```

## Listing Loaded Plug-ins

Once plug-ins are loaded, developers can list the loaded plug-in names using the following approach:

```c
WasmEdge_PluginLoadWithDefaultPaths();
printf(""Number of loaded plug-ins: %d\n"", WasmEdge_PluginListPluginsLength());

WasmEdge_String Names[20];
uint32_t NumPlugins = WasmEdge_PluginListPlugins(Names, 20);
for (int I = 0; I < NumPlugins; I++) {
  printf(""Plug-in %d name: %s\n"", I, Names[I].Buf);
}
```

## Getting Plug-in Context by Name

Developers can obtain the plug-in context by its name using the following method:

```c
/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */
WasmEdge_PluginLoadWithDefaultPaths();

const char PluginName[] = ""wasi_crypto"";
WasmEdge_String NameString =
    WasmEdge_StringWrap(PluginName, strlen(PluginName));
const WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(NameString);
```

## Creating Module Instances from Plug-ins

With the plug-in context, developers can create module instances by providing the module name:

```c
/* Assume that the `PluginCxt` is the context to the wasi_crypto plug-in. */

/* List the available host modules in the plug-in. */
WasmEdge_String Names[20];
uint32_t ModuleLen = WasmEdge_PluginListModule(PluginCxt, Names, 20);
for (uint32_t I = 0; I < ModuleLen; I++) {
  /* Will print the available host module names in the plug-in. */
  printf(""%s\n"", Names[I].Buf);
}
/* Will print here for the WASI-Crypto plug-in here:
 * wasi_ephemeral_crypto_asymmetric_common
 * wasi_ephemeral_crypto_common
 * wasi_ephemeral_crypto_kx
 * wasi_ephemeral_crypto_signatures
 * wasi_ephemeral_crypto_symmetric
 */

/* Create a module instance from the plug-in by the module name. */
const char ModuleName[] = ""wasi_ephemeral_crypto_common"";
WasmEdge_String NameString =
    WasmEdge_StringWrap(ModuleName, strlen(ModuleName));
WasmEdge_ModuleInstance *ModCxt =
    WasmEdge_PluginCreateModule(PluginCxt, NameString);

WasmEdge_ModuleInstanceDelete(ModCxt);
```

There may be several plug-ins in the default plug-in paths if users [installed WasmEdge plug-ins by the installer](/contribute/installer.md#plugins).

Before using the plug-ins, developers should [Loading Plug-ins from Paths](#loading-plug-ins-from-paths).

## Automatic Module Creation and Mocking

Upon creating a `VM` context, the WasmEdge runtime will automatically create and register the modules of loaded plug-ins. In cases where specific plug-ins are not loaded, WasmEdge will provide mock implementations for certain host modules. These mocked modules include:

- `wasi_ephemeral_crypto_asymmetric_common` (for the `WASI-Crypto`)
- `wasi_ephemeral_crypto_common` (for the `WASI-Crypto`)
- `wasi_ephemeral_crypto_kx` (for the `WASI-Crypto`)
- `wasi_ephemeral_crypto_signatures` (for the `WASI-Crypto`)
- `wasi_ephemeral_crypto_symmetric` (for the `WASI-Crypto`)
- `wasi_ephemeral_nn`
- `wasi_snapshot_preview1`
- `wasmedge_httpsreq`
- `wasmedge_process`

## Handling Missing Plug-ins and Error Messages

When the WASM want to invoke these host functions but the corresponding plug-in is not installed, WasmEdge will print the error message and return an error.

```c
/* Load the plug-ins in the default paths first. */
WasmEdge_PluginLoadWithDefaultPaths();
/* Create the configure context and add the WASI configuration. */
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt,
                                        WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
WasmEdge_ConfigureDelete(ConfCxt);
/* The following API can retrieve the registered modules in the VM context,
* includes the built-in WASI and the plug-ins.
*/
/*
* This API will return `NULL` if the module instance is not found.
*/
WasmEdge_String WasiName =
    WasmEdge_StringCreateByCString(""wasi_snapshot_preview1"");
/* The `WasiModule` will not be `NULL` because the configuration was set. */
const WasmEdge_ModuleInstanceContext *WasiModule =
    WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);
WasmEdge_StringDelete(WasiName);
WasmEdge_String WasiNNName =
    WasmEdge_StringCreateByCString(""wasi_ephemeral_nn"");
/* The `WasiNNModule` will not be `NULL` even if the wasi_nn plug-in is not
* installed, because the VM context will mock and register the host
* modules.
*/
const WasmEdge_ModuleInstanceContext *WasiNNModule =
    WasmEdge_VMGetRegisteredModule(VMCxt, WasiNNName);
WasmEdge_StringDelete(WasiNNName);

WasmEdge_VMDelete(VMCxt);
```
","**Summary**

The provided code is a documentation for the WasmEdge runtime, specifically explaining how to use plug-ins to extend its functionality. It covers loading plug-ins from specific paths, listing loaded plug-in names, obtaining plug-in contexts by name, and creating module instances from plug-ins.

**Key Components**

1. **Loading Plug-ins**: The code provides two APIs for loading plug-ins:
	* `WasmEdge_PluginLoadWithDefaultPaths()`: Loads plug-ins from default paths specified in the environment variable `WASMEDGE_PLUGIN_PATH`, relative to the WasmEdge installation path, and under the library path if installed in a system directory.
	* `WasmEdge_PluginLoadFromPath(""PATH_TO_PLUGIN/plugin.so"")`: Loads a specific plug-in from a given path.
2. **Listing Loaded Plug-ins**: The code shows how to list loaded plug-in names using the `WasmEdge_PluginListPlugins()` function, which takes an array of `WasmEdge_String` objects as input and returns their lengths.
3. **Getting Plug-in Context by Name**: The code demonstrates how to obtain a plug-in context by its name using the `WasmEdge_PluginFind()` function, which takes a `WasmEdge_String` object as input.
4. **Creating Module Instances from Plug-ins**: Once a plug-in context is obtained, the code shows how to create module instances by providing the module name using the `WasmEdge_PluginCreateModule()` function.

**Potential Issues and Areas for Improvement**

1. **Error Handling**: The code does not provide explicit error handling for some API calls, which could lead to undefined behavior or crashes.
2. **Plugin Management**: The code assumes that plug-ins are loaded from specific paths or default paths, but it does not provide a way to manage multiple versions of the same plug-in or unload loaded plug-ins.
3. **Module Instance Creation**: The code creates module instances using the `WasmEdge_PluginCreateModule()` function, but it does not handle cases where the plugin instance is null or the module instance creation fails.

To address these issues and areas for improvement, additional documentation, API modifications, or implementation changes may be necessary to ensure that plug-ins are loaded and managed correctly, and error handling is implemented effectively."
docs/contribute/source/os/android/cli.md,"---
sidebar_position: 2
---

# CLI Tools

In this section, we will show you how to use WasmEdge CLI tools on Android devices. We will showcase a full WasmEdge demo to perform image classification (Tensorflow-based AI inference) on an Android device.

<!-- prettier-ignore -->
:::note
The `WasmEdge-tensorflow-tools` has been deprecated after the 0.12.1 version. We'll update to use the WasmEdge plug-in in the future.
:::

## Install Android version of WasmEdge-TensorFlow-Tools

First, install WasmEdge-TensorFlow-Tools pre-release on your Android device. It works with the Android version of TensorFlow-Lite dynamic shared library.

### Preparation

#### Android developer options

Currently, WasmEdge only supports the arm64-v8a architecture on Android devices. You need an arm64-v8a Android simulator or a physical device with [developer options turned on](https://developer.android.com/studio/debug/dev-options). WasmEdge requires Android 6.0 and above.

#### Android development CLI

In Ubuntu Linux, you can use the `apt-get` command to install Android debugging and testing tool `adb`. Using the `adb shell` command on the Ubuntu dev machine, you can open a CLI shell to execute commands on the connected Android device.

```bash
$ sudo apt-get install adb
$ adb devices
* daemon not running; starting now at tcp:5037
* daemon started successfully
List of devices attached
c657c643 device
$ adb shell
sirius:/ $
```

### Install WasmEdge-TensorFlow-Tools packages

Use the following commands on your Ubuntu dev machine to download the WasmEdge-TensorFlow-Tools pre-release packages.

```bash
$ wget https://github.com/second-state/WasmEdge-tensorflow-tools/releases/download/0.12.1/WasmEdge-tensorflow-tools-0.12.1-android_aarch64.tar.gz
$ mkdir WasmEdge-tensorflow-tools && tar zxvf WasmEdge-tensorflow-tools-0.12.1-android_aarch64.tar.gz -C WasmEdge-tensorflow-tools
show-tflite-tensor
wasmedge-tensorflow-lite
```

### Install Android version of the TensorFlow-Lite shared library

We provide an Android compatible version of TensorFlow-Lite dynamic shared library in the WasmEdge-Tensorflow-deps package. Download the package to your Ubuntu dev machine as follows.

```bash
$ wget https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/0.12.1/WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz
$ tar zxvf WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz -C WasmEdge-tensorflow-tools
libtensorflowlite_c.so
```

Next use the `adb` tool to push the downloaded WasmEdge-TensorFlow packages onto a connected Android device.

```bash
adb push WasmEdge-tensorflow-tools /data/local/tmp
```

## Try it out

### Sample application

In this example, we will demonstrate a standard [WasmEdge Tensorflow-Lite sample application](https://github.com/second-state/wasm-learning/tree/master/rust/birds_v1). It can recognize and classify the bird type from a JPG or PNG picture of a bird. The explanation of the source code can be [found here](/develop/rust/wasinn/tensorflow_lite).

```bash
git clone https://github.com/second-state/wasm-learning.git
cd wasm-learning/rust/birds_v1
```

Use the `cargo` command to build a WASM bytecode file from the Rust source code. The WASM file is located at `target/wasm32-wasi/release/birds_v1.wasm`.

```bash
rustup target add wasm32-wasi
cargo build --release --target=wasm32-wasi
```

Push the WASM bytecode file, tensorflow lite model file, and the test bird picture file onto the Android device using `adb`.

```bash
adb push target/wasm32-wasi/release/birds_v1.wasm /data/local/tmp/WasmEdge-tensorflow-tools
adb push lite-model_aiy_vision_classifier_birds_V1_3.tflite /data/local/tmp/WasmEdge-tensorflow-tools
adb push bird.jpg /data/local/tmp/WasmEdge-tensorflow-tools
```

### Run the WasmEdge-TensorFlow-Tools

Type `adb shell` from the Ubuntu CLI to open a command shell for the connected Android device. Confirm that the tools, programs, and test image are all available on the Android device under the `/data/local/tmp/WasmEdge-tensorflow-tools` folder.

```bash
$ adb shell
sirius:/ $ cd /data/local/tmp/WasmEdge-tensorflow-tools
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ls
bird.jpg               lite-model_aiy_vision_classifier_birds_V1_3.tflite
birds_v1.wasm          show-tflite-tensor
libtensorflowlite_c.so wasmedge-tensorflow-lite
```

Load the TensorFlow-Lite dynamic shared library, and use the `show-tflite-tensor` CLI tool to examine the Tensorflow Lite model file.

```bash
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ chmod 777 show-tflite-tensor
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ./show-tflite-tensor lite-model_aiy_vision_classifier_birds_V1_3.tflite
INFO: Initialized TensorFlow Lite runtime.
Input tensor nums: 1
    Input tensor name: module/hub_input/images_uint8
        dimensions: [1 , 224 , 224 , 3]
        data type: UInt8
        tensor byte size: 150528
Output tensor nums: 1
    Output tensor name: module/prediction
        dimensions: [1 , 965]
        data type: UInt8
        tensor byte size: 965
```

Use the extended WasmEdge Runtime in `wasmedge-tensorflow-lite` to execute the compiled WASM program on the Android device. It loads the Tensorflow Lite model and bird image, and outputs the bird classification and its confidence.

```bash
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ chmod 777 wasmedge-tensorflow-lite
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ./wasmedge-tensorflow-lite --dir .:. birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
INFO: Initialized TensorFlow Lite runtime.
166 : 0.84705883
```

The result shows that the bird type is in [line 166 of the label file](https://github.com/second-state/wasm-learning/blob/master/rust/birds_v1/aiy_birds_V1_labels.txt#L166) (Sicalis flaveola) and the confidence level is 84.7%.
","**Summary**

This documentation provides a step-by-step guide to setting up and running a WasmEdge Tensorflow-Lite application on an Android device. The process involves installing the necessary packages, pushing them onto the Android device using `adb`, and executing the compiled WASM program.

**Key Components**

1. **WasmEdge-TensorFlow-Tools**: A package containing pre-release binaries for Android.
2. **TensorFlow-Lite shared library**: An Android-compatible version of the dynamic shared library.
3. **show-tflite-tensor CLI tool**: Examines the Tensorflow Lite model file.
4. **wasmedge-tensorflow-lite**: Executes the compiled WASM program on the Android device, loading the Tensorflow Lite model and input image.

**Potential Issues/Improvements**

1. **Deprecation notice**: The `WasmEdge-tensorflow-tools` package has been deprecated after version 0.12.1.
2. **Android architecture support**: WasmEdge only supports arm64-v8a architecture on Android devices.
3. **ADB installation and usage**: Users need to install and use `adb` correctly to push packages onto the Android device.
4. **Error handling**: The documentation does not provide explicit error handling mechanisms for potential issues that may arise during the setup and execution process.

**Code Quality**

The provided code is well-structured and follows a clear, step-by-step approach to setting up and running the WasmEdge Tensorflow-Lite application on an Android device. However, there are some minor improvements that can be made:

1. **Comments**: Add more comments to explain complex sections of code and provide additional context.
2. **Code organization**: Consider organizing the code into separate files or modules for better maintainability.
3. **Error handling**: Implement explicit error handling mechanisms to handle potential issues that may arise during the setup and execution process."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/cli.md,"---
sidebar_position: 2
---

# CLI Tools

In this section, we will show you how to use WasmEdge CLI tools on Android devices. We will showcase a full WasmEdge demo to perform image classification (Tensorflow-based AI inference) on an Android device.

<!-- prettier-ignore -->
:::note
The `WasmEdge-tensorflow-tools` has been deprecated after the 0.12.1 version. We'll update to use the WasmEdge plug-in in the future.
:::

## Install Android version of WasmEdge-TensorFlow-Tools

First, install WasmEdge-TensorFlow-Tools pre-release on your Android device. It works with the Android version of TensorFlow-Lite dynamic shared library.

### Preparation

#### Android developer options

Currently, WasmEdge only supports the arm64-v8a architecture on Android devices. You need an arm64-v8a Android simulator or a physical device with [developer options turned on](https://developer.android.com/studio/debug/dev-options). WasmEdge requires Android 6.0 and above.

#### Android development CLI

In Ubuntu Linux, you can use the `apt-get` command to install Android debugging and testing tool `adb`. Using the `adb shell` command on the Ubuntu dev machine, you can open a CLI shell to execute commands on the connected Android device.

```bash
$ sudo apt-get install adb
$ adb devices
* daemon not running; starting now at tcp:5037
* daemon started successfully
List of devices attached
c657c643 device
$ adb shell
sirius:/ $
```

### Install WasmEdge-TensorFlow-Tools packages

Use the following commands on your Ubuntu dev machine to download the WasmEdge-TensorFlow-Tools pre-release packages.

```bash
$ wget https://github.com/second-state/WasmEdge-tensorflow-tools/releases/download/0.12.1/WasmEdge-tensorflow-tools-0.12.1-android_aarch64.tar.gz
$ mkdir WasmEdge-tensorflow-tools && tar zxvf WasmEdge-tensorflow-tools-0.12.1-android_aarch64.tar.gz -C WasmEdge-tensorflow-tools
show-tflite-tensor
wasmedge-tensorflow-lite
```

### Install Android version of the TensorFlow-Lite shared library

We provide an Android compatible version of TensorFlow-Lite dynamic shared library in the WasmEdge-Tensorflow-deps package. Download the package to your Ubuntu dev machine as follows.

```bash
$ wget https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/0.12.1/WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz
$ tar zxvf WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz -C WasmEdge-tensorflow-tools
libtensorflowlite_c.so
```

Next use the `adb` tool to push the downloaded WasmEdge-TensorFlow packages onto a connected Android device.

```bash
adb push WasmEdge-tensorflow-tools /data/local/tmp
```

## Try it out

### Sample application

In this example, we will demonstrate a standard [WasmEdge Tensorflow-Lite sample application](https://github.com/second-state/wasm-learning/tree/master/rust/birds_v1). It can recognize and classify the bird type from a JPG or PNG picture of a bird. The explanation of the source code can be [found here](/develop/rust/wasinn/tensorflow_lite).

```bash
git clone https://github.com/second-state/wasm-learning.git
cd wasm-learning/rust/birds_v1
```

Use the `cargo` command to build a WASM bytecode file from the Rust source code. The WASM file is located at `target/wasm32-wasi/release/birds_v1.wasm`.

```bash
rustup target add wasm32-wasi
cargo build --release --target=wasm32-wasi
```

Push the WASM bytecode file, tensorflow lite model file, and the test bird picture file onto the Android device using `adb`.

```bash
adb push target/wasm32-wasi/release/birds_v1.wasm /data/local/tmp/WasmEdge-tensorflow-tools
adb push lite-model_aiy_vision_classifier_birds_V1_3.tflite /data/local/tmp/WasmEdge-tensorflow-tools
adb push bird.jpg /data/local/tmp/WasmEdge-tensorflow-tools
```

### Run the WasmEdge-TensorFlow-Tools

Type `adb shell` from the Ubuntu CLI to open a command shell for the connected Android device. Confirm that the tools, programs, and test image are all available on the Android device under the `/data/local/tmp/WasmEdge-tensorflow-tools` folder.

```bash
$ adb shell
sirius:/ $ cd /data/local/tmp/WasmEdge-tensorflow-tools
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ls
bird.jpg               lite-model_aiy_vision_classifier_birds_V1_3.tflite
birds_v1.wasm          show-tflite-tensor
libtensorflowlite_c.so wasmedge-tensorflow-lite
```

Load the TensorFlow-Lite dynamic shared library, and use the `show-tflite-tensor` CLI tool to examine the Tensorflow Lite model file.

```bash
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ chmod 777 show-tflite-tensor
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ./show-tflite-tensor lite-model_aiy_vision_classifier_birds_V1_3.tflite
INFO: Initialized TensorFlow Lite runtime.
Input tensor nums: 1
    Input tensor name: module/hub_input/images_uint8
        dimensions: [1 , 224 , 224 , 3]
        data type: UInt8
        tensor byte size: 150528
Output tensor nums: 1
    Output tensor name: module/prediction
        dimensions: [1 , 965]
        data type: UInt8
        tensor byte size: 965
```

Use the extended WasmEdge Runtime in `wasmedge-tensorflow-lite` to execute the compiled WASM program on the Android device. It loads the Tensorflow Lite model and bird image, and outputs the bird classification and its confidence.

```bash
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ chmod 777 wasmedge-tensorflow-lite
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ./wasmedge-tensorflow-lite --dir .:. birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
INFO: Initialized TensorFlow Lite runtime.
166 : 0.84705883
```

The result shows that the bird type is in [line 166 of the label file](https://github.com/second-state/wasm-learning/blob/master/rust/birds_v1/aiy_birds_V1_labels.txt#L166) (Sicalis flaveola) and the confidence level is 84.7%.
","**Code Analysis Summary**

This document guides users on how to use WasmEdge CLI tools on Android devices for image classification using TensorFlow Lite. It outlines the preparation, installation, and execution of a sample application.

**Key Components:**

1. **WasmEdge-TensorFlow-Tools**: A deprecated tool for TensorFlow Lite integration.
2. **Android development setup**: Requires an arm64-v8a architecture Android simulator or device with developer options enabled.
3. **ADB (Android Debug Bridge)**: Used to install and execute tools on the Android device from a Ubuntu Linux machine.
4. **TensorFlow Lite model and image**: A sample application is used, which consists of a TensorFlow Lite model (lite-model_aiy_vision_classifier_birds_V1_3.tflite) and an image file (bird.jpg).
5. **WASM bytecode compilation**: The Rust source code is compiled into WASM bytecode using the `cargo` command.
6. **Execution on Android device**: The WASM bytecode, TensorFlow Lite model, and image are pushed to the Android device using ADB. The `wasmedge-tensorflow-lite` tool executes the compiled WASM program on the device.

**Potential Issues or Areas for Improvement:**

1. **Deprecated Tool**: WasmEdge-TensorFlow-Tools has been deprecated, and alternative solutions should be explored.
2. **Android Compatibility**: The guide assumes an arm64-v8a architecture Android simulator or device with developer options enabled. Other architectures and devices might require adjustments.
3. **ADB Setup**: ADB setup on Ubuntu Linux may require additional dependencies or configurations.
4. **TensorFlow Lite Model**: Using a sample model might not be representative of real-world applications. Consider providing more diverse models or explaining the process for creating custom models.
5. **WASM Bytecode Compilation**: The guide assumes familiarity with Rust and the `cargo` command-line tool. Additional instructions or examples could help users who are new to these tools.
6. **Execution on Android Device**: Ensure that the execution steps are clear, concise, and easy to follow, especially for users without prior experience with ADB or WASM.

Overall, this guide provides a comprehensive overview of using WasmEdge CLI tools on Android devices for image classification. However, it assumes some familiarity with Android development, Rust, and TensorFlow Lite. Additional examples, instructions, and clarifications can help make the guide more accessible to users with varying levels of expertise."
docs/start/wasmedge/extensions/plugins.md,"---
sidebar_position: 2
---

# WasmEdge Plug-ins

For those workloads which are too heavy to compile into WebAssembly, it would be more appropriate to build them into native host functions. To satisfy the portability of WebAssembly runtime, WasmEdge introduced the plug-in mechanism to make the host functions loadable and portable.

The plug-in mechanism for WasmEdge is an easy way to extend the host modules from loadable shared libraries. With the plug-ins, users can load and instantiate the host functions from the shared libraries released by WasmEdge official or even by other developers.

## Official Released Plug-ins

The following lists are the WasmEdge official released plug-ins. Users can install them easily by the installer.

| Plug-in | Description | Platform Support | Guest Language Support | Build From Source |
|---------|-------------|------------------|------------------------|-------------------|
| [WasmEdge-Process](../../../contribute/source/plugin/process.md) | Allows WebAssembly programs to execute native commands in the host operating system. It supports passing arguments, environment variables, `STDIN`/`STDOUT` pipes, and security policies for host access. | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>(since `0.10.0`) | [Rust](https://crates.io/crates/wasmedge_process_interface) | [Steps](../../../contribute/source/plugin/process.md) |
| [WASI-Crypto](https://github.com/WebAssembly/wasi-crypto) | APIs that a runtime can expose to WebAssembly modules in order to perform cryptographic operations and key management. | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>(since `0.10.1`) | [Rust](https://crates.io/crates/wasi-crypto) | [Steps](../../../contribute/source/plugin/wasi_crypto.md) |
| [WASI-NN](https://github.com/WebAssembly/wasi-nn) [(OpenVINO backend)](../../../develop/rust/wasinn/openvino.md) | AI inference using OpenVINO models. | `ubuntu 20.04 (x86_64)`<br/>(since `0.10.1`) | [Rust](https://crates.io/crates/wasi-nn), JavaScript | [Steps](../../../contribute/source/plugin/wasi_nn.md#build-wasmedge-with-wasi-nn-openvino-backend) |
| [WASI-NN](https://github.com/WebAssembly/wasi-nn) [(Pytorch backend)](../../../develop/rust/wasinn/pytorch.md) | AI inference using Pytorch models. | `manylinux2014 (x86_64)`<br/>`ubuntu 20.04 (x86_64)`<br/>(since `0.11.1`) | [Rust](https://crates.io/crates/wasi-nn), JavaScript | [Steps](../../../contribute/source/plugin/wasi_nn.md#build-wasmedge-with-wasi-nn-pytorch-backend) |
| [WASI-NN](https://github.com/WebAssembly/wasi-nn) [(TensorFlow-Lite backend)](../../../develop/rust/wasinn/tensorflow_lite.md) | AI inference using TensorFlow-Lite models. | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>(since `0.11.2`) | [Rust](https://crates.io/crates/wasi-nn), JavaScript | [Steps](../../../contribute/source/plugin/wasi_nn.md#build-wasmedge-with-wasi-nn-tensorflow-lite-backend) |
| [WASI-NN](https://github.com/WebAssembly/wasi-nn) [(Ggml backend)](../../../develop/rust/wasinn/llm_inference.md) | AI inference using LLM interfaces. | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.13.4`) | [Rust](https://github.com/second-state/wasmedge-wasi-nn) | [Steps](../../../contribute/source/plugin/wasi_nn.md#build-wasmedge-with-wasi-nn-llamacpp-backend) |
| [WASI-Logging](https://github.com/WebAssembly/wasi-logging) | Logging API for WebAssembly program to log messages. | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.13.0`) | Rust | [Steps](../../../contribute/source/plugin/wasi_logging.md) |
| [WasmEdge-Image](../../../contribute/source/plugin/image.md) | A native library to manipulate images for AI inference tasks. | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.13.0`) | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface) (0.3.0) | [Steps](../../../contribute/source/plugin/image.md) |
| [WasmEdge-Tensorflow](../../../contribute/source/plugin/tensorflow.md) | A native library for inferring TensorFlow models.| `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.13.0`) | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface) (0.3.0) | [Steps](../../../contribute/source/plugin/tensorflow.md) |
| [WasmEdge-TensorflowLite](../../../contribute/source/plugin/tensorflowlite.md)| A native library for inferring TensorFlow-Lite models. | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.13.0`) | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface) (0.3.0) | [Steps](../../../contribute/source/plugin/tensorflowlite.md) |
| WasmEdge-OpenCV | Very popular utility functions to process images and videos for AI input/output. | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.13.3`) | Rust | |
| [WasmEdge-eBPF](../../../contribute/source/plugin/ebpf.md) | A native library for inferring eBPF applications | `manylinux2014 (x86_64,  aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>(since `0.13.2`) | Rust | [Steps](../../../contribute/source/plugin/ebpf.md) |
| [WasmEdge-rustls](../../../contribute/source/plugin/rusttls.md) (DEPRECATED) | A native library for inferring Rust and TLS Library | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.13.0`, until `0.13.5`) | [Rust](https://crates.io/crates/wasmedge_rustls_api) | [Steps](../../../contribute/source/plugin/rusttls.md) |

## Old WasmEdge Extensions

Besides the plug-ins, WasmEdge provides the extensions before the `0.13.0` versions. Noticed that the extensions are replaced by the corresponding plug-ins after the `0.13.0` version.

The latest version supporting the extensions is `0.12.1`. This chapter will be deprecated when the `0.12.x` versions are no longer supported by the WasmEdge installer.

| Extension | Description | Platform Support | Language support |
| --- | --- | --- | --- |
| [Image processing](https://github.com/second-state/WasmEdge-image) | A native library to manipulate images for AI inference tasks. Migrated into the plug-in after WasmEdge `0.13.0`. | `manylinux2014 x86_64`, `manylinux2014 aarch64`, `android aarch64`, `ubuntu 20.04 x86_64`, and `darwin x86_64` | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface) (0.2.2) |
| [TensorFlow and Tensorflow-Lite](https://github.com/second-state/WasmEdge-tensorflow) | A native library to inferring TensorFlow and TensorFlow-Lite models. Migrated into the plug-in after WasmEdge `0.13.0`. | `manylinux2014 x86_64`, `manylinux2014 aarch64` (TensorFlow-Lite only), `android aarch64` (TensorFlow-Lite only), `ubuntu 20.04 x86_64`, and `darwin x86_64` | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface) (0.2.2) |
","**Summary**

WasmEdge is a WebAssembly runtime that introduced the plug-in mechanism to make host functions loadable and portable. The plug-ins allow users to extend the functionality of WasmEdge by loading native shared libraries, enabling support for heavy workloads that cannot be compiled into WebAssembly.

**Key Components**

1. **Plug-ins**: Shared libraries that can be loaded by WasmEdge to provide additional functionality.
2. **Host Functions**: Native functions that can be invoked from WebAssembly programs using the plug-in mechanism.
3. **Platform Support**: List of platforms (e.g., Linux, macOS, Android) where each plug-in is supported.

**Official Released Plug-ins**

1. WasmEdge-Process: Execute native commands in the host operating system.
2. WASI-Crypto: Perform cryptographic operations and key management.
3. WASI-NN: AI inference using OpenVINO, PyTorch, TensorFlow-Lite, or Ggml backend.
4. WASI-Logging: Logging API for WebAssembly programs.
5. WasmEdge-Image: Manipulate images for AI inference tasks.
6. WasmEdge-Tensorflow: Inferring TensorFlow models.
7. WasmEdge-TensorflowLite: Inferring TensorFlow-Lite models.
8. WasmEdge-OpenCV: Utility functions to process images and videos for AI input/output.
9. WasmEdge-eBPF: Inferring eBPF applications.

**Old WasmEdge Extensions**

These extensions will be deprecated as the corresponding plug-ins take their place.

1. Image Processing
2. TensorFlow and Tensorflow-Lite

**Potential Issues or Areas for Improvement**

1. **Complexity**: The list of plug-ins and platforms supported can be overwhelming, making it difficult for users to navigate.
2. **Deprecation**: Old extensions may still be used in existing projects, causing confusion when the corresponding plug-in is released.
3. **Documentation**: Detailed documentation for each plug-in and extension is essential to ensure smooth adoption.
4. **Community Engagement**: Regular updates and feedback from the community can help identify areas for improvement and prioritize development efforts.

**Recommendations**

1. Simplify the documentation and presentation of plug-ins and platforms supported.
2. Provide clear guidelines on when to use old extensions versus new plug-ins.
3. Continuously engage with the community to gather feedback and improve the ecosystem.
4. Prioritize development of key features and bug fixes based on user needs and adoption patterns."
docs/embed/quick-start/install.md,"---
sidebar_position: 1
---

# Install Notes

To use a kind of WasmEdge language SDK, you must install WasmEdge itself first. Please be noted, he version of WasmEdge's language SDKs should be the same as the version of WasmEdge. For example, If you want to use WasmEdge Go SDK v{{ wasmedge_go_version }}, then your WasmEdge version must be {{ wasmedge_go_version }} as well.

<!-- prettier-ignore -->
:::note
The releases of WasmEdge language SDKs follow the official version of WasmEdge. We don't release the alpha, beta, and RC versions for WasmEdge language SDKs. For the WasmEdge release process, please check [here](../../contribute/release.md).
:::

## Install WasmEdge GO SDK as an example

Let's take WasmEdge Go SDK as an example to show how to embed a WASM App in Rust to a Go Host application.

First, ensure you have installed [Go](https://go.dev/dl/) first. The Golang version should be above 1.16.

Next, let's install WasmEdge and WasmEdge Go SDK. Again, The WasmEdge and WasmEdge Go SDK should be the same version.

```bash
$ go version
go version go1.16.5 linux/amd64

# Install WasmEdge
$ curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_go_version }}

# Install WasmEdge-Go
$ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}
```

Now we have set up WasmEdge and WasmEdge Go SDK. Next, let's see how to create a WASM app using Rust and wasmedge-bindgen.

To embed WasmEdge into your host app, you must install WasmEdge itself and its corresponding WasmEdge's language bindings.

In this Quick Start guide, we use WasmEdge Go SDK as an example to show how it works. Primarily, we will use [a bindgen function](https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs) in rust to demonstrate how to call a few simple WebAssembly functions from a Go app.

Before we start, ensure you have installed [Go first](https://go.dev/dl/). The Golang version should be above 1.16.

First, let's install WasmEdge and WasmEdge Go SDK. **They should be in the same version**.

```bash
$ go version
go version go1.16.5 linux/amd64

# Install WasmEdge
$ curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_go_version }}

# Install WasmEdge-Go
$ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

# Install the WasmEdge-bindgen tool, which helps us handle complex data passing
$ go get github.com/second-state/wasmedge-bindgen@v0.4.1
```

<!-- prettier-ignore -->
:::note
For more advanced features like AI inference, please refer to [Go SDK For Embedding WASM Function Chapter](/category/go-sdk-for-embedding-wasmedge).
:::

Since the demo app includes [a compiled WASM file](https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs_lib.wasm) from [the Rust function](https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs), so we don't need to install the Rust toolchain to compile the Rust code to wasm.

## Run the demo

Now we have set up the basic environment, let's run the example.

```bash
# Get the source code of this example
$ git clone https://github.com/second-state/WasmEdge-go-examples.git
$ cd WasmEdge-go-examples//wasmedge-bindgen/go_BindgenFuncs/

# build the project
go build

# run the example
./bindgen_funcs rust_bindgen_funcs_lib.wasm
```

The standard output of this example will be the following:

```bash
Run bindgen -- create_line: {""points"":[{""x"":2.5,""y"":7.8},{""x"":2.5,""y"":5.8}],""valid"":true,""length"":2.0,""desc"":""A thin red line""}
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
```

## Achieve higher performance

Use the following command line if you want to get better performance.

```bash
# Use the AoT mode
wasmedgec rust_bindgen_funcs_lib.wasm rust_bindgen_funcs_lib.wasm

# Run the demo
./bindgen_funcs rust_bindgen_funcs_lib.wasm
```

That's it. Let's dive into [more examples with WasmEdge Go SDK](/category/go-sdk-for-embedding-wasmedge).
","**Summary**

This code is a Quick Start guide for installing and using the WasmEdge Go SDK. It provides instructions on how to install WasmEdge and its corresponding language bindings, including the Go SDK.

**Functionality**

The code covers the following steps:

1. Installing WasmEdge
2. Installing the WasmEdge Go SDK
3. Creating a WASM app using Rust and wasmedge-bindgen
4. Running the demo application

**Key Components**

* `wasmedge_install.sh`: A script to install WasmEdge
* `go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}`: Installs the WasmEdge Go SDK
* `github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs`: The source code for the demo application

**Potential Issues**

* The version of WasmEdge and its corresponding language bindings must be the same.
* The Golang version should be above 1.16.

**Improvement Suggestions**

* Consider adding more detailed instructions for installing WasmEdge on different operating systems.
* Provide more information on how to troubleshoot common issues with the installation process.
* Consider adding more examples of using the WasmEdge Go SDK, such as integrating it with other frameworks or libraries."
i18n/zh/docusaurus-plugin-content-docs/current/embed/quick-start/install.md,"---
sidebar_position: 1
---

# Install Notes

To use a kind of WasmEdge language SDK, you must install WasmEdge itself first. Please be noted, he version of WasmEdge's language SDKs should be the same as the version of WasmEdge. For example, If you want to use WasmEdge Go SDK v{{ wasmedge_go_version }}, then your WasmEdge version must be {{ wasmedge_go_version }} as well.

<!-- prettier-ignore -->
:::note
The releases of WasmEdge language SDKs follow the official version of WasmEdge. We don't release the alpha, beta, and RC versions for WasmEdge language SDKs. For the WasmEdge release process, please check [here](../../contribute/release.md).
:::

## Install WasmEdge GO SDK as an example

Let's take WasmEdge Go SDK as an example to show how to embed a WASM App in Rust to a Go Host application.

First, ensure you have installed [Go](https://go.dev/dl/) first. The Golang version should be above 1.16.

Next, let's install WasmEdge and WasmEdge Go SDK. Again, The WasmEdge and WasmEdge Go SDK should be the same version.

```bash
$ go version
go version go1.16.5 linux/amd64

# Install WasmEdge
$ curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_go_version }}

# Install WasmEdge-Go
$ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}
```

Now we have set up WasmEdge and WasmEdge Go SDK. Next, let's see how to create a WASM app using Rust and wasmedge-bindgen.

To embed WasmEdge into your host app, you must install WasmEdge itself and its corresponding WasmEdge's language bindings.

In this Quick Start guide, we use WasmEdge Go SDK as an example to show how it works. Primarily, we will use [a bindgen function](https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs) in rust to demonstrate how to call a few simple WebAssembly functions from a Go app.

Before we start, ensure you have installed [Go first](https://go.dev/dl/). The Golang version should be above 1.16.

First, let's install WasmEdge and WasmEdge Go SDK. **They should be in the same version**.

```bash
$ go version
go version go1.16.5 linux/amd64

# Install WasmEdge
$ curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_go_version }}

# Install WasmEdge-Go
$ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

# Install the WasmEdge-bindgen tool, which helps us handle complex data passing
$ go get github.com/second-state/wasmedge-bindgen@v0.4.1
```

<!-- prettier-ignore -->
:::note
For more advanced features like AI inference, please refer to [Go SDK For Embedding WASM Function Chapter](/category/go-sdk-for-embedding-wasmedge).
:::

Since the demo app includes [a compiled WASM file](https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs_lib.wasm) from [the Rust function](https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs), so we don't need to install the Rust toolchain to compile the Rust code to wasm.

## Run the demo

Now we have set up the basic environment, let's run the example.

```bash
# Get the source code of this example
$ git clone https://github.com/second-state/WasmEdge-go-examples.git
$ cd WasmEdge-go-examples//wasmedge-bindgen/go_BindgenFuncs/

# build the project
go build

# run the example
./bindgen_funcs rust_bindgen_funcs_lib.wasm
```

The standard output of this example will be the following:

```bash
Run bindgen -- create_line: {""points"":[{""x"":2.5,""y"":7.8},{""x"":2.5,""y"":5.8}],""valid"":true,""length"":2.0,""desc"":""A thin red line""}
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
```

## Achieve higher performance

Use the following command line if you want to get better performance.

```bash
# Use the AoT mode
wasmedgec rust_bindgen_funcs_lib.wasm rust_bindgen_funcs_lib.wasm

# Run the demo
./bindgen_funcs rust_bindgen_funcs_lib.wasm
```

That's it. Let's dive into [more examples with WasmEdge Go SDK](/category/go-sdk-for-embedding-wasmedge).
","**Summary**

The provided code is a Quick Start guide for using WasmEdge language SDKs, specifically focusing on the Go SDK. It explains how to install WasmEdge and its corresponding language bindings, including WasmEdge-Go, and demonstrates how to embed WasmEdge into a host application.

**Key Components**

1. **Installation**: The guide provides commands to install WasmEdge and its dependencies, including WasmEdge-Go.
2. **Language Bindings**: It explains the concept of language bindings and how they allow for communication between the host application and the WasmEdge runtime.
3. **Demo Application**: The guide includes a demo application written in Go that uses WasmEdge-Go to interact with a compiled WASM file generated from Rust code.
4. **Performance Optimization**: It provides tips on achieving better performance by using the AoT mode.

**Potential Issues or Areas for Improvement**

1. **Complexity**: The code and explanations might be overwhelming for beginners, making it difficult for them to follow along.
2. **Outdated Information**: Some of the commands and versions mentioned in the guide might be outdated, requiring updates to ensure compatibility with newer versions of WasmEdge and its dependencies.
3. **Missing Context**: The guide assumes a basic understanding of WebAssembly, WASM file compilation, and Go programming; readers without this background might find it challenging to understand the concepts presented.

**Suggestions for Improvement**

1. **Simplify the Explanation**: Break down complex concepts into smaller, more digestible pieces, providing clear explanations and examples.
2. **Update Code and Commands**: Ensure that all commands and versions are up-to-date with the latest releases of WasmEdge and its dependencies.
3. **Add Contextual Information**: Provide additional background information on WebAssembly, WASM file compilation, and Go programming to help readers new to these topics understand the code and concepts presented."
docs/contribute/release.md,"---
sidebar_position: 9
---

# Release Process

## Create the releasing process issue of the new version

- [ ] Keep adding new features, issues, and documents, and builds a checklist into the issue.
- [ ] Add the GitHub project of the new version.

## Write Changelog

- [ ] Make sure every change is written in the changelog.
- [ ] Make sure the `Changelog.md` has the correct version number and the release date.
- [ ] Copy the changelog of this version to `.CurrentChangelog.md`. (Our release CI will take this file as the release notes.)
- [ ] Record the contributor lists.
- [ ] Create a pull request, make sure the CI is all passed, and merge it.

## Create the Alpha Pre-Release

- [ ] In this step, the main features are completed. No more major features will be merged after the first Alpha pre-release.
- [ ] Make sure that the features in the releasing process issue are completed.
- [ ] Use git tag to create a new release tag `major.minor.patch-alpha.version`. And push this tag to GitHub.
- [ ] Wait for the CI builds and pushes the release binaries and release notes to the GitHub release page.
- [ ] Check the `Pre-release` checkbox and publish the pre-release.
- [ ] This step will automatically close and turn into the Beta or RC phase in about 3 days if there are no critical issues.

## Create the Beta Pre-Release

- [ ] This step is for the issue fixing if needed. No more features will be accepted.
- [ ] Make sure all the features in the releasing process issue are completed.
- [ ] Use git tag to create a new release tag `major.minor.patch-beta.version`. And push this tag to GitHub.
- [ ] Wait for the CI builds and pushes the release binaries and release notes to the GitHub release page.
- [ ] Check the `Pre-release` checkbox and publish the pre-release.
- [ ] This step will automatically close and turn into the RC phase in about 3 days if there are no critical issues.

## Create the RC Pre-Release

- [ ] In this step, the issue fixing is finished. The `RC` pre-releases are for installation, bindings, and package testing.
- [ ] Make sure that all the issues in the release process issue are completed.
- [ ] Update `WASMEDGE_CAPI_VERSION` in `CMakeLists.txt`.
- [ ] Update `wasmedge_version` in `docs/.env`.
- [ ] Use git tag to create a new release tag `major.minor.patch-rc.version`. And push this tag to GitHub.
- [ ] Wait for the CI builds and pushes the release binaries and release notes to the GitHub release page.
- [ ] Check the `Pre-release` checkbox and publish the pre-release.
- [ ] This step will automatically close and announce the official release in about three days if there are no critical issues.

## Create the Official Release

- [ ] Make sure the `Changelog.md` and `.CurrentChangelog.md` have the correct version number and the release date.
- [ ] Use git tag to create a new release tag `major.minor.patch`. And push this tag to GitHub.
- [ ] Wait for the CI builds and push the release binaries and release notes to the GitHub release page.
- [ ] Publish the release.
- [ ] Close the releasing process issue and the GitHub project.

## Update the Extensions

Following projects will be updated with the `Alpha`, `Beta`, and `RC` pre-releases and the official release:

- [ ] [WasmEdge-Go SDK](https://github.com/second-state/WasmEdge-go)
- [ ] [WasmEdge-core NAPI package](https://github.com/second-state/wasmedge-core)
- [ ] [WasmEdge-extensions NAPI package](https://github.com/second-state/wasmedge-extensions)
","**Summary**

The provided code is a documentation for the release process of the WasmEdge project. It outlines the steps to be taken when creating a new version, from creating the releasing process issue to updating the extensions.

**Key Components**

1. **Create the releasing process issue**: A checklist-style document that tracks progress and issues related to the new version.
2. **Write Changelog**: Document all changes made in the new version, including contributor lists and release dates.
3. **Create Pre-Releases (Alpha, Beta, RC)**: Use git tags to create pre-release versions, push them to GitHub, and wait for CI builds to generate binaries and release notes.
4. **Publish Official Release**: Create a final release tag, update relevant files, publish the release, and close the releasing process issue.

**Potential Issues or Areas for Improvement**

1. **Overly complex process**: The current process involves multiple steps and pre-releases, which may lead to confusion or errors.
2. **Lack of automation**: Some tasks, such as updating extensions, could be automated using CI/CD pipelines.
3. **No clear distinction between pre-releases and official release**: The process does not clearly outline the differences between pre-releases and the official release, potentially leading to confusion among developers.

**Recommendations**

1. **Simplify the process**: Streamline the steps involved in creating a new version to reduce complexity and errors.
2. **Automate tasks**: Utilize CI/CD pipelines to automate repetitive tasks, such as updating extensions.
3. **Clarify pre-release vs official release**: Provide clear guidance on the differences between pre-releases and the official release to avoid confusion among developers.

By addressing these areas for improvement, the WasmEdge project can improve its release process efficiency, reduce errors, and enhance overall developer experience."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/release.md,"---
sidebar_position: 9
---

# Release Process

## Create the releasing process issue of the new version

- [ ] Keep adding new features, issues, and documents, and builds a checklist into the issue.
- [ ] Add the GitHub project of the new version.

## Write Changelog

- [ ] Make sure every change is written in the changelog.
- [ ] Make sure the `Changelog.md` has the correct version number and the release date.
- [ ] Copy the changelog of this version to `.CurrentChangelog.md`. (Our release CI will take this file as the release notes.)
- [ ] Record the contributor lists.
- [ ] Create a pull request, make sure the CI is all passed, and merge it.

## Create the Alpha Pre-Release

- [ ] In this step, the main features are completed. No more major features will be merged after the first Alpha pre-release.
- [ ] Make sure that the features in the releasing process issue are completed.
- [ ] Use git tag to create a new release tag `major.minor.patch-alpha.version`. And push this tag to GitHub.
- [ ] Wait for the CI builds and pushes the release binaries and release notes to the GitHub release page.
- [ ] Check the `Pre-release` checkbox and publish the pre-release.
- [ ] This step will automatically close and turn into the Beta or RC phase in about 3 days if there are no critical issues.

## Create the Beta Pre-Release

- [ ] This step is for the issue fixing if needed. No more features will be accepted.
- [ ] Make sure all the features in the releasing process issue are completed.
- [ ] Use git tag to create a new release tag `major.minor.patch-beta.version`. And push this tag to GitHub.
- [ ] Wait for the CI builds and pushes the release binaries and release notes to the GitHub release page.
- [ ] Check the `Pre-release` checkbox and publish the pre-release.
- [ ] This step will automatically close and turn into the RC phase in about 3 days if there are no critical issues.

## Create the RC Pre-Release

- [ ] In this step, the issue fixing is finished. The `RC` pre-releases are for installation, bindings, and package testing.
- [ ] Make sure that all the issues in the release process issue are completed.
- [ ] Update `WASMEDGE_CAPI_VERSION` in `CMakeLists.txt`.
- [ ] Update `wasmedge_version` in `docs/.env`.
- [ ] Use git tag to create a new release tag `major.minor.patch-rc.version`. And push this tag to GitHub.
- [ ] Wait for the CI builds and pushes the release binaries and release notes to the GitHub release page.
- [ ] Check the `Pre-release` checkbox and publish the pre-release.
- [ ] This step will automatically close and announce the official release in about three days if there are no critical issues.

## Create the Official Release

- [ ] Make sure the `Changelog.md` and `.CurrentChangelog.md` have the correct version number and the release date.
- [ ] Use git tag to create a new release tag `major.minor.patch`. And push this tag to GitHub.
- [ ] Wait for the CI builds and push the release binaries and release notes to the GitHub release page.
- [ ] Publish the release.
- [ ] Close the releasing process issue and the GitHub project.

## Update the Extensions

Following projects will be updated with the `Alpha`, `Beta`, and `RC` pre-releases and the official release:

- [ ] [WasmEdge-Go SDK](https://github.com/second-state/WasmEdge-go)
- [ ] [WasmEdge-core NAPI package](https://github.com/second-state/wasmedge-core)
- [ ] [WasmEdge-extensions NAPI package](https://github.com/second-state/wasmedge-extensions)
","**Summary**

This is a release process document for the WasmEdge project, which outlines the steps to create and manage releases of the project. The document covers creating the releasing process issue, writing changelog entries, creating pre-releases (Alpha, Beta, RC), and finally publishing an official release.

**Key Components**

1. **Release Process Issue**: A checklist is created in a GitHub issue for tracking new features, issues, and documents.
2. **Changelog Entries**: All changes are written in the `Changelog.md` file, including version number and release date. A copy of the changelog is also kept in `.CurrentChangelog.md`.
3. **Pre-Release Tags**: Git tags are created for Alpha, Beta, and RC pre-releases using the format `major.minor.patch-alpha.version`, `major.minor.patch-beta.version`, and `major.minor.patch-rc.version` respectively.
4. **Publishing Pre-Releases**: CI builds and pushes release binaries and release notes to GitHub releases page, where the pre-release is published with a checkbox marked as ""Pre-release"".
5. **Official Release Tag**: A final Git tag is created using the format `major.minor.patch`.
6. **Extensions Update**: The WasmEdge-Go SDK, WasmEdge-core NAPI package, and WasmEdge-extensions NAPI package are updated to use the new release.

**Potential Issues or Areas for Improvement**

1. **Overly complex process**: The document outlines multiple steps and considerations for creating releases, which may lead to errors or misunderstandings.
2. **Inconsistent naming conventions**: Different parts of the process use different naming conventions (e.g., ""Alpha Pre-Release"" vs. ""major.minor.patch-alpha.version"").
3. **Lack of automation**: While CI is mentioned, there is no clear indication that the entire release process can be automated, which may introduce errors or delays.
4. **Insufficient testing**: The document does not explicitly mention thorough testing before releasing pre-releases or the final release.

To address these potential issues, it's recommended to simplify and standardize the release process, consider implementing automation tools, and conduct thorough testing before each step of the release process."
docs/embed/c/intro.md,"---
sidebar_position: 1
---

# WasmEdge C SDK Introduction

The WasmEdge C API denotes an interface to embed the WasmEdge runtime into a C program. The following is the quick start guide for working with the C APIs of WasmEdge. For the details of the WasmEdge C API, please refer to the [complete documentation](reference/latest.md). Before programming with the WasmEdge C API, please [install WasmEdge](../../start/install.md#install) first.

The WasmEdge C API is also the fundamental API for other languages' SDK.

<!-- prettier-ignore -->
:::note
For all WASM example codes used in this chapter, users can convert `wat` to `wasm` through [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) live tool.
:::

## Quick Start Guide for the WasmEdge Runner

The following is an example of running a WASM file. Assume that the WASM file [fibonacci.wasm](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test_wasmedge.c` is as follows:
Please Note: In the example directory, `fibonacci.wat` file is provided and users should convert it into corresponding wasm file using [WABT tool](https://github.com/WebAssembly/wabt)

```c
#include <wasmedge/wasmedge.h>
#include <stdio.h>
int main(int Argc, const char* Argv[]) {
  /* Create the configure context and add the WASI support. */
  /* This step is not necessary unless you need WASI support. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  /* The configure and store context to the VM creation can be NULL. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(32) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, Argv[1], FuncName, Params, 1, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(""Get result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
```

Then you can compile and run: (the 32th fibonacci number is 3524578 in 0-based index)

```bash
$ gcc test_wasmedge.c -lwasmedge -o test_wasmedge
$ ./test_wasmedge fibonacci.wasm
Get result: 3524578
```

## Quick Start Guide for the WasmEdge AOT compiler

Assume that the WASM file [fibonacci.wasm](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test_wasmedge_compiler.c` is as follows:
Please Note: In the example directory, `fibonacci.wat` file is provided and users should convert it into corresponding wasm file using [WABT tool](https://github.com/WebAssembly/wabt)

```c
#include <wasmedge/wasmedge.h>
#include <stdio.h>
int main(int Argc, const char* Argv[]) {
  /* Create the configure context. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /* ... Adjust settings in the configure context. */
  /* Result. */
  WasmEdge_Result Res;

  /* Create the compiler context. The configure context can be NULL. */
  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);
  /* Compile the WASM file with input and output paths. */
  Res = WasmEdge_CompilerCompile(CompilerCxt, Argv[1], Argv[2]);
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Compilation failed: %s\n"", WasmEdge_ResultGetMessage(Res));
    return 1;
  }

  WasmEdge_CompilerDelete(CompilerCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  return 0;
}
```

Then you can compile and run (the output file is `fibonacci_aot.wasm`):

```bash
$ gcc test_wasmedge_compiler.c -lwasmedge -o test_wasmedge_compiler
$ ./test_wasmedge_compiler fibonacci.wasm fibonacci_aot.wasm
[2021-07-02 11:08:08.651] [info] compile start
[2021-07-02 11:08:08.653] [info] verify start
[2021-07-02 11:08:08.653] [info] optimize start
[2021-07-02 11:08:08.670] [info] codegen start
[2021-07-02 11:08:08.706] [info] compile done
```

The compiled WASM file can be used as a WASM input for the WasmEdge runner. The following is the comparison of the interpreter mode and the AOT mode:

```bash
$ time ./test_wasmedge fibonacci.wasm
Get result: 5702887

real 0m2.715s
user 0m2.700s
sys 0m0.008s

$ time ./test_wasmedge fibonacci_aot.wasm
Get result: 5702887

real 0m0.036s
user 0m0.022s
sys 0m0.011s
```

## API References

- [0.13.4](reference/latest.md)
- [0.12.1](reference/0.12.x.md)
- [0.11.2](reference/0.11.x.md)
- [0.10.1](reference/0.10.x.md)
- [0.9.1](reference/0.9.x.md)

## Examples

- Link with the [WasmEdge library](library.md)
- Use the [external reference](externref.md) of WebAssembly input and output in C/C++
- Implement the [host functions](host_function.md) in C/C++
- [Multiple WASM Module Example](multiple_modules.md)
","**Summary:**

This documentation provides a quick start guide for using the WasmEdge C API, an interface to embed the WasmEdge runtime into a C program. It includes examples of running WASM files and compiling them with the AOT compiler.

**Key Components:**

*   `WasmEdge_ConfigureContext`: creates a configure context for setting up the VM
*   `WasmEdge_VMCreate`: creates a VM instance from the configure context
*   `WasmEdge_Value`: represents a WebAssembly value, such as an integer or string
*   `WasmEdge_Result`: represents the result of a WasmEdge operation, including error messages

**Example Code:**

The code example demonstrates how to run a WASM file using the WasmEdge runner and compile it with the AOT compiler. It showcases the use of the `WasmEdge_VMRunWasmFromFile` function to execute the WASM code and retrieve the result.

**API References:**

The documentation provides links to reference materials for different versions of the WasmEdge C API, including version 0.13.4, 0.12.1, and others.

**Best Practices:**

To write high-quality code using the WasmEdge C API:

*   Always initialize the configure context before creating a VM instance
*   Use the `WasmEdge_Value` type to represent WebAssembly values in your C program
*   Handle errors correctly by checking the result of WasmEdge operations and displaying error messages as needed

**Potential Issues:**

When using the WasmEdge C API, be aware of the following potential issues:

*   Make sure to deallocate resources properly after use to prevent memory leaks
*   Be cautious when working with external references, as they can lead to security vulnerabilities if not handled correctly
*   Ensure that your code is compatible with different versions of the WasmEdge C API

Overall, this documentation provides a solid foundation for using the WasmEdge C API and helps developers write high-quality code that effectively integrates WebAssembly into their applications."
i18n/zh/docusaurus-plugin-content-docs/current/embed/c/intro.md,"---
sidebar_position: 1
---

# WasmEdge C SDK Introduction

The WasmEdge C API denotes an interface to embed the WasmEdge runtime into a C program. The following is the quick start guide for working with the C APIs of WasmEdge. For the details of the WasmEdge C API, please refer to the [complete documentation](reference/latest.md). Before programming with the WasmEdge C API, please [install WasmEdge](../../start/install.md#install) first.

The WasmEdge C API is also the fundamental API for other languages' SDK.

<!-- prettier-ignore -->
:::note
For all WASM example codes used in this chapter, users can convert `wat` to `wasm` through [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) live tool.
:::

## Quick Start Guide for the WasmEdge Runner

The following is an example of running a WASM file. Assume that the WASM file [fibonacci.wasm](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test_wasmedge.c` is as follows:
Please Note: In the example directory, `fibonacci.wat` file is provided and users should convert it into corresponding wasm file using [WABT tool](https://github.com/WebAssembly/wabt)

```c
#include <wasmedge/wasmedge.h>
#include <stdio.h>
int main(int Argc, const char* Argv[]) {
  /* Create the configure context and add the WASI support. */
  /* This step is not necessary unless you need WASI support. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  /* The configure and store context to the VM creation can be NULL. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(32) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, Argv[1], FuncName, Params, 1, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(""Get result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
```

Then you can compile and run: (the 32th fibonacci number is 3524578 in 0-based index)

```bash
$ gcc test_wasmedge.c -lwasmedge -o test_wasmedge
$ ./test_wasmedge fibonacci.wasm
Get result: 3524578
```

## Quick Start Guide for the WasmEdge AOT compiler

Assume that the WASM file [fibonacci.wasm](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test_wasmedge_compiler.c` is as follows:
Please Note: In the example directory, `fibonacci.wat` file is provided and users should convert it into corresponding wasm file using [WABT tool](https://github.com/WebAssembly/wabt)

```c
#include <wasmedge/wasmedge.h>
#include <stdio.h>
int main(int Argc, const char* Argv[]) {
  /* Create the configure context. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /* ... Adjust settings in the configure context. */
  /* Result. */
  WasmEdge_Result Res;

  /* Create the compiler context. The configure context can be NULL. */
  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);
  /* Compile the WASM file with input and output paths. */
  Res = WasmEdge_CompilerCompile(CompilerCxt, Argv[1], Argv[2]);
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Compilation failed: %s\n"", WasmEdge_ResultGetMessage(Res));
    return 1;
  }

  WasmEdge_CompilerDelete(CompilerCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  return 0;
}
```

Then you can compile and run (the output file is `fibonacci_aot.wasm`):

```bash
$ gcc test_wasmedge_compiler.c -lwasmedge -o test_wasmedge_compiler
$ ./test_wasmedge_compiler fibonacci.wasm fibonacci_aot.wasm
[2021-07-02 11:08:08.651] [info] compile start
[2021-07-02 11:08:08.653] [info] verify start
[2021-07-02 11:08:08.653] [info] optimize start
[2021-07-02 11:08:08.670] [info] codegen start
[2021-07-02 11:08:08.706] [info] compile done
```

The compiled WASM file can be used as a WASM input for the WasmEdge runner. The following is the comparison of the interpreter mode and the AOT mode:

```bash
$ time ./test_wasmedge fibonacci.wasm
Get result: 5702887

real 0m2.715s
user 0m2.700s
sys 0m0.008s

$ time ./test_wasmedge fibonacci_aot.wasm
Get result: 5702887

real 0m0.036s
user 0m0.022s
sys 0m0.011s
```

## API References

- [0.13.4](reference/latest.md)
- [0.12.1](reference/0.12.x.md)
- [0.11.2](reference/0.11.x.md)
- [0.10.1](reference/0.10.x.md)
- [0.9.1](reference/0.9.x.md)

## Examples

- Link with the [WasmEdge library](library.md)
- Use the [external reference](externref.md) of WebAssembly input and output in C/C++
- Implement the [host functions](host_function.md) in C/C++
- [Multiple WASM Module Example](multiple_modules.md)
","**Summary**

This document provides a quick start guide to using the WasmEdge C SDK, which allows embedding the WasmEdge runtime into a C program. The guide includes examples of running WASM files and compiling them ahead-of-time (AOT) using the WasmEdge AOT compiler.

**Key Components**

1. **WasmEdge C API**: An interface to embed the WasmEdge runtime into a C program.
2. **Configure Context**: Used to configure settings for the WasmEdge runtime.
3. **VMContext**: Represents the virtual machine (VM) context, which is used to execute WASM code.
4. **Compiler Context**: Used to compile WASM code ahead-of-time (AOT).
5. **WASM File**: The input file containing WebAssembly bytecode.

**Examples**

1. **Running a WASM file with WasmEdge runner**:
	* Create a configure context and add WASI support (optional).
	* Create a VM context from the configure context.
	* Run the WASM function from file using `WasmEdge_VMRunWasmFromFile`.
2. **Compiling a WASM file ahead-of-time (AOT)**:
	* Create a configure context.
	* Create a compiler context from the configure context.
	* Compile the WASM file using `WasmEdge_CompilerCompile`.

**API References**

The document provides links to API references for different versions of WasmEdge.

**Notes**

1. The examples are provided in C, but the WasmEdge C SDK can be used with other programming languages as well.
2. The compiled WASM file generated by the AOT compiler can be used as input for the WasmEdge runner.
3. The document provides a comparison between running a WASM file with the interpreter mode and compiling it ahead-of-time (AOT)."
CONTRIBUTING.md,"# Contributing Overview for WasmEdge Docs

You are always welcome to contribute and Thank you for your help in improving WasmEdge :)

This project values community collaboration and welcomes contributions from all interested parties. If you are new to the project, please review the newcomers welcome guide to learn more about how and where to contribute. Additionally, all contributors are expected to follow the Code of Conduct.

If you are ready to contribute, please search for open issues labeled ""help-wanted"" and choose one to work on. Feel free to join our Slack channel to participate in discussions or create a new issue if you have a suggestion or request. When submitting a pull request, please reference the corresponding open issue if one exists. To automatically close related issues in GitHub, include keywords in your pull request descriptions and commit messages.

- [Contribution Flow](#contribution-flow)
  - [Developer Certificate of Origin](#signing-off-on-commits-developer-certificate-of-origin)
- WasmEdge Contribution Flow
  - [WasmEdge Docs](#wasmedge-docs)
  - [WasmEdge Runtime](https://wasmedge.org/docs/contribute/)
  - [Reporting a vulnerability](https://github.com/WasmEdge/WasmEdge/blob/master/SECURITY.md)

## Contribution Flow

To contribute to WasmEdge Docs

### Signing-off on Commits (Developer Certificate of Origin)

To contribute to this project, you must agree to the Developer Certificate of Origin (DCO) for each commit you make. The DCO is a simple statement that you, as a contributor, have the legal right to make the contribution.

See the [DCO](https://developercertificate.org) file for the full text of what you must agree to and how it works [here](https://github.com/probot/dco#how-it-works). To signify that you agree to the DCO for contributions, you simply add a line to each of your git commit messages:

```text
Signed-off-by: John Doe <john.doe@example.com>
```

In most cases, you can add this signoff to your commit automatically with the `-s` or `--signoff` flag to `git commit`. You must use your real name and a reachable email address (sorry, no pseudonyms or anonymous contributions). An example of signing off on a commit:

```bash
git commit -s -m “my commit message w/signoff”
```

To ensure all your commits are signed, you may choose to add this alias to your global `.gitconfig`:

```text
[alias]
  amend = commit -s --amend
  cm = commit -s -m
  commit = commit -s
```

Or you may configure your IDE, for example, Visual Studio Code to automatically sign-off commits for you:

![VSCode sign-off](https://user-images.githubusercontent.com/7570704/64490167-98906400-d25a-11e9-8b8a-5f465b854d49.png)

### WasmEdge Docs

If you want to contribute to the WasmEdge Docs, you can follow these steps:

1. **Fork the project:** Click the ""Fork"" button on the top-right corner of the repository page to create a copy of the project in your GitHub account.

2. **Clone the forked project:** Open a terminal or command prompt and type the following command:

   ```bash
   git clone <forked-repository-url>
   ```

3. **Create a new branch:** Navigate to the project directory and create a new branch to make your changes in:

   ```bash
   git checkout -b my-new-branch
   ```

4. **Make your changes:** Make any changes or additions to the documentation in the project directory.

5. **Commit your changes:** Once you are satisfied with your changes, commit them with a descriptive commit message

   ```bash
   git add .
   ```

   ```bash
   git commit -m "" Message  Signed-off-by: Name <email@example.com> ""
                               OR
                   git commit -s -m "" Message ""
   ```

6. **Push your changes:** Push your changes to your forked repository:

   ```bash
   git push origin my-new-branch
   ```

7. **Create a pull request:** Go to the our repository page, <https://github.com/WasmEdge/docs> and click the ""New pull request"" button. Select your forked repository and the branch you created. Add a description of your changes and click ""Create pull request"".

That's it! Your changes will now be reviewed by the maintainers of the WasmEdge Docs project.
","**Summary**

The provided code is a contribution guide for the WasmEdge project, specifically for its documentation (WasmEdge Docs). The guide explains how to contribute to the project, including how to fork the repository, create a new branch, make changes, commit and push those changes, and finally, create a pull request. 

**Key Components**

1. **Contribution Flow**: A step-by-step guide on how to contribute to WasmEdge Docs.
2. **Developer Certificate of Origin (DCO)**: A statement that contributors must agree to for each commit they make.
3. **Signing-off on Commits**: Contributors are required to add a signoff line (`Signed-off-by`) to their commit messages, which includes their real name and email address.
4. **Forking the Project**: Step-by-step instructions on how to create a fork of the WasmEdge Docs repository in GitHub.
5. **Creating a New Branch**: How to create a new branch to make changes in.
6. **Making Changes**: Instructions on how to make changes to the documentation.
7. **Committing and Pushing Changes**: How to commit and push changes to the forked repository.
8. **Creating a Pull Request**: A step-by-step guide on how to create a pull request to merge the changes into the main project.

**Potential Issues or Areas for Improvement**

1. **Assumes GitHub Familiarity**: The guide assumes that contributors are familiar with GitHub and its terminology (e.g., ""Fork,"" ""Branch,"" ""Pull Request"").
2. **Lack of Visual Aids**: Although there is an image showing how to sign-off on a commit using Visual Studio Code, the rest of the guide relies solely on text.
3. **Could be More Concise**: Some sections are repetitive or could be summarized for easier reading.
4. **No Error Handling**: If contributors encounter issues while following these steps (e.g., merge conflicts), they may not know how to resolve them without additional guidance.

By addressing these areas, the contribution guide can become even more user-friendly and helpful for potential contributors."
docs/contribute/source/os/android/apk.md,"---
sidebar_position: 4
---

# Call WasmEdge functions from an Android APK app

In this section, we will show you how to build a ""regular"" Android app (i.e., an APK file that can be installed on an Android device). The APK app embeds a WasmEdge Runtime. It can call WebAssembly functions through the embedded WasmEdge. The benefit is that developers can safely embed high-performance functions written in several different languages (e.g., Rust, JS, Grain, TinyGo etc) into a Kotlin application.

## Quickstart

The demo project is [available here](https://github.com/WasmEdge/WasmEdge/tree/master/utils/android/app). You can build the project using the Gradle tool or using the Android Studio IDE.

### Building Project with Gradle

1. Setup environment variable `ANDROID_HOME=path/to/your/android/sdk`
2. Run Command `./gradlew assembleRelease`
3. Sign your APK file with `apksigner`. The apk file is at `./app/build/outputs/apk/release`. The `apksigner` utility is at `$ANDROID_HOME/build-tools/$VERSION/apksigner`.

### Building Project with Android Studio

Open this folder with [Android Studio](https://developer.android.com/studio) 2020.3.1 or later.

For Release APK, click `Menu -> Build -> Generate Signed Bundle/APK`, select APK, setup keystore configuration and wait for build finished.

## Review of the source code

The Android UI app is written in Kotlin, and it uses JNI (Java Native Interface) to load a C shared library, which in turn embeds WasmEdge.

### Android UI

The Android UI application is [located here](https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/app/src/main/java/org/wasmedge/example_app/MainActivity.kt). It is written in Kotlin using the Android SDK.

```java
class MainActivity : AppCompatActivity() {
  lateinit var lib: NativeLib

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    val tv = findViewById<TextView>(R.id.tv_text)

    lib = NativeLib(this)

    Thread {
      val lines = Vector<String>()
      val idxArr = arrayOf(20, 25, 28, 30, 32)
      for (idx: Int in idxArr) {
        lines.add(""running fib(${idx}) ..."")
        runOnUiThread {
          tv.text = lines.joinToString(""\n"")
        }
        val begin = System.currentTimeMillis()
        val retVal = lib.wasmFibonacci(idx)
        val end = System.currentTimeMillis()
        lines.removeLast()
        lines.add(""fib(${idx}) -> ${retVal}, ${end - begin}ms"")
        runOnUiThread {
          tv.text = lines.joinToString(""\n"")
        }
      }
    }.start()
  }
}
```

### The native library

The Android UI app calls a `NativeLib` Kotlin object to access WasmEdge functions. The `NativeLib` source code is [available here](https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/lib/src/main/java/org/wasmedge/native_lib/NativeLib.kt). It uses JNI (Java Native Interface) to load a C shared library called `wasmedge_lib`. It then calls the `nativeWasmFibonacci` function in `wasmedge_lib` to execute the `fibonacci.wasm` WebAssembly bytecode.

```java
class NativeLib(ctx : Context) {
  private external fun nativeWasmFibonacci(imageBytes : ByteArray, idx : Int ) : Int

  companion object {
    init {
      System.loadLibrary(""wasmedge_lib"")
    }
  }

  private var fibonacciWasmImageBytes : ByteArray = ctx.assets.open(""fibonacci.wasm"").readBytes()

  fun wasmFibonacci(idx : Int) : Int{
    return nativeWasmFibonacci(fibonacciWasmImageBytes, idx)
  }
}
```

### The C shared library

The C shared library source code `wasmedge_lib.cpp` is [available here](https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/lib/src/main/cpp/wasmedge_lib.cpp). It uses the WasmEdge C SDK to embed a WasmEdge VM and execute the WebAssembly function.

```c
extern ""C"" JNIEXPORT jint JNICALL
Java_org_wasmedge_native_1lib_NativeLib_nativeWasmFibonacci(
    JNIEnv *env, jobject, jbyteArray image_bytes, jint idx) {
  jsize buffer_size = env->GetArrayLength(image_bytes);
  jbyte *buffer = env->GetByteArrayElements(image_bytes, nullptr);

  WasmEdge_ConfigureContext *conf = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(conf, WasmEdge_HostRegistration_Wasi);

  WasmEdge_VMContext *vm_ctx = WasmEdge_VMCreate(conf, nullptr);

  const WasmEdge_String &func_name = WasmEdge_StringCreateByCString(""fib"");
  std::array<WasmEdge_Value, 1> params{WasmEdge_ValueGenI32(idx)};
  std::array<WasmEdge_Value, 1> ret_val{};

  const WasmEdge_Result &res = WasmEdge_VMRunWasmFromBuffer(
      vm_ctx, (uint8_t *)buffer, buffer_size, func_name, params.data(),
      params.size(), ret_val.data(), ret_val.size());

  WasmEdge_VMDelete(vm_ctx);
  WasmEdge_ConfigureDelete(conf);
  WasmEdge_StringDelete(func_name);

  env->ReleaseByteArrayElements(image_bytes, buffer, 0);
  if (!WasmEdge_ResultOK(res)) {
    return -1;
  }
  return WasmEdge_ValueGetI32(ret_val[0]);
}
```

### The WebAssembly function

The `factorial.wat` is a [handwritten WebAssembly script](https://github.com/WasmEdge/WasmEdge/blob/master/examples/wasm/fibonacci.wat) to compute factorial numbers. It is compiled into WebAssembly using the [WABT tool](https://github.com/WebAssembly/wabt).

### Build dependencies

Android Studio and Gradle use CMake to build the C shared library. The [CMakeLists.txt file](https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/lib/src/main/cpp/CMakeLists.txt) builds the WasmEdge source into Android shared library files and embeds them into the final APK application. In this case, there is no separate step to install WasmEdge share libraries onto the Android device.
","**Summary:**

The provided code demonstrates how to build an Android APK app that embeds a WasmEdge Runtime. The app uses Java Native Interface (JNI) to load a C shared library, which in turn embeds WasmEdge and executes WebAssembly functions. The code is divided into three main parts:

1. **Android UI**: Written in Kotlin, this part creates an Android application that calls the `NativeLib` object to access WasmEdge functions.
2. **Native Library**: Also written in Kotlin, this part uses JNI to load a C shared library called `wasmedge_lib`, which embeds WasmEdge and executes WebAssembly functions.
3. **C Shared Library**: Written in C++, this part uses the WasmEdge C SDK to embed a WasmEdge VM and execute WebAssembly functions.

**Key Components:**

* **WasmEdge Runtime**: Embedded within the Android app, providing the necessary infrastructure for executing WebAssembly functions.
* **JNI**: Used to load the C shared library from Java code.
* **C Shared Library (wasmedge_lib)**: Implements WasmEdge functionality in C++ and uses JNI to interact with Java code.

**Potential Issues/Areas for Improvement:**

1. **Complexity**: The use of multiple languages (Kotlin, Java, C++) and frameworks (Android SDK, JNI) may introduce complexity and make it challenging to maintain.
2. **Performance**: Embedding a WasmEdge Runtime within an Android app may impact performance due to the added layer of abstraction and potential overhead of WebAssembly execution.
3. **Error Handling**: The code does not explicitly handle errors or exceptions that may occur during WebAssembly function execution or JNI interactions.

**Future Improvements:**

1. **Simplify the architecture**: Consider using a single language for all components or exploring more efficient ways to embed WasmEdge within the Android app.
2. **Optimize performance**: Investigate techniques to improve performance, such as using caching, optimizing WebAssembly code, or leveraging platform-specific optimizations.
3. **Enhance error handling**: Implement robust error handling mechanisms to ensure that errors and exceptions are properly handled and reported."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/apk.md,"---
sidebar_position: 4
---

# Call WasmEdge functions from an Android APK app

In this section, we will show you how to build a ""regular"" Android app (i.e., an APK file that can be installed on an Android device). The APK app embeds a WasmEdge Runtime. It can call WebAssembly functions through the embedded WasmEdge. The benefit is that developers can safely embed high-performance functions written in several different languages (e.g., Rust, JS, Grain, TinyGo etc) into a Kotlin application.

## Quickstart

The demo project is [available here](https://github.com/WasmEdge/WasmEdge/tree/master/utils/android/app). You can build the project using the Gradle tool or using the Android Studio IDE.

### Building Project with Gradle

1. Setup environment variable `ANDROID_HOME=path/to/your/android/sdk`
2. Run Command `./gradlew assembleRelease`
3. Sign your APK file with `apksigner`. The apk file is at `./app/build/outputs/apk/release`. The `apksigner` utility is at `$ANDROID_HOME/build-tools/$VERSION/apksigner`.

### Building Project with Android Studio

Open this folder with [Android Studio](https://developer.android.com/studio) 2020.3.1 or later.

For Release APK, click `Menu -> Build -> Generate Signed Bundle/APK`, select APK, setup keystore configuration and wait for build finished.

## Review of the source code

The Android UI app is written in Kotlin, and it uses JNI (Java Native Interface) to load a C shared library, which in turn embeds WasmEdge.

### Android UI

The Android UI application is [located here](https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/app/src/main/java/org/wasmedge/example_app/MainActivity.kt). It is written in Kotlin using the Android SDK.

```java
class MainActivity : AppCompatActivity() {
  lateinit var lib: NativeLib

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    val tv = findViewById<TextView>(R.id.tv_text)

    lib = NativeLib(this)

    Thread {
      val lines = Vector<String>()
      val idxArr = arrayOf(20, 25, 28, 30, 32)
      for (idx: Int in idxArr) {
        lines.add(""running fib(${idx}) ..."")
        runOnUiThread {
          tv.text = lines.joinToString(""\n"")
        }
        val begin = System.currentTimeMillis()
        val retVal = lib.wasmFibonacci(idx)
        val end = System.currentTimeMillis()
        lines.removeLast()
        lines.add(""fib(${idx}) -> ${retVal}, ${end - begin}ms"")
        runOnUiThread {
          tv.text = lines.joinToString(""\n"")
        }
      }
    }.start()
  }
}
```

### The native library

The Android UI app calls a `NativeLib` Kotlin object to access WasmEdge functions. The `NativeLib` source code is [available here](https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/lib/src/main/java/org/wasmedge/native_lib/NativeLib.kt). It uses JNI (Java Native Interface) to load a C shared library called `wasmedge_lib`. It then calls the `nativeWasmFibonacci` function in `wasmedge_lib` to execute the `fibonacci.wasm` WebAssembly bytecode.

```java
class NativeLib(ctx : Context) {
  private external fun nativeWasmFibonacci(imageBytes : ByteArray, idx : Int ) : Int

  companion object {
    init {
      System.loadLibrary(""wasmedge_lib"")
    }
  }

  private var fibonacciWasmImageBytes : ByteArray = ctx.assets.open(""fibonacci.wasm"").readBytes()

  fun wasmFibonacci(idx : Int) : Int{
    return nativeWasmFibonacci(fibonacciWasmImageBytes, idx)
  }
}
```

### The C shared library

The C shared library source code `wasmedge_lib.cpp` is [available here](https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/lib/src/main/cpp/wasmedge_lib.cpp). It uses the WasmEdge C SDK to embed a WasmEdge VM and execute the WebAssembly function.

```c
extern ""C"" JNIEXPORT jint JNICALL
Java_org_wasmedge_native_1lib_NativeLib_nativeWasmFibonacci(
    JNIEnv *env, jobject, jbyteArray image_bytes, jint idx) {
  jsize buffer_size = env->GetArrayLength(image_bytes);
  jbyte *buffer = env->GetByteArrayElements(image_bytes, nullptr);

  WasmEdge_ConfigureContext *conf = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(conf, WasmEdge_HostRegistration_Wasi);

  WasmEdge_VMContext *vm_ctx = WasmEdge_VMCreate(conf, nullptr);

  const WasmEdge_String &func_name = WasmEdge_StringCreateByCString(""fib"");
  std::array<WasmEdge_Value, 1> params{WasmEdge_ValueGenI32(idx)};
  std::array<WasmEdge_Value, 1> ret_val{};

  const WasmEdge_Result &res = WasmEdge_VMRunWasmFromBuffer(
      vm_ctx, (uint8_t *)buffer, buffer_size, func_name, params.data(),
      params.size(), ret_val.data(), ret_val.size());

  WasmEdge_VMDelete(vm_ctx);
  WasmEdge_ConfigureDelete(conf);
  WasmEdge_StringDelete(func_name);

  env->ReleaseByteArrayElements(image_bytes, buffer, 0);
  if (!WasmEdge_ResultOK(res)) {
    return -1;
  }
  return WasmEdge_ValueGetI32(ret_val[0]);
}
```

### The WebAssembly function

The `factorial.wat` is a [handwritten WebAssembly script](https://github.com/WasmEdge/WasmEdge/blob/master/examples/wasm/fibonacci.wat) to compute factorial numbers. It is compiled into WebAssembly using the [WABT tool](https://github.com/WebAssembly/wabt).

### Build dependencies

Android Studio and Gradle use CMake to build the C shared library. The [CMakeLists.txt file](https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/lib/src/main/cpp/CMakeLists.txt) builds the WasmEdge source into Android shared library files and embeds them into the final APK application. In this case, there is no separate step to install WasmEdge share libraries onto the Android device.
","**Summary**

This document provides a guide on how to build an Android app (APK file) that embeds the WasmEdge Runtime, allowing it to call WebAssembly functions. The demo project is available on GitHub.

**Key Components**

1. **Android UI App**: Written in Kotlin using the Android SDK.
2. **JNI (Java Native Interface)**: Used to load a C shared library, which in turn embeds WasmEdge.
3. **Native Library**: A Kotlin object that uses JNI to access WasmEdge functions.
4. **C Shared Library**: Written in C++ and uses the WasmEdge C SDK to embed a WasmEdge VM.
5. **WebAssembly Function**: Handwritten WebAssembly script (fibonacci.wat) compiled into WebAssembly bytecode.

**Build Process**

1. Set up environment variables for Android Studio and Gradle.
2. Run Command `./gradlew assembleRelease` or use Android Studio 2020.3.1 or later to build the project.
3. Sign the APK file using `apksigner`.

**Potential Issues**

1. **JNI and C++ Compatibility**: Ensure that the JNI interface is compatible with the C++ code in the shared library.
2. **WasmEdge Versioning**: Verify that the WasmEdge version used in the shared library matches the one used in the Android app.
3. **Native Library Loading**: Double-check that the native library is loaded correctly and can access WasmEdge functions.

**Areas for Improvement**

1. **Error Handling**: Improve error handling in the C shared library to handle potential errors when running WebAssembly code.
2. **Code Optimization**: Optimize the C shared library to reduce overhead and improve performance.
3. **Documentation**: Document the build process, dependencies, and any specific requirements or configurations needed for the project."
docs/develop/rust/wasicrypto.md,"---
sidebar_position: 9
---

# Crypto for WASI

While optimizing compilers could allow efficient implementation of cryptographic features in WebAssembly, there are several occasions where a host implementation is more desirable. [WASI-crypto](https://github.com/WebAssembly/wasi-crypto/blob/main/docs/HighLevelGoals.md) aims to fill those gaps by defining a standard interface as a set of APIs. Currently not support Android.

Make sure [you have Rust and WasmEdge installed](setup.md) and [the WASI-crypto plugin](../../start/install.md#wasi-crypto-plug-in) installed.

## Write WebAssembly Using WASI-Crypto

### _(Optional)_ Rust Installation

For importing WASI-Crypto in rust, you should use the [wasi-crypto binding](https://github.com/WebAssembly/wasi-crypto/tree/main/implementations/bindings/rust) in your cargo.toml

```toml
[dependencies]
wasi-crypto = ""0.1.5""
```

### High-Level Operations

#### Hash Function

| Identifier    | Algorithm                                    |
| ------------- | -------------------------------------------- |
| `SHA-256`     | SHA-256 hash function                        |
| `SHA-512`     | SHA-512 hash function                        |
| `SHA-512/256` | SHA-512/256 hash function with a specific IV |

```rust
// hash ""test"" by SHA-256
let hash : Vec<u8> = Hash::hash(""SHA-256"", b""test"", 32, None)?;
assert_eq!(hash.len(), 32);
```

#### Message Authentications function

| Identifier     | Algorithm                                   |
| -------------- | ------------------------------------------- |
| `HMAC/SHA-256` | RFC2104 MAC using the SHA-256 hash function |
| `HMAC/SHA-512` | RFC2104 MAC using the SHA-512 hash function |

```rust
// generate key
let key = AuthKey::generate(""HMAC/SHA-512"")?;
// generate tag
let tag = Auth::auth(""test"", &key)?;
// verify
Auth::auth_verify(""test"", &key, tag)?;
```

#### Key Driven function

| Identifier | Algorithm |
| --- | --- |
| `HKDF-EXTRACT/SHA-256` | RFC5869 `EXTRACT` function using the SHA-256 hash function |
| `HKDF-EXTRACT/SHA-512` | RFC5869 `EXTRACT` function using the SHA-512 hash function |
| `HKDF-EXPAND/SHA-256` | RFC5869 `EXPAND` function using the SHA-256 hash function |
| `HKDF-EXPAND/SHA-512` | RFC5869 `EXPAND` function using the SHA-512 hash function |

Example:

```rust
let key = HkdfKey::generate(""HKDF-EXTRACT/SHA-512"")?;
let prk = Hkdf::new(""HKDF-EXPAND/SHA-512"", &key, Some(b""salt""))?;
let derived_key = prk.expand(""info"", 100)?;
assert_eq!(derived_key.len(), 100);
```

#### Signatures Operation

| Identifier | Algorithm |
| --- | --- |
| `ECDSA_P256_SHA256` | ECDSA over the NIST p256 curve with the SHA-256 hash function |
| `ECDSA_K256_SHA256` | ECDSA over the secp256k1 curve with the SHA-256 hash function |
| `Ed25519` | Edwards Curve signatures over Edwards25519 (pure EdDSA) as specified in RFC8032 |
| `RSA_PKCS1_2048_SHA256` | RSA signatures with a 2048 bit modulus, PKCS1 padding and the SHA-256 hash function |
| `RSA_PKCS1_2048_SHA384` | RSA signatures with a 2048 bit modulus, PKCS1 padding and the SHA-384 hash function |
| `RSA_PKCS1_2048_SHA512` | RSA signatures with a 2048 bit modulus, PKCS1 padding and the SHA-512 hash function |
| `RSA_PKCS1_3072_SHA384` | RSA signatures with a 3072 bit modulus, PKCS1 padding and the SHA-384 hash function |
| `RSA_PKCS1_3072_SHA512` | RSA signatures with a 3072 bit modulus, PKCS1 padding and the SHA-512 hash function |
| `RSA_PKCS1_4096_SHA512` | RSA signatures with a 4096 bit modulus, PKCS1 padding and the SHA-512 hash function |
| `RSA_PSS_2048_SHA256` | RSA signatures with a 2048 bit modulus, PSS padding and the SHA-256 hash function |
| `RSA_PSS_2048_SHA384` | RSA signatures with a 2048 bit modulus, PSS padding and the SHA-384 hash function |
| `RSA_PSS_2048_SHA512` | RSA signatures with a 2048 bit modulus, PSS padding and the SHA-512 hash function |
| `RSA_PSS_3072_SHA384` | RSA signatures with a 2048 bit modulus, PSS padding and the SHA-384 hash function |
| `RSA_PSS_3072_SHA512` | RSA signatures with a 3072 bit modulus, PSS padding and the SHA-512 hash function |
| `RSA_PSS_4096_SHA512` | RSA signatures with a 4096 bit modulus, PSS padding and the SHA-512 hash function |

Example:

```rust
let pk = SignaturePublicKey::from_raw(""Ed25519"", &[0; 32])?;

let kp = SignatureKeyPair::generate(""Ed25519"")?;
let signature = kp.sign(""hello"")?;

kp.publickey()?.signature_verify(""hello"", &signature)?;
```
","**Summary:**

This code snippet is a reference implementation of the WASI-crypto interface for Rust, which provides a set of APIs for cryptographic operations. The code includes examples for various high-level operations such as hash functions (SHA-256, SHA-512), message authentications (HMAC/SHA-256, HMAC/SHA-512), key derivation functions (HKDF-EXTRACT/SHA-256, HKDF-EXPAND/SHA-256), and digital signatures (ECDSA, Ed25519, RSA).

**Key Components:**

1. **Hash Functions**: Implementations for SHA-256, SHA-512, and SHA-512/256 hash functions.
2. **Message Authentications**: Implementations for HMAC/SHA-256 and HMAC/SHA-512 message authentications.
3. **Key Driven Functions**: Implementations for HKDF-EXTRACT/SHA-256, HKDF-EXPAND/SHA-256, HKDF-EXTRACT/SHA-512, and HKDF-EXPAND/SHA-512 key derivation functions.
4. **Signatures Operations**: Implementations for ECDSA (P-256 and K-256 curves), Ed25519, RSA (PKCS1 and PSS padding schemes), and various modulus sizes.

**Example Use Cases:**

* Hashing a string with SHA-256:
```rust
let hash = Hash::hash(""SHA-256"", b""test"", 32, None)?;
assert_eq!(hash.len(), 32);
```
* Generating an HMAC signature with HMAC/SHA-512:
```rust
let key = AuthKey::generate(""HMAC/SHA-512"")?;
let tag = Auth::auth(""test"", &key)?;
Auth::auth_verify(""test"", &key, tag)?;
```
* Deriving a key using HKDF-EXTRACT/SHA-256:
```rust
let key = HkdfKey::generate(""HKDF-EXTRACT/SHA-512"")?;
let prk = Hkdf::new(""HKDF-EXPAND/SHA-512"", &key, Some(b""salt""))?;
let derived_key = prk.expand(""info"", 100)?;
assert_eq!(derived_key.len(), 100);
```
* Signing a message with Ed25519:
```rust
let pk = SignaturePublicKey::from_raw(""Ed25519"", &[0; 32])?;

let kp = SignatureKeyPair::generate(""Ed25519"")?;
let signature = kp.sign(""hello"")?;

kp.publickey()?.signature_verify(""hello"", &signature)?;
```
**Potential Issues and Areas for Improvement:**

* The code does not handle errors properly. It is recommended to use the `Result` type and provide meaningful error messages.
* Some functions have duplicate implementations for different hash algorithms (e.g., SHA-256 and SHA-512). Consider using a more generic approach to reduce duplication.
* The code lacks documentation, making it harder for others to understand its purpose and usage. Add comments and docstrings to explain the reasoning behind each function and example use case."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasicrypto.md,"---
sidebar_position: 9
---

# Crypto for WASI

While optimizing compilers could allow efficient implementation of cryptographic features in WebAssembly, there are several occasions where a host implementation is more desirable. [WASI-crypto](https://github.com/WebAssembly/wasi-crypto/blob/main/docs/HighLevelGoals.md) aims to fill those gaps by defining a standard interface as a set of APIs. Currently not support Android.

Make sure [you have Rust and WasmEdge installed](setup.md) and [the WASI-crypto plugin](../../start/install.md#wasi-crypto-plug-in) installed.

## Write WebAssembly Using WASI-Crypto

### _(Optional)_ Rust Installation

For importing WASI-Crypto in rust, you should use the [wasi-crypto binding](https://github.com/WebAssembly/wasi-crypto/tree/main/implementations/bindings/rust) in your cargo.toml

```toml
[dependencies]
wasi-crypto = ""0.1.5""
```

### High-Level Operations

#### Hash Function

| Identifier    | Algorithm                                    |
| ------------- | -------------------------------------------- |
| `SHA-256`     | SHA-256 hash function                        |
| `SHA-512`     | SHA-512 hash function                        |
| `SHA-512/256` | SHA-512/256 hash function with a specific IV |

```rust
// hash ""test"" by SHA-256
let hash : Vec<u8> = Hash::hash(""SHA-256"", b""test"", 32, None)?;
assert_eq!(hash.len(), 32);
```

#### Message Authentications function

| Identifier     | Algorithm                                   |
| -------------- | ------------------------------------------- |
| `HMAC/SHA-256` | RFC2104 MAC using the SHA-256 hash function |
| `HMAC/SHA-512` | RFC2104 MAC using the SHA-512 hash function |

```rust
// generate key
let key = AuthKey::generate(""HMAC/SHA-512"")?;
// generate tag
let tag = Auth::auth(""test"", &key)?;
// verify
Auth::auth_verify(""test"", &key, tag)?;
```

#### Key Driven function

| Identifier | Algorithm |
| --- | --- |
| `HKDF-EXTRACT/SHA-256` | RFC5869 `EXTRACT` function using the SHA-256 hash function |
| `HKDF-EXTRACT/SHA-512` | RFC5869 `EXTRACT` function using the SHA-512 hash function |
| `HKDF-EXPAND/SHA-256` | RFC5869 `EXPAND` function using the SHA-256 hash function |
| `HKDF-EXPAND/SHA-512` | RFC5869 `EXPAND` function using the SHA-512 hash function |

Example:

```rust
let key = HkdfKey::generate(""HKDF-EXTRACT/SHA-512"")?;
let prk = Hkdf::new(""HKDF-EXPAND/SHA-512"", &key, Some(b""salt""))?;
let derived_key = prk.expand(""info"", 100)?;
assert_eq!(derived_key.len(), 100);
```

#### Signatures Operation

| Identifier | Algorithm |
| --- | --- |
| `ECDSA_P256_SHA256` | ECDSA over the NIST p256 curve with the SHA-256 hash function |
| `ECDSA_K256_SHA256` | ECDSA over the secp256k1 curve with the SHA-256 hash function |
| `Ed25519` | Edwards Curve signatures over Edwards25519 (pure EdDSA) as specified in RFC8032 |
| `RSA_PKCS1_2048_SHA256` | RSA signatures with a 2048 bit modulus, PKCS1 padding and the SHA-256 hash function |
| `RSA_PKCS1_2048_SHA384` | RSA signatures with a 2048 bit modulus, PKCS1 padding and the SHA-384 hash function |
| `RSA_PKCS1_2048_SHA512` | RSA signatures with a 2048 bit modulus, PKCS1 padding and the SHA-512 hash function |
| `RSA_PKCS1_3072_SHA384` | RSA signatures with a 3072 bit modulus, PKCS1 padding and the SHA-384 hash function |
| `RSA_PKCS1_3072_SHA512` | RSA signatures with a 3072 bit modulus, PKCS1 padding and the SHA-512 hash function |
| `RSA_PKCS1_4096_SHA512` | RSA signatures with a 4096 bit modulus, PKCS1 padding and the SHA-512 hash function |
| `RSA_PSS_2048_SHA256` | RSA signatures with a 2048 bit modulus, PSS padding and the SHA-256 hash function |
| `RSA_PSS_2048_SHA384` | RSA signatures with a 2048 bit modulus, PSS padding and the SHA-384 hash function |
| `RSA_PSS_2048_SHA512` | RSA signatures with a 2048 bit modulus, PSS padding and the SHA-512 hash function |
| `RSA_PSS_3072_SHA384` | RSA signatures with a 2048 bit modulus, PSS padding and the SHA-384 hash function |
| `RSA_PSS_3072_SHA512` | RSA signatures with a 3072 bit modulus, PSS padding and the SHA-512 hash function |
| `RSA_PSS_4096_SHA512` | RSA signatures with a 4096 bit modulus, PSS padding and the SHA-512 hash function |

Example:

```rust
let pk = SignaturePublicKey::from_raw(""Ed25519"", &[0; 32])?;

let kp = SignatureKeyPair::generate(""Ed25519"")?;
let signature = kp.sign(""hello"")?;

kp.publickey()?.signature_verify(""hello"", &signature)?;
```
","**Code Analysis**

This code is a part of the Docusaurus documentation for using WASI-crypto in Rust. It provides an introduction to crypto operations on WebAssembly (WASM) and demonstrates how to perform various cryptographic tasks.

**Key Components:**

1. **Hash Function**: The code shows examples of hashing strings using SHA-256, SHA-512, and SHA-512/256 hash functions.
2. **Message Authentications Function**: HMAC/SHA-256 and HMAC/SHA-512 algorithms are demonstrated for generating tags and verifying authenticity.
3. **Key Driven Functions**: HKDF-EXTRACT/SHA-256, HKDF-EXTRACT/SHA-512, HKDF-EXPAND/SHA-256, and HKDF-EXPAND/SHA-512 functions are showcased for key derivation.
4. **Signatures Operation**: Various signature algorithms, including ECDSA_P256_SHA256, ECDSA_K256_SHA256, Ed25519, RSA_PKCS1_2048_SHA256, etc., are demonstrated.

**Rust Code**

The code is written in Rust and uses the `wasi-crypto` crate for cryptographic operations. The examples provided demonstrate how to perform these operations using WASM.

**Areas for Improvement:**

1. **Error Handling**: While some error handling is present, more robust error handling would make the code more robust.
2. **Documentation**: Additional comments and documentation could improve understanding of the code and its purpose.
3. **Testing**: Including tests to verify the correctness of cryptographic operations would enhance confidence in the implementation.

**Summary:**

This code provides an introduction to crypto operations on WASM using Rust and demonstrates various cryptographic tasks. While it has some areas for improvement, it serves as a useful resource for developers looking to implement crypto operations on WebAssembly."
i18n/zh/docusaurus-plugin-content-docs/current/start/usage/serverless/vercel.md,"---
sidebar_position: 5
---

# 运行在 Vercel 上的 Rust 和 WebAssembly 无服务器函数

在本文中，我们将展示在 Vercel 上部署的两个使用 Rust 和 WasmEdge 编写的无服务器函数。一个是图像处理函数，另一个是 TensorFlow 推理函数。

> 欲了解更多关于为何在 Vercel 上使用 WasmEdge，请参阅文章 [Rust and WebAssembly Serverless Functions in Vercel](https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/)。

## 环境

由于我们的演示 WebAssembly 函数是用 Rust 编写的，你将需要 [Rust 编译器](https://www.rust-lang.org/tools/install)。确保你按照以下方式安装 `wasm32-wasi` 编译目标，以生成 WebAssembly 字节码。

```bash
rustup target add wasm32-wasi
```

演示应用的前端是用 [Next.js](https://nextjs.org/) 编写的，并部署在 Vercel 上。我们假设你对如何使用 Vercel 已经有基本的了解。

## 示例1：图像处理

我们的第一个演示应用允许用户上传图像，然后调用一个无服务器函数将其转换为黑白图像。在 Vercel 上部署的[实时演示](https://vercel-wasm-runtime.vercel.app/)可以直接使用。

首先 Fork [演示应用的 GitHub 存储库](https://github.com/second-state/vercel-wasm-runtime)。要在 Vercel 上部署应用程序，只需从 [Vercel for Github](https://vercel.com/docs/git/vercel-for-github) 网页中[导入 Github 存储库](https://vercel.com/docs/git#deploying-a-git-repository)。

该存储库是一个标准的适用于 Vercel 平台的 Next.js 应用程序。后端无服务器函数位于 [`api/functions/image_grayscale`](https://github.com/second-state/vercel-wasm-runtime/tree/main/api/functions/image-grayscale) 文件夹中。[`src/main.rs`](https://github.com/second-state/vercel-wasm-runtime/blob/main/api/functions/image-grayscale/src/main.rs) 文件包含了 Rust 程序的源代码。Rust 程序从 `STDIN` 读取图像数据，然后将黑白图像输出到 `STDOUT`。

```rust
use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&buf).unwrap();
  let img = image::load_from_memory(&buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif => {
      filtered.write_to(&mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ => {
      filtered.write_to(&mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&buf).unwrap();
  io::stdout().flush().unwrap();
}
```


你可以使用 Rust 的 `cargo` 工具将 Rust 程序构建成 WebAssembly 字节码或本机代码。

```bash
cd api/functions/image-grayscale/
cargo build --release --target wasm32-wasi
```

将构建产物复制到 `api` 文件夹。

```bash
cp target/wasm32-wasi/release/grayscale.wasm ../../
```

> 在构建 Docker 镜像时，将执行 `api/pre.sh`。`pre.sh` 安装 WasmEdge 运行时，然后将每个 WebAssembly 字节码程序编译成本地 `so` 库，以实现更快的执行。

### 创建服务脚本以加载函数

[`api/hello.js`](https://github.com/second-state/vercel-wasm-runtime/blob/main/api/hello.js) 脚本加载 WasmEdge 运行时，在 WasmEdge 中启动编译后的 WebAssembly 程序，并通过 `STDIN` 传递上传的图像数据。请注意，为了实现更好的性能，[`api/hello.js`](https://github.com/second-state/vercel-wasm-runtime/blob/main/api/hello.js) 运行的是由 [`api/pre.sh`](https://github.com/second-state/vercel-wasm-runtime/blob/main/api/pre.sh) 生成的编译后的 `grayscale.so` 文件。

```javascript
const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) => {
  const wasmedge = spawn(path.join(__dirname, 'wasmedge'), [
    path.join(__dirname, 'grayscale.so'),
  ]);

  let d = [];
  wasmedge.stdout.on('data', (data) => {
    d.push(data);
  });

  wasmedge.on('close', (code) => {
    let buf = Buffer.concat(d);

    res.setHeader('Content-Type', req.headers['image-type']);
    res.send(buf);
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
};
```

准备就绪。现在[将存储库部署到 Vercel](https://vercel.com/docs/git#deploying-a-git-repository)上，你就拥有了一个使用高性能 Rust 和 WebAssembly 构建的无服务器后端的 Vercel Jamstack 应用程序。

## 示例 2：AI 推理

[第二个演示](https://vercel-wasm-runtime.vercel.app/) 应用允许用户上传图像，然后调用一个无服务器函数对图像的主要对象进行分类。

这个示例位于[与之前示例相同的 GitHub 存储库](https://github.com/second-state/vercel-wasm-runtime)，但在 `tensorflow` 分支中。注意：当你[在 Vercel 网站上导入此 GitHub 存储库](https://vercel.com/docs/git#deploying-a-git-repository)时，它会为每个分支创建一个[预览 URL](https://vercel.com/docs/platform/deployments#preview)。`tensorflow` 分支将有其自己的部署URL。

用于图像分类的后端无服务器函数位于 `tensorflow` 分支中的 [`api/functions/image-classification`](https://github.com/second-state/vercel-wasm-runtime/tree/tensorflow/api/functions/image-classification) 文件夹中。[`src/main.rs`](https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/functions/image-classification/src/main.rs) 文件包含了 Rust 程序的源代码。Rust 程序从 `STDIN` 读取图像数据，然后将文本输出到 `STDOUT`。它利用了 WasmEdge Tensorflow API 来进行AI 推理。

```rust
pub fn main() {
  // Step 1: Load the TFLite model
  let model_data: &[u8] = include_bytes!(""models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite"");
  let labels = include_str!(""models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt"");

  // Step 2: Read image from STDIN
  let mut buf = Vec::new();
  io::stdin().read_to_end(&mut buf).unwrap();

  // Step 3: Resize the input image for the tensorflow model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&buf, 224, 224);

  // Step 4: AI inference
  let mut session = wasmedge_tensorflow_interface::Session::new(&model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(""input"", &flat_img, &[1, 224, 224, 3])
         .run();
  let res_vec: Vec<u8> = session.get_output(""MobilenetV1/Predictions/Reshape_1"");

  // Step 5: Find the food label that responds to the highest probability in res_vec
  // ... ...
  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }

  // Step 6: Generate the output text
  let class_name = label_lines.next().unwrap().to_string();
  if max_value > 50 {
    println!(""It {} a <a href='https://www.google.com/search?q={}'>{}</a> in the picture"", confidence.to_string(), class_name, class_name);
  } else {
    println!(""It does not appears to be any food item in the picture."");
  }
}
```

你可以使用 `cargo` 工具将 Rust 程序构建成 WebAssembly 字节码或本机代码。

```bash
cd api/functions/image-classification/
cargo build --release --target wasm32-wasi
```

将构建产物复制到 `api` 文件夹。

```bash
cp target/wasm32-wasi/release/classify.wasm ../../
```

同样，`api/pre.sh` 脚本在此应用程序中安装了 WasmEdge 运行时及其 TensorFlow 依赖项。它还在部署时将 `classify.wasm` 字节码程序编译为 `classify.so` 本机共享库。

[`api/hello.js`](https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/hello.js) 文件符合 Vercel 无服务器规范。它加载 WasmEdge 运行时，在 WasmEdge 中启动已编译的 WebAssembly 程序，并通过 `STDIN` 传递上传的图像数据。请注意，[`api/hello.js`](https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/hello.js) 运行由 [`api/pre.sh`](https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/pre.sh) 生成的已编译 `classify.so` 文件，以获得更佳的性能。

```javascript
const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) => {
  const wasmedge = spawn(
    path.join(__dirname, 'wasmedge-tensorflow-lite'),
    [path.join(__dirname, 'classify.so')],
    { env: { LD_LIBRARY_PATH: __dirname } },
  );

  let d = [];
  wasmedge.stdout.on('data', (data) => {
    d.push(data);
  });

  wasmedge.on('close', (code) => {
    res.setHeader('Content-Type', `text/plain`);
    res.send(d.join(''));
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
};
```

现在，你可以[将你 Fork 的存储库部署到 Vercel](https://vercel.com/docs/git#deploying-a-git-repository)，获得一个用于主题分类的 Web 应用。

接下来，轮到你使用 [vercel-wasm-runtime 存储库](https://github.com/second-state/vercel-wasm-runtime) 作为模板，在 Vercel 中开发你自己的 Rust 无服务器函数了。期待着你出色的工作。
","该代码是关于如何在 Vercel 平台上部署使用 Rust 和 WebAssembly 构建的无服务器函数。它包含两个示例：

1.  图像处理：一个使用 Rust 和 WasmEdge 的 WebAssembly 函数，可以将图像转换为黑白图像。
2.  AI 推理：另一个使用 TensorFlow Lite 和 WasmEdge 的 WebAssembly 函数，用于对图像的主要对象进行分类。

每个示例都包括一个前端 Web 应用，使用 Next.js 构建，并部署在 Vercel 上。这些示例展示了如何使用 Rust、WebAssembly 和 WasmEdge 来创建高性能的无服务器函数，并如何与 Vercel 平台进行集成。

以下是代码和功能的关键方面：

*   Rust 代码：每个示例都包括一个 Rust 程序，该程序使用 WasmEdge 运行时来执行 WebAssembly 函数。
*   WebAssembly 函数：图像处理函数使用 `image_grayscale` 函数将图像转换为黑白图像，AI 推理函数使用 TensorFlow Lite 来对图像的主要对象进行分类。
*   Vercel 部署：每个示例都包括一个部署脚本，以便将它们部署到 Vercel 平台上。
*   WasmEdge 运行时：每个示例都包含 WasmEdge 运行时的依赖项，以及用于在 Rust 中使用 WasmEdge 的 API。

总体而言，这些代码和功能展示了如何使用 Rust、WebAssembly 和 WasmEdge 来创建高性能的无服务器函数，并与 Vercel 平台进行集成。"
docs/develop/rust/database/qdrant_driver.md,"---
sidebar_position: 4
---

# Qdrant driver

WasmEdge is emerging as a lightweight, portable, and embeddable runtime for large language models (LLMs). LLM inference applications, such as RAG chatbots and AI agents, can be developed on Mac or Windows, compiled to Wasm once, and then deployed across Nvidia / AMD / ARM-powered devices or servers, fully taking advantage of on-device GPUs, NPUs, and accelerators.

Hence, besides the LLM inference runtime, those LLM applications also need to manage embeddings in vector databases. The [qdrant-rest-client](https://crates.io/crates/qdrant_rest_client) crate allows you to access the Qdrant vector database from your portable Wasm apps!

<!-- prettier-ignore -->
:::note
Before we start, [you need to have Rust and WasmEdge installed](../setup.md).
Make sure that you read the [special notes on networking apps](../setup#special-notes-for-networking-apps) especially if you are compiling Rust programs on a Mac.
:::

## Run the example

The [wasmedge-db-example/qdrant](https://github.com/WasmEdge/wasmedge-db-examples/tree/main/qdrant) is a Qdrant client example written in Rust.

```bash
git clone https://github.com/WasmEdge/wasmedge-db-examples
cd wasmedge-db-examples/qdrant

# Compile the rust code into WASM
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release

# Perform vector data operations against a Qdrant at http://localhost:6333
wasmedge target/wasm32-wasi/release/qdrant_examples.wasm
```

## Configuration

In order to compile the `qdrant_rest_client` and `tokio` crates, we will need to apply patches to add WasmEdge-specific socket APIs to those crates in `Cargo.toml`.

```rust
[patch.crates-io]
socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }
reqwest = { git = ""https://github.com/second-state/wasi_reqwest.git"", branch = ""0.11.x"" }
hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }

[dependencies]
anyhow = ""1.0""
serde_json = ""1.0""
serde = { version = ""1.0"", features = [""derive""] }
url = ""2.3""
tokio = { version = ""1"", features = [""io-util"", ""fs"", ""net"", ""time"", ""rt"", ""macros""] }
qdrant_rest_client = ""0.1.0""
```

## Code explanation

The following program uses the `qdrant_rest_client` crate to access local Qdrant server through its RESTful API.
It first creates several points (vectors), saves those vectors to the Qdrant database, retrieves some vectors, 
searches for vectors, and finally deletes them from the database.

```rust
#[tokio::main(flavor = ""current_thread"")]
async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    let client = qdrant::Qdrant::new();
    // Create a collection with 10-dimensional vectors
    let r = client.create_collection(""my_test"", 4).await;
    println!(""Create collection result is {:?}"", r);

    let mut points = Vec::<Point>::new();
    points.push(Point {
        id: PointId::Num(1),
        vector: vec![0.05, 0.61, 0.76, 0.74],
        payload: json!({""city"": ""Berlin""}).as_object().map(|m| m.to_owned()),
    });
    points.push(Point {
        id: PointId::Num(2),
        vector: vec![0.19, 0.81, 0.75, 0.11],
        payload: json!({""city"": ""London""}).as_object().map(|m| m.to_owned()),
    });
    points.push(Point {
        id: PointId::Num(3),
        vector: vec![0.36, 0.55, 0.47, 0.94],
        payload: json!({""city"": ""Moscow""}).as_object().map(|m| m.to_owned()),
    });
    points.push(Point {
        id: PointId::Num(4),
        vector: vec![0.18, 0.01, 0.85, 0.80],
        payload: json!({""city"": ""New York""})
            .as_object()
            .map(|m| m.to_owned()),
    });
    points.push(Point {
        id: PointId::Num(5),
        vector: vec![0.24, 0.18, 0.22, 0.44],
        payload: json!({""city"": ""Beijing""}).as_object().map(|m| m.to_owned()),
    });
    points.push(Point {
        id: PointId::Num(6),
        vector: vec![0.35, 0.08, 0.11, 0.44],
        payload: json!({""city"": ""Mumbai""}).as_object().map(|m| m.to_owned()),
    });

    let r = client.upsert_points(""my_test"", points).await;
    println!(""Upsert points result is {:?}"", r);

    println!(
        ""The collection size is {}"",
        client.collection_info(""my_test"").await
    );

    let p = client.get_point(""my_test"", 2).await;
    println!(""The second point is {:?}"", p);

    let ps = client.get_points(""my_test"", vec![1, 2, 3, 4, 5, 6]).await;
    println!(""The 1-6 points are {:?}"", ps);

    let q = vec![0.2, 0.1, 0.9, 0.7];
    let r = client.search_points(""my_test"", q, 2, None).await;
    println!(""Search result points are {:?}"", r);

    let r = client.delete_points(""my_test"", vec![1, 4]).await;
    println!(""Delete points result is {:?}"", r);

    println!(
        ""The collection size is {}"",
        client.collection_info(""my_test"").await
    );

    let q = vec![0.2, 0.1, 0.9, 0.7];
    let r = client.search_points(""my_test"", q, 2, None).await;
    println!(""Search result points are {:?}"", r);
    Ok(())
}
```

","**Qdrant Driver Summary**

The Qdrant driver is a Rust library that allows accessing the Qdrant vector database from portable Wasm applications. It uses the `qdrant_rest_client` crate to interact with the Qdrant server through its RESTful API.

**Key Components:**

1. **Qdrant Client**: The client instance (`client`) is created using `qdrant::Qdrant::new()`.
2. **Collection Management**: The driver allows creating, deleting, and updating collections.
3. **Point Operations**: It supports inserting, upserting, retrieving, searching, and deleting points (vectors) in a collection.
4. **Search Queries**: The driver enables searching points using a query vector.

**Code Explanation:**

The example code demonstrates the usage of the Qdrant driver by performing various operations:

1. Creating a collection with 10-dimensional vectors.
2. Inserting points into the collection using `upsert_points()`.
3. Retrieving and printing individual points using `get_point()` and `get_points()`.
4. Searching for points using `search_points()`.
5. Deleting points from the collection using `delete_points()`.

**Configuration:**

To compile the code, a custom `Cargo.toml` configuration is required to apply patches to the `qdrant_rest_client`, `tokio`, and other dependencies to support WasmEdge-specific socket APIs.

**Notes:**

* The example uses the `wasi_reqwest` crate for HTTP requests.
* The driver assumes the Qdrant server is running on `http://localhost:6333`.
* The code uses `async/await` syntax with Tokio as the runtime."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/qdrant_driver.md,"---
sidebar_position: 4
---

# Qdrant driver

WasmEdge is emerging as a lightweight, portable, and embeddable runtime for large language models (LLMs). LLM inference applications, such as RAG chatbots and AI agents, can be developed on Mac or Windows, compiled to Wasm once, and then deployed across Nvidia / AMD / ARM-powered devices or servers, fully taking advantage of on-device GPUs, NPUs, and accelerators.

Hence, besides the LLM inference runtime, those LLM applications also need to manage embeddings in vector databases. The [qdrant-rest-client](https://crates.io/crates/qdrant_rest_client) crate allows you to access the Qdrant vector database from your portable Wasm apps!

<!-- prettier-ignore -->
:::note
Before we start, [you need to have Rust and WasmEdge installed](../setup.md).
Make sure that you read the [special notes on networking apps](../setup#special-notes) especially if you are compiling Rust programs on a Mac.
:::

## Run the example

The [wasmedge-db-example/qdrant](https://github.com/WasmEdge/wasmedge-db-examples/tree/main/qdrant) is a Qdrant client example written in Rust.

```bash
git clone https://github.com/WasmEdge/wasmedge-db-examples
cd wasmedge-db-examples/qdrant

# Compile the rust code into WASM
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release

# Perform vector data operations against a Qdrant at http://localhost:6333
wasmedge target/wasm32-wasi/release/qdrant_examples.wasm
```

## Configuration

In order to compile the `qdrant_rest_client` and `tokio` crates, we will need to apply patches to add WasmEdge-specific socket APIs to those crates in `Cargo.toml`.

```rust
[patch.crates-io]
socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }
reqwest = { git = ""https://github.com/second-state/wasi_reqwest.git"", branch = ""0.11.x"" }
hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }

[dependencies]
anyhow = ""1.0""
serde_json = ""1.0""
serde = { version = ""1.0"", features = [""derive""] }
url = ""2.3""
tokio = { version = ""1"", features = [""io-util"", ""fs"", ""net"", ""time"", ""rt"", ""macros""] }
qdrant_rest_client = ""0.1.0""
```

## Code explanation

The following program uses the `qdrant_rest_client` crate to access local Qdrant server through its RESTful API.
It first creates several points (vectors), saves those vectors to the Qdrant database, retrieves some vectors, 
searches for vectors, and finally deletes them from the database.

```rust
#[tokio::main(flavor = ""current_thread"")]
async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    let client = qdrant::Qdrant::new();
    // Create a collection with 10-dimensional vectors
    let r = client.create_collection(""my_test"", 4).await;
    println!(""Create collection result is {:?}"", r);

    let mut points = Vec::<Point>::new();
    points.push(Point {
        id: PointId::Num(1),
        vector: vec![0.05, 0.61, 0.76, 0.74],
        payload: json!({""city"": ""Berlin""}).as_object().map(|m| m.to_owned()),
    });
    points.push(Point {
        id: PointId::Num(2),
        vector: vec![0.19, 0.81, 0.75, 0.11],
        payload: json!({""city"": ""London""}).as_object().map(|m| m.to_owned()),
    });
    points.push(Point {
        id: PointId::Num(3),
        vector: vec![0.36, 0.55, 0.47, 0.94],
        payload: json!({""city"": ""Moscow""}).as_object().map(|m| m.to_owned()),
    });
    points.push(Point {
        id: PointId::Num(4),
        vector: vec![0.18, 0.01, 0.85, 0.80],
        payload: json!({""city"": ""New York""})
            .as_object()
            .map(|m| m.to_owned()),
    });
    points.push(Point {
        id: PointId::Num(5),
        vector: vec![0.24, 0.18, 0.22, 0.44],
        payload: json!({""city"": ""Beijing""}).as_object().map(|m| m.to_owned()),
    });
    points.push(Point {
        id: PointId::Num(6),
        vector: vec![0.35, 0.08, 0.11, 0.44],
        payload: json!({""city"": ""Mumbai""}).as_object().map(|m| m.to_owned()),
    });

    let r = client.upsert_points(""my_test"", points).await;
    println!(""Upsert points result is {:?}"", r);

    println!(
        ""The collection size is {}"",
        client.collection_info(""my_test"").await
    );

    let p = client.get_point(""my_test"", 2).await;
    println!(""The second point is {:?}"", p);

    let ps = client.get_points(""my_test"", vec![1, 2, 3, 4, 5, 6]).await;
    println!(""The 1-6 points are {:?}"", ps);

    let q = vec![0.2, 0.1, 0.9, 0.7];
    let r = client.search_points(""my_test"", q, 2, None).await;
    println!(""Search result points are {:?}"", r);

    let r = client.delete_points(""my_test"", vec![1, 4]).await;
    println!(""Delete points result is {:?}"", r);

    println!(
        ""The collection size is {}"",
        client.collection_info(""my_test"").await
    );

    let q = vec![0.2, 0.1, 0.9, 0.7];
    let r = client.search_points(""my_test"", q, 2, None).await;
    println!(""Search result points are {:?}"", r);
    Ok(())
}
```

","**Summary**

This is a documentation for the Qdrant driver, a Rust library that enables interaction with the Qdrant vector database. The code provides an example of how to use the library to create a collection, insert points (vectors), retrieve points, search for points, and delete points.

**Key Components**

1. **Qdrant Rest Client**: A Rust crate that allows interacting with Qdrant through its RESTful API.
2. **Collection Management**: The code demonstrates how to create a collection with a specified dimensionality.
3. **Point Management**: Points are inserted into the database, retrieved by ID or batch, searched for using a query vector, and deleted.
4. **Querying**: Searching for points in the database based on a query vector.

**Code Explanation**

The provided code is a comprehensive example of how to use the Qdrant driver library. It includes:

1. Creating a collection with 10-dimensional vectors.
2. Inserting points into the collection using the `upsert_points` method.
3. Retrieving individual points and batched points using the `get_point` and `get_points` methods, respectively.
4. Searching for points in the database using the `search_points` method.
5. Deleting points from the collection using the `delete_points` method.

**Potential Issues/Improvement Areas**

1. **Error Handling**: While the code provides some basic error handling, it would be beneficial to add more robust error checking and handling mechanisms.
2. **Performance Optimization**: The code may benefit from optimization techniques such as parallel processing or caching to improve performance.
3. **Documentation**: Additional documentation on how to use the Qdrant driver library could be beneficial for users who are not familiar with Rust or the Qdrant database.
4. **Testing**: Adding more comprehensive testing to ensure the correctness of the code and its interaction with the Qdrant database is crucial.

**Best Practices**

1. The code adheres to the standard naming conventions and coding guidelines of the Rust language.
2. The use of comments and docstrings provides clear explanations of the code's functionality.
3. The organization of the code into logical sections and methods makes it easy to understand and maintain."
docs/start/getting-started/quick_start_redhat.md,"---
sidebar_position: 3
---

# Quick start with Red Hat

In this guide, we will walk you through how to quickly run WasmEdge apps in Fedora / CentOS / Red Hat Linux / OpenShift systems. There is no additional dependencies as the entire development and runtime environments are managed by OpenSift / Podman.

<!-- prettier-ignore -->
:::note
If you are not using OpenShift / Podman, [get started here](quick_start.md).
:::

We will cover the following examples.

- [Run a standalone WASM app](#run-a-standalone-wasm-app)
- [Run an HTTP server](#run-an-http-server)
- [Run a JavaScript server (node.js)](#run-a-javascript-based-server)

## Install

You can use an one-liner `dnf` command to install WasmEdge, [crun](https://github.com/containers/crun) and [Podman](https://www.redhat.com/en/topics/containers/what-is-podman) on your Fedora / CentOS / Red Hat Linux system. The WasmEdge Runtime is available as an [officially maintained upstream package](https://packages.fedoraproject.org/pkgs/wasmedge/wasmedge/index.html) for Fedora 37 and Red Hat REPL 8 and 9.

```bash
dnf install wasmedge crun-wasm podman
```

## Run a standalone WASM app

The Hello world example is a standalone Rust application. Its source code and build instructions are available [here](https://github.com/second-state/rust-examples/tree/main/hello).

Use Podman to run the containerized WASM app. The WASM container image is stored in Docker Hub, and its image size is only 500KB. This image can run on any OS and CPU platform Red Hat supports.

```bash
$ podman --runtime /usr/bin/crun-wasm run --platform=wasi/wasm -t --rm docker.io/secondstate/rust-example-hello:latest
Hello WasmEdge!
```

To learn more about how to create WASM apps in Rust

- [Basic Rust examples for WasmEdge](https://github.com/second-state/rust-examples)
- [Rust developer guides](/category/develop-wasm-apps-in-rust)
  - WASI-NN with [PyTorch](../../develop/rust/wasinn/pytorch.md), [OpenVINO](../../develop/rust/wasinn/openvino.md), or [Tensorflow Lite](../../develop/rust/wasinn/tensorflow_lite.md) backends
  - [HTTP and HTTPS client](../../develop/rust/http_service/client.md)
  - [MySQL database client](../../develop/rust/database/my_sql_driver.md)
  - Redis client
  - Kafka client

## Run an HTTP server

This example is a standalone HTTP server written in Rust. It demonstrates Rust + WasmEdge as a lightweight stack for microservices. Its source code and build instructions are available [here](https://github.com/second-state/rust-examples/tree/main/server).

Use Podman to pull the container image (around 800KB) from Docker Hub and then run it in a WasmEdge container. The container starts as a server. Note how we map the container's port 8080 to the local host's port 8080 so that the server becomes accessible from outside of the WASM container.

```bash
$ podman --runtime /usr/bin/crun-wasm run -dp 8080:8080 --platform=wasi/wasm -t --rm docker.io/secondstate/rust-example-server:latest
Listening on http://0.0.0.0:8080
```

From another terminal window, do the following.

```bash
$ curl http://localhost:8080/
Try POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`

$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

To learn more about how to create WASM services in Rust

- [Rust developer guides](/category/develop-wasm-apps-in-rust)
- [HTTP application examples](https://github.com/WasmEdge/wasmedge_hyper_demo)
- [Database application examples](https://github.com/WasmEdge/wasmedge-db-examples)
- Lightweight microservices in Rust and WasmEdge
  - [WasmEdge + Nginx + MySQL](https://github.com/second-state/microservice-rust-mysql)
  - [WasmEdge + Kafka + MySQL](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql)
  - [Dapr + WasmEdge](https://github.com/second-state/dapr-wasm)

## Run a JavaScript-based server

This example is a standalone HTTP server written in JavaScript using the node.js API. It demonstrates WasmEdge as a lightweight runtime for zero-dependency and portable node.js applications. Its source code is available [here](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/docker_wasm/server).

```bash
$ podman --runtime /usr/bin/crun-wasm run -dp 8080:8080 --platform=wasi/wasm -t --rm docker.io/secondstate/node-example-server:latest
... ...
```

From another terminal window, do the following.

```bash
$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

To learn more about how to run JavaScript apps in WasmEdge.

- [The WasmEdge QuickJS runtime](https://github.com/second-state/wasmedge-quickjs)
- [AI inference application examples](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo)
- [Web service client examples with fetch()](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js)

## Next steps

- [Basic Rust examples for WasmEdge](https://github.com/second-state/rust-examples)
- Write WASM apps in your favorite languages, like [Rust](/category/develop-wasm-apps-in-rust), [C/C++](/category/develop-wasm-apps-in-cc), [JavaScript](/category/develop-wasm-apps-in-javascript), [Go](/category/develop-wasm-apps-in-go), and many other languages.
","**Summary**

The provided code is a documentation of the Quick Start guide for running WasmEdge apps on Red Hat Linux systems. It covers three examples:

1. Running a standalone WASM app using Rust and Podman.
2. Running an HTTP server written in Rust using Podman.
3. Running a JavaScript-based server using Node.js and Podman.

**Key Components**

* **WasmEdge**: A lightweight WebAssembly runtime for Red Hat Linux systems.
* **Podman**: A containerization platform that runs WasmEdge containers.
* **Rust**: A programming language used to create WASM apps.
* **Node.js**: A JavaScript runtime environment used to create server-side applications.

**Functionality**

The code demonstrates how to:

1. Install WasmEdge, Podman, and other dependencies using a one-liner `dnf` command.
2. Run a standalone WASM app using Rust and Podman.
3. Run an HTTP server written in Rust using Podman.
4. Run a JavaScript-based server using Node.js and Podman.

**Potential Issues/Improvements**

* The guide assumes that the reader has basic knowledge of containerization, WebAssembly, and programming languages (Rust, JavaScript).
* Some sections may be confusing or unclear, particularly for readers new to WasmEdge or containerization.
* Additional examples or use cases would be beneficial to further illustrate the capabilities of WasmEdge on Red Hat Linux systems.
* Consider adding more detailed instructions for setting up and configuring Podman, as well as troubleshooting common issues."
docs/start/wasmedge/extensions/proposals.md,"---
sidebar_position: 1
---

# WebAssembly Proposals

## Standard WebAssembly Features

WasmEdge supports the following [WebAssembly proposals](https://github.com/WebAssembly/proposals). These proposals are likely to become official WebAssembly specifications in the future.

| Proposal | WasmEdge CLI flag | WasmEdge C API enumeration | Default turning on | Interpreter mode | AOT mode |
| --- | --- | --- | --- | --- | --- |
| [Import/Export of Mutable Globals][] | `--disable-import-export-mut-globals` | `WasmEdge_Proposal_ImportExportMutGlobals` | ✓ (since `0.8.2`) | ✓ | ✓ |
| [Non-trapping float-to-int conversions][] | `--disable-non-trap-float-to-int` | `WasmEdge_Proposal_NonTrapFloatToIntConversions` | ✓ (since `0.8.2`) | ✓ | ✓ |
| [Sign-extension operators][] | `--disable-sign-extension-operators` | `WasmEdge_Proposal_SignExtensionOperators` | ✓ (since `0.8.2`) | ✓ | ✓ |
| [Multi-value][] | `--disable-multi-value` | `WasmEdge_Proposal_MultiValue` | ✓ (since `0.8.2`) | ✓ | ✓ |
| [Reference Types][] | `--disable-reference-types` | `WasmEdge_Proposal_ReferenceTypes` | ✓ (since `0.8.2`) | ✓ | ✓ |
| [Bulk memory operations][] | `--disable-bulk-memory` | `WasmEdge_Proposal_BulkMemoryOperations` | ✓ (since `0.8.2`) | ✓ | ✓ |
| [Fixed-width SIMD][] | `--disable-simd` | `WasmEdge_Proposal_SIMD` | ✓ (since `0.9.0`) | ✓ (since `0.8.2`) | ✓ (since `0.8.2`) |
| [Tail call][] | `--enable-tail-call` | `WasmEdge_Proposal_TailCall` |  | ✓ (since `0.10.0`) | ✓ (since `0.10.0`) |
| [Extended Constant Expressions][] | `--enable-extended-const` | `WasmEdge_Proposal_ExtendedConst` |  | ✓ (since `0.10.0`) | ✓ (since `0.10.0`) |
| [Typed Function References][] | `--enable-function-reference` | `WasmEdge_Proposal_FunctionReferences` |  | ✓ (since `0.14.0`) | ✓ (since `0.14.0`) |
| [Garbage collection][] | `--enable-gc` | `WasmEdge_Proposal_GC` |  | ✓ (since `0.14.0`) |  |
| [Multiple memories][] | `--enable-multi-memory` | `WasmEdge_Proposal_MultiMemories` |  | ✓ (since `0.9.1`) | ✓ (since `0.9.1`) |
| [Threads][] | `--enable-threads` | `WasmEdge_Proposal_Threads` |  | ✓ (since `0.10.1`) | ✓ (since `0.10.1`) |
| [Exception handling][] | `--enable-exception-handling` | `WasmEdge_Proposal_ExceptionHandling` |  | ✓ (since `0.14.0`) |  |
| [Component Model][] | `--enable-component` | `WasmEdge_Proposal_Component` |  | Loader only (since `0.14.0`) |  |

The following proposals are under development and may be supported in the future:

- [Exception handling][]
- [Relaxed SIMD][]
- [Memory64][]
- [WebAssembly C and C++ API][]

[Import/Export of Mutable Globals]: https://github.com/WebAssembly/mutable-global
[Non-trapping float-to-int conversions]: https://github.com/WebAssembly/nontrapping-float-to-int-conversions
[Sign-extension operators]: https://github.com/WebAssembly/sign-extension-ops
[Multi-value]: https://github.com/WebAssembly/multi-value
[Reference Types]: https://github.com/WebAssembly/reference-types
[Bulk memory operations]: https://github.com/WebAssembly/bulk-memory-operations
[Fixed-width SIMD]: https://github.com/webassembly/simd
[Tail call]: https://github.com/WebAssembly/tail-call
[Multiple memories]: https://github.com/WebAssembly/multi-memory
[Extended Constant Expressions]: https://github.com/WebAssembly/extended-const
[Threads]: https://github.com/webassembly/threads
[Component Model]: https://github.com/WebAssembly/component-model
[Exception handling]: https://github.com/WebAssembly/exception-handling
[Typed Function References]: https://github.com/WebAssembly/function-references
[Garbage collection]: https://github.com/WebAssembly/gc
[Relaxed SIMD]: https://github.com/WebAssembly/relaxed-simd
[Memory64]: https://github.com/WebAssembly/memory64
[WebAssembly C and C++ API]: https://github.com/WebAssembly/wasm-c-api

## WASI proposals

WasmEdge implements the following [WASI proposals](https://github.com/WebAssembly/WASI/blob/main/Proposals.md):

| Proposal | Platform: `Linux x86_64` | Platform: `Linux aarch64` | Platform: `x86_64 MacOS` | Platform: `MacOS arm64` |
| --- | --- | --- | --- | --- |
| [Sockets][] | ✓ (since `0.10.0`) | ✓ (since `0.10.0`) | ✓ (since `0.10.0`) | ✓ (since `0.10.0`) |
| [Crypto][] | ✓ (since `0.10.1`) | ✓ (since `0.10.1`) | ✓ (since `0.13.0`) | ✓ (since `0.13.0`) |
| [Logging][] | ✓ (since `0.13.0`) | ✓ (since `0.13.0`) | ✓ (since `0.13.0`) | ✓ (since `0.13.0`) |
| [Machine Learning (wasi-nn)][] | ✓ OpenVINO (since `0.10.1`)<br/>✓ PyTorch (since `0.11.1`)<br/>✓ TensorFlow-Lite (since `0.11.2`)<br/>✓ Ggml (since `0.13.4`) | ✓ Ggml (since `0.13.4`) | ✓ Ggml (since `0.13.4`) | ✓ Ggml (since `0.13.4`) |
| [proxy-wasm][] | ✓ (since `0.8.2`, interpreter) | | ✓ (since `0.11.2`, interpreter) | |

The following proposals is under development and may be supported in the future:

- TensorFlow backend of WASI-NN

[Sockets]: https://github.com/WebAssembly/wasi-sockets
[Crypto]: https://github.com/WebAssembly/wasi-crypto
[Logging]: https://github.com/WebAssembly/wasi-logging
[Machine Learning (wasi-nn)]: https://github.com/WebAssembly/wasi-nn
[proxy-wasm]: https://github.com/proxy-wasm/spec
","**Summary**

The provided code is a documentation for the WebAssembly (WasmEdge) engine, which supports various WebAssembly proposals and WASI (WebAssembly System Interface) proposals. The documentation lists the supported features, including import/export of mutable globals, non-trapping float-to-int conversions, sign-extension operators, and more. It also specifies the default behavior for each proposal in different modes (interpreter mode, AOT mode). Additionally, it mentions some proposals that are under development but may be supported in the future.

**Key Components**

1. **WebAssembly Proposals**: The engine supports various WebAssembly proposals, which are likely to become official WebAssembly specifications in the future.
2. **WASI Proposals**: The engine also implements various WASI proposals, which provide a system interface for WebAssembly code.
3. **Supported Features**: The documentation lists the supported features for each proposal, including their default behavior in different modes.
4. **Under Development**: Some proposals are under development but may be supported in the future.

**Potential Issues or Areas for Improvement**

1. **Complexity**: The documentation is quite extensive and might be overwhelming for users who are new to WebAssembly or WasmEdge.
2. **Versioning**: The documentation does not explicitly mention version numbers, which could lead to confusion about the compatibility of different proposals across versions.
3. **Error Handling**: There is no clear information on how error handling works for each proposal, which might lead to issues when using the engine in production environments.

**Recommendations**

1. **Simplify Documentation**: Consider breaking down the documentation into smaller sections and providing a clear overview of the supported features and proposals.
2. **Add Version Information**: Include version numbers in the documentation to ensure that users are aware of the compatibility across different versions.
3. **Error Handling Guidelines**: Provide guidelines on error handling for each proposal to help users understand how to handle errors when using the engine."
docs/contribute/source/os/android/ndk.md,"---
sidebar_position: 3
---

# Call WasmEdge functions from an NDK native app

In this section, we will demonstrate how to build an Android native application using C and the Android SDK. The native application uses the WasmEdge C SDK to embed the WasmEdge Runtime, and call WASM functions through WasmEdge.

<!-- prettier-ignore -->
:::note
The `WasmEdge-Image`, `WasmEdge-Tensorflow`, and `WasmEdge-tensorflow-tools` have been deprecated after the 0.12.1 version. We'll update to use the WasmEdge plug-in in the future.
:::

## Prerequisite

### Android

Currently, WasmEdge only supports the arm64-v8a architecture on Android devices. You need an arm64-v8a Android simulator or a physical device with [developer options turned on](https://developer.android.com/studio/debug/dev-options). WasmEdge requires Android 6.0 and above.

### Android development CLI

In Ubuntu Linux, you can use the `apt-get` command to install Android debugging and testing tool `adb`. Using the `adb shell` command on the Ubuntu dev machine, you can open a CLI shell to execute commands on the connected Android device.

```bash
sudo apt-get install adb
```

### Android NDK

To compile programs with the wasmedge-tensorflow c api, you need to install the [Android NDK](https://developer.android.google.cn/ndk/downloads). In this example, we use the latest LTS version (r23b).

## Review of source code

The [`test.c`](https://github.com/second-state/wasm-learning/blob/master/android/test.c) uses the wasmedge-tensorflow c api to run a WebAssembly function. The WebAssembly file `birds_v1.wasm` is compiled from Rust source code and [explained here](/develop/rust/wasinn/tensorflow_lite).

```c
#include <wasmedge/wasmedge.h>
#include <wasmedge/wasmedge-image.h>
#include <wasmedge/wasmedge-tensorflowlite.h>

#include <stdio.h>

int main(int argc, char *argv[]) {
  /*
   * argv[0]: ./a.out
   * argv[1]: WASM file
   * argv[2]: tflite model file
   * argv[3]: image file
   * Usage: ./a.out birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
   */

  /* Create the VM context. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
  WasmEdge_ConfigureDelete(ConfCxt);

  /* Create the image and TFLite import objects. */
  WasmEdge_ModuleInstanceContext *ImageImpObj = WasmEdge_Image_ModuleInstanceCreate();
  WasmEdge_ModuleInstanceContext *TFLiteImpObj = WasmEdge_TensorflowLite_ModuleInstanceCreate();
  WasmEdge_ModuleInstanceContext *TFDummyImpObj = WasmEdge_Tensorflow_ModuleInstanceCreateDummy();

  /* Register into VM. */
  WasmEdge_VMRegisterModuleFromImport(VMCxt, ImageImpObj);
  WasmEdge_VMRegisterModuleFromImport(VMCxt, TFLiteImpObj);
  WasmEdge_VMRegisterModuleFromImport(VMCxt, TFDummyImpObj);

  /* Init WASI. */
  const char *Preopens[] = {"".:.""};
  const char *Args[] = {argv[1], argv[2], argv[3]};
  WasmEdge_ModuleInstanceContext *WASIImpObj = WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
  WasmEdge_ModuleInstanceInitWASI(WASIImpObj, Args, 3, NULL, 0, Preopens, 1);

  /* Run WASM file. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""_start"");
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, argv[1], FuncName, NULL, 0, NULL, 0);
  WasmEdge_StringDelete(FuncName);

  /* Check the result. */
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Run WASM failed: %s\n"", WasmEdge_ResultGetMessage(Res));
    return -1;
  }

  WasmEdge_ModuleInstanceDelete(ImageImpObj);
  WasmEdge_ModuleInstanceDelete(TFLiteImpObj);
  WasmEdge_ModuleInstanceDelete(TFDummyImpObj);
  WasmEdge_VMDelete(VMCxt);
  return 0;
}
```

## Build

### Install dependencies

Use the following commands to download WasmEdge for Android on your Ubuntu dev machine.

```bash
wget https://github.com/WasmEdge/WasmEdge/releases/download/0.12.1/WasmEdge-0.12.1-android_aarch64.tar.gz
wget https://github.com/second-state/WasmEdge-image/releases/download/0.12.1/WasmEdge-image-0.12.1-android_aarch64.tar.gz
wget https://github.com/second-state/WasmEdge-tensorflow/releases/download/0.12.1/WasmEdge-tensorflowlite-0.12.1-android_aarch64.tar.gz
wget https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/0.12.1/WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz
tar -zxf WasmEdge-0.12.1-android_aarch64.tar.gz
tar -zxf WasmEdge-image-0.12.1-android_aarch64.tar.gz -C WasmEdge-0.12.1-Android/
tar -zxf WasmEdge-tensorflowlite-0.12.1-android_aarch64.tar.gz -C WasmEdge-0.12.1-Android/
tar -zxf WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz -C WasmEdge-0.12.1-Android/lib/
```

### Compile

The following command compiles the C program to `a.out` on your Ubunu dev machine.

```bash
(/path/to/ndk)/toolchains/llvm/prebuilt/(HostPlatform)/bin/aarch64-linux-(AndroidApiVersion)-clang test.c -I./WasmEdge-0.12.1-Android/include -L./WasmEdge-0.12.1-Android/lib -lwasmedge-image_c -lwasmedge-tensorflowlite_c -ltensorflowlite_c -lwasmedge
```

## Run

### Push files onto Android

Install the compiled program, Tensorflow Lite model file, test image file, as well as WasmEdge shared library files for Android, onto the Android device using `adb` from your Ubuntu dev machine.

```bash
adb push a.out /data/local/tmp
adb push birds_v1.wasm /data/local/tmp
adb push lite-model_aiy_vision_classifier_birds_V1_3.tflite /data/local/tmp
adb push bird.jpg /data/local/tmp
adb push ./WasmEdge-0.12.1-Android/lib /data/local/tmp
```

### Run the example

Now you can run the compiled C program on the Android device via a remote shell command. Run `adb shell` from your Ubuntu dev machine.

```bash
$ adb shell
sirius:/ $ cd /data/local/tmp
sirius:/data/local/tmp $ export LD_LIBRARY_PATH=/data/local/tmp/lib:$LD_LIBRARY_PATH
sirius:/data/local/tmp $ ./a.out birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
INFO: Initialized TensorFlow Lite runtime.
166 : 0.84705883
```
","Here's a concise, coherent summary of the code and its functionality:

**Purpose:**

The provided code is an example of how to call WebAssembly functions from an NDK (Native Development Kit) native app on Android. It uses the WasmEdge C SDK to embed the WasmEdge Runtime and calls WASM functions through WasmEdge.

**Key Components:**

1. **WasmEdge C SDK**: Provides a C API for working with WebAssembly modules.
2. **WasmEdge VMContext**: Represents the WasmEdge runtime environment.
3. **WasmEdge_ModuleInstanceContext**: Represents a module instance in the WasmEdge runtime.
4. **TensorFlow Lite**: Used for machine learning tasks.
5. **NDK**: Allows C code to interact with native Android libraries.

**Functionality:**

1. Compiles a C program that uses the WasmEdge C SDK to run a WebAssembly function.
2. Pushes files onto an Android device using `adb`.
3. Runs the compiled C program on the Android device, which in turn runs the WebAssembly function using WasmEdge.

**Potential Issues and Areas for Improvement:**

1. **Deprecation**: The code uses deprecated libraries (`WasmEdge-Image`, `WasmEdge-Tensorflow`, and `WasmEdge-tensorflow-tools`) after version 0.12.1.
2. **Android architecture**: Currently only supports arm64-v8a architecture on Android devices.
3. **NDK version compatibility**: The code may not work with newer versions of the NDK.
4. **TensorFlow Lite model file**: Requires a specific TensorFlow Lite model file (`lite-model_aiy_vision_classifier_birds_V1_3.tflite`) to be present on the device.

Overall, this code provides an example of how to integrate WebAssembly functions into an Android native app using the WasmEdge C SDK. However, it may require updates and modifications to work with newer versions of the NDK and WasmEdge."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/ndk.md,"---
sidebar_position: 3
---

# Call WasmEdge functions from an NDK native app

In this section, we will demonstrate how to build an Android native application using C and the Android SDK. The native application uses the WasmEdge C SDK to embed the WasmEdge Runtime, and call WASM functions through WasmEdge.

<!-- prettier-ignore -->
:::note
The `WasmEdge-Image`, `WasmEdge-Tensorflow`, and `WasmEdge-tensorflow-tools` have been deprecated after the 0.12.1 version. We'll update to use the WasmEdge plug-in in the future.
:::

## Prerequisite

### Android

Currently, WasmEdge only supports the arm64-v8a architecture on Android devices. You need an arm64-v8a Android simulator or a physical device with [developer options turned on](https://developer.android.com/studio/debug/dev-options). WasmEdge requires Android 6.0 and above.

### Android development CLI

In Ubuntu Linux, you can use the `apt-get` command to install Android debugging and testing tool `adb`. Using the `adb shell` command on the Ubuntu dev machine, you can open a CLI shell to execute commands on the connected Android device.

```bash
sudo apt-get install adb
```

### Android NDK

To compile programs with the wasmedge-tensorflow c api, you need to install the [Android NDK](https://developer.android.google.cn/ndk/downloads). In this example, we use the latest LTS version (r23b).

## Review of source code

The [`test.c`](https://github.com/second-state/wasm-learning/blob/master/android/test.c) uses the wasmedge-tensorflow c api to run a WebAssembly function. The WebAssembly file `birds_v1.wasm` is compiled from Rust source code and [explained here](/develop/rust/wasinn/tensorflow_lite).

```c
#include <wasmedge/wasmedge.h>
#include <wasmedge/wasmedge-image.h>
#include <wasmedge/wasmedge-tensorflowlite.h>

#include <stdio.h>

int main(int argc, char *argv[]) {
  /*
   * argv[0]: ./a.out
   * argv[1]: WASM file
   * argv[2]: tflite model file
   * argv[3]: image file
   * Usage: ./a.out birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
   */

  /* Create the VM context. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
  WasmEdge_ConfigureDelete(ConfCxt);

  /* Create the image and TFLite import objects. */
  WasmEdge_ModuleInstanceContext *ImageImpObj = WasmEdge_Image_ModuleInstanceCreate();
  WasmEdge_ModuleInstanceContext *TFLiteImpObj = WasmEdge_TensorflowLite_ModuleInstanceCreate();
  WasmEdge_ModuleInstanceContext *TFDummyImpObj = WasmEdge_Tensorflow_ModuleInstanceCreateDummy();

  /* Register into VM. */
  WasmEdge_VMRegisterModuleFromImport(VMCxt, ImageImpObj);
  WasmEdge_VMRegisterModuleFromImport(VMCxt, TFLiteImpObj);
  WasmEdge_VMRegisterModuleFromImport(VMCxt, TFDummyImpObj);

  /* Init WASI. */
  const char *Preopens[] = {"".:.""};
  const char *Args[] = {argv[1], argv[2], argv[3]};
  WasmEdge_ModuleInstanceContext *WASIImpObj = WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
  WasmEdge_ModuleInstanceInitWASI(WASIImpObj, Args, 3, NULL, 0, Preopens, 1);

  /* Run WASM file. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""_start"");
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, argv[1], FuncName, NULL, 0, NULL, 0);
  WasmEdge_StringDelete(FuncName);

  /* Check the result. */
  if (!WasmEdge_ResultOK(Res)) {
    printf(""Run WASM failed: %s\n"", WasmEdge_ResultGetMessage(Res));
    return -1;
  }

  WasmEdge_ModuleInstanceDelete(ImageImpObj);
  WasmEdge_ModuleInstanceDelete(TFLiteImpObj);
  WasmEdge_ModuleInstanceDelete(TFDummyImpObj);
  WasmEdge_VMDelete(VMCxt);
  return 0;
}
```

## Build

### Install dependencies

Use the following commands to download WasmEdge for Android on your Ubuntu dev machine.

```bash
wget https://github.com/WasmEdge/WasmEdge/releases/download/0.12.1/WasmEdge-0.12.1-android_aarch64.tar.gz
wget https://github.com/second-state/WasmEdge-image/releases/download/0.12.1/WasmEdge-image-0.12.1-android_aarch64.tar.gz
wget https://github.com/second-state/WasmEdge-tensorflow/releases/download/0.12.1/WasmEdge-tensorflowlite-0.12.1-android_aarch64.tar.gz
wget https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/0.12.1/WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz
tar -zxf WasmEdge-0.12.1-android_aarch64.tar.gz
tar -zxf WasmEdge-image-0.12.1-android_aarch64.tar.gz -C WasmEdge-0.12.1-Android/
tar -zxf WasmEdge-tensorflowlite-0.12.1-android_aarch64.tar.gz -C WasmEdge-0.12.1-Android/
tar -zxf WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz -C WasmEdge-0.12.1-Android/lib/
```

### Compile

The following command compiles the C program to `a.out` on your Ubunu dev machine.

```bash
(/path/to/ndk)/toolchains/llvm/prebuilt/(HostPlatform)/bin/aarch64-linux-(AndroidApiVersion)-clang test.c -I./WasmEdge-0.12.1-Android/include -L./WasmEdge-0.12.1-Android/lib -lwasmedge-image_c -lwasmedge-tensorflowlite_c -ltensorflowlite_c -lwasmedge
```

## Run

### Push files onto Android

Install the compiled program, Tensorflow Lite model file, test image file, as well as WasmEdge shared library files for Android, onto the Android device using `adb` from your Ubuntu dev machine.

```bash
adb push a.out /data/local/tmp
adb push birds_v1.wasm /data/local/tmp
adb push lite-model_aiy_vision_classifier_birds_V1_3.tflite /data/local/tmp
adb push bird.jpg /data/local/tmp
adb push ./WasmEdge-0.12.1-Android/lib /data/local/tmp
```

### Run the example

Now you can run the compiled C program on the Android device via a remote shell command. Run `adb shell` from your Ubuntu dev machine.

```bash
$ adb shell
sirius:/ $ cd /data/local/tmp
sirius:/data/local/tmp $ export LD_LIBRARY_PATH=/data/local/tmp/lib:$LD_LIBRARY_PATH
sirius:/data/local/tmp $ ./a.out birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
INFO: Initialized TensorFlow Lite runtime.
166 : 0.84705883
```
","**Summary:**

The provided code is an example of how to build and run a native Android application using C and the Android SDK that embeds the WasmEdge Runtime and calls WASM functions through WasmEdge. The code includes:

1. Prerequisites for building and running the application on an arm64-v8a Android device.
2. A review of the source code, which includes a C program (`test.c`) that uses the WasmEdge TensorFlow C API to run a WebAssembly function.
3. Instructions on how to install dependencies, compile the C program, and push files onto the Android device using `adb`.
4. A step-by-step guide on how to run the example on the Android device via a remote shell command.

**Key Components:**

1. WasmEdge Runtime
2. WasmEdge TensorFlow Lite C API
3. Android NDK
4. C programming language
5. Android SDK

**Potential Issues or Areas for Improvement:**

1. The code assumes that the `WasmEdge-0.12.1-android_aarch64.tar.gz` file is downloaded and extracted correctly, but it does not provide any error handling for this step.
2. The `LD_LIBRARY_PATH` environment variable is set manually in the `adb shell` command, which may not be necessary if the shared library files are installed correctly on the Android device.
3. The example code assumes that the WebAssembly file (`birds_v1.wasm`) and the TensorFlow Lite model file (`lite-model_aiy_vision_classifier_birds_V1_3.tflite`) are in the same directory as the compiled C program, but it does not provide any error handling for this assumption.
4. The `adb push` command is used to install the compiled C program and other files on the Android device, but it does not provide any confirmation that the installation was successful.

Overall, the code provides a good example of how to build and run a native Android application using WasmEdge, but it could benefit from some additional error handling and validation to make it more robust."
docs/develop/rust/wasinn/openvino.md,"---
sidebar_position: 4
---

# OpenVINO Backend

We will use [this example project](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/openvino-mobilenet-image) to show how to make AI inference with an OpenVINO model in WasmEdge and Rust.

## Prerequisite

Besides the [regular WasmEdge and Rust requirements](../../rust/setup.md), please make sure that you have the [Wasi-NN plugin with OpenVINO installed](../../../start/install.md#wasi-nn-plug-in-with-openvino-backend).

## Quick start

Because the example already includes a compiled WASM file from the Rust code, we could use WasmEdge CLI to execute the example directly. First, git clone the `WasmEdge-WASINN-examples` repo.

```bash
git clone https://github.com/second-state/WasmEdge-WASINN-examples.git
cd WasmEdge-WASINN-examples/openvino-mobilenet-image/
```

Download the model files in OpenVINO format and then run the inference application in WasmEdge.

```bash
# download the fixture files (OpenVINO model files)
./download_mobilenet.sh
wasmedge --dir .:. wasmedge-wasinn-example-mobilenet-image.wasm mobilenet.xml mobilenet.bin input.jpg
```

If everything goes well, you should have the terminal output:

```bash
Read graph XML, size in bytes: 143525
Read graph weights, size in bytes: 13956476
Loaded graph into wasi-nn with ID: 0
Created wasi-nn execution context with ID: 0
Read input tensor, size in bytes: 602112
Executed graph inference
   1.) [954](0.9789)banana
   2.) [940](0.0074)spaghetti squash
   3.) [951](0.0014)lemon
   4.) [969](0.0005)eggnog
   5.) [942](0.0005)butternut squash
```

## Build and run

Let's build the wasm file from the rust source code. First, git clone the `WasmEdge-WASINN-examples` repo.

```bash
git clone https://github.com/second-state/WasmEdge-WASINN-examples.git
cd WasmEdge-WASINN-examples/openvino-mobilenet-image/rust/
```

Second, use `cargo` to build the template project.

```bash
cargo build --target wasm32-wasi --release
```

The output WASM file is `target/wasm32-wasi/release/wasmedge-wasinn-example-mobilenet-image.wasm`. Download the OpenVINO model files. Next, use WasmEdge to load the OpenVINO model and then use it to classify objects in your image.

```bash
./download_mobilenet.sh
wasmedge --dir .:. wasmedge-wasinn-example-mobilenet-image.wasm mobilenet.xml mobilenet.bin input.jpg
```

You can replace `input.jpg` with your image file.

## Improve performance

You can make the inference program run faster by AOT compiling the `wasm` file first.

```bash
wasmedge compile wasmedge-wasinn-example-mobilenet.wasm out.wasm
wasmedge --dir .:. out.wasm mobilenet.xml mobilenet.bin input.jpg
```

## Understand the code

The [main.rs](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/openvino-mobilenet-image/rust/src/main.rs) is the full example Rust source. First, read the image file and OpenVINO model file names from the command line.

```rust
let args: Vec<String> = env::args().collect();
let model_xml_name: &str = &args[1]; // File name for the model xml
let model_bin_name: &str = &args[2]; // File name for the weights
let image_name: &str = &args[3]; // File name for the input image
```

We use a helper function called `image_to_tensor()` to convert the input image into tensor data (the tensor type is `F32`). Now we can load the model, feed the tensor array from the image to the model, and get the inference output tensor array.

```rust
// load model
let graph = GraphBuilder::new(
    GraphEncoding::Openvino,
    ExecutionTarget::CPU
).build_from_files([model_xml_path, model_bin_path])?;
let mut context = graph.init_execution_context()?;

// Load a tensor that precisely matches the graph input tensor
let input_dims = vec![1, 3, 224, 224];
let tensor_data = image_to_tensor(image_name.to_string(), 224, 224);
context.set_input(0, TensorType::F32, &input_dims, tensor_data)?;

// Execute the inference.
context.compute()?;

// Retrieve the output.
let mut output_buffer = vec![0f32; 1001];
let size_in_bytes = context.get_output(0, &mut output_buffer)?;
```

In the above code, `GraphEncoding::Openvino` means using the OpenVINO backend, and `ExecutionTarget::CPU` means running the computation on the CPU. Finally, we sort the output and then print the top-5 classification results.

```rust
let results = sort_results(&output_buffer);
for i in 0..5 {
    println!(
        ""   {}.) [{}]({:.4}){}"",
        i + 1,
        results[i].0,
        results[i].1,
        imagenet_classes::IMAGENET_CLASSES[results[i].0]
    );
}
```

## More Examples

There is also an example that [using OpenVINO to do road segmentation ADAS](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/openvino-road-segmentation-adas/rust). Welcome to give it a try. You are also welcome to contribute your own examples.
","**Summary**

The provided code demonstrates how to use the OpenVINO backend with WasmEdge and Rust for AI inference. It includes an example project that uses a pre-trained MobileNet model to classify objects in images.

**Key Components**

1. **OpenVINO Model**: The code loads an OpenVINO model, which is used for image classification.
2. **WASM Edge**: The WASM Edge runtime is used to execute the OpenVINO model.
3. **Rust Code**: A Rust program is provided that loads the OpenVINO model and uses it to classify objects in images.

**Functionality**

The code performs the following tasks:

1. Loads an image file and converts it into a tensor data structure.
2. Loads the OpenVINO model and creates a graph execution context.
3. Feeds the tensor array from the image to the model and gets the inference output tensor array.
4. Sorts the output and prints the top-5 classification results.

**Improvement Suggestions**

1. **AOT Compilation**: The code suggests AOT compiling the WASM file first for improved performance.
2. **Optimize Model Loading**: Optimizing the loading of the OpenVINO model can improve inference time.
3. **Use Multiple Threads**: Using multiple threads to execute the inference can take advantage of multi-core CPUs.

**Understanding the Code**

The Rust code is well-documented, and each section has a clear explanation. However, some parts may require additional context or explanations for non-Rust developers.

**Additional Examples**

There are other examples available, such as road segmentation ADAS, which demonstrate using OpenVINO with WasmEdge and Rust.

Overall, the provided code demonstrates how to use OpenVINO with WasmEdge and Rust for AI inference. It includes a clear example project and provides suggestions for improvement."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/openvino.md,"---
sidebar_position: 4
---

# OpenVINO Backend

We will use [this example project](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/openvino-mobilenet-image) to show how to make AI inference with an OpenVINO model in WasmEdge and Rust.

## Prerequisite

Besides the [regular WasmEdge and Rust requirements](../../rust/setup.md), please make sure that you have the [Wasi-NN plugin with OpenVINO installed](../../../start/install.md#wasi-nn-plug-in-with-openvino-backend).

## Quick start

Because the example already includes a compiled WASM file from the Rust code, we could use WasmEdge CLI to execute the example directly. First, git clone the `WasmEdge-WASINN-examples` repo.

```bash
git clone https://github.com/second-state/WasmEdge-WASINN-examples.git
cd WasmEdge-WASINN-examples/openvino-mobilenet-image/
```

Download the model files in OpenVINO format and then run the inference application in WasmEdge.

```bash
# download the fixture files (OpenVINO model files)
./download_mobilenet.sh
wasmedge --dir .:. wasmedge-wasinn-example-mobilenet-image.wasm mobilenet.xml mobilenet.bin input.jpg
```

If everything goes well, you should have the terminal output:

```bash
Read graph XML, size in bytes: 143525
Read graph weights, size in bytes: 13956476
Loaded graph into wasi-nn with ID: 0
Created wasi-nn execution context with ID: 0
Read input tensor, size in bytes: 602112
Executed graph inference
   1.) [954](0.9789)banana
   2.) [940](0.0074)spaghetti squash
   3.) [951](0.0014)lemon
   4.) [969](0.0005)eggnog
   5.) [942](0.0005)butternut squash
```

## Build and run

Let's build the wasm file from the rust source code. First, git clone the `WasmEdge-WASINN-examples` repo.

```bash
git clone https://github.com/second-state/WasmEdge-WASINN-examples.git
cd WasmEdge-WASINN-examples/openvino-mobilenet-image/rust/
```

Second, use `cargo` to build the template project.

```bash
cargo build --target wasm32-wasi --release
```

The output WASM file is `target/wasm32-wasi/release/wasmedge-wasinn-example-mobilenet-image.wasm`. Download the OpenVINO model files. Next, use WasmEdge to load the OpenVINO model and then use it to classify objects in your image.

```bash
./download_mobilenet.sh
wasmedge --dir .:. wasmedge-wasinn-example-mobilenet-image.wasm mobilenet.xml mobilenet.bin input.jpg
```

You can replace `input.jpg` with your image file.

## Improve performance

You can make the inference program run faster by AOT compiling the `wasm` file first.

```bash
wasmedge compile wasmedge-wasinn-example-mobilenet.wasm out.wasm
wasmedge --dir .:. out.wasm mobilenet.xml mobilenet.bin input.jpg
```

## Understand the code

The [main.rs](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/openvino-mobilenet-image/rust/src/main.rs) is the full example Rust source. First, read the image file and OpenVINO model file names from the command line.

```rust
let args: Vec<String> = env::args().collect();
let model_xml_name: &str = &args[1]; // File name for the model xml
let model_bin_name: &str = &args[2]; // File name for the weights
let image_name: &str = &args[3]; // File name for the input image
```

We use a helper function called `image_to_tensor()` to convert the input image into tensor data (the tensor type is `F32`). Now we can load the model, feed the tensor array from the image to the model, and get the inference output tensor array.

```rust
// load model
let graph = GraphBuilder::new(
    GraphEncoding::Openvino,
    ExecutionTarget::CPU
).build_from_files([model_xml_path, model_bin_path])?;
let mut context = graph.init_execution_context()?;

// Load a tensor that precisely matches the graph input tensor
let input_dims = vec![1, 3, 224, 224];
let tensor_data = image_to_tensor(image_name.to_string(), 224, 224);
context.set_input(0, TensorType::F32, &input_dims, tensor_data)?;

// Execute the inference.
context.compute()?;

// Retrieve the output.
let mut output_buffer = vec![0f32; 1001];
let size_in_bytes = context.get_output(0, &mut output_buffer)?;
```

In the above code, `GraphEncoding::Openvino` means using the OpenVINO backend, and `ExecutionTarget::CPU` means running the computation on the CPU. Finally, we sort the output and then print the top-5 classification results.

```rust
let results = sort_results(&output_buffer);
for i in 0..5 {
    println!(
        ""   {}.) [{}]({:.4}){}"",
        i + 1,
        results[i].0,
        results[i].1,
        imagenet_classes::IMAGENET_CLASSES[results[i].0]
    );
}
```

## More Examples

There is also an example that [using OpenVINO to do road segmentation ADAS](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/openvino-road-segmentation-adas/rust). Welcome to give it a try. You are also welcome to contribute your own examples.
","**Summary**

This document provides an example of using OpenVINO with the WasmEdge and Rust environments. It demonstrates how to run AI inference with a pre-trained OpenVINO model on a WasmEdge WASM file.

**Key Components**

*   **WasmEdge**: A WebAssembly (WASM) runtime environment for hosting Edge applications.
*   **OpenVINO**: An open-source framework for computer vision, deep learning, and edge AI.
*   **Rust**: A systems programming language used to develop the WASM file.

**Functionality**

The example code downloads a pre-trained OpenVINO model and uses it to perform inference on an input image. The output is printed in the terminal with the top 5 classification results.

**Steps to Reproduce**

To run the example:

1.  Clone the WasmEdge-WASINN-examples repository.
2.  Navigate to the openvino-mobilenet-image directory and follow the instructions provided in the README file.
3.  Use `cargo` to build the template project, which generates a WASM file.
4.  Download the OpenVINO model files using the `download_mobilenet.sh` script.
5.  Run the inference application using WasmEdge, providing the input image as an argument.

**Potential Issues and Areas for Improvement**

*   **Performance**: The example code does not take advantage of AOT compilation or other optimization techniques that can improve performance.
*   **Error Handling**: The code assumes that all operations will be successful, but error handling is essential in real-world applications.
*   **Code Organization**: The main logic of the code is scattered across multiple files and functions. Refactoring the code to make it more modular and reusable would improve maintainability.

**Additional Resources**

*   WasmEdge-WASINN-examples repository: <https://github.com/second-state/WasmEdge-WASINN-examples>
*   OpenVINO documentation: <https://docs.openvino.ai/>
*   Rust documentation: <https://doc.rust-lang.org/>"
i18n/zh/docusaurus-plugin-content-docs/current/start/usage/serverless/netlify.md,"---
sidebar_position: 2
---
# 在 Netlify 上的 WebAssembly 无服务器函数

在本文中，我们将展示在 Netlify 上部署的两个使用 Rust 和 WasmEdge 的无服务器函数。一个是图像处理功能，另一个是 TensorFlow 推理功能。

> 欲了解更多有关为何在 Netlify 上使用 WasmEdge，请参阅文章 [WebAssembly Serverless Functions in Netlify](https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/)。

## 环境

由于我们的演示 WebAssembly 函数是用 Rust 编写的，你将需要一个 [Rust 编译器](https://www.rust-lang.org/tools/install)。确保按照以下步骤安装 `wasm32-wasi` 编译目标，以便生成 WebAssembly 字节码。

```bash
rustup target add wasm32-wasi
```

演示应用的前端是用 [Next.js](https://nextjs.org/) 编写的，并部署在 Netlify 上。我们假设你已经具备使用 Next.js 和 Netlify 的基本知识。

## 示例 1：图像处理

我们的第一个演示应用允许用户上传图像，然后调用无服务器函数将其转换为黑白。部署在 Netlify 上的 [实时演示](https://60fe22f9ff623f0007656040--reverent-hodgkin-dc1f51.netlify.app/) 可供使用。

首先请 fork [演示应用的 GitHub 存储库](https://github.com/second-state/netlify-wasm-runtime)。要在 Netlify 上部署该应用，只需[将你的 GitHub 存储库添加到 Netlify](https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/)。

该存储库是一个标准的 Netlify 平台 Next.js 应用程序。后端无服务器函数位于 [`api/functions/image_grayscale`](https://github.com/second-state/netlify-wasm-runtime/tree/main/api/functions/image-grayscale) 文件夹中。[`src/main.rs`](https://github.com/second-state/netlify-wasm-runtime/blob/main/api/functions/image-grayscale/src/main.rs) 文件包含了 Rust 程序的源代码。Rust 程序从 `STDIN` 读取图像数据，然后将黑白图像输出到 `STDOUT`。


```rust
use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&buf).unwrap();
  let img = image::load_from_memory(&buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif => {
      filtered.write_to(&mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ => {
      filtered.write_to(&mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&buf).unwrap();
  io::stdout().flush().unwrap();
}
```

你可以使用 Rust 的 `cargo` 工具将 Rust 程序构建成 WebAssembly 字节码或本机代码。

```bash
cd api/functions/image-grayscale/
cargo build --release --target wasm32-wasi
```

将构建产物复制到 `api` 文件夹。

```bash
cp target/wasm32-wasi/release/grayscale.wasm ../../
```

> 在设置无服务器环境时，Netlify 函数会运行 [`api/pre.sh`](https://github.com/second-state/netlify-wasm-runtime/blob/main/api/pre.sh)。该脚本安装 WasmEdge 运行时，然后将每个 WebAssembly 字节码程序编译为本机 `so` 库，以实现更快的执行。

[`api/hello.js`](https://github.com/second-state/netlify-wasm-runtime/blob/main/api/hello.js) 脚本加载 WasmEdge 运行时，启动 WasmEdge 中编译的 WebAssembly 程序，并通过 `STDIN` 传递上传的图像数据。请注意，为了获得更好的性能，[`api/hello.js`](https://github.com/second-state/netlify-wasm-runtime/blob/main/api/hello.js) 运行的是由 [`api/pre.sh`](https://github.com/second-state/netlify-wasm-runtime/blob/main/api/pre.sh) 生成的编译后的 `grayscale.so` 文件。

```javascript
const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) => {
  const wasmedge = spawn(path.join(__dirname, 'wasmedge'), [
    path.join(__dirname, 'grayscale.so'),
  ]);

  let d = [];
  wasmedge.stdout.on('data', (data) => {
    d.push(data);
  });

  wasmedge.on('close', (code) => {
    let buf = Buffer.concat(d);

    res.setHeader('Content-Type', req.headers['image-type']);
    res.send(buf);
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
};
```

准备就绪。现在[将存储库部署到 Netlify](https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/)，你就拥有了一个基于 Rust 和 WebAssembly 的高性能无服务器后端的 Netlify Jamstack 应用。

## 示例 2：AI 推理

[第二个演示](https://60ff7e2d10fe590008db70a9--reverent-hodgkin-dc1f51.netlify.app/) 应用允许用户上传图像，然后调用一个无服务器函数对图像中的主要主题进行分类。

它位于[与上一个示例相同的 GitHub 存储库](https://github.com/second-state/netlify-wasm-runtime/tree/tensorflow)中，但在 `tensorflow` 分支中。用于图像分类的后端无服务器函数位于 `tensorflow` 分支的 [`api/functions/image-classification`](https://github.com/second-state/netlify-wasm-runtime/tree/tensorflow/api/functions/image-classification) 文件夹中。[`src/main.rs`](https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/functions/image-classification/src/main.rs) 文件包含了 Rust 程序的源代码。Rust 程序从 `STDIN` 读取图像数据，然后将文本输出输出到 `STDOUT`。它利用 WasmEdge Tensorflow API 运行 AI 推理。

```rust
pub fn main() {
  // Step 1: Load the TFLite model
  let model_data: &[u8] = include_bytes!(""models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite"");
  let labels = include_str!(""models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt"");

  // Step 2: Read image from STDIN
  let mut buf = Vec::new();
  io::stdin().read_to_end(&mut buf).unwrap();

  // Step 3: Resize the input image for the tensorflow model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&buf, 224, 224);

  // Step 4: AI inference
  let mut session = wasmedge_tensorflow_interface::Session::new(&model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(""input"", &flat_img, &[1, 224, 224, 3])
         .run();
  let res_vec: Vec<u8> = session.get_output(""MobilenetV1/Predictions/Reshape_1"");

  // Step 5: Find the food label that responds to the highest probability in res_vec
  // ... ...
  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }

  // Step 6: Generate the output text
  let class_name = label_lines.next().unwrap().to_string();
  if max_value > 50 {
    println!(""It {} a <a href='https://www.google.com/search?q={}'>{}</a> in the picture"", confidence.to_string(), class_name, class_name);
  } else {
    println!(""It does not appears to be any food item in the picture."");
  }
}
```

你可以使用 `cargo` 工具将 Rust 程序构建为 WebAssembly 字节码或本机代码。

```bash
cd api/functions/image-classification/
cargo build --release --target wasm32-wasi
```

将构建产物复制到 `api` 文件夹中。

```bash
cp target/wasm32-wasi/release/classify.wasm ../../
```

同样，[`api/pre.sh`](https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/pre.sh) 脚本在该应用程序中安装 WasmEdge 运行时及其 Tensorflow 依赖项。它还在部署时将 `classify.wasm` 字节码程序编译为 `classify.so` 本机共享库。

[`api/hello.js`](https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/hello.js) 脚本加载 WasmEdge 运行时，启动在 WasmEdge 中编译的 WebAssembly 程序，并通过 `STDIN` 传递上传的图像数据。请注意，[`api/hello.js`](https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/hello.js) 运行由 [`api/pre.sh`](https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/pre.sh) 生成的编译后的 `classify.so` 文件，以获得更好的性能。

```javascript
const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) => {
  const wasmedge = spawn(
    path.join(__dirname, 'wasmedge-tensorflow-lite'),
    [path.join(__dirname, 'classify.so')],
    { env: { LD_LIBRARY_PATH: __dirname } },
  );

  let d = [];
  wasmedge.stdout.on('data', (data) => {
    d.push(data);
  });

  wasmedge.on('close', (code) => {
    res.setHeader('Content-Type', `text/plain`);
    res.send(d.join(''));
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
};
```

现在，你可以[将你 Fork 的存储库部署到 Netlify](https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/)，获得一个用于主题分类的 Web 应用程序。

接下来，轮到你使用 [netlify-wasm-runtime 存储库](https://github.com/second-state/netlify-wasm-runtime) 作为模板在 Netlify 中开发 Rust 无服务器函数了。期待着你出色的工作。
","该代码片段描述了在 Netlify 上部署 Rust 编写的 WebAssembly 函数。它提供了两个示例：图像处理和 AI 推理。在这两个示例中，代码使用 WasmEdge 运行时来执行 WebAssembly 函数。

**功能性总结**

1. 在 Netlify 上部署 Rust 编写的 WebAssembly 函数。
2. 使用 WasmEdge 运行时来执行 WebAssembly 函数。
3. 提供两个示例：图像处理和 AI 推理。

**代码片段总结**

该代码片段包括：

1. 使用 `rustup target add wasm32-wasi` 安装 `wasm32-wasi` 编译目标。
2. 构建 Rust 程序并生成 WebAssembly 字节码或本机代码。
3. 使用 WasmEdge 运行时来执行 WebAssembly 函数。
4. 在 Netlify 上部署应用程序。

**潜在问题**

1. 在构建过程中可能出现错误，例如缺少依赖项或编译错误。
2. 部署应用程序到 Netlify 的配置可能会出现问题。

**改进建议**

1. 为每个示例提供更多详细信息和示例代码。
2. 在部署过程中提供更详细的指南。
3. 提供测试用例来验证应用程序的正确性。"
docs/embed/use-case/plugin/go_sdk.md,"---
sidebar_position: 3
---

# Using Plug-ins to Extend the Runtime in Go

The WasmEdge plug-ins are the shared libraries to provide the WasmEdge runtime to load and create host module instances. With the plug-ins, the WasmEdge runtime can be extended more easily.

## Loading Plug-ins from Paths

Developers can start using WasmEdge plug-ins by loading them from specific paths. To load plug-ins from the default paths, the following API can be used:

```go
wasmedge.LoadPluginDefaultPaths()
```

Once this API is called, plug-ins from the default paths will be loaded. The default paths include:

- The path specified in the `WASMEDGE_PLUGIN_PATH` environment variable.
- The `../plugin/` directory relative to the WasmEdge installation path.
- The `./wasmedge/` directory under the library path if WasmEdge is installed in a system directory (e.g., `/usr` and `/usr/local`).

Developers can also load plug-ins from specific paths using this API:

```go
wasmedge.LoadPluginFromPath(""PATH_TO_PLUGIN/plugin.so"")
```

## Listing Loaded Plug-ins

Once plug-ins are loaded, developers can list the loaded plug-in names using the following approach:

```go
wasmedge.LoadPluginDefaultPaths()
pluginnames := wasmedge.ListPlugins()
for _, name := range pluginnames {
  fmt.Println(""Loaded plug-in name: "", name)
}
```

## Getting Plug-in Context by Name

Developers can obtain the plug-in context by its name using the following method:

```go
// Assume that wasi_crypto plug-in is installed in the default plug-in path.
wasmedge.LoadPluginDefaultPaths()
plugincrypto := wasmedge.FindPlugin(""wasi_crypto"")
```

## Creating Module Instances from Plug-ins

With the plug-in context, developers can create module instances by providing the module name:

```go
// Assume that the `plugincrypto` is the object to the wasi_crypto plug-in.

// List the available host modules in the plug-in.
modules := plugincrypto.ListModule()
for _, name := range modules {
  fmt.Println(""Available module: "", name)
}
// Will print here for the WASI-Crypto plug-in here:
//   wasi_ephemeral_crypto_asymmetric_common
//   wasi_ephemeral_crypto_common
//   wasi_ephemeral_crypto_kx
//   wasi_ephemeral_crypto_signatures
//   wasi_ephemeral_crypto_symmetric

// Create a module instance from the plug-in by the module name.
modinst := plugincrypto.CreateModule(""wasi_ephemeral_crypto_common"")

modinst.Release()
```

There may be several plug-ins in the default plug-in paths if users [installed WasmEdge plug-ins by the installer](/contribute/installer.md#plugins).

Before using the plug-ins, developers should [Loading Plug-ins from Paths](#loading-plug-ins-from-paths).

## Automatic Module Creation and Mocking

Upon creating a `VM` context, the WasmEdge runtime will automatically create and register the modules of loaded plug-ins. In cases where specific plug-ins are not loaded, WasmEdge will provide mock implementations for certain host modules. These mocked modules include:

- `wasi_ephemeral_crypto_asymmetric_common` (for the `WASI-Crypto`)
- `wasi_ephemeral_crypto_common` (for the `WASI-Crypto`)
- `wasi_ephemeral_crypto_kx` (for the `WASI-Crypto`)
- `wasi_ephemeral_crypto_signatures` (for the `WASI-Crypto`)
- `wasi_ephemeral_crypto_symmetric` (for the `WASI-Crypto`)
- `wasi_ephemeral_nn`
- `wasi_snapshot_preview1`
- `wasmedge_httpsreq`
- `wasmedge_process`
- `wasi:logging/logging` (for the `WASI-Logging`)

## Handling Missing Plug-ins and Error Messages

When the WASM want to invoke these host functions but the corresponding plug-in not installed, WasmEdge will print the error message and return an error.

```go
// Load the plug-ins in the default paths first.
wasmedge.LoadPluginDefaultPaths()

// Create the VM object with the WASI configuration.
conf := wasmedge.NewConfigure(wasmedge.WASI)
vm := wasmedge.NewVMWithConfig(conf)
conf.Release()

// The following API can retrieve the registered modules in the VM objects, includes the built-in WASI and the plug-ins.
// This API will return `NULL` if the module instance not found.

// The `wasimodule` will not be `nil` because the configuration was set.
wasimodule := vm.GetRegisteredModule(""wasi_snapshot_preview1"")

// The `wasinnmodule` will not be `nil` even if the wasi_nn plug-in is not installed, because the VM context will mock and register the host modules.
wasinnmodule := vm.GetRegisteredModule(""wasi_ephemeral_nn"")

vm.Release()
```
","**Summary**

The provided code snippet demonstrates how to use plug-ins with the WasmEdge runtime in Go. Plug-ins are shared libraries that provide host module instances, allowing developers to extend the runtime's functionality. The code covers loading plug-ins from default paths or specific paths, listing loaded plug-in names, obtaining a plug-in context by name, creating module instances from plug-ins, and automatic module creation and mocking.

**Key Components**

1. `wasmedge.LoadPluginDefaultPaths()`: Loads plug-ins from the default paths.
2. `wasmedge.LoadPluginFromPath(""PATH_TO_PLUGIN/plugin.so"")`: Loads a plug-in from a specific path.
3. `wasmedge.ListPlugins()`: Returns a list of loaded plug-in names.
4. `wasmedge.FindPlugin(""wasi_crypto"")`: Obtains the plug-in context by its name.
5. `plugincrypto.CreateModule(""wasi_ephemeral_crypto_common"")`: Creates a module instance from the plug-in by the module name.

**Potential Issues or Areas for Improvement**

1. Error handling: While the code provides some error handling, it's essential to handle errors more robustly, especially when working with dynamic loading of plug-ins.
2. Plugin discovery: The default paths for plugin discovery might not be sufficient in all cases. Consider providing a mechanism for developers to specify custom paths or allow plugins to register themselves.
3. Mocking: While the automatic module creation and mocking are convenient, they might lead to issues when dealing with specific use cases where certain modules need to be replaced by actual implementations.
4. Code organization: The code snippets provided seem to be from different parts of a larger system. Consider reorganizing the code into a more cohesive and modular structure.

**Best Practices**

1. **Use Go's built-in concurrency features**: When working with plug-ins, consider using Go's concurrent features (e.g., goroutines, channels) to improve performance and avoid blocking.
2. **Document APIs thoroughly**: Provide clear documentation for each API, including parameters, return values, and expected behavior.
3. **Test code extensively**: Develop a comprehensive testing suite to ensure the code works as expected in various scenarios."
i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/go_sdk.md,"---
sidebar_position: 3
---

# Using Plug-ins to Extend the Runtime in Go

The WasmEdge plug-ins are the shared libraries to provide the WasmEdge runtime to load and create host module instances. With the plug-ins, the WasmEdge runtime can be extended more easily.

## Loading Plug-ins from Paths

Developers can start using WasmEdge plug-ins by loading them from specific paths. To load plug-ins from the default paths, the following API can be used:

```go
wasmedge.LoadPluginDefaultPaths()
```

Once this API is called, plug-ins from the default paths will be loaded. The default paths include:

- The path specified in the `WASMEDGE_PLUGIN_PATH` environment variable.
- The `../plugin/` directory relative to the WasmEdge installation path.
- The `./wasmedge/` directory under the library path if WasmEdge is installed in a system directory (e.g., `/usr` and `/usr/local`).

Developers can also load plug-ins from specific paths using this API:

```go
wasmedge.LoadPluginFromPath(""PATH_TO_PLUGIN/plugin.so"")
```

## Listing Loaded Plug-ins

Once plug-ins are loaded, developers can list the loaded plug-in names using the following approach:

```go
wasmedge.LoadPluginDefaultPaths()
pluginnames := wasmedge.ListPlugins()
for _, name := range pluginnames {
  fmt.Println(""Loaded plug-in name: "", name)
}
```

## Getting Plug-in Context by Name

Developers can obtain the plug-in context by its name using the following method:

```go
// Assume that wasi_crypto plug-in is installed in the default plug-in path.
wasmedge.LoadPluginDefaultPaths()
plugincrypto := wasmedge.FindPlugin(""wasi_crypto"")
```

## Creating Module Instances from Plug-ins

With the plug-in context, developers can create module instances by providing the module name:

```go
// Assume that the `plugincrypto` is the object to the wasi_crypto plug-in.

// List the available host modules in the plug-in.
modules := plugincrypto.ListModule()
for _, name := range modules {
  fmt.Println(""Available module: "", name)
}
// Will print here for the WASI-Crypto plug-in here:
//   wasi_ephemeral_crypto_asymmetric_common
//   wasi_ephemeral_crypto_common
//   wasi_ephemeral_crypto_kx
//   wasi_ephemeral_crypto_signatures
//   wasi_ephemeral_crypto_symmetric

// Create a module instance from the plug-in by the module name.
modinst := plugincrypto.CreateModule(""wasi_ephemeral_crypto_common"")

modinst.Release()
```

There may be several plug-ins in the default plug-in paths if users [installed WasmEdge plug-ins by the installer](/contribute/installer.md#plugins).

Before using the plug-ins, developers should [Loading Plug-ins from Paths](#loading-plug-ins-from-paths).

## Automatic Module Creation and Mocking

Upon creating a `VM` context, the WasmEdge runtime will automatically create and register the modules of loaded plug-ins. In cases where specific plug-ins are not loaded, WasmEdge will provide mock implementations for certain host modules. These mocked modules include:

- `wasi_ephemeral_crypto_asymmetric_common` (for the `WASI-Crypto`)
- `wasi_ephemeral_crypto_common` (for the `WASI-Crypto`)
- `wasi_ephemeral_crypto_kx` (for the `WASI-Crypto`)
- `wasi_ephemeral_crypto_signatures` (for the `WASI-Crypto`)
- `wasi_ephemeral_crypto_symmetric` (for the `WASI-Crypto`)
- `wasi_ephemeral_nn`
- `wasi_snapshot_preview1`
- `wasmedge_httpsreq`
- `wasmedge_process`
- `wasi:logging/logging` (for the `WASI-Logging`)

## Handling Missing Plug-ins and Error Messages

When the WASM want to invoke these host functions but the corresponding plug-in not installed, WasmEdge will print the error message and return an error.

```go
// Load the plug-ins in the default paths first.
wasmedge.LoadPluginDefaultPaths()

// Create the VM object with the WASI configuration.
conf := wasmedge.NewConfigure(wasmedge.WASI)
vm := wasmedge.NewVMWithConfig(conf)
conf.Release()

// The following API can retrieve the registered modules in the VM objects, includes the built-in WASI and the plug-ins.
// This API will return `NULL` if the module instance not found.

// The `wasimodule` will not be `nil` because the configuration was set.
wasimodule := vm.GetRegisteredModule(""wasi_snapshot_preview1"")

// The `wasinnmodule` will not be `nil` even if the wasi_nn plug-in is not installed, because the VM context will mock and register the host modules.
wasinnmodule := vm.GetRegisteredModule(""wasi_ephemeral_nn"")

vm.Release()
```
","**Summary**

The provided code is a Go API documentation for the WasmEdge plug-in system. It explains how to load and use plug-ins in the WasmEdge runtime, including loading from default paths or specific paths, listing loaded plug-ins, getting plug-in contexts by name, creating module instances from plug-ins, and handling missing plug-ins and error messages.

**Key Components**

1. **Loading Plug-ins**: The code provides two ways to load plug-ins: using `wasmedge.LoadPluginDefaultPaths()` to load from default paths or using `wasmedge.LoadPluginFromPath()` to load from a specific path.
2. **Listing Loaded Plug-ins**: The code shows how to list the loaded plug-in names using the `wasmedge.ListPlugins()` API.
3. **Getting Plug-in Context by Name**: The code demonstrates how to get the plug-in context by its name using the `wasmedge.FindPlugin()` method.
4. **Creating Module Instances from Plug-ins**: The code explains how to create module instances by providing the module name and releasing the instance when done.
5. **Automatic Module Creation and Mocking**: When creating a VM context, WasmEdge automatically creates and registers modules of loaded plug-ins or provides mock implementations for certain host modules.

**Potential Issues and Areas for Improvement**

1. **Error Handling**: The code does not handle errors properly in some cases (e.g., when loading plug-ins from specific paths). It would be beneficial to add more robust error handling.
2. **Code Organization**: The documentation is written in Markdown format, but it might benefit from being reorganized into a more logical structure (e.g., using sections or subsections).
3. **Code Examples**: While the code provides some examples, they are not always clear or complete. Adding more thorough and well-documented examples would improve the usefulness of the documentation.
4. **Plug-in Installation**: The documentation mentions installing plug-ins using the installer, but it does not provide a detailed guide on how to do this.

Overall, the code provides a good foundation for understanding the WasmEdge plug-in system, but could benefit from additional error handling and code organization improvements."
docs/embed/c/library.md,"---
sidebar_position: 2
---

# Use WasmEdge Library

When programming with WasmEdge C API, developers should include the required headers and link with the WasmEdge Library. Besides [install WasmEdge](../../start/install.md#install) with the WasmEdge shared library, developers can also [build WasmEdge](../../contribute/source/build_from_src.md) to generate the WasmEdge static library.

Assume the example `test.c`:

```c
#include <stdio.h>
#include <wasmedge/wasmedge.h>

/* Host function body definition. */
WasmEdge_Result Add(void *Data,
                    const WasmEdge_CallingFrameContext *CallFrameCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  printf(""Host function \""Add\"": %d + %d\n"", Val1, Val2);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The WASM module buffer. */
  uint8_t WASM[] = {/* WASM header */
                    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
                    /* Type section */
                    0x01, 0x07, 0x01,
                    /* function type {i32, i32} -> {i32} */
                    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
                    /* Import section */
                    0x02, 0x13, 0x01,
                    /* module name: ""extern"" */
                    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
                    /* extern name: ""func-add"" */
                    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
                    /* import desc: func 0 */
                    0x00, 0x00,
                    /* Function section */
                    0x03, 0x02, 0x01, 0x00,
                    /* Export section */
                    0x07, 0x0A, 0x01,
                    /* export name: ""addTwo"" */
                    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
                    /* export desc: func 0 */
                    0x00, 0x01,
                    /* Code section */
                    0x0A, 0x0A, 0x01,
                    /* code body */
                    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};

  /* Create the module instance. */
  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");
  WasmEdge_ModuleInstanceContext *HostModCxt =
      WasmEdge_ModuleInstanceCreate(ExportName);
  WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(), WasmEdge_ValTypeGenI32()};
  WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};
  WasmEdge_FunctionTypeContext *HostFType =
      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
  WasmEdge_FunctionInstanceContext *HostFunc =
      WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""func-add"");
  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);
  WasmEdge_StringDelete(HostFuncName);

  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),
                              WasmEdge_ValueGenI32(5678)};
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""addTwo"");
  /* Run the WASM function from buffer. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(
      VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ModuleInstanceDelete(HostModCxt);
  return 0;
}
```

This example will execute a WASM, which calls into a host function to add 2 numbers.

## Link with WasmEdge Shared Library

To link the executable with the WasmEdge shared library is easy. Just compile the example file after installation of WasmEdge.

```bash
$ gcc test.c -lwasmedge -o test
$ ./test
Host function ""Add"": 1234 + 5678
Get the result: 6912
```

## Link with WasmEdge Static Library

For preparing the WasmEdge static library, developers should [build WasmEdge from source](../../contribute/source/build_from_src#cmake-building-options) with the options:

```bash
# Recommend to use the `wasmedge/wasmedge:latest` docker image. This will provide the required packages.
# In the WasmEdge source directory
cmake -Bbuild -GNinja -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_LINK_LLVM_STATIC=ON -DWASMEDGE_BUILD_SHARED_LIB=Off -DWASMEDGE_BUILD_STATIC_LIB=On -DWASMEDGE_LINK_TOOLS_STATIC=On -DWASMEDGE_BUILD_PLUGINS=Off
cmake --build build
cmake --install build
```

The cmake option `-DWASMEDGE_LINK_LLVM_STATIC=ON` will turn on the static library building, and the `-DWASMEDGE_BUILD_SHARED_LIB=Off` will turn off the shared library building.

After installation, developers can compile the example file:

```bash
# Note: only the Linux platforms need the `-lrt`. The MacOS platforms do not need this linker flag.
$ gcc test.c -lwasmedge -lrt -ldl -pthread -lm -lstdc++ -o test
$ ./test
Host function ""Add"": 1234 + 5678
Get the result: 6912
```
","Here's a concise and coherent summary of the provided code:

**Purpose**: The code is an example of how to use the WasmEdge library in C programming. It demonstrates how to create a WASM module, register it with the WasmEdge Virtual Machine (VM), and call into a host function from the WASM module.

**Key Components**:

1. **WasmEdge Library**: The code includes the required headers and links with the WasmEdge library.
2. **WASM Module**: The code creates a WASM module buffer, which is a binary representation of a WebAssembly (WASM) module.
3. **WasmEdge VM**: The code creates a WasmEdge VM context and registers the WASM module with the VM.
4. **Host Function**: The code defines a host function `Add` that takes two integers as input and returns their sum.

**Functionality**:

1. The code compiles the WASM module buffer into a binary format.
2. It creates a WasmEdge VM context and registers the WASM module with the VM.
3. It calls into the `Add` host function from the WASM module, passing two integers as arguments.
4. It retrieves the result of the `Add` function call and prints it to the console.

**Compilation and Execution**:

1. To link with the WasmEdge shared library, compile the code using the `-lwasmedge` flag.
2. To link with the WasmEdge static library, compile the code using the `-lwasmedge -lrt -ldl -pthread -lm -lstdc++` flags.

**Potential Issues**:

1. The code assumes that the WASM module buffer is correctly compiled and formatted.
2. The code does not handle errors that may occur during VM initialization or registration of the WASM module.
3. The code uses `printf` for debugging purposes, which may not be suitable for production environments.

Overall, this code provides a basic example of how to use the WasmEdge library in C programming and demonstrates the creation and execution of a simple WASM module. However, it requires further refinement to handle potential errors and improve its robustness."
i18n/zh/docusaurus-plugin-content-docs/current/embed/c/library.md,"---
sidebar_position: 2
---

# Use WasmEdge Library

When programming with WasmEdge C API, developers should include the required headers and link with the WasmEdge Library. Besides [install WasmEdge](../../start/install.md#install) with the WasmEdge shared library, developers can also [build WasmEdge](../../contribute/source/build_from_src.md) to generate the WasmEdge static library.

Assume the example `test.c`:

```c
#include <stdio.h>
#include <wasmedge/wasmedge.h>

/* Host function body definition. */
WasmEdge_Result Add(void *Data,
                    const WasmEdge_CallingFrameContext *CallFrameCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  printf(""Host function \""Add\"": %d + %d\n"", Val1, Val2);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The WASM module buffer. */
  uint8_t WASM[] = {/* WASM header */
                    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
                    /* Type section */
                    0x01, 0x07, 0x01,
                    /* function type {i32, i32} -> {i32} */
                    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
                    /* Import section */
                    0x02, 0x13, 0x01,
                    /* module name: ""extern"" */
                    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
                    /* extern name: ""func-add"" */
                    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
                    /* import desc: func 0 */
                    0x00, 0x00,
                    /* Function section */
                    0x03, 0x02, 0x01, 0x00,
                    /* Export section */
                    0x07, 0x0A, 0x01,
                    /* export name: ""addTwo"" */
                    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
                    /* export desc: func 0 */
                    0x00, 0x01,
                    /* Code section */
                    0x0A, 0x0A, 0x01,
                    /* code body */
                    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};

  /* Create the module instance. */
  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");
  WasmEdge_ModuleInstanceContext *HostModCxt =
      WasmEdge_ModuleInstanceCreate(ExportName);
  WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(), WasmEdge_ValTypeGenI32()};
  WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};
  WasmEdge_FunctionTypeContext *HostFType =
      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
  WasmEdge_FunctionInstanceContext *HostFunc =
      WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""func-add"");
  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);
  WasmEdge_StringDelete(HostFuncName);

  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),
                              WasmEdge_ValueGenI32(5678)};
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""addTwo"");
  /* Run the WASM function from buffer. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(
      VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ModuleInstanceDelete(HostModCxt);
  return 0;
}
```

This example will execute a WASM, which calls into a host function to add 2 numbers.

## Link with WasmEdge Shared Library

To link the executable with the WasmEdge shared library is easy. Just compile the example file after installation of WasmEdge.

```bash
$ gcc test.c -lwasmedge -o test
$ ./test
Host function ""Add"": 1234 + 5678
Get the result: 6912
```

## Link with WasmEdge Static Library

For preparing the WasmEdge static library, developers should [build WasmEdge from source](../../contribute/source/build_from_src#cmake-building-options) with the options:

```bash
# Recommend to use the `wasmedge/wasmedge:latest` docker image. This will provide the required packages.
# In the WasmEdge source directory
cmake -Bbuild -GNinja -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_LINK_LLVM_STATIC=ON -DWASMEDGE_BUILD_SHARED_LIB=Off -DWASMEDGE_BUILD_STATIC_LIB=On -DWASMEDGE_LINK_TOOLS_STATIC=On -DWASMEDGE_BUILD_PLUGINS=Off
cmake --build build
cmake --install build
```

The cmake option `-DWASMEDGE_LINK_LLVM_STATIC=ON` will turn on the static library building, and the `-DWASMEDGE_BUILD_SHARED_LIB=Off` will turn off the shared library building.

After installation, developers can compile the example file:

```bash
# Note: only the Linux platforms need the `-lrt`. The MacOS platforms do not need this linker flag.
$ gcc test.c -lwasmedge -lrt -ldl -pthread -lm -lstdc++ -o test
$ ./test
Host function ""Add"": 1234 + 5678
Get the result: 6912
```
","**Code Summary**

This code is an example of using the WasmEdge library to execute a WebAssembly (WASM) module that calls into a host function. The host function, `Add`, takes two integer parameters and returns their sum.

The code creates a WASM module instance, registers it with the WasmEdge VM, and then runs the `addTwo` function from the WASM module, which calls the `Add` host function. The result of the addition is printed to the console.

**Key Components**

1. **WASM Module**: A buffer containing the binary data of a WASM module.
2. **Host Function**: A C function, `Add`, that takes two integer parameters and returns their sum.
3. **WasmEdge VM**: An instance of the WasmEdge virtual machine that executes the WASM module.
4. **Module Instance**: An object that represents an instance of a WASM module in memory.

**Linking with WasmEdge Library**

To link the executable with the WasmEdge shared library, compile the example file after installing WasmEdge:

```bash
$ gcc test.c -lwasmedge -o test
```

For building the WasmEdge static library, follow these steps:

1. Build WasmEdge from source using CMake:
```bash
cmake -Bbuild -GNinja -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_LINK_LLVM_STATIC=ON -DWASMEDGE_BUILD_SHARED_LIB=Off -DWASMEDGE_BUILD_STATIC_LIB=On -DWASMEDGE_LINK_TOOLS_STATIC=On -DWASMEDGE_BUILD_PLUGINS=Off
```
2. Compile the example file:
```bash
$ gcc test.c -lwasmedge -lrt -ldl -pthread -lm -lstdc++ -o test
```

**Notes**

* The code assumes a Linux platform and uses the `-lrt` linker flag to link against the `librt` library.
* On MacOS platforms, this flag is not needed.
* The `DWASMEDGE_LINK_LLVM_STATIC=ON` CMake option enables static linking with LLVM libraries."
docs/develop/javascript/intro.md,"---
sidebar_position: 1
---

# Introduction

WebAssembly started as a ""JavaScript alternative for browsers"". The idea is to safely run high-performance applications compiled from languages like C/C++ or Rust in browsers. In the browser, WebAssembly runs side by side with JavaScript.

As WebAssembly is increasingly used in the cloud, it is now a universal runtime for cloud-native applications. Compared with Linux containers, WebAssembly runtimes achieve higher performance with lower resource consumption.

In cloud-native use cases, developers often want to use JavaScript to write business applications. That means we must now support JavaScript in WebAssembly. Furthermore, we should support calling C/C++ or Rust functions from JavaScript in a WebAssembly runtime to maximize WebAssembly's computational efficiency. The WasmEdge WebAssembly runtime allows you to do exactly that.

![javascript](javascript.png)

## Why run JavaScript in WasmEdge

- Lightweight and secure JS runtime. Compared with V8 and Node.js, WasmEdge itself is a lightweight， high-performance JavaScript runtime。
- No need for Linux containers. WasmEdge could be a secure container without tons of dependencies.
- Node.js compatible. See the status [here](https://github.com/WasmEdge/WasmEdge/issues/1535).
- Use Rust to implement JS APIs. See the tutorial here.

This section will demonstrate how to run and enhance JavaScript in WasmEdge.

- [Getting started](hello_world) demonstrates how to run simple JavaScript programs in WasmEdge.
- [Networking sockets](networking) shows how to create non-blocking (async) HTTP clients, including the `fetch` API, and server applications in JavaScript.
- [Node.js compatibility](nodejs) describes Node.js APIs support in WasmEdge QuickJS.
- [ES6 modules](es6) shows how to incorporate ES6 modules in WasmEdge.
- [Node.js and NPM modules](npm) shows how to incorporate NPM modules in WasmEdge.
- [Built-in modules](modules) show how to add JavaScript functions into the WasmEdge runtime as built-in API functions.
- [Use Rust to implement JS API](rust) discusses using Rust to implement and support a JavaScript API.
- [React SSR](ssr) shows example React SSR applications, including streaming SSR support.

## A note on v8

Now, the choice of QuickJS as our JavaScript engine might raise the question of performance. Isn't QuickJS [a lot slower](https://bellard.org/quickjs/bench.html) than v8 due to a lack of JIT support? Yes, but ...

First of all, QuickJS is a lot smaller than v8. It only takes 1/40 (or 2.5%) of the runtime resources v8 consumes. You can run many more QuickJS functions than v8 functions on a single physical machine.

Second, for most business logic applications, raw performance is not critical. The application may have computationally intensive tasks, such as AI inference on the fly. WasmEdge allows the QuickJS applications to drop to high-performance WebAssembly for these tasks while adding such extensions modules is more challenging with v8.

Third, WasmEdge is [itself an OCI-compliant container](../deploy/intro). It is secure by default, supports resource isolation, and can be managed by container tools to run with Linux containers in a single k8s cluster.

Finally, v8 has a huge attack surface and requires [significant efforts](https://blog.cloudflare.com/mitigating-spectre-and-other-security-threats-the-cloudflare-workers-security-model/) to run securely in a public cloud environment. It is known that [many JavaScript security issues arise from JIT](https://www.theregister.com/2021/08/06/edge_super_duper_security_mode/). Maybe turning off JIT in the cloud-native environment is not a bad idea!

In the end, running v8 in a cloud-native environment often requires a whole stack of software tools consisting of ""Linux container + guest OS + node or deno + v8"", which makes it much heavier and slower than a simple WasmEdge + QuickJS container runtime.
","**Summary**

This is a documentation section on the WasmEdge WebAssembly runtime, which allows developers to run high-performance applications compiled from languages like C/C++ or Rust in browsers. The focus of this section is on supporting JavaScript in WebAssembly and calling C/C++ or Rust functions from JavaScript.

**Key Components**

1. **WasmEdge Runtime**: A lightweight, high-performance WebAssembly runtime that can run side by side with JavaScript.
2. **QuickJS Engine**: A JavaScript engine used as the default JavaScript engine for WasmEdge, providing a secure and lightweight alternative to V8 and Node.js.
3. **Node.js Compatibility**: Support for running Node.js APIs in WasmEdge QuickJS.
4. **Rust Integration**: The ability to use Rust to implement JavaScript APIs.

**Functionalities**

1. **Running JavaScript programs**: Demonstrated through the ""Getting started"" example.
2. **Networking sockets**: Creating non-blocking (async) HTTP clients and server applications using JavaScript.
3. **ES6 modules**: Incorporating ES6 modules in WasmEdge.
4. **Built-in modules**: Adding JavaScript functions into the WasmEdge runtime as built-in API functions.

**Potential Issues/ Areas for Improvement**

1. **Performance Comparison with V8**: While QuickJS is smaller and lighter, it may have performance issues compared to V8.
2. **Lack of JIT support**: QuickJS's lack of JIT support may lead to slower performance.
3. **Security considerations**: Running v8 in a cloud-native environment requires significant efforts to ensure security.

**Recommendations**

1. **Use WasmEdge + QuickJS for lightweight and secure JavaScript execution**: Given the benefits of WasmEdge and QuickJS, this combination is recommended for running JavaScript applications.
2. **Consider Rust integration for custom JavaScript APIs**: Using Rust to implement custom JavaScript APIs can provide performance benefits and flexibility."
docs/embed/quick-start/embed-wasm-apps-go.md,"---
sidebar_position: 3
---

# Embed the WASM app into your Go Host app

In the previous chapter, we learned how to create a WASM app using Rust and `wasmedge-bindgen` tool. In this chapter, I will walk you through how to embed the compiled WASM app into your Go Host app.

## The Go Host Application

In the [Go host application](https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/bindgen_funcs.go), you can create and set up the WasmEdge VM using the WasmEdge Go SDK.

However, instead of calling `vm.Instantiate()`, you should now call `bindgen.Instantiate(vm)` to instantiate the VM and return a `bindgen` object.

```go
func main() {
  // Expected Args[0]: program name (./bindgen_funcs)
  // Expected Args[1]: wasm file (rust_bindgen_funcs_lib.wasm))

  wasmedge.SetLogErrorLevel()
  var conf = wasmedge.NewConfigure(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{"".:.""}, // The mapping preopens
  )
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()

  // Instantiate the bindgen and vm
  bg := bindgen.Instantiate(vm)
```

Next, you can call any `[wasmedge_bindgen]` annotated functions in the VM via the `bindgen` object.

```go
  // create_line: string, string, string -> string (inputs are JSON stringified)
  res, err := bg.Execute(""create_line"", ""{\""x\"":2.5,\""y\"":7.8}"", ""{\""x\"":2.5,\""y\"":5.8}"", ""A thin red line"")
  if err == nil {
    fmt.Println(""Run bindgen -- create_line:"", string(res))
  } else {
    fmt.Println(""Run bindgen -- create_line FAILED"", err)
  }

  // say: string -> string
  res, err = bg.Execute(""say"", ""bindgen funcs test"")
  if err == nil {
    fmt.Println(""Run bindgen -- say:"", string(res))
  } else {
    fmt.Println(""Run bindgen -- say FAILED"")
  }

  // obfusticate: string -> string
  res, err = bg.Execute(""obfusticate"", ""A quick brown fox jumps over the lazy dog"")
  if err == nil {
    fmt.Println(""Run bindgen -- obfusticate:"", string(res))
  } else {
    fmt.Println(""Run bindgen -- obfusticate FAILED"")
  }

  // lowest_common_multiple: i32, i32 -> i32
  res, err = bg.Execute(""lowest_common_multiple"", int32(123), int32(2))
  if err == nil {
    num, _ := strconv.ParseInt(string(res), 10, 32)
    fmt.Println(""Run bindgen -- lowest_common_multiple:"", num)
  } else {
    fmt.Println(""Run bindgen -- lowest_common_multiple FAILED"")
  }

  // sha3_digest: array -> array
  res, err = bg.Execute(""sha3_digest"", []byte(""This is an important message""))
  if err == nil {
    fmt.Println(""Run bindgen -- sha3_digest:"", res)
  } else {
    fmt.Println(""Run bindgen -- sha3_digest FAILED"")
  }

  // keccak_digest: array -> array
  res, err = bg.Execute(""keccak_digest"", []byte(""This is an important message""))
  if err == nil {
    fmt.Println(""Run bindgen -- keccak_digest:"", res)
  } else {
    fmt.Println(""Run bindgen -- keccak_digest FAILED"")
  }

  bg.Release()
  vm.Release()
  conf.Release()
}
```

## Run the WASM app from your Go Host

Before that, make sure you have [installed Go, WasmEdge, and WasmEdge Go SDK](install.md).

```bash
$ cd rust_bindgen_funcs
go build
./bindgen_funcs rust_bindgen_funcs_lib.wasm
```

The standard output of this example will be the following.

```bash
Run bindgen -- create_line: {""points"":[{""x"":1.5,""y"":3.8},{""x"":2.5,""y"":5.8}],""valid"":true,""length"":2.2360682,""desc"":""A thin red line""}
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
```

That's it. Next, let's dive into how to pass complex data from host applications to the WASM app.
","**Summary**

The provided code is an example of how to embed a WASM (WebAssembly) app into a Go Host application using the WasmEdge SDK. The Go Host application is responsible for loading and instantiating the WASM app, as well as passing arguments and retrieving results from the WASM app.

**Key Components**

1. **WasmEdge VM**: The code creates a new instance of the WasmEdge VM using the `wasmedge.NewVMWithConfig` function.
2. **Bindgen**: The code uses the `bindgen.Instantiate` function to instantiate the bindgen object, which is used to interact with the WASM app.
3. **WASM App**: The code loads a WASM file into the VM using the `vm.LoadWasmFile` function and validates it using the `vm.Validate` function.

**Functionality**

The code demonstrates how to call various functions in the WASM app, including:

* `create_line`: takes three string arguments (JSON serialized) and returns a JSON-serialized result
* `say`: takes one string argument and returns a string result
* `obfusticate`: takes one string argument and returns a string result
* `lowest_common_multiple`: takes two i32 arguments and returns an i32 result
* `sha3_digest` and `keccak_digest`: take an array of bytes as input and return an array of bytes as output

**Potential Issues**

1. **Error handling**: The code does not properly handle errors that may occur when loading or instantiating the WASM app.
2. **Memory safety**: The code does not check for memory safety issues, such as buffer overflows or underflows, when working with the WASM app's output.
3. **Performance**: The code does not optimize performance-critical functions in the WASM app.

**Areas for Improvement**

1. **Implement proper error handling**: Add try-catch blocks to handle errors that may occur during loading and instantiation of the WASM app.
2. **Add memory safety checks**: Use tools like AddressSanitizer or Valgrind to identify potential memory safety issues in the code.
3. **Optimize performance-critical functions**: Profile the performance of the WASM app's output functions and optimize them using techniques such as caching, memoization, or parallelism."
i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/intro.md,"---
sidebar_position: 1
---

# Introduction

WebAssembly started as a ""JavaScript alternative for browsers"". The idea is to safely run high-performance applications compiled from languages like C/C++ or Rust in browsers. In the browser, WebAssembly runs side by side with JavaScript.

As WebAssembly is increasingly used in the cloud, it is now a universal runtime for cloud-native applications. Compared with Linux containers, WebAssembly runtimes achieve higher performance with lower resource consumption.

In cloud-native use cases, developers often want to use JavaScript to write business applications. That means we must now support JavaScript in WebAssembly. Furthermore, we should support calling C/C++ or Rust functions from JavaScript in a WebAssembly runtime to maximize WebAssembly's computational efficiency. The WasmEdge WebAssembly runtime allows you to do exactly that.

![javascript](javascript.png)

## Why run JavaScript in WasmEdge

- Lightweight and secure JS runtime. Compared with V8 and Node.js, WasmEdge itself is a lightweight， high-performance JavaScript runtime。
- No need for Linux containers. WasmEdge could be a secure container without tons of dependencies.
- Node.js compatible. See the status [here](https://github.com/WasmEdge/WasmEdge/issues/1535).
- Use Rust to implement JS APIs. See the tutorial here.

This section will demonstrate how to run and enhance JavaScript in WasmEdge.

- [Getting started](hello_world) demonstrates how to run simple JavaScript programs in WasmEdge.
- [Networking sockets](networking) shows how to create non-blocking (async) HTTP clients, including the `fetch` API, and server applications in JavaScript.
- [Node.js compatibility](nodejs) describes Node.js APIs support in WasmEdge QuickJS.
- [ES6 modules](es6) shows how to incorporate ES6 modules in WasmEdge.
- [Node.js and NPM modules](npm) shows how to incorporate NPM modules in WasmEdge.
- [Built-in modules](modules) show how to add JavaScript functions into the WasmEdge runtime as built-in API functions.
- [Use Rust to implement JS API](rust) discusses using Rust to implement and support a JavaScript API.
- [React SSR](ssr) shows example React SSR applications, including streaming SSR support.

## A note on v8

Now, the choice of QuickJS as our JavaScript engine might raise the question of performance. Isn't QuickJS [a lot slower](https://bellard.org/quickjs/bench.html) than v8 due to a lack of JIT support? Yes, but ...

First of all, QuickJS is a lot smaller than v8. It only takes 1/40 (or 2.5%) of the runtime resources v8 consumes. You can run many more QuickJS functions than v8 functions on a single physical machine.

Second, for most business logic applications, raw performance is not critical. The application may have computationally intensive tasks, such as AI inference on the fly. WasmEdge allows the QuickJS applications to drop to high-performance WebAssembly for these tasks while adding such extensions modules is more challenging with v8.

Third, WasmEdge is [itself an OCI-compliant container](../deploy/intro). It is secure by default, supports resource isolation, and can be managed by container tools to run with Linux containers in a single k8s cluster.

Finally, v8 has a huge attack surface and requires [significant efforts](https://blog.cloudflare.com/mitigating-spectre-and-other-security-threats-the-cloudflare-workers-security-model/) to run securely in a public cloud environment. It is known that [many JavaScript security issues arise from JIT](https://www.theregister.com/2021/08/06/edge_super_duper_security_mode/). Maybe turning off JIT in the cloud-native environment is not a bad idea!

In the end, running v8 in a cloud-native environment often requires a whole stack of software tools consisting of ""Linux container + guest OS + node or deno + v8"", which makes it much heavier and slower than a simple WasmEdge + QuickJS container runtime.
","**Summary:**

This document introduces WebAssembly as a ""JavaScript alternative for browsers"" and its evolution into a universal runtime for cloud-native applications. It highlights the benefits of using WebAssembly, including higher performance with lower resource consumption compared to Linux containers.

The document also focuses on supporting JavaScript in WebAssembly, particularly through the WasmEdge WebAssembly runtime. It showcases how WasmEdge allows developers to run lightweight and secure JavaScript applications while leveraging the performance of WebAssembly.

**Key Components:**

1. Introduction to WebAssembly as a cloud-native runtime
2. Benefits of using WebAssembly compared to Linux containers
3. Overview of WasmEdge as a JavaScript engine for WebAssembly
4. Examples of WasmEdge usage, including networking sockets, Node.js compatibility, ES6 modules, and built-in modules
5. Discussion on the choice of QuickJS over V8 as the JavaScript engine

**Potential Issues:**

1. Performance comparison between QuickJS and V8 might not be entirely accurate due to factors like JIT support.
2. The document mentions that running v8 in a cloud-native environment can have significant security implications, but it's unclear how this is mitigated by WasmEdge.
3. While the document highlights the benefits of using WebAssembly, it doesn't provide concrete evidence or benchmarks for these claims.

**Areas for Improvement:**

1. Provide more concrete performance comparisons between QuickJS and V8.
2. Offer a clearer explanation on how WasmEdge addresses security concerns related to v8 in cloud-native environments.
3. Include more detailed examples or use cases demonstrating the benefits of using WebAssembly with WasmEdge.
4. Consider adding more information on WasmEdge's architecture, design decisions, and trade-offs when choosing QuickJS as the JavaScript engine."
i18n/zh/docusaurus-plugin-content-docs/current/embed/quick-start/embed-wasm-apps-go.md,"---
sidebar_position: 3
---

# Embed the WASM app into your Go Host app

In the previous chapter, we learned how to create a WASM app using Rust and `wasmedge-bindgen` tool. In this chapter, I will walk you through how to embed the compiled WASM app into your Go Host app.

## The Go Host Application

In the [Go host application](https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/bindgen_funcs.go), you can create and set up the WasmEdge VM using the WasmEdge Go SDK.

However, instead of calling `vm.Instantiate()`, you should now call `bindgen.Instantiate(vm)` to instantiate the VM and return a `bindgen` object.

```go
func main() {
  // Expected Args[0]: program name (./bindgen_funcs)
  // Expected Args[1]: wasm file (rust_bindgen_funcs_lib.wasm))

  wasmedge.SetLogErrorLevel()
  var conf = wasmedge.NewConfigure(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{"".:.""}, // The mapping preopens
  )
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()

  // Instantiate the bindgen and vm
  bg := bindgen.Instantiate(vm)
```

Next, you can call any `[wasmedge_bindgen]` annotated functions in the VM via the `bindgen` object.

```go
  // create_line: string, string, string -> string (inputs are JSON stringified)
  res, err := bg.Execute(""create_line"", ""{\""x\"":2.5,\""y\"":7.8}"", ""{\""x\"":2.5,\""y\"":5.8}"", ""A thin red line"")
  if err == nil {
    fmt.Println(""Run bindgen -- create_line:"", string(res))
  } else {
    fmt.Println(""Run bindgen -- create_line FAILED"", err)
  }

  // say: string -> string
  res, err = bg.Execute(""say"", ""bindgen funcs test"")
  if err == nil {
    fmt.Println(""Run bindgen -- say:"", string(res))
  } else {
    fmt.Println(""Run bindgen -- say FAILED"")
  }

  // obfusticate: string -> string
  res, err = bg.Execute(""obfusticate"", ""A quick brown fox jumps over the lazy dog"")
  if err == nil {
    fmt.Println(""Run bindgen -- obfusticate:"", string(res))
  } else {
    fmt.Println(""Run bindgen -- obfusticate FAILED"")
  }

  // lowest_common_multiple: i32, i32 -> i32
  res, err = bg.Execute(""lowest_common_multiple"", int32(123), int32(2))
  if err == nil {
    num, _ := strconv.ParseInt(string(res), 10, 32)
    fmt.Println(""Run bindgen -- lowest_common_multiple:"", num)
  } else {
    fmt.Println(""Run bindgen -- lowest_common_multiple FAILED"")
  }

  // sha3_digest: array -> array
  res, err = bg.Execute(""sha3_digest"", []byte(""This is an important message""))
  if err == nil {
    fmt.Println(""Run bindgen -- sha3_digest:"", res)
  } else {
    fmt.Println(""Run bindgen -- sha3_digest FAILED"")
  }

  // keccak_digest: array -> array
  res, err = bg.Execute(""keccak_digest"", []byte(""This is an important message""))
  if err == nil {
    fmt.Println(""Run bindgen -- keccak_digest:"", res)
  } else {
    fmt.Println(""Run bindgen -- keccak_digest FAILED"")
  }

  bg.Release()
  vm.Release()
  conf.Release()
}
```

## Run the WASM app from your Go Host

Before that, make sure you have [installed Go, WasmEdge, and WasmEdge Go SDK](install.md).

```bash
$ cd rust_bindgen_funcs
go build
./bindgen_funcs rust_bindgen_funcs_lib.wasm
```

The standard output of this example will be the following.

```bash
Run bindgen -- create_line: {""points"":[{""x"":1.5,""y"":3.8},{""x"":2.5,""y"":5.8}],""valid"":true,""length"":2.2360682,""desc"":""A thin red line""}
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
```

That's it. Next, let's dive into how to pass complex data from host applications to the WASM app.
","**Summary**

The code provided demonstrates how to embed a WebAssembly (WASM) application into a Go host application using the WasmEdge Go SDK. It explains the process of creating and setting up a WasmEdge VM, instantiating the VM with a bindgen object, and calling WASM functions annotated with `wasmedge_bindgen` through the bindgen object.

**Key Components**

1. **WasmEdge VM**: The code creates a WasmEdge VM instance using the WasmEdge Go SDK.
2. **Bindgen**: A bindgen object is created by instantiating the VM and used to call WASM functions annotated with `wasmedge_bindgen`.
3. **WASMedge Bindgen Annotated Functions**: The code demonstrates how to call various WASMedge Bindgen annotated functions, such as `create_line`, `say`, `obfusticate`, `lowest_common_multiple`, `sha3_digest`, and `keccak_digest`.

**Functionality**

The code provides a step-by-step guide on how to:

1. Create a WasmEdge VM instance.
2. Instantiate the VM with a bindgen object.
3. Call WASMedge Bindgen annotated functions through the bindgen object.

**Potential Issues or Areas for Improvement**

1. **Error Handling**: The code does not handle errors properly, and the `err` variable is often ignored or handled improperly.
2. **Performance**: The code may be optimized for better performance by using caching mechanisms or optimizing the WASM function calls.
3. **Testing**: The code could benefit from additional testing to ensure that it works correctly in different scenarios.

**Best Practices**

1. **Use Go Standard Library**: The code should use the standard Go library functions instead of external libraries whenever possible.
2. **Follow Best Practices for Error Handling**: Proper error handling is crucial, and the code should be modified to handle errors more robustly.
3. **Optimize Code for Performance**: Regular optimization of the code can improve its performance.

**Installation**

To run the WASM app from your Go host, make sure you have installed:

* `go`
* `wasm2go` (the WasmEdge Go SDK)
* `go build` to compile and link the Go code."
docs/develop/rust/database/postgres_driver.md,"---
sidebar_position: 2
---

# PostgreSQL driver

A database connection is necessary for today's enterprise development. WasmEdge provides a PostgreSQL driver for Rust developers, enabling developers to build database applications in Rust and then running in WasmEdge.

<!-- prettier-ignore -->
:::note
Before we start, [you need to have Rust and WasmEdge installed](../setup.md).
Make sure that you read the [special notes on networking apps](../setup#special-notes-for-networking-apps) especially if you are compiling Rust programs on a Mac.
:::

## Run the example

The [wasmedge-db-example/postgres](https://github.com/WasmEdge/wasmedge-db-examples/tree/main/postgres) is a PostgreSQL connector example written in Rust.

```bash
git clone https://github.com/WasmEdge/wasmedge-db-examples
cd wasmedge-db-examples/postgres

# Compile the rust code into WASM
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release

# Execute SQL statements against a PostgreSQL database at postgres://user:passwd@localhost/testdb
wasmedge --env ""DATABASE_URL=postgres://user:passwd@localhost/testdb"" target/wasm32-wasi/release/crud.wasm
```

## Configuration

In order to compile the `tokio-postgres` and `tokio` crates, we will need to apply patches to add WasmEdge-specific socket APIs to those crates in `Cargo.toml`.

```
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }
socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }
tokio-postgres = { git = ""https://github.com/second-state/rust-postgres.git"" }

[dependencies]
tokio-postgres = ""0.7""
tokio = { version = ""1"", features = [
    ""io-util"",
    ""fs"",
    ""net"",
    ""time"",
    ""rt"",
    ""macros"",
] }
```

## Code explanation

We first use a Rust struct to represent the database table.

```rust
#[derive(Debug)]
struct Order {
    order_id: i32,
    production_id: i32,
    quantity: i32,
    amount: f32,
    shipping: f32,
    tax: f32,
    shipping_address: String,
}

impl Order {
    fn new(
        order_id: i32,
        production_id: i32,
        quantity: i32,
        amount: f32,
        shipping: f32,
        tax: f32,
        shipping_address: String,
    ) -> Self {
        Self {
            order_id,
            production_id,
            quantity,
            amount,
            shipping,
            tax,
            shipping_address,
        }
    }
}
```

Then, you can use the `tokio-postgres` API to access the database through its connection URL.
The code below shows how to perform basic CRUD operations using SQL commands.

```rust
#[tokio::main(flavor = ""current_thread"")]
async fn main() -> Result<(), Error> {
    // Connect to the database.
    let (client, connection) = tokio_postgres::connect(&*get_url(), NoTls).await?;

    // The connection object performs the actual communication with the database,
    // so spawn it off to run on its own.
    tokio::spawn(async move {
        if let Err(e) = connection.await {
            eprintln!(""connection error: {}"", e);
        }
    });

    client.execute(""CREATE TABLE IF NOT EXISTS orders (order_id INT, production_id INT, quantity INT, amount REAL, shipping REAL, tax REAL, shipping_address VARCHAR(256));"", &[]).await?;

    let orders = vec![
        Order::new(1, 12, 2, 56.0, 15.0, 2.0, String::from(""Mataderos 2312"")),
        Order::new(2, 15, 3, 256.0, 30.0, 16.0, String::from(""1234 NW Bobcat"")),
        Order::new(3, 11, 5, 536.0, 50.0, 24.0, String::from(""20 Havelock"")),
        Order::new(4, 8, 8, 126.0, 20.0, 12.0, String::from(""224 Pandan Loop"")),
        Order::new(5, 24, 1, 46.0, 10.0, 2.0, String::from(""No.10 Jalan Besar"")),
    ];

    for order in orders.iter() {
        client.execute(
            ""INSERT INTO orders (order_id, production_id, quantity, amount, shipping, tax, shipping_address) VALUES ($1, $2, $3, $4, $5, $6, $7)"",
            &[&order.order_id, &order.production_id, &order.quantity, &order.amount, &order.shipping, &order.tax, &order.shipping_address]
        ).await?;
    }

    let rows = client.query(""SELECT * FROM orders;"", &[]).await?;
    for row in rows.iter() {
        let order_id : i32 = row.get(0);
        println!(""order_id {}"", order_id);

        let production_id : i32 = row.get(1);
        println!(""production_id {}"", production_id);

        let quantity : i32 = row.get(2);
        println!(""quantity {}"", quantity);

        let amount : f32 = row.get(3);
        println!(""amount {}"", amount);

        let shipping : f32 = row.get(4);
        println!(""shipping {}"", shipping);

        let tax : f32 = row.get(5);
        println!(""tax {}"", tax);

        let shipping_address : &str = row.get(6);
        println!(""shipping_address {}"", shipping_address);
    }

    client.execute(""DELETE FROM orders;"", &[]).await?;

    Ok(())
}
```

","**Summary**

The provided code is a PostgreSQL driver for Rust developers using the WasmEdge framework. It enables developers to build database applications in Rust and then run them in WasmEdge.

**Key Components**

1. `tokio-postgres` API: used to access the database through its connection URL.
2. `Order` struct: represents the database table, with methods for creating new instances.
3. CRUD operations:
	* Create: inserts new records into the `orders` table.
	* Read: retrieves all records from the `orders` table and prints them.
	* Update/Insert: not implemented in this example.
	* Delete: deletes all records from the `orders` table.

**Configuration**

To compile the `tokio-postgres` and `tokio` crates, patches need to be applied to add WasmEdge-specific socket APIs. The `Cargo.toml` file contains the necessary configuration.

**Potential Issues/Improvements**

1. **Error Handling**: The code does not properly handle errors, which could lead to unexpected behavior or crashes.
2. **Security**: The code uses a hardcoded database connection URL and credentials, which is a security risk. Consider using environment variables or secure storage for sensitive data.
3. **Performance**: The code creates multiple connections to the database, which can lead to performance issues. Consider reusing connections or using a connection pool.
4. **Code Organization**: The code mixes database operations with business logic, making it harder to maintain and extend.
5. **Type Safety**: The code uses `f32` for floating-point numbers, but it's better to use more specific types (e.g., `BigDecimal`) for financial calculations.

**Best Practices**

1. Follow the WasmEdge framework guidelines for building database applications.
2. Use environment variables or secure storage for sensitive data.
3. Implement proper error handling and logging mechanisms.
4. Reuse connections or use a connection pool to improve performance.
5. Keep the code organized, with separate modules for business logic and database operations."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/postgres_driver.md,"---
sidebar_position: 2
---

# PostgreSQL driver

A database connection is necessary for today's enterprise development. WasmEdge provides a PostgreSQL driver for Rust developers, enabling developers to build database applications in Rust and then running in WasmEdge.

<!-- prettier-ignore -->
:::note
Before we start, [you need to have Rust and WasmEdge installed](../setup.md).
Make sure that you read the [special notes on networking apps](../setup#special-notes) especially if you are compiling Rust programs on a Mac.
:::

## Run the example

The [wasmedge-db-example/postgres](https://github.com/WasmEdge/wasmedge-db-examples/tree/main/postgres) is a PostgreSQL connector example written in Rust.

```bash
git clone https://github.com/WasmEdge/wasmedge-db-examples
cd wasmedge-db-examples/postgres

# Compile the rust code into WASM
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release

# Execute SQL statements against a PostgreSQL database at postgres://user:passwd@localhost/testdb
wasmedge --env ""DATABASE_URL=postgres://user:passwd@localhost/testdb"" target/wasm32-wasi/release/crud.wasm
```

## Configuration

In order to compile the `tokio-postgres` and `tokio` crates, we will need to apply patches to add WasmEdge-specific socket APIs to those crates in `Cargo.toml`.

```
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }
socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }
tokio-postgres = { git = ""https://github.com/second-state/rust-postgres.git"" }

[dependencies]
tokio-postgres = ""0.7""
tokio = { version = ""1"", features = [
    ""io-util"",
    ""fs"",
    ""net"",
    ""time"",
    ""rt"",
    ""macros"",
] }
```

## Code explanation

We first use a Rust struct to represent the database table.

```rust
#[derive(Debug)]
struct Order {
    order_id: i32,
    production_id: i32,
    quantity: i32,
    amount: f32,
    shipping: f32,
    tax: f32,
    shipping_address: String,
}

impl Order {
    fn new(
        order_id: i32,
        production_id: i32,
        quantity: i32,
        amount: f32,
        shipping: f32,
        tax: f32,
        shipping_address: String,
    ) -> Self {
        Self {
            order_id,
            production_id,
            quantity,
            amount,
            shipping,
            tax,
            shipping_address,
        }
    }
}
```

Then, you can use the `tokio-postgres` API to access the database through its connection URL.
The code below shows how to perform basic CRUD operations using SQL commands.

```rust
#[tokio::main(flavor = ""current_thread"")]
async fn main() -> Result<(), Error> {
    // Connect to the database.
    let (client, connection) = tokio_postgres::connect(&*get_url(), NoTls).await?;

    // The connection object performs the actual communication with the database,
    // so spawn it off to run on its own.
    tokio::spawn(async move {
        if let Err(e) = connection.await {
            eprintln!(""connection error: {}"", e);
        }
    });

    client.execute(""CREATE TABLE IF NOT EXISTS orders (order_id INT, production_id INT, quantity INT, amount REAL, shipping REAL, tax REAL, shipping_address VARCHAR(256));"", &[]).await?;

    let orders = vec![
        Order::new(1, 12, 2, 56.0, 15.0, 2.0, String::from(""Mataderos 2312"")),
        Order::new(2, 15, 3, 256.0, 30.0, 16.0, String::from(""1234 NW Bobcat"")),
        Order::new(3, 11, 5, 536.0, 50.0, 24.0, String::from(""20 Havelock"")),
        Order::new(4, 8, 8, 126.0, 20.0, 12.0, String::from(""224 Pandan Loop"")),
        Order::new(5, 24, 1, 46.0, 10.0, 2.0, String::from(""No.10 Jalan Besar"")),
    ];

    for order in orders.iter() {
        client.execute(
            ""INSERT INTO orders (order_id, production_id, quantity, amount, shipping, tax, shipping_address) VALUES ($1, $2, $3, $4, $5, $6, $7)"",
            &[&order.order_id, &order.production_id, &order.quantity, &order.amount, &order.shipping, &order.tax, &order.shipping_address]
        ).await?;
    }

    let rows = client.query(""SELECT * FROM orders;"", &[]).await?;
    for row in rows.iter() {
        let order_id : i32 = row.get(0);
        println!(""order_id {}"", order_id);

        let production_id : i32 = row.get(1);
        println!(""production_id {}"", production_id);

        let quantity : i32 = row.get(2);
        println!(""quantity {}"", quantity);

        let amount : f32 = row.get(3);
        println!(""amount {}"", amount);

        let shipping : f32 = row.get(4);
        println!(""shipping {}"", shipping);

        let tax : f32 = row.get(5);
        println!(""tax {}"", tax);

        let shipping_address : &str = row.get(6);
        println!(""shipping_address {}"", shipping_address);
    }

    client.execute(""DELETE FROM orders;"", &[]).await?;

    Ok(())
}
```

","**Summary**

The provided code is a PostgreSQL driver for Rust developers, enabling them to build database applications in Rust and run them in WasmEdge. The code includes an example of how to perform basic CRUD operations using SQL commands.

**Key Components**

1. **Cargo.toml**: Configuration file that specifies dependencies and patches required for the project.
2. **Rust struct `Order`**: Represents a database table with fields for order information.
3. **`tokio-postgres` API**: Used to access the database through its connection URL.
4. **SQL commands**: Executed using the `tokio_postgres` API to perform CRUD operations on the database.

**Functionality**

The code demonstrates how to:

1. Connect to a PostgreSQL database using the `tokio-postgres` API.
2. Create a table in the database if it does not exist.
3. Insert data into the table.
4. Query the table and retrieve data.
5. Delete all records from the table.

**Potential Issues**

1. **Network dependencies**: The code requires WasmEdge and Rust to be installed, which may pose a challenge for users without these tools.
2. **Patching dependencies**: The `Cargo.toml` file specifies patches to add WasmEdge-specific socket APIs to certain crates. This may require manual intervention or custom configuration.
3. **Database connectivity**: The code assumes a PostgreSQL database is available and accessible. Users must ensure this is the case before running the example.

**Improvement Suggestions**

1. **Documentation**: Additional comments and documentation would improve readability and understanding of the code, especially for users unfamiliar with WasmEdge or Rust.
2. **Error handling**: Implement more robust error handling to handle potential issues such as database connection failures or invalid SQL queries.
3. **Security considerations**: Consider implementing security measures such as password protection or encryption to safeguard sensitive data stored in the database."
docs/start/wasmedge/features.md,"---
sidebar_position: 1
---

# WasmEdge Features

WasmEdge ([a sandbox project under CNCF](https://www.cncf.io/projects/wasmedge/)) is a safe, fast, lightweight, portable, and extensible WebAssembly runtime.

## High Performance

Taking advantage of [the LLVM-based AoT compiler](../build-and-run/aot), WasmEdge is the fastest WebAssembly runtime on the market.

- [A Lightweight Design for High-performance Serverless Computing](https://arxiv.org/abs/2010.07115), published on IEEE Software, Jan 2021. [https://arxiv.org/abs/2010.07115](https://arxiv.org/abs/2010.07115)
- [Performance Analysis for Arm vs. x86 CPUs in the Cloud](https://www.infoq.com/articles/arm-vs-x86-cloud-performance/), published on infoQ.com, Jan 2021. [https://www.infoq.com/articles/arm-vs-x86-cloud-performance/](https://www.infoq.com/articles/arm-vs-x86-cloud-performance/)
- [WasmEdge is the fastest WebAssembly Runtime in Suborbital Reactr test suite](https://blog.suborbital.dev/suborbital-wasmedge), Dec 2021

## Cloud-native Extensions

Besides WASI and the standard WebAssembly proposal, WasmEdge has some cloud-native extensions.

- Non-blocking network sockets and web services with Rust, C, and JavaScript SDK
- MySQL-based database driver
- Key value store
- Gas meter for resource limitation
- WasmEdge-bindgen for complex para passing
- AI inference with TensorFlow, TensorFlow Lite, Pytorch, and OpenVINO

## JavaScript Support

Through the [WasmEdge-Quickjs](https://github.com/second-state/wasmedge-quickjs) project, WasmEdge could run a JavaScript program, lowering the bar for developing a WASM app.

- ES6 module and std API support
- NPM module support
- Native JS API in Rust
- Node.js API Support
- Async networking
- Fetch API
- React SSR

## Cloud Native orchestration

WasmEdge could be seamlessly integrated with the existing cloud-native infra.

To integrate WasmEdge with your existing cloud-native infrastructure, there are several options available for managing WASM applications as ""containers"" under Kubernetes. These options enable you to run Linux containers and WASM containers side by side within a Kubernetes cluster.

**Option #1:** is to [use an OCI runtime crun](../../develop/deploy/oci-runtime/crun.md) (the C version of runc — mainly supported by Red Hat). crun decides whether an OCI image is WASM or Linux based on image annotations. If the image is annotated as wasm32, crun will bypass the Linux container setup and just use WasmEdge to run the image. By using crun, you can get the entire Kubernetes stack - including CRI-O, containerd, Podman, kind, micro k8s, and k8s - to work with WASM images.

Option #2 is to [use a containerd-shim to start WASM ""containers"" via runwasi](../../develop/deploy/cri-runtime/containerd.md). Basically, containerd could look at the image's target platform. It uses runwasi if the image is wasm32 and runc if it is x86 / arm. This is the approach used by Docker + Wasm.

## Cross Platform

WASM is Portable. The compiled WASM file could run on different hardware and platforms without any changes.

WasmEdge supports a wide range of operating systems and hardware platforms. It allows WebAssembly applications to be truly portable across platforms. It runs on Linux-like systems and microkernels such as the `seL4` real-time system.

WasmEdge now supports:

- [Linux (x86_64 and aarch64)](../../contribute/source/os/linux.md)
- [MacOS (x86_64 and M1)](../../contribute/source/os/macos.md)
- [Windows 10](../../contribute/source/os/windows.md)
- [Android](/category/build-and-run-wasmedge-on-android)
- [seL4 RTOS](../../contribute/source/os/sel4.md)
- [OpenWrt](../../contribute/source/os/openwrt.md)
- [OpenHarmony](../../contribute/source/os/openharmony.md)
- [Raspberry Pi](../../contribute/source/os/raspberrypi.md)
- [RISC-V (WIP)](../../contribute/source/os/riscv64.md)

## Easy extensible

It is easy to build customized WasmEdge runtime with native host functions in C, Go, and Rust.

Or you could build your own plug-ins for WasmEdge in

- [Rust](../../contribute/plugin/develop_plugin_rustsdk)
- [C](../../contribute/plugin/develop_plugin_c)
- [C++](../../contribute/plugin/develop_plugin_cpp)

## Easy to Embed into a Host Application

[Embedded runtime](https://wasmedge.org/docs/embed/overview) is the classical use case for WasmEdge. You could embed WasmEdge functions in C, Go, Rust, Node.js, Java (WIP), and Python (WIP) host applications.
","**Summary**

WasmEdge is a WebAssembly runtime that offers high performance, cloud-native extensions, JavaScript support, and cross-platform compatibility. It is designed to be safe, fast, lightweight, portable, and extensible.

**Key Features**

1. **High Performance**: WasmEdge takes advantage of an LLVM-based Ahead-of-Time (AoT) compiler, making it one of the fastest WebAssembly runtimes available.
2. **Cloud-Native Extensions**: WasmEdge provides non-blocking network sockets, a MySQL-based database driver, and key-value store functionality, among others.
3. **JavaScript Support**: Through the WasmEdge-Quickjs project, WasmEdge can execute JavaScript programs, making it easier to develop WASM applications.
4. **Cross-Platform Compatibility**: WasmEdge supports a wide range of operating systems, including Linux, macOS, Windows 10, Android, and seL4 RTOS.
5. **Easy Extensibility**: Developers can build customized runtime environments with native host functions in C, Go, or Rust, or create their own plug-ins using Rust, C, or C++.

**Areas for Improvement**

1. **Documentation**: While the documentation is extensive, it could benefit from better organization and clear, concise language.
2. **Community Engagement**: As a relatively new project, WasmEdge may struggle to establish a strong community presence, which can be essential for long-term success.
3. **Compatibility Issues**: Although WasmEdge supports multiple platforms, there may still be compatibility issues with certain versions of operating systems or hardware configurations.

**Code Quality**

The code quality appears to be good overall, with clear and concise comments, proper documentation, and a well-structured project structure. However, there may be some areas where refactoring could improve the maintainability and readability of the code."
docs/embed/use-case/wasm-nginx.md,"---
sidebar_position: 3
---

# wasm-nginx-module

The wasm-nginx-module is an Nginx module built upon OpenResty. By implementing the [Proxy-WASM ABI](https://github.com/proxy-wasm/spec), any WASM program written with Proxy WASM SDK can be run inside it. Hence, you can write Go or Rust code, compile them into Wasm, then load & execute it in Nginx.

> The wasm-nginx-module is already used in APISIX and allows it to [run WASM plugin like Lua plugin](https://github.com/apache/apisix/blob/master/docs/en/latest/wasm.md).

To follow along the tutorials in this chapter, you will need to first [build your Nginx with wasm-nginx-module included and WasmEdge shared library installed in the right path](https://github.com/api7/wasm-nginx-module#install-dependencies).

Once you have Nginx installed, let me show you a real-world example - using WASM to inject custom responses in Nginx.

## Inject Custom Response via Go in Nginx, Step by Step

### Go Step 1: Write code based on proxy-wasm-go-sdk

The implementation code (including `go.mod` and others) can be found [here](https://github.com/apache/apisix/tree/master/t/wasm).

It should be explained that although the proxy-wasm-go-sdk project carries the Go name, it actually uses tinygo instead of native Go, which has some problems supporting WASI (which you can think of as a non-browser WASM runtime interface). See [here](https://github.com/tetratelabs/proxy-wasm-go-sdk/blob/main/doc/OVERVIEW.md#tinygo-vs-the-official-go-compiler) for more details.

We also provide a Rust version (including Cargo.toml and others) [there](https://github.com/api7/wasm-nginx-module/tree/main/t/testdata/rust/fault-injection).

### Go Step 2: Build the corresponding WASM file

```shell
tinygo build -o ./fault-injection/main.go.wasm -scheduler=none -target=wasi ./fault-injection/main.go
```

### Go Step 3: Load and execute the WASM file

Then, start Nginx with the configuration below:

```conf
worker_processes  1;

error_log  /tmp/error.log warn;

events {
    worker_connections  10240;
}

http {
    wasm_vm wasmedge;
    init_by_lua_block {
        local wasm = require(""resty.proxy-wasm"")
        package.loaded.plugin = assert(wasm.load(""fault_injection"",
            ""/path/to/fault-injection/main.go.wasm""))
    }
    server {
        listen 1980;
        location / {
            content_by_lua_block {
                local wasm = require(""resty.proxy-wasm"")
                local ctx = assert(wasm.on_configure(package.loaded.plugin,
                    '{""http_status"": 403, ""body"": ""powered by wasm-nginx-module""}'))
                assert(wasm.on_http_request_headers(ctx))
            }
        }
    }
}
```

This configuration loads the WASM file we just built, and executes it with the configuration `{""http_status"": 403, ""body"": ""powered by wasm-nginx-module""}`.

### Go Step 4: Verify the Result

After Nginx starts, we can use `curl http://127.0.0.1:1980/ -i` to verify the execution result of the Wasm.

It is expected to see the output:

```bash
HTTP/1.1 403 Forbidden
...

powered by wasm-nginx-module
```

## Inject Custom Response via Rust in Nginx, Step by Step

### Rust Step 1: Write code based on proxy-wasm-rust-sdk

We also provide a Rust version (including Cargo.toml and others) [here](https://github.com/api7/wasm-nginx-module/tree/main/t/testdata/rust/fault-injection).

### Rust Step 2: Build the corresponding WASM file

```shell
cargo build --target=wasm32-wasi
```

### Rust Step 3: Load and execute the WASM file

Then, start Nginx with the configuration below:

```conf
worker_processes  1;

error_log  /tmp/error.log warn;

events {
    worker_connections  10240;
}

http {
    wasm_vm wasmedge;
    init_by_lua_block {
        local wasm = require(""resty.proxy-wasm"")
        package.loaded.plugin = assert(wasm.load(""fault_injection"",
            ""/path/to/fault-injection/target/wasm32-wasi/debug/fault_injection.wasm""))
    }
    server {
        listen 1980;
        location / {
            content_by_lua_block {
                local wasm = require(""resty.proxy-wasm"")
                local ctx = assert(wasm.on_configure(package.loaded.plugin,
                    '{""http_status"": 403, ""body"": ""powered by wasm-nginx-module""}'))
                assert(wasm.on_http_request_headers(ctx))
            }
        }
    }
}
```

This configuration loads the WASM file we just built, executes it with the configuration `{""http_status"": 403, ""body"": ""powered by wasm-nginx-module""}`.

### Rust Step 4: verify the result

After Nginx starts, we can use `curl http://127.0.0.1:1980/ -i` to verify the execution result of the Wasm.

It is expected to see the output:

```bash
HTTP/1.1 403 Forbidden
...

powered by wasm-nginx-module
```
","**Summary**

The provided code is an example of using the wasm-nginx-module to inject custom responses in Nginx. The module allows users to write Go or Rust code, compile it into WASM, and load & execute it in Nginx using the Proxy-WASM ABI.

**Key Components**

* `wasm-nginx-module`: An Nginx module built upon OpenResty that enables the execution of WASM programs.
* `proxy-wasm-go-sdk` (Go version) and `proxy-wasm-rust-sdk` (Rust version): SDKs for writing WASM code in Go and Rust, respectively.
* `tinygo`: A compiler used to build the Go WASM file.
* `Cargo.toml`: The build configuration file for the Rust project.

**Functionality**

The example demonstrates how to:

1. Write a WASM program using Go or Rust and compile it into a WASM file.
2. Load and execute the WASM file in Nginx using the `wasm-nginx-module`.
3. Configure Nginx to inject custom responses based on the executed Wasm code.

**Steps**

The example includes step-by-step instructions for:

1. Writing and building the Go or Rust WASM program.
2. Loading and executing the WASM file in Nginx.
3. Verifying the execution result using `curl`.

**Potential Issues**

* The use of `tinygo` to compile the Go WASM file may have some limitations, as mentioned in the documentation.
* The configuration files (e.g., `nginx.conf`) should be carefully reviewed and customized according to specific requirements.

Overall, this example demonstrates how the wasm-nginx-module can be used to inject custom responses in Nginx using WASM programs written in Go or Rust."
i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/wasm-nginx.md,"---
sidebar_position: 3
---

# wasm-nginx-module

The wasm-nginx-module is an Nginx module built upon OpenResty. By implementing the [Proxy-WASM ABI](https://github.com/proxy-wasm/spec), any WASM program written with Proxy WASM SDK can be run inside it. Hence, you can write Go or Rust code, compile them into Wasm, then load & execute it in Nginx.

> The wasm-nginx-module is already used in APISIX and allows it to [run WASM plugin like Lua plugin](https://github.com/apache/apisix/blob/master/docs/en/latest/wasm.md).

To follow along the tutorials in this chapter, you will need to first [build your Nginx with wasm-nginx-module included and WasmEdge shared library installed in the right path](https://github.com/api7/wasm-nginx-module#install-dependencies).

Once you have Nginx installed, let me show you a real-world example - using WASM to inject custom responses in Nginx.

## Inject Custom Response via Go in Nginx, Step by Step

### Go Step 1: Write code based on proxy-wasm-go-sdk

The implementation code (including `go.mod` and others) can be found [here](https://github.com/apache/apisix/tree/master/t/wasm).

It should be explained that although the proxy-wasm-go-sdk project carries the Go name, it actually uses tinygo instead of native Go, which has some problems supporting WASI (which you can think of as a non-browser WASM runtime interface). See [here](https://github.com/tetratelabs/proxy-wasm-go-sdk/blob/main/doc/OVERVIEW.md#tinygo-vs-the-official-go-compiler) for more details.

We also provide a Rust version (including Cargo.toml and others) [there](https://github.com/api7/wasm-nginx-module/tree/main/t/testdata/rust/fault-injection).

### Go Step 2: Build the corresponding WASM file

```shell
tinygo build -o ./fault-injection/main.go.wasm -scheduler=none -target=wasi ./fault-injection/main.go
```

### Go Step 3: Load and execute the WASM file

Then, start Nginx with the configuration below:

```conf
worker_processes  1;

error_log  /tmp/error.log warn;

events {
    worker_connections  10240;
}

http {
    wasm_vm wasmedge;
    init_by_lua_block {
        local wasm = require(""resty.proxy-wasm"")
        package.loaded.plugin = assert(wasm.load(""fault_injection"",
            ""/path/to/fault-injection/main.go.wasm""))
    }
    server {
        listen 1980;
        location / {
            content_by_lua_block {
                local wasm = require(""resty.proxy-wasm"")
                local ctx = assert(wasm.on_configure(package.loaded.plugin,
                    '{""http_status"": 403, ""body"": ""powered by wasm-nginx-module""}'))
                assert(wasm.on_http_request_headers(ctx))
            }
        }
    }
}
```

This configuration loads the WASM file we just built, and executes it with the configuration `{""http_status"": 403, ""body"": ""powered by wasm-nginx-module""}`.

### Go Step 4: Verify the Result

After Nginx starts, we can use `curl http://127.0.0.1:1980/ -i` to verify the execution result of the Wasm.

It is expected to see the output:

```bash
HTTP/1.1 403 Forbidden
...

powered by wasm-nginx-module
```

## Inject Custom Response via Rust in Nginx, Step by Step

### Rust Step 1: Write code based on proxy-wasm-rust-sdk

We also provide a Rust version (including Cargo.toml and others) [here](https://github.com/api7/wasm-nginx-module/tree/main/t/testdata/rust/fault-injection).

### Rust Step 2: Build the corresponding WASM file

```shell
cargo build --target=wasm32-wasi
```

### Rust Step 3: Load and execute the WASM file

Then, start Nginx with the configuration below:

```conf
worker_processes  1;

error_log  /tmp/error.log warn;

events {
    worker_connections  10240;
}

http {
    wasm_vm wasmedge;
    init_by_lua_block {
        local wasm = require(""resty.proxy-wasm"")
        package.loaded.plugin = assert(wasm.load(""fault_injection"",
            ""/path/to/fault-injection/target/wasm32-wasi/debug/fault_injection.wasm""))
    }
    server {
        listen 1980;
        location / {
            content_by_lua_block {
                local wasm = require(""resty.proxy-wasm"")
                local ctx = assert(wasm.on_configure(package.loaded.plugin,
                    '{""http_status"": 403, ""body"": ""powered by wasm-nginx-module""}'))
                assert(wasm.on_http_request_headers(ctx))
            }
        }
    }
}
```

This configuration loads the WASM file we just built, executes it with the configuration `{""http_status"": 403, ""body"": ""powered by wasm-nginx-module""}`.

### Rust Step 4: verify the result

After Nginx starts, we can use `curl http://127.0.0.1:1980/ -i` to verify the execution result of the Wasm.

It is expected to see the output:

```bash
HTTP/1.1 403 Forbidden
...

powered by wasm-nginx-module
```
","**Summary**

This documentation provides an example of using the `wasm-nginx-module` to inject custom responses in Nginx using Go and Rust. The module allows running WASM programs written with Proxy WASM SDK inside Nginx, enabling the execution of custom code in response to HTTP requests.

**Key Components**

1. **Proxy-WASM ABI**: An interface for interacting with WASM programs.
2. **wasm-nginx-module**: An Nginx module that enables running WASM programs inside Nginx.
3. **Go and Rust SDKs**: Toolkits for developing WASM programs using Go and Rust, respectively.

**Steps**

The example consists of four steps:

1. **Write code**: Write a WASM program in either Go or Rust using the respective SDK.
2. **Build the WASM file**: Compile the WASM program into a WASM file using `tinygo` for Go or `cargo build` for Rust.
3. **Load and execute the WASM file**: Load the WASM file inside Nginx using the `wasm-nginx-module`.
4. **Verify the result**: Test the execution of the Wasm by making an HTTP request to the Nginx server.

**Potential Issues**

1. **WASI compatibility**: The example uses TinyGo, which may have issues with WASI (WebAssembly System Interface), a non-browser WASM runtime interface.
2. **Nginx configuration**: The example assumes a specific Nginx configuration, which may need to be adapted for different environments.

**Improvement Suggestions**

1. **Use native Go compiler**: Instead of TinyGo, use the official Go compiler to avoid potential issues with WASI compatibility.
2. **Provide more detailed configuration instructions**: Add more information on configuring Nginx and the `wasm-nginx-module` for specific use cases."
docs/contribute/source/os/android/build.md,"---
sidebar_position: 1
---

# Build WasmEdge for Android

The WasmEdge Runtime releases come with pre-built binaries for the Android OS. Why WasmEdge on Android?

- Native speed & sandbox safety for Android apps
- Support multiple dev languages — eg C, [Rust](/category/develop-wasm-apps-in-rust), [Go](../../../../category/develop-wasm-apps-in-go) & [JS](../../../../category/develop-wasm-apps-in-javascript)
- [Embed 3rd party functions](../../../../embed/overview.md) in your android app
- [Kubernetes managed](../../../../category/deploy-wasmedge-apps-in-kubernetes) android apps

However, the WasmEdge installer does not support Android. The user must download the release files to a computer, and then use the `adb` tool to transfer the files to an Android device or simulator. We will show you how to do that.

- [WasmEdge CLI tools for Android](./cli.md)
- [Call WasmEdge functions from an NDK native app](./ndk.md)
- [Call WasmEdge functions from an Android APK app](./apk.md)

## Build from source for Android platforms

Please follow this guide to build and test WasmEdge from source code with Android NDK.

<!-- prettier-ignore -->
:::note
In current state, we only support the runtime for the interpreter mode.
:::

## Prepare the Environment

We recommend developers to [use our Docker images](../linux.md##prepare-the-environment) and follow the steps to prepare the building environment.

- Download and extract the [Android NDK 23b](https://developer.android.com/ndk/downloads).
- Check the cmake for [CMake 3.21](https://cmake.org/download/) or greater version.
- Download and install the [ADB platform tools](https://developer.android.com/studio/releases/platform-tools).
  - If you use the debian or ubuntu Linux distributions, you can install the ADB platform tools via `apt`.
- An Android device which is [enabled developer options and USB debugging](https://developer.android.com/studio/debug/dev-options) and with at least Android 6.0 or higher system version.

## Build WasmEdge for Android platforms

Get the WasmEdge source code.

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
```

Add the Android NDK path into the environment variable.

```bash
export ANDROID_NDK_HOME=path/to/you/ndk/dir
```

Run the build script in WasmEdge source code. This script will automatically build the WasmEdge for Android, and the results are in the `build` folder.

```bash
./utils/android/standalone/build_for_android.sh
```

## Test the WasmEdge CLI on Android platforms

### Push the WasmEdge CLI and related test data onto Android platforms

1. Connect the device by using a USB cable or Wi-Fi. Then you can check the attached devices via the `adb devices` command.

   ```bash
   $ adb devices
   List of devices attached
   0a388e93      device
   ```

2. Use the `adb push` command to push the entire `build/tools/wasmedge` folder into the `/data/local/tmp` folder on your Android device.

   ```bash
   cp -r examples build/tools/wasmedge/examples
   cd build
   adb push ./tools/wasmedge /data/local/tmp
   ```

### Run WasmEdge CLI on Android platforms

1. Please use the `adb shell` command to access into the Android device.
2. Follow the steps to test the WasmEdge CLI on the Android device.

```bash
$ cd /data/local/tmp/wasmedge/examples
$ ../wasmedge hello.wasm 1 2 3
hello
1
2
3

$ ../wasmedge --reactor add.wasm add 2 2
4

$ ../wasmedge --reactor fibonacci.wasm fib 8
34

$ ../wasmedge --reactor factorial.wasm fac 12
479001600

$ cd js
$ ./../wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3
```

## Notice

- For the Android 10 or greater versions, SELinux will disallow the untrusted applications' `exec()` system call to execute the binaries in `home` or `/data/local/tmp` folder.
- The Android SELinux policy will disallow the untrusted applications to access the `/data/local/tmp` folder.
","**Summary**

The provided code is a guide on how to build and test the WasmEdge Runtime for Android platforms from source code. It assumes that the user has already downloaded and extracted the Android NDK 23b, installed CMake 3.21 or greater, and set up an Android device with at least Android 6.0 or higher system version.

**Key Components**

1. **Prepare Environment**: The guide provides instructions on how to prepare the building environment using Docker images or by setting up the necessary tools (e.g., Android NDK, CMake, ADB platform tools) manually.
2. **Build WasmEdge for Android Platforms**: The user is directed to clone the WasmEdge source code repository and run a build script (`build_for_android.sh`) to generate the WasmEdge binary for Android.
3. **Test WasmEdge CLI on Android Platforms**: The guide provides instructions on how to push the WasmEdge CLI and test data onto an Android device using ADB, and then run tests on the device.

**Potential Issues or Areas for Improvement**

1. **SELinux Restrictions**: The guide mentions that SELinux may disallow the untrusted applications' `exec()` system call to execute binaries in certain folders (e.g., `/data/local/tmp`), which might require additional configuration or exemptions.
2. **ADB Push and Test Data**: The guide assumes that users have already set up ADB and can push files onto their Android device using `adb push`. However, this may not be the case for all users, especially those who are new to Android development.
3. **Error Handling**: The guide does not provide any error handling or troubleshooting steps in case of build or test failures.

**Recommendations**

1. Add more detailed instructions on how to set up ADB and push files onto an Android device.
2. Provide additional guidance on configuring SELinux exemptions for untrusted applications.
3. Incorporate error handling and troubleshooting steps into the guide.
4. Consider adding more information on debugging and logging tools that can be used with WasmEdge on Android platforms."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/android/build.md,"---
sidebar_position: 1
---

# Build WasmEdge for Android

The WasmEdge Runtime releases come with pre-built binaries for the Android OS. Why WasmEdge on Android?

- Native speed & sandbox safety for Android apps
- Support multiple dev languages — eg C, [Rust](/category/develop-wasm-apps-in-rust), [Go](../../../../category/develop-wasm-apps-in-go) & [JS](../../../../category/develop-wasm-apps-in-javascript)
- [Embed 3rd party functions](../../../../embed/overview.md) in your android app
- [Kubernetes managed](../../../../category/deploy-wasmedge-apps-in-kubernetes) android apps

However, the WasmEdge installer does not support Android. The user must download the release files to a computer, and then use the `adb` tool to transfer the files to an Android device or simulator. We will show you how to do that.

- [WasmEdge CLI tools for Android](./cli.md)
- [Call WasmEdge functions from an NDK native app](./ndk.md)
- [Call WasmEdge functions from an Android APK app](./apk.md)

## Build from source for Android platforms

Please follow this guide to build and test WasmEdge from source code with Android NDK.

<!-- prettier-ignore -->
:::note
In current state, we only support the runtime for the interpreter mode.
:::

## Prepare the Environment

We recommend developers to [use our Docker images](../linux.md##prepare-the-environment) and follow the steps to prepare the building environment.

- Download and extract the [Android NDK 23b](https://developer.android.com/ndk/downloads).
- Check the cmake for [CMake 3.21](https://cmake.org/download/) or greater version.
- Download and install the [ADB platform tools](https://developer.android.com/studio/releases/platform-tools).
  - If you use the debian or ubuntu Linux distributions, you can install the ADB platform tools via `apt`.
- An Android device which is [enabled developer options and USB debugging](https://developer.android.com/studio/debug/dev-options) and with at least Android 6.0 or higher system version.

## Build WasmEdge for Android platforms

Get the WasmEdge source code.

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
```

Add the Android NDK path into the environment variable.

```bash
export ANDROID_NDK_HOME=path/to/you/ndk/dir
```

Run the build script in WasmEdge source code. This script will automatically build the WasmEdge for Android, and the results are in the `build` folder.

```bash
./utils/android/standalone/build_for_android.sh
```

## Test the WasmEdge CLI on Android platforms

### Push the WasmEdge CLI and related test data onto Android platforms

1. Connect the device by using a USB cable or Wi-Fi. Then you can check the attached devices via the `adb devices` command.

   ```bash
   $ adb devices
   List of devices attached
   0a388e93      device
   ```

2. Use the `adb push` command to push the entire `build/tools/wasmedge` folder into the `/data/local/tmp` folder on your Android device.

   ```bash
   cp -r examples build/tools/wasmedge/examples
   cd build
   adb push ./tools/wasmedge /data/local/tmp
   ```

### Run WasmEdge CLI on Android platforms

1. Please use the `adb shell` command to access into the Android device.
2. Follow the steps to test the WasmEdge CLI on the Android device.

```bash
$ cd /data/local/tmp/wasmedge/examples
$ ../wasmedge hello.wasm 1 2 3
hello
1
2
3

$ ../wasmedge --reactor add.wasm add 2 2
4

$ ../wasmedge --reactor fibonacci.wasm fib 8
34

$ ../wasmedge --reactor factorial.wasm fac 12
479001600

$ cd js
$ ./../wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3
```

## Notice

- For the Android 10 or greater versions, SELinux will disallow the untrusted applications' `exec()` system call to execute the binaries in `home` or `/data/local/tmp` folder.
- The Android SELinux policy will disallow the untrusted applications to access the `/data/local/tmp` folder.
","**Summary:**

This is a documentation for building and testing WasmEdge on Android platforms. The guide explains how to prepare the environment, build WasmEdge from source code with Android NDK, and test it on an Android device or emulator.

**Key Components:**

1. **Environment Preparation**: Download and extract the Android NDK 23b, check for CMake 3.21 or greater version, install ADB platform tools, and set up an Android device.
2. **Building WasmEdge**: Clone the WasmEdge repository, add the Android NDK path to environment variables, and run a build script to generate binaries in the `build` folder.
3. **Testing WasmEdge CLI on Android**: Push the generated binaries onto the Android device using ADB, connect to the device via USB or Wi-Fi, and test the WasmEdge CLI.

**Potential Issues:**

1. **SELinux restrictions**: On Android 10 or greater versions, SELinux may disallow untrusted applications from executing binaries in `/data/local/tmp` folder.
2. **Android version limitations**: The guide assumes a minimum Android system version of 6.0, which might not be compatible with newer Android versions.

**Areas for Improvement:**

1. **Documentation updates**: Update the documentation to reflect changes in WasmEdge repository structure or build process.
2. **Error handling**: Implement error handling and logging mechanisms to make it easier to diagnose and fix issues during the building and testing process.
3. **Cross-platform compatibility**: Investigate ways to improve cross-platform compatibility for WasmEdge on different Android versions and devices."
docs/develop/deploy/kubernetes/kind.md,"---
sidebar_position: 7
---

# Kind

KinD is a Kubernetes distribution that runs inside Docker and is well-suited for local development or integration testing. It runs containerd as CRI and crun as OCI Runtime.

<!-- prettier-ignore -->
:::note
This demo is based on containerd + crun.
:::

## Quick start

As a prerequisite, we need to install KinD first. To do that, the [quick start guide](https://kind.sigs.k8s.io/docs/user/quick-start/#installing-from-release-binaries) and the [release page](https://github.com/kubernetes-sigs/kind/releases) can be used to install the latest version of the KinD CLI.

If KinD is installed, we can directly start with the example from [here](https://github.com/Liquid-Reply/kind-crun-wasm):

```bash
# Create a ""WASM in KinD"" Cluster
kind create cluster --image ghcr.io/liquid-reply/kind-crun-wasm:v1.23.0
# Run the example
kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" /wasi_example_main.wasm 50000000
```

In the rest of this section, we will explain how to create a KinD node image with wasmedge support.

## Build crun

KinD uses the `kindest/node` image for the control plane and worker nodes. The image contains containerd as CRI and runc as OCI Runtime. To enable WasmEdge support, we replace `runc` with `crun`.

We only need the crun binary for the node image and not the entire build toolchain. Therefore we use a multistage dockerfile where we create crun in the first step and only copy the crun binary to the node image.

```Dockerfile
FROM ubuntu:21.10 AS builder
WORKDIR /data
RUN DEBIAN_FRONTEND=noninteractive apt update \
    && DEBIAN_FRONTEND=noninteractive apt install -y curl make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake \
    && curl https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local \
    && git clone --single-branch --branch feat/handler_per_container https://github.com/liquid-reply/crun \
    && cd crun \
    && ./autogen.sh \
    && ./configure --with-wasmedge --enable-embedded-yajl\
    && make

...
```

Now we have a fresh `crun` binary with wasmedge enabled under `/data/crun/crun` that we can copy from this container in the next step.

## Replace crun and configure containerd

Both runc and crun implement the OCI runtime spec and have the same CLI parameters. Therefore we can replace the runc binary with our crun-wasmedge binary we created before.

Since crun is using shared libraries we need to install libyajl, wasmedge and criu to make our crun work.

Now we have a KinD that uses crun instead of runc. Now we need two config changes. The first one is in the `/etc/containerd/config.toml` where we add the `pod_annotations`that can be passed to the runtime:

```toml
[plugins.""io.containerd.grpc.v1.cri"".containerd.runtimes.runc]
  pod_annotations = [""*.wasm.*"", ""wasm.*"", ""module.wasm.image/*"", ""*.module.wasm.image"", ""module.wasm.image/variant.*""]
```

And the second one to the `/etc/containerd/cri-base.json` where we remove a hook that causes some issues.

The resulting dockerfile looks as follows:

```Dockerfile
...

FROM kindest/node:v1.23.0

COPY config.toml /etc/containerd/config.toml
COPY --from=builder /data/crun/crun /usr/local/sbin/runc
COPY --from=builder /usr/local/lib/libwasmedge.so /usr/local/lib/libwasmedge.so

RUN echo ""Installing Packages ..."" \
    && bash -c 'cat <<< $(jq ""del(.hooks.createContainer)"" /etc/containerd/cri-base.json) > /etc/containerd/cri-base.json' \
    && ldconfig
```

## Build and test

Finally, we can build a new `node-wasmedge` image. We create a kind cluster from that image and run the simple app example to test it.

```bash
docker build -t node-wasmedge .
kind create cluster --image node-wasmedge
# Now you can run the example to validate your cluster
kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" /wasi_example_main.wasm 50000000
```
","**Summary**

This document describes how to create a custom KinD (Kubernetes-in-Docker) cluster that runs containerd as CRI and crun as OCI Runtime with wasmedge support. The process involves:

1. Installing KinD
2. Creating a node image with crun and wasmedge support using a multistage Dockerfile
3. Replacing runc with crun in the node image
4. Configuring containerd to use crun
5. Building and testing the custom node-wasmedge image

**Key Components**

1. KinD: A Kubernetes distribution that runs inside Docker.
2. Containerd: A container runtime that implements the CRI (Container Runtime Interface).
3. Crun: A lightweight OCI runtime that supports wasmedge.
4. Wasmedge: A WebAssembly runtime for Linux.
5. Dockerfile: A script used to build a Docker image.

**Potential Issues and Areas for Improvement**

1. **Security**: The document uses `DEBIAN_FRONTEND=noninteractive` which may not be secure in certain environments.
2. **Compatibility**: The crun version used in this example might not be compatible with future versions of KinD or containerd.
3. **Performance**: Using a multistage Dockerfile can lead to performance issues if the intermediate stages are large.
4. **Testing**: The document only tests a simple app example, more comprehensive testing should be done before deploying to production.

**Best Practices**

1. Use `docker build --no-cache` to prevent building unnecessary cache layers.
2. Consider using a Docker image like `ubuntu:20.04` instead of `ubuntu:21.10` for better compatibility.
3. Always test and validate the custom node-wasmedge image before deploying it in production.
4. Follow secure practices when running containers, such as disabling root privileges and limiting container privileges."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kind.md,"---
sidebar_position: 7
---

# Kind

KinD is a Kubernetes distribution that runs inside Docker and is well-suited for local development or integration testing. It runs containerd as CRI and crun as OCI Runtime.

<!-- prettier-ignore -->
:::note
This demo is based on containerd + crun.
:::

## Quick start

As a prerequisite, we need to install KinD first. To do that, the [quick start guide](https://kind.sigs.k8s.io/docs/user/quick-start/#installing-from-release-binaries) and the [release page](https://github.com/kubernetes-sigs/kind/releases) can be used to install the latest version of the KinD CLI.

If KinD is installed, we can directly start with the example from [here](https://github.com/Liquid-Reply/kind-crun-wasm):

```bash
# Create a ""WASM in KinD"" Cluster
kind create cluster --image ghcr.io/liquid-reply/kind-crun-wasm:v1.23.0
# Run the example
kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" /wasi_example_main.wasm 50000000
```

In the rest of this section, we will explain how to create a KinD node image with wasmedge support.

## Build crun

KinD uses the `kindest/node` image for the control plane and worker nodes. The image contains containerd as CRI and runc as OCI Runtime. To enable WasmEdge support, we replace `runc` with `crun`.

We only need the crun binary for the node image and not the entire build toolchain. Therefore we use a multistage dockerfile where we create crun in the first step and only copy the crun binary to the node image.

```Dockerfile
FROM ubuntu:21.10 AS builder
WORKDIR /data
RUN DEBIAN_FRONTEND=noninteractive apt update \
    && DEBIAN_FRONTEND=noninteractive apt install -y curl make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake \
    && curl https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local \
    && git clone --single-branch --branch feat/handler_per_container https://github.com/liquid-reply/crun \
    && cd crun \
    && ./autogen.sh \
    && ./configure --with-wasmedge --enable-embedded-yajl\
    && make

...
```

Now we have a fresh `crun` binary with wasmedge enabled under `/data/crun/crun` that we can copy from this container in the next step.

## Replace crun and configure containerd

Both runc and crun implement the OCI runtime spec and have the same CLI parameters. Therefore we can replace the runc binary with our crun-wasmedge binary we created before.

Since crun is using shared libraries we need to install libyajl, wasmedge and criu to make our crun work.

Now we have a KinD that uses crun instead of runc. Now we need two config changes. The first one is in the `/etc/containerd/config.toml` where we add the `pod_annotations`that can be passed to the runtime:

```toml
[plugins.""io.containerd.grpc.v1.cri"".containerd.runtimes.runc]
  pod_annotations = [""*.wasm.*"", ""wasm.*"", ""module.wasm.image/*"", ""*.module.wasm.image"", ""module.wasm.image/variant.*""]
```

And the second one to the `/etc/containerd/cri-base.json` where we remove a hook that causes some issues.

The resulting dockerfile looks as follows:

```Dockerfile
...

FROM kindest/node:v1.23.0

COPY config.toml /etc/containerd/config.toml
COPY --from=builder /data/crun/crun /usr/local/sbin/runc
COPY --from=builder /usr/local/lib/libwasmedge.so /usr/local/lib/libwasmedge.so

RUN echo ""Installing Packages ..."" \
    && bash -c 'cat <<< $(jq ""del(.hooks.createContainer)"" /etc/containerd/cri-base.json) > /etc/containerd/cri-base.json' \
    && ldconfig
```

## Build and test

Finally, we can build a new `node-wasmedge` image. We create a kind cluster from that image and run the simple app example to test it.

```bash
docker build -t node-wasmedge .
kind create cluster --image node-wasmedge
# Now you can run the example to validate your cluster
kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" /wasi_example_main.wasm 50000000
```
","**Summary**

This document provides a guide on how to create a KinD (Kubernetes in Docker) cluster with WasmEdge support. The guide assumes that the reader has basic knowledge of Kubernetes and Docker. It covers the following steps:

1. **Quick start**: Installs KinD using the quick-start guide.
2. **Build crun**: Builds a custom `crun` binary with WasmEdge support.
3. **Replace runc and configure containerd**: Replaces the `runc` binary with the custom `crun` binary and configures containerd to use it.
4. **Build and test**: Builds a new `node-wasmedge` image, creates a Kind cluster from it, and runs a simple app example to validate the cluster.

**Key components**

* KinD (Kubernetes in Docker)
* WasmEdge
* crun
* containerd

**Potential issues or areas for improvement**

1. **Security**: The guide assumes that the reader has basic knowledge of Kubernetes and Docker security best practices.
2. **Compatibility**: The guide uses KinD version v1.23.0, which might not be compatible with all versions of WasmEdge.
3. **Performance**: The guide does not provide any optimization techniques for performance improvement.
4. **Error handling**: The guide assumes that the reader can handle errors and exceptions properly.

**Recommendations**

1. **Use a CI/CD pipeline**: Create a Continuous Integration and Continuous Deployment (CI/CD) pipeline to automate the build, test, and deployment process.
2. **Monitor performance**: Monitor the performance of the Kind cluster and optimize it as needed.
3. **Test for security vulnerabilities**: Test the Kind cluster for security vulnerabilities and fix them promptly.
4. **Document the process**: Document the entire process, including any assumptions, potential issues, or areas for improvement."
docs/develop/rust/wasinn/mediapipe.md,"---
sidebar_position: 2
---

# Mediapipe solutions

Mediapipe is a collection of highly popular AI models developed by Google. They focus on intelligent processing of media files and streams. The `mediapipe-rs` crate is a Rust library for data processing using the Mediapipe suite of models. The crate provides Rust APIs to pre-process the data in media files or streams, run AI model inference to analyze the data, and then post-process or manipulate the media data based on the AI output.

## Prerequisite

Besides the [regular WasmEdge and Rust requirements](../../rust/setup.md), please make sure that you have the [WASI-NN plugin with TensorFlow Lite installed](../../../start/install.md#wasi-nn-plug-in-with-tensorflow-lite-backend).

## Quick start

Clone the following demo project to your local computer or dev environment.

```bash
git clone https://github.com/juntao/demo-object-detection
cd demo-object-detection/
```

Build an inference application using the Mediapipe object detection model.

```bash
cargo build --target wasm32-wasi --release
wasmedge compile target/wasm32-wasi/release/demo-object-detection.wasm demo-object-detection.wasm
```

Run the inference application against an image. The input `example.jpg` image is shown below.

![The input image](https://raw.githubusercontent.com/juntao/demo-object-detection/main/example.jpg)

```bash
wasmedge --dir .:. demo-object-detection.wasm example.jpg output.jpg
```

The inference result `output.jpg` image is shown below.

![The output image](https://raw.githubusercontent.com/WasmEdge/mediapipe-rs/main/assets/doc/cat_and_dog_detection.jpg)

The console output from the above inference command shows the detected objects and their boundaries.

```bash
DetectionResult:
  Detection #0:
    Box: (left: 0.47665566, top: 0.05484602, right: 0.87270254, bottom: 0.87143743)
    Category #0:
      Category name: ""dog""
      Display name:  None
      Score:         0.7421875
      Index:         18
  Detection #1:
    Box: (left: 0.12402746, top: 0.37931007, right: 0.5297544, bottom: 0.8517805)
    Category #0:
      Category name: ""cat""
      Display name:  None
      Score:         0.7421875
      Index:         17
```

## Understand the code

The [main.rs](https://github.com/juntao/demo-object-detection/blob/main/src/main.rs) is the complete example Rust source. All `mediapipe-rs` APIs follow a common pattern. A Rust struct is designed to work with a model. It contains functions required to pre- and post-process data for the model. For example, we can create an `detector` instance using the builder pattern, which can build from any ""object detection"" model in the Mediapipe model library.

```rust
let model_data: &[u8] = include_bytes!(""mobilenetv2_ssd_256_uint8.tflite"");
let detector = ObjectDetectorBuilder::new()
        .max_results(2)
        .build_from_buffer(model_data)?;
```

The `detect()` function takes in an image, pre-processes it into a tensor array, runs inference on the mediapipe object detection model, and the post-processes the returned tensor array into a human readable format stored in the `detection_result`.

```rust
let mut input_img = image::open(img_path)?;
let detection_result = detector.detect(&input_img)?;
println!(""{}"", detection_result);
```

Furthermore, the `mediapipe-rs` crate provides additional utility functions to post-process the data. For example, the `draw_detection()` utility function draws the data in `detection_result` onto the input image.

```rust
draw_detection(&mut input_img, &detection_result);
input_img.save(output_path)?;
```

## Available mediapipe models

`AudioClassifierBuilder` builds from an audio classification model and uses `classify()` to process audio data. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/audio_classification.rs).

`GestureRecognizerBuilder` builds from a hand gesture recognition model and uses `recognize()` to process image data. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/gesture_recognition.rs).

`ImageClassifierBuilder` builds from an image classification model and uses `classify()` to process image data. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/image_classification.rs).

`ImageEmbedderBuilder` builds from an image embedding model and uses `embed()` to compute a vector representation (embedding) for an input image. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/image_embedding.rs).

`ObjectDetectorBuilder` builds from an object detection model and uses `detect()` to process image data. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/object_detection.rs).

`TextClassifierBuilder` builds from a text classification model and uses `classify()` to process text data. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/text_classification.rs).
","**Summary**

The code provided is an example of using the `mediapipe-rs` crate to run object detection on images. The crate provides a Rust interface to the Mediapipe suite of AI models, which can be used for various tasks such as image classification, object detection, gesture recognition, and more.

**Key Components**

1. **Mediapipe Model Library**: A collection of highly popular AI models developed by Google.
2. **ObjectDetectorBuilder**: A Rust struct that builds an instance of the object detection model from the Mediapipe model library.
3. **detect() function**: Runs inference on the mediapipe object detection model and returns a human-readable format of the detected objects.

**Example Code**

```rust
let model_data: &[u8] = include_bytes!(""mobilenetv2_ssd_256_uint8.tflite"");
let detector = ObjectDetectorBuilder::new()
        .max_results(2)
        .build_from_buffer(model_data)?;

let input_img = image::open(img_path)?;
let detection_result = detector.detect(&input_img)?;
println!(""{}"", detection_result);
```

**Available Mediapipe Models**

The `mediapipe-rs` crate provides additional utility functions to post-process data, including:

*   **AudioClassifierBuilder**: Builds from an audio classification model and uses `classify()` to process audio data.
*   **GestureRecognizerBuilder**: Builds from a hand gesture recognition model and uses `recognize()` to process image data.
*   **ImageClassifierBuilder**: Builds from an image classification model and uses `classify()` to process image data.
*   **ImageEmbedderBuilder**: Builds from an image embedding model and uses `embed()` to compute a vector representation (embedding) for an input image.
*   **TextClassifierBuilder**: Builds from a text classification model and uses `classify()` to process text data.

**Potential Issues**

1.  **Model Selection**: The code assumes the use of the object detection model, but the user may want to experiment with other models.
2.  **Image Quality**: The code does not handle image quality issues such as low resolution or poor lighting conditions.
3.  **Performance Optimization**: The code does not optimize performance for large-scale inference tasks.

Overall, the `mediapipe-rs` crate provides a convenient interface to various AI models, making it easier to integrate computer vision and machine learning capabilities into Rust applications. However, users should consider potential issues such as model selection, image quality, and performance optimization when using this crate."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/mediapipe.md,"---
sidebar_position: 2
---

# Mediapipe solutions

Mediapipe is a collection of highly popular AI models developed by Google. They focus on intelligent processing of media files and streams. The `mediapipe-rs` crate is a Rust library for data processing using the Mediapipe suite of models. The crate provides Rust APIs to pre-process the data in media files or streams, run AI model inference to analyze the data, and then post-process or manipulate the media data based on the AI output.

## Prerequisite

Besides the [regular WasmEdge and Rust requirements](../../rust/setup.md), please make sure that you have the [WASI-NN plugin with TensorFlow Lite installed](../../../start/install.md#wasi-nn-plug-in-with-tensorflow-lite-backend).

## Quick start

Clone the following demo project to your local computer or dev environment.

```bash
git clone https://github.com/juntao/demo-object-detection
cd demo-object-detection/
```

Build an inference application using the Mediapipe object detection model.

```bash
cargo build --target wasm32-wasi --release
wasmedge compile target/wasm32-wasi/release/demo-object-detection.wasm demo-object-detection.wasm
```

Run the inference application against an image. The input `example.jpg` image is shown below.

![The input image](https://raw.githubusercontent.com/juntao/demo-object-detection/main/example.jpg)

```bash
wasmedge --dir .:. demo-object-detection.wasm example.jpg output.jpg
```

The inference result `output.jpg` image is shown below.

![The output image](https://raw.githubusercontent.com/WasmEdge/mediapipe-rs/main/assets/doc/cat_and_dog_detection.jpg)

The console output from the above inference command shows the detected objects and their boundaries.

```bash
DetectionResult:
  Detection #0:
    Box: (left: 0.47665566, top: 0.05484602, right: 0.87270254, bottom: 0.87143743)
    Category #0:
      Category name: ""dog""
      Display name:  None
      Score:         0.7421875
      Index:         18
  Detection #1:
    Box: (left: 0.12402746, top: 0.37931007, right: 0.5297544, bottom: 0.8517805)
    Category #0:
      Category name: ""cat""
      Display name:  None
      Score:         0.7421875
      Index:         17
```

## Understand the code

The [main.rs](https://github.com/juntao/demo-object-detection/blob/main/src/main.rs) is the complete example Rust source. All `mediapipe-rs` APIs follow a common pattern. A Rust struct is designed to work with a model. It contains functions required to pre- and post-process data for the model. For example, we can create an `detector` instance using the builder pattern, which can build from any ""object detection"" model in the Mediapipe model library.

```rust
let model_data: &[u8] = include_bytes!(""mobilenetv2_ssd_256_uint8.tflite"");
let detector = ObjectDetectorBuilder::new()
        .max_results(2)
        .build_from_buffer(model_data)?;
```

The `detect()` function takes in an image, pre-processes it into a tensor array, runs inference on the mediapipe object detection model, and the post-processes the returned tensor array into a human readable format stored in the `detection_result`.

```rust
let mut input_img = image::open(img_path)?;
let detection_result = detector.detect(&input_img)?;
println!(""{}"", detection_result);
```

Furthermore, the `mediapipe-rs` crate provides additional utility functions to post-process the data. For example, the `draw_detection()` utility function draws the data in `detection_result` onto the input image.

```rust
draw_detection(&mut input_img, &detection_result);
input_img.save(output_path)?;
```

## Available mediapipe models

`AudioClassifierBuilder` builds from an audio classification model and uses `classify()` to process audio data. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/audio_classification.rs).

`GestureRecognizerBuilder` builds from a hand gesture recognition model and uses `recognize()` to process image data. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/gesture_recognition.rs).

`ImageClassifierBuilder` builds from an image classification model and uses `classify()` to process image data. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/image_classification.rs).

`ImageEmbedderBuilder` builds from an image embedding model and uses `embed()` to compute a vector representation (embedding) for an input image. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/image_embedding.rs).

`ObjectDetectorBuilder` builds from an object detection model and uses `detect()` to process image data. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/object_detection.rs).

`TextClassifierBuilder` builds from a text classification model and uses `classify()` to process text data. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/text_classification.rs).
","**Summary**

The provided code is a documentation for the `mediapipe-rs` crate, which is a Rust library for data processing using the Mediapipe suite of models developed by Google. The crate provides Rust APIs to pre-process media files or streams, run AI model inference, and post-process or manipulate media data based on the AI output.

**Key Components**

1. **Prerequisite**: The user needs to have WasmEdge and Rust requirements installed, as well as the WASI-NN plugin with TensorFlow Lite installed.
2. **Quick Start**: A demo project is provided that demonstrates how to use the Mediapipe object detection model for inference on an image.
3. **Main Functionality**: The `mediapipe-rs` crate provides APIs for various models, including object detection, audio classification, gesture recognition, image classification, image embedding, and text classification.
4. **API Documentation**: The code includes API documentation for each of the models, showing how to build instances of the models using a builder pattern and how to use them to process data.

**Potential Issues or Areas for Improvement**

1. **Complexity**: The code is quite complex, with many different APIs and models to navigate.
2. **Error Handling**: There is no explicit error handling in the code, which could make it difficult to debug issues.
3. **Documentation Quality**: While the code includes API documentation, some of the explanations are brief or unclear, making it harder for users to understand how to use the APIs correctly.

**Recommendations**

1. **Simplify the Code**: Consider breaking down the complex code into smaller, more manageable pieces to make it easier to navigate and understand.
2. **Improve Error Handling**: Add explicit error handling mechanisms to handle potential errors and provide clear explanations of what went wrong.
3. **Enhance Documentation Quality**: Provide more detailed and clear explanations of each API, including examples and use cases, to help users understand how to use them correctly."
docs/develop/rust/wasinn/tensorflow_lite.md,"---
sidebar_position: 3
---

# TensorFlow Lite Backend

We will use [this example project](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/tflite-birds_v1-image) to show how to make AI inference with a TensorFlow Lite model in WasmEdge and Rust.

## Prerequisite

Besides the [regular WasmEdge and Rust requirements](../../rust/setup.md), please make sure that you have the [WASI-NN plugin with TensorFlow Lite installed](../../../start/install.md#wasi-nn-plug-in-with-tensorflow-lite-backend).

## Quick start

Because the example already includes a compiled WASM file from the Rust code, we could use WasmEdge CLI to execute the example directly. First, git clone the `WasmEdge-WASINN-examples` repo.

```bash
git clone https://github.com/second-state/WasmEdge-WASINN-examples.git
cd WasmEdge-WASINN-examples/tflite-birds_v1-image/
```

Run the inference application in WasmEdge.

```bash
wasmedge --dir .:. wasmedge-wasinn-example-tflite-bird-image.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
```

If everything goes well, you should have the terminal output:

```bash
Read graph weights, size in bytes: 3561598
Loaded graph into wasi-nn with ID: 0
Created wasi-nn execution context with ID: 0
Read input tensor, size in bytes: 150528
Executed graph inference
   1.) [166](198)Aix galericulata
   2.) [158](2)Coccothraustes coccothraustes
   3.) [34](1)Gallus gallus domesticus
   4.) [778](1)Sitta europaea
   5.) [819](1)Anas platyrhynchos
```

## Build and run

Let's build the wasm file from the rust source code. First, git clone the `WasmEdge-WASINN-examples` repo.

```bash
git clone https://github.com/second-state/WasmEdge-WASINN-examples.git
cd WasmEdge-WASINN-examples/tflite-birds_v1-image/rust/
```

Second, use `cargo` to build the example project.

```bash
cargo build --target wasm32-wasi --release
```

The output WASM file is `target/wasm32-wasi/release/wasmedge-wasinn-example-tflite-bird-image.wasm`. Next, let's use WasmEdge to load the Tensorflow Lite model and then use it to classify objects in your image.

```bash
wasmedge --dir .:. wasmedge-wasinn-example-tflite-bird-image.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
```

You can replace `bird.jpg` with your image file.

## Improve performance

You can make the inference program run faster by AOT compiling the `wasm` file first.

```bash
wasmedge compile wasmedge-wasinn-example-tflite-bird-image.wasm out.wasm
wasmedge --dir .:. out.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
```

## Understand the code

The [main.rs](https://github.com/second-state/WasmEdge-WASINN-examples/blob/master/tflite-birds_v1-image/rust/tflite-bird/src/main.rs) is the complete example Rust source. First, read the image file and Tensorflow Lite (tflite) model file names from the command line.

```rust
let args: Vec<String> = env::args().collect();
let model_bin_name: &str = &args[1]; // File name for the TFLite model
let image_name: &str = &args[2]; // File name for the input image
```

We use a helper function called `image_to_tensor()` to convert the input image into tensor data (the tensor type is `U8`). Now we can load the model, feed the tensor array from the image to the model, and get the inference output tensor array.

```rust
// load model
let weights = fs::read(model_bin_name)?;
let graph = GraphBuilder::new(
    GraphEncoding::TensorflowLite,
    ExecutionTarget::CPU,
).build_from_bytes(&[&weights])?;
let mut ctx = graph.init_execution_context()?;

// Load a tensor that precisely matches the graph input tensor
let tensor_data = image_to_tensor(image_name.to_string(), 224, 224);
ctx.set_input(0, TensorType::U8, &[1, 224, 224, 3], &tensor_data)?;

// Execute the inference.
ctx.compute().unwrap();

// Retrieve the output.
let mut output_buffer = vec![0u8; imagenet_classes::AIY_BIRDS_V1.len()];
_ = ctx.get_output(0, &mut output_buffer)?;
```

In the above code, `GraphEncoding::TensorflowLite` means using the PyTorch backend, and `ExecutionTarget::CPU` means running the computation on the CPU. Finally, we sort the output and then print the top-5 classification results. Finally, we sort the output and then print the top-5 classification results:

```rust
let results = sort_results(&output_buffer);
for i in 0..5 {
    println!(
        ""   {}.) [{}]({:.4}){}"",
        i + 1,
        results[i].0,
        results[i].1,
        imagenet_classes::AIY_BIRDS_V1[results[i].0]
    );
}
```
","**Summary**

This code is an example of how to use the TensorFlow Lite backend with WasmEdge and Rust. It provides a step-by-step guide on how to:

1. Clone the `WasmEdge-WASINN-examples` repository.
2. Build the WASM file from the Rust source code using Cargo.
3. Use WasmEdge to load the TensorFlow Lite model and classify objects in an image.

**Key Components**

* `main.rs`: The complete example Rust source that reads input image and model files, converts the image into tensor data, loads the model, feeds the tensor array to the model, and gets the inference output tensor array.
* `image_to_tensor()` function: Converts the input image into tensor data (U8).
* `GraphBuilder` and `ExecutionTarget`: Used to build the graph and set up execution context for the TensorFlow Lite model.

**Potential Issues**

* The code assumes that the input image file and model file are in the correct format, which might not always be the case.
* The code does not handle errors properly, which might lead to unexpected behavior if there are issues with reading files or loading models.
* The performance of the inference program can be improved by AOT compiling the WASM file.

**Improvement Suggestions**

* Add error handling for file operations and model loading.
* Use a more robust way to read input image data.
* Consider using a different backend, such as WebAssembly's `wasm-ast` library, which might provide better performance and easier debugging."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/tensorflow_lite.md,"---
sidebar_position: 3
---

# TensorFlow Lite Backend

We will use [this example project](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/tflite-birds_v1-image) to show how to make AI inference with a TensorFlow Lite model in WasmEdge and Rust.

## Prerequisite

Besides the [regular WasmEdge and Rust requirements](../../rust/setup.md), please make sure that you have the [WASI-NN plugin with TensorFlow Lite installed](../../../start/install.md#wasi-nn-plug-in-with-tensorflow-lite-backend).

## Quick start

Because the example already includes a compiled WASM file from the Rust code, we could use WasmEdge CLI to execute the example directly. First, git clone the `WasmEdge-WASINN-examples` repo.

```bash
git clone https://github.com/second-state/WasmEdge-WASINN-examples.git
cd WasmEdge-WASINN-examples/tflite-birds_v1-image/
```

Run the inference application in WasmEdge.

```bash
wasmedge --dir .:. wasmedge-wasinn-example-tflite-bird-image.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
```

If everything goes well, you should have the terminal output:

```bash
Read graph weights, size in bytes: 3561598
Loaded graph into wasi-nn with ID: 0
Created wasi-nn execution context with ID: 0
Read input tensor, size in bytes: 150528
Executed graph inference
   1.) [166](198)Aix galericulata
   2.) [158](2)Coccothraustes coccothraustes
   3.) [34](1)Gallus gallus domesticus
   4.) [778](1)Sitta europaea
   5.) [819](1)Anas platyrhynchos
```

## Build and run

Let's build the wasm file from the rust source code. First, git clone the `WasmEdge-WASINN-examples` repo.

```bash
git clone https://github.com/second-state/WasmEdge-WASINN-examples.git
cd WasmEdge-WASINN-examples/tflite-birds_v1-image/rust/
```

Second, use `cargo` to build the example project.

```bash
cargo build --target wasm32-wasi --release
```

The output WASM file is `target/wasm32-wasi/release/wasmedge-wasinn-example-tflite-bird-image.wasm`. Next, let's use WasmEdge to load the Tensorflow Lite model and then use it to classify objects in your image.

```bash
wasmedge --dir .:. wasmedge-wasinn-example-tflite-bird-image.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
```

You can replace `bird.jpg` with your image file.

## Improve performance

You can make the inference program run faster by AOT compiling the `wasm` file first.

```bash
wasmedge compile wasmedge-wasinn-example-tflite-bird-image.wasm out.wasm
wasmedge --dir .:. out.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
```

## Understand the code

The [main.rs](https://github.com/second-state/WasmEdge-WASINN-examples/blob/master/tflite-birds_v1-image/rust/tflite-bird/src/main.rs) is the complete example Rust source. First, read the image file and Tensorflow Lite (tflite) model file names from the command line.

```rust
let args: Vec<String> = env::args().collect();
let model_bin_name: &str = &args[1]; // File name for the TFLite model
let image_name: &str = &args[2]; // File name for the input image
```

We use a helper function called `image_to_tensor()` to convert the input image into tensor data (the tensor type is `U8`). Now we can load the model, feed the tensor array from the image to the model, and get the inference output tensor array.

```rust
// load model
let weights = fs::read(model_bin_name)?;
let graph = GraphBuilder::new(
    GraphEncoding::TensorflowLite,
    ExecutionTarget::CPU,
).build_from_bytes(&[&weights])?;
let mut ctx = graph.init_execution_context()?;

// Load a tensor that precisely matches the graph input tensor
let tensor_data = image_to_tensor(image_name.to_string(), 224, 224);
ctx.set_input(0, TensorType::U8, &[1, 224, 224, 3], &tensor_data)?;

// Execute the inference.
ctx.compute().unwrap();

// Retrieve the output.
let mut output_buffer = vec![0u8; imagenet_classes::AIY_BIRDS_V1.len()];
_ = ctx.get_output(0, &mut output_buffer)?;
```

In the above code, `GraphEncoding::TensorflowLite` means using the PyTorch backend, and `ExecutionTarget::CPU` means running the computation on the CPU. Finally, we sort the output and then print the top-5 classification results. Finally, we sort the output and then print the top-5 classification results:

```rust
let results = sort_results(&output_buffer);
for i in 0..5 {
    println!(
        ""   {}.) [{}]({:.4}){}"",
        i + 1,
        results[i].0,
        results[i].1,
        imagenet_classes::AIY_BIRDS_V1[results[i].0]
    );
}
```
","**Code Summary:**

This code is an example of using WasmEdge and Rust to perform AI inference with a TensorFlow Lite model. The code provides a step-by-step guide on how to clone the example repository, build the WASM file from the Rust source code, load the Tensorflow Lite model, and use it to classify objects in an image.

**Key Components:**

1. **WASMEdge**: A WebAssembly runtime for executing Rust code.
2. **Rust Code**: The `main.rs` file contains the complete example Rust source code, which reads the input image and TensorFlow Lite model file names from the command line, converts the image to tensor data, loads the model, feeds the tensor array to the model, and gets the inference output tensor array.
3. **TensorFlow Lite (TFLite)**: A lightweight open-source framework for machine learning models.
4. **WASM Compilation**: The code uses WASM compilation to improve performance.

**Potential Issues or Areas for Improvement:**

1. **Error Handling**: The code does not handle errors properly, which can lead to unexpected behavior if an error occurs during execution.
2. **Performance Optimization**: While the code improves performance using WASM compilation, there may be opportunities for further optimization, such as using a more efficient runtime environment or optimizing the Rust code itself.
3. **Code Organization**: The code is not organized in a modular way, making it harder to maintain and extend.

**Best Practices:**

1. **Follow Coding Conventions**: The code follows some coding conventions, but there are opportunities for improvement, such as using consistent naming conventions and formatting.
2. **Use Meaningful Variable Names**: Some variable names could be more descriptive, making the code easier to understand.
3. **Use Comments**: The code would benefit from additional comments to explain its purpose and behavior."
docs/contribute/source/os/linux.md,"---
sidebar_position: 1
---

# Build on Linux

## Get the Source Code

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
```

## Prepare the Environment

### Docker Images

The easiest way to set up the environment is using the WasmEdge docker images.

You can use the following commands to get our latest docker image [from dockerhub](https://hub.docker.com/search?q=wasmedge):

```bash
docker pull wasmedge/wasmedge # Pulls the latest - wasmedge/wasmedge:latest
```

Or you can pull with the [available tags](../docker.md#docker-images-for-building-wasmedge).

### Install Dependencies on Ubuntu Manually

For the developers who don't want to use docker, they can set up the environment on Ubuntu Manually.

Please check that these dependencies are satisfied.

- LLVM 12.0.0 (>= 10.0.0)
- _(Optional)_ GCC 11.1.0 (>= 9.4.0), install it if you prefer to use GCC toolchain.

After `WasmEdge 0.13.0`, the `boost` dependency is not needed.

#### For Ubuntu 22.04

```bash
# Tools and libraries
sudo apt install -y \
   software-properties-common \
   cmake

# And you will need to install llvm for the AOT runtime
sudo apt install -y \
   llvm-14-dev \
   liblld-14-dev

# WasmEdge supports both clang++ and g++ compilers.
# You can choose one of them to build this project.
# If you prefer GCC, then:
sudo apt install -y gcc g++
# Or if you prefer clang, then:
sudo apt install -y clang-14
```

#### For Ubuntu 20.04

```bash
# Tools and libraries
sudo apt install -y \
   software-properties-common \
   cmake

# And you will need to install llvm for the AOT runtime
sudo apt install -y \
   llvm-12-dev \
   liblld-12-dev

# WasmEdge supports both clang++ and g++ compilers.
# You can choose one of them to build this project.
# If you prefer GCC, then:
sudo apt install -y gcc g++
# Or if you prefer clang, then:
sudo apt install -y clang-12
```

### Support for Legacy Operating Systems

Our development environment requires `libLLVM-12` and `>=GLIBCXX_3.4.33`.

If users use operating systems older than Ubuntu 20.04, please use our particular docker image to build WasmEdge. If you are looking for the pre-built binaries for the older operating system, we also provide several pre-built binaries based on `manylinux*` distributions.

| Docker Image | Base Image | Provided Requirements |
| --- | --- | --- |
| `wasmedge/wasmedge:manylinux2014_x86_64` | CentOS 7.9 | GLIBC <= 2.17<br/>CXXABI <= 1.3.7<br/>GLIBCXX <= 3.4.19<br/>GCC <= 4.8.0 |
| `wasmedge/wasmedge:manylinux2014_aarch64` | CentOS 7.9 | GLIBC <= 2.17<br/>CXXABI <= 1.3.7<br/>GLIBCXX <= 3.4.19<br/>GCC <= 4.8.0 |

## Build WasmEdge

Please refer to [here](../build_from_src.md#cmake-building-options) for the descriptions of all CMake options.

```bash
# After pulling our wasmedge docker image
docker run -it --rm \
    -v <path/to/your/wasmedge/source/folder>:/root/wasmedge \
    wasmedge/wasmedge:latest
# In docker
cd /root/wasmedge
# If you don't use docker then you need to run only the following commands in the cloned repository root
mkdir -p build && cd build
cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_TESTS=ON .. && make -j
```

## Run Tests

The following tests are available only when the build option `WASMEDGE_BUILD_TESTS` is set to `ON`.

Users can use these tests to verify the correctness of WasmEdge binaries.

```bash
# In docker
cd <path/to/wasmedge/build_folder>
LD_LIBRARY_PATH=$(pwd)/lib/api ctest
```
","**Summary**

The provided code is a tutorial on how to build and run the WasmEdge project, a WebAssembly runtime environment. The guide covers two approaches:

1. **Docker Images**: Using pre-built Docker images for WasmEdge from Docker Hub.
2. **Manual Setup on Ubuntu**: Installing dependencies manually on an Ubuntu system.

**Key Components**

* `git clone` command to obtain the WasmEdge source code
* Docker commands to pull and run the WasmEdge image
* CMake options and build configurations
* Test running instructions

**Potential Issues or Areas for Improvement**

1. **Docker Image Availability**: If users encounter issues with pulling the latest WasmEdge Docker image, they may need to use an older version of the image.
2. **Manual Setup on Ubuntu**: The manual setup process assumes a clean installation of Ubuntu and does not account for potential package conflicts or dependencies.
3. **Test Running Instructions**: The test running instructions assume that users have set up their environment correctly and are aware of the CMake options used.

**Recommendations**

1. Provide clearer instructions on troubleshooting Docker image issues.
2. Offer guidance on handling package conflicts during manual setup on Ubuntu.
3. Consider providing a more comprehensive explanation of CMake options and build configurations for advanced users.

By addressing these areas, the tutorial can provide a more comprehensive and user-friendly experience for those seeking to build and run WasmEdge."
docs/embed/quick-start/wasm-app-in-rust.md,"---
sidebar_position: 2
---

# Create a WASM app using Rust and wasmedge-bindgen

In the previous chapter, we learned how to install WasmEdge and WasmEdge Go SDK. This chapter will teach us how to create a WASM app using Rust and `wasmedge-bindgen` tool.

<!-- prettier-ignore -->
:::note
The [wasmedge-bindgen](https://github.com/second-state/wasmedge-bindgen) project provides Rust macros for functions to accept and return complex data types and then for Go functions to call such Rust functions running in WasmEdge.
:::

## Prerequisites

We need to install [Rust and add `wasm32-wasi` target for Rust](../../develop/rust/setup.md)

We also need to install `wasmedge-bindgen`.

```bash
# Install the WasmEdge-bindgen tool, which help us handle complex data passing
$ go get github.com/second-state/wasmedge-bindgen@v0.4.1
```

## Rust function

The complete source code for the demo in this chapter is [available here](https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs).

In the [Rust project](https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs), all you need is to annotate [your functions](https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs) with a `[wasmedge_bindgen]` macro.

Those annotated functions will be automatically instrumented by the Rust compiler and turned into WebAssembly functions that can be called from the bindgen related functions of WasmEdge GO SDK.

The example below shows several Rust functions that take complex call parameters and return complex values.

```rust
use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;
use num_integer::lcm;
use sha3::{Digest, Sha3_256, Keccak256};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32,
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec<Point>,
  valid: bool,
  length: f32,
  desc: String
}

#[wasmedge_bindgen]
pub fn create_line(p1: String, p2: String, desc: String) -> Result<Vec<u8>, String> {
  let point1: Point = serde_json::from_str(p1.as_str()).unwrap();
  let point2: Point = serde_json::from_str(p2.as_str()).unwrap();
  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();

  let valid = if length == 0.0 { false } else { true };

  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc };

  return Ok(serde_json::to_vec(&line).unwrap());
}

#[wasmedge_bindgen]
pub fn say(s: String) -> Result<Vec<u8>, String> {
  let r = String::from(""hello "");
  return Ok((r + s.as_str()).as_bytes().to_vec());
}

#[wasmedge_bindgen]
pub fn obfusticate(s: String) -> Result<Vec<u8>, String> {
  let r: String = (&s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' => ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' => ((c as u8) - 13) as char,
      _ => c
    }
  }).collect();
  Ok(r.as_bytes().to_vec())
}

#[wasmedge_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -> Result<Vec<u8>, String> {
  let r = lcm(a, b);
  return Ok(r.to_string().as_bytes().to_vec());
}

#[wasmedge_bindgen]
pub fn sha3_digest(v: Vec<u8>) -> Result<Vec<u8>, String> {
  return Ok(Sha3_256::digest(&v).as_slice().to_vec());
}

#[wasmedge_bindgen]
pub fn keccak_digest(s: Vec<u8>) -> Result<Vec<u8>, String> {
  return Ok(Keccak256::digest(&s).as_slice().to_vec());
}
```

## Compile the Rust code into Wasm

Now the rust function is ready. Let's compile the Rust code to WASM.

First， fork or git clone the demo project to get the source code.

```bash
git clone https://github.com/second-state/WasmEdge-go-examples.git
```

Next, build the WebAssembly bytecode file using standard `Cargo` commands.

```bash
cd rust_bindgen_funcs
cargo build --target wasm32-wasi --release
# The output WASM will be target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm.
cp target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm ../
cd ../
```

Now we have a WASM function. Next, how to embed the WASM function into a Go Host application.
","**Summary**

This code is a Quick Start guide on creating a WebAssembly (WASM) app using Rust and the `wasmedge-bindgen` tool. It provides a step-by-step walkthrough of how to:

1. Install the necessary dependencies, including Rust and `wasmedge-bindgen`.
2. Annotate Rust functions with the `[wasmedge_bindgen]` macro to enable automatic instrumentation.
3. Compile the annotated Rust code into WASM bytecode using Cargo.

**Key Components**

* The code is organized around a single Rust project (`go_BindgenFuncs/rust_bindgen_funcs`) that contains several example functions annotated with `#[wasmedge_bindgen]`.
* Each function demonstrates how to pass complex data types (e.g., structs, vectors) and return complex values.
* The example functions include:
	+ `create_line`: creates a line object with points and calculates its length.
	+ `say`: concatenates two strings and returns the result as WASM bytes.
	+ `obfusticate`: applies Caesar cipher encryption to a string.
	+ `lowest_common_multiple`: computes the lowest common multiple of two integers.
	+ `sha3_digest` and `keccak_digest`: compute SHA-3 and Keccak-256 digests, respectively.

**Potential Issues or Areas for Improvement**

* The code assumes that the Rust compiler will correctly instrument the annotated functions. However, there may be cases where this fails due to compilation errors or incorrect annotations.
* The example functions are relatively simple and do not demonstrate more complex scenarios, such as passing large datasets or using advanced WebAssembly features like memory management.
* The `wasmedge-bindgen` tool is still in development, and future versions may introduce breaking changes or new features that require updates to the code.

**Context**

This code is part of a larger project (WasmEdge) aimed at creating a Go SDK for WebAssembly. The `wasmedge-bindgen` tool is designed to enable seamless integration between Rust and WasmEdge, making it easier to create high-performance WASM apps that leverage the strengths of both languages."
i18n/zh/docusaurus-plugin-content-docs/current/embed/quick-start/wasm-app-in-rust.md,"---
sidebar_position: 2
---

# Create a WASM app using Rust and wasmedge-bindgen

In the previous chapter, we learned how to install WasmEdge and WasmEdge Go SDK. This chapter will teach us how to create a WASM app using Rust and `wasmedge-bindgen` tool.

<!-- prettier-ignore -->
:::note
The [wasmedge-bindgen](https://github.com/second-state/wasmedge-bindgen) project provides Rust macros for functions to accept and return complex data types and then for Go functions to call such Rust functions running in WasmEdge.
:::

## Prerequisites

We need to install [Rust and add `wasm32-wasi` target for Rust](../../develop/rust/setup.md)

We also need to install `wasmedge-bindgen`.

```bash
# Install the WasmEdge-bindgen tool, which help us handle complex data passing
$ go get github.com/second-state/wasmedge-bindgen@v0.4.1
```

## Rust function

The complete source code for the demo in this chapter is [available here](https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs).

In the [Rust project](https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs), all you need is to annotate [your functions](https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs) with a `[wasmedge_bindgen]` macro.

Those annotated functions will be automatically instrumented by the Rust compiler and turned into WebAssembly functions that can be called from the bindgen related functions of WasmEdge GO SDK.

The example below shows several Rust functions that take complex call parameters and return complex values.

```rust
use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;
use num_integer::lcm;
use sha3::{Digest, Sha3_256, Keccak256};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32,
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec<Point>,
  valid: bool,
  length: f32,
  desc: String
}

#[wasmedge_bindgen]
pub fn create_line(p1: String, p2: String, desc: String) -> Result<Vec<u8>, String> {
  let point1: Point = serde_json::from_str(p1.as_str()).unwrap();
  let point2: Point = serde_json::from_str(p2.as_str()).unwrap();
  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();

  let valid = if length == 0.0 { false } else { true };

  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc };

  return Ok(serde_json::to_vec(&line).unwrap());
}

#[wasmedge_bindgen]
pub fn say(s: String) -> Result<Vec<u8>, String> {
  let r = String::from(""hello "");
  return Ok((r + s.as_str()).as_bytes().to_vec());
}

#[wasmedge_bindgen]
pub fn obfusticate(s: String) -> Result<Vec<u8>, String> {
  let r: String = (&s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' => ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' => ((c as u8) - 13) as char,
      _ => c
    }
  }).collect();
  Ok(r.as_bytes().to_vec())
}

#[wasmedge_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -> Result<Vec<u8>, String> {
  let r = lcm(a, b);
  return Ok(r.to_string().as_bytes().to_vec());
}

#[wasmedge_bindgen]
pub fn sha3_digest(v: Vec<u8>) -> Result<Vec<u8>, String> {
  return Ok(Sha3_256::digest(&v).as_slice().to_vec());
}

#[wasmedge_bindgen]
pub fn keccak_digest(s: Vec<u8>) -> Result<Vec<u8>, String> {
  return Ok(Keccak256::digest(&s).as_slice().to_vec());
}
```

## Compile the Rust code into Wasm

Now the rust function is ready. Let's compile the Rust code to WASM.

First， fork or git clone the demo project to get the source code.

```bash
git clone https://github.com/second-state/WasmEdge-go-examples.git
```

Next, build the WebAssembly bytecode file using standard `Cargo` commands.

```bash
cd rust_bindgen_funcs
cargo build --target wasm32-wasi --release
# The output WASM will be target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm.
cp target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm ../
cd ../
```

Now we have a WASM function. Next, how to embed the WASM function into a Go Host application.
","**Summary**

The provided code is a tutorial on how to create a WASM (WebAssembly) application using Rust and the `wasmedge-bindgen` tool. The tutorial covers:

1. Prerequisites: Installing Rust, adding the `wasm32-wasi` target for Rust, and installing `wasmedge-bindgen`.
2. Annotating Rust functions with the `[wasmedge_bindgen]` macro to make them callable from WasmEdge GO SDK.
3. Compiling the annotated Rust code into WebAssembly bytecode using standard `Cargo` commands.

**Key Components**

1. `wasmedge-bindgen`: A tool that provides Rust macros for functions to accept and return complex data types, making it possible to call these functions from Go running in WasmEdge.
2. `[wasmedge_bindgen]` macro: Annotates Rust functions to make them callable from WasmEdge GO SDK.

**Potential Issues or Areas for Improvement**

1. The code assumes that the reader has a basic understanding of Rust and WebAssembly.
2. The tutorial does not cover error handling in detail, which may lead to issues when working with complex data types.
3. The `wasmedge-bindgen` tool is specific to WasmEdge, and users may need to adjust their code to work with other WASM runtimes.

**Best Practices**

1. Use clear and concise naming conventions for Rust functions and variables.
2. Provide detailed explanations of the code and its purpose.
3. Consider adding more examples or test cases to demonstrate the usage of `wasmedge-bindgen` and annotated Rust functions."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/linux.md,"---
sidebar_position: 1
---

# Build on Linux

## Get the Source Code

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
```

## Prepare the Environment

### Docker Images

The easiest way to set up the environment is using the WasmEdge docker images.

You can use the following commands to get our latest docker image [from dockerhub](https://hub.docker.com/search?q=wasmedge):

```bash
docker pull wasmedge/wasmedge # Pulls the latest - wasmedge/wasmedge:latest
```

Or you can pull with the [available tags](../docker.md#docker-images-for-building-wasmedge).

### Install Dependencies on Ubuntu Manually

For the developers who don't want to use docker, they can set up the environment on Ubuntu Manually.

Please check that these dependencies are satisfied.

- LLVM 12.0.0 (>= 10.0.0)
- _(Optional)_ GCC 11.1.0 (>= 9.4.0), install it if you prefer to use GCC toolchain.

#### For Ubuntu 22.04

```bash
# Tools and libraries
sudo apt install -y \
   software-properties-common \
   cmake

# And you will need to install llvm for the AOT runtime
sudo apt install -y \
   llvm-14-dev \
   liblld-14-dev

# WasmEdge supports both clang++ and g++ compilers.
# You can choose one of them to build this project.
# If you prefer GCC, then:
sudo apt install -y gcc g++
# Or if you prefer clang, then:
sudo apt install -y clang-14
```

#### For Ubuntu 20.04

```bash
# Tools and libraries
sudo apt install -y \
   software-properties-common \
   cmake

# And you will need to install llvm for the AOT runtime
sudo apt install -y \
   llvm-12-dev \
   liblld-12-dev

# WasmEdge supports both clang++ and g++ compilers.
# You can choose one of them to build this project.
# If you prefer GCC, then:
sudo apt install -y gcc g++
# Or if you prefer clang, then:
sudo apt install -y clang-12
```

### Support for Legacy Operating Systems

Our development environment requires `libLLVM-12` and `>=GLIBCXX_3.4.33`.

If users use operating systems older than Ubuntu 20.04, please use our particular docker image to build WasmEdge. If you are looking for the pre-built binaries for the older operating system, we also provide several pre-built binaries based on `manylinux*` distributions.

| Docker Image | Base Image | Provided Requirements |
| --- | --- | --- |
| `wasmedge/wasmedge:manylinux2014_x86_64` | CentOS 7.9 | GLIBC <= 2.17<br/>CXXABI <= 1.3.7<br/>GLIBCXX <= 3.4.19<br/>GCC <= 4.8.0 |
| `wasmedge/wasmedge:manylinux2014_aarch64` | CentOS 7.9 | GLIBC <= 2.17<br/>CXXABI <= 1.3.7<br/>GLIBCXX <= 3.4.19<br/>GCC <= 4.8.0 |

## Build WasmEdge

Please refer to [here](../build_from_src.md#cmake-building-options) for the descriptions of all CMake options.

```bash
# After pulling our wasmedge docker image
docker run -it --rm \
    -v <path/to/your/wasmedge/source/folder>:/root/wasmedge \
    wasmedge/wasmedge:latest
# In docker
cd /root/wasmedge
# If you don't use docker then you need to run only the following commands in the cloned repository root
mkdir -p build && cd build
cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_TESTS=ON .. && make -j
```

## Run Tests

The following tests are available only when the build option `WASMEDGE_BUILD_TESTS` is set to `ON`.

Users can use these tests to verify the correctness of WasmEdge binaries.

```bash
# In docker
cd <path/to/wasmedge/build_folder>
LD_LIBRARY_PATH=$(pwd)/lib/api ctest
```
","**Summary**

This is a documentation file for setting up and building the WasmEdge project on Linux. The file provides step-by-step instructions for getting the source code, preparing the environment, installing dependencies, and building WasmEdge using Docker or manually.

**Key Components**

1. **Getting the Source Code**: Clone the WasmEdge repository from GitHub.
2. **Preparing the Environment**:
	* Using Docker: Pull the latest WasmEdge docker image from Docker Hub.
	* Manual setup: Install LLVM 12.0.0 and optionally GCC 11.1.0 on Ubuntu 22.04 or Ubuntu 20.04.
3. **Building WasmEdge**: Use CMake to build WasmEdge with the desired options (e.g., Release, Debug).
4. **Running Tests**: Run tests using `ctest` only when the build option `WASMEDGE_BUILD_TESTS` is set to `ON`.

**Potential Issues or Areas for Improvement**

1. **Docker Image Variability**: The documentation uses specific docker image tags (`wasmedge/wasmedge:latest`) which may not be available in the future. Consider using a more stable or version-specific tag.
2. **Manual Setup Instructions**: The instructions for manual setup are lengthy and may require additional steps. Consider breaking down the setup process into smaller, more manageable tasks.
3. **CMake Options**: The documentation does not explicitly mention the available CMake options for building WasmEdge. Consider adding a link to a dedicated page or section that explains these options in detail.
4. **Testing Instructions**: The testing instructions assume a basic understanding of `ctest` and its usage. Consider adding more context or examples to help users who are new to testing.

Overall, the documentation provides a clear and concise guide for setting up and building WasmEdge on Linux using Docker or manual setup methods. However, some areas could benefit from additional clarification or detail to improve user experience."
docs/develop/go/hello_world.md,"---
sidebar_position: 1
---

# TinyGo

The best way to run Go programs in WasmEdge is to compile Go source code to WebAssembly using [TinyGo](https://tinygo.org/). In this article, we will show you how.

The Golang is adding WASI support. Stay tuned!

## Install TinyGo

You must have [Go already installed](https://go.dev/doc/install) on your machine before installing TinyGo. Go v1.17 or above is recommended. For Ubuntu or other Debian-based Linux systems on x86 processors, you could use the following command line to install TinyGo. For other platforms, please refer to [TinyGo docs](https://tinygo.org/getting-started/install/).

```bash
wget https://github.com/tinygo-org/tinygo/releases/download/v0.21.0/tinygo_0.21.0_amd64.deb
sudo dpkg -i tinygo_0.21.0_amd64.deb`
```

Next, run the following command line to check if the installation succeeds.

```bash
$ tinygo version
tinygo version 0.21.0 linux/amd64 (using go version go1.16.7 and LLVM version 11.0.0)
```

## Hello world

The simple Go app has a `main()` function to print a message to the console. The source code in `main.go` file is as follows.

```go
package main

func main() {
  println(""Hello TinyGo from WasmEdge!"")
}
```

<!-- prettier-ignore -->
:::note
Inside the `main()` function, you can use Go standard API to read / write files, and access command line arguments and `env` variables.
:::

### Hello world: Compile and build

Next, compile the `main.go` program to WebAssembly using TinyGo.

```bash
tinygo build -o hello.wasm -target wasi main.go
```

You will see a `hello.wasm` file in the same directory, a WebAssembly bytecode file.

### Hello world: Run

You can run it with the [WasmEdge CLI](../../start/build-and-run/cli.md).

```bash
$ wasmedge hello.wasm
Hello TinyGo from WasmEdge!
```

## A simple function

The second example is a Go function that takes a call parameter to compute a fibonacci number. However, for the Go application to set up proper access to the OS (e.g., to access the command line arguments), you must include an empty `main()` function in the source code.

```go
package main

func main(){
}

//export fibArray
func fibArray(n int32) int32{
  arr := make([]int32, n)
  for i := int32(0); i < n; i++ {
    switch {
    case i < 2:
      arr[i] = i
    default:
      arr[i] = arr[i-1] + arr[i-2]
    }
  }
  return arr[n-1]
}
```

### A simple function: Compile and build

Next, compile the `main.go` program to WebAssembly using TinyGo.

```bash
tinygo build -o fib.wasm -target wasi main.go
```

You will see a file named `fib.wasm` in the same directory, a WebAssembly bytecode file.

### A simple function: Run

You can run it with the [WasmEdge CLI](../../start/build-and-run/cli.md) in its `--reactor` mode. The command line arguments following the `wasm` file are the function name and call parameters.

```bash
$ wasmedge --reactor fib.wasm fibArray 10
34
```

## Improve performance

To achieve native Go performance for those applications, you could use the `wasmedge compile` command to AOT compile the `wasm` program, then run it with the `wasmedge` command.

```bash
$ wasmedge compile hello.wasm hello.wasm

$ wasmedge hello.wasm
Hello TinyGo from WasmEdge!
```

For the `--reactor` mode,

```bash
$ wasmedge compile fib.wasm fib.wasm

$ wasmedge --reactor fib.wasm fibArray 10
34
```
","**Summary:**

The provided code is a tutorial on using TinyGo to compile Go programs to WebAssembly (WASM) and run them with WasmEdge. The tutorial covers two examples:

1. A ""Hello World"" program that prints a message to the console.
2. A simple function that computes a Fibonacci number.

**Key Components:**

* `tinygo`: a compiler from Go to WASM
* `main.go`: the source code file for the Go programs
* `wasmedge`: the WasmEdge CLI for running WASM programs

**Functionality:**

1. Compile the Go program to WASM using TinyGo.
2. Run the resulting WASM program with WasmEdge.

**Potential Issues/Areas for Improvement:**

1. **WASI support**: The tutorial mentions that Golang is adding WASI support, but it's not clear when this feature will be available.
2. **TinyGo version compatibility**: The tutorial recommends using Go v1.17 or above and TinyGo 0.21.0, but it's unclear if later versions of TinyGo are compatible with earlier versions of Go.
3. **AOT compilation**: The tutorial mentions AOT (Ahead-of-Time) compilation, which can improve performance, but the instructions for doing so are incomplete.
4. **Error handling**: There is no error handling in the examples provided, which could make it difficult to diagnose issues when running the programs.

**Best Practices:**

1. **Use the latest versions of TinyGo and Go**: To ensure compatibility and take advantage of any new features or bug fixes.
2. **Test your code thoroughly**: Before releasing it to production, test your code with various inputs and edge cases to catch any bugs or errors.
3. **Follow best practices for error handling**: Use try-catch blocks, logging, and other techniques to handle errors and make your code more robust."
i18n/zh/docusaurus-plugin-content-docs/current/develop/go/hello_world.md,"---
sidebar_position: 1
---

# TinyGo

The best way to run Go programs in WasmEdge is to compile Go source code to WebAssembly using [TinyGo](https://tinygo.org/). In this article, we will show you how.

The Golang is adding WASI support. Stay tuned!

## Install TinyGo

You must have [Go already installed](https://go.dev/doc/install) on your machine before installing TinyGo. Go v1.17 or above is recommended. For Ubuntu or other Debian-based Linux systems on x86 processors, you could use the following command line to install TinyGo. For other platforms, please refer to [TinyGo docs](https://tinygo.org/getting-started/install/).

```bash
wget https://github.com/tinygo-org/tinygo/releases/download/v0.21.0/tinygo_0.21.0_amd64.deb
sudo dpkg -i tinygo_0.21.0_amd64.deb`
```

Next, run the following command line to check if the installation succeeds.

```bash
$ tinygo version
tinygo version 0.21.0 linux/amd64 (using go version go1.16.7 and LLVM version 11.0.0)
```

## Hello world

The simple Go app has a `main()` function to print a message to the console. The source code in `main.go` file is as follows.

```go
package main

func main() {
  println(""Hello TinyGo from WasmEdge!"")
}
```

<!-- prettier-ignore -->
:::note
Inside the `main()` function, you can use Go standard API to read / write files, and access command line arguments and `env` variables.
:::

### Hello world: Compile and build

Next, compile the `main.go` program to WebAssembly using TinyGo.

```bash
tinygo build -o hello.wasm -target wasi main.go
```

You will see a `hello.wasm` file in the same directory, a WebAssembly bytecode file.

### Hello world: Run

You can run it with the [WasmEdge CLI](../../start/build-and-run/cli.md).

```bash
$ wasmedge hello.wasm
Hello TinyGo from WasmEdge!
```

## A simple function

The second example is a Go function that takes a call parameter to compute a fibonacci number. However, for the Go application to set up proper access to the OS (e.g., to access the command line arguments), you must include an empty `main()` function in the source code.

```go
package main

func main(){
}

//export fibArray
func fibArray(n int32) int32{
  arr := make([]int32, n)
  for i := int32(0); i < n; i++ {
    switch {
    case i < 2:
      arr[i] = i
    default:
      arr[i] = arr[i-1] + arr[i-2]
    }
  }
  return arr[n-1]
}
```

### A simple function: Compile and build

Next, compile the `main.go` program to WebAssembly using TinyGo.

```bash
tinygo build -o fib.wasm -target wasi main.go
```

You will see a file named `fib.wasm` in the same directory, a WebAssembly bytecode file.

### A simple function: Run

You can run it with the [WasmEdge CLI](../../start/build-and-run/cli.md) in its `--reactor` mode. The command line arguments following the `wasm` file are the function name and call parameters.

```bash
$ wasmedge --reactor fib.wasm fibArray 10
34
```

## Improve performance

To achieve native Go performance for those applications, you could use the `wasmedge compile` command to AOT compile the `wasm` program, then run it with the `wasmedge` command.

```bash
$ wasmedge compile hello.wasm hello.wasm

$ wasmedge hello.wasm
Hello TinyGo from WasmEdge!
```

For the `--reactor` mode,

```bash
$ wasmedge compile fib.wasm fib.wasm

$ wasmedge --reactor fib.wasm fibArray 10
34
```
","**Summary**

This is a documentation article for using TinyGo to compile Go source code to WebAssembly and run it on WasmEdge. The article covers the installation of TinyGo, a simple ""Hello World"" example, a more complex function example, and how to improve performance.

**Key Components**

1. **Installation**: The article explains how to install TinyGo on different platforms.
2. **Hello World Example**: A simple Go program that prints a message to the console is compiled to WebAssembly using TinyGo and run on WasmEdge.
3. **Complex Function Example**: A Go function that computes a Fibonacci number is compiled to WebAssembly using TinyGo and run on WasmEdge with command-line arguments.
4. **Performance Improvement**: The article explains how to use `wasmedge compile` to AOT compile the `wasm` program for better performance.

**Potential Issues or Areas for Improvement**

1. **Platform Support**: The article assumes that the reader is using a Linux system, which may not be true for all readers.
2. **TinyGo Version**: The article specifies TinyGo version 0.21.0, but it's not clear if this version is the latest or recommended one.
3. **WasmEdge CLI**: The article mentions WasmEdge CLI without providing a link to its documentation or usage instructions.
4. **Code Quality**: Some of the code snippets appear to be simplified for demonstration purposes, which may not reflect real-world code quality.

**Recommendations**

1. Update the platform support section to include more platforms and operating systems.
2. Specify the latest recommended TinyGo version and provide a link to its documentation.
3. Provide a link to WasmEdge CLI documentation and usage instructions.
4. Review the code snippets for better coding practices and best practices."
docs/embed/rust/intro.md,"---
sidebar_position: 1
---

# WasmEdge Rust SDK

## Overview

WasmEdge Rust SDK consists of five crates:

- `wasmedge-sdk` crate defines a group of safe, ergonomic high-level APIs developers use to build up their own business applications.

- `wasmedge-sys` crate is a wrapper of WasmEdge C-API and provides safe counterparts. It is not recommended to use it directly by application developers. `wasmedge-sys`, `wasmedge-types`, and `wasmedge-macro` constitute the low-level layer of WasmEdge Rust SDK.

- `wasmedge-types` crate defines the data structures commonly used in `wasmedge-sdk` and `wasmedge-sys`.

- `wasmedge-macro` crate defines the macros that are commonly used in `wasmedge-sdk` and `wasmedge-sys` to declare [host functions](https://webassembly.github.io/spec/core/exec/runtime.html#:~:text=A%20host%20function%20is%20a,a%20module%20as%20an%20import.).

- `async-wasi` crate provides the asynchronous WASI APIs.

## Usage

- Deploy WasmEdge library in your local environment.

  Since this crate depends on the WasmEdge C API, it needs to be installed in your system first. Please refer to [WasmEdge Installation and Uninstallation](../../start/install.md) to install the WasmEdge library. The versioning table below shows the version of the WasmEdge library required by each version of the `wasmedge-sdk` crate.

  | wasmedge-sdk | WasmEdge lib | wasmedge-sys | wasmedge-types | wasmedge-macro | async-wasi |
  | :-: | :-: | :-: | :-: | :-: | :-: |
  | 0.11.0 | 0.13.3 | 0.16.0 | 0.4.3 | 0.6.0 | 0.0.3 |
  | 0.10.1 | 0.13.3 | 0.15.1 | 0.4.2 | 0.5.0 | 0.0.2 |
  | 0.10.0 | 0.13.2 | 0.15.0 | 0.4.2 | 0.5.0 | 0.0.2 |
  | 0.9.0 | 0.13.1 | 0.14.0 | 0.4.2 | 0.4.0 | 0.0.1 |
  | 0.9.0 | 0.13.0 | 0.14.0 | 0.4.2 | 0.4.0 | 0.0.1 |
  | 0.8.1 | 0.12.1 | 0.13.1 | 0.4.1 | 0.3.0 | - |
  | 0.8.0 | 0.12.0 | 0.13.0 | 0.4.1 | 0.3.0 | - |
  | 0.7.1 | 0.11.2 | 0.12.2 | 0.3.1 | 0.3.0 | - |
  | 0.7.0 | 0.11.2 | 0.12 | 0.3.1 | 0.3.0 | - |
  | 0.6.0 | 0.11.2 | 0.11 | 0.3.0 | 0.2.0 | - |
  | 0.5.0 | 0.11.1 | 0.10 | 0.3.0 | 0.1.0 | - |
  | 0.4.0 | 0.11.0 | 0.9 | 0.2.1 | - | - |
  | 0.3.0 | 0.10.1 | 0.8 | 0.2 | - | - |
  | 0.1.0 | 0.10.0 | 0.7 | 0.1 | - | - |

  WasmEdge Rust SDK can automatically search the following paths for the WasmEdge library:

  - `/usr/local` (Linux/macOS)
  - `$HOME/.wasmedge` (Linux/macOS)

    Note that if you have installed the WasmEdge library in a different path, you can set the `WASMEDGE_INCLUDE_DIR` and `WASMEDGE_LIB_DIR` environment variables to the path of the WasmEdge library.

- Add `wasmedge-sdk` crate to your `Cargo.toml` file. Note that, according to the versioning table, the version of `wasmedge-sdk` matching `WasmEdge v0.13.3` is `0.11.0`.

  ```toml
  wasmedge-sdk = ""0.11.0""
  ```

**Notice:** The minimum supported Rust version is 1.68.

## Examples

[wasmedge-rustsdk-examples](https://github.com/second-state/wasmedge-rustsdk-examples/tree/main) provides a set of examples to demonstrate how to use `wasmedge-sdk` to, for example, create host functions, create WebAssembly libraries, create plug-ins, etc.
","**Summary**

The provided code is a documentation for the WasmEdge Rust SDK, which consists of five crates: `wasmedge-sdk`, `wasmedge-sys`, `wasmedge-types`, `wasmedge-macro`, and `async-wasi`. The SDK provides safe, ergonomic high-level APIs for developers to build business applications. It relies on the WasmEdge C API, which needs to be installed in the system first.

**Key Components**

* `wasmedge-sdk` crate: defines a group of safe, ergonomic high-level APIs
* `wasmedge-sys` crate: wrapper of WasmEdge C-API and provides safe counterparts
* `wasmedge-types` crate: defines data structures commonly used in `wasmedge-sdk` and `wasmedge-sys`
* `wasmedge-macro` crate: defines macros for declaring host functions
* `async-wasi` crate: provides asynchronous WASI APIs

**Usage**

1. Deploy WasmEdge library in your local environment.
2. Add `wasmedge-sdk` crate to your `Cargo.toml` file with the correct version.

**Notice**

* Minimum supported Rust version is 1.68.
* The versioning table shows the required version of the WasmEdge library for each version of `wasmedge-sdk`.

**Examples**

The provided link points to a repository containing examples of how to use the `wasmedge-sdk` crate.

**Potential Issues/Improvements**

* The documentation does not provide clear instructions on how to install the WasmEdge C API.
* The versioning table could be more concise and easier to read.
* Consider adding more examples or tutorials to help developers get started with the SDK."
i18n/zh/docusaurus-plugin-content-docs/current/embed/rust/intro.md,"---
sidebar_position: 1
---

# WasmEdge Rust SDK

## Overview

WasmEdge Rust SDK consists of five crates:

- `wasmedge-sdk` crate defines a group of safe, ergonomic high-level APIs developers use to build up their own business applications.

- `wasmedge-sys` crate is a wrapper of WasmEdge C-API and provides safe counterparts. It is not recommended to use it directly by application developers. `wasmedge-sys`, `wasmedge-types`, and `wasmedge-macro` constitute the low-level layer of WasmEdge Rust SDK.

- `wasmedge-types` crate defines the data structures commonly used in `wasmedge-sdk` and `wasmedge-sys`.

- `wasmedge-macro` crate defines the macros that are commonly used in `wasmedge-sdk` and `wasmedge-sys` to declare [host functions](https://webassembly.github.io/spec/core/exec/runtime.html#:~:text=A%20host%20function%20is%20a,a%20module%20as%20an%20import.).

- `async-wasi` crate provides the asynchronous WASI APIs.

## Usage

- Deploy WasmEdge library in your local environment.

  Since this crate depends on the WasmEdge C API, it needs to be installed in your system first. Please refer to [WasmEdge Installation and Uninstallation](../../start/install.md) to install the WasmEdge library. The versioning table below shows the version of the WasmEdge library required by each version of the `wasmedge-sdk` crate.

  | wasmedge-sdk | WasmEdge lib | wasmedge-sys | wasmedge-types | wasmedge-macro | async-wasi |
  | :-: | :-: | :-: | :-: | :-: | :-: |
  | 0.11.0 | 0.13.3 | 0.16.0 | 0.4.3 | 0.6.0 | 0.0.3 |
  | 0.10.1 | 0.13.3 | 0.15.1 | 0.4.2 | 0.5.0 | 0.0.2 |
  | 0.10.0 | 0.13.2 | 0.15.0 | 0.4.2 | 0.5.0 | 0.0.2 |
  | 0.9.0 | 0.13.1 | 0.14.0 | 0.4.2 | 0.4.0 | 0.0.1 |
  | 0.9.0 | 0.13.0 | 0.14.0 | 0.4.2 | 0.4.0 | 0.0.1 |
  | 0.8.1 | 0.12.1 | 0.13.1 | 0.4.1 | 0.3.0 | - |
  | 0.8.0 | 0.12.0 | 0.13.0 | 0.4.1 | 0.3.0 | - |
  | 0.7.1 | 0.11.2 | 0.12.2 | 0.3.1 | 0.3.0 | - |
  | 0.7.0 | 0.11.2 | 0.12 | 0.3.1 | 0.3.0 | - |
  | 0.6.0 | 0.11.2 | 0.11 | 0.3.0 | 0.2.0 | - |
  | 0.5.0 | 0.11.1 | 0.10 | 0.3.0 | 0.1.0 | - |
  | 0.4.0 | 0.11.0 | 0.9 | 0.2.1 | - | - |
  | 0.3.0 | 0.10.1 | 0.8 | 0.2 | - | - |
  | 0.1.0 | 0.10.0 | 0.7 | 0.1 | - | - |

  WasmEdge Rust SDK can automatically search the following paths for the WasmEdge library:

  - `/usr/local` (Linux/macOS)
  - `$HOME/.wasmedge` (Linux/macOS)

    Note that if you have installed the WasmEdge library in a different path, you can set the `WASMEDGE_INCLUDE_DIR` and `WASMEDGE_LIB_DIR` environment variables to the path of the WasmEdge library.

- Add `wasmedge-sdk` crate to your `Cargo.toml` file. Note that, according to the versioning table, the version of `wasmedge-sdk` matching `WasmEdge v0.13.3` is `0.11.0`.

  ```toml
  wasmedge-sdk = ""0.11.0""
  ```

**Notice:** The minimum supported Rust version is 1.68.

## Examples

[wasmedge-rustsdk-examples](https://github.com/second-state/wasmedge-rustsdk-examples/tree/main) provides a set of examples to demonstrate how to use `wasmedge-sdk` to, for example, create host functions, create WebAssembly libraries, create plug-ins, etc.
","**Summary**

The provided code is a documentation file for the WasmEdge Rust SDK, which is a set of five crates for building business applications with WebAssembly (WASM). The crates are:

1. `wasmedge-sdk`: A high-level API crate that provides safe and ergonomic APIs.
2. `wasmedge-sys`: A wrapper of the WasmEdge C-API that provides safe counterparts.
3. `wasmedge-types`: A crate that defines common data structures used in the SDK.
4. `wasmedge-macro`: A crate that defines macros for declaring host functions.
5. `async-wasi`: A crate that provides asynchronous WASI APIs.

**Key Components**

1. **Overview**: An introduction to the WasmEdge Rust SDK, its crates, and their purposes.
2. **Usage**: Instructions on how to deploy the WasmEdge library, add the `wasmedge-sdk` crate to a project, and configure environment variables for searching the WasmEdge library.
3. **Examples**: A link to a repository containing example code demonstrating how to use the `wasmedge-sdk` crate.

**Potential Issues or Areas for Improvement**

1. **Versioning Table**: The versioning table appears to be incomplete, as some versions are missing dependencies. It would be helpful to ensure that the table is comprehensive and up-to-date.
2. **Installation Instructions**: While the installation instructions are provided, they might benefit from being more concise and user-friendly. For example, including a step-by-step guide for installing the WasmEdge library on different operating systems.
3. **Documentation**: The documentation seems to be focused primarily on the usage section, but additional documentation could be beneficial for users who want to delve deeper into the SDK's features and implementation details.

**Minimum Supported Rust Version**

The minimum supported Rust version is specified as 1.68, which might limit the compatibility of the SDK with older versions of Rust."
docs/embed/go/ai.md,"---
sidebar_position: 5
---

# AI Inference with TensorFlow

<!-- prettier-ignore -->
:::note
The WasmEdge extensions have been deprecated after the v0.12.1 version. We'll update to use the WasmEdge plug-in in the future.
:::

In this section, we will show you how to create a TensorFlow or TensorFlow-Lite inference function in Rust for image classification and then embed it into a Go application. The project source code is [available here](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_TfliteFood/).

## The WASM app in Rust

The Rust function for image classification is [available here](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_TfliteFood/rust_tflite_food/src/lib.rs). It utilizes the WasmEdge Tensorflow Lite plug-in as well as the [wasmedge_bindgen](function.md) for passing call parameters.

```rust
#[wasmedge_bindgen]
fn infer(image_data: Vec<u8>) -> Result<Vec<u8>, String> {
  let img = image::load_from_memory(&image_data).unwrap().to_rgb8();
  let flat_img = image::imageops::thumbnail(&img, 192, 192);

  let model_data: &[u8] = include_bytes!(""lite-model_aiy_vision_classifier_food_V1_1.tflite"");
  let labels = include_str!(""aiy_food_V1_labelmap.txt"");

  let mut session = wasmedge_tensorflow_interface::TFLiteSession::new(model_data);
  session.add_input(""input"", &flat_img).run();
  let res_vec: Vec<u8> = session.get_output(""MobilenetV1/Predictions/Softmax"");
  ... ...
}
```

## Compile the Rust code to Wasm

You can build the standard `Cargo` command into a WebAssembly function.

```bash
git clone https://github.com/second-state/WasmEdge-go-examples.git
cd go_TfliteFood/rust_tflite_food
cargo build --target wasm32-wasi --release
cp target/wasm32-wasi/release/rust_tflite_food_lib.wasm ../
cd ../
```

You can use our AOT compiler `wasmedge compile` to instrument the WebAssembly file to make it run much faster. [Learn more](../../start/build-and-run/aot.md).

```bash
wasmedge compile rust_tflite_food_lib.wasm rust_tflite_food_lib.wasm
```

## Go host app

The [Go host app](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_TfliteFood/tflite_food.go) source code shows how to instantiate a WasmEdge runtime with the Tensorflow extension, and how to pass the image data to the Rust function in WasmEdge to run the inference.

```go
import (
  ""fmt""
  ""io/ioutil""
  ""os""

  ""github.com/second-state/WasmEdge-go/wasmedge""
  bindgen ""github.com/second-state/wasmedge-bindgen/host/go""
)

func main() {
  fmt.Println(""Go: Args:"", os.Args)
  // Expected Args[0]: program name (./mobilenet)
  // Expected Args[1]: wasm file (rust_mobilenet_lib.wasm)
  // Expected Args[2]: input image name (grace_hopper.jpg)

  // Set not to print debug info
  wasmedge.SetLogErrorLevel()

  // Set Tensorflow not to print debug info
  os.Setenv(""TF_CPP_MIN_LOG_LEVEL"", ""3"")
  os.Setenv(""TF_CPP_MIN_VLOG_LEVEL"", ""3"")

  // Load WasmEdge-image and WasmEdge-tensorflow from default path
  wasmedge.LoadPluginDefaultPaths()

  // Create configure
  var conf = wasmedge.NewConfigure(wasmedge.WASI)

  // Create VM with configure
  var vm = wasmedge.NewVMWithConfig(conf)

  // Init WASI
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{"".:.""}, // The mapping preopens
  )

  // Load and validate the wasm
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()

  // Instantiate the bindgen and vm
  bg := bindgen.New(vm)
  bg.Instantiate()

  img, _ := ioutil.ReadFile(os.Args[2])
  if res, _, err := bg.Execute(""infer"", img); err != nil {
    fmt.Println(err)
  } else {
    fmt.Println(res[0].(string))
  }

  bg.Release()
  vm.Release()
  conf.Release()
}
```

## Build and run the wasm app from your go host

<!-- prettier-ignore -->
:::note
Ensure you have installed [Go, WasmEdge, and WasmEdge Go SDK with the TensorFlow extension](intro.md).
:::

Builds the Go host application with the WasmEdge Go SDK.

```bash
go build
```

Now you can run the Go application. It calls the WebAssembly function in WasmEdge to run inference on the input image.

```bash
./tflite_food rust_tflite_food_lib.wasm food.jpg
```

The results are as follows.

```bash
Go: Args: [./tflite_food rust_tflite_food_lib.wasm food.jpg]
It is very likely a Hot dog in the picture
```
","**Summary**

The provided code is a demonstration of how to create a TensorFlow or TensorFlow-Lite inference function in Rust for image classification and then embed it into a Go application using WasmEdge. The project source code is available on GitHub.

**Key Components**

1. **Rust Function**: The `infer` function uses the WasmEdge Tensorflow Lite plug-in and wasmedge_bindgen to pass call parameters.
2. **WebAssembly (WASM) App**: The Rust code is compiled into a WASM file using Cargo, which can be run in WasmEdge.
3. **Go Host App**: The Go host app uses the WasmEdge Go SDK to instantiate a WasmEdge runtime with the Tensorflow extension and pass image data to the Rust function to run inference.

**Potential Issues or Areas for Improvement**

1. **WasmEdge Extension Deprecation**: The code still uses the deprecated WasmEdge extensions, which may cause issues in future versions.
2. **Error Handling**: Error handling is minimal in both the Rust and Go code, making it difficult to debug issues that arise during execution.
3. **Security Considerations**: Running WASM code in a web browser or other untrusted environment can pose security risks. The code does not appear to include any sandboxing or isolation mechanisms.
4. **Performance Optimization**: While WasmEdge provides an AOT compiler for performance optimization, the code does not demonstrate how to use this feature.

**Best Practices**

1. **Follow Standard Coding Guidelines**: Both Rust and Go have established coding guidelines (e.g., Rust Style Guide, Go Code Review Comments) that should be followed.
2. **Use Modern Language Features**: The code can benefit from using modern language features such as Rust's `async/await` or Go's `context.Context`.
3. **Document Code Thoroughly**: Adding comments and documentation to both the Rust and Go code would make it easier for others to understand how the code works.

By addressing these areas of improvement, the code can become more robust, maintainable, and secure while adhering to best practices in both Rust and Go development."
i18n/zh/docusaurus-plugin-content-docs/current/embed/go/ai.md,"---
sidebar_position: 5
---

# AI Inference with TensorFlow

<!-- prettier-ignore -->
:::note
The WasmEdge extensions have been deprecated after the v0.12.1 version. We'll update to use the WasmEdge plug-in in the future.
:::

In this section, we will show you how to create a TensorFlow or TensorFlow-Lite inference function in Rust for image classification and then embed it into a Go application. The project source code is [available here](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_TfliteFood/).

## The WASM app in Rust

The Rust function for image classification is [available here](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_TfliteFood/rust_tflite_food/src/lib.rs). It utilizes the WasmEdge Tensorflow Lite plug-in as well as the [wasmedge_bindgen](function.md) for passing call parameters.

```rust
#[wasmedge_bindgen]
fn infer(image_data: Vec<u8>) -> Result<Vec<u8>, String> {
  let img = image::load_from_memory(&image_data).unwrap().to_rgb8();
  let flat_img = image::imageops::thumbnail(&img, 192, 192);

  let model_data: &[u8] = include_bytes!(""lite-model_aiy_vision_classifier_food_V1_1.tflite"");
  let labels = include_str!(""aiy_food_V1_labelmap.txt"");

  let mut session = wasmedge_tensorflow_interface::TFLiteSession::new(model_data);
  session.add_input(""input"", &flat_img).run();
  let res_vec: Vec<u8> = session.get_output(""MobilenetV1/Predictions/Softmax"");
  ... ...
}
```

## Compile the Rust code to Wasm

You can build the standard `Cargo` command into a WebAssembly function.

```bash
git clone https://github.com/second-state/WasmEdge-go-examples.git
cd go_TfliteFood/rust_tflite_food
cargo build --target wasm32-wasi --release
cp target/wasm32-wasi/release/rust_tflite_food_lib.wasm ../
cd ../
```

You can use our AOT compiler `wasmedge compile` to instrument the WebAssembly file to make it run much faster. [Learn more](../../start/build-and-run/aot.md).

```bash
wasmedge compile rust_tflite_food_lib.wasm rust_tflite_food_lib.wasm
```

## Go host app

The [Go host app](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_TfliteFood/tflite_food.go) source code shows how to instantiate a WasmEdge runtime with the Tensorflow extension, and how to pass the image data to the Rust function in WasmEdge to run the inference.

```go
import (
  ""fmt""
  ""io/ioutil""
  ""os""

  ""github.com/second-state/WasmEdge-go/wasmedge""
  bindgen ""github.com/second-state/wasmedge-bindgen/host/go""
)

func main() {
  fmt.Println(""Go: Args:"", os.Args)
  // Expected Args[0]: program name (./mobilenet)
  // Expected Args[1]: wasm file (rust_mobilenet_lib.wasm)
  // Expected Args[2]: input image name (grace_hopper.jpg)

  // Set not to print debug info
  wasmedge.SetLogErrorLevel()

  // Set Tensorflow not to print debug info
  os.Setenv(""TF_CPP_MIN_LOG_LEVEL"", ""3"")
  os.Setenv(""TF_CPP_MIN_VLOG_LEVEL"", ""3"")

  // Load WasmEdge-image and WasmEdge-tensorflow from default path
  wasmedge.LoadPluginDefaultPaths()

  // Create configure
  var conf = wasmedge.NewConfigure(wasmedge.WASI)

  // Create VM with configure
  var vm = wasmedge.NewVMWithConfig(conf)

  // Init WASI
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{"".:.""}, // The mapping preopens
  )

  // Load and validate the wasm
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()

  // Instantiate the bindgen and vm
  bg := bindgen.New(vm)
  bg.Instantiate()

  img, _ := ioutil.ReadFile(os.Args[2])
  if res, _, err := bg.Execute(""infer"", img); err != nil {
    fmt.Println(err)
  } else {
    fmt.Println(res[0].(string))
  }

  bg.Release()
  vm.Release()
  conf.Release()
}
```

## Build and run the wasm app from your go host

<!-- prettier-ignore -->
:::note
Ensure you have installed [Go, WasmEdge, and WasmEdge Go SDK with the TensorFlow extension](intro.md).
:::

Builds the Go host application with the WasmEdge Go SDK.

```bash
go build
```

Now you can run the Go application. It calls the WebAssembly function in WasmEdge to run inference on the input image.

```bash
./tflite_food rust_tflite_food_lib.wasm food.jpg
```

The results are as follows.

```bash
Go: Args: [./tflite_food rust_tflite_food_lib.wasm food.jpg]
It is very likely a Hot dog in the picture
```
","**Summary**

This is a documentation on using WebAssembly (Wasm) to run TensorFlow Lite inference functions in Rust and embed them into a Go application. The code uses the WasmEdge Tensorflow extension for running inference.

**Key Components**

* **Rust Function**: A function written in Rust that performs image classification using TensorFlow Lite.
* **WasmEdge Tensorflow Extension**: Used to enable TensorFlow support on WasmEdge.
* **WASM App**: The Rust function is compiled into a WASM file, which can be executed by the Go host application.
* **Go Host App**: A Go application that loads the WASM file and calls the `infer` function with an image input.

**Functionality**

1. The Rust function performs image classification using TensorFlow Lite.
2. The Rust function is compiled into a WASM file.
3. The Go host app loads the WASM file and instantiates a WasmEdge runtime with the TensorFlow extension.
4. The Go host app calls the `infer` function with an image input.
5. The `infer` function performs the image classification using TensorFlow Lite.

**Potential Issues/Improvements**

* **Performance**: Running inference on Wasm can be slower than running native code. Optimizing the Rust code or using a more efficient compilation target (e.g., AOT) may improve performance.
* **Security**: WebAssembly has built-in security features, such as sandboxing and memory safety checks. However, ensure that the input data is properly validated to prevent potential attacks.
* **Debugging**: WasmEdge provides some debugging tools, but debugging a complex application can still be challenging. Consider using additional debugging tools or techniques.

**Example Use Case**

This code demonstrates how to use WasmEdge with TensorFlow Lite for image classification tasks in Rust and Go applications. It can be used as a starting point for more complex tasks, such as object detection or segmentation."
docs/develop/rust/wasinn/pytorch.md,"---
sidebar_position: 2
---

# PyTorch Backend

We will use [this example project](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/pytorch-mobilenet-image) to show how to make AI inference with a PyTorch model in WasmEdge and Rust.

## Prerequisite

Besides the [regular WasmEdge and Rust requirements](../../rust/setup.md), please make sure that you have the [Wasi-NN plugin with PyTorch installed](../../../start/install.md#wasi-nn-plug-in-with-pytorch-backend).

## Quick start

Because the example already includes a compiled WASM file from the Rust code, we could use WasmEdge CLI to execute the example directly. First, git clone the `WasmEdge-WASINN-examples` repo.

```bash
git clone https://github.com/second-state/WasmEdge-WASINN-examples.git
cd WasmEdge-WASINN-examples/pytorch-mobilenet-image/
```

Run the inference application in WasmEdge.

```bash
wasmedge --dir .:. wasmedge-wasinn-example-mobilenet-image.wasm mobilenet.pt input.jpg
```

If everything goes well, you should have the terminal output:

```bash
Read torchscript binaries, size in bytes: 14376924
Loaded graph into wasi-nn with ID: 0
Created wasi-nn execution context with ID: 0
Read input tensor, size in bytes: 602112
Executed graph inference
   1.) [954](20.6681)banana
   2.) [940](12.1483)spaghetti squash
   3.) [951](11.5748)lemon
   4.) [950](10.4899)orange
   5.) [953](9.4834)pineapple, ananas
```

## Build and run

Let's build the wasm file from the rust source code. First, git clone the `WasmEdge-WASINN-examples` repo.

```bash
git clone https://github.com/second-state/WasmEdge-WASINN-examples.git
cd WasmEdge-WASINN-examples/pytorch-mobilenet-image/rust
```

Second, use `cargo` to build the example project.

```bash
cargo build --target wasm32-wasi --release
```

The output WASM file is `target/wasm32-wasi/release/wasmedge-wasinn-example-mobilenet-image.wasm`. Next, use WasmEdge to load the PyTorch model and then use it to classify objects in your image.

```bash
wasmedge --dir .:. wasmedge-wasinn-example-mobilenet-image.wasm mobilenet.pt input.jpg
```

You can replace `input.jpg` with your image file.

## Improve performance

You can make the inference program run faster by AOT compiling the `wasm` file first.

```bash
wasmedge compile wasmedge-wasinn-example-mobilenet.wasm out.wasm
wasmedge --dir .:. out.wasm mobilenet.pt input.jpg
```

## Understand the code

The [main.rs](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/pytorch-mobilenet-image/rust/src/main.rs) is the complete example Rust source. First, read the image file and PyTorch model file names from the command line.

```rust
let args: Vec<String> = env::args().collect();
let model_bin_name: &str = &args[1]; // File name for the PyTorch model
let image_name: &str = &args[2]; // File name for the input image
```

We use a helper function called `image_to_tensor()` to convert the input image into tensor data (the tensor type is `F32`). Now we can load the model, feed the tensor array from the image to the model, and get the inference output tensor array.

```rust
// load model
let graph = wasi_nn::GraphBuilder::new(
    wasi_nn::GraphEncoding::Pytorch,
    wasi_nn::ExecutionTarget::CPU,
).build_from_files([model_bin_name]).unwrap();
let mut context = graph.init_execution_context().unwrap();

// Load a tensor that precisely matches the graph input tensor
let tensor_data = image_to_tensor(image_name.to_string(), 224, 224);
context.set_input(0, wasi_nn::TensorType::F32, &[1, 3, 224, 224], &tensor_data).unwrap();

// Execute the inference.
context.compute().unwrap();

// Retrieve the output.
let mut output_buffer = vec![0f32; 1000];
context.get_output(0, &mut output_buffer).unwrap();
```

In the above code, `wasi_nn::GraphEncoding::Pytorch` means using the PyTorch backend, and `wasi_nn::ExecutionTarget::CPU` means running the computation on the CPU. Finally, we sort the output and then print the top-5 classification results.

```rust
let results = sort_results(&output_buffer);
for i in 0..5 {
  println!(
    ""   {}.) [{}]({:.4}){}"",
    i + 1,
    results[i].0,
    results[i].1,
    imagenet_classes::IMAGENET_CLASSES[results[i].0]
  );
}
```
","**Summary**

The code is a Rust implementation of an AI inference application using the PyTorch model in WasmEdge and Rust. The application can classify objects in an image by loading the pre-trained PyTorch model and feeding it with tensor data from the input image.

**Key Components**

1. **Main Function**: Reads image file name and PyTorch model file name from command line arguments.
2. **Image to Tensor**: Converts input image into tensor data (F32 type).
3. **Load Model**: Loads PyTorch model using Wasi-NN plugin with PyTorch backend.
4. **Feed Input**: Sets the input tensor from image data to the loaded model.
5. **Inference**: Executes inference on the loaded model using CPU execution target.
6. **Get Output**: Retrieves output tensor from the executed inference.
7. **Sort Results**: Sorts output tensor and prints top-5 classification results.

**Potential Issues or Areas for Improvement**

1. **Error Handling**: The code lacks error handling, which can lead to crashes if exceptions occur during model loading, input feeding, inference execution, or output retrieval.
2. **Optimization**: The code does not optimize the PyTorch model for WasmEdge and Rust, which may result in performance bottlenecks.
3. **Image Preprocessing**: The code assumes that the input image is preprocessed (e.g., resized) to match the model's expected input shape.
4. **Model Selection**: The code loads a fixed PyTorch model (mobilenet.pt), but it would be better to provide a mechanism for selecting different models or architectures.

**Recommendations**

1. Add error handling mechanisms to ensure robustness and reliability.
2. Optimize the PyTorch model for WasmEdge and Rust using techniques like AOT compilation, graph optimization, or model pruning.
3. Implement image preprocessing steps (e.g., resizing) in the code to ensure that the input image matches the expected shape of the loaded model.
4. Develop a mechanism for selecting different models or architectures at runtime to support experimentation and customization."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/wasinn/pytorch.md,"---
sidebar_position: 2
---

# PyTorch Backend

We will use [this example project](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/pytorch-mobilenet-image) to show how to make AI inference with a PyTorch model in WasmEdge and Rust.

## Prerequisite

Besides the [regular WasmEdge and Rust requirements](../../rust/setup.md), please make sure that you have the [Wasi-NN plugin with PyTorch installed](../../../start/install.md#wasi-nn-plug-in-with-pytorch-backend).

## Quick start

Because the example already includes a compiled WASM file from the Rust code, we could use WasmEdge CLI to execute the example directly. First, git clone the `WasmEdge-WASINN-examples` repo.

```bash
git clone https://github.com/second-state/WasmEdge-WASINN-examples.git
cd WasmEdge-WASINN-examples/pytorch-mobilenet-image/
```

Run the inference application in WasmEdge.

```bash
wasmedge --dir .:. wasmedge-wasinn-example-mobilenet-image.wasm mobilenet.pt input.jpg
```

If everything goes well, you should have the terminal output:

```bash
Read torchscript binaries, size in bytes: 14376924
Loaded graph into wasi-nn with ID: 0
Created wasi-nn execution context with ID: 0
Read input tensor, size in bytes: 602112
Executed graph inference
   1.) [954](20.6681)banana
   2.) [940](12.1483)spaghetti squash
   3.) [951](11.5748)lemon
   4.) [950](10.4899)orange
   5.) [953](9.4834)pineapple, ananas
```

## Build and run

Let's build the wasm file from the rust source code. First, git clone the `WasmEdge-WASINN-examples` repo.

```bash
git clone https://github.com/second-state/WasmEdge-WASINN-examples.git
cd WasmEdge-WASINN-examples/pytorch-mobilenet-image/rust
```

Second, use `cargo` to build the example project.

```bash
cargo build --target wasm32-wasi --release
```

The output WASM file is `target/wasm32-wasi/release/wasmedge-wasinn-example-mobilenet-image.wasm`. Next, use WasmEdge to load the PyTorch model and then use it to classify objects in your image.

```bash
wasmedge --dir .:. wasmedge-wasinn-example-mobilenet-image.wasm mobilenet.pt input.jpg
```

You can replace `input.jpg` with your image file.

## Improve performance

You can make the inference program run faster by AOT compiling the `wasm` file first.

```bash
wasmedge compile wasmedge-wasinn-example-mobilenet.wasm out.wasm
wasmedge --dir .:. out.wasm mobilenet.pt input.jpg
```

## Understand the code

The [main.rs](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/pytorch-mobilenet-image/rust/src/main.rs) is the complete example Rust source. First, read the image file and PyTorch model file names from the command line.

```rust
let args: Vec<String> = env::args().collect();
let model_bin_name: &str = &args[1]; // File name for the PyTorch model
let image_name: &str = &args[2]; // File name for the input image
```

We use a helper function called `image_to_tensor()` to convert the input image into tensor data (the tensor type is `F32`). Now we can load the model, feed the tensor array from the image to the model, and get the inference output tensor array.

```rust
// load model
let graph = wasi_nn::GraphBuilder::new(
    wasi_nn::GraphEncoding::Pytorch,
    wasi_nn::ExecutionTarget::CPU,
).build_from_files([model_bin_name]).unwrap();
let mut context = graph.init_execution_context().unwrap();

// Load a tensor that precisely matches the graph input tensor
let tensor_data = image_to_tensor(image_name.to_string(), 224, 224);
context.set_input(0, wasi_nn::TensorType::F32, &[1, 3, 224, 224], &tensor_data).unwrap();

// Execute the inference.
context.compute().unwrap();

// Retrieve the output.
let mut output_buffer = vec![0f32; 1000];
context.get_output(0, &mut output_buffer).unwrap();
```

In the above code, `wasi_nn::GraphEncoding::Pytorch` means using the PyTorch backend, and `wasi_nn::ExecutionTarget::CPU` means running the computation on the CPU. Finally, we sort the output and then print the top-5 classification results.

```rust
let results = sort_results(&output_buffer);
for i in 0..5 {
  println!(
    ""   {}.) [{}]({:.4}){}"",
    i + 1,
    results[i].0,
    results[i].1,
    imagenet_classes::IMAGENET_CLASSES[results[i].0]
  );
}
```
","**Code Summary**

The provided code is a tutorial on how to make AI inference with a PyTorch model in WasmEdge and Rust. The tutorial covers the following topics:

1. Prerequisites: It lists the necessary dependencies, including WasmEdge, Rust, and the Wasi-NN plugin with PyTorch installed.
2. Quick start: It guides the reader through executing an example program using the WasmEdge CLI to run a PyTorch model on a WASM file compiled from Rust code.
3. Build and run: It provides instructions on how to build the WASM file from the Rust source code and run it in WasmEdge.
4. Improve performance: It suggests AOT compiling the WASM file for faster inference.

**Key Components**

1. `wasi_nn::GraphEncoding::Pytorch`: This specifies that the PyTorch backend is used to load the model.
2. `wasi_nn::ExecutionTarget::CPU`: This specifies that the computation is run on the CPU.
3. `image_to_tensor()`: A helper function that converts an image file into a tensor data structure.
4. `GraphBuilder` and `GraphEncoding`: Classes for building and encoding PyTorch graphs.

**Potential Issues or Areas for Improvement**

1. The code assumes that the reader has already installed WasmEdge, Rust, and the Wasi-NN plugin with PyTorch. It might be helpful to provide a step-by-step installation guide.
2. The quick start section may not work if the reader's environment is different from the one assumed in the tutorial.
3. The build and run instructions assume that the reader has basic knowledge of Rust and WASM development. Additional guidance or examples for beginners would be beneficial.
4. The improve performance section suggests AOT compiling, but it's unclear how to integrate this with WasmEdge. More information on this topic might be useful.

Overall, the code provides a good starting point for exploring PyTorch model inference in WasmEdge and Rust. With some additional guidance and explanations, it could be even more effective as a tutorial."
docs/start/faq.md,"---
sidebar_position: 4
---

# Frequently Asked Questions

This FAQ page is designed to address the most common technical questions about WasmEdge. If your question is not directly answered here, please refer to the WasmEdge [documentation](https://wasmedge.org/docs/) or engage with the WasmEdge community via discord.

## 1. How does WasmEdge handle memory sharing between modules?

WasmEdge follows the WebAssembly specification, which currently does not support shared memory between different modules. Each module has its own linear memory space. This is because WebAssembly modules are isolated and cannot directly access each other's memory 1. However, it is possible to manually copy data from one module to another using host functions

## 2. Can WasmEdge support model training?

As of now, WasmEdge supports [model inference](https://www.secondstate.io/articles/fast-llm-inference/). It uses the WASI-NN API to make predictions using pre-trained models. However, model training is not yet supported. It only allows for the execution of pre-trained models.

## 3. What is the internal flow of WasmEdge?

The WasmEdge runtime follows a general flow: parsing the Wasm file, validating the parsed Wasm file, compiling the validated Wasm file into native code, and then executing the compiled code. For more detailed information, please refer to the WasmEdge runtime [documentation](https://wasmedge.org/docs/).

## 4. Why is my plugin crashing?

If your plugin crashes, it might be due to several reasons. It could be related to incorrect use of the WasmEdge API, or the plugin may be incompatible with the WasmEdge version you're using. It's recommended to debug the plugin using a debugger tool to get more detailed error information. Also it you should check the [plug-in documentation](https://wasmedge.org/docs/contribute/plugin/test_plugin)

## 5. How to create a VM to call `infer()` in a Wasm library?

You can use the WASI-NN API to call the `infer()` function in a Wasm library. First, you need to prepare the model, inputs, and outputs. Then, you can call the `infer()` function with these parameters.

## 6. Can WasmEdge support Tensorflow as its inference backend using WASI-NN?

Yes, WasmEdge can use Tensorflow as its [inference](https://wasmedge.org/docs/embed/go/ai/) backend through the WASI-NN API.

## 7. How to read a host file in WasmEdge runtime?

WasmEdge provides the WASI (WebAssembly System Interface) API for interacting with the host system, including file operations. You can use the [WASI API](https://wasmedge.org/docs/embed/go/reference/0.11.x?_highlight=wasi&_highlight=api#preregistrations) to open and read files from the host system.

## 8. What's the relationship between WasmEdge and Second State

The relationship between WasmEdge and Second State is rooted in the latter contributing their WasmEdge Runtime project to the Cloud Native Computing Foundation (CNCF). Subsequently, Second State became one of the maintainers for WasmEdge. As WasmEdge seeks to broaden its community, it continues to search for additional maintainers.

Please remember, this FAQ page is not exhaustive, and the WasmEdge community is always ready to help with any questions or issues you may have. Don't hesitate to reach out if you need assistance in our [Discord server](https://discord.gg/h4KDyB8XTt).


","**Summary:**

This FAQ document provides answers to common technical questions about WasmEdge, a WebAssembly runtime. The document covers topics such as memory sharing between modules, model training support, the internal flow of WasmEdge, debugging plugins, creating VMs for inference, and interacting with the host system using WASI APIs.

**Key Components:**

1. **Memory Sharing:** Each module has its own linear memory space, and there is no direct support for shared memory.
2. **Model Training:** Model training is not supported; only model inference is available through the WASI-NN API.
3. **Internal Flow:** WasmEdge follows a general flow of parsing, validating, compiling, and executing Wasm files.
4. **Debugging Plugins:** Debugging plugins using debugger tools is recommended to get detailed error information.

**Potential Issues:**

1. **Limited Support for Shared Memory:** The lack of direct shared memory support between modules may cause issues in certain use cases.
2. **No Model Training Support:** Users may need to rely on pre-trained models or third-party libraries for model training.

**Areas for Improvement:**

1. **Documentation:** While the FAQ document is helpful, providing more detailed documentation and tutorials for specific topics would be beneficial.
2. **Community Engagement:** Encouraging community involvement through forums, mailing lists, or issue trackers could lead to a more vibrant and responsive community.

Overall, this FAQ document provides valuable information about WasmEdge's capabilities and limitations, making it an essential resource for developers working with the platform."
docs/embed/go/app.md,"---
sidebar_position: 2
---

# Embed a standalone WASM app

The WasmEdge Go SDK can [embed standalone WebAssembly applications](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile) — ie a Rust application with a `main()` function compiled into WebAssembly.

## The WASM app in Rust

Our [demo Rust application](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile/rust_readfile) reads from a file. Note that the WebAssembly program's input and output data are now passed by the STDIN and STDOUT.

```rust
use std::env;
use std::fs::File;
use std::io::{self, BufRead};

fn main() {
  // Get the argv.
  let args: Vec<String> = env::args().collect();
  if args.len() <= 1 {
    println!(""Rust: ERROR - No input file name."");
    return;
  }

  // Open the file.
  println!(""Rust: Opening input file \""{}\""..."", args[1]);
  let file = match File::open(&args[1]) {
    Err(why) => {
      println!(""Rust: ERROR - Open file \""{}\"" failed: {}"", args[1], why);
      return;
    },
    Ok(file) => file,
  };

  // Read lines.
  let reader = io::BufReader::new(file);
  let mut texts:Vec<String> = Vec::new();
  for line in reader.lines() {
    if let Ok(text) = line {
      texts.push(text);
    }
  }
  println!(""Rust: Read input file \""{}\"" succeeded."", args[1]);

  // Get stdin to print lines.
  println!(""Rust: Please input the line number to print the line of file."");
  let stdin = io::stdin();
  for line in stdin.lock().lines() {
    let input = line.unwrap();
    match input.parse::<usize>() {
      Ok(n) => if n > 0 && n <= texts.len() {
        println!(""{}"", texts[n - 1]);
      } else {
        println!(""Rust: ERROR - Line \""{}\"" is out of range."", n);
      },
      Err(e) => println!(""Rust: ERROR - Input \""{}\"" is not an integer: {}"", input, e),
    }
  }
  println!(""Rust: Process end."");
}
```

## Compile the Rust code into Wasm

Next, let's compile the application into WebAssembly.

```bash
git clone https://github.com/second-state/WasmEdge-go-examples.git
cd rust_readfile
cargo build --target wasm32-wasi
# The output file will be target/wasm32-wasi/debug/rust_readfile.wasm
```

## The Go Host app

The Go source code to run the WebAssembly function in WasmEdge is as follows.

```go
package main

import (
  ""os""
  ""github.com/second-state/WasmEdge-go/wasmedge""
)

func main() {
  wasmedge.SetLogErrorLevel()

  var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)
  conf.AddConfig(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{"".:.""}, // The mapping directories
  )

  // Instantiate wasm. _start refers to the main() function
  vm.RunWasmFile(os.Args[1], ""_start"")

  vm.Release()
  conf.Release()
}
```

## Run the compiled WASM file from Go host

::note Make sure you have installed [Go, WasmEdge, and WasmEdge Go SDK](intro.md). ::

Next, let's build the Go application with the WasmEdge Go SDK.

```bash
go build
```

Run the Golang application.

```bash
$ ./read_file rust_readfile/target/wasm32-wasi/debug/rust_readfile.wasm file.txt
Rust: Opening input file ""file.txt""...
Rust: Read input file ""file.txt"" succeeded.
Rust: Please input the line number to print the line of file.
# Input ""5"" and press Enter.
5
# The output will be the 5th line of `file.txt`:
abcDEF___!@#$%^
# To terminate the program, send the EOF (Ctrl + D).
^D
# The output will print the terminate message:
Rust: Process end.
```

More examples can be found at [the WasmEdge-go-examples GitHub repo.](https://github.com/second-state/WasmEdge-go-examples)
","**Summary:**

This code demonstrates how to embed a standalone WebAssembly (WASM) application in Go using the WasmEdge Go SDK. The example includes a Rust application that reads from a file and a Go host application that runs the WASM function.

**Key Components:**

1. **Rust Application:** A simple Rust program that reads lines from a file and asks for user input to print specific lines.
2. **WASM Compilation:** The Rust code is compiled into WebAssembly using `cargo build --target wasm32-wasi`.
3. **Go Host Application:** A Go program that uses the WasmEdge SDK to run the WASM function, passing arguments and environment variables.
4. **WASM Execution:** The Go host application runs the WASM file and captures its output.

**Potential Issues/Improvements:**

1. Error handling: While some error cases are handled in the Rust code, others might be missed (e.g., when reading from the file or parsing user input).
2. Code organization: The Go host application combines setup, WASM execution, and cleanup into a single function. Consider breaking it down into smaller functions for better readability.
3. Performance: If the WASM application is complex or computationally intensive, consider using more efficient memory management techniques, such as manual memory allocation.
4. Security: Be mindful of potential security risks when executing user-supplied input (e.g., via `io.Stdin`). Consider implementing additional security checks or validation.

Overall, this example showcases a basic workflow for embedding WASM applications in Go, but may benefit from further refinement and error handling to make it more robust and secure."
i18n/zh/docusaurus-plugin-content-docs/current/embed/go/app.md,"---
sidebar_position: 2
---

# Embed a standalone WASM app

The WasmEdge Go SDK can [embed standalone WebAssembly applications](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile) — ie a Rust application with a `main()` function compiled into WebAssembly.

## The WASM app in Rust

Our [demo Rust application](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile/rust_readfile) reads from a file. Note that the WebAssembly program's input and output data are now passed by the STDIN and STDOUT.

```rust
use std::env;
use std::fs::File;
use std::io::{self, BufRead};

fn main() {
  // Get the argv.
  let args: Vec<String> = env::args().collect();
  if args.len() <= 1 {
    println!(""Rust: ERROR - No input file name."");
    return;
  }

  // Open the file.
  println!(""Rust: Opening input file \""{}\""..."", args[1]);
  let file = match File::open(&args[1]) {
    Err(why) => {
      println!(""Rust: ERROR - Open file \""{}\"" failed: {}"", args[1], why);
      return;
    },
    Ok(file) => file,
  };

  // Read lines.
  let reader = io::BufReader::new(file);
  let mut texts:Vec<String> = Vec::new();
  for line in reader.lines() {
    if let Ok(text) = line {
      texts.push(text);
    }
  }
  println!(""Rust: Read input file \""{}\"" succeeded."", args[1]);

  // Get stdin to print lines.
  println!(""Rust: Please input the line number to print the line of file."");
  let stdin = io::stdin();
  for line in stdin.lock().lines() {
    let input = line.unwrap();
    match input.parse::<usize>() {
      Ok(n) => if n > 0 && n <= texts.len() {
        println!(""{}"", texts[n - 1]);
      } else {
        println!(""Rust: ERROR - Line \""{}\"" is out of range."", n);
      },
      Err(e) => println!(""Rust: ERROR - Input \""{}\"" is not an integer: {}"", input, e),
    }
  }
  println!(""Rust: Process end."");
}
```

## Compile the Rust code into Wasm

Next, let's compile the application into WebAssembly.

```bash
git clone https://github.com/second-state/WasmEdge-go-examples.git
cd rust_readfile
cargo build --target wasm32-wasi
# The output file will be target/wasm32-wasi/debug/rust_readfile.wasm
```

## The Go Host app

The Go source code to run the WebAssembly function in WasmEdge is as follows.

```go
package main

import (
  ""os""
  ""github.com/second-state/WasmEdge-go/wasmedge""
)

func main() {
  wasmedge.SetLogErrorLevel()

  var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)
  conf.AddConfig(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{"".:.""}, // The mapping directories
  )

  // Instantiate wasm. _start refers to the main() function
  vm.RunWasmFile(os.Args[1], ""_start"")

  vm.Release()
  conf.Release()
}
```

## Run the compiled WASM file from Go host

::note Make sure you have installed [Go, WasmEdge, and WasmEdge Go SDK](intro.md). ::

Next, let's build the Go application with the WasmEdge Go SDK.

```bash
go build
```

Run the Golang application.

```bash
$ ./read_file rust_readfile/target/wasm32-wasi/debug/rust_readfile.wasm file.txt
Rust: Opening input file ""file.txt""...
Rust: Read input file ""file.txt"" succeeded.
Rust: Please input the line number to print the line of file.
# Input ""5"" and press Enter.
5
# The output will be the 5th line of `file.txt`:
abcDEF___!@#$%^
# To terminate the program, send the EOF (Ctrl + D).
^D
# The output will print the terminate message:
Rust: Process end.
```

More examples can be found at [the WasmEdge-go-examples GitHub repo.](https://github.com/second-state/WasmEdge-go-examples)
","**Summary**

This code provides a tutorial on how to embed a standalone WebAssembly (WASM) application in Go using the WasmEdge Go SDK. The example uses a Rust application compiled into WASM that reads from a file, and a Go host program that runs the WASM function.

**Key Components**

1. **Rust Application**: A simple Rust application that reads from a file and prints its lines.
2. **Compilation to WASM**: Compiling the Rust application using Cargo to generate a WASM file.
3. **Go Host Program**: A Go program that uses the WasmEdge Go SDK to run the compiled WASM function.

**Functionality**

The Go host program:

1. Initializes the WasmEdge engine with the WASI (WebAssembly System Interface) configuration.
2. Loads the compiled WASM file into memory.
3. Calls the `_start` function, which is equivalent to the Rust application's `main()` function.
4. Exposes the WASI interface to the Rust application.

**Potential Issues and Areas for Improvement**

1. **Error Handling**: The code assumes that the WASM compilation and loading process will be successful. In a real-world scenario, error handling should be implemented to handle potential issues, such as file loading errors or WasmEdge engine initialization failures.
2. **Security**: As with any web assembly execution environment, there are security concerns related to executing untrusted code. The code does not implement any security measures, such as sandboxing or access control lists, which may be necessary depending on the use case.
3. **Performance Optimization**: The code assumes that the WasmEdge engine is optimized for performance, but this may not always be the case in real-world scenarios. Performance optimizations could be implemented to improve execution speed.

**Code Quality**

The code is well-structured and follows standard Rust and Go coding conventions. However, there are some minor improvements that could be made:

1. **Commenting**: While the code has comments, they are mostly brief and do not provide sufficient context for understanding the code's logic.
2. **Type Annotations**: Some type annotations are missing, which may make it harder to understand the code's intent."
docs/develop/deploy/intro.md,"---
sidebar_position: 1
---

# Introduction

WasmEdge could be integrated with the existing cloud-native infra seamlessly. So developers can leverage container tools such as Kubernetes, Docker, and CRI-O to deploy, manage, and run lightweight WebAssembly applications. This chapter will demonstrate how Kubernetes ecosystem tools work with WasmEdge WebAssembly applications.

Several options exist to manage WASM apps as “containers” under Kubernetes. Both options will give you a Kubernetes cluster that runs Linux containers and WASM containers side by side.

## With containerd-shim

**Option #1:** is to use a containerd-shim to start WASM ""containers"" via runwasi. Basically containerd could look at the image’s target platform. It uses runwasi if the image is wasm32 and runc if it is x86 / arm. Currently, Docker and Microsoft prefer this approach, which is also the basis for the [Docker + WASM preview](https://www.docker.com/blog/docker-wasm-technical-preview/). Based on containerd

The following image shows how it works.

![Containerd](containerd.png)

## With crun

Option #2 is to use an OCI runtime called crun (the C version of runc, mainly supported by Red Hat). crun decides whether an OCI image is wasm or Linux based on image annotations. If the image is annotated as wasm32, crun will bypass Linux container setup and just use WasmEdge to run it. Based on crun, we can get the entire Kubernetes stack CRI-O, containerd, Podman, kind, micro k8s, k8s etc to work with WASM images.

## With youki

Option #3 is to use an OCI runtime called youki (the Rust version of runc). Like crun, youki decides whether an OCI image is wasm or Linux based on image annotations. If the image is annotated as wasm32, youki will bypass Linux container setup and just use WasmEdge to run it. Based on youki, we can get the entire Kubernetes stack CRI-O, containerd, Podman, kind, micro k8s, k8s etc to work with WASM images.

Both crun and youki could use the following image to show how it works.

![Kubernetes](kubernetes.png)

## Examples we covered

This section will show how to manage WASM App in three different ways. The goal is to load and run WebAssembly OCI images alongside Linux OCI images (e.g., today's Docker containers) across the Kubernetes stack.

We will cover two different demos in most cases. We built them from Rust source code, built OCI images around them, and then published them to Docker Hub. You can find the more container example [here](https://github.com/second-state/wasmedge-containers-examples).

- [A simple WASI example](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md)
- [A HTTP server example](https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md)

Since we have already built and published those demo apps on Docker Hub, you could also pull the images from Docker Hub. If you want to build your own WASM image, please refer to this article.

Since we have already built and published those demo apps on Docker Hub, you could also just go straight to the container runtime sections to use these images.

Let's get started.
","**Summary**

The provided code is not a traditional software code, but rather a documentation or tutorial on how to integrate WasmEdge with container tools such as Kubernetes, Docker, and CRI-O. The document describes three options (containerd-shim, crun, and youki) for managing WebAssembly applications as ""containers"" under Kubernetes.

**Key Components**

1. **WasmEdge**: A WebAssembly runtime that allows running Wasm applications on various platforms.
2. **Container tools**: Tools such as Kubernetes, Docker, and CRI-O that are used to deploy, manage, and run containers.
3. **containerd-shim**: A container runtime shim for starting WASM ""containers"" via runwasi.
4. **crun** and **youki**: OCI runtimes that decide whether an image is wasm or Linux based on image annotations.

**Functionality**

The document demonstrates how to manage Wasm applications in three different ways:

1. Using containerd-shim to start WASM ""containers"" via runwasi.
2. Using crun or youki to bypass Linux container setup and just use WasmEdge to run wasm images.

**Potential Issues or Areas for Improvement**

1. The document assumes a certain level of familiarity with Kubernetes and container tools, which might be a barrier for readers who are new to these technologies.
2. The document does not provide detailed instructions on how to build and publish WASM images, making it challenging for readers to follow along.
3. There is no clear guidance on troubleshooting issues that may arise during the integration process.

**Recommendations**

1. Consider adding more detailed instructions and examples to help readers understand the concepts better.
2. Provide clearer guidance on troubleshooting issues that may arise during the integration process.
3. Consider creating a separate document or tutorial for readers who are new to Kubernetes and container tools."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/intro.md,"---
sidebar_position: 1
---

# Introduction

WasmEdge could be integrated with the existing cloud-native infra seamlessly. So developers can leverage container tools such as Kubernetes, Docker, and CRI-O to deploy, manage, and run lightweight WebAssembly applications. This chapter will demonstrate how Kubernetes ecosystem tools work with WasmEdge WebAssembly applications.

Several options exist to manage WASM apps as “containers” under Kubernetes. Both options will give you a Kubernetes cluster that runs Linux containers and WASM containers side by side.

## With containerd-shim

**Option #1:** is to use a containerd-shim to start WASM ""containers"" via runwasi. Basically containerd could look at the image’s target platform. It uses runwasi if the image is wasm32 and runc if it is x86 / arm. Currently, Docker and Microsoft prefer this approach, which is also the basis for the [Docker + WASM preview](https://www.docker.com/blog/docker-wasm-technical-preview/). Based on containerd

The following image shows how it works.

![Containerd](containerd.png)

## With crun

Option #2 is to use an OCI runtime called crun (the C version of runc, mainly supported by Red Hat). crun decides whether an OCI image is wasm or Linux based on image annotations. If the image is annotated as wasm32, crun will bypass Linux container setup and just use WasmEdge to run it. Based on crun, we can get the entire Kubernetes stack CRI-O, containerd, Podman, kind, micro k8s, k8s etc to work with WASM images.

## With youki

Option #3 is to use an OCI runtime called youki (the Rust version of runc). Like crun, youki decides whether an OCI image is wasm or Linux based on image annotations. If the image is annotated as wasm32, youki will bypass Linux container setup and just use WasmEdge to run it. Based on youki, we can get the entire Kubernetes stack CRI-O, containerd, Podman, kind, micro k8s, k8s etc to work with WASM images.

Both crun and youki could use the following image to show how it works.

![Kubernetes](kubernetes.png)

## Examples we covered

This section will show how to manage WASM App in three different ways. The goal is to load and run WebAssembly OCI images alongside Linux OCI images (e.g., today's Docker containers) across the Kubernetes stack.

We will cover two different demos in most cases. We built them from Rust source code, built OCI images around them, and then published them to Docker Hub. You can find the more container example [here](https://github.com/second-state/wasmedge-containers-examples).

- [A simple WASI example](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md)
- [A HTTP server example](https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md)

Since we have already built and published those demo apps on Docker Hub, you could also pull the images from Docker Hub. If you want to build your own WASM image, please refer to this article.

Since we have already built and published those demo apps on Docker Hub, you could also just go straight to the container runtime sections to use these images.

Let's get started.
","**Summary**

This document provides an introduction to integrating WasmEdge with Kubernetes, a cloud-native infrastructure. It explains how to manage WebAssembly (WASM) applications as ""containers"" under Kubernetes using three options: containerd-shim, crun, and youki. The document demonstrates how each option works by providing examples of running WASM applications alongside Linux containers.

**Key Components**

1. **Containerd-shim**: Uses runwasi to start WASM ""containers"" via target platform checks.
2. **Crun**: Decides whether an OCI image is wasm or Linux based on image annotations and uses WasmEdge to run it if annotated as wasm32.
3. **Youki**: Similar to crun, decides whether an OCI image is wasm or Linux based on image annotations and uses WasmEdge to run it if annotated as wasm32.
4. **OCI (Open Container Initiative)**: An open standard for containerization.

**Potential Issues or Areas for Improvement**

1. **Complexity**: The document assumes a certain level of technical knowledge about containerization, Kubernetes, and WasmEdge, which may make it difficult to understand for beginners.
2. **Limited Examples**: While the document provides two demo examples, more concrete use cases and scenarios would help readers better understand how to apply this knowledge in practice.
3. **Missing Details**: Some sections, such as the containerd-shim example, are brief and lack detailed explanations or code snippets.

**Suggestions**

1. **Break down complex topics**: Divide the document into smaller sections or create separate documents for each topic to make it easier to understand and digest.
2. **Add more examples**: Include more concrete use cases, such as running multiple WASM applications together or integrating with other Kubernetes features like Persistent Volumes.
3. **Provide code snippets and configurations**: Include code examples or configuration files to help readers implement the concepts presented in the document."
docs/develop/c/hello_world.md,"---
sidebar_position: 1
---

# Hello World

This chapter will take Hello World as an example to show how to compile a C program to WASM bytecode and run it in WasmEdge.

## Prerequisites

Before we start, make sure you have installed the following software:

1. [Install WasmEdge](../../start/install.md#install)

2. Emscripten, a toolchain for compiling C/C++ to WebAssembly. Please refer to the [emcc official repository](https://github.com/emscripten-core/emsdk) for detailed instructions.

```bash
git clone --depth 1 https://github.com/emscripten-core/emsdk.git
cd emsdk
./emsdk install latest
./emsdk activate latest
source ./emsdk_env.sh
```

## Example: Hello World

### Compile the C code into Wasm

As the first step is always the ""Hello World"" program, given below is the C program implementation.

```c
// hello.c

#include<stdio.h>
int main(int argc,char **argv){
  printf(""Hello World!\n"");
  return 0;
}
```

Save it in any file and then compile it to WebAssembly with emscripten.

```bash
emcc hello.c -o hello.wasm
```

<!-- prettier-ignore -->
:::note
Make sure you either supply `-s STANDALONE_WASM` flag or specify output as wasm `-o your_file_name.wasm`
:::

Then run the wasm in wasmedge runtime.

```bash
$ wasmedge hello.wasm
Hello World
```

### Run in WasmEdge

Run the compiled wasm with WasmEdge CLI, and you will get the hello world output.

```bash
$ wasmedge hello.wasm
Hello, world!
```

### AoT mode

With WasmEdge's AoT compiler, you will get higher performance.

```bash
# Compile the wasm file with wasmedge aot compiler
$ wasmedgec hello.wasm hello.wasm
# Run the native binary with wasmedge
$ wasmedge hello.wasm
```

## Example: Add function

We can also pass cmd arguments. For example, add function takes two arguments and prints their sum in this example.

```c
// add.c

#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
  int a,b;
  if(argc==3){
    a = atoi(argv[1]);
    b = atoi(argv[2]);
    printf(""%d\n"",a+b);
  }
  return 0;
}
```

Again Compiling to wasm with emcc

```bash
emcc add.c -o add.wasm
```

Running the application in wasmedge runtime

```bash
$ wasmedge add.wasm 2 3
5
```

We can further improve performance by using wasmedge AOT compilation , this feature gives near native performance

```bash
$ wasmedgec add.wasm add_aot.wasm
$ wasmedge add_aot.wasm 4 9
13
```

## Example: Fibonacci function

We can also structure our project in separate header and implementation files.

```c
// fibonacci.h

int fib(int n);
```

```c
// fibonacci.c

#include <stdio.h>
#include ""fibonacci.h""

int fib(int n){
  int f1 = 0;
  int f2 = 1;
  if(n<=2){
    if(n==1) return f1;
    else return f2;
  }
  else
    for(int i=2; i<n; i++ ){
      int temp = f2;
      f2=f1+f2;
      f1=temp;
    }
  return f2;
}
```

```c
// main.c

#include <stdio.h>
#include <stdlib.h>
#include ""fibonacci.h""

int main(int argc, char *argv[])
{
  if (argc<2) {
    return 0;
  }
  int n = atoi(argv[1]);
  printf(""%d"",fib(n));
  return 0;
}
```

Compiling the program to wasm with emcc

```bash
emcc main.c fibonacci.c -o fib.wasm
```

Running in wasmedge runtime

```bash
$ wasmedge fib.wasm 6
5
```
","**Summary**

This document provides a step-by-step guide on how to compile C programs into WebAssembly (WASM) bytecode and run them using WasmEdge. The examples include:

1. A basic ""Hello World"" program
2. An ""Add function"" that takes two arguments
3. A Fibonacci function

The compilation process involves using the Emscripten toolchain, which compiles C/C++ code to WASM.

**Key Components**

1. **Emscripten**: a toolchain for compiling C/C++ to WebAssembly (WASM)
2. **WasmEdge**: a runtime environment for executing WASM bytecode
3. **emcc**: the Emscripten compiler that generates WASM bytecode from C/C++ code

**Potential Issues or Areas for Improvement**

1. The guide assumes that users have already installed Emscripten and WasmEdge, which may not be the case for all users.
2. The compilation process can be complex and error-prone, especially for users who are new to WebAssembly development.
3. The guide could benefit from more detailed explanations of the compilation process and potential pitfalls.

**Code Quality**

The code examples provided in this document appear to be well-structured and easy to follow. However, there is some redundancy in the code, such as repeated printf statements. Additionally, some of the functions (e.g., `fib`) could benefit from additional comments or documentation to explain their purpose and behavior.

Overall, the guide provides a solid introduction to compiling C programs into WASM bytecode using Emscripten and running them with WasmEdge. However, there are opportunities for improvement in terms of clarity, concision, and code quality."
i18n/zh/docusaurus-plugin-content-docs/current/develop/c/hello_world.md,"---
sidebar_position: 1
---

# Hello World

This chapter will take Hello World as an example to show how to compile a C program to WASM bytecode and run it in WasmEdge.

## Prerequisites

Before we start, make sure you have installed the following software:

1. [Install WasmEdge](../../start/install.md#install)

2. Emscripten, a toolchain for compiling C/C++ to WebAssembly. Please refer to the [emcc official repository](https://github.com/emscripten-core/emsdk) for detailed instructions.

```bash
git clone --depth 1 https://github.com/emscripten-core/emsdk.git
cd emsdk
./emsdk install latest
./emsdk activate latest
source ./emsdk_env.sh
```

## Example: Hello World

### Compile the C code into Wasm

As the first step is always the ""Hello World"" program, given below is the C program implementation.

```c
// hello.c

#include<stdio.h>
int main(int argc,char **argv){
  printf(""Hello World!\n"");
  return 0;
}
```

Save it in any file and then compile it to WebAssembly with emscripten.

```bash
emcc hello.c -o hello.wasm
```

<!-- prettier-ignore -->
:::note
Make sure you either supply `-s STANDALONE_WASM` flag or specify output as wasm `-o your_file_name.wasm`
:::

Then run the wasm in wasmedge runtime.

```bash
$ wasmedge hello.wasm
Hello World
```

### Run in WasmEdge

Run the compiled wasm with WasmEdge CLI, and you will get the hello world output.

```bash
$ wasmedge hello.wasm
Hello, world!
```

### AoT mode

With WasmEdge's AoT compiler, you will get higher performance.

```bash
# Compile the wasm file with wasmedge aot compiler
$ wasmedgec hello.wasm hello.wasm
# Run the native binary with wasmedge
$ wasmedge hello.wasm
```

## Example: Add function

We can also pass cmd arguments. For example, add function takes two arguments and prints their sum in this example.

```c
// add.c

#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
  int a,b;
  if(argc==3){
    a = atoi(argv[1]);
    b = atoi(argv[2]);
    printf(""%d\n"",a+b);
  }
  return 0;
}
```

Again Compiling to wasm with emcc

```bash
emcc add.c -o add.wasm
```

Running the application in wasmedge runtime

```bash
$ wasmedge add.wasm 2 3
5
```

We can further improve performance by using wasmedge AOT compilation , this feature gives near native performance

```bash
$ wasmedgec add.wasm add_aot.wasm
$ wasmedge add_aot.wasm 4 9
13
```

## Example: Fibonacci function

We can also structure our project in separate header and implementation files.

```c
// fibonacci.h

int fib(int n);
```

```c
// fibonacci.c

#include <stdio.h>
#include ""fibonacci.h""

int fib(int n){
  int f1 = 0;
  int f2 = 1;
  if(n<=2){
    if(n==1) return f1;
    else return f2;
  }
  else
    for(int i=2; i<n; i++ ){
      int temp = f2;
      f2=f1+f2;
      f1=temp;
    }
  return f2;
}
```

```c
// main.c

#include <stdio.h>
#include <stdlib.h>
#include ""fibonacci.h""

int main(int argc, char *argv[])
{
  if (argc<2) {
    return 0;
  }
  int n = atoi(argv[1]);
  printf(""%d"",fib(n));
  return 0;
}
```

Compiling the program to wasm with emcc

```bash
emcc main.c fibonacci.c -o fib.wasm
```

Running in wasmedge runtime

```bash
$ wasmedge fib.wasm 6
5
```
","**Summary:**

This documentation is for the Docusaurus plugin content-docs, which provides a tutorial on compiling C programs to WebAssembly (WASM) bytecode using Emscripten and running them in WasmEdge. The tutorial covers various examples, including ""Hello World"", adding functions, and calculating Fibonacci numbers.

**Key Components:**

1. **Emscripten**: A toolchain for compiling C/C++ code to WASM.
2. **WasmEdge**: A runtime environment for executing WASM code.
3. **AOT compilation**: Ahead-of-time compilation in WasmEdge for improved performance.
4. **Examples**: ""Hello World"", adding functions, and calculating Fibonacci numbers.

**Functionality:**

1. Compile C code to WASM using Emscripten.
2. Run the compiled WASM code in WasmEdge.
3. Use AOT compilation for improved performance.

**Potential Issues or Areas for Improvement:**

1. **Error handling**: The tutorial assumes that users will follow the instructions correctly and doesn't provide error handling mechanisms for common mistakes, such as incorrect compiler flags or missing dependencies.
2. **Code organization**: The code examples are not well-organized, with functions and variables declared in different files without clear documentation on how to use them.
3. **Performance optimization**: While AOT compilation is mentioned as a performance optimization technique, the tutorial doesn't provide detailed instructions on how to use it effectively.

**Suggestions:**

1. Add error handling mechanisms for common user mistakes.
2. Improve code organization and documentation for better usability.
3. Provide more detailed instructions on using AOT compilation for improved performance."
docs/contribute/source/plugin/ebpf.md,"---
sidebar_position: 7
---

# Build with eBPF Plug-in

The eBPF (extended Berkeley Packet Filter) plug-in provides an interface to execute eBPF programs in WasmEdge. It allows WasmEdge to execute eBPF code that is compiled into WebAssembly format. This guide will walk you through the steps to build WasmEdge with the eBPF plug-in.

## Build the eBPF Plug-in

### Prerequisites

Before building the eBPF plug-in, ensure that you have the following installed:

* WasmEdge - If you haven't installed it, follow the [follow the guide to build from source](../os/linux.md).
* libbpf - This plug-in requires `libbpf >= 1.2`. See [Building libbpf](https://github.com/libbpf/libbpf#building-libbpf) for details.

### Build steps

To build the eBPF plug-in, run the following commands at the root of the WasmEdge project:

```bash
cmake -DWASMEDGE_PLUGIN_WASM_BPF:BOOL=TRUE -B ./build -G ""Unix Makefiles""
cmake --build ./build
```

Make sure to set `WASMEDGE_PLUGIN_WASM_BPF` to `TRUE` in the command line. This toggle controls the build of the `wasm_bpf` plug-in.

## Use the eBPF Plug-in

### Download Examples

You can download examples of wasm-bpf programs from here:

```bash
wget https://eunomia-bpf.github.io/wasm-bpf/examples/runqlat/runqlat.wasm
```

### Build Examples

You can also build examples of wasm-bpf programs from the `wasm-bpf` repository:

1. Install the wasi-sdk if you don't have it:

   ```bash
   wget https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-17/wasi-sdk-17.0-linux.tar.gz
   tar -zxf wasi-sdk-17.0-linux.tar.gz
   sudo mkdir -p /opt/wasi-sdk/ && sudo mv wasi-sdk-17.0/* /opt/wasi-sdk/
   ```

2. Build the examples:

   ```bash
   git clone https://github.com/eunomia-bpf/wasm-bpf
   cd wasm-bpf/examples
   git submodule update --init --recursive
   ```

3. For example, to build the execve example:

```bash
cd execve && make
```

The available examples are:

```bash
bootstrap  execve  go-execve  go-lsm  lsm   opensnoop runqlat  rust-bootstrap  sockfilter  sockops
```

### Run Examples

After building, you can find the plug-in at `./build/plugins/wasm_bpf/libwasmedgePluginWasmBpf.so` and the WasmEdge CLI tool at `./build/tools/wasmedge/wasmedge`.

To run the examples, set `WASMEDGE_PLUGIN_PATH=./build/plugins/wasm_bpf/` and run wasmedge:

```bash
WASMEDGE_PLUGIN_PATH=./build/plugins/wasm_bpf/ ./build/tools/wasmedge/wasmedge execve.wasm
```

Adjust `WASMEDGE_PLUGIN_PATH` according to your build directory of the plug-in.

## Host Functions

This plug-in adds six host functions that give your Wasm application access to eBPF. All of these functions are in the module `wasm_bpf`, if you loaded this plug-in:

```c
/// lookup a bpf map fd by name.
i32 wasm_bpf_map_fd_by_name(u64 obj, u32 name);
/// detach and close a bpf program.
i32 wasm_close_bpf_object(u64 obj);
/// CO-RE load a bpf object into the kernel.
u64 wasm_load_bpf_object(u32 obj_buf, u32 obj_buf_sz);
/// attach a bpf program to a kernel hook.
i32 wasm_attach_bpf_program(u64 obj, u32 name,
                            u32 attach_target);
/// poll a bpf buffer, and call a wasm callback indicated by sample_func.
/// the first time to call this function will open and create a bpf buffer.
i32 wasm_bpf_buffer_poll(u64 program, i32 fd, u32 sample_func,
                         u32 ctx, u32 data, i32 max_size,
                         i32 timeout_ms);
/// lookup, update, delete, and get_next_key operations on a bpf map.
i32 wasm_bpf_map_operate(u64 fd, i32 cmd, u32 key, u32 value,
                         u32 next_key, u64 flags);
```

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_bpf).
","**Summary:**

The eBPF (extended Berkeley Packet Filter) plug-in for WasmEdge allows executing eBPF programs compiled into WebAssembly format. This guide outlines the steps to build and use the eBPF plug-in.

**Key Components:**

1. Prerequisites:
	* Installed WasmEdge
	* `libbpf >= 1.2`
2. Build Steps:
	* Run `cmake` with flag `-DWASMEDGE_PLUGIN_WASM_BPF:BOOL=TRUE`
	* Run `make` in the build directory
3. Use Examples:
	* Download wasm-bpf programs from a GitHub repository
	* Build examples using `wasi-sdk`
4. Host Functions:
	* Added six host functions for accessing eBPF functionality

**Potential Issues and Areas for Improvement:**

1. **Documentation Quality**: The provided documentation is mostly in code comments, which may not be the most user-friendly format.
2. **Error Handling**: There are no clear guidelines on error handling and debugging strategies for eBPF programs.
3. **Security Considerations**: The guide does not mention any security considerations or best practices when using eBPF functionality.
4. **Platform Compatibility**: The build process is only outlined for Linux, while the documentation mentions other platforms (e.g., Windows) without clear guidance on compatibility.

**Recommendations:**

1. **Improve Documentation**: Provide user-friendly documentation and tutorials for building and using the eBPF plug-in.
2. **Enhance Error Handling**: Develop a comprehensive error handling strategy for eBPF programs, including logging and debugging tools.
3. **Security Guidelines**: Establish clear security guidelines and best practices for using eBPF functionality in WasmEdge applications.
4. **Platform Compatibility**: Provide guidance on building and running the eBPF plug-in on multiple platforms (e.g., Windows)."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/ebpf.md,"---
sidebar_position: 7
---

# Build with eBPF Plug-in

The eBPF (extended Berkeley Packet Filter) plug-in provides an interface to execute eBPF programs in WasmEdge. It allows WasmEdge to execute eBPF code that is compiled into WebAssembly format. This guide will walk you through the steps to build WasmEdge with the eBPF plug-in.

## Build the eBPF Plug-in

### Prerequisites

Before building the eBPF plug-in, ensure that you have the following installed:

* WasmEdge - If you haven't installed it, follow the [follow the guide to build from source](../os/linux.md).
* libbpf - This plug-in requires `libbpf >= 1.2`. See [Building libbpf](https://github.com/libbpf/libbpf#building-libbpf) for details.

### Build steps

To build the eBPF plug-in, run the following commands at the root of the WasmEdge project:

```bash
cmake -DWASMEDGE_PLUGIN_WASM_BPF:BOOL=TRUE -B ./build -G ""Unix Makefiles""
cmake --build ./build
```

Make sure to set `WASMEDGE_PLUGIN_WASM_BPF` to `TRUE` in the command line. This toggle controls the build of the `wasm_bpf` plug-in.

## Use the eBPF Plug-in

### Download Examples

You can download examples of wasm-bpf programs from here:

```bash
wget https://eunomia-bpf.github.io/wasm-bpf/examples/runqlat/runqlat.wasm
```

### Build Examples

You can also build examples of wasm-bpf programs from the `wasm-bpf` repository:

1. Install the wasi-sdk if you don't have it:

   ```bash
   wget https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-17/wasi-sdk-17.0-linux.tar.gz
   tar -zxf wasi-sdk-17.0-linux.tar.gz
   sudo mkdir -p /opt/wasi-sdk/ && sudo mv wasi-sdk-17.0/* /opt/wasi-sdk/
   ```

2. Build the examples:

   ```bash
   git clone https://github.com/eunomia-bpf/wasm-bpf
   cd wasm-bpf/examples
   git submodule update --init --recursive
   ```

3. For example, to build the execve example:

```bash
cd execve && make
```

The available examples are:

```bash
bootstrap  execve  go-execve  go-lsm  lsm   opensnoop runqlat  rust-bootstrap  sockfilter  sockops
```

### Run Examples

After building, you can find the plug-in at `./build/plugins/wasm_bpf/libwasmedgePluginWasmBpf.so` and the WasmEdge CLI tool at `./build/tools/wasmedge/wasmedge`.

To run the examples, set `WASMEDGE_PLUGIN_PATH=./build/plugins/wasm_bpf/` and run wasmedge:

```bash
WASMEDGE_PLUGIN_PATH=./build/plugins/wasm_bpf/ ./build/tools/wasmedge/wasmedge execve.wasm
```

Adjust `WASMEDGE_PLUGIN_PATH` according to your build directory of the plug-in.

## Host Functions

This plug-in adds six host functions that give your Wasm application access to eBPF. All of these functions are in the module `wasm_bpf`, if you loaded this plug-in:

```c
/// lookup a bpf map fd by name.
i32 wasm_bpf_map_fd_by_name(u64 obj, u32 name);
/// detach and close a bpf program.
i32 wasm_close_bpf_object(u64 obj);
/// CO-RE load a bpf object into the kernel.
u64 wasm_load_bpf_object(u32 obj_buf, u32 obj_buf_sz);
/// attach a bpf program to a kernel hook.
i32 wasm_attach_bpf_program(u64 obj, u32 name,
                            u32 attach_target);
/// poll a bpf buffer, and call a wasm callback indicated by sample_func.
/// the first time to call this function will open and create a bpf buffer.
i32 wasm_bpf_buffer_poll(u64 program, i32 fd, u32 sample_func,
                         u32 ctx, u32 data, i32 max_size,
                         i32 timeout_ms);
/// lookup, update, delete, and get_next_key operations on a bpf map.
i32 wasm_bpf_map_operate(u64 fd, i32 cmd, u32 key, u32 value,
                         u32 next_key, u64 flags);
```

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_bpf).
","**Summary**

This document guides users through the process of building and using the WasmEdge eBPF plug-in. The eBPF plug-in allows WasmEdge to execute eBPF code compiled into WebAssembly format.

**Key Components**

1. **Prerequisites**: Users need to have WasmEdge installed and libbpf version 1.2 or later.
2. **Build steps**: Run `cmake` with the flag `-DWASMEDGE_PLUGIN_WASM_BPF:BOOL=TRUE` to enable building the eBPF plug-in.
3. **Use examples**: Download or build wasm-bpf programs, then run them using WasmEdge CLI tool.

**Potential Issues and Areas for Improvement**

1. **Complexity**: The document assumes users have a good understanding of WasmEdge and eBPF concepts, which may not be the case for beginners.
2. **Dependence on libbpf version**: The document requires libbpf version 1.2 or later, which might limit its usability for users with earlier versions.
3. **Limited information on host functions**: While the document provides information on six host functions, it may not be enough to fully understand their usage and implications.

**Recommendations**

1. **Simplify language**: Use more accessible language to make the document easier to understand for beginners.
2. **Provide detailed instructions for libbpf installation**: Offer step-by-step instructions for installing libbpf version 1.2 or later.
3. **Include additional information on host functions**: Provide more details on each host function, including their usage, limitations, and potential applications.

By addressing these areas, the document can become a more comprehensive resource for users interested in using WasmEdge eBPF plug-in."
docs/contribute/source/os/openwrt.md,"---
sidebar_position: 5
---

# Build on OpenWRT

Please follow this tutorial to build and test WasmEdge in OpenWrt(x86_64) from source code.

<!-- prettier-ignore -->
:::note
Currently, we only support the runtime for the interpreter mode.
:::

## Prepare the Environment

### OpenWrt

First, we need to obtain the source code of OpenWrt and install the relevant tools to compile OpenWrt. The following commands take Debian / Ubuntu system as an example. For commands to install OpenWrt compilation tools in other host systems, see [Building OpenWrt System Settings](https://openwrt.org/docs/guide-developer/toolchain/install-buildsystem).

```bash
$ git clone https://github.com/openwrt/openwrt
$ sudo apt update
$ sudo apt install build-essential ccache ecj fastjar file g++ gawk \
gettext git java-propose-classpath libelf-dev libncurses5-dev \
libncursesw5-dev libssl-dev python python2.7-dev python3 unzip wget \
python-distutils-extra python3-setuptools python3-dev rsync subversion \
swig time xsltproc zlib1g-dev
```

Then, obtain all the latest package definitions of OpenWrt and install the symlinks for all obtained packages.

```bash
cd openwrt
./scripts/feeds update -a
./scripts/feeds install -a
```

## Build WasmEdge

### Get WasmEdge source code

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
```

### Run the build script

Run the build script `build_for_openwrt.sh` in WasmEdge source code and input the path of the OpenWrt source code as parameter. This script will automatically add the WasmEdge into the packages list which will be built of OpenWrt, and build the OpenWrt firmware. The generated OpenWrt images are in the `openwrt/bin/targets/x86/64` folder.

```bash
./utils/openwrt/build_for_openwrt.sh ~/openwrt
```

When running the build script, the OpenWrt configuration interface will appear. In this interface, we need to set `Target System` to x86, `Target Profile` to Generic x86/64, and find `WasmEdge` in the `Runtime` column and check it. Once set up, the script automatically builds WasmEdge and compiles the OpenWrt system.

## Test

### Deploy OpenWrt in VMware

To verify the availability of WasmEdge, we use a VMware virtual machine to install the compiled OpenWrt image. Before creating a virtual machine, we must use the `QEMU` command to convert the OpenWrt image to vmdk format.

```bash
cd ~/openwrt/bin/targets/x86/64
sudo apt install qemu
gunzip openwrt-x86-64-generic-squashfs-combined.img.gz
qemu-img convert -f raw -O vmdk openwrt-x86-64-generic-squashfs-combined.img Openwrt.vmdk
```

After that, create a virtual machine in VMware and install the OpenWrt system.

### Upload the test files

After setting the IP address of OpenWrt according to the gateway of the host, use `scp` to transfer the wasm file on the host to the OpenWrt system.

For example, we set the IP address of OpenWrt as 192.168.0.111, then we use the following commands to upload [hello.wasm (compiled from this example)](https://github.com/WasmEdge/WasmEdge/tree/master/examples/wasm) and [add.wasm (in text format)](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/add.wat) these two test files to OpenWrt.

```bash
scp hello.wasm root@192.168.0.111:/
scp add.wasm root@192.168.0.111:/
```

### Test the Wasmedge program

```bash
$ wasmedge hello.wasm second state
hello
second
state
$ wasmedge --reactor add.wasm add 2 2
4
```
","**Summary**

The provided code is a tutorial on how to build and test the WasmEdge runtime in OpenWrt (x86_64) from source code. The tutorial consists of three main sections: preparing the environment, building WasmEdge, and testing.

**Key Components**

1. **Preparing the Environment**: This section guides the reader through obtaining the source code of OpenWrt, installing relevant tools to compile it, and updating package definitions.
2. **Building WasmEdge**: In this section, the reader learns how to obtain WasmEdge source code, run a build script (`build_for_openwrt.sh`) that adds WasmEdge to the OpenWrt packages list and builds the firmware.
3. **Testing**: The final section guides the reader through deploying the compiled OpenWrt image in VMware, converting it to vmdk format using QEMU, and testing WasmEdge programs on the virtual machine.

**Potential Issues or Areas for Improvement**

1. **Build Script Complexity**: The `build_for_openwrt.sh` script appears to perform multiple tasks, including adding packages, building the firmware, and configuring OpenWrt settings. This could make it difficult to debug and maintain.
2. **Package Management**: The tutorial uses `scripts/feeds` to manage packages, which might not be familiar to all users. Providing more context or guidance on package management would be helpful.
3. **Testing Environment**: The tutorial assumes a VMware virtual machine for testing, but this might not be accessible or practical for everyone. Alternative testing environments or instructions could be provided.

**Code Quality and Readability**

The code is generally well-structured and follows standard conventions. However, some sections, such as the build script, could benefit from additional comments or explanations to improve understanding.

Overall, the tutorial provides a clear and concise guide on building and testing WasmEdge in OpenWrt. With some minor adjustments to address potential issues and areas for improvement, it can be an even more valuable resource for developers."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/openwrt.md,"---
sidebar_position: 5
---

# Build on OpenWRT

Please follow this tutorial to build and test WasmEdge in OpenWrt(x86_64) from source code.

<!-- prettier-ignore -->
:::note
Currently, we only support the runtime for the interpreter mode.
:::

## Prepare the Environment

### OpenWrt

First, we need to obtain the source code of OpenWrt and install the relevant tools to compile OpenWrt. The following commands take Debian / Ubuntu system as an example. For commands to install OpenWrt compilation tools in other host systems, see [Building OpenWrt System Settings](https://openwrt.org/docs/guide-developer/toolchain/install-buildsystem).

```bash
$ git clone https://github.com/openwrt/openwrt
$ sudo apt update
$ sudo apt install build-essential ccache ecj fastjar file g++ gawk \
gettext git java-propose-classpath libelf-dev libncurses5-dev \
libncursesw5-dev libssl-dev python python2.7-dev python3 unzip wget \
python-distutils-extra python3-setuptools python3-dev rsync subversion \
swig time xsltproc zlib1g-dev
```

Then, obtain all the latest package definitions of OpenWrt and install the symlinks for all obtained packages.

```bash
cd openwrt
./scripts/feeds update -a
./scripts/feeds install -a
```

## Build WasmEdge

### Get WasmEdge source code

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
```

### Run the build script

Run the build script `build_for_openwrt.sh` in WasmEdge source code and input the path of the OpenWrt source code as parameter. This script will automatically add the WasmEdge into the packages list which will be built of OpenWrt, and build the OpenWrt firmware. The generated OpenWrt images are in the `openwrt/bin/targets/x86/64` folder.

```bash
./utils/openwrt/build_for_openwrt.sh ~/openwrt
```

When running the build script, the OpenWrt configuration interface will appear. In this interface, we need to set `Target System` to x86, `Target Profile` to Generic x86/64, and find `WasmEdge` in the `Runtime` column and check it. Once set up, the script automatically builds WasmEdge and compiles the OpenWrt system.

## Test

### Deploy OpenWrt in VMware

To verify the availability of WasmEdge, we use a VMware virtual machine to install the compiled OpenWrt image. Before creating a virtual machine, we must use the `QEMU` command to convert the OpenWrt image to vmdk format.

```bash
cd ~/openwrt/bin/targets/x86/64
sudo apt install qemu
gunzip openwrt-x86-64-generic-squashfs-combined.img.gz
qemu-img convert -f raw -O vmdk openwrt-x86-64-generic-squashfs-combined.img Openwrt.vmdk
```

After that, create a virtual machine in VMware and install the OpenWrt system.

### Upload the test files

After setting the IP address of OpenWrt according to the gateway of the host, use `scp` to transfer the wasm file on the host to the OpenWrt system.

For example, we set the IP address of OpenWrt as 192.168.0.111, then we use the following commands to upload [hello.wasm (compiled from this example)](https://github.com/WasmEdge/WasmEdge/tree/master/examples/wasm) and [add.wasm (in text format)](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/add.wat) these two test files to OpenWrt.

```bash
scp hello.wasm root@192.168.0.111:/
scp add.wasm root@192.168.0.111:/
```

### Test the Wasmedge program

```bash
$ wasmedge hello.wasm second state
hello
second
state
$ wasmedge --reactor add.wasm add 2 2
4
```
","**Summary**

The provided code is a tutorial on building and testing WasmEdge in OpenWrt (x86_64) from source code. It guides the reader through preparing the environment, building WasmEdge, and testing its functionality.

**Key Components**

1. **Preparing the Environment**: The first step involves obtaining the source code of OpenWrt, installing necessary tools, and updating package definitions.
2. **Building WasmEdge**: This section describes how to obtain the WasmEdge source code, run a build script (`build_for_openwrt.sh`), and configure OpenWrt to include WasmEdge in its build process.
3. **Testing**: The tutorial covers deploying OpenWrt on VMware, uploading test files to the virtual machine, and testing the functionality of WasmEdge using those files.

**Potential Issues/Improvement Areas**

1. **Complexity**: The tutorial assumes a certain level of familiarity with Linux commands and software development tools.
2. **Error Handling**: If any errors occur during the build process or testing, the instructions do not provide clear guidance on how to troubleshoot or recover from those issues.
3. **Cross-Platform Compatibility**: The tutorial focuses on x86_64 architecture; it would be beneficial to explore porting WasmEdge and OpenWrt to other architectures, such as ARM or MIPS.
4. **Security Considerations**: When using OpenWrt and WasmEdge in production environments, security should be a top priority. The tutorial does not address potential security risks or best practices for securing the system.

**Code Quality**

The code itself is well-structured and follows standard Markdown conventions. However, there are some minor formatting issues and redundant sections that can be improved upon. Overall, the code quality is satisfactory, but some refactoring would make it more readable and maintainable."
docs/embed/c++/intro.md,"---
sidebar_position: 1
---

# WasmEdge C++ SDK Introduction

The WasmEdge C++ SDK is a collection of headers and libraries that allow you to build and deploy WebAssembly (Wasm) modules for execution on WasmEdge devices. It includes a CMake project and a set of command-line tools that you can use to build and deploy your Wasm modules.

## Quick Start Guide

To get started with WasmEdge, follow these steps:

Install the WasmEdge C/C++ SDK: Download C++ SDK from the WasmEdge [website](https://wasmedge.org/docs/embed/quick-start/install) and follow the instructions to install it on your development machine

```cpp
#include <wasmedge/wasmedge.h>
#include <iostream>

int main(int argc, char** argv) {
  /* Create the configure context and add the WASI support. */
  /* This step is not necessary unless you need WASI support. */
  WasmEdge_ConfigureContext* conf_cxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(conf_cxt, WasmEdge_HostRegistration_Wasi);
  /* The configure and store context to the VM creation can be NULL. */
  WasmEdge_VMContext* vm_cxt = WasmEdge_VMCreate(conf_cxt, nullptr);

  /* The parameters and returns arrays. */
  WasmEdge_Value params[1] = { WasmEdge_ValueGenI32(40) };
  WasmEdge_Value returns[1];
  /* Function name. */
  WasmEdge_String func_name = WasmEdge_StringCreateByCString(""fib"");
  /* Run the WASM function from file. */
  WasmEdge_Result res = WasmEdge_VMRunWasmFromFile(vm_cxt, argv[1], func_name, params, 1, returns, 1);

  if (WasmEdge_ResultOK(res)) {
    std::cout << ""Get result: "" << WasmEdge_ValueGetI32(returns[0]) << std::endl;
  } else {
    std::cout << ""Error message: "" << WasmEdge_ResultGetMessage(res) << std::endl;
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(vm_cxt);
  WasmEdge_ConfigureDelete(conf_cxt);
  WasmEdge_StringDelete(func_name);
  return 0;
}
```

You can use the -I flag to specify the include directories and the -L and -l flags to specify the library directories and library names, respectively. Then you can compile the code and run: ( the 40th fibonacci number is 102334155)

```bash
gcc example.cpp -x c++ -I/path/to/wasmedge/include -L/path/to/wasmedge/lib -lwasmedge -o example
```

To run the `example` executable that was created in the previous step, you can use the following command

```bash
./example
```

## Quick Start Guide in AOT compiler

```cpp
#include <wasmedge/wasmedge.h>
#include <stdio.h>

int main(int argc, const char* argv[]) {
  // Create the configure context and add the WASI support.
  // This step is not necessary unless you need WASI support.
  wasmedge_configure_context* conf_cxt = wasmedge_configure_create();
  wasmedge_configure_add_host_registration(conf_cxt, WASMEDGE_HOST_REGISTRATION_WASI);

  // Create the VM context in AOT mode.
  wasmedge_vm_context* vm_cxt = wasmedge_vm_create_aot(conf_cxt, NULL);

  // The parameters and returns arrays.
  wasmedge_value params[1] = { wasmedge_value_gen_i32(32) };
  wasmedge_value returns[1];
  // Function name.
  wasmedge_string func_name = wasmedge_string_create_by_cstring(""fib"");
  // Run the WASM function from file.
  wasmedge_result res = wasmedge_vm_run_wasm_from_file(vm_cxt, argv[1], func_name, params, 1, returns, 1);

  if (wasmedge_result_ok(res)) {
    printf(""Get result: %d\n"", wasmedge_value_get_i32(returns[0]));
  } else {
    printf(""Error message: %s\n"", wasmedge_result_get_message(res));
  }

  // Resources deallocations.
  wasmedge_vm_delete(vm_cxt);
  wasmedge_configure_delete(conf_cxt);
  wasmedge_string_delete(func_name);
  return 0;
}
```

In this example, the wasmedge_vm_create_aot function is used to create a wasmedge_vm_context object in AOT mode, which is then passed as the second argument to the wasmedge_vm_run_wasm_from_file function to execute the Wasm module in AOT mode.
","**Summary**

The provided code is an introduction to the WasmEdge C++ SDK, a collection of headers and libraries for building and deploying WebAssembly (WASM) modules on WasmEdge devices. The code includes two examples: one using the Just-In-Time (JIT) compiler and another using the Ahead-Of-Time (AOT) compiler.

**Functionality**

The code demonstrates how to:

1. Create a configure context and add WASI support.
2. Create a VM context in JIT or AOT mode.
3. Define parameters and returns arrays for function execution.
4. Run a Wasm function from file using `WasmEdge_VMRunWasmFromFile` (JIT) or `wasmedge_vm_run_wasm_from_file` (AOT).
5. Print the result of the function execution.

**Key Components**

1. `WasmEdge_ConfigureContext` and `wasmedge_configure_context`: configure context objects for JIT and AOT modes, respectively.
2. `WasmEdge_VMContext` and `wasmedge_vm_context`: VM context objects for JIT and AOT modes, respectively.
3. `WasmEdge_Value` and `wasmedge_value`: value types for parameters and returns.
4. `WasmEdge_String` and `wasmedge_string`: string types for function names.

**Potential Issues**

1. Memory leaks: the code does not explicitly release memory allocated by `WasmEdge_ConfigureCreate`, `WasmEdge_VMCreate`, and `WasmEdge_StringCreateByCString`.
2. Error handling: the code only checks if the result is OK using `WasmEdge_ResultOK` or `wasmedge_result_ok`, but it does not handle potential errors.
3. Compiler-specific code: the AOT example uses compiler-specific functions (`wasmedge_vm_create_aot` and `wasmedge_vm_run_wasm_from_file`) which may not be available in all compilers.

**Improvement Suggestions**

1. Use smart pointers to manage memory allocated by `WasmEdge_ConfigureCreate`, `WasmEdge_VMCreate`, and `WasmEdge_StringCreateByCString`.
2. Handle potential errors by checking the result of function calls and printing error messages.
3. Use compiler-agnostic code or provide separate examples for different compilers."
i18n/zh/docusaurus-plugin-content-docs/current/embed/c++/intro.md,"---
sidebar_position: 1
---

# WasmEdge C++ SDK Introduction

The WasmEdge C++ SDK is a collection of headers and libraries that allow you to build and deploy WebAssembly (Wasm) modules for execution on WasmEdge devices. It includes a CMake project and a set of command-line tools that you can use to build and deploy your Wasm modules.

## Quick Start Guide

To get started with WasmEdge, follow these steps:

Install the WasmEdge C/C++ SDK: Download C++ SDK from the WasmEdge [website](https://wasmedge.org/docs/embed/quick-start/install) and follow the instructions to install it on your development machine

```cpp
#include <wasmedge/wasmedge.h>
#include <iostream>

int main(int argc, char** argv) {
  /* Create the configure context and add the WASI support. */
  /* This step is not necessary unless you need WASI support. */
  WasmEdge_ConfigureContext* conf_cxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(conf_cxt, WasmEdge_HostRegistration_Wasi);
  /* The configure and store context to the VM creation can be NULL. */
  WasmEdge_VMContext* vm_cxt = WasmEdge_VMCreate(conf_cxt, nullptr);

  /* The parameters and returns arrays. */
  WasmEdge_Value params[1] = { WasmEdge_ValueGenI32(40) };
  WasmEdge_Value returns[1];
  /* Function name. */
  WasmEdge_String func_name = WasmEdge_StringCreateByCString(""fib"");
  /* Run the WASM function from file. */
  WasmEdge_Result res = WasmEdge_VMRunWasmFromFile(vm_cxt, argv[1], func_name, params, 1, returns, 1);

  if (WasmEdge_ResultOK(res)) {
    std::cout << ""Get result: "" << WasmEdge_ValueGetI32(returns[0]) << std::endl;
  } else {
    std::cout << ""Error message: "" << WasmEdge_ResultGetMessage(res) << std::endl;
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(vm_cxt);
  WasmEdge_ConfigureDelete(conf_cxt);
  WasmEdge_StringDelete(func_name);
  return 0;
}
```

You can use the -I flag to specify the include directories and the -L and -l flags to specify the library directories and library names, respectively. Then you can compile the code and run: ( the 40th fibonacci number is 102334155)

```bash
gcc example.cpp -x c++ -I/path/to/wasmedge/include -L/path/to/wasmedge/lib -lwasmedge -o example
```

To run the `example` executable that was created in the previous step, you can use the following command

```bash
./example
```

## Quick Start Guide in AOT compiler

```cpp
#include <wasmedge/wasmedge.h>
#include <stdio.h>

int main(int argc, const char* argv[]) {
  // Create the configure context and add the WASI support.
  // This step is not necessary unless you need WASI support.
  wasmedge_configure_context* conf_cxt = wasmedge_configure_create();
  wasmedge_configure_add_host_registration(conf_cxt, WASMEDGE_HOST_REGISTRATION_WASI);

  // Create the VM context in AOT mode.
  wasmedge_vm_context* vm_cxt = wasmedge_vm_create_aot(conf_cxt, NULL);

  // The parameters and returns arrays.
  wasmedge_value params[1] = { wasmedge_value_gen_i32(32) };
  wasmedge_value returns[1];
  // Function name.
  wasmedge_string func_name = wasmedge_string_create_by_cstring(""fib"");
  // Run the WASM function from file.
  wasmedge_result res = wasmedge_vm_run_wasm_from_file(vm_cxt, argv[1], func_name, params, 1, returns, 1);

  if (wasmedge_result_ok(res)) {
    printf(""Get result: %d\n"", wasmedge_value_get_i32(returns[0]));
  } else {
    printf(""Error message: %s\n"", wasmedge_result_get_message(res));
  }

  // Resources deallocations.
  wasmedge_vm_delete(vm_cxt);
  wasmedge_configure_delete(conf_cxt);
  wasmedge_string_delete(func_name);
  return 0;
}
```

In this example, the wasmedge_vm_create_aot function is used to create a wasmedge_vm_context object in AOT mode, which is then passed as the second argument to the wasmedge_vm_run_wasm_from_file function to execute the Wasm module in AOT mode.
","**Summary**

The provided code is an example of using the WasmEdge C++ SDK to execute a WebAssembly (Wasm) module. The code demonstrates how to create a configure context, add WASI support, and run a Wasm function from file in both Just-In-Time (JIT) mode and Ahead-Of-Time (AOT) compilation mode.

**Key Components**

1. `wasmedge/wasmedge.h`: The header file for the WasmEdge C++ SDK.
2. `WasmEdge_ConfigureContext` and `WasmEdge_VMContext`: Structures used to create configure and VM contexts, respectively.
3. `WasmEdge_StringCreateByCString` and `WasmEdge_ValueGenI32`: Functions used to create strings and values (i32 integers).
4. `WasmEdge_VMRunWasmFromFile` and `wasmedge_vm_run_wasm_from_file`: Functions used to run Wasm functions from file in JIT mode and AOT compilation mode, respectively.

**Functionality**

1. Create a configure context and add WASI support.
2. Run a Wasm function from file in both JIT mode and AOT compilation mode.
3. Use the `WasmEdge_Value` struct to store parameters and returns arrays.
4. Deallocation of resources using `WasmEdge_VMDelete`, `WasmEdge_ConfigureDelete`, and `WasmEdge_StringDelete`.

**Potential Issues/Improvements**

1. **Error Handling**: The code does not handle errors properly in some cases, such as when running Wasm functions in AOT mode.
2. **Resource Management**: The code assumes that all resources will be deallocated correctly, but this might not always be the case.
3. **Code Organization**: The example code mixes different modes (JIT and AOT) and use cases (function execution and resource management) in a single file. Consider separating these concerns into different files or modules.

**Example Use Case**

To run this example code, you need to:

1. Install the WasmEdge C++ SDK.
2. Compile the provided code using `gcc`.
3. Run the compiled executable with the required input arguments (e.g., a Wasm file).

Note that this is just an example and may not be the most efficient or production-ready way of working with WasmEdge. For more information, please refer to the official documentation and community resources."
docs/contribute/plugin/develop_plugin_rustsdk.md,"---
sidebar_position: 4
---

# Develop WasmEdge Plug-in in Rust SDK with witc

By developing a plug-in, one can extend the functionality of WasmEdge and customize it to suit specific needs. WasmEdge provides a Rust-based API for registering extension modules and host functions.

```mermaid
graph TD
A[Build WasmEdge from source] -- witc --> B[Generate Rust Plug-in Code]
B -- SDK Crate --> C[Create SDK Crate]
C -- Module File --> D[Create Module File]
D -- Wrapper Functions --> E[Write Wrapper Functions in src/lib.rs]
```

<!-- prettier-ignore -->
:::note
It is recommended that developers choose the WasmEdge [C API](develop_plugin_c.md) for plug-in development because of the support, compatibility, and flexibility the WasmEdge runtime provides.
:::

## Set up the development environment

To start developing WasmEdge plug-ins, it is essential to properly set up the development environment. This section provides step-by-step instructions for WasmEdge plug-in development -

- **Build WasmEdge from source**: For developing the WasmEdge plug-in in C++, you must build WasmEdge from source. Follow the[build WasmEdge from source](../source/build_from_src.md) for instructions. Once you complete the C++ plug-in code, you can use witc[^1] to generate Rust Plug-in SDK.

After installing WasmEdge, you need to set up the build environment. If you're using Linux or other platforms, you can follow the instructions in the [build environment setup guide](../source/os/linux.md).

## Write the plug-in code

To develop a WasmEdge Plug-in in Rust using the witc tool, you can follow these steps:

- **Generate Rust Plug-in Code**: Consider you have a file named `wasmedge_opencvmini.wit` with the following content:

  ```wit
  imdecode: func(buf: list<u8>) -> u32
  imshow: func(window-name: string, mat-key: u32) -> unit
  waitkey: func(delay: u32) -> unit
  ```

  You can use the witc tool to generate Rust plug-in code for it by running the following command:

  ```shell
  witc plugin wasmedge_opencvmini.wit
  ```

- **Create SDK Crate**: You need to create an SDK crate for your plug-in. Run the following command to create a new crate named `opencvmini-sdk`:

  ```shell
  cargo new --lib opencvmini-sdk && cd opencvmini-sdk
  ```

- **Create Module File**: The witc tool puts the Rust code to stdout. To capture the generated code, create a new module file named `src/generated.rs` and run the following command:

  ```shell
  witc plugin wasmedge_opencvmini.wit > src/generated.rs
  ```

- **Write Wrapper Functions**: In the `src/lib.rs` file of your crate, write the following code of `mod generated` to access the generated code and create wrapper functions:

  ```rust
  mod generated;

  pub fn imdecode(buf: &[u8]) -> u32 {
      unsafe { generated::imdecode(buf.as_ptr(), buf.len()) }
  }
  pub fn imshow(window_name: &str, mat_key: u32) -> () {
      unsafe { generated::imshow(window_name.as_ptr(), window_name.len(), mat_key) }
  }
  pub fn waitkey(delay: u32) -> () {
      unsafe { generated::waitkey(delay) }
  }
  ```

  This code imports the generated module and provides safe wrapper functions for each generated function.

[^1]: <https://github.com/second-state/witc>
","**Summary**

The provided code is a guide on how to develop a WasmEdge plug-in in Rust using the witc tool. The guide covers setting up the development environment, generating Rust plug-in code from a .wit file, creating an SDK crate, and writing wrapper functions.

**Key Components**

1. **Wit file**: A .wit file containing the extension module definitions for the plug-in.
2. **witc tool**: A command-line tool used to generate Rust plug-in code from the wit file.
3. **SDK crate**: A Cargo package (library) created to hold the generated Rust code and wrapper functions.
4. **Wrapper functions**: Safe Rust functions that wrap the generated code, providing a safe API for users.

**Potential Issues or Areas for Improvement**

1. **Documentation**: The guide assumes familiarity with WasmEdge, Rust, and Cargo. Adding more documentation on these topics could improve understanding.
2. **Error handling**: The generated code and wrapper functions do not handle errors explicitly. Adding error handling mechanisms would make the code more robust.
3. **Code organization**: The generated code is dumped into a single file (src/generated.rs). Consider organizing it into separate files or modules for better maintainability.
4. **Testing**: There are no tests mentioned in the guide. Adding unit tests and integration tests would ensure the correctness of the generated code and wrapper functions.

Overall, this guide provides a good starting point for developing WasmEdge plug-ins in Rust using witc. With additional documentation, error handling, and testing, it can become a more comprehensive resource for developers."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_rustsdk.md,"---
sidebar_position: 4
---

# Develop WasmEdge Plug-in in Rust SDK with witc

By developing a plug-in, one can extend the functionality of WasmEdge and customize it to suit specific needs. WasmEdge provides a Rust-based API for registering extension modules and host functions.

```mermaid
graph TD
A[Build WasmEdge from source] -- witc --> B[Generate Rust Plug-in Code]
B -- SDK Crate --> C[Create SDK Crate]
C -- Module File --> D[Create Module File]
D -- Wrapper Functions --> E[Write Wrapper Functions in src/lib.rs]
```

<!-- prettier-ignore -->
:::note
It is recommended that developers choose the WasmEdge [C API](develop_plugin_c.md) for plug-in development because of the support, compatibility, and flexibility the WasmEdge runtime provides.
:::

## Set up the development environment

To start developing WasmEdge plug-ins, it is essential to properly set up the development environment. This section provides step-by-step instructions for WasmEdge plug-in development -

- **Build WasmEdge from source**: For developing the WasmEdge plug-in in C++, you must build WasmEdge from source. Follow the[build WasmEdge from source](../source/build_from_src.md) for instructions. Once you complete the C++ plug-in code, you can use witc[^1] to generate Rust Plug-in SDK.

After installing WasmEdge, you need to set up the build environment. If you're using Linux or other platforms, you can follow the instructions in the [build environment setup guide](../source/os/linux.md).

## Write the plug-in code

To develop a WasmEdge Plug-in in Rust using the witc tool, you can follow these steps:

- **Generate Rust Plug-in Code**: Consider you have a file named `wasmedge_opencvmini.wit` with the following content:

  ```wit
  imdecode: func(buf: list<u8>) -> u32
  imshow: func(window-name: string, mat-key: u32) -> unit
  waitkey: func(delay: u32) -> unit
  ```

  You can use the witc tool to generate Rust plug-in code for it by running the following command:

  ```shell
  witc plugin wasmedge_opencvmini.wit
  ```

- **Create SDK Crate**: You need to create an SDK crate for your plug-in. Run the following command to create a new crate named `opencvmini-sdk`:

  ```shell
  cargo new --lib opencvmini-sdk && cd opencvmini-sdk
  ```

- **Create Module File**: The witc tool puts the Rust code to stdout. To capture the generated code, create a new module file named `src/generated.rs` and run the following command:

  ```shell
  witc plugin wasmedge_opencvmini.wit > src/generated.rs
  ```

- **Write Wrapper Functions**: In the `src/lib.rs` file of your crate, write the following code of `mod generated` to access the generated code and create wrapper functions:

  ```rust
  mod generated;

  pub fn imdecode(buf: &[u8]) -> u32 {
      unsafe { generated::imdecode(buf.as_ptr(), buf.len()) }
  }
  pub fn imshow(window_name: &str, mat_key: u32) -> () {
      unsafe { generated::imshow(window_name.as_ptr(), window_name.len(), mat_key) }
  }
  pub fn waitkey(delay: u32) -> () {
      unsafe { generated::waitkey(delay) }
  }
  ```

  This code imports the generated module and provides safe wrapper functions for each generated function.

[^1]: <https://github.com/second-state/witc>
","**Summary:**

The code provided is a documentation for developing WasmEdge plug-ins in Rust using the witc tool. The guide outlines the steps to create a plugin, from setting up the development environment to writing wrapper functions in Rust.

**Purpose and Functionality:**

1. **Developing WasmEdge Plug-ins:** The code provides a step-by-step guide on how to develop WasmEdge plug-ins using Rust.
2. **witc Tool:** The witc tool is used to generate Rust code from the Wit file that defines the plug-in's functionality.
3. **SDK Crate Creation:** The guide explains how to create an SDK crate for the plug-in, which includes generating wrapper functions in Rust.

**Key Components:**

1. **Build WasmEdge from Source:** Building WasmEdge from source is a necessary step before developing the plugin.
2. **witc Tool Usage:** The witc tool generates Rust code from the Wit file that defines the plugin's functionality.
3. **SDK Crate Creation:** Creating an SDK crate involves generating wrapper functions in Rust to access the generated code.

**Potential Issues and Areas for Improvement:**

1. **Build Environment Setup:** The guide assumes a Linux or other platform, but building WasmEdge on Windows may require additional steps.
2. **witc Tool Usage:** The witc tool is not included in the guide, so users may need to install it separately.
3. **Error Handling:** The guide does not provide information on how to handle errors that may occur during plugin development or execution.

**Recommendations:**

1. **Provide more detailed build environment setup instructions for Windows users.**
2. **Include information on error handling and troubleshooting common issues with witc tool usage.**
3. **Provide a sample project repository with the guide, including example code and a working SDK crate.**"
docs/contribute/plugin/test_plugin.md,"---
sidebar_position: 5
---

# Writing Tests for WasmEdge Plugins

This guide aims to help you write tests for your newly developed WasmEdge plugin. We will cover the steps of creating test cases, implementing the test cases in code, and executing them with Google Test, a popular C++ testing framework.

## Understanding Your Plugin

Before you start writing tests, make sure you understand your plugin's functionality and structure. The plugin code for WasmEdge typically consists of the following parts:

- **Plugin and Module Descriptions**: These are structures that provide metadata about the plugin and the modules it includes.
- **Host Functions and Modules**: These are the functionalities provided by the plugin, implemented as C++ classes and methods.
- **Module Creation Functions**: These functions create instances of the plugin's modules when the plugin is loaded by the WasmEdge runtime.

## Creating Test Cases

The first step in writing tests is to create test cases. Each test case should focus on a specific functionality of your plugin. For example, if your plugin provides a function to add two numbers, you might have test cases that cover normal inputs, edge cases (like the maximum possible integers), and error handling (like passing non-integer values).

## Implementing Test Cases

Once you have your test cases, you can start implementing them in code. Each test case should be implemented as a C++ function that uses Google Test macros to perform assertions.

Here's an example of how you might implement a test case:

    ```cpp
    #include ""gtest/gtest.h""
    #include ""your_plugin.h""

    TEST(YourPluginTest, ConvertsNormalString) {
    YourPlugin plugin;
    std::string input = ""123"";
    int expected = 123;
    EXPECT_EQ(expected, plugin.convert(input));
    }
    ```

In this example, `YourPluginTest` is the test suite name, and `ConvertsNormalString` is the test case name. The `EXPECT_EQ` macro is used to verify that the result of `plugin.convert(input)` is the same as `expected`.

## Compiling and Executing Tests

The final step is to compile and execute your tests. WasmEdge uses CMake to manage its build process, so you can add your test file to the `CMakeLists.txt` file in the test directory:

    ```cmake
    add_executable(your_plugin_test your_plugin_test.cpp)
    target_link_libraries(your_plugin_test gtest_main your_plugin)
    add_test(NAME your_plugin_test COMMAND your_plugin_test)
    ```

Then, you can build and run your tests with the following commands:

    ```bash
    mkdir build
    cd buildtest_plugin.md
    cmake ..
    make
    ctest
    ```

If everything is set up correctly, this will compile your tests, run them, and report the results.

Remember, testing is an iterative process. As you develop new features or fix bugs, you should also update your tests to reflect these changes. This will ensure that your plugin continues to work as expected as it evolves.

We hope this guide helps you get started with writing tests for your WasmEdge plugins!
","**Summary**

This guide provides a step-by-step approach to writing tests for WasmEdge plugins using the Google Test framework. It covers understanding the plugin's functionality and structure, creating test cases, implementing test cases in code, compiling, and executing tests.

**Key Components**

1. **Understanding Your Plugin**: Familiarize yourself with the plugin's parts:
	* **Plugin and Module Descriptions**: Provide metadata about the plugin and its modules.
	* **Host Functions and Modules**: Implement functionalities as C++ classes and methods.
	* **Module Creation Functions**: Create instances of the plugin's modules when loaded by WasmEdge runtime.
2. **Creating Test Cases**: Define test cases focusing on specific functionality, including edge cases and error handling.
3. **Implementing Test Cases**: Write each test case as a C++ function using Google Test macros for assertions.

**Example**

```cpp
TEST(YourPluginTest, ConvertsNormalString) {
    YourPlugin plugin;
    std::string input = ""123"";
    int expected = 123;
    EXPECT_EQ(expected, plugin.convert(input));
}
```

**Compiling and Executing Tests**

1. Add test file to `CMakeLists.txt`:
```cmake
add_executable(your_plugin_test your_plugin_test.cpp)
target_link_libraries(your_plugin_test gtest_main your_plugin)
add_test(NAME your_plugin_test COMMAND your_plugin_test)
```
2. Build and run tests with:
```bash
mkdir build
cd build
cmake ..
make
ctest
```

**Potential Issues or Areas for Improvement**

* The guide assumes a basic understanding of C++ and Google Test framework.
* It doesn't provide guidance on handling complex test cases or edge scenarios.
* The example provided is a simple conversion function; more complex functions may require additional testing strategies."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/test_plugin.md,"---
sidebar_position: 5
---

# Writing Tests for WasmEdge Plugins

This guide aims to help you write tests for your newly developed WasmEdge plugin. We will cover the steps of creating test cases, implementing the test cases in code, and executing them with Google Test, a popular C++ testing framework.

## Understanding Your Plugin

Before you start writing tests, make sure you understand your plugin's functionality and structure. The plugin code for WasmEdge typically consists of the following parts:

- **Plugin and Module Descriptions**: These are structures that provide metadata about the plugin and the modules it includes.
- **Host Functions and Modules**: These are the functionalities provided by the plugin, implemented as C++ classes and methods.
- **Module Creation Functions**: These functions create instances of the plugin's modules when the plugin is loaded by the WasmEdge runtime.

## Creating Test Cases

The first step in writing tests is to create test cases. Each test case should focus on a specific functionality of your plugin. For example, if your plugin provides a function to add two numbers, you might have test cases that cover normal inputs, edge cases (like the maximum possible integers), and error handling (like passing non-integer values).

## Implementing Test Cases

Once you have your test cases, you can start implementing them in code. Each test case should be implemented as a C++ function that uses Google Test macros to perform assertions.

Here's an example of how you might implement a test case:

    ```cpp
    #include ""gtest/gtest.h""
    #include ""your_plugin.h""

    TEST(YourPluginTest, ConvertsNormalString) {
    YourPlugin plugin;
    std::string input = ""123"";
    int expected = 123;
    EXPECT_EQ(expected, plugin.convert(input));
    }
    ```

In this example, `YourPluginTest` is the test suite name, and `ConvertsNormalString` is the test case name. The `EXPECT_EQ` macro is used to verify that the result of `plugin.convert(input)` is the same as `expected`.

## Compiling and Executing Tests

The final step is to compile and execute your tests. WasmEdge uses CMake to manage its build process, so you can add your test file to the `CMakeLists.txt` file in the test directory:

    ```cmake
    add_executable(your_plugin_test your_plugin_test.cpp)
    target_link_libraries(your_plugin_test gtest_main your_plugin)
    add_test(NAME your_plugin_test COMMAND your_plugin_test)
    ```

Then, you can build and run your tests with the following commands:

    ```bash
    mkdir build
    cd buildtest_plugin.md
    cmake ..
    make
    ctest
    ```

If everything is set up correctly, this will compile your tests, run them, and report the results.

Remember, testing is an iterative process. As you develop new features or fix bugs, you should also update your tests to reflect these changes. This will ensure that your plugin continues to work as expected as it evolves.

We hope this guide helps you get started with writing tests for your WasmEdge plugins!
","**Summary:**

This guide is an introduction to writing tests for WasmEdge plugins. It covers the importance of testing, understanding plugin functionality and structure, creating test cases, implementing test cases in code using Google Test, and compiling and executing tests.

**Key Components:**

1. **Understanding Your Plugin**: Familiarize yourself with your plugin's functionality and structure.
2. **Creating Test Cases**: Develop test cases that cover specific functionalities of your plugin.
3. **Implementing Test Cases**: Write C++ functions to implement each test case using Google Test macros.
4. **Compiling and Executing Tests**: Use CMake to manage the build process, add test files, link libraries, and run tests.

**Example Code:**

```cpp
#include ""gtest/gtest.h""
#include ""your_plugin.h""

TEST(YourPluginTest, ConvertsNormalString) {
    YourPlugin plugin;
    std::string input = ""123"";
    int expected = 123;
    EXPECT_EQ(expected, plugin.convert(input));
}
```

**Potential Issues/Areas for Improvement:**

1. **Insufficient Test Coverage**: Ensure that test cases cover all possible scenarios, including edge cases and error handling.
2. **Test Suite Organization**: Consider organizing tests into suites based on plugin features or functionality to improve maintainability.
3. **Code Duplication**: Minimize code duplication by using common functions or utilities for testing.
4. **CMake Configuration**: Review CMake configuration to ensure it is properly set up for testing and compilation.

**Best Practices:**

1. **Write Tests First**: Prioritize writing tests before implementing plugin features to ensure thorough testing.
2. **Use Google Test Macros**: Leverage Google Test macros to simplify test implementation and improve readability.
3. **Keep Tests Independent**: Ensure that each test is independent, making it easier to modify or remove individual tests without affecting the overall test suite.

By following this guide and adhering to best practices, you can create a robust testing framework for your WasmEdge plugins."
docs/embed/go/intro.md,"---
sidebar_position: 1
---

# WasmEdge Go SDK Introduction

The following is the guide to working with the WasmEdge Go API. You can embed the WasmEdge into your go application through the WasmEdge Go API.

## Set up Environment for embedding WASM functions into your go application

### Install and build WasmEdge and WasmEdge Go SDK

The WasmEdge-go requires Golang version >= 1.16. Please check your Golang version before installation. You can [download Golang here](https://golang.org/dl/).

```bash
$ go version
go version go1.16.5 linux/amd64
```

Meanwhile, please ensure you have installed [WasmEdge](../../start/install.md#install) with the same `WasmEdge-go` release version.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_go_version }}
```

Install the `WasmEdge-go` package and build in your Go project directory:

```bash
go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}
go build
```

### Build WasmEdge-go Extensions

<!-- prettier-ignore -->
:::note
The WasmEdge extensions have been deprecated after the 0.12.1 version. Please use the corresponding plug-ins after the 0.13.0 version.
:::

By default, the `WasmEdge-go` only turns on the basic runtime.

`WasmEdge-go` has the following extensions:

- TensorFlow

  - This extension supports the host functions in [WasmEdge-tensorflow](https://github.com/second-state/WasmEdge-tensorflow).
  - To install the `tensorflow` extension, please use the `-e tensorflow` flag in the WasmEdge installer command.
  - For using this extension, the tag `tensorflow` when building is required:

    ```bash
    go build -tags tensorflow
    ```

- Image

  - This extension supports the host functions in [WasmEdge-image](https://github.com/second-state/WasmEdge-image).
  - To install the `image` extension, please use the `-e image` flag in the WasmEdge installer command.
  - For using this extension, the tag `image` when building is required:

    ```bash
    go build -tags image
    ```

You can also turn on the multiple extensions when building:

```bash
go build -tags image,tensorflow
```

For examples, please refer to the [example repository](https://github.com/second-state/WasmEdge-go-examples/).

### WasmEdge AOT Compiler in Go

The [go_WasmAOT example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT) demonstrates how to compile a WASM file into a native binary (AOT compile) from within a Go application.

### Toolchain for Compile the Source Code to WASM Bytecode

To embed WasmEdge into your go application and run the WASM function, we still need language toolchain to compile the source code to WASM bytecode.

- For Rust, please refer to [the Rust setup guide](../../develop/rust/setup.md)

- For Tinygo, please refer to [the Tinygo setup guide](../../develop/go/hello_world.md)

- For C, please refer to [the C setup guide](../../develop/c/hello_world.md)

- For Javascript, you need the [WasmEdge-QuickJS](https://github.com/second-state/wasmedge-quickjs) into your Go application. See a community example [here](https://github.com/Edgenesis/wasm-shifu-demo).

## Examples

- [Embed a standalone WASM app](app.md)
- [Embed a WASM function](function.md)
- [Pass complex parameters to WASM functions](passing_data.md)
- [Embed a Tensorflow inference function](ai.md)
- [Embed a bindgen function](bindgen.md)

## API References

- [v0.13.4](reference/latest.md)
- [v0.12.1](reference/0.12.x.md)
- [v0.11.2](reference/0.11.x.md)
- [v0.10.1](reference/0.10.x.md)
- [v0.9.1](reference/0.9.x.md)
","**Summary**

The provided code is a guide to using the WasmEdge Go API for embedding WebAssembly (WASM) functions into a Go application. It covers setting up the environment, installing and building WasmEdge and the WasmEdge Go SDK, and utilizing extensions such as TensorFlow and Image.

**Key Components**

1. **Environment Setup**: The guide requires Go version 1.16 or later and WasmEdge installed with the same release version.
2. **WasmEdge-go Installation**: The `go get` command is used to install the `wasmedge` package, followed by building the project using `go build`.
3. **Extensions**: The guide explains how to enable extensions such as TensorFlow and Image using tags or flags during building.
4. **AOT Compiler**: The `go_WasmAOT example` demonstrates compiling a WASM file into a native binary from within a Go application.
5. **Toolchain**: The guide provides links to setup guides for Rust, Tinygo, C, and Javascript.

**Potential Issues**

1. **Version Compatibility**: Ensure that the WasmEdge version matches the Go version and the installed packages.
2. **Extension Deprecation**: Note that some extensions (e.g., `WasmEdge extensions`) have been deprecated after the 0.12.1 version.
3. **Build Tags**: Be aware of build tags (`-tags image,tensorflow`) and their implications.

**Areas for Improvement**

1. **Simplify Environment Setup**: Provide a more straightforward environment setup process, possibly using a Docker container or a package manager like `go mod`.
2. **Improve Extension Management**: Consider introducing a more streamlined way to manage extensions, such as a central repository or a package manager.
3. **Enhance Documentation**: Provide more detailed documentation for each section, including examples and explanations of complex concepts.

Overall, the guide provides a solid foundation for using WasmEdge in Go applications. However, there are opportunities to improve the user experience by simplifying setup and extension management processes."
i18n/zh/docusaurus-plugin-content-docs/current/embed/go/intro.md,"---
sidebar_position: 1
---

# WasmEdge Go SDK Introduction

The following is the guide to working with the WasmEdge Go API. You can embed the WasmEdge into your go application through the WasmEdge Go API.

## Set up Environment for embedding WASM functions into your go application

### Install and build WasmEdge and WasmEdge Go SDK

The WasmEdge-go requires Golang version >= 1.16. Please check your Golang version before installation. You can [download Golang here](https://golang.org/dl/).

```bash
$ go version
go version go1.16.5 linux/amd64
```

Meanwhile, please ensure you have installed [WasmEdge](../../start/install.md#install) with the same `WasmEdge-go` release version.

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_go_version }}
```

Install the `WasmEdge-go` package and build in your Go project directory:

```bash
go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}
go build
```

### Build WasmEdge-go Extensions

<!-- prettier-ignore -->
:::note
The WasmEdge extensions have been deprecated after the 0.12.1 version. Please use the corresponding plug-ins after the 0.13.0 version.
:::

By default, the `WasmEdge-go` only turns on the basic runtime.

`WasmEdge-go` has the following extensions:

- TensorFlow

  - This extension supports the host functions in [WasmEdge-tensorflow](https://github.com/second-state/WasmEdge-tensorflow).
  - To install the `tensorflow` extension, please use the `-e tensorflow` flag in the WasmEdge installer command.
  - For using this extension, the tag `tensorflow` when building is required:

    ```bash
    go build -tags tensorflow
    ```

- Image

  - This extension supports the host functions in [WasmEdge-image](https://github.com/second-state/WasmEdge-image).
  - To install the `image` extension, please use the `-e image` flag in the WasmEdge installer command.
  - For using this extension, the tag `image` when building is required:

    ```bash
    go build -tags image
    ```

You can also turn on the multiple extensions when building:

```bash
go build -tags image,tensorflow
```

For examples, please refer to the [example repository](https://github.com/second-state/WasmEdge-go-examples/).

### WasmEdge AOT Compiler in Go

The [go_WasmAOT example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT) demonstrates how to compile a WASM file into a native binary (AOT compile) from within a Go application.

### Toolchain for Compile the Source Code to WASM Bytecode

To embed WasmEdge into your go application and run the WASM function, we still need language toolchain to compile the source code to WASM bytecode.

- For Rust, please refer to [the Rust setup guide](../../develop/rust/setup.md)

- For Tinygo, please refer to [the Tinygo setup guide](../../develop/go/hello_world.md)

- For C, please refer to [the C setup guide](../../develop/c/hello_world.md)

- For Javascript, you need the [WasmEdge-QuickJS](https://github.com/second-state/wasmedge-quickjs) into your Go application. See a community example [here](https://github.com/Edgenesis/wasm-shifu-demo).

## Examples

- [Embed a standalone WASM app](app.md)
- [Embed a WASM function](function.md)
- [Pass complex parameters to WASM functions](passing_data.md)
- [Embed a Tensorflow inference function](ai.md)
- [Embed a bindgen function](bindgen.md)

## API References

- [v0.13.4](reference/latest.md)
- [v0.12.1](reference/0.12.x.md)
- [v0.11.2](reference/0.11.x.md)
- [v0.10.1](reference/0.10.x.md)
- [v0.9.1](reference/0.9.x.md)
","**Summary**

The provided code is a documentation for the WasmEdge Go SDK, which allows developers to embed WebAssembly (WASM) functions into their Go applications. The guide covers setting up the environment, installing and building WasmEdge and its SDK, using extensions such as TensorFlow and Image, and compiling WASM bytecode from source code.

**Key Components**

1. **Setting up Environment**: The guide explains how to install and build WasmEdge and its SDK, including checking Go version and installing WasmEdge using a script.
2. **Using Extensions**: The documentation covers the use of extensions such as TensorFlow and Image, which provide additional functionality for working with WASM functions.
3. **Compiling WASM Bytecode**: The guide explains how to compile source code into WASM bytecode using toolchains for Rust, Tinygo, C, and JavaScript.
4. **API References**: The documentation provides API references for different versions of the WasmEdge Go SDK.

**Potential Issues/Improvement Areas**

1. **Outdated Information**: Some sections of the guide may contain outdated information or deprecated functionality.
2. **Complexity**: The documentation covers multiple topics and extensions, which may make it difficult for new users to navigate.
3. **Lack of Examples**: While there are some examples provided, additional code examples would be helpful for demonstrating specific use cases.

**Recommendations**

1. **Update the Guide**: Regularly review and update the guide to reflect changes in WasmEdge and its SDK.
2. **Simplify Documentation**: Consider breaking down complex topics into smaller sections or creating separate guides for each extension.
3. **Add More Examples**: Provide additional code examples to demonstrate specific use cases and make it easier for developers to get started with the WasmEdge Go SDK."
docs/develop/javascript/tensorflow.md,"---
sidebar_position: 4
---

# AI inference

The WasmEdge-QuickJs supports the WasmEdge WASI-NN plug-ins so your JavaScript can run inference on AI models.

## Prerequisites

Install WasmEdge with WASI-NN plug-in.

- [with the Tensorflow Lite backend](../../start/install.md#wasi-nn-plug-in-with-tensorflow-lite-backend)
- [with the PyTorch backend](../../start/install.md#wasi-nn-plug-in-with-pytorch-backend)

Instead of a [standard](hello_world.md#prerequisites) QuickJS setup, you need to get the WasmEdge QuickJS runtime with WASI NN support built-in. Clone the wasmedge-quickjs repo and use it as the current directory.

```bash
git clone https://github.com/second-state/wasmedge-quickjs
cd wasmedge-quickjs
```

Then download the pre-built [WasmEdge QuickJS + WASI NN Runtime program](#build-it-yourself), and optionally, AOT compiles it for better performance.

```bash
curl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs_nn.wasm
wasmedgec wasmedge_quickjs_nn.wasm wasmedge_quickjs_nn.wasm
```

## A Tensorflow Lite example

Here is an example of JavaScript. You could find the full code from [example_js/tensorflow_lite_demo/wasi_nn_main.js](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo/wasi_nn_main.js).

```javascript
import { Image } from 'image';
import * as fs from 'fs';
import { NnGraph, NnContext, TENSOR_TYPE_U8 } from 'wasi_nn';

let img = new Image(__dirname + '/food.jpg');
let img_rgb = img.to_rgb().resize(192, 192);
let rgb_pix = img_rgb.pixels();

let data = fs.readFileSync(
  __dirname + '/lite-model_aiy_vision_classifier_food_V1_1.tflite',
);
let graph = new NnGraph([data.buffer], 'tensorflowlite', 'cpu');
let context = new NnContext(graph);
context.setInput(0, rgb_pix, [1, 192, 192, 3], TENSOR_TYPE_U8);
context.compute();

let output_view = new Uint8Array(2024);
context.getOutput(0, output_view.buffer);

let max = 0;
let max_idx = 0;
for (var i in output_view) {
  let v = output_view[i];
  if (v > max) {
    max = v;
    max_idx = i;
  }
}

let label_file = fs.readFileSync(
  __dirname + '/aiy_food_V1_labelmap.txt',
  'utf-8',
);
let lables = label_file.split(/\r?\n/);

let label = lables[max_idx];

print('label:');
print(label);
print('confidence:');
print(max / 255);
```

To run the JavaScript in the WasmEdge runtime, make sure that you have the [WASI-NN plug-in and Tensorflow Lite dependency libraries installed with WasmEdge](../../start/install.md#wasi-nn-plug-in-with-tensorflow-lite-backend). You should see the food item's name recognized by the TensorFlow lite ImageNet model.

```bash
$ wasmedge --dir .:. wasmedge_quickjs_nn.wasm example_js/tensorflow_lite_demo/wasi_nn_main.js
label:
Hot dog
confidence:
0.8941176470588236
```

## Build it yourself

Following the instructions, you can build a WASI-NN enabled JavaScript interpreter for WasmEdge. Make sure you have installed GCC. If you don't, run the following command line.

```bash
# Install GCC
sudo apt update
sudo apt install build-essential
```

Then, we could build the WasmEdge-Quickjs runtime. Fork or clone the [wasmedge-quickjs Github repository](https://github.com/second-state/wasmedge-quickjs).

```bash
# get the source code
git clone https://github.com/second-state/wasmedge-quickjs
cd wasmedge-quickjs

# Build the QuickJS JavaScript interpreter with WASI NN
cargo build --target wasm32-wasi --release --features=wasi_nn
```

The WebAssembly-based JavaScript interpreter program is located in the build `target` directory.

WasmEdge provides a `wasmedge compile` utility to compile and add a native machine code section to the wasm file. You can use wasmedge to run the natively instrumented wasm file to get much faster performance.

```bash
wasmedge compile target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs_nn.wasm
```
","**Summary:**

The code provided is a JavaScript example that utilizes the WASI-NN plug-in and TensorFlow Lite backend to run inference on an AI model. The code is designed to be executed within the WasmEdge runtime, which provides support for WebAssembly-based JavaScript execution.

**Key Components:**

1. **WASI-NN Plug-in:** A set of libraries provided by WasmEdge that enable WASM modules to interact with native machine learning frameworks like TensorFlow Lite.
2. **TensorFlow Lite:** A lightweight version of the popular deep learning framework, used in this example as the backend for model inference.
3. **QuickJS JavaScript Interpreter:** The WasmEdge-Quickjs runtime is a WebAssembly-based implementation of the QuickJS JavaScript interpreter, which allows running JavaScript code within the WasmEdge runtime.

**Code Structure:**

The provided code is organized into two main parts:

1. **TensorFlow Lite Example (wasi_nn_main.js):**
	* Loads an image and its label map.
	* Creates a TensorFlow Lite model from the loaded data.
	* Runs inference on the model using the WASI-NN plug-in.
	* Prints the recognized label and confidence score.
2. **Building the WasmEdge-Quickjs Runtime:**
	* Provides instructions for building the WasmEdge-Quickjs runtime with the WASI NN feature enabled.

**Potential Issues/Areas for Improvement:**

1. **Compilation Complexity:** The code requires building a native machine code section using `wasmedgec` or `wasmedge compile`, which might be complex to manage.
2. **Dependency Management:** Ensuring that all dependencies (WASI-NN, TensorFlow Lite) are properly installed and configured can be challenging.
3. **Performance Optimization:** The code might not achieve optimal performance due to the overhead of WebAssembly execution.

Overall, this example showcases the capabilities of WasmEdge in running JavaScript-based AI inference workloads using WASI-NN and TensorFlow Lite. However, it may require careful consideration of compilation complexities and dependency management to ensure smooth operation."
i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/tensorflow.md,"---
sidebar_position: 4
---

# AI inference

The WasmEdge-QuickJs supports the WasmEdge WASI-NN plug-ins so your JavaScript can run inference on AI models.

## Prerequisites

Install WasmEdge with WASI-NN plug-in.

- [with the Tensorflow Lite backend](../../start/install.md#wasi-nn-plug-in-with-tensorflow-lite-backend)
- [with the PyTorch backend](../../start/install.md#wasi-nn-plug-in-with-pytorch-backend)

Instead of a [standard](hello_world.md#prerequisites) QuickJS setup, you need to get the WasmEdge QuickJS runtime with WASI NN support built-in. Clone the wasmedge-quickjs repo and use it as the current directory.

```bash
git clone https://github.com/second-state/wasmedge-quickjs
cd wasmedge-quickjs
```

Then download the pre-built [WasmEdge QuickJS + WASI NN Runtime program](#build-it-yourself), and optionally, AOT compiles it for better performance.

```bash
curl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs_nn.wasm
wasmedgec wasmedge_quickjs_nn.wasm wasmedge_quickjs_nn.wasm
```

## A Tensorflow Lite example

Here is an example of JavaScript. You could find the full code from [example_js/tensorflow_lite_demo/wasi_nn_main.js](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo/wasi_nn_main.js).

```javascript
import { Image } from 'image';
import * as fs from 'fs';
import { NnGraph, NnContext, TENSOR_TYPE_U8 } from 'wasi_nn';

let img = new Image(__dirname + '/food.jpg');
let img_rgb = img.to_rgb().resize(192, 192);
let rgb_pix = img_rgb.pixels();

let data = fs.readFileSync(
  __dirname + '/lite-model_aiy_vision_classifier_food_V1_1.tflite',
);
let graph = new NnGraph([data.buffer], 'tensorflowlite', 'cpu');
let context = new NnContext(graph);
context.setInput(0, rgb_pix, [1, 192, 192, 3], TENSOR_TYPE_U8);
context.compute();

let output_view = new Uint8Array(2024);
context.getOutput(0, output_view.buffer);

let max = 0;
let max_idx = 0;
for (var i in output_view) {
  let v = output_view[i];
  if (v > max) {
    max = v;
    max_idx = i;
  }
}

let label_file = fs.readFileSync(
  __dirname + '/aiy_food_V1_labelmap.txt',
  'utf-8',
);
let lables = label_file.split(/\r?\n/);

let label = lables[max_idx];

print('label:');
print(label);
print('confidence:');
print(max / 255);
```

To run the JavaScript in the WasmEdge runtime, make sure that you have the [WASI-NN plug-in and Tensorflow Lite dependency libraries installed with WasmEdge](../../start/install.md#wasi-nn-plug-in-with-tensorflow-lite-backend). You should see the food item's name recognized by the TensorFlow lite ImageNet model.

```bash
$ wasmedge --dir .:. wasmedge_quickjs_nn.wasm example_js/tensorflow_lite_demo/wasi_nn_main.js
label:
Hot dog
confidence:
0.8941176470588236
```

## Build it yourself

Following the instructions, you can build a WASI-NN enabled JavaScript interpreter for WasmEdge. Make sure you have installed GCC. If you don't, run the following command line.

```bash
# Install GCC
sudo apt update
sudo apt install build-essential
```

Then, we could build the WasmEdge-Quickjs runtime. Fork or clone the [wasmedge-quickjs Github repository](https://github.com/second-state/wasmedge-quickjs).

```bash
# get the source code
git clone https://github.com/second-state/wasmedge-quickjs
cd wasmedge-quickjs

# Build the QuickJS JavaScript interpreter with WASI NN
cargo build --target wasm32-wasi --release --features=wasi_nn
```

The WebAssembly-based JavaScript interpreter program is located in the build `target` directory.

WasmEdge provides a `wasmedge compile` utility to compile and add a native machine code section to the wasm file. You can use wasmedge to run the natively instrumented wasm file to get much faster performance.

```bash
wasmedge compile target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs_nn.wasm
```
","**Summary**

This code is a documentation for using the WasmEdge-QuickJs runtime to run JavaScript code with AI inference capabilities. It provides instructions on installing WasmEdge with WASI-NN plug-in and Tensorflow Lite backend, as well as building a WASI-NN enabled JavaScript interpreter.

**Key Components**

1. **WasmEdge-QuickJs Runtime**: A WebAssembly-based JavaScript interpreter that supports AI inference capabilities.
2. **WASI-NN Plug-in**: A plugin for WasmEdge that enables WASM execution and provides access to NN-related APIs.
3. **Tensorflow Lite Backend**: A backend for WASI-NN that allows running TensorFlow Lite models.

**Example Code**

The code includes an example JavaScript program that demonstrates AI inference using the Tensorflow Lite model. It imports necessary modules, loads the model, sets up inputs, and runs inference to get outputs.

**Potential Issues/Improvements**

1. **Dependencies**: The code assumes that the WasmEdge-QuickJs runtime is installed with WASI-NN plug-in and Tensorflow Lite backend. Ensuring these dependencies are properly installed may require additional setup.
2. **Compilation**: Building the WasmEdge-Quickjs runtime from source may require GCC installation, which can be a challenge for some users.
3. **Performance Optimization**: The example code uses wasmedge to run the natively instrumented wasm file for better performance. This step may not be necessary or possible in all environments.

**Best Practices**

1. **Clearly Document Dependencies**: Ensure that dependencies are clearly documented and installed before running the code.
2. **Provide Pre-built Binaries**: Provide pre-built binaries for the WasmEdge-QuickJs runtime to simplify installation and usage.
3. **Test Code Thoroughly**: Test the code thoroughly in various environments to ensure compatibility and performance.

By following these guidelines, users can successfully use the WasmEdge-QuickJs runtime with AI inference capabilities to run their JavaScript programs efficiently."
i18n/zh/docusaurus-plugin-content-docs/current/start/faq.md,"---
sidebar_position: 4
---

# Frequently Asked Questions

This FAQ page is designed to address the most common technical questions about WasmEdge. If your question is not directly answered here, please refer to the WasmEdge [documentation](https://wasmedge.org/docs/) or engage with the WasmEdge community via discord.

## 1. How does WasmEdge handle memory sharing between modules?

WasmEdge follows the WebAssembly specification, which currently does not support shared memory between different modules. Each module has its own linear memory space. This is because WebAssembly modules are isolated and cannot directly access each other's memory 1. However, it is possible to manually copy data from one module to another using host functions

## 2. Can WasmEdge support model training?

As of now, WasmEdge supports [model inference](https://www.secondstate.io/articles/fast-llm-inference/). It uses the WASI-NN API to make predictions using pre-trained models. However, model training is not yet supported. It only allows for the execution of pre-trained models.

## 3. What is the internal flow of WasmEdge?

The WasmEdge runtime follows a general flow: parsing the Wasm file, validating the parsed Wasm file, compiling the validated Wasm file into native code, and then executing the compiled code. For more detailed information, please refer to the WasmEdge runtime [documentation](https://wasmedge.org/docs/).

## 4. Why is my plugin crashing?

If your plugin crashes, it might be due to several reasons. It could be related to incorrect use of the WasmEdge API, or the plugin may be incompatible with the WasmEdge version you're using. It's recommended to debug the plugin using a debugger tool to get more detailed error information. Also it you should check the [plug-in documentation](https://wasmedge.org/docs/contribute/plugin/test_plugin)

## 5. How to create a VM to call `infer()` in a Wasm library?

You can use the WASI-NN API to call the `infer()` function in a Wasm library. First, you need to prepare the model, inputs, and outputs. Then, you can call the `infer()` function with these parameters.

## 6. Can WasmEdge support Tensorflow as its inference backend using WASI-NN?

Yes, WasmEdge can use Tensorflow as its [inference](https://wasmedge.org/docs/embed/go/ai/) backend through the WASI-NN API.

## 7. How to read a host file in WasmEdge runtime?

WasmEdge provides the WASI (WebAssembly System Interface) API for interacting with the host system, including file operations. You can use the [WASI API](https://wasmedge.org/docs/embed/go/reference/0.11.x?_highlight=wasi&_highlight=api#preregistrations) to open and read files from the host system.

Please remember, this FAQ page is not exhaustive, and the WasmEdge community is always ready to help with any questions or issues you may have. Don't hesitate to reach out if you need assistance in our [Discord server](https://discord.gg/h4KDyB8XTt).
","**Summary**

This FAQ page provides answers to frequently asked questions about WasmEdge, a WebAssembly runtime. The document covers topics such as memory sharing between modules, model training support, internal flow of WasmEdge, plugin crashes, creating a VM to call `infer()` in a Wasm library, and reading host files.

**Key Components**

1. **Memory Sharing**: WasmEdge does not support shared memory between different modules, but it is possible to manually copy data from one module to another using host functions.
2. **Model Training**: WasmEdge currently only supports model inference, not training.
3. **Internal Flow**: WasmEdge follows a general flow of parsing, validating, compiling, and executing the WebAssembly file.
4. **Plugin Crashes**: Possible reasons for plugin crashes include incorrect use of the WasmEdge API or incompatibility with the WasmEdge version.
5. **WASI-NN API**: Used for calling `infer()` function in a Wasm library.
6. **Tensorflow Inference Backend**: Supported through WASI-NN API.

**Potential Issues**

1. **Incomplete FAQ Page**: This document is not exhaustive and does not cover all possible questions or issues.
2. **Lack of Detailed Error Information**: Debugging plugins may be challenging without detailed error information.
3. **Incompatible WasmEdge Versions**: Plugins may crash due to incompatibility with the WasmEdge version.

**Recommendations**

1. **Refer to Documentation**: For more detailed information, refer to the WasmEdge documentation and API references.
2. **Join the Discord Server**: Engage with the WasmEdge community for assistance with any questions or issues.
3. **Use Debugging Tools**: Utilize debugging tools to get more detailed error information when troubleshooting plugin crashes."
docs/develop/rust/setup.md,"---
sidebar_position: 1
---

# Set up Rust toolchain

In the following chapters, we will show how to build and compile Rust programs into WASM bytecode and then run them in WasmEdge.

Before we start, let's set up the software we need.

## Install WasmEdge

Use the following command line to install WasmEdge on your machine. If you use Windows or other non-Unix-like platforms, please refer to the [WasmEdge installation](../../start/install.md#install).

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
```

## Install Rust

Use the following command line to install Rust on your machine. If you use Windows or other non-Unix-like platforms, please refer to the [Rust installation instruction](https://www.rust-lang.org/tools/install).

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

## Set up the Rust compiler's target

To build a WASM file running in server-side WebAssembly like WasmEdge, we need to add the `wasm32-wasi` target for the Rust compiler after Rust is installed.

```bash
rustup target add wasm32-wasi
```

## Special notes for networking apps

### Tokio support

WasmEdge supports async networking APIs provided by [Tokio](https://tokio.rs/) and related crates. If you have tokio in your `Cargo.toml`, you
need to add a few config flags to help the Rust compiler choose the correct feature branches in the library source code. Here is an example of `cargo build` command for compiling a tokio app to Wasm.

```bash
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release
```

Alternatively, you could add these lines to the `.cargo/config.toml` file.

```toml
[build]
target = ""wasm32-wasi""
rustflags = [""--cfg"", ""wasmedge"", ""--cfg"", ""tokio_unstable""]
```

Once you have these lines in `.cargo/config.toml`, you can simply use the regular `cargo` command.

```
cargo build --target wasm32-wasi --release
```

### TLS on MacOS

The standard `cargo` toolchain can support the [Rust TLS](https://github.com/rustls/rustls) library on Linux. However,
on MacOS, you need a special version of the Clang tool, released from the official [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), in order to support TLS libraries.

> When you compile Rust TLS source code to Wasm on Linux, the result Wasm file is cross-platform and can run correctly on any platform with WasmEdge installed. This section is only applicable when you need to **compile** Rust TLS source code on MacOS.

[Download the latest wasi-sdk release](https://github.com/WebAssembly/wasi-sdk/releases) for your platform and
expand it into a directory. Point the `WASI_SDK_PATH` variable to this directory and export a `CC` variable for the default Clang.

```bash
export WASI_SDK_PATH /path/to/wasi-sdk-22.0
export CC=""${WASI_SDK_PATH}/bin/clang --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot""
```

That's it. Now you can use the `cargo` tools on MacOS to compile tokio libraries with `rust-tls` feature turned on.
","**Summary**

This document guides users through setting up the Rust toolchain for building and compiling Rust programs into WebAssembly (WASM) bytecode that can be run on WasmEdge. The steps involve installing WasmEdge, Rust, and configuring the Rust compiler's target.

**Key Components**

1. **Installing WasmEdge**: Using a command-line installation script to download and install WasmEdge.
2. **Installing Rust**: Using the official Rust installer to download and install Rust.
3. **Configuring Rust Compiler Target**: Adding the `wasm32-wasi` target for building WASM files that can run on server-side WebAssembly like WasmEdge.

**Special Notes**

1. **Tokio Support**: For Tokio-based networking apps, additional configuration is required to enable async networking APIs provided by Tokio.
2. **TLS on MacOS**: When compiling Rust TLS source code on MacOS, a special version of Clang from the official wasi-sdk release is needed to support TLS libraries.

**Potential Issues or Areas for Improvement**

1. **Platform-Specific Installation Scripts**: The installation scripts may not work correctly on non-Unix-like platforms (e.g., Windows). Improving platform-specific installation instructions would enhance the user experience.
2. **Complex Configuration**: The Tokio configuration and WASI SDK setup process might be complex for users unfamiliar with these tools. Providing more detailed explanations or examples would help users better understand these steps.

Overall, this document provides a clear guide for setting up the Rust toolchain for building and compiling Rust programs into WebAssembly bytecode that can run on WasmEdge."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/setup.md,"---
sidebar_position: 1
---

# Set up Rust toolchain

In the following chapters, we will show how to build and compile Rust programs into WASM bytecode and then run them in WasmEdge.

Before we start, let's set up the software we need.

## Install WasmEdge

Use the following command line to install WasmEdge on your machine. If you use Windows or other non-Unix-like platforms, please refer to the [WasmEdge installation](../../start/install.md#install).

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
```

## Install Rust

Use the following command line to install Rust on your machine. If you use Windows or other non-Unix-like platforms, please refer to the [Rust installation instruction](https://www.rust-lang.org/tools/install).

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

## Set up the Rust compiler's target

To build a WASM file running in server-side WebAssembly like WasmEdge, we need to add the `wasm32-wasi` target for the Rust compiler after Rust is installed.

```bash
rustup target add wasm32-wasi
```

## Special notes for networking apps

### Tokio support

WasmEdge supports async networking APIs provided by [Tokio](https://tokio.rs/) and related crates. If you have tokio in your `Cargo.toml`, you 
need to add a few config flags to help the Rust compiler choose the correct feature branches in the library source code. Here is an example of `cargo build` command for 
compiling a tokio app to Wasm.

```
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release
```

Alternatively, you could add these lines to the `.cargo/config.toml` file.

```
[build]
target = ""wasm32-wasi""
rustflags = [""--cfg"", ""wasmedge"", ""--cfg"", ""tokio_unstable""]
```

Once you have these lines in `.cargo/config.toml`, you can simply use the regular `cargo` command.

```
cargo build --target wasm32-wasi --release
```

### TLS on MacOS

The standard `cargo` toolchain can support the [Rust TLS](https://github.com/rustls/rustls) library on Linux. However,
on MacOS, you need a special version of the Clang tool, released from the official [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), in order to support TLS libraries.

> When you compile Rust TLS source code to Wasm on Linux, the result Wasm file is cross-platform and can run correctly on any platform with WasmEdge installed. This section is only applicable when you need to **compile** Rust TLS source code on MacOS.

[Download the latest wasi-sdk release](https://github.com/WebAssembly/wasi-sdk/releases) for your platform and 
expand it into a directory. Point the `WASI_SDK_PATH` variable to this directory and export a `CC` variable for the default Clang.

```
export WASI_SDK_PATH /path/to/wasi-sdk-22.0
export CC=""${WASI_SDK_PATH}/bin/clang --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot""
```

That's it. Now you can use the `cargo` tools on MacOS to compile tokio libraries with `rust-tls` feature turned on.

","**Summary:**

This code is a setup guide for building and compiling Rust programs into WASM bytecode using the WasmEdge runtime. It provides instructions on installing WasmEdge, Rust, and setting up the Rust compiler's target. Additionally, it offers special notes for networking apps, including Tokio support and TLS configuration on MacOS.

**Key Components:**

1. **Install WasmEdge**: The code provides a command to install WasmEdge using `curl`.
2. **Install Rust**: The code provides a command to install Rust using `curl` or `rustup`.
3. **Set up the Rust compiler's target**: The code shows how to add the `wasm32-wasi` target for the Rust compiler.
4. **Tokio support**: The code explains how to configure Tokio support, including adding config flags and modifying Cargo configurations.
5. **TLS on MacOS**: The code provides instructions on configuring TLS support using a special version of Clang from the wasi-sdk.

**Potential Issues or Areas for Improvement:**

1. **Platform-specific instructions**: The code assumes Unix-like platforms, but there are specific instructions for Windows and MacOS. These should be more clearly separated.
2. **Outdated links**: Some links in the code may become outdated over time, which could make it difficult to follow the setup process.
3. **Missing information on other dependencies**: The code only covers WasmEdge, Rust, Tokio, and TLS; however, there might be additional dependencies required for a complete setup.
4. **Error handling**: The code does not handle potential errors that may occur during installation or configuration.

Overall, the code provides a good starting point for setting up a Rust development environment with WASM bytecode support using WasmEdge. However, some improvements are necessary to make it more platform-agnostic and robust."
docs/start/troubleshooting_guide.md,"---
sidebar_position: 4
---

# Troubleshooting Guide

This guide aims to provide solutions to common problems you may encounter when using WasmEdge, helping you to troubleshoot effectively and get back to your development work as quickly as possible.

## Installation Issues

If you encounter errors during the installation process, make sure to check the following:

1. **Supported Platform**: Make sure you are running a [supported operating system and architecture](https://wasmedge.org/docs/start/install/).

2. **Dependencies**: Ensure that all necessary dependencies are installed and up-to-date. This includes the correct versions of your compiler, build system (like CMake), and any libraries that WasmEdge depends on.

3. **Environment**: Check your environment variables and paths. Some issues can be caused by incorrect paths or missing environment variables.

## Runtime Errors

Runtime errors can occur for a variety of reasons. Here are some common causes and solutions:

1. **Incorrect Usage**: If you're getting errors when executing a Wasm file, make sure that you're using the wasmedge command correctly. Check the [CLI documentation](https://wasmedge.org/docs/start/build-and-run/cli/) to make sure you're using the correct syntax and options.

2. **Incompatible Wasm Files**: Not all Wasm files are compatible with WasmEdge. If the Wasm file uses features or instructions that are not supported by WasmEdge, it may fail to execute. Make sure the Wasm file is compatible with WasmEdge.

3. **Plugin Issues**: If you're using plugins and they're causing issues, make sure the plugins are correctly installed and configured. Check the [plugin documentation](https://wasmedge.org/docs/category/wasmedge-plugin-system) for any specific requirements or known issues.

## Performance Issues

If WasmEdge is running slowly or consuming too much memory, consider the following:

1. **Optimization**: Make sure you're using the [AOT compiler](https://wasmedge.org/docs/start/build-and-run/aot/) if performance is a concern. The AOT compiler can significantly speed up the execution of Wasm files.

2. **Memory Usage**: If memory usage is too high, consider whether the Wasm file or the data it's processing is too large. You may need to optimize the Wasm file or adjust the way it processes data.

## Contributing to WasmEdge

If you're having trouble contributing to WasmEdge, make sure to:

1. **Follow the Contribution Guidelines**: Ensure that your contributions follow the [guidelines](https://wasmedge.org/docs/contribute/).

2. **Understand the Code**: Make sure you have a good understanding of the [WasmEdge codebase](https://github.com/WasmEdge/WasmEdge) before making changes.

3. **Test Your Changes**: Always test your changes before submitting a pull request. This can help catch issues early and make the review process smoother.

If any of the above steps do not help you, you should ask about your problem in Wasmedge's [discord server](https://discord.gg/h4KDyB8XTt) for furthur help.
","**Summary**

The provided code is a troubleshooting guide for WasmEdge, a WebAssembly runtime. The guide aims to help users resolve common issues they may encounter when using WasmEdge. It covers installation issues, runtime errors, performance issues, and contributing to the project.

**Key Components**

1. **Installation Issues**: Provides steps to troubleshoot installation problems, including checking supported platforms, dependencies, and environment variables.
2. **Runtime Errors**: Offers solutions for common runtime errors, such as incorrect usage of Wasm files, incompatible Wasm files, and plugin issues.
3. **Performance Issues**: Suggests optimizations for performance-related problems, including using the AOT compiler and reducing memory usage.
4. **Contributing to WasmEdge**: Outlines steps for contributing to the project, including following contribution guidelines, understanding the codebase, and testing changes.

**Potential Issues or Areas for Improvement**

1. **Duplicate content**: Some sections have similar information, which could be condensed or removed to improve readability.
2. **Lack of clear headings**: The guide could benefit from more prominent headings to help users quickly navigate the content.
3. **Insufficient examples**: While the guide provides good general advice, it would be helpful to include specific examples or scenarios to illustrate each point.
4. **Outdated links**: Some links may become outdated over time; consider using version numbers or dynamic links to ensure they remain valid.

Overall, this is a comprehensive and well-organized guide that can help users troubleshoot common issues with WasmEdge. However, some minor adjustments could improve its effectiveness and readability."
i18n/zh/docusaurus-plugin-content-docs/current/start/troubleshooting_guide.md,"---
sidebar_position: 4
---

# Troubleshooting Guide

This guide aims to provide solutions to common problems you may encounter when using WasmEdge, helping you to troubleshoot effectively and get back to your development work as quickly as possible.

## Installation Issues

If you encounter errors during the installation process, make sure to check the following:

1. **Supported Platform**: Make sure you are running a [supported operating system and architecture](https://wasmedge.org/docs/start/install/).

2. **Dependencies**: Ensure that all necessary dependencies are installed and up-to-date. This includes the correct versions of your compiler, build system (like CMake), and any libraries that WasmEdge depends on.

3. **Environment**: Check your environment variables and paths. Some issues can be caused by incorrect paths or missing environment variables.

## Runtime Errors

Runtime errors can occur for a variety of reasons. Here are some common causes and solutions:

1. **Incorrect Usage**: If you're getting errors when executing a Wasm file, make sure that you're using the wasmedge command correctly. Check the [CLI documentation](https://wasmedge.org/docs/start/build-and-run/cli/) to make sure you're using the correct syntax and options.

2. **Incompatible Wasm Files**: Not all Wasm files are compatible with WasmEdge. If the Wasm file uses features or instructions that are not supported by WasmEdge, it may fail to execute. Make sure the Wasm file is compatible with WasmEdge.

3. **Plugin Issues**: If you're using plugins and they're causing issues, make sure the plugins are correctly installed and configured. Check the [plugin documentation](https://wasmedge.org/docs/category/wasmedge-plugin-system) for any specific requirements or known issues.

## Performance Issues

If WasmEdge is running slowly or consuming too much memory, consider the following:

1. **Optimization**: Make sure you're using the [AOT compiler](https://wasmedge.org/docs/start/build-and-run/aot/) if performance is a concern. The AOT compiler can significantly speed up the execution of Wasm files.

2. **Memory Usage**: If memory usage is too high, consider whether the Wasm file or the data it's processing is too large. You may need to optimize the Wasm file or adjust the way it processes data.

## Contributing to WasmEdge

If you're having trouble contributing to WasmEdge, make sure to:

1. **Follow the Contribution Guidelines**: Ensure that your contributions follow the [guidelines](https://wasmedge.org/docs/contribute/).

2. **Understand the Code**: Make sure you have a good understanding of the [WasmEdge codebase](https://github.com/WasmEdge/WasmEdge) before making changes.

3. **Test Your Changes**: Always test your changes before submitting a pull request. This can help catch issues early and make the review process smoother.

If any of the above steps do not help you, you should ask about your problem in Wasmedge's [discord server](https://discord.gg/h4KDyB8XTt) for furthur help.
","**Summary**

The provided code is a Markdown document that serves as a troubleshooting guide for WasmEdge, a WebAssembly runtime. The guide aims to provide solutions to common problems users may encounter when using WasmEdge, including installation issues, runtime errors, performance issues, and contributing to the project.

**Key Components**

1. **Installation Issues**: The guide provides steps to troubleshoot common installation issues, such as checking supported platforms, dependencies, and environment variables.
2. **Runtime Errors**: The section covers common causes of runtime errors, including incorrect usage, incompatible Wasm files, and plugin issues.
3. **Performance Issues**: The guide suggests optimization techniques, such as using the AOT compiler, to improve performance and reduce memory usage.
4. **Contributing to WasmEdge**: The final section provides guidelines for contributing to the project, including following contribution guidelines, understanding the codebase, and testing changes.

**Potential Issues or Areas for Improvement**

1. **Overly broad troubleshooting steps**: Some steps may be too general and not specific enough to address complex issues.
2. **Lack of technical detail**: The guide could benefit from more technical details and examples to help users understand the solutions better.
3. **Outdated links**: Some links, such as the Discord server link, may become outdated over time.
4. **Insufficient testing and validation**: Users may encounter issues if they don't test their changes thoroughly before submitting a pull request.

**Recommendations**

1. **Break down complex troubleshooting steps into smaller, more specific sections**
2. **Add more technical details and examples to illustrate solutions**
3. **Regularly review and update links to ensure they remain valid**
4. **Emphasize the importance of thorough testing and validation before submitting changes**"
docs/start/style_guide.md,"# WasmEdge Style Guide

- [Documentation Style Guide](#documentation-style-guide)
  - [Language](#language)
  - [Structure and Format](#structure-and-format)
  - [Content](#content)
  - [Other Considerations](#other-considerations)
- [Coding Style Guide](#coding-style-guide)
  - [Code Formatting](#code-formatting)
  - [Code Quality](#code-quality)
  - [Testing](#testing)
  - [Security](#security)

## Documentation Style Guide

### Language

- Use clear, simple, and concise language. Avoid jargon and technical terms as much as possible. If they are unavoidable, provide clear definitions or explanations.
- Write in the active voice and use the second person (""you"") to make the documentation more user-oriented.

### Structure and Format

- Structure content with descriptive headings and subheadings.
- Make content more readable and easier to follow with bullet points and numbered lists.
- Include code examples and technical references where necessary. They should be well-formatted and easy to understand. Use code blocks and syntax highlighting for code examples.

### Content

- Start with an introduction that provides an overview of the topic.
- Provide step-by-step instructions and include code examples where necessary.
- Include a section on troubleshooting to help users solve common problems they might encounter.

### Other Considerations

- Encourage contributions from the community. Include a section explaining how users can contribute to the project.
- Regularly review the content and make updates as necessary.
- Ensure that the documentation is accessible to everyone. It should be easy to read, understand, and navigate.

## Coding Style Guide

### Code Formatting

- Use consistent indentation. For example, you can choose to use spaces over tabs and stick with it throughout the project.
- Use meaningful variable, function, and class names. They should clearly indicate what the variable contains, what the function does, etc.
- Comment your code. Explain what each section or line of code does, especially if it involves complex logic.

### Code Quality

- Keep your code DRY (Don't Repeat Yourself). If you find yourself writing the same code in multiple places, consider creating a function or class.
- Write small, single-purpose functions. Each function should do one thing and do it well.
- Handle errors properly. Don't leave empty catch blocks in your code.

### Testing

- Write tests for your code. This helps to catch bugs early and makes sure that the code is working as expected.
- Follow a testing methodology, like unit testing or integration testing.

### Security

- Avoid code that might lead to security vulnerabilities, such as SQL injection.
- Use secure functions and libraries.
- Follow the security best practices provided by the CNCF.
","**Summary**

This is a style guide for the WasmEdge project, which includes guidelines for documentation and coding best practices. The goal of this guide is to ensure that all documentation and code written within the project are clear, concise, well-structured, and follow industry standards.

**Documentation Style Guide**

* **Language**: Use simple, clear language and avoid technical jargon.
* **Structure and Format**: Organize content with descriptive headings, use bullet points and numbered lists, and include code examples where necessary.
* **Content**: Provide step-by-step instructions, include troubleshooting sections, and encourage community contributions.
* **Other Considerations**: Regularly review and update documentation to ensure accessibility.

**Coding Style Guide**

* **Code Formatting**: Use consistent indentation, meaningful variable names, and comment code with explanations.
* **Code Quality**: Keep code DRY (Don't Repeat Yourself), write small functions, handle errors properly, and avoid empty catch blocks.
* **Testing**: Write tests for code to ensure it works as expected.
* **Security**: Avoid security vulnerabilities, use secure functions and libraries, and follow industry best practices.

**Key Components**

* Consistent language and formatting guidelines
* Clear documentation structure and content organization
* Code quality and testing guidelines
* Security best practices

**Potential Issues or Areas for Improvement**

* Enforcing consistency across all contributors
* Regularly reviewing and updating the style guide to ensure it remains relevant
* Providing clear definitions or explanations for technical terms used in the project"
i18n/zh/docusaurus-plugin-content-docs/current/start/style_guide.md,"# WasmEdge Style Guide

- [Documentation Style Guide](#documentation-style-guide)
  - [Language](#language)
  - [Structure and Format](#structure-and-format)
  - [Content](#content)
  - [Other Considerations](#other-considerations)
- [Coding Style Guide](#coding-style-guide)
  - [Code Formatting](#code-formatting)
  - [Code Quality](#code-quality)
  - [Testing](#testing)
  - [Security](#security)

## Documentation Style Guide

### Language

- Use clear, simple, and concise language. Avoid jargon and technical terms as much as possible. If they are unavoidable, provide clear definitions or explanations.
- Write in the active voice and use the second person (""you"") to make the documentation more user-oriented.

### Structure and Format

- Structure content with descriptive headings and subheadings.
- Make content more readable and easier to follow with bullet points and numbered lists.
- Include code examples and technical references where necessary. They should be well-formatted and easy to understand. Use code blocks and syntax highlighting for code examples.

### Content

- Start with an introduction that provides an overview of the topic.
- Provide step-by-step instructions and include code examples where necessary.
- Include a section on troubleshooting to help users solve common problems they might encounter.

### Other Considerations

- Encourage contributions from the community. Include a section explaining how users can contribute to the project.
- Regularly review the content and make updates as necessary.
- Ensure that the documentation is accessible to everyone. It should be easy to read, understand, and navigate.

## Coding Style Guide

### Code Formatting

- Use consistent indentation. For example, you can choose to use spaces over tabs and stick with it throughout the project.
- Use meaningful variable, function, and class names. They should clearly indicate what the variable contains, what the function does, etc.
- Comment your code. Explain what each section or line of code does, especially if it involves complex logic.

### Code Quality

- Keep your code DRY (Don't Repeat Yourself). If you find yourself writing the same code in multiple places, consider creating a function or class.
- Write small, single-purpose functions. Each function should do one thing and do it well.
- Handle errors properly. Don't leave empty catch blocks in your code.

### Testing

- Write tests for your code. This helps to catch bugs early and makes sure that the code is working as expected.
- Follow a testing methodology, like unit testing or integration testing.

### Security

- Avoid code that might lead to security vulnerabilities, such as SQL injection.
- Use secure functions and libraries.
- Follow the security best practices provided by the CNCF.
","**Summary:**

This is a style guide for documentation and coding best practices, specifically tailored to the WasmEdge project. The guide provides recommendations on how to write clear, concise, and user-friendly documentation, as well as code that is maintainable, readable, and secure.

**Key Components:**

1. **Documentation Style Guide**: Provides guidelines for writing high-quality documentation, including language, structure, content, and other considerations.
2. **Coding Style Guide**: Offers recommendations on coding best practices, covering code formatting, quality, testing, and security.

**Functionality:**

The style guide aims to ensure that the WasmEdge project's documentation and code are:

* Easy to read and understand
* Consistent in style and format
* Secure and free from vulnerabilities
* Maintainable and scalable

**Potential Issues or Areas for Improvement:**

1. **Enforcement**: While the style guide provides recommendations, it does not specify how these guidelines will be enforced.
2. **Up-to-date information**: The style guide may not reflect the latest best practices or technological advancements.
3. **Community engagement**: The guide could benefit from more explicit language on community involvement and contribution guidelines.
4. **Integration with existing tools**: The style guide should be integrated with existing project tools, such as linters, formatters, and testing frameworks.

**Recommendations:**

1. Regularly review and update the style guide to ensure it remains relevant and effective.
2. Establish a process for enforcing the guidelines, such as code reviews or automated checks.
3. Consider integrating the style guide with existing project tools to provide a more seamless experience for developers.
4. Engage with the community to gather feedback and suggestions on improving the style guide."
docs/develop/javascript/nodejs.md,"---
sidebar_position: 5
---

# Node.js support

Many existing JavaScript apps use Node.js built-in APIs. To support and reuse these JavaScript apps, we are implementing many Node.JS APIs for WasmEdge QuickJS. The goal is to have unmodified Node.js programs running in WasmEdge QuickJS.

To use Node.js APIs in WasmEdge, you must make the `modules` directory from [wasmedge-quickjs](https://github.com/second-state/wasmedge-quickjs) accessible to the WasmEdge Runtime. The most straightforward approach is to clone the [wasmedge-quickjs](https://github.com/second-state/wasmedge-quickjs) repo and run the Node.js app from the repo's top directory.

```bash
# Clone the wasmedge-quickjs
git clone https://github.com/second-state/wasmedge-quickjs
# Use the wasmedge-quickjs directory as the working directory for modules access
cd wasmedge-quickjs
# Download a released WasmEdge QuickJS runtime
curl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm
# Copy the nodejs project to the current working directory and run the nodejs app
cp -r /path/to/my_node_app .
wasmedge --dir .:. wasmedge_quickjs.wasm my_node_app/index.js
```

<!-- prettier-ignore -->
:::note
If you want to run `wasmedge` from a directory outside the repo, you will need to tell it where to find the `modules` directory using the `--dir` option. A typical command will look like this: `wasmedge --dir .:. --dir ./modules:/path/to/modules wasmedge_quickjs.wasm app.js`
:::

The progress of Node.js support in WasmEdge QuickJS is **[tracked in this issue](https://github.com/WasmEdge/WasmEdge/issues/1535).** There are two approaches for supporting Node.js APIs in WasmEdge QuickJS.

## The JavaScript modules

Some Node.js functions can be implemented in pure JavaScript using the [modules](modules) approach. For example,

- The [querystring](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/querystring.js) functions just perform string manipulations.
- The [buffer](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/buffer.js) functions manage and encode arrays and memory structures.
- The [encoding](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/encoding.js) and [http](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/http.js) functions support corresponding Node.js APIs by wrapping around [Rust internal modules](rust).

## The Rust internal modules

Other Node.js functions must be implemented using the [internal_module](rust) approach in Rust. There are two reasons for that. First, some Node.js API functions are CPU intensive (e.g., encoding) and is most efficiently implemented in Rust. Second, some Node.js API functions require access to the underlying system (e.g., networking and file system) through native host functions.

- The [core](https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/core.rs) module provides OS-level functions such as `timeout`.
- The [encoding](https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/encoding.rs) module provides high-performance encoding and decoding functions, which are in turn [wrapped into Node.js encoding APIs](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/encoding.js).
- The [wasi_net_module](https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/wasi_net_module.rs) provides JavaScript networking functions implemented via the Rust-based WasmEdge WASI socket API. It is then wrapped into the [Node.js http module](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/http.js).

Node.js compatibility support in WasmEdge QuickJS is a work in progress. It is an excellent way for new developers to get familiar with WasmEdge QuickJS. Join us!
","**Summary**

The provided code is a documentation for implementing Node.js support in WasmEdge QuickJS. It outlines the steps to use Node.js APIs in WasmEdge and describes two approaches: using JavaScript modules or Rust internal modules. The goal is to have unmodified Node.js programs running in WasmEdge QuickJS.

**Key Components**

1. **JavaScript Modules**: Some Node.js functions can be implemented using pure JavaScript, performing string manipulations, managing arrays and memory structures, and supporting corresponding Node.js APIs by wrapping around Rust internal modules.
2. **Rust Internal Modules**: Other Node.js functions must be implemented in Rust for CPU-intensive tasks (e.g., encoding) or to access underlying system functionality through native host functions.

**Code Snippets**

1. A command to clone the `wasmedge-quickjs` repository and run a Node.js app using WasmEdge QuickJS.
2. An example of wrapping Rust internal modules into JavaScript modules for Node.js APIs, such as encoding and http.

**Potential Issues or Areas for Improvement**

1. **Documentation**: While the documentation is comprehensive, it might be beneficial to create separate sections for each approach (JavaScript Modules and Rust Internal Modules) for easier comparison.
2. **Error Handling**: The current implementation does not handle errors properly, which could lead to unexpected behavior or crashes.
3. **Performance Optimization**: Some Node.js functions are CPU-intensive; consider implementing optimized versions in Rust for better performance.
4. **Integration with WasmEdge QuickJS**: Ensure seamless integration between the two projects by reviewing and testing each other's APIs regularly.

Overall, this documentation provides a clear understanding of how to implement Node.js support in WasmEdge QuickJS using both JavaScript modules and Rust internal modules. However, some areas require attention to improve error handling, performance optimization, and overall project integration."
i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/nodejs.md,"---
sidebar_position: 5
---

# Node.js support

Many existing JavaScript apps use Node.js built-in APIs. To support and reuse these JavaScript apps, we are implementing many Node.JS APIs for WasmEdge QuickJS. The goal is to have unmodified Node.js programs running in WasmEdge QuickJS.

To use Node.js APIs in WasmEdge, you must make the `modules` directory from [wasmedge-quickjs](https://github.com/second-state/wasmedge-quickjs) accessible to the WasmEdge Runtime. The most straightforward approach is to clone the [wasmedge-quickjs](https://github.com/second-state/wasmedge-quickjs) repo and run the Node.js app from the repo's top directory.

```bash
# Clone the wasmedge-quickjs
git clone https://github.com/second-state/wasmedge-quickjs
# Use the wasmedge-quickjs directory as the working directory for modules access
cd wasmedge-quickjs
# Download a released WasmEdge QuickJS runtime
curl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm
# Copy the nodejs project to the current working directory and run the nodejs app
cp -r /path/to/my_node_app .
wasmedge --dir .:. wasmedge_quickjs.wasm my_node_app/index.js
```

<!-- prettier-ignore -->
:::note
If you want to run `wasmedge` from a directory outside the repo, you will need to tell it where to find the `modules` directory using the `--dir` option. A typical command will look like this: `wasmedge --dir .:. --dir ./modules:/path/to/modules wasmedge_quickjs.wasm app.js`
:::

The progress of Node.js support in WasmEdge QuickJS is **[tracked in this issue](https://github.com/WasmEdge/WasmEdge/issues/1535).** There are two approaches for supporting Node.js APIs in WasmEdge QuickJS.

## The JavaScript modules

Some Node.js functions can be implemented in pure JavaScript using the [modules](modules) approach. For example,

- The [querystring](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/querystring.js) functions just perform string manipulations.
- The [buffer](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/buffer.js) functions manage and encode arrays and memory structures.
- The [encoding](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/encoding.js) and [http](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/http.js) functions support corresponding Node.js APIs by wrapping around [Rust internal modules](rust).

## The Rust internal modules

Other Node.js functions must be implemented using the [internal_module](rust) approach in Rust. There are two reasons for that. First, some Node.js API functions are CPU intensive (e.g., encoding) and is most efficiently implemented in Rust. Second, some Node.js API functions require access to the underlying system (e.g., networking and file system) through native host functions.

- The [core](https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/core.rs) module provides OS-level functions such as `timeout`.
- The [encoding](https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/encoding.rs) module provides high-performance encoding and decoding functions, which are in turn [wrapped into Node.js encoding APIs](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/encoding.js).
- The [wasi_net_module](https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/wasi_net_module.rs) provides JavaScript networking functions implemented via the Rust-based WasmEdge WASI socket API. It is then wrapped into the [Node.js http module](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/http.js).

Node.js compatibility support in WasmEdge QuickJS is a work in progress. It is an excellent way for new developers to get familiar with WasmEdge QuickJS. Join us!
","**Summary**

This documentation provides guidance on how to use Node.js APIs within the WasmEdge QuickJS runtime. The goal is to allow unmodified Node.js programs to run in WasmEdge QuickJS without modifications.

To achieve this, two approaches are being implemented:

1. **JavaScript modules**: Pure JavaScript implementation of some Node.js functions using the `modules` approach.
2. **Rust internal modules**: Implementation of CPU-intensive and system-accessing Node.js functions using the `internal_module` approach in Rust.

**Key Components**

* `wasmedge-quickjs` repository: Provides the necessary modules for WasmEdge QuickJS to access Node.js APIs.
* `modules` directory: Contains pure JavaScript implementations of some Node.js functions.
* `Rust internal modules`: Implements CPU-intensive and system-accessing Node.js functions using Rust.

**Potential Issues or Areas for Improvement**

* The documentation assumes a basic understanding of WasmEdge QuickJS, Node.js, and Rust. Users may require additional guidance on these topics to successfully implement Node.js APIs in WasmEdge QuickJS.
* The implementation of Node.js APIs in Rust may not be optimal due to the use of `internal_module` approach, which may lead to performance issues.
* The documentation does not provide clear instructions for users who want to contribute to the project or report issues.
* The project tracking issue (WasmEdge/WasmEdge#1535) should be regularly updated with the progress and status of Node.js compatibility support in WasmEdge QuickJS."
i18n/zh/docusaurus-plugin-content-docs/current/start/build-and-run/aot.md,"---
sidebar_position: 3
---

# AoT 编译器

安装完成后（请参阅[安装指南](../install.md#install)），用户可以执行 `wasmedge compile` 命令。

`wasmedge compile` 命令的用法如下：

```bash
$ wasmedge compile -h
USAGE
   wasmedge compile [OPTIONS] [--] WASM WASM_SO

...
```

`wasmedge compile` 命令可将 WebAssembly 编译为本机机器码（即，AOT 编译器）。对于纯 WebAssembly，`wasmedge` 工具将以解释器模式执行 WASM。通过 `wasmedge compile` AOT 编译器编译后，`wasmedge` 工具可以以 AOT 模式执行 WASM，速度要快得多。

## 选项

`wasmedge compile` 命令的选项如下。

1. `-h|--help`：显示帮助信息。将忽略下面的其他参数。
2. （可选）`--dump`：将 LLVM IR 转储到 `wasm.ll` 和 `wasm-opt.ll`。
3. （可选）`--interruptible`：生成支持可中断执行的二进制文件。
   - 默认情况下，AOT 编译的 WASM 不支持[异步执行中的中断](../../embed/c/reference/0.12.x#async)。
4. （可选）统计信息：
   - 默认情况下，即使在运行 `wasmedge` 工具时打开选项，AOT 编译的 WASM 也不支持所有统计信息。
   - 使用 `--enable-time-measuring` 生成用于启用执行时间测量统计的代码。
   - 使用 `--enable-gas-measuring` 生成用于启用执行中的 gas 测量统计的代码。
   - 使用 `--enable-instruction-count` 生成用于启用 WebAssembly 指令计数统计的代码。
5. （可选）`--generic-binary`：生成通用二进制文件。
6. （可选）WebAssembly 提案：
   - 使用 `--disable-import-export-mut-globals` 禁用[可变全局变量的导入/导出](https://github.com/WebAssembly/mutable-global) 提案（默认为 `ON`）。
   - 使用 `--disable-non-trap-float-to-int` 禁用[非陷阱浮点到整数转换](https://github.com/WebAssembly/nontrapping-float-to-int-conversions) 提案（默认为 `ON`）。
   - 使用 `--disable-sign-extension-operators` 禁用[符号扩展运算符](https://github.com/WebAssembly/sign-extension-ops) 提案（默认为 `ON`）。
   - 使用 `--disable-multi-value` 禁用[多值](https://github.com/WebAssembly/multi-value) 提案（默认为 `ON`）。
   - 使用 `--disable-bulk-memory` 禁用[批量内存操作](https://github.com/WebAssembly/bulk-memory-operations) 提案（默认为 `ON`）。
   - 使用 `--disable-reference-types` 禁用[引用类型](https://github.com/WebAssembly/reference-types) 提案（默认为 `ON`）。
   - 使用 `--disable-simd` 禁用[固定宽度 SIMD](https://github.com/webassembly/simd) 提案（默认为 `ON`）。
   - 使用 `--enable-multi-memory` 启用[多内存](https://github.com/WebAssembly/multi-memory) 提案（默认为 `OFF`）。
   - 使用 `--enable-tail-call` 启用[尾调用](https://github.com/WebAssembly/tail-call) 提案（默认为 `OFF`）。
   - 使用 `--enable-extended-const` 启用[扩展常量表达式](https://github.com/WebAssembly/extended-const) 提案（默认为 `OFF`）。
   - 使用 `--enable-threads` 启用[线程](https://github.com/webassembly/threads) 提案（默认为 `OFF`）。
   - 使用 `--enable-all` 启用上述所有提案。
7. （可选）`--optimize`：选择 LLVM 优化级别。
   - 使用 `--optimize LEVEL` 来设置优化级别。`LEVEL` 应为 `0`、`1`、`2`、`3`、`s` 或 `z` 中的一个。
   - 默认值为 `2`，即 `O2`。
8. 输入的 WASM 文件（`/path/to/wasm/file`）。
9. 输出路径（`/path/to/output/file`）。
   - 默认情况下，`wasmedge compile` 命令将输出[通用的 WASM 格式](#output-format-universal-wasm)。
   - 如果在输出路径中指定了特定的文件扩展名（在 Linux 上为 `.so`，在 MacOS 上为 `.dylib`，在 Windows 上为 `.dll`），`wasmedge compile` 命令将输出[共享库格式](#output-format-shared-library)。

## 示例

我们创建了纯手工编写的 [fibonacci.wat](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wat) 并使用 [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) 工具将其转换为 `fibonacci.wasm` WebAssembly 程序。以此为例，将它导出为一个接收单个 `i32` 整数作为输入参数的 `fib()` 函数。

你可以执行：

```bash
wasmedge compile fibonacci.wasm fibonacci_aot.wasm
```

或者：

```bash
wasmedge compile fibonacci.wasm fibonacci_aot.so # 在 Linux 上
```

输出将会是：

```bash
[2022-09-09 14:22:10.540] [info] compile start
[2022-09-09 14:22:10.541] [info] verify start
[2022-09-09 14:22:10.542] [info] optimize start
[2022-09-09 14:22:10.547] [info] codegen start
[2022-09-09 14:22:10.552] [info] output start
[2022-09-09 14:22:10.600] [info] compile done
```

然后，你可以使用 `wasmedge` 执行输出文件并测量执行时间：

```bash
time wasmedge --reactor fibonacci_aot.wasm fib 30
```

输出将会是：

```bash
1346269

real    0m0.029s
user    0m0.012s
sys     0m0.014s
```

接着，你可以与解释器模式进行比较：

```bash
time wasmedge --reactor fibonacci.wasm fib 30
```

输出显示，AOT 编译的 WASM 比解释器模式快得多：

```bash
1346269

real    0m0.442s
user    0m0.427s
sys     0m0.012s
```

## 输出格式：通用 WASM

默认情况下，`wasmedge compile` AOT 编译器工具可以将 AOT 编译的本机二进制文件包装为原始 WASM 文件中的自定义部分。我们称其为通用 WASM 二进制格式。

这个 AOT 编译的 WASM 文件与所有的 WebAssembly runtime 兼容。但是，当 WasmEdge runtime 执行此 WASM 文件时，WasmEdge 将从自定义部分提取本机二进制并以 AOT 模式执行它。

<!-- prettier-ignore -->
:::note
在 MacOS 平台上，通用 WASM 格式在执行时会产生 `bus error`。默认情况下，`wasmedge compile` 工具会以 `O2` 级别优化 WASM。我们正在尝试解决此问题。请使用共享库输出格式以暂时解决此问题。
:::

```bash
wasmedge compile app.wasm app_aot.wasm
wasmedge app_aot.wasm
```

## 输出格式：共享库

用户可以为输出文件指定共享库扩展名（在 Linux 上为 `.so`，在 MacOS 上为 `.dylib`，在 Windows 上为 `.dll`），以生成共享库格式的输出。

这个 AOT 编译的 WASM 文件仅供 WasmEdge 使用，其他 WebAssembly runtime 无法使用。

```bash
wasmedge compile app.wasm app_aot.so
wasmedge app_aot.so
```
","此文档描述了如何使用 `wasmedge compile` 命令将 WebAssembly (WASM) 编译为本机机器码（AOT编译）。这是 WasmEdge 运行时环境中一种高效的方式，允许执行 WASM 应用程序。 

以下是关键功能和选项：

1.  **安装和使用 `wasmedge compile` 命令**:文档提供了 `wasmedge compile` 命令的语法、可用的参数以及一些示例。
2.  **AOT 编译优化级别：**用户可以选择不同的优化级别（0、1、2、3、s 或 z），以控制生成的二进制文件的大小和执行效率。
3.  **输出格式**:文档提到了两个可能的输出格式：通用 WASM 格式（默认）和共享库格式（指定扩展名）。用户可以根据需要选择其中一个。

总的来说，`wasmedge compile` 命令为开发人员提供了一种快速有效地将 WebAssembly 应用程序编译为本机机器码的方式，从而实现更好的性能。"
docs/contribute/source/plugin/wasi_crypto.md,"---
sidebar_position: 1
---

# Build with WASI-Crypto Plug-in

WebAssembly System Interface (WASI) Crypto is a proposal for a set of APIs that provide cryptographic operations for WebAssembly modules. It aims to provide a consistent, portable, and secure interface for cryptographic operations across different platforms. The WasmEdge WASI-Crypto plug-in is an implementation of this proposal, providing cryptographic functionalities to WebAssembly applications running on the WasmEdge runtime.

## Prerequisites

Currently, WasmEdge used `OpenSSL 1.1` or `3.0` for the WASI-Crypto implementation.

For installing `OpenSSL 1.1` development package on `Ubuntu 20.04`, we recommend the following commands:

```bash
sudo apt update
sudo apt install -y libssl-dev
```

For legacy systems such as `CensOS 7.6`, or if you want to build `OpenSSL 1.1` from source, you can refer to the following commands:

```bash
# Download and extract the OpenSSL source to the current directory.
curl -s -L -O --remote-name-all https://www.openssl.org/source/openssl-1.1.1n.tar.gz
echo ""40dceb51a4f6a5275bde0e6bf20ef4b91bfc32ed57c0552e2e8e15463372b17a openssl-1.1.1n.tar.gz"" | sha256sum -c
tar -xf openssl-1.1.1n.tar.gz
cd ./openssl-1.1.1n
# OpenSSL configure need newer perl.
curl -s -L -O --remote-name-all https://www.cpan.org/src/5.0/perl-5.34.0.tar.gz
tar -xf perl-5.34.0.tar.gz
cd perl-5.34.0
mkdir localperl
./Configure -des -Dprefix=$(pwd)/localperl/
make -j
make install
export PATH=""$(pwd)/localperl/bin/:$PATH""
cd ..
# Configure by previous perl.
mkdir openssl
./perl-5.34.0/localperl/bin/perl ./config --prefix=$(pwd)/openssl --openssldir=$(pwd)/openssl
make -j
make test
make install
cd ..
# The OpenSSL installation directory is at `$(pwd)/openssl-1.1.1n/openssl`.
# Then you can use the `-DOPENSSL_ROOT_DIR=` option of cmake to assign the directory.
```

For MacOS platforms, you should install the `openssl`:

```bash
brew install openssl
```

<!-- prettier-ignore -->
:::note
We'll soon update this chapter to use `OpenSSL 3.0`.
:::

## Build WasmEdge with WASI-Crypto Plug-in

To enable the WasmEdge WASI-Crypto, developers need to [building the WasmEdge from source](../os/linux.md) with the cmake option `-DWASMEDGE_PLUGIN_WASI_CRYPTO=ON`.

```bash
cd <path/to/your/wasmedge/source/folder>
# For using self-get OpenSSL, you can assign the cmake option `-DOPENSSL_ROOT_DIR=<path/to/openssl>`.
# On MacOS, it may be: `-DOPENSSL_ROOT_DIR=$(brew --prefix)/opt/openssl`
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_CRYPTO=On
cmake --build build
# For the WASI-Crypto plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-Crypto plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_crypto/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-Crypto plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiCrypto.so` after installation.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasi_crypto).
","**Summary**

The provided code is a set of instructions on how to build and use the WasmEdge WASI-Crypto plug-in, which provides cryptographic functionalities for WebAssembly applications running on the WasmEdge runtime. The plug-in relies on OpenSSL 1.1 or 3.0 for its implementation.

**Key Components**

1. **Prerequisites**: The code requires users to install OpenSSL 1.1 or 3.0, depending on their operating system (Ubuntu, CentOS, MacOS).
2. **Building WasmEdge with WASI-Crypto Plug-in**: Developers need to build the WasmEdge runtime from source using CMake, specifying the `-DWASMEDGE_PLUGIN_WASI_CRYPTO=ON` option to enable the plug-in.
3. **Installation**: After building, users can install the WasmEdge runtime and the WASI-Crypto plug-in.

**Potential Issues/Improvement Areas**

1. **Outdated instructions**: The code mentions that OpenSSL 3.0 will soon replace OpenSSL 1.1, but the instructions for installing OpenSSL 3.0 are not provided.
2. **Platform-specific installation commands**: The code provides platform-specific installation commands (e.g., `apt install` on Ubuntu) which may not be applicable to other platforms or users with different package managers.
3. **CMake options**: The `-DWASMEDGE_PLUGIN_WASI_CRYPTO=On` option is specified as a string (with a capital ""O"") in the code, but it should be an integer value (`1`) for CMake.

**Recommendations**

To improve the code:

1. Update instructions to use OpenSSL 3.0.
2. Provide platform-agnostic installation commands using package managers or other methods that work across different platforms.
3. Correct the CMake option value to an integer (`1`)."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_crypto.md,"---
sidebar_position: 1
---

# Build with WASI-Crypto Plug-in

WebAssembly System Interface (WASI) Crypto is a proposal for a set of APIs that provide cryptographic operations for WebAssembly modules. It aims to provide a consistent, portable, and secure interface for cryptographic operations across different platforms. The WasmEdge WASI-Crypto plug-in is an implementation of this proposal, providing cryptographic functionalities to WebAssembly applications running on the WasmEdge runtime.

## Prerequisites

Currently, WasmEdge used `OpenSSL 1.1` or `3.0` for the WASI-Crypto implementation.

For installing `OpenSSL 1.1` development package on `Ubuntu 20.04`, we recommend the following commands:

```bash
sudo apt update
sudo apt install -y libssl-dev
```

For legacy systems such as `CensOS 7.6`, or if you want to build `OpenSSL 1.1` from source, you can refer to the following commands:

```bash
# Download and extract the OpenSSL source to the current directory.
curl -s -L -O --remote-name-all https://www.openssl.org/source/openssl-1.1.1n.tar.gz
echo ""40dceb51a4f6a5275bde0e6bf20ef4b91bfc32ed57c0552e2e8e15463372b17a openssl-1.1.1n.tar.gz"" | sha256sum -c
tar -xf openssl-1.1.1n.tar.gz
cd ./openssl-1.1.1n
# OpenSSL configure need newer perl.
curl -s -L -O --remote-name-all https://www.cpan.org/src/5.0/perl-5.34.0.tar.gz
tar -xf perl-5.34.0.tar.gz
cd perl-5.34.0
mkdir localperl
./Configure -des -Dprefix=$(pwd)/localperl/
make -j
make install
export PATH=""$(pwd)/localperl/bin/:$PATH""
cd ..
# Configure by previous perl.
mkdir openssl
./perl-5.34.0/localperl/bin/perl ./config --prefix=$(pwd)/openssl --openssldir=$(pwd)/openssl
make -j
make test
make install
cd ..
# The OpenSSL installation directory is at `$(pwd)/openssl-1.1.1n/openssl`.
# Then you can use the `-DOPENSSL_ROOT_DIR=` option of cmake to assign the directory.
```

For MacOS platforms, you should install the `openssl`:

```bash
brew install openssl
```

<!-- prettier-ignore -->
:::note
We'll soon update this chapter to use `OpenSSL 3.0`.
:::

## Build WasmEdge with WASI-Crypto Plug-in

To enable the WasmEdge WASI-Crypto, developers need to [building the WasmEdge from source](../os/linux.md) with the cmake option `-DWASMEDGE_PLUGIN_WASI_CRYPTO=ON`.

```bash
cd <path/to/your/wasmedge/source/folder>
# For using self-get OpenSSL, you can assign the cmake option `-DOPENSSL_ROOT_DIR=<path/to/openssl>`.
# On MacOS, it may be: `-DOPENSSL_ROOT_DIR=$(brew --prefix)/opt/openssl`
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_CRYPTO=On
cmake --build build
# For the WASI-Crypto plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-Crypto plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_crypto/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-Crypto plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiCrypto.so` after installation.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasi_crypto).
","**Summary**

The provided code is a documentation of the WasmEdge WASI-Crypto plug-in, which provides cryptographic functionalities to WebAssembly applications running on the WasmEdge runtime. The document outlines the prerequisites for installing OpenSSL 1.1 or 3.0 and provides instructions for building the WasmEdge from source with the WASI-Crypto plug-in enabled.

**Key Components**

*   **WASMEdge**: A runtime environment for WebAssembly applications.
*   **WASI-Crypto**: A set of APIs for cryptographic operations in WebAssembly modules.
*   **OpenSSL**: A library used for cryptographic functions in WasmEdge.
*   **cmake**: A build system used to configure and build WasmEdge from source.

**Functionality**

The document guides developers through the process of:

1.  Installing OpenSSL 1.1 or 3.0 on different platforms (Ubuntu, MacOS).
2.  Building WasmEdge from source with the WASI-Crypto plug-in enabled.
3.  Configuring the build system to include the WASI-Crypto plug-in.

**Potential Issues**

*   The document assumes that developers have a basic understanding of WebAssembly and the WasmEdge runtime environment.
*   The instructions for building WasmEdge from source may be complex and require significant time and effort.
*   The use of OpenSSL 1.1 or 3.0 may lead to compatibility issues with certain systems or applications.

**Areas for Improvement**

*   Provide more detailed instructions for building WasmEdge from source, including troubleshooting guides for common issues.
*   Consider adding a section on testing the WASI-Crypto plug-in and providing example use cases.
*   Update the documentation to reflect any changes in the WasmEdge API or WASI-Crypto implementation."
docs/contribute/source/plugin/tensorflow.md,"---
sidebar_position: 5
---

# Build WasmEdge With WasmEdge-Tensorflow Plug-in

The WasmEdge-TensorFlow plug-in is a software component that extends the functionality of the WasmEdge runtime. It allows developers to perform TensorFlow model inference with similar APIs to Python. The plug-in is designed for Rust to WebAssembly applications and depends on the TensorFlow C library for its operations.

## Prerequisites

The prerequisites of the WasmEdge-Tensorflow plug-in is the same as the WasmEdge building environment on the [Linux platforms](../os/linux.md) or [MacOS platforms](../os/macos.md).

## Build WasmEdge with WasmEdge-Tensorflow Plug-in

To enable the WasmEdge WasmEdge-Tensorflow, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_TENSORFLOW=On`.

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_TENSORFLOW=On
cmake --build build
# For the WasmEdge-Tensorflow plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WasmEdge-Tensorflow plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_tensorflow/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-Tensorflow plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeTensorflow.so` after installation.

## Install the TensorFlow Dependency

Installing the necessary `libtensorflow_cc.so` and `libtensorflow_framework.so` on both `Linux` and `MacOS` platforms, we recommend the following commands:

```bash
curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
# For the Linux aarch64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_aarch64.tar.gz`.
# For the MacOS x86_64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-darwin_x86_64.tar.gz`.
# For the MacOS arm64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-darwin_arm64.tar.gz`.
tar -zxf WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
rm -f WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
```

The shared library will be extracted in the current directory `./libtensorflow_cc.so.2.12.0` and `./libtensorflow_framework.so.2.12.0` on `Linux` platforms, or `./libtensorflow_cc.2.12.0.dylib` and `./libtensorflow_framework.2.12.0.dylib` on `MacOS` platforms.

<!-- prettier-ignore -->
:::note
After building the plug-in, you can also find these shared libraries under the `build/_deps/wasmedge_tensorflow_lib_tf-src/` directory.
:::

Then you can move the library to the installation path and create the symbolic link:

```bash
mv libtensorflow_cc.so.2.12.0 /usr/local/lib
mv libtensorflow_framework.so.2.12.0 /usr/local/lib
ln -s libtensorflow_cc.so.2.12.0 /usr/local/lib/libtensorflow_cc.so.2
ln -s libtensorflow_cc.so.2 /usr/local/lib/libtensorflow_cc.so
ln -s libtensorflow_framework.so.2.12.0 /usr/local/lib/libtensorflow_framework.so.2
ln -s libtensorflow_framework.so.2 /usr/local/lib/libtensorflow_framework.so
```

If on `MacOS` platforms:

```bash
mv libtensorflow_cc.2.12.0.dylib /usr/local/lib
mv libtensorflow_framework.2.12.0.dylib /usr/local/lib
ln -s libtensorflow_cc.2.12.0.dylib /usr/local/lib/libtensorflow_cc.2.dylib
ln -s libtensorflow_cc.2.dylib /usr/local/lib/libtensorflow_cc.dylib
ln -s libtensorflow_framework.2.12.0.dylib /usr/local/lib/libtensorflow_framework.2.dylib
ln -s libtensorflow_framework.2.dylib /usr/local/lib/libtensorflow_framework.dylib
```

Or create the symbolic link in the current directory and set the environment variable `export LD_LIBRARY_PATH=$(pwd):${LD_LIBRARY_PATH}`.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_tensorflow).
","**Summary**

The provided code is a guide on how to build and install the WasmEdge-TensorFlow plug-in, which allows developers to perform TensorFlow model inference with similar APIs to Python. The plug-in depends on the TensorFlow C library for its operations.

**Key Components**

1. Building WasmEdge with WasmEdge-TensorFlow plug-in: This involves running cmake with specific options to enable the plug-in.
2. Installing the plug-in: After building, the plug-in can be installed using cmake's `--install` option.
3. Installing TensorFlow dependency: The necessary libraries (libtensorflow_cc.so and libtensorflow_framework.so) need to be downloaded and extracted manually.
4. Setting up environment variables: To use the plug-in, environment variables such as `WASMEDGE_PLUGIN_PATH` and `LD_LIBRARY_PATH` need to be set.

**Potential Issues or Areas for Improvement**

1. Manual extraction of libraries: The current process requires manual extraction and installation of TensorFlow dependencies, which may lead to version conflicts or other issues.
2. Complex build process: The build process involves multiple steps, including building WasmEdge and installing the plug-in, which may be confusing for new users.
3. Limited documentation: While there is a GitHub repository available, more detailed documentation on the plug-in's functionality, usage examples, and troubleshooting might be beneficial.

**Recommendations**

1. Simplify the build process: Consider using a tool like CMake or Meson to simplify the build process and make it more user-friendly.
2. Automate library installation: Instead of manual extraction and installation of TensorFlow dependencies, consider integrating this into the build process.
3. Improve documentation: Add more detailed documentation on the plug-in's functionality, usage examples, and troubleshooting to help new users get started."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/tensorflow.md,"---
sidebar_position: 5
---

# Build WasmEdge With WasmEdge-Tensorflow Plug-in

The WasmEdge-TensorFlow plug-in is a software component that extends the functionality of the WasmEdge runtime. It allows developers to perform TensorFlow model inference with similar APIs to Python. The plug-in is designed for Rust to WebAssembly applications and depends on the TensorFlow C library for its operations.

## Prerequisites

The prerequisites of the WasmEdge-Tensorflow plug-in is the same as the WasmEdge building environment on the [Linux platforms](../os/linux.md) or [MacOS platforms](../os/macos.md).

## Build WasmEdge with WasmEdge-Tensorflow Plug-in

To enable the WasmEdge WasmEdge-Tensorflow, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_TENSORFLOW=On`.

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_TENSORFLOW=On
cmake --build build
# For the WasmEdge-Tensorflow plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WasmEdge-Tensorflow plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_tensorflow/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-Tensorflow plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeTensorflow.so` after installation.

## Install the TensorFlow Dependency

Installing the necessary `libtensorflow_cc.so` and `libtensorflow_framework.so` on both `Linux` and `MacOS` platforms, we recommend the following commands:

```bash
curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
# For the Linux aarch64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_aarch64.tar.gz`.
# For the MacOS x86_64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-darwin_x86_64.tar.gz`.
# For the MacOS arm64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-darwin_arm64.tar.gz`.
tar -zxf WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
rm -f WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
```

The shared library will be extracted in the current directory `./libtensorflow_cc.so.2.12.0` and `./libtensorflow_framework.so.2.12.0` on `Linux` platforms, or `./libtensorflow_cc.2.12.0.dylib` and `./libtensorflow_framework.2.12.0.dylib` on `MacOS` platforms.

<!-- prettier-ignore -->
:::note
After building the plug-in, you can also find these shared libraries under the `build/_deps/wasmedge_tensorflow_lib_tf-src/` directory.
:::

Then you can move the library to the installation path and create the symbolic link:

```bash
mv libtensorflow_cc.so.2.12.0 /usr/local/lib
mv libtensorflow_framework.so.2.12.0 /usr/local/lib
ln -s libtensorflow_cc.so.2.12.0 /usr/local/lib/libtensorflow_cc.so.2
ln -s libtensorflow_cc.so.2 /usr/local/lib/libtensorflow_cc.so
ln -s libtensorflow_framework.so.2.12.0 /usr/local/lib/libtensorflow_framework.so.2
ln -s libtensorflow_framework.so.2 /usr/local/lib/libtensorflow_framework.so
```

If on `MacOS` platforms:

```bash
mv libtensorflow_cc.2.12.0.dylib /usr/local/lib
mv libtensorflow_framework.2.12.0.dylib /usr/local/lib
ln -s libtensorflow_cc.2.12.0.dylib /usr/local/lib/libtensorflow_cc.2.dylib
ln -s libtensorflow_cc.2.dylib /usr/local/lib/libtensorflow_cc.dylib
ln -s libtensorflow_framework.2.12.0.dylib /usr/local/lib/libtensorflow_framework.2.dylib
ln -s libtensorflow_framework.2.dylib /usr/local/lib/libtensorflow_framework.dylib
```

Or create the symbolic link in the current directory and set the environment variable `export LD_LIBRARY_PATH=$(pwd):${LD_LIBRARY_PATH}`.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_tensorflow).
","**Summary:**

The provided code is a documentation for building the WasmEdge runtime with the TensorFlow plug-in. It includes instructions on setting up the prerequisites, building the WasmEdge source code with the required CMake options, and installing the necessary libraries for TensorFlow.

**Key Components:**

1. **Prerequisites:** The code lists the prerequisites for building the WasmEdge-TensorFlow plug-in, which are the same as those for the WasmEdge building environment.
2. **Building WasmEdge with WasmEdge-TensorFlow Plug-in:** This section provides instructions on how to build the WasmEdge source code with the required CMake options and install the WasmEdge-TensorFlow plug-in.
3. **Installing TensorFlow Dependency:** The code includes steps for installing the necessary libraries for TensorFlow, including `libtensorflow_cc.so` and `libtensorflow_framework.so`, on Linux and MacOS platforms.

**Potential Issues or Areas for Improvement:**

1. **Platform-specific instructions:** The code has platform-specific instructions for building and installing the WasmEdge-TensorFlow plug-in. This may lead to confusion for users who are not familiar with the specific platform they are working on.
2. **Complexity of installation process:** The installation process involves multiple steps, including building the WasmEdge source code, installing the WasmEdge-TensorFlow plug-in, and setting up the TensorFlow libraries. This may be overwhelming for users without prior experience in building and installing complex software systems.
3. **Documentation quality:** While the provided documentation is detailed, it could benefit from more clear and concise language to make it easier for users to follow the instructions.
4. **Lack of error handling:** The code does not include any error handling mechanisms, which may lead to difficulties in troubleshooting issues that arise during the installation process.

**Suggestions for Improvement:**

1. **Simplify platform-specific instructions:** Consider providing a single set of instructions that can be applied across multiple platforms.
2. **Improve documentation quality:** Use clear and concise language to make the documentation more accessible to users.
3. **Add error handling mechanisms:** Incorporate checks and error messages to help users troubleshoot issues during the installation process.
4. **Provide additional resources:** Consider providing links to external resources, such as tutorials or forums, to assist users who are new to building and installing complex software systems."
docs/contribute/source/os/windows.md,"---
sidebar_position: 3
---

# Build on Windows 10

You can also find the details [here](https://github.com/WasmEdge/WasmEdge/blob/master/.github/workflows/reusable-build-on-windows.yml#L37-L48).

## Get Source Code

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
```

## Requirements and Dependencies

WasmEdge requires LLVM 16 and you may need to install these following dependencies by yourself.

- [Chocolatey](https://chocolatey.org/install), we use it to install `cmake`, `ninja`, and `vswhere`.
- [Windows SDK 19041](https://blogs.windows.com/windowsdeveloper/2020/05/12/start-developing-on-windows-10-version-2004-today/)
- LLVM 16.0.6, download the pre-built files [here](https://github.com/WasmEdge/llvm-windows/releases) or you can just follow the `instructions/commands` to download automatically.

<!-- prettier-ignore -->
:::note
If you use the community version of Visual Studio, you may encounter errors like: `ninja: error: 'C:/Program Files/Microsoft Visual Studio/2022/Enterprise/DIA SDK/lib/amd64/diaguids.lib', needed by 'test/aot/wasmedgeAOTCoreTests.exe', missing and no known rule to make it`. You need to manually open the file `LLVM-16.0.6-win64/lib/cmake/llvm/LLVMExports.cmake`, search for the only occurrence of `Enterprise` and change it to `Community`. See [this issue](https://github.com/WasmEdge/WasmEdge/issues/1290#issuecomment-1056784554) for details.
:::

```powershell
# Install the required tools
choco install cmake ninja vswhere

$vsPath = (vswhere -latest -property installationPath)
# If vswhere.exe is not in PATH, try the following instead.
# $vsPath = (&""C:\Program Files (x86)\Microsoft Visual Studio\Installer\vswhere.exe"" -latest -property installationPath)

Import-Module (Join-Path $vsPath ""Common7\Tools\Microsoft.VisualStudio.DevShell.dll"")
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments ""-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0""

# Download our pre-built LLVM 16 binary
$llvm = ""LLVM-16.0.6-win64-MultiThreadedDLL.zip""
curl -sLO https://github.com/WasmEdge/llvm-windows/releases/download/llvmorg-16.0.6/LLVM-16.0.6-win64-MultiThreadedDLL.zip -o $llvm
Expand-Archive -Path $llvm

# Set LLVM environment
$llvm_dir = ""$pwd\LLVM-16.0.6-win64-MultiThreadedDLL\LLVM-16.0.6-win64\lib\cmake\llvm""
```

## Build WasmEdge

On Windows, either Clang-cl or MSVC can be used to build WasmEdge. To use MSVC, simply comment out the two lines that set the environment variables `CC` and `CXX`.

```powershell
$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath ""Common7\Tools\Microsoft.VisualStudio.DevShell.dll"")
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments ""-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0""
# If you would like to use MSVC, and want to use a specific version of MSVC, set the arg `vcvars_ver` like the following.
# Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments ""-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0 -vcvars_ver=14.34.31933""

# Set LLVM path according to the download location
$llvm_dir = ""$pwd\LLVM-16.0.6-win64-MultiThreadedDLL\LLVM-16.0.6-win64\lib\cmake\llvm""

# Use clang-cl as the compiler.
# Comment out the following two lines to use MSVC.
$Env:CC = ""clang-cl""
$Env:CXX = ""clang-cl""

cmake -Bbuild -GNinja -DCMAKE_SYSTEM_VERSION=10.0.19041.0 -DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreadedDLL ""-DLLVM_DIR=$llvm_dir"" -DWASMEDGE_BUILD_TESTS=ON -DWASMEDGE_BUILD_PACKAGE=""ZIP"" .
cmake --build build
```

## Run Tests

The following tests are available only when the build option `WASMEDGE_BUILD_TESTS` was set to `ON`.

Users can use these tests to verify the correctness of WasmEdge binaries.

```powershell
$Env:PATH += "";$pwd\build\lib\api""
cd build
ctest --output-on-failure
cd -
```
","**Summary**

This documentation provides a step-by-step guide for building WasmEdge on Windows 10. The process involves cloning the WasmEdge source code, installing required dependencies and tools, setting up the LLVM environment, and finally building WasmEdge using either Clang-cl or MSVC.

**Key Components**

1. **Getting Source Code**: Clone the WasmEdge repository from GitHub using `git clone`.
2. **Requirements and Dependencies**: Install Chocolatey, Windows SDK 19041, and LLVM 16.0.6 (either by downloading pre-built files or following installation instructions).
3. **Building WasmEdge**:
	* Set up the LLVM environment by importing the DevShell module and entering the VsDevShell.
	* Choose either Clang-cl or MSVC as the compiler by setting the `CC` and `CXX` environment variables.
4. **Running Tests**: Run tests using the `ctest` command to verify the correctness of WasmEdge binaries.

**Potential Issues**

1. **Community Edition of Visual Studio**: If using the community edition, modify the `LLVMExports.cmake` file to resolve an error related to missing rules for building `diaguids.lib`.
2. **Path and Environment Variables**: Ensure that path variables are correctly set for tools like `vswhere`, `choco`, and `cmake`.

**Improvement Suggestions**

1. **Simplify the Build Process**: Consider streamlining the build process by providing pre-built binaries or using a more robust build system.
2. **Improve Error Handling**: Enhance error handling and reporting to help users diagnose issues with the build process.
3. **Documentations Updates**: Regularly update documentation to reflect changes in dependencies, tools, or build processes."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/windows.md,"---
sidebar_position: 3
---

# Build on Windows 10

You can also find the details [here](https://github.com/WasmEdge/WasmEdge/blob/master/.github/workflows/reusable-build-on-windows.yml#L37-L48).

## Get Source Code

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
```

## Requirements and Dependencies

WasmEdge requires LLVM 16 and you may need to install these following dependencies by yourself.

- [Chocolatey](https://chocolatey.org/install), we use it to install `cmake`, `ninja`, and `vswhere`.
- [Windows SDK 19041](https://blogs.windows.com/windowsdeveloper/2020/05/12/start-developing-on-windows-10-version-2004-today/)
- LLVM 16.0.6, download the pre-built files [here](https://github.com/WasmEdge/llvm-windows/releases) or you can just follow the `instructions/commands` to download automatically.

<!-- prettier-ignore -->
:::note
If you use the community version of Visual Studio, you may encounter errors like: `ninja: error: 'C:/Program Files/Microsoft Visual Studio/2022/Enterprise/DIA SDK/lib/amd64/diaguids.lib', needed by 'test/aot/wasmedgeAOTCoreTests.exe', missing and no known rule to make it`. You need to manually open the file `LLVM-16.0.6-win64/lib/cmake/llvm/LLVMExports.cmake`, search for the only occurrence of `Enterprise` and change it to `Community`. See [this issue](https://github.com/WasmEdge/WasmEdge/issues/1290#issuecomment-1056784554) for details.
:::

```powershell
# Install the required tools
choco install cmake ninja vswhere

$vsPath = (vswhere -latest -property installationPath)
# If vswhere.exe is not in PATH, try the following instead.
# $vsPath = (&""C:\Program Files (x86)\Microsoft Visual Studio\Installer\vswhere.exe"" -latest -property installationPath)

Import-Module (Join-Path $vsPath ""Common7\Tools\Microsoft.VisualStudio.DevShell.dll"")
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments ""-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0""

# Download our pre-built LLVM 16 binary
$llvm = ""LLVM-16.0.6-win64-MultiThreadedDLL.zip""
curl -sLO https://github.com/WasmEdge/llvm-windows/releases/download/llvmorg-16.0.6/LLVM-16.0.6-win64-MultiThreadedDLL.zip -o $llvm
Expand-Archive -Path $llvm

# Set LLVM environment
$llvm_dir = ""$pwd\LLVM-16.0.6-win64-MultiThreadedDLL\LLVM-16.0.6-win64\lib\cmake\llvm""
```

## Build WasmEdge

On Windows, either Clang-cl or MSVC can be used to build WasmEdge. To use MSVC, simply comment out the two lines that set the environment variables `CC` and `CXX`.

```powershell
$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath ""Common7\Tools\Microsoft.VisualStudio.DevShell.dll"")
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments ""-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0""
# If you would like to use MSVC, and want to use a specific version of MSVC, set the arg `vcvars_ver` like the following.
# Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments ""-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0 -vcvars_ver=14.34.31933""

# Set LLVM path according to the download location
$llvm_dir = ""$pwd\LLVM-16.0.6-win64-MultiThreadedDLL\LLVM-16.0.6-win64\lib\cmake\llvm""

# Use clang-cl as the compiler.
# Comment out the following two lines to use MSVC.
$Env:CC = ""clang-cl""
$Env:CXX = ""clang-cl""

cmake -Bbuild -GNinja -DCMAKE_SYSTEM_VERSION=10.0.19041.0 -DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreadedDLL ""-DLLVM_DIR=$llvm_dir"" -DWASMEDGE_BUILD_TESTS=ON -DWASMEDGE_BUILD_PACKAGE=""ZIP"" .
cmake --build build
```

## Run Tests

The following tests are available only when the build option `WASMEDGE_BUILD_TESTS` was set to `ON`.

Users can use these tests to verify the correctness of WasmEdge binaries.

```powershell
$Env:PATH += "";$pwd\build\lib\api""
cd build
ctest --output-on-failure
cd -
```
","**Summary**

This code is a step-by-step guide for building and running WasmEdge on Windows 10. It requires the user to clone the WasmEdge repository, install dependencies (LLVM 16, Chocolatey, Windows SDK 19041), and then use PowerShell scripts to download pre-built LLVM binaries and build WasmEdge using either Clang-cl or MSVC.

**Key Components**

1. **Prerequisites**: The guide assumes that the user has:
	* Git installed on their system.
	* Chocolatey package manager installed on their system.
	* Windows 10 (version 19041) installed on their system.
2. **Downloading Dependencies**:
	* LLVM 16 binary is downloaded from a pre-built location and extracted to a folder.
3. **Building WasmEdge**:
	* The user can choose between Clang-cl or MSVC as the compiler.
	* The build process uses CMake to generate build files and Ninja to perform the actual build.
4. **Running Tests**: After building WasmEdge, the user can run tests using CTest.

**Potential Issues**

1. **Clash of Dependencies**: If multiple versions of dependencies (e.g., LLVM, Chocolatey) are installed on the system, conflicts may arise.
2. **Incorrect Environment Variables**: Incorrectly set environment variables (e.g., $llvm_dir, $vsPath) can prevent the build process from working correctly.

**Areas for Improvement**

1. **Simplifying Build Process**: Consider using a simpler build tool (e.g., Meson) or providing a pre-built binary package.
2. **Error Handling**: Improve error handling in the scripts to make it easier for users to identify and resolve issues.
3. **Documentation**: Provide more detailed documentation on how to use WasmEdge and troubleshoot common errors."
docs/develop/javascript/modules.md,"---
sidebar_position: 7
---

# Built-in modules

The WasmEdge QuickJS runtime supports [ES6](es6) and [NPM](npm) modules for application developers. However, those approaches could be more convenient for system developers. They need an easier way to add multiple JavaScript modules and APIs into the runtime without using build tools like rollup.js. The WasmEdge QuickJS modules system allows developers to drop JavaScript files into a `modules` folder and have the JavaScript functions defined in the files immediately available to all JavaScript programs in the runtime. A good use case for this module's system is to support [Node.js](nodejs) APIs in WasmEdge.

In this article, we will use the [wasmedge-quickjs/modules](https://github.com/second-state/wasmedge-quickjs/tree/main/modules) as an example to showcase how to import NodeJS API or a third-party module.

## Prerequisites

[See here](./hello_world#prerequisites)

## The modules system

The modules system collects JavaScript files in the `modules` directory in the WasmEdge QuickJS distribution. To use the JavaScript functions and APIs defined in those modules, you need to map this directory to the `/modules` directory inside the WasmEdge Runtime instance. The following example shows how to do this on the WasmEdge CLI. You can do this with any of the host language SDKs that support the embedded use of WasmEdge.

```bash
wasmedge --dir /modules:/host/os/path/to/modules wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime
```

## Add your own JavaScript modules

The [module_demo](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/module_demo) shows how you can use the modules system to add your own JavaScript APIs. To run the demo, first copy the two files in the demo's [modules](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/module_demo/modules) directory to your WasmEdge QuickJS's `modules` directory.

```bash
cp example_js/module_demo/modules/* modules/
```

The two JavaScript files in the `modules` directory provide two simple functions. Below is the [modules/my_mod_1.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/modules/my_mod_1.js) file.

```javascript
export function hello_mod_1() {
  console.log('hello from ""my_mod_1.js""');
}
```

And the [modules/my_mod_2.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/modules/my_mod_2.js) file.

```javascript
export function hello_mod_2() {
  console.log('hello from ""my_mod_2.js""');
}
```

Then, just run the [demo.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/demo.js) file to call the two exported functions from the modules.

```javascript
import { hello_mod_1 } from 'my_mod_1';
import { hello_mod_2 } from 'my_mod_2';

hello_mod_1();
hello_mod_2();
```

Here is the command to run the demo and the output.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/module_demo/demo.js
hello from ""my_mod_1.js""
hello from ""my_mod_2.js""
```

Following the above tutorials, you can easily add third-party JavaScript functions and APIs to your WasmEdge QuickJS runtime.

We included JavaScript files to support [Node.js APIs](nodejs) for the official distribution. You can use [those files](https://github.com/second-state/wasmedge-quickjs/tree/main/modules) as further examples.
","**Summary**

The WasmEdge QuickJS runtime supports ES6 and NPM modules for application developers, but provides an easier way for system developers to add multiple JavaScript modules and APIs without using build tools. The WasmEdge QuickJS module system allows developers to drop JavaScript files into a `modules` folder, making them available to all JavaScript programs in the runtime.

**Key Components**

1. **Modules Folder**: A directory that contains JavaScript files, which can be mapped to the `/modules` directory inside the WasmEdge Runtime instance.
2. **Module Mapping**: The process of mapping the `modules` folder to the `/modules` directory using the `--dir` flag in the WasmEdge CLI.
3. **JavaScript Modules**: Files that contain functions and APIs, which can be imported and used by other JavaScript programs in the runtime.

**Use Cases**

1. Adding third-party JavaScript functions and APIs to the WasmEdge QuickJS runtime.
2. Supporting Node.js APIs in the WasmEdge runtime.

**Example Code**

The example code demonstrates how to add custom JavaScript modules to the WasmEdge QuickJS runtime, using a simple `hello_mod_1` function and a `hello_mod_2` function. The code shows how to import these functions from the module using ES6 imports.

**Potential Issues or Areas for Improvement**

1. **Error Handling**: The current implementation does not handle errors that may occur when loading or executing JavaScript modules.
2. **Security**: The use of JavaScript modules in a sandboxed environment like WasmEdge QuickJS requires careful consideration of security risks, such as injection attacks.
3. **Performance**: The performance impact of loading and executing multiple JavaScript modules needs to be evaluated and optimized for production environments.

**Future Development**

The development of the WasmEdge QuickJS module system is ongoing, with plans to include additional features, such as support for WebAssembly (WASM) modules and improved error handling mechanisms."
docs/embed/use-case/plugin/rust_sdk.md,"---
sidebar_position: 2
---

# Using Plug-ins to Extend the Runtime in Rust

The WasmEdge plug-ins are the shared libraries to provide the WasmEdge runtime to load and create host module instances. With the plug-ins, the WasmEdge runtime can be extended more easily.

## Loading Plug-ins from Paths

Developers can start using WasmEdge plug-ins by loading them from specific paths. To load plug-ins from the default paths, the following API can be used:

```rust
impl PluginManager
pub fn load(path: Option<&Path>) -> WasmEdgeResult<()>
```

- The default plug-in paths will be used if the path is not given.

  - The path specified in the `WASMEDGE_PLUGIN_PATH` environment variable.
  - The `../plugin/` directory relative to the WasmEdge installation path.
  - The `./wasmedge/` directory under the library path if WasmEdge is installed in the `/usr` directory.

- If the path is given, then

  - If the path is pointing at a file, then it indicates that a single plug-in will be loaded from the file.
  - If the path is pointing at a directory, then the method will load plug-ins from the files.

To get the names of all loaded plug-ins as returns -

```rust
pub fn names() -> Vec<String>
```

<!-- prettier-ignore -->
:::note
`path` - A path to a plug-in file or a directory holding plug-in files. If `None`, then the default plug-in path will be used.
:::

## Listing Loaded Plug-ins

Once plug-ins are loaded, developers can list the loaded plug-in names using the following approach:

```rust
pub fn names() -> Vec<String>
```

## Getting Plug-in Context by Name

Developers can get the plug-in context by its name using the following method:

```rust
pub fn find(name: impl AsRef<str>) -> Option<Plugin>
```

Here `name` is the name of the target plug-in.

## Getting Module Instances from Plug-ins

With the plug-in context, developers can get module instances by providing the module name:

```rust
pub fn mod_names(&self) -> Vec<String>
```

There may be several plug-ins in the default plug-in paths if users [installed WasmEdge plug-ins by the installer](/contribute/installer.md#plugins).

Before using the plug-ins, developers should [Loading Plug-ins from Paths](#loading-plug-ins-from-paths).

## Plug-in Module Instance

To initialize the `wasmedge_process` plug-in module instance with the parameters -

```rust
pub fn init_wasmedge_process(allowed_cmds: Option<Vec<&str>>, allowed: bool)
```

Here, `allowed_cmds` is A white list of commands and `allowed` determines if wasmedge_process is allowed to execute all commands on the white list.
","**Summary**

The provided code is part of the WasmEdge runtime in Rust, which allows developers to extend the runtime by loading shared libraries called plug-ins. The `PluginManager` API enables loading plug-ins from specific paths, listing loaded plug-in names, getting plug-in contexts by name, and retrieving module instances.

**Key Components**

1. **Loading Plug-ins**: The `load` method takes an optional path parameter, which can be used to load plug-ins from default paths (environment variable, installation directory, or library path) or a specific file/directory.
2. **Listing Loaded Plug-ins**: The `names` method returns a vector of strings containing the names of all loaded plug-ins.
3. **Getting Plug-in Context by Name**: The `find` method takes a string parameter and returns an optional `Plugin` context if found.
4. **Getting Module Instances from Plug-ins**: With a plug-in context, the `mod_names` method returns a vector of strings containing the module names.

**Potential Issues/Improvement Areas**

1. **Error Handling**: The provided code does not handle errors explicitly. Consider adding try-catch blocks to handle potential errors when loading plug-ins or retrieving module instances.
2. **Plugin Management**: Currently, there is no mechanism for managing plug-in dependencies or versioning. This could lead to issues if multiple versions of the same plugin are loaded concurrently.
3. **Security**: Be cautious when allowing arbitrary command execution (e.g., `allowed_cmds` parameter in `init_wasmedge_process`). Ensure proper input validation and sanitization to prevent security vulnerabilities.

**Best Practices**

1. Follow Rust's standard library and coding conventions for consistency and maintainability.
2. Use explicit error handling mechanisms, such as `Result` or `Error`, to handle potential errors.
3. Keep the code modular, reusable, and well-documented to facilitate future development and maintenance."
docs/start/wasmedge/extensions/unique_extensions.md,"---
sidebar_position: 3
---

# Other Extensions

A challenge for running WASM apps on the server side is the lack of support for Linux APIs and common application libraries. WasmEdge fixes this by adding support for many platform APIs for WASM apps. Developers can often simply compile their Linux apps to WASM and expect it run in WasmEdge. WasmEdge provides an easy extension mechanism for the community to add these APIs. For example,

Through its support for networking socket and related APIs, WasmEdge can run Rust applications that

- [provide HTTP services](https://github.com/WasmEdge/wasmedge_hyper_demo)
- [access external web services](https://github.com/WasmEdge/wasmedge_reqwest_demo)
- [connect to databases](https://github.com/WasmEdge/wasmedge-db-examples)
- [connect to messging queues](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql)
- [support database driven microservices](https://github.com/second-state/microservice-rust-mysql)
- [support microservices with Dapr sidecars](https://github.com/second-state/dapr-wasm)

Furthermore, the networking socket APIs also allow us to support the node.js API, including both the `server` and `fetch()`, in WasmEdge's JavaScript runtime.

Through its support for WASI-NN APIs, WasmEdge can support Rust and JavaScript applications for AI inference. Models from popular AI frameworks such as Tensorflow, PyTorch and OpenVINO [are all supported](https://github.com/second-state/WasmEdge-WASINN-examples).

## Available extensions

The extensions can be easily installed by the WasmEdge installer. They can also be included in WASM container images for Docker, Podman, and Kubernetes applications.

| Name | Description | Platform Support | Language support | Note |
| --- | --- | --- | --- | --- |
| Networking sockets | Supports async (non-blocking) POSIX networking sockets | Linux | Rust, JavaScript, C | Supports popular libraries such as tokio (Rust) and node (JavaScript) |
| DNS | Supports DNS domain names in networking sockets | Linux | Rust, JavaScript, C | Supports popular libraries such as tokio (Rust) and node (JavaScript) |
| Domain sockets | Supports high-performance data exchange between processes | Linux | Rust, JavaScript, C |  |
| TLS | Supports TLS and HTTPS connections from the networking sockets | Linux | Rust, JavaScript, C |  |
| KV Storage | Allows WebAssembly programs to read and write a key value store | Linux | Rust |  |
| [Ethereum](https://github.com/second-state/wasmedge-evmc) | supports Ethereum smart contracts compiled to WebAssembly. | Linux | none | It is a leading implementation for Ethereum flavored WebAssembly (Ewasm). |
| [Substrate](https://github.com/second-state/substrate-ssvm-node) | The [Pallet](https://github.com/second-state/pallet-ssvm) allows WasmEdge to act as an Ethereum smart contract execution engine on any Substrate based blockchains. | Linux | none |  |
","**Summary**

The code snippet describes the features and capabilities of WasmEdge, a WebAssembly runtime that provides an extension mechanism for adding platform APIs to WASM applications. The extensions allow developers to run Linux apps on WasmEdge, leveraging networking socket and related APIs to support various use cases such as HTTP services, database connections, messaging queues, and more.

**Key Components**

1. **Networking Sockets**: Supports async (non-blocking) POSIX networking sockets for Linux.
2. **DNS**: Supports DNS domain names in networking sockets for Linux.
3. **Domain Sockets**: Supports high-performance data exchange between processes for Linux.
4. **TLS**: Supports TLS and HTTPS connections from the networking sockets for Linux.
5. **KV Storage**: Allows WebAssembly programs to read and write a key-value store for Linux.
6. **Ethereum**: Supports Ethereum smart contracts compiled to WebAssembly for Linux.
7. **Substrate**: Enables WasmEdge to act as an Ethereum smart contract execution engine on any Substrate-based blockchains.

**Platform Support**

1. **Linux**: Most of the extensions are supported on Linux platforms.
2. **Rust**: Many extensions support Rust programming language.
3. **JavaScript**: Some extensions support JavaScript programming language, including node.js API.

**Potential Issues or Areas for Improvement**

1. **Limited platform support**: Although most extensions are supported on Linux platforms, there may be limitations for other operating systems.
2. **Language support**: While some extensions support multiple languages (e.g., Rust and JavaScript), others might only support one language.
3. **Performance optimization**: Some extensions, like Domain Sockets, aim to provide high-performance data exchange between processes but might require further optimization.

Overall, the code snippet highlights the features and capabilities of WasmEdge extensions, which enable developers to run Linux apps on this WebAssembly runtime and leverage various platform APIs for their applications."
i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/modules.md,"---
sidebar_position: 7
---

# Built-in modules

The WasmEdge QuickJS runtime supports [ES6](es6) and [NPM](npm) modules for application developers. However, those approaches could be more convenient for system developers. They need an easier way to add multiple JavaScript modules and APIs into the runtime without using build tools like rollup.js. The WasmEdge QuickJS modules system allows developers to drop JavaScript files into a `modules` folder and have the JavaScript functions defined in the files immediately available to all JavaScript programs in the runtime. A good use case for this module's system is to support [Node.js](nodejs) APIs in WasmEdge.

In this article, we will use the [wasmedge-quickjs/modules](https://github.com/second-state/wasmedge-quickjs/tree/main/modules) as an example to showcase how to import NodeJS API or a third-party module.

## Prerequisites

[See here](./hello_world#prerequisites)

## The modules system

The modules system collects JavaScript files in the `modules` directory in the WasmEdge QuickJS distribution. To use the JavaScript functions and APIs defined in those modules, you need to map this directory to the `/modules` directory inside the WasmEdge Runtime instance. The following example shows how to do this on the WasmEdge CLI. You can do this with any of the host language SDKs that support the embedded use of WasmEdge.

```bash
wasmedge --dir /modules:/host/os/path/to/modules wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime
```

## Add your own JavaScript modules

The [module_demo](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/module_demo) shows how you can use the modules system to add your own JavaScript APIs. To run the demo, first copy the two files in the demo's [modules](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/module_demo/modules) directory to your WasmEdge QuickJS's `modules` directory.

```bash
cp example_js/module_demo/modules/* modules/
```

The two JavaScript files in the `modules` directory provide two simple functions. Below is the [modules/my_mod_1.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/modules/my_mod_1.js) file.

```javascript
export function hello_mod_1() {
  console.log('hello from ""my_mod_1.js""');
}
```

And the [modules/my_mod_2.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/modules/my_mod_2.js) file.

```javascript
export function hello_mod_2() {
  console.log('hello from ""my_mod_2.js""');
}
```

Then, just run the [demo.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/demo.js) file to call the two exported functions from the modules.

```javascript
import { hello_mod_1 } from 'my_mod_1';
import { hello_mod_2 } from 'my_mod_2';

hello_mod_1();
hello_mod_2();
```

Here is the command to run the demo and the output.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/module_demo/demo.js
hello from ""my_mod_1.js""
hello from ""my_mod_2.js""
```

Following the above tutorials, you can easily add third-party JavaScript functions and APIs to your WasmEdge QuickJS runtime.

We included JavaScript files to support [Node.js APIs](nodejs) for the official distribution. You can use [those files](https://github.com/second-state/wasmedge-quickjs/tree/main/modules) as further examples.
","**Summary**

The provided code is a documentation of the WasmEdge QuickJS modules system, which allows developers to add multiple JavaScript modules and APIs into the runtime without using build tools like rollup.js. The modules system collects JavaScript files in the `modules` directory and maps this directory to the `/modules` directory inside the WasmEdge Runtime instance.

**Key Components**

1. **Modules Directory**: The `modules` directory is where developers can place their own JavaScript files.
2. **Mapping Directory**: The `--dir` flag is used to map the `modules` directory to the `/modules` directory inside the WasmEdge Runtime instance.
3. **JavaScript Files**: Example JavaScript files (`my_mod_1.js`, `my_mod_2.js`) are provided in the repository, which can be used as a reference for adding custom modules.

**Functionality**

The WasmEdge QuickJS modules system allows developers to:

1. Add their own JavaScript modules and APIs.
2. Use third-party JavaScript functions and APIs.
3. Run example demos that showcase how to use the modules system.

**Potential Issues or Areas for Improvement**

1. **Documentation**: The documentation could be improved by providing more detailed explanations of each step, including error handling and troubleshooting tips.
2. **Example Code**: The example code (`my_mod_1.js`, `my_mod_2.js`) is minimal and lacks comments. Adding more complex examples with comments would help developers understand how to use the modules system in real-world scenarios.
3. **Security**: The modules system allows developers to add custom JavaScript files, which could potentially introduce security vulnerabilities if not properly sanitized.
4. **Scalability**: The documentation does not mention any limitations or considerations for large-scale deployments of the WasmEdge QuickJS runtime with multiple modules.

Overall, the WasmEdge QuickJS modules system provides a convenient way for developers to add custom JavaScript modules and APIs without using build tools like rollup.js. However, additional documentation, example code, and security considerations are needed to fully utilize this feature."
i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/plugin/rust_sdk.md,"---
sidebar_position: 2
---

# Using Plug-ins to Extend the Runtime in Rust

The WasmEdge plug-ins are the shared libraries to provide the WasmEdge runtime to load and create host module instances. With the plug-ins, the WasmEdge runtime can be extended more easily.

## Loading Plug-ins from Paths

Developers can start using WasmEdge plug-ins by loading them from specific paths. To load plug-ins from the default paths, the following API can be used:

```rust
impl PluginManager
pub fn load(path: Option<&Path>) -> WasmEdgeResult<()>
```

- The default plug-in paths will be used if the path is not given.

  - The path specified in the `WASMEDGE_PLUGIN_PATH` environment variable.
  - The `../plugin/` directory relative to the WasmEdge installation path.
  - The `./wasmedge/` directory under the library path if WasmEdge is installed in the `/usr` directory.

- If the path is given, then

  - If the path is pointing at a file, then it indicates that a single plug-in will be loaded from the file.
  - If the path is pointing at a directory, then the method will load plug-ins from the files.

To get the names of all loaded plug-ins as returns -

```rust
pub fn names() -> Vec<String>
```

<!-- prettier-ignore -->
:::note
`path` - A path to a plug-in file or a directory holding plug-in files. If `None`, then the default plug-in path will be used.
:::

## Listing Loaded Plug-ins

Once plug-ins are loaded, developers can list the loaded plug-in names using the following approach:

```rust
pub fn names() -> Vec<String>
```

## Getting Plug-in Context by Name

Developers can get the plug-in context by its name using the following method:

```rust
pub fn find(name: impl AsRef<str>) -> Option<Plugin>
```

Here `name` is the name of the target plug-in.

## Getting Module Instances from Plug-ins

With the plug-in context, developers can get module instances by providing the module name:

```rust
pub fn mod_names(&self) -> Vec<String>
```

There may be several plug-ins in the default plug-in paths if users [installed WasmEdge plug-ins by the installer](/contribute/installer.md#plugins).

Before using the plug-ins, developers should [Loading Plug-ins from Paths](#loading-plug-ins-from-paths).

## Plug-in Module Instance

To initialize the `wasmedge_process` plug-in module instance with the parameters -

```rust
pub fn init_wasmedge_process(allowed_cmds: Option<Vec<&str>>, allowed: bool)
```

Here, `allowed_cmds` is A white list of commands and `allowed` determines if wasmedge_process is allowed to execute all commands on the white list.
","**Summary:**

The code snippet is a part of the Rust SDK documentation for the WasmEdge plugin. It describes how to extend the WasmEdge runtime by loading plugins from specific paths, listing loaded plugins, and getting plug-in contexts by name.

**Key Components:**

1. `load`: A method to load plugins from default or custom paths.
2. `names`: A method to get the names of all loaded plugins.
3. `find`: A method to retrieve a plugin context by its name.
4. `mod_names`: A method to get module instances from a plug-in context.

**Potential Issues:**

1. The code does not handle cases where the specified path is invalid or non-existent.
2. There is no error handling for cases where multiple plugins with the same name are loaded.
3. The documentation could be improved by including more detailed examples and use cases.

**Areas for Improvement:**

1. Add input validation and error handling for the `load` method to ensure that the provided path is valid and exists.
2. Consider implementing a mechanism to handle conflicts between plugins with the same name.
3. Enhance the documentation to include additional examples, use cases, and code snippets to make it more comprehensive and user-friendly.

**Code Quality:**

The code appears to be well-structured and follows good coding practices. However, some improvements could be made in terms of error handling and input validation. Overall, the code is easy to understand and navigate, making it suitable for a technical audience."
docs/develop/rust/bindgen.md,"---
sidebar_position: 10
---

# Bindgen of Rust Functions

If your Rust program has a `main()` function, you could compile it into WebAssembly, and run it using the `wasmedge` CLI tool as a standalone application. However, a far more common use case is to compile a Rust function into WebAssembly, and then call it from a host application. That is known as an embedded WASM function. The host application uses WasmEdge language SDKs (e.g., [Go](/category/go-sdk-for-embedding-wasmedge), [Rust](/category/rust-sdk-for-embedding-wasmedge), [C](/category/c-sdk-for-embedding-wasmedge), Python (WIP) and Java (WIP)) to call those WASM functions compiled from Rust source code. In this chapter, we will cover a little about WasmEdge-bindgen, and you can find more information [here](/category/passing-complex-data)

All the WasmEdge host language SDKs support simple function calls. However, the WASM spec only supports simple data types as call parameters and return values, such as `i32`, `i64`, `f32`, `f64`, and `v128`. The `wasmedge-bindgen` crate would transform parameters and return values of Rust functions into simple integer types when the Rust function is compiled into WASM. For example, a string is automatically converted into two integers, a memory address and a length, which the standard WASM spec can handle. It is very easy to do this in Rust source code. Just annotate your function with the `#[wasmedge-bindgen]` macro. You can compile the annotated Rust code using the standard Rust compiler toolchain (e.g., the latest `Cargo`).

```rust
use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;

#[wasmedge_bindgen]
pub fn say(s: String) -> Result<Vec<u8>, String> {
  let r = String::from(""hello "");
  return Ok((r + s.as_str()).as_bytes().to_vec());
}
```

Of course, once the above Rust code is compiled into WASM, the function `say()` no longer takes the `String` parameter nor returns the `Vec<u8>`. So, the caller (i.e., the host application) must also deconstruct the call parameter into the memory pointer first before the call and assemble the return value from the memory pointer after the call. These actions can be handled automatically by the WasmEdge language SDKs. To see a complete example, including the Rust WASM function and the Go host application, check out our tutorial in the Go SDK documentation.

[A complete wasmedge-bindgen example in Rust (WASM) and Go (host)](../../embed/go/function.md)

Of course, the developer could do `wasmedge-bindgen`'s work by hand and pass a memory pointer directly. If you are interested in this approach to call Rust compiled WASM functions, check out our [examples in the Go SDK](../../embed/go/passing_data.md).
","**Summary**

This document describes how to use the `wasmedge-bindgen` crate to generate WebAssembly (WASM) functions from Rust code. The `wasmedge-bindgen` crate is a tool that allows Rust developers to compile their Rust functions into WASM, which can then be called from a host application written in various languages, including Go, Rust, C, and Python.

**Key Components**

1. **Rust Function**: A Rust function annotated with the `#[wasmedge_bindgen]` macro is compiled into WASM.
2. **WASM Function**: The annotated Rust function is transformed into a WASM function that can be called from a host application.
3. **Host Application**: A host application written in a supported language (e.g., Go, Rust, C) calls the WASM function using the WasmEdge language SDK.

**Functionality**

The `wasmedge-bindgen` crate performs two key functions:

1. **Parameter Conversion**: It converts complex data types (e.g., strings, vectors) into simple integer types that can be handled by the WASM specification.
2. **Return Value Transformation**: It transforms return values from the Rust function into a format that can be understood by the host application.

**Potential Issues**

1. **Complex Data Types**: If a function takes or returns complex data types (e.g., structs, custom classes), additional work may be required to handle their conversion and transformation.
2. **Function Signature Changes**: After compiling with `wasmedge-bindgen`, the function signature changes, which may require updates to the host application code.

**Best Practices**

1. **Use the `#[wasmedge_bindgen]` macro**: Annotate Rust functions with this macro to enable WASM compilation.
2. **Understand WASM specification limitations**: Familiarize yourself with the limitations of the WASM specification and how they impact data type conversion and return value transformation.

Overall, using the `wasmedge-bindgen` crate provides a convenient way to compile Rust code into WebAssembly functions that can be easily called from host applications."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/bindgen.md,"---
sidebar_position: 10
---

# Bindgen of Rust Functions

If your Rust program has a `main()` function, you could compile it into WebAssembly, and run it using the `wasmedge` CLI tool as a standalone application. However, a far more common use case is to compile a Rust function into WebAssembly, and then call it from a host application. That is known as an embedded WASM function. The host application uses WasmEdge language SDKs (e.g., [Go](/category/go-sdk-for-embedding-wasmedge), [Rust](/category/rust-sdk-for-embedding-wasmedge), [C](/category/c-sdk-for-embedding-wasmedge), Python (WIP) and Java (WIP)) to call those WASM functions compiled from Rust source code. In this chapter, we will cover a little about WasmEdge-bindgen, and you can find more information [here](/category/passing-complex-data)

All the WasmEdge host language SDKs support simple function calls. However, the WASM spec only supports simple data types as call parameters and return values, such as `i32`, `i64`, `f32`, `f64`, and `v128`. The `wasmedge-bindgen` crate would transform parameters and return values of Rust functions into simple integer types when the Rust function is compiled into WASM. For example, a string is automatically converted into two integers, a memory address and a length, which the standard WASM spec can handle. It is very easy to do this in Rust source code. Just annotate your function with the `#[wasmedge-bindgen]` macro. You can compile the annotated Rust code using the standard Rust compiler toolchain (e.g., the latest `Cargo`).

```rust
use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;

#[wasmedge_bindgen]
pub fn say(s: String) -> Result<Vec<u8>, String> {
  let r = String::from(""hello "");
  return Ok((r + s.as_str()).as_bytes().to_vec());
}
```

Of course, once the above Rust code is compiled into WASM, the function `say()` no longer takes the `String` parameter nor returns the `Vec<u8>`. So, the caller (i.e., the host application) must also deconstruct the call parameter into the memory pointer first before the call and assemble the return value from the memory pointer after the call. These actions can be handled automatically by the WasmEdge language SDKs. To see a complete example, including the Rust WASM function and the Go host application, check out our tutorial in the Go SDK documentation.

[A complete wasmedge-bindgen example in Rust (WASM) and Go (host)](../../embed/go/function.md)

Of course, the developer could do `wasmedge-bindgen`'s work by hand and pass a memory pointer directly. If you are interested in this approach to call Rust compiled WASM functions, check out our [examples in the Go SDK](../../embed/go/passing_data.md).
","**Summary**

The code provided is a documentation for the `wasmedge-bindgen` crate, which is a tool to generate WebAssembly (WASM) bindings for Rust functions. The purpose of this crate is to allow calling WASM functions compiled from Rust source code from host applications written in various languages such as Go, Rust, C, and Python. The documentation explains how the `wasmedge-bindgen` crate works, its limitations, and provides an example of using it to compile a Rust function into WASM.

**Key Components**

1. **`#[wasmedge_bindgen]` macro**: This is a Rust macro that annotates functions to be compiled into WASM.
2. **WASM specification**: The documentation explains the limitations of the WASM specification, which only supports simple data types as call parameters and return values.
3. **Parameter conversion**: The `wasmedge-bindgen` crate automatically converts Rust function parameters and return values into simple integer types when compiling to WASM.
4. **Host language SDKs**: The documentation mentions various host language SDKs (e.g., Go, Rust, C) that can call WASM functions compiled from Rust source code.

**Potential Issues or Areas for Improvement**

1. **Limited support for complex data types**: The WASM specification only supports simple data types, which may limit the functionality of the generated bindings.
2. **Manual parameter conversion**: As mentioned in the documentation, developers could manually handle parameter conversion by passing memory pointers directly to the WASM function. This approach requires more effort and may lead to errors if not done correctly.
3. **Limited support for Rust features**: The `wasmedge-bindgen` crate may not fully support all Rust features, which may limit its usefulness in certain situations.

**Conclusion**

The `wasmedge-bindgen` crate is a useful tool for generating WebAssembly bindings for Rust functions. While it has some limitations, it provides an easy way to call WASM functions from host applications written in various languages. The documentation provided is comprehensive and well-written, making it easier for developers to understand how to use the crate effectively."
docs/develop/rust/hello_world.md,"---
sidebar_position: 2
---

# Hello world

Before we start, ensure [you have Rust and WasmEdge installed](setup.md).

## A simple main app

The Hello World example is a standalone Rust application that can be executed by the [WasmEdge CLI](../../start/build-and-run/cli.md). The full source code for the Rust [main.rs](https://github.com/second-state/rust-examples/tree/main/hello) file is as follows. It echoes the command line arguments passed to this program at runtime.

```rust
fn main() {
  let s : &str = ""Hello WasmEdge!"";
  println!(""{}"", s);
}
```

Build the WASM bytecode:

```bash
cargo build --target wasm32-wasi --release
```

We will use the `wasmedge` command to run the program.

```bash
$ wasmedge target/wasm32-wasi/release/hello.wasm
Hello WasmEdge
```

## A simple function

### The code

The [add example](https://github.com/second-state/wasm-learning/tree/master/cli/add) is a Rust library function that can be executed by the [WasmEdge CLI](../../start/build-and-run/cli.md) in the reactor mode.

The full source code for the Rust [lib.rs](https://github.com/second-state/wasm-learning/blob/master/cli/add/src/lib.rs) file is as follows. It provides a simple `add()` function.

```rust
#[no_mangle]
pub fn add(a: i32, b: i32) -> i32 {
  return a + b;
}
```

### Build the WASM bytecode

```bash
cargo build --target wasm32-wasi --release
```

### Run the application from command line

We will use `wasmedge` in reactor mode to run the program. We pass the function name and its input parameters as command line arguments.

```bash
$ wasmedge --reactor target/wasm32-wasi/release/add.wasm add 2 2
4
```

## Pass parameters with complex data types

Of course, in most cases, you will not call functions using CLI arguments. Instead, you will probably need to use a [language SDK from WasmEdge] to call the function, pass call parameters, and receive return values. Below are some SDK examples for complex call parameters and return values.

- [Use wasmedge-bindgen in a Go host app](../../embed/go/bindgen.md)
- [Use direct memory passing in a Go host app](../../embed/go/passing_data.md)

## Improve the performance

If we don't have extra notes for AoT, all the WASM file will be executed in the interpreter mode, which is much slower. To achieve native Rust performance for those applications, you could use the `wasmedge compile` command to AOT compile the `wasm` program and then run it with the `wasmedge` command.

```bash
$ wasmedge compile hello.wasm hello_aot.wasm

$ wasmedge hello_aot.wasm second state
hello
second
state
```

For the `--reactor` mode,

```bash
$ wasmedge compile add.wasm add_aot.wasm

$ wasmedge --reactor add_aot.wasm add 2 2
4
```
","**Summary**

This code provides examples of creating standalone Rust applications that can be executed by the WasmEdge CLI. The first example is a simple ""Hello World"" application that echoes command-line arguments, and the second example is a library function called `add` that adds two integers.

**Key Components**

1. **Rust Code**: The code consists of two files: `main.rs` for the ""Hello World"" example and `lib.rs` for the `add` library function.
2. **Cargo Build Script**: A script using Cargo, Rust's package manager, is used to build the WASM bytecode for both examples.
3. **WasmEdge CLI**: The WasmEdge CLI is used to run the compiled WASM code.

**Functionality**

1. **Hello World Example**: This example demonstrates how to create a simple ""Hello World"" application that echoes command-line arguments.
2. **Add Library Function**: This example demonstrates how to create a library function called `add` that adds two integers.
3. **AOT Compilation**: The code also demonstrates how to use the `wasmedge compile` command to AOT (Ahead-of-Time) compile the WASM program for improved performance.

**Potential Issues**

1. **Error Handling**: The code does not handle errors that may occur during compilation or execution, which could lead to unexpected behavior.
2. **Dependency Management**: The code uses Cargo, but it's unclear if there are any dependencies that need to be managed.
3. **Performance Optimization**: While AOT compilation is demonstrated, it's unclear if other performance optimization techniques can be applied.

**Improvement Suggestions**

1. **Error Handling**: Add error handling mechanisms to handle potential errors during compilation and execution.
2. **Dependency Management**: Document dependencies and their management in the code.
3. **Performance Optimization**: Explore additional performance optimization techniques beyond AOT compilation, such as loop unrolling or function inlining.
4. **Code Organization**: Consider organizing the code into separate modules or crates to improve maintainability and reusability."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/hello_world.md,"---
sidebar_position: 2
---

# Hello world

Before we start, ensure [you have Rust and WasmEdge installed](setup.md).

## A simple main app

The Hello World example is a standalone Rust application that can be executed by the [WasmEdge CLI](../../start/build-and-run/cli.md). The full source code for the Rust [main.rs](https://github.com/second-state/rust-examples/tree/main/hello) file is as follows. It echoes the command line arguments passed to this program at runtime.

```rust
fn main() {
  let s : &str = ""Hello WasmEdge!"";
  println!(""{}"", s);
}
```

Build the WASM bytecode:

```bash
cargo build --target wasm32-wasi --release
```

We will use the `wasmedge` command to run the program.

```bash
$ wasmedge target/wasm32-wasi/release/hello.wasm
Hello WasmEdge
```

## A simple function

### The code

The [add example](https://github.com/second-state/wasm-learning/tree/master/cli/add) is a Rust library function that can be executed by the [WasmEdge CLI](../../start/build-and-run/cli.md) in the reactor mode.

The full source code for the Rust [lib.rs](https://github.com/second-state/wasm-learning/blob/master/cli/add/src/lib.rs) file is as follows. It provides a simple `add()` function.

```rust
#[no_mangle]
pub fn add(a: i32, b: i32) -> i32 {
  return a + b;
}
```

### Build the WASM bytecode

```bash
cargo build --target wasm32-wasi --release
```

### Run the application from command line

We will use `wasmedge` in reactor mode to run the program. We pass the function name and its input parameters as command line arguments.

```bash
$ wasmedge --reactor target/wasm32-wasi/release/add.wasm add 2 2
4
```

## Pass parameters with complex data types

Of course, in most cases, you will not call functions using CLI arguments. Instead, you will probably need to use a [language SDK from WasmEdge] to call the function, pass call parameters, and receive return values. Below are some SDK examples for complex call parameters and return values.

- [Use wasmedge-bindgen in a Go host app](../../embed/go/bindgen.md)
- [Use direct memory passing in a Go host app](../../embed/go/passing_data.md)

## Improve the performance

If we don't have extra notes for AoT, all the WASM file will be executed in the interpreter mode, which is much slower. To achieve native Rust performance for those applications, you could use the `wasmedge compile` command to AOT compile the `wasm` program and then run it with the `wasmedge` command.

```bash
$ wasmedge compile hello.wasm hello_aot.wasm

$ wasmedge hello_aot.wasm second state
hello
second
state
```

For the `--reactor` mode,

```bash
$ wasmedge compile add.wasm add_aot.wasm

$ wasmedge --reactor add_aot.wasm add 2 2
4
```
","**Summary**

The code provided is a tutorial on how to create and run Rust applications using the WasmEdge CLI. The tutorial covers three main topics:

1. Creating a standalone Rust application that can be executed by the WasmEdge CLI.
2. Creating a Rust library function that can be executed by the WasmEdge CLI in reactor mode.
3. Passing parameters with complex data types and improving performance through Ahead-of-Time (AOT) compilation.

**Key Components**

* `main.rs` file: The full source code for the standalone Rust application that echoes command-line arguments passed to this program at runtime.
* `lib.rs` file: The full source code for the Rust library function that provides a simple `add()` function.
* `wasmedge` command: Used to run the WASM bytecode and execute the functions.
* AOT compilation: Used to achieve native Rust performance by compiling the WASM program beforehand.

**Potential Issues or Areas for Improvement**

* The tutorial assumes that readers have already installed Rust and WasmEdge, which may not be the case for some users.
* There is no explanation on how to handle errors or exceptions in the Rust code.
* The `wasmedge` command options and usage are not thoroughly documented, making it difficult for users to understand its behavior.
* The tutorial could benefit from more examples of passing complex data types and return values using language SDKs.

Overall, the code provided is a good starting point for beginners interested in learning how to create and run Rust applications with WasmEdge. However, additional documentation and explanations are needed to make it more comprehensive and user-friendly."
docs/start/wasmedge/integrations.md,"---
sidebar_position: 2
---

# WasmEdge Integrations

WasmEdge is a ""serverless"" runtime for cloud-native and edge computing applications. It allows developers safely embed third-party or ""native"" functions into a host application or a distributed computing framework.

## Embed WasmEdge Into A Host Application

A major use case of WasmEdge is to start a VM instance from a host application. Depending on your host application's programming language, you can use WasmEdge SDKs to start and invoke WasmEdge functions.

- Embed WasmEdge functions into a `C`-based application using the [WasmEdge C API](/category/c-sdk-for-embedding-wasmedge). Checkout the [quick start guide](../../embed/c/intro.md).
- Embed WasmEdge functions into a `Go` application using the [WasmEdge Go API](/category/go-sdk-for-embedding-wasmedge). Here is a [tutorial](https://www.secondstate.io/articles/extend-golang-app-with-webassembly-rust/) and are some [examples](https://github.com/second-state/WasmEdge-go-examples)!
- Embed WasmEdge functions into a `Rust` application using the [WasmEdge Rust crate](https://crates.io/crates/wasmedge-sdk).
- Embed WasmEdge functions into a `Node.js` application using the `NAPI`. Here is a [tutorial](https://www.secondstate.io/articles/getting-started-with-rust-function/).
- Embed WasmEdge functions into any application by spawning a new process. See examples for [Vercel Serverless Functions](https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/) and [AWS Lambda](https://www.cncf.io/blog/2021/08/25/webassembly-serverless-functions-in-aws-lambda/).

However, the WebAssembly spec only supports very limited data types as input parameters and return values for the WebAssembly bytecode functions. To pass complex data types, such as a string of an array, as call arguments into WebAssembly compiled from Rust, you should use the `bindgen` solution provided by the [`wasmedge-bindgen`](https://crates.io/crates/wasmedge-bindgen). We currently support the `wasmedge-bindgen` in the [Rust](../../develop/rust/bindgen.md) and in [Go](../../embed/go/bindgen.md).

## Use WasmEdge As A Docker-Like Container

WasmEdge provides an OCI-compliant interface. You can use container tools like CRI-O, Docker Hub, and Kubernetes to orchestrate and manage WasmEdge runtimes.

- [Manage WasmEdge with CRI-O and Docker Hub](https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/).

## Call Native Host Functions From WasmEdge

A key feature of WasmEdge is its extensibility. WasmEdge APIs allow developers to register ""host functions"" from the host programming languages into a WasmEdge instance and invoke these functions from the WebAssembly program.

- The WasmEdge C API supports the [C host functions](../../embed/c/host_function.md).
- The WasmEdge Go API supports the [Go host functions](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_HostFunc#wasmedge-go-host-function-example).
- The WasmEdge Rust API supports the [Rust host functions](https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#host-functions).

[Here is an example](https://www.secondstate.io/articles/call-native-functions-from-javascript/) of a JavaScript program in WasmEdge calling a C-based host function in the underlying OS.

The host functions break the WASM sandbox to access the underly OS or hardware. But the sandbox breaking is done with explicit permission from the system’s operator.
","**Summary**

WasmEdge is a ""serverless"" runtime for cloud-native and edge computing applications that allows developers to safely embed third-party or ""native"" functions into a host application or distributed computing framework. It provides APIs for various programming languages, including C, Go, Rust, and Node.js, enabling the embedding of WasmEdge functions into a host application.

**Key Components**

1. **WasmEdge Integrations**: Provide SDKs and APIs for various programming languages to embed WasmEdge functions into a host application.
2. **Embedding WasmEdge Functions**: Enables developers to start a VM instance from a host application using the provided APIs.
3. **Host Functions**: Allow developers to register ""host functions"" from the host programming language into a WasmEdge instance and invoke these functions from the WebAssembly program.

**Potential Issues or Areas for Improvement**

1. **Complex Data Types Support**: The WebAssembly spec only supports limited data types as input parameters and return values for the WebAssembly bytecode functions, making it challenging to pass complex data types.
2. **Bindgen Solution**: The `bindgen` solution provided by the `wasmedge-bindgen` crate is currently supported in Rust and Go, which may limit its availability for other languages.
3. **Containerization Support**: WasmEdge provides an OCI-compliant interface but may require additional support for container tools like CRI-O, Docker Hub, and Kubernetes to orchestrate and manage WasmEdge runtimes.

**Additional Recommendations**

1. **Expand Bindgen Support**: Consider expanding bindgen support to more programming languages to improve the ease of use for developers.
2. **Improve Containerization Support**: Provide additional resources or documentation to help users integrate WasmEdge with container tools like CRI-O, Docker Hub, and Kubernetes.
3. **Enhance Host Function Support**: Continue to enhance host function support across various programming languages to increase the extensibility of WasmEdge."
i18n/zh/docusaurus-plugin-content-docs/current/start/getting-started/quick_start.md,"---
sidebar_position: 1
---

# Linux 下的快速入门

在本指南中，我们将介绍如何快速地在常规 Linux 发行版（例如 Ubuntu、Debian、Raspberry OS 或 Windows 上的 WSL）上安装和运行 WasmEdge 运行时。你可以在[此处](../install.md#install)找到更全面和其他特定操作系统的安装说明。

<!-- prettier-ignore -->
:::note
如果你使用 Docker Desktop 4.15 及以上版本，则可以跳过这一部分，可以[在此开始](quick_start_docker.md)。对于 Fedora Linux / Red Hat Linux / OpenShift / Podman 用户，可以[在此开始](quick_start_redhat.md)。
:::

我们将涵盖以下示例：

- [如何运行一个独立的 WASM 应用](#how-to-run-a-standalone-wasm-app)
- [如何运行一个 HTTP 服务器](#how-to-run-an-http-server)
- [如何运行一个 JavaScript 服务器 (node.js)](#how-to-run-a-javascript-based-server)

## 使用一行指令安装 WasmEdge

安装 WasmEdge 的最简单方式是运行以下命令。你应该具有 root 或至少 `sudo` 权限。在运行此命令之前，你的系统应该已经安装了 `git` 和 `curl`。

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | sudo bash -s -- -p /usr/local
```

如果你没有 root 或 `sudo` 权限，则可以使用以下命令在 `$HOME/.wasmedge` 目录中安装 WasmEdge：

```bash
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
```

## 如何运行一个独立的 WASM 应用

Hello World 示例是一个独立的 Rust 应用程序，可由[WasmEdge CLI](../build-and-run/cli.md)执行。其源代码和构建说明可在[此处](https://github.com/second-state/rust-examples/tree/main/hello)找到。

在[此处](https://github.com/second-state/rust-examples/releases/latest/download/hello.wasm)下载 hello.wasm 文件，或运行以下命令：

```bash
wget https://github.com/second-state/rust-examples/releases/latest/download/hello.wasm
```

使用 `wasmedge` 命令来运行程序。

```bash
$ wasmedge hello.wasm
Hello WasmEdge!
```

使用 AoT 编译器 `wasmedgec` 可获得更好的性能。

```bash
$ wasmedgec hello.wasm hello_aot.wasm
$ wasmedge hello_aot.wasm
Hello WasmEdge!
```

了解更多如何在 Rust 中创建 WASM 应用

- [WasmEdge 的基本 Rust 示例](https://github.com/second-state/rust-examples)
- [Rust 开发指南](/category/develop-wasm-apps-in-rust)
  - 使用 [PyTorch](../../develop/rust/wasinn/pytorch.md), [OpenVINO](../../develop/rust/wasinn/openvino.md) 或 [Tensorflow Lite](../../develop/rust/wasinn/tensorflow_lite.md) 后端的 WASI-NN
  - [HTTP 和 HTTPS 客户端](../../develop/rust/http_service/client.md)
  - [MySQL 数据库客户端](../../develop/rust/database/my_sql_driver.md)
  - Redis 客户端
  - Kafka 客户端

## 如何运行一个 HTTP 服务器

此示例是一个使用 Rust 编写的独立 HTTP 服务器。它展示了将 Rust + WasmEdge 作为微服务的轻量级技术栈。其源代码和构建说明可在[此处](https://github.com/second-state/rust-examples/tree/main/server)找到。

在[此处](https://github.com/second-state/rust-examples/releases/latest/download/server.wasm)下载 server.wasm 文件，或运行以下命令：

```bash
wget https://github.com/second-state/rust-examples/releases/latest/download/server.wasm
```

使用 `wasmedge` 命令来运行该程序。

```bash
$ wasmedge server.wasm
Listening on http://0.0.0.0:8080
```

从另一个终端窗口执行以下步骤。

```bash
$ curl http://localhost:8080/
Try POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`

$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

了解如何在 Rust 中创建 WASM 服务

- [Rust 开发指南](/category/develop-wasm-apps-in-rust)
- [HTTP 应用程序示例](https://github.com/WasmEdge/wasmedge_hyper_demo)
- [数据库应用程序示例](https://github.com/WasmEdge/wasmedge-db-examples)
- Rust 和 WasmEdge 中的轻量级微服务
  - [WasmEdge + Nginx + MySQL](https://github.com/second-state/microservice-rust-mysql)
  - [WasmEdge + Kafka + MySQL](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql)
  - [Dapr + WasmEdge](https://github.com/second-state/dapr-wasm)

## 如何运行基于 JavaScript 的服务器

该示例是基于 Node.js API 并使用 JavaScript 编写的独立 HTTP 服务器。它展示了如何将 WasmEdge 作为 Node.js 应用程序的轻量级运行时。其源代码可在[此处](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/docker_wasm/server)找到。

- 在[此处](https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm)下载 wasmedge_quickjs.wasm 文件，或运行以下命令：

```bash
wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm
```

- 在[此处](https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip)下载 modules.zip 文件，或运行以下命令：

```bash
wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip
```

将 modules.zip 文件解压到当前文件夹，保存为 `./modules/`。

```bash
unzip modules.zip
```

- 在[此处](https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/docker_wasm/server/server.js)下载 server.js 文件。

```bash
wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/docker_wasm/server/server.js
```

使用 `wasmedge` 命令来运行该程序。

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm server.js
Listening on 8080 ...
```

从另一个终端窗口执行以下步骤。

```bash
$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

了解如何在 WasmEdge 中运行 JavaScript 应用程序。

- [WasmEdge QuickJS runtime](https://github.com/second-state/wasmedge-quickjs)
- [AI 推理应用示例](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo)
- [使用 fetch() 的 Web 服务客户端示例](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js)

## 下一步

- 查看所有可用的[WasmEdge CLI选项](../build-and-run/cli.md)以探索 WasmEdge 的功能。
- 用你喜欢的语言编写 WASM 应用，如 [Rust](/category/develop-wasm-apps-in-rust)、[C/C++](/category/develop-wasm-apps-in-cc)、[JavaScript](/category/develop-wasm-apps-in-javascript)、[Go](/category/develop-wasm-apps-in-go) 等其他语言。
","**Summary:**

The provided code is a Markdown file for a Docusaurus documentation page, specifically designed to guide users through the quick start process of running WasmEdge on Linux. The document covers three main examples:

1. Running an independent WASM application
2. Running an HTTP server using Rust and WasmEdge
3. Running a JavaScript-based server using Node.js and WasmEdge

**Key Components:**

* Installation of WasmEdge using a single command or an alternative method for non-root users
* Example 1: Running an independent WASM application in Rust, using the `wasmedge` CLI to execute the program
* Example 2: Running an HTTP server using Rust and WasmEdge, demonstrating how to create a microservice using WasmEdge as a lightweight runtime
* Example 3: Running a JavaScript-based server using Node.js and WasmEdge, showing how to use QuickJS as a runtime for Node.js applications

**Potential Issues or Areas for Improvement:**

1. The code assumes users have root or sudo privileges to install WasmEdge, which may not be the case for all users.
2. The examples are based on specific versions of Rust and Node.js, which may need to be updated to match newer versions.
3. The documentation could benefit from more detailed explanations and additional examples to make it easier for users to follow along.

**Suggestions for Future Development:**

1. Add more examples and tutorials to the documentation to cater to a broader range of users and use cases.
2. Provide more detailed instructions and troubleshooting guides for common issues that users may encounter during installation and usage.
3. Consider adding interactive components, such as quizzes or hands-on exercises, to make the learning experience more engaging and effective."
docs/contribute/source/plugin/tensorflowlite.md,"---
sidebar_position: 6
---

# Build WasmEdge With WasmEdge-TensorflowLite Plug-in

The WasmEdge-TensorflowLite plug-in is a software component that extends the functionality of the WasmEdge runtime to perform TensorFlow-Lite model inference. It allows WebAssembly applications to access TensorFlow-Lite functionality when executed on the WasmEdge runtime. The plugin provides a bridge between the WasmEdge runtime and the TensorFlow-Lite backend, allowing developers to execute machine learning models within WebAssembly applications.

## Prerequisites

The prerequisites of the WasmEdge-TensorflowLite plug-in is the same as the WasmEdge building environment on the [Linux platforms](../os/linux.md) or [MacOS platforms](../os/macos.md).

## Build WasmEdge with WasmEdge-TensorflowLite Plug-in

To enable the WasmEdge WasmEdge-TensorflowLite, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_TENSORFLOWLITE=On`.

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_TENSORFLOWLITE=On
cmake --build build
# For the WasmEdge-TensorflowLite plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WasmEdge-TensorflowLite plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_tensorflowlite/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-TensorflowLite plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeTensorflowLite.so` after installation.

## Install the TensorFlowLite Dependency

Installing the necessary `libtensorflowlite_c.so` and `libtensorflowlite_flex.so` on both `Linux` and `MacOS` platforms, we recommend the following commands:

```bash
curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
# For the Linux aarch64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_aarch64.tar.gz`.
# For the MacOS x86_64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-darwin_x86_64.tar.gz`.
# For the MacOS arm64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-darwin_arm64.tar.gz`.
tar -zxf WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
rm -f WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
```

The shared library will be extracted in the current directory `./libtensorflowlite_c.so` and `./libtensorflowlite_flex.so` on `Linux` platforms, or `./libtensorflowlite_c.dylib` and `./libtensorflowlite_flex.dylib` on `MacOS` platforms.

<!-- prettier-ignore -->
:::note
After building the plug-in, you can also find these shared libraries under the `build/_deps/wasmedge_tensorflow_lib_tflite-src/` directory.
:::

Then you can move the library to the installation path:

```bash
mv libtensorflowlite_c.so /usr/local/lib
mv libtensorflowlite_flex.so /usr/local/lib
```

If on `MacOS` platforms:

```bash
mv libtensorflowlite_c.dylib /usr/local/lib
mv libtensorflowlite_flex.dylib /usr/local/lib
```

Or set the environment variable `export LD_LIBRARY_PATH=$(pwd):${LD_LIBRARY_PATH}`.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_tensorflowlite).
","**Summary**

The provided code is a tutorial on building the WasmEdge runtime with the WasmEdge-TensorFlow Lite (TFLite) plugin. The TFLite plugin allows WebAssembly applications to access TensorFlow-Lite model inference functionality when executed on the WasmEdge runtime.

**Key Components**

1. **Prerequisites**: The build environment for WasmEdge is required, which can be found on Linux and MacOS platforms.
2. **Building WasmEdge with TFLite Plugin**: Developers need to build WasmEdge from source using CMake with the option `-DWASMEDGE_PLUGIN_TENSORFLOWLITE=On`.
3. **Installing TensorFlowLite Dependency**: The necessary `libtensorflowlite_c.so` and `libtensorflowlite_flex.so` libraries are required, which can be downloaded and installed manually.
4. **Configuring Environment Variables**: The `WASMEDGE_PLUGIN_PATH` environment variable needs to be set to the installation path of the TFLite plugin.

**Potential Issues/Improvements**

1. **Manual Installation**: The process of installing the TensorFlowLite dependency requires manual intervention, which can be error-prone and time-consuming.
2. **Environment Variable Configuration**: Setting up the `WASMEDGE_PLUGIN_PATH` environment variable may require additional configuration steps.
3. **Build and Install Process**: The build and installation process for WasmEdge with the TFLite plugin is complex and may require additional troubleshooting.

**Recommendations**

1. **Automate Installation**: Automate the installation of the TensorFlowLite dependency using a script or tool to simplify the process.
2. **Simplify Environment Variable Configuration**: Provide clear instructions on how to configure the `WASMEDGE_PLUGIN_PATH` environment variable, or consider making it automatic through CMake or another build tool.
3. **Refine Build and Install Process**: Refine the build and installation process for WasmEdge with the TFLite plugin to reduce complexity and make it more user-friendly."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/tensorflowlite.md,"---
sidebar_position: 6
---

# Build WasmEdge With WasmEdge-TensorflowLite Plug-in

The WasmEdge-TensorflowLite plug-in is a software component that extends the functionality of the WasmEdge runtime to perform TensorFlow-Lite model inference. It allows WebAssembly applications to access TensorFlow-Lite functionality when executed on the WasmEdge runtime. The plugin provides a bridge between the WasmEdge runtime and the TensorFlow-Lite backend, allowing developers to execute machine learning models within WebAssembly applications.

## Prerequisites

The prerequisites of the WasmEdge-TensorflowLite plug-in is the same as the WasmEdge building environment on the [Linux platforms](../os/linux.md) or [MacOS platforms](../os/macos.md).

## Build WasmEdge with WasmEdge-TensorflowLite Plug-in

To enable the WasmEdge WasmEdge-TensorflowLite, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_TENSORFLOWLITE=On`.

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_TENSORFLOWLITE=On
cmake --build build
# For the WasmEdge-TensorflowLite plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WasmEdge-TensorflowLite plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_tensorflowlite/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-TensorflowLite plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeTensorflowLite.so` after installation.

## Install the TensorFlowLite Dependency

Installing the necessary `libtensorflowlite_c.so` and `libtensorflowlite_flex.so` on both `Linux` and `MacOS` platforms, we recommend the following commands:

```bash
curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
# For the Linux aarch64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_aarch64.tar.gz`.
# For the MacOS x86_64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-darwin_x86_64.tar.gz`.
# For the MacOS arm64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-darwin_arm64.tar.gz`.
tar -zxf WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
rm -f WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz
```

The shared library will be extracted in the current directory `./libtensorflowlite_c.so` and `./libtensorflowlite_flex.so` on `Linux` platforms, or `./libtensorflowlite_c.dylib` and `./libtensorflowlite_flex.dylib` on `MacOS` platforms.

<!-- prettier-ignore -->
:::note
After building the plug-in, you can also find these shared libraries under the `build/_deps/wasmedge_tensorflow_lib_tflite-src/` directory.
:::

Then you can move the library to the installation path:

```bash
mv libtensorflowlite_c.so /usr/local/lib
mv libtensorflowlite_flex.so /usr/local/lib
```

If on `MacOS` platforms:

```bash
mv libtensorflowlite_c.dylib /usr/local/lib
mv libtensorflowlite_flex.dylib /usr/local/lib
```

Or set the environment variable `export LD_LIBRARY_PATH=$(pwd):${LD_LIBRARY_PATH}`.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_tensorflowlite).
","**Summary**

The code provides a guide on how to build WasmEdge with the TensorFlow Lite plug-in, which enables WebAssembly applications to access TensorFlow-Lite functionality when executed on the WasmEdge runtime. The plug-in provides a bridge between the WasmEdge runtime and the TensorFlow-Lite backend.

**Key Components**

1. **Building WasmEdge**: The code provides instructions on how to build WasmEdge from source with the cmake option `-DWASMEDGE_PLUGIN_TENSORFLOWLITE=On`.
2. **Installing TensorFlowLite Dependency**: The code explains how to install the necessary shared libraries `libtensorflowlite_c.so` and `libtensorflowlite_flex.so` on both Linux and MacOS platforms.
3. **Configuring Environment Variables**: The code provides instructions on how to set environment variables such as `WASMEDGE_PLUGIN_PATH` and `LD_LIBRARY_PATH` to fix potential issues with the built `wasmedge` CLI tool.

**Potential Issues**

1. **Missing Shared Libraries**: If the shared libraries are not installed correctly, the `wasmedge` CLI tool may not be able to find them.
2. **Environment Variable Issues**: If environment variables such as `WASMEDGE_PLUGIN_PATH` and `LD_LIBRARY_PATH` are not set correctly, the plug-in may not work as expected.

**Areas for Improvement**

1. **Automate Building Process**: Consider automating the building process using a CI/CD pipeline to streamline the development and testing process.
2. **Provide More Detailed Instructions**: Provide more detailed instructions on how to configure environment variables and install shared libraries.
3. **Include Example Use Cases**: Include example use cases or demos that showcase the capabilities of the TensorFlow Lite plug-in with WasmEdge."
i18n/zh/docusaurus-plugin-content-docs/current/start/getting-started/quick_start_docker.md,"---
sidebar_position: 2
---

# 使用 Docker 的快速入门

在本指南中，我们将介绍如何在 Docker Desktop 中快速运行 WasmEdge 应用。由于整个开发和运行环境都由 Docker Desktop 管理，因此没有额外的依赖。

<!-- prettier-ignore -->
:::note
如果你没有使用 Docker Desktop，请[从这里开始](quick_start.md)。
:::

我们将介绍以下示例。

- [运行一个独立的 WASM 应用](#run-a-standalone-wasm-app)
- [运行一个 HTTP 服务器](#run-an-http-server)
- [运行一个基于 JavaScript 的服务器 (node.js)](#run-a-javascript-based-server)

在此快速入门指南中，我们将介绍如何使用 Docker 命令运行 WASM 容器应用。如果你对如何从源代码构建、发布和组合 WASM 容器应用感兴趣，请查看[Docker + wasm 章节](../build-and-run/docker_wasm.md)。

## 环境

你必须安装 Docker Desktop 4.15+。确保在 Docker Desktop 中启用了 containerd 镜像存储功能。

![Docker config](docker_config.png)

## 运行独立的 WASM 应用

Hello World 示例是一个独立的 Rust 应用程序。其源代码和构建说明在[此处](https://github.com/second-state/rust-examples/tree/main/hello)。

使用 Docker 来运行容器化的 WASM 应用。WASM 容器镜像存储在 Docker Hub 中，镜像大小仅为 500KB。该镜像可在 Docker 支持的任何 OS 和 CPU 平台上运行。

```bash
$ docker run --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/rust-example-hello:latest
Hello WasmEdge!
```

了解如何在 Rust 中创建 WASM 应用

- [WasmEdge 的基本 Rust 示例](https://github.com/second-state/rust-examples)
- [Rust 开发者指南](/category/develop-wasm-apps-in-rust)
  - 使用 [PyTorch](../../develop/rust/wasinn/pytorch.md)、[OpenVINO](../../develop/rust/wasinn/openvino.md) 或 [Tensorflow Lite](../../develop/rust/wasinn/tensorflow_lite.md) 后端的 WASI-NN
  - [HTTP 和 HTTPS 客户端](../../develop/rust/http_service/client.md)
  - [MySQL 数据库客户端](../../develop/rust/database/my_sql_driver.md)
  - Redis 客户端
  - Kafka 客户端

## 运行 HTTP 服务器

这个示例是一个用 Rust 编写的独立的 HTTP 服务器。它演示了 Rust + WasmEdge 作为轻量级微服务堆栈。其源代码和构建说明在[此处](https://github.com/second-state/rust-examples/tree/main/server)。

使用 Docker 从 Docker Hub 拉取容器镜像（大约 800KB），然后在 WasmEdge 容器中运行它。该容器作为服务器启动。请注意，我们将容器的端口 8080 映射到本地主机的端口 8080，以便从 WASM 容器外部访问服务器。

```bash
$ docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/rust-example-server:latest
Listening on http://0.0.0.0:8080
```

在另一个终端窗口中执行以下操作。

```bash
$ curl http://localhost:8080/
Try POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`

$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

了解如何在 Rust 中创建 WASM 服务

- [Rust 开发者指南](/category/develop-wasm-apps-in-rust)
- [HTTP 应用程序示例](https://github.com/WasmEdge/wasmedge_hyper_demo)
- [数据库应用程序示例](https://github.com/WasmEdge/wasmedge-db-examples)
- Rust 和 WasmEdge 中的轻量级微服务
  - [WasmEdge + Nginx + MySQL](https://github.com/second-state/microservice-rust-mysql)
  - [WasmEdge + Kafka + MySQL](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql)
  - [Dapr + WasmEdge](https://github.com/second-state/dapr-wasm)

## 运行基于 JavaScript 的服务器

这个示例是使用 Node.js API 编写的独立 HTTP 服务器。它演示了将 WasmEdge 作为零依赖和可移植的 Node.js 应用的轻量级运行时。其源代码在[此处](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/docker_wasm/server)。

```bash
$ docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/node-example-server:latest
... ...
```

在另一个终端窗口中执行以下操作。

```bash
$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

了解如何在 WasmEdge 中运行 JavaScript 应用。

- [WasmEdge QuickJS runtime](https://github.com/second-state/wasmedge-quickjs)
- [AI 推理应用示例](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo)
- [使用 fetch() 的 Web 服务客户端示例](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js)

## 下一步

- [了解有关在 Docker 中构建和管理 WASM 容器](../build-and-run/docker_wasm.md)
- [WasmEdge 的基本 Rust 示例](https://github.com/second-state/rust-examples)
- 使用 Docker Compose 构建和 Rust 的微服务
  - [WasmEdge / MySQL / Nginx](https://github.com/docker/awesome-compose/tree/master/wasmedge-mysql-nginx) - 示例使用静态 HTML 前端的 Wasm-based Web 应用，使用 MySQL（MariaDB）数据库。前端连接到使用 WasmEdge runtime 运行的用 Rust 编写的 WASM 微服务。
  - [WasmEdge / Kafka / MySQL](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql) - 示例 Wasm-based 微服务订阅 Kafka（Redpanda）队列主题，并将任何传入的消息转换并保存到 MySQL（MariaDB）数据库中。
- 用你喜欢的语言编写 WASM 应用，比如 [Rust](/category/develop-wasm-apps-in-rust)、[C/C++](/category/develop-wasm-apps-in-cc)、[JavaScript](/category/develop-wasm-apps-in-javascript)、[Go](/category/develop-wasm-apps-in-go) 和许多其他语言。
","This is a tutorial guide for quickly running WasmEdge applications using Docker Desktop. The guide covers three examples: 

1. Running an independent WASM app (a Rust application) 
2. Running an HTTP server (a Rust application)
3. Running a JavaScript-based server (a Node.js application)

**Environment**: To follow this guide, you need to have Docker Desktop 4.15+ installed and containerd image storage enabled.

**Running Independent WASM App**

The ""Hello World"" example is a standalone Rust app. The source code and build instructions are available on GitHub.

```bash
$ docker run --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/rust-example-hello:latest
Hello WasmEdge!
```

**Running HTTP Server**

The ""Rust-based server"" example is a standalone Rust app that demonstrates the use of Rust + WasmEdge as a lightweight microservices stack. 

```bash
$ docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/rust-example-server:latest
```

**Running JavaScript-based Server**

The ""Node.js server"" example is a standalone HTTP server written in Node.js. 

```bash
$ docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/node-example-server:latest
```

Potential issues and areas for improvement:

1. **Container size**: The containers used in the examples have a relatively large size, which might be an issue for users with limited storage space.
2. **Networking**: The guide assumes that the user has basic knowledge of Docker networking concepts and can map ports correctly.
3. **Security**: The guide does not provide information on security best practices when using WasmEdge and Docker containers in a production environment.

Overall, this is a well-structured tutorial that provides a clear introduction to using Docker with WasmEdge applications."
docs/start/usage/use-cases.md,"---
sidebar_position: 1
---

# Use Cases

Featuring AOT compiler optimization, WasmEdge is one of the fastest WebAssembly runtimes on the market today. Therefore WasmEdge is widely used in edge computing, automotive, Jamstack, serverless, SaaS, service mesh, and even blockchain applications.

- Modern web apps feature rich UIs that are rendered in the browser and/or on the edge cloud. WasmEdge works with popular web UI frameworks, such as React, Vue, Yew, and Percy, to support isomorphic [server-side rendering (SSR)](../../embed/use-case/ssr-modern-ui.md) functions on edge servers. It could also support server-side rendering of Unity3D animations and AI-generated interactive videos for web applications on the edge cloud.

- WasmEdge provides a lightweight, secure and high-performance runtime for microservices. It is fully compatible with application service frameworks such as Dapr, and service orchestrators like Kubernetes. WasmEdge microservices can run on edge servers, and have access to distributed cache, to support both stateless and stateful business logic functions for modern web apps. Also related: Serverless function-as-a-service in public clouds.

- [Serverless SaaS (Software-as-a-Service)](/category/serverless-platforms) functions enables users to extend and customize their SaaS experience without operating their own API callback servers. The serverless functions can be embedded into the SaaS or reside on edge servers next to the SaaS servers. Developers simply upload functions to respond to SaaS events or to connect SaaS APIs.

- [Smart device apps](./wasm-smart-devices.md) could embed WasmEdge as a middleware runtime to render interactive content on the UI, connect to native device drivers, and access specialized hardware features (i.e, the GPU for AI inference). The benefits of the WasmEdge runtime over native-compiled machine code include security, safety, portability, manageability, and developer productivity. WasmEdge runs on Android, OpenHarmony, and seL4 RTOS devices.

- WasmEdge could support high performance DSLs (Domain Specific Languages) or act as a cloud-native JavaScript runtime by embedding a JS execution engine or interpreter.

- Developers can leverage container tools such as [Kubernetes](../../develop/deploy/kubernetes/kubernetes-containerd-crun.md), Docker and CRI-O to deploy, manage, and run lightweight WebAssembly applications.

- WasmEdge applications can be plugged into existing application frameworks or platforms.

If you have any great ideas on WasmEdge, don't hesitate to open a GitHub issue to discuss together.
","**Summary**

The provided code is not a programming code but rather a documentation file describing use cases for the WasmEdge WebAssembly runtime. The document highlights various applications and use cases where WasmEdge can be employed, including:

1. Edge computing and automotive
2. Jamstack and serverless environments
3. Service mesh and blockchain applications
4. Modern web apps with rich UIs
5. Microservices and distributed cache
6. Serverless SaaS functions
7. Smart device apps (e.g., Android, OpenHarmony)
8. High-performance DSLs or cloud-native JavaScript runtime
9. Container deployment with Kubernetes, Docker, and CRI-O

**Key Components**

The key components of WasmEdge highlighted in the documentation are:

1. AOT (Ahead-of-Time) compiler optimization for performance
2. Lightweight and secure runtime environment
3. Compatibility with various frameworks and platforms (e.g., React, Vue, Yew, Dapr, Kubernetes)
4. Support for server-side rendering (SSR), isomorphic functions, and microservices

**Potential Issues or Areas for Improvement**

1. **Documentation organization**: The document could be organized into sections with clear headings and subheadings to improve readability.
2. **Code examples**: While the documentation provides use cases, it would be beneficial to include code snippets or examples to illustrate how WasmEdge can be used in each scenario.
3. **Technical details**: Some of the concepts mentioned (e.g., AOT compiler optimization, isomorphic functions) might require more detailed explanations for developers who are not familiar with these topics.
4. **Comparison with other solutions**: The documentation could benefit from comparisons with other WebAssembly runtimes or solutions to help users understand the advantages and disadvantages of WasmEdge.

Overall, the documentation provides a good overview of the use cases and capabilities of WasmEdge, but some areas for improvement remain."
docs/develop/javascript/hello_world.md,"---
sidebar_position: 2
---

# Quickstart for JavaScript

## Prerequisites

[Install WasmEdge](../../start/install.md#install)

Clone the [wasmedge-quickjs](https://github.com/second-state/wasmedge-quickjs) repo and use it as the current directory.

```bash
git clone https://github.com/second-state/wasmedge-quickjs
cd wasmedge-quickjs
```

Then download the pre-built WasmEdge QuickJS Runtime program, and optionally, AOT compile it for better performance.

```bash
curl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm
wasmedge compile wasmedge_quickjs.wasm wasmedge_quickjs.wasm
```

<!-- prettier-ignore -->
:::note
The reason to use `wasmedge-quickjs` as the current working directory is that `modules` in the repo are required for the QuickJS runtime.
:::

## Quick start

You can try a simple ""hello world"" JavaScript program ([example_js/hello.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/hello.js)), which prints out the command line arguments to the console.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime
Hello WasmEdge Runtime
```

<!-- prettier-ignore -->
:::note
The `--dir .:.` on the command line is to give `wasmedge` permission to read the local directory in the file system for the `hello.js` file.
:::

The JavaScript source code for the `hello.js` program is as follows.

```javascript
import * as os from 'os';
import * as std from 'std';

args = args.slice(1);
print('Hello', ...args);
setTimeout(() => {
  print('timeout 2s');
}, 2000);
```

## Build it yourself

This section is optional. Read on if you are interested in [adding custom built-in JavaScript APIs](rust) to the runtime.

Following the instructions, you can build a JavaScript interpreter for WasmEdge. Make sure you have installed GCC. If you don't, run the following command line.

```bash
# Install GCC
sudo apt update
sudo apt install build-essential
```

Then, we could build the WasmEdge-Quickjs runtime.

Fork or clone [the wasmedge-quickjs Github repository](https://github.com/second-state/wasmedge-quickjs).

```bash
# get the source code
git clone https://github.com/second-state/wasmedge-quickjs
cd wasmedge-quickjs

# Build the QuickJS JavaScript interpreter
cargo build --target wasm32-wasi --release
```

The WebAssembly-based JavaScript interpreter program is located in the build `target` directory.

WasmEdge provides a `wasmedgec` utility to compile and add a native machine code section to the `wasm` file. You can use `wasmedge` to run the natively instrumented `wasm` file to get a much faster performance.

```bash
wasmedge compile target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs.wasm
wasmedge --dir .:. wasmedge_quickjs.wasm example_js/hello.js
```

Next, we will discuss more advanced use cases for JavaScript in WasmEdge.
","**Summary**

The provided code is a quickstart guide for running JavaScript on the WasmEdge WebAssembly runtime. It provides instructions for installing and setting up WasmEdge, downloading the pre-built QuickJS Runtime program, and optionally AOT compiling it for better performance.

**Key Components**

1. Prerequisites:
	* Installing WasmEdge
	* Cloning the `wasmedge-quickjs` repository
2. Quick Start:
	* Downloading the pre-built QuickJS Runtime program
	* Running a simple ""hello world"" JavaScript program (`example_js/hello.js`)
3. Building it yourself (optional):
	* Installing GCC
	* Building the WasmEdge-Quickjs runtime using Cargo

**Functionality**

The code demonstrates how to run JavaScript on WasmEdge by:

1. Importing modules (`os` and `std`) in a JavaScript file (`hello.js`)
2. Defining a simple function that prints ""Hello"" followed by command-line arguments
3. Using the `setTimeout` function to print a message after 2 seconds

**Potential Issues or Areas for Improvement**

1. The code assumes that the user has installed GCC, which may not be the case on all systems.
2. The instructions for building the WasmEdge-Quickjs runtime are specific to the WASM32-WASI target and may need modifications for other targets.
3. The `wasmedge` command is used to run the natively instrumented `wasm` file, but this step can be skipped if the user only wants to run the uninstrumented `wasm` file.

**Code Quality**

The code is well-structured and easy to follow. However, there are some areas where the code could benefit from additional comments or documentation:

1. The instructions for installing GCC and building the WasmEdge-Quickjs runtime are not thoroughly documented.
2. The `hello.js` example script does not have any comments or explanations about its purpose or how it works.

Overall, the code is a good starting point for exploring JavaScript on WasmEdge, but may benefit from additional documentation and testing to make it more accessible to users."
docs/embed/use-case/libsql.md,"---
sidebar_position: 1
---

# UDF in the libSQL database

[libSQL](https://github.com/libsql/libsql) is a fork of the popular [SQLite](https://www.sqlite.org/) database. One of the key enhancements libSQL brings is UDF (User Defined Functions) support. Through Wasm-based UDFs, users can add their own processing logic to the database, and then process the data in and out of the database on the fly. libSQL uses WasmEdge to run these UDFs. In this article, I will show you how.

## Prerequisites

First, you will need to [install WasmEdge runtime](../../start/install.md#install).

Next, install the latest libSQL or build it from source.

```bash
git clone https://github.com/libsql/libsql
cd libsql
./configure --enable-wasm-runtime-wasmedge
make
```

## The encrypt and decrypt example

Build the encrypt and decrypt example into wasm. Since WasmEdge supports WASI functions here, we will use the `wasm32-wasi` target.

```bash
git clone https://github.com/libsql/libsql_bindgen
cd libsql_bindgen/examples/encrypt_decrypt
cargo build --target wasm32-wasi --release
```

Then, we can build a SQL file for creating the `encrypt` function in a libSQL database.

```bash
export FUNC_NAME='encrypt'
echo ""DROP FUNCTION IF EXISTS ${FUNC_NAME};"" >> create_${FUNC_NAME}_udf.sql
echo -n ""CREATE FUNCTION ${FUNC_NAME} LANGUAGE wasm AS X'"" >> create_${FUNC_NAME}_udf.sql
xxd -p  ../../target/wasm32-wasi/release/libsql_encrypt_decrypt.wasm | tr -d ""\n"" >> create_${FUNC_NAME}_udf.sql
echo ""';"" >> create_${FUNC_NAME}_udf.sql
```

Create another SQL file for the `decrypt` function.

```bash
export FUNC_NAME='decrypt'
echo ""DROP FUNCTION IF EXISTS ${FUNC_NAME};"" >> create_${FUNC_NAME}_udf.sql
echo -n ""CREATE FUNCTION ${FUNC_NAME} LANGUAGE wasm AS X'"" >> create_${FUNC_NAME}_udf.sql
xxd -p  ../../target/wasm32-wasi/release/libsql_encrypt_decrypt.wasm | tr -d ""\n"" >> create_${FUNC_NAME}_udf.sql
echo ""';"" >> create_${FUNC_NAME}_udf.sql
```

Now, you can add those UDFs to a libSQL instance.

```bash
./libsql
libsql> .init_wasm_func_table
libsql> .read create_encrypt_udf.sql
libsql> .read create_decrypt_udf.sql
```

Finally, you can create a table and test it.

```bash
libsql>

CREATE TABLE secrets(secret);
INSERT INTO secrets (secret) VALUES (encrypt('my secret value: 1', 's3cretp4ss'));
INSERT INTO secrets (secret) VALUES (encrypt('my even more secret value: 2', 's3cretp4ss'));
INSERT INTO secrets (secret) VALUES (encrypt('classified value: 3', 's3cretp4ss'));

SELECT secret, decrypt(secret, 'wrong-pass') from secrets;
secret                                        decrypt(secret, 'wrong-pass')
--------------------------------------------  -----------------------------
IyTvoTEnh9a/f6+pac3rLPToP9DkWqS7CEW8tan3mbQ=  [ACCESS DENIED]
bUQ4fEe6hPnsMx8ABOZO97CMr/wouGTByfUCEmFVZTs=  [ACCESS DENIED]
o+m1w7UdoxBZxLumNW0VoMKSMFaC4o8N5uknAQZ/yFY=  [ACCESS DENIED]

SELECT secret, decrypt(secret, 's3cretp4ss') from secrets;
secret                                        decrypt(secret, 's3cretp4ss')
--------------------------------------------  -----------------------------
IyTvoTEnh9a/f6+pac3rLPToP9DkWqS7CEW8tan3mbQ=  my secret value: 1
bUQ4fEe6hPnsMx8ABOZO97CMr/wouGTByfUCEmFVZTs=  my even more secret value: 2
o+m1w7UdoxBZxLumNW0VoMKSMFaC4o8N5uknAQZ/yFY=  classified value: 3
```
","**Summary**

This document describes how to use User Defined Functions (UDFs) in the libSQL database, a fork of SQLite. libSQL supports Wasm-based UDFs that can be used to add custom processing logic to the database. The example demonstrates how to create and use two UDFs: `encrypt` and `decrypt`, using the WASI target.

**Key Components**

1. **libSQL**: A fork of SQLite with support for Wasm-based UDFs.
2. **WasmEdge**: A runtime environment used to execute Wasm-based UDFs.
3. **libsql_bindgen**: A library used to build and manage libSQL UDFs.
4. **create_*_udf.sql**: SQL scripts used to create the `encrypt` and `decrypt` functions.

**Prerequisites**

1. Install the WasmEdge runtime.
2. Clone and build the latest libSQL or build it from source.

**Steps**

1. Build the encrypt and decrypt example into wasm using Cargo.
2. Create SQL files for creating the `encrypt` and `decrypt` functions.
3. Run the libSQL instance and initialize the WASM function table.
4. Read the create_*_udf.sql scripts to add the UDFs to the libSQL instance.
5. Test the UDFs by creating a table, inserting data, and decrypting the encrypted values.

**Potential Issues**

1. **Security**: The example uses a hardcoded password for decryption, which is insecure in production environments.
2. **Performance**: The performance of Wasm-based UDFs may be lower compared to native code implementations.
3. **Dependencies**: The example requires libsql_bindgen and WasmEdge runtime, which may require additional dependencies and setup.

**Areas for Improvement**

1. **Error handling**: Improve error handling in the UDFs and the SQL scripts.
2. **Performance optimization**: Optimize performance by using more efficient algorithms or data structures.
3. **Security enhancements**: Implement secure password storage and authentication mechanisms."
i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/hello_world.md,"---
sidebar_position: 2
---

# Quickstart for JavaScript

## Prerequisites

[Install WasmEdge](../../start/install.md#install)

Clone the [wasmedge-quickjs](https://github.com/second-state/wasmedge-quickjs) repo and use it as the current directory.

```bash
git clone https://github.com/second-state/wasmedge-quickjs
cd wasmedge-quickjs
```

Then download the pre-built WasmEdge QuickJS Runtime program, and optionally, AOT compile it for better performance.

```bash
curl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm
wasmedge compile wasmedge_quickjs.wasm wasmedge_quickjs.wasm
```

<!-- prettier-ignore -->
:::note
The reason to use `wasmedge-quickjs` as the current working directory is that `modules` in the repo are required for the QuickJS runtime.
:::

## Quick start

You can try a simple ""hello world"" JavaScript program ([example_js/hello.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/hello.js)), which prints out the command line arguments to the console.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime
Hello WasmEdge Runtime
```

<!-- prettier-ignore -->
:::note
The `--dir .:.` on the command line is to give `wasmedge` permission to read the local directory in the file system for the `hello.js` file.
:::

The JavaScript source code for the `hello.js` program is as follows.

```javascript
import * as os from 'os';
import * as std from 'std';

args = args.slice(1);
print('Hello', ...args);
setTimeout(() => {
  print('timeout 2s');
}, 2000);
```

## Build it yourself

This section is optional. Read on if you are interested in [adding custom built-in JavaScript APIs](rust) to the runtime.

Following the instructions, you can build a JavaScript interpreter for WasmEdge. Make sure you have installed GCC. If you don't, run the following command line.

```bash
# Install GCC
sudo apt update
sudo apt install build-essential
```

Then, we could build the WasmEdge-Quickjs runtime.

Fork or clone [the wasmedge-quickjs Github repository](https://github.com/second-state/wasmedge-quickjs).

```bash
# get the source code
git clone https://github.com/second-state/wasmedge-quickjs
cd wasmedge-quickjs

# Build the QuickJS JavaScript interpreter
cargo build --target wasm32-wasi --release
```

The WebAssembly-based JavaScript interpreter program is located in the build `target` directory.

WasmEdge provides a `wasmedgec` utility to compile and add a native machine code section to the `wasm` file. You can use `wasmedge` to run the natively instrumented `wasm` file to get a much faster performance.

```bash
wasmedge compile target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs.wasm
wasmedge --dir .:. wasmedge_quickjs.wasm example_js/hello.js
```

Next, we will discuss more advanced use cases for JavaScript in WasmEdge.
","**Summary:**

This is a Markdown documentation for the Quickstart guide of WasmEdge, a WebAssembly runtime. The guide provides step-by-step instructions on how to set up and use WasmEdge with JavaScript. It covers installing WasmEdge, cloning a repository, downloading pre-built binaries, and running a simple ""hello world"" JavaScript program.

**Key Components:**

1. **Prerequisites:** Install WasmEdge and clone the `wasmedge-quickjs` repository.
2. **Quick start:** Run a simple JavaScript program (`hello.js`) using WasmEdge.
3. **Build it yourself:** Build a custom WasmEdge runtime with a built-in JavaScript API.

**Code:**

The guide includes code snippets for:

1. Installing WasmEdge and cloning the repository
2. Running a simple ""hello world"" JavaScript program
3. Building a custom WasmEdge runtime

**Potential Issues or Areas for Improvement:**

1. **Assumes prior knowledge:** The guide assumes the reader has basic knowledge of WebAssembly, Rust, and C++.
2. **Lack of error handling:** The code snippets do not include error handling, which may make it difficult to diagnose issues.
3. **Complexity:** The build process for a custom WasmEdge runtime is complex and requires advanced knowledge of Rust and Cargo.

**Recommendations:**

1. **Simplify the installation process:** Provide more detailed instructions on installing WasmEdge and its dependencies.
2. **Add error handling:** Include try-catch blocks in code snippets to handle potential errors.
3. **Break down complex tasks:** Divide the build process into smaller, more manageable steps for easier understanding."
i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/libsql.md,"---
sidebar_position: 1
---

# UDF in the libSQL database

[libSQL](https://github.com/libsql/libsql) is a fork of the popular [SQLite](https://www.sqlite.org/) database. One of the key enhancements libSQL brings is UDF (User Defined Functions) support. Through Wasm-based UDFs, users can add their own processing logic to the database, and then process the data in and out of the database on the fly. libSQL uses WasmEdge to run these UDFs. In this article, I will show you how.

## Prerequisites

First, you will need to [install WasmEdge runtime](../../start/install.md#install).

Next, install the latest libSQL or build it from source.

```bash
git clone https://github.com/libsql/libsql
cd libsql
./configure --enable-wasm-runtime-wasmedge
make
```

## The encrypt and decrypt example

Build the encrypt and decrypt example into wasm. Since WasmEdge supports WASI functions here, we will use the `wasm32-wasi` target.

```bash
git clone https://github.com/libsql/libsql_bindgen
cd libsql_bindgen/examples/encrypt_decrypt
cargo build --target wasm32-wasi --release
```

Then, we can build a SQL file for creating the `encrypt` function in a libSQL database.

```bash
export FUNC_NAME='encrypt'
echo ""DROP FUNCTION IF EXISTS ${FUNC_NAME};"" >> create_${FUNC_NAME}_udf.sql
echo -n ""CREATE FUNCTION ${FUNC_NAME} LANGUAGE wasm AS X'"" >> create_${FUNC_NAME}_udf.sql
xxd -p  ../../target/wasm32-wasi/release/libsql_encrypt_decrypt.wasm | tr -d ""\n"" >> create_${FUNC_NAME}_udf.sql
echo ""';"" >> create_${FUNC_NAME}_udf.sql
```

Create another SQL file for the `decrypt` function.

```bash
export FUNC_NAME='decrypt'
echo ""DROP FUNCTION IF EXISTS ${FUNC_NAME};"" >> create_${FUNC_NAME}_udf.sql
echo -n ""CREATE FUNCTION ${FUNC_NAME} LANGUAGE wasm AS X'"" >> create_${FUNC_NAME}_udf.sql
xxd -p  ../../target/wasm32-wasi/release/libsql_encrypt_decrypt.wasm | tr -d ""\n"" >> create_${FUNC_NAME}_udf.sql
echo ""';"" >> create_${FUNC_NAME}_udf.sql
```

Now, you can add those UDFs to a libSQL instance.

```bash
./libsql
libsql> .init_wasm_func_table
libsql> .read create_encrypt_udf.sql
libsql> .read create_decrypt_udf.sql
```

Finally, you can create a table and test it.

```bash
libsql>

CREATE TABLE secrets(secret);
INSERT INTO secrets (secret) VALUES (encrypt('my secret value: 1', 's3cretp4ss'));
INSERT INTO secrets (secret) VALUES (encrypt('my even more secret value: 2', 's3cretp4ss'));
INSERT INTO secrets (secret) VALUES (encrypt('classified value: 3', 's3cretp4ss'));

SELECT secret, decrypt(secret, 'wrong-pass') from secrets;
secret                                        decrypt(secret, 'wrong-pass')
--------------------------------------------  -----------------------------
IyTvoTEnh9a/f6+pac3rLPToP9DkWqS7CEW8tan3mbQ=  [ACCESS DENIED]
bUQ4fEe6hPnsMx8ABOZO97CMr/wouGTByfUCEmFVZTs=  [ACCESS DENIED]
o+m1w7UdoxBZxLumNW0VoMKSMFaC4o8N5uknAQZ/yFY=  [ACCESS DENIED]

SELECT secret, decrypt(secret, 's3cretp4ss') from secrets;
secret                                        decrypt(secret, 's3cretp4ss')
--------------------------------------------  -----------------------------
IyTvoTEnh9a/f6+pac3rLPToP9DkWqS7CEW8tan3mbQ=  my secret value: 1
bUQ4fEe6hPnsMx8ABOZO97CMr/wouGTByfUCEmFVZTs=  my even more secret value: 2
o+m1w7UdoxBZxLumNW0VoMKSMFaC4o8N5uknAQZ/yFY=  classified value: 3
```
","**Summary**

This code provides a step-by-step guide on how to create and use User Defined Functions (UDFs) in the libSQL database, which is a fork of SQLite. The UDFs are written in WebAssembly (Wasm) and run using WasmEdge runtime. The example demonstrates how to encrypt and decrypt data using custom functions.

**Key Components**

1. **libsql**: A fork of SQLite database with support for UDFs.
2. **WasmEdge**: A WebAssembly runtime used to execute UDFs.
3. **UDFs**: User Defined Functions written in Wasm, which can be added to the libSQL instance.
4. **create_encrypt_udf.sql** and **create_decrypt_udf.sql**: SQL files used to create the UDFs in the libSQL database.

**Step-by-Step Process**

1. Install the latest version of libSQL or build it from source.
2. Clone the `libsql_bindgen` repository and build the example Wasm module for encryption/decryption.
3. Create two SQL files, one for creating the encrypt function (`create_encrypt_udf.sql`) and another for creating the decrypt function (`create_decrypt_udf.sql`).
4. Build a libSQL instance and load the UDFs using the `init_wasm_func_table`, `read` commands.

**Potential Issues**

1. **Wasm compilation issues**: The Wasm module may not compile correctly due to errors in the code or dependencies.
2. **libsql compatibility issues**: There might be compatibility issues between libSQL and the UDF implementation.
3. **Performance overhead**: Executing UDFs using WasmEdge may introduce performance overhead compared to native functions.

**Areas for Improvement**

1. **Simplifying the example**: The example code can be simplified by reducing the number of steps or removing unnecessary files.
2. **Improving documentation**: Additional comments and documentation should be added to explain the code, UDFs, and libSQL features.
3. **Error handling**: Error handling mechanisms should be implemented to handle unexpected errors during UDF execution."
docs/develop/javascript/npm.md,"---
sidebar_position: 8
---

# NodeJS and NPM modules

With [rollup.js](https://rollupjs.org/guide/en/), we can run CommonJS (CJS) and NodeJS (NPM) modules in WasmEdge too.

## Prerequisites

[See here](./hello_world#prerequisites)

## Run the example

The [simple_common_js_demo/npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) demo shows how it works.

First, you will need to use the NPM command to roll up the dependency modules into a single JavaScript file.

```bash
cd example_js/simple_common_js_demo
npm install
npm run build
# Go back to the working directory
cd ../../
```

NPM generates a new JavaScript file at `example_js/simple_common_js_demo/dist/npm_main.mjs`, which is the file you can execute with the WasmEdge QuickJS runtime.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/simple_common_js_demo/dist/npm_main.mjs
md5(message)= 78e731027d8fd50ed642340b7c9a63b3
sqrt(-4)= 2i
```

## Code explanation

The [simple_common_js_demo/npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) utilizes the third-party `md5` and `mathjs` modules.

```javascript
const md5 = require('md5');
console.log('md5(message)=', md5('message'));

const { sqrt } = require('mathjs');
console.log('sqrt(-4)=', sqrt(-4).toString());
```

To run it, we must first use the [rollup.js](https://rollupjs.org/guide/en/) tool to build all dependencies into a single file. In the process, `rollup.js` converts CommonJS modules into [WasmEdge-compatible ES6 modules](es6). The build script is [rollup.config.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/rollup.config.js).

```javascript
const { babel } = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const builtins = require('rollup-plugin-node-builtins');
const plugin_async = require('rollup-plugin-async');

const babelOptions = {
  presets: ['@babel/preset-react'],
};

module.exports = [
  {
    input: './npm_main.js',
    output: {
      inlineDynamicImports: true,
      file: 'dist/npm_main.mjs',
      format: 'esm',
    },
    external: ['process', 'wasi_net', 'std'],
    plugins: [
      plugin_async(),
      nodeResolve(),
      commonjs({ ignoreDynamicRequires: false }),
      babel(babelOptions),
      globals(),
      builtins(),
      replace({
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];
```

The [package.json](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/package.json) file specifies the `rollup.js` dependencies and the command to build the [npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) demo program into a single bundle.

```json
{
  ""dependencies"": {
    ""mathjs"": ""^9.5.1"",
    ""md5"": ""^2.3.0""
  },
  ""devDependencies"": {
    ""@babel/core"": ""^7.16.5"",
    ""@babel/preset-env"": ""^7.16.5"",
    ""@babel/preset-react"": ""^7.16.5"",
    ""@rollup/plugin-babel"": ""^5.3.0"",
    ""@rollup/plugin-commonjs"": ""^21.0.1"",
    ""@rollup/plugin-node-resolve"": ""^7.1.3"",
    ""@rollup/plugin-replace"": ""^3.0.0"",
    ""rollup"": ""^2.60.1"",
    ""rollup-plugin-babel"": ""^4.4.0"",
    ""rollup-plugin-node-builtins"": ""^2.1.2"",
    ""rollup-plugin-node-globals"": ""^1.4.0"",
    ""rollup-plugin-async"": ""^1.2.0""
  },
  ""scripts"": {
    ""build"": ""rollup -c rollup.config.js""
  }
}
```

Run the following NPM commands to build [npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) demo program into `dist/npm_main.mjs`.

```bash
npm install
npm run build
```

You can import and run any NPM packages in WasmEdge this way.
","**Summary**

The code provided demonstrates how to use Rollup.js to bundle CommonJS (CJS) and Node.js (NPM) modules for execution in WasmEdge. The example uses the `md5` and `mathjs` third-party libraries, which are installed via NPM. The Rollup configuration file (`rollup.config.js`) is used to build the dependencies into a single file, converting CJS modules to ES6 modules compatible with WasmEdge.

**Key Components**

1. **Rollup Configuration File**: `rollup.config.js` specifies the input file (`npm_main.js`), output file format (ESM), and plugins for building the dependencies.
2. **NPM Packages**: `mathjs` and `md5` are used in the example, and their installation is specified in `package.json`.
3. **Build Script**: The `build` script in `package.json` runs Rollup using the configuration file to build the `npm_main.js` demo program into a single bundle (`dist/npm_main.mjs`).
4. **WasmEdge Execution**: The generated `dist/npm_main.mjs` file is executed using WasmEdge, along with the QuickJS runtime.

**Potential Issues or Areas for Improvement**

1. **Dependency Management**: As the number of dependencies grows, managing their versions and compatibility with WasmEdge may become more complex.
2. **Optimization**: The Rollup configuration can be optimized to reduce bundle size and improve performance.
3. **Error Handling**: Implementing robust error handling mechanisms in the demo program and during build process would make it more reliable.
4. **Security**: Ensure that third-party libraries used are secure and up-to-date, as outdated or vulnerable libraries can compromise WasmEdge's security.

Overall, this code demonstrates a practical approach to using Rollup.js for bundling NPM packages for execution in WasmEdge. However, as with any complex software system, ongoing maintenance, optimization, and security considerations are essential to ensure its reliability and effectiveness."
i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/npm.md,"---
sidebar_position: 8
---

# NodeJS and NPM modules

With [rollup.js](https://rollupjs.org/guide/en/), we can run CommonJS (CJS) and NodeJS (NPM) modules in WasmEdge too.

## Prerequisites

[See here](./hello_world#prerequisites)

## Run the example

The [simple_common_js_demo/npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) demo shows how it works.

First, you will need to use the NPM command to roll up the dependency modules into a single JavaScript file.

```bash
cd example_js/simple_common_js_demo
npm install
npm run build
# Go back to the working directory
cd ../../
```

NPM generates a new JavaScript file at `example_js/simple_common_js_demo/dist/npm_main.mjs`, which is the file you can execute with the WasmEdge QuickJS runtime.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/simple_common_js_demo/dist/npm_main.mjs
md5(message)= 78e731027d8fd50ed642340b7c9a63b3
sqrt(-4)= 2i
```

## Code explanation

The [simple_common_js_demo/npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) utilizes the third-party `md5` and `mathjs` modules.

```javascript
const md5 = require('md5');
console.log('md5(message)=', md5('message'));

const { sqrt } = require('mathjs');
console.log('sqrt(-4)=', sqrt(-4).toString());
```

To run it, we must first use the [rollup.js](https://rollupjs.org/guide/en/) tool to build all dependencies into a single file. In the process, `rollup.js` converts CommonJS modules into [WasmEdge-compatible ES6 modules](es6). The build script is [rollup.config.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/rollup.config.js).

```javascript
const { babel } = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const builtins = require('rollup-plugin-node-builtins');
const plugin_async = require('rollup-plugin-async');

const babelOptions = {
  presets: ['@babel/preset-react'],
};

module.exports = [
  {
    input: './npm_main.js',
    output: {
      inlineDynamicImports: true,
      file: 'dist/npm_main.mjs',
      format: 'esm',
    },
    external: ['process', 'wasi_net', 'std'],
    plugins: [
      plugin_async(),
      nodeResolve(),
      commonjs({ ignoreDynamicRequires: false }),
      babel(babelOptions),
      globals(),
      builtins(),
      replace({
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];
```

The [package.json](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/package.json) file specifies the `rollup.js` dependencies and the command to build the [npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) demo program into a single bundle.

```json
{
  ""dependencies"": {
    ""mathjs"": ""^9.5.1"",
    ""md5"": ""^2.3.0""
  },
  ""devDependencies"": {
    ""@babel/core"": ""^7.16.5"",
    ""@babel/preset-env"": ""^7.16.5"",
    ""@babel/preset-react"": ""^7.16.5"",
    ""@rollup/plugin-babel"": ""^5.3.0"",
    ""@rollup/plugin-commonjs"": ""^21.0.1"",
    ""@rollup/plugin-node-resolve"": ""^7.1.3"",
    ""@rollup/plugin-replace"": ""^3.0.0"",
    ""rollup"": ""^2.60.1"",
    ""rollup-plugin-babel"": ""^4.4.0"",
    ""rollup-plugin-node-builtins"": ""^2.1.2"",
    ""rollup-plugin-node-globals"": ""^1.4.0"",
    ""rollup-plugin-async"": ""^1.2.0""
  },
  ""scripts"": {
    ""build"": ""rollup -c rollup.config.js""
  }
}
```

Run the following NPM commands to build [npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) demo program into `dist/npm_main.mjs`.

```bash
npm install
npm run build
```

You can import and run any NPM packages in WasmEdge this way.
","**Summary:**

This document provides a guide on how to run Node.js and NPM modules in WasmEdge using Rollup.js. The example demonstrates how to use the `md5` and `mathjs` libraries with WasmEdge.

**Key Components:**

1. **Rollup.js**: A tool used to build all dependencies into a single file.
2. **npm_main.js**: The demo program that utilizes third-party modules (`md5` and `mathjs`).
3. **rollup.config.js**: The configuration file for Rollup.js, specifying plugins and settings.
4. **package.json**: The package file specifying dependencies and build scripts.

**Functionality:**

1. Install dependencies using NPM.
2. Run the Rollup.js build script to create a single bundle `dist/npm_main.mjs`.
3. Execute `npm_main.mjs` with WasmEdge QuickJS runtime.

**Potential Issues and Areas for Improvement:**

1. **Dependency Management**: Managing multiple dependencies (e.g., `md5`, `mathjs`) can be complex.
2. **Compatibility**: Ensuring compatibility between Rollup.js, NPM, and WasmEdge versions.
3. **Performance**: Optimizing build times and runtime performance.
4. **Documentation**: Improving documentation for developers to create and run NPM modules in WasmEdge.

**Recommendations:**

1. Use a more efficient dependency manager (e.g., yarn) for easier dependency management.
2. Test the example with different NPM packages and libraries.
3. Optimize the build process by using more efficient plugins or configuration options.
4. Improve documentation to make it easier for developers to create and run their own NPM modules in WasmEdge."
docs/embed/use-case/ssr-modern-ui.md,"---
sidebar_position: 6
---

# Server Side Rendering Modern Web UI

Traditional web applications follow the client-server model. In the past era of application servers, the entire UI is dynamically generated from the server. The browser is a thin client that displays the rendered web pages in real-time. However, as the browser becomes more capable and sophisticated, the client can take on more workload to improve application UX, performance, and security.

That gave rise to the era of Jamstack. There is now a clear separation between frontend and backend services. The frontend is a static website (HTML + JavaScript + WebAssembly) generated from UI frameworks such as React.js, Vue.js, Yew, or Percy, and the backend consists of microservices. Yet, as Jamstack gains popularity, the diversity of clients (browsers and apps) makes it difficult to achieve great performance across all use cases.

The solution is server-side rendering (SSR). That is to have edge servers run the ""client side"" UI code (i.e., the React-generated JavaScript OR Percy-generated WebAssembly) and send back the rendered HTML DOM objects to the browser. In this case, the edge server must execute the same code (i.e., [JavaScript](../../develop/javascript/hello_world.md) and WebAssembly) as the browser to render the UI. That is called isomorphic Jamstack applications. The WasmEdge runtime provides a lightweight, high-performance, OCI complaint, and polyglot container to run all SSR functions on edge servers.

- [React JS SSR function](../../develop/javascript/ssr.md)
- Vue JS SSR function (coming soon)
- Yew Rust compiled to WebAssembly SSR function (coming soon)
- [Percy Rust compiled to WebAssembly SSR function](../../develop/rust/ssr.md)

We also exploring ways to render more complex UI and interactions on WasmEdge-based edge servers and then stream the rendered results to the client application. Potential examples include

- Render Unity3D animations on the edge server (based on [WebAssembly rendering of Unity3D](https://docs.unity3d.com/2020.1/Documentation/Manual/webgl-gettingstarted.html))
- Render interactive video (generated from AI) on the edge server

Of course, the edge cloud could grow well beyond SSR for UI components. It could also host high-performance microservices for business logic and serverless functions. Read on to the next chapter.
","**Summary**

This code documentation describes the concept of Server-Side Rendering (SSR) for modern web UI, particularly in the context of Jamstack applications. The author argues that as browsers become more capable and sophisticated, the traditional client-server model may not be optimal for all use cases. To address this issue, SSR involves running ""client-side"" UI code on edge servers to generate rendered HTML DOM objects, which are then sent back to the browser.

**Key Components**

1. **Jamstack**: A modern web application architecture that separates frontend and backend services.
2. **Server-Side Rendering (SSR)**: The process of generating rendered HTML DOM objects on edge servers using client-side UI code.
3. **Isomorphic Jamstack Applications**: Applications that execute the same code on both client and server sides to render UI components.
4. **WasmEdge Runtime**: A lightweight, high-performance, and polyglot container for running SSR functions on edge servers.

**Potential Issues or Areas for Improvement**

1. **Scalability**: Edge servers may need to handle a large number of requests, which could impact performance.
2. **Security**: Running client-side code on edge servers may introduce security risks if not properly secured.
3. **Complexity**: Implementing SSR for complex UI components and interactions may require significant development effort.
4. **Standardization**: The use of WebAssembly as a runtime environment may not be universally adopted, which could create compatibility issues.

**Future Directions**

The author mentions exploring ways to render more complex UI and interactions on WasmEdge-based edge servers, such as:

1. **Unity3D Animations**: Rendering Unity3D animations on the edge server using WebAssembly.
2. **Interactive Video**: Rendering interactive video generated from AI on the edge server.

Overall, this documentation provides a comprehensive overview of SSR for modern web UI and its potential applications in Jamstack architectures."
i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/ssr-modern-ui.md,"---
sidebar_position: 6
---

# Server Side Rendering Modern Web UI

Traditional web applications follow the client-server model. In the past era of application servers, the entire UI is dynamically generated from the server. The browser is a thin client that displays the rendered web pages in real-time. However, as the browser becomes more capable and sophisticated, the client can take on more workload to improve application UX, performance, and security.

That gave rise to the era of Jamstack. There is now a clear separation between frontend and backend services. The frontend is a static website (HTML + JavaScript + WebAssembly) generated from UI frameworks such as React.js, Vue.js, Yew, or Percy, and the backend consists of microservices. Yet, as Jamstack gains popularity, the diversity of clients (browsers and apps) makes it difficult to achieve great performance across all use cases.

The solution is server-side rendering (SSR). That is to have edge servers run the ""client side"" UI code (i.e., the React-generated JavaScript OR Percy-generated WebAssembly) and send back the rendered HTML DOM objects to the browser. In this case, the edge server must execute the same code (i.e., [JavaScript](../../develop/javascript/hello_world.md) and WebAssembly) as the browser to render the UI. That is called isomorphic Jamstack applications. The WasmEdge runtime provides a lightweight, high-performance, OCI complaint, and polyglot container to run all SSR functions on edge servers.

- [React JS SSR function](../../develop/javascript/ssr.md)
- Vue JS SSR function (coming soon)
- Yew Rust compiled to WebAssembly SSR function (coming soon)
- [Percy Rust compiled to WebAssembly SSR function](../../develop/rust/ssr.md)

We also exploring ways to render more complex UI and interactions on WasmEdge-based edge servers and then stream the rendered results to the client application. Potential examples include

- Render Unity3D animations on the edge server (based on [WebAssembly rendering of Unity3D](https://docs.unity3d.com/2020.1/Documentation/Manual/webgl-gettingstarted.html))
- Render interactive video (generated from AI) on the edge server

Of course, the edge cloud could grow well beyond SSR for UI components. It could also host high-performance microservices for business logic and serverless functions. Read on to the next chapter.
","**Summary:**

This document describes the concept of Server-Side Rendering (SSR) in modern web UI development, specifically for isomorphic Jamstack applications. The goal is to improve application performance and UX by offloading workload from the client browser to edge servers. WasmEdge, a lightweight runtime, enables execution of JavaScript and WebAssembly code on edge servers to render UI components.

**Key Components:**

1. **Server-Side Rendering (SSR):** Edge servers execute ""client side"" UI code (JavaScript or WebAssembly) to render HTML DOM objects.
2. **Isomorphic Jamstack Applications:** Edge server executes same code as browser to render UI.
3. **WasmEdge Runtime:** Provides lightweight, high-performance container for running SSR functions on edge servers.

**Potential Issues/Improvement Areas:**

1. **Complex UI Rendering:** Exploring ways to render more complex UI interactions and animations on WasmEdge-based edge servers.
2. **Microservices Hosting:** Edge cloud could host high-performance microservices for business logic and serverless functions, expanding beyond SSR for UI components.

**Recommendations:**

1. Further development of Vue JS and Yew Rust compiled to WebAssembly SSR functions.
2. Exploration of more advanced use cases for WasmEdge-based edge servers.
3. Investigation into hosting high-performance microservices on the edge cloud."
i18n/zh/docusaurus-plugin-content-docs/current/start/getting-started/quick_start_redhat.md,"---
sidebar_position: 3
---

# 在 Red Hat 下的快速入门

在本指南中，我们将指导你如何在 Fedora / CentOS / Red Hat Linux / OpenShift 系统中快速运行 WasmEdge 应用程序。整个开发和运行环境由 OpenSift / Podman 管理，因此不需要额外的依赖。

<!-- prettier-ignore -->
:::note
如果你不使用 OpenShift / Podman，请[从这里开始](quick_start.md)。
:::

我们将涵盖以下示例。

- [运行独立的 WASM 应用](#运行独立的-wasm-应用)
- [运行 HTTP 服务器](#运行一个 HTTP 服务器)
- [运行基于 JavaScript 的服务器 (node.js)](#运行一个基于 JavaScript 的服务器)

## 安装

你可以使用一行 `dnf` 命令在 Fedora / CentOS / Red Hat Linux 系统上安装 WasmEdge，[crun](https://github.com/containers/crun) 和 [Podman](https://www.redhat.com/en/topics/containers/what-is-podman)。WasmEdge 运行时是 Fedora 37 和 Red Hat REPL 8、9 的[官方维护上游包](https://packages.fedoraproject.org/pkgs/wasmedge/wasmedge/index.html)。

```bash
dnf install wasmedge crun-wasm podman
```

## 运行独立的 WASM 应用程序

Hello world 示例是一个独立的 Rust 应用程序。其源代码和构建说明可在[此处](https://github.com/second-state/rust-examples/tree/main/hello)找到。

使用 Podman 运行容器化的 WASM 应用。WASM 容器镜像存储在 Docker Hub 中，其镜像大小仅为 500KB。该镜像可在 Red Hat 支持的任何 OS 和 CPU 平台上运行。

```bash
$ podman --runtime /usr/bin/crun-wasm run --platform=wasi/wasm -t --rm docker.io/secondstate/rust-example-hello:latest
Hello WasmEdge!
```

了解如何在 Rust 中创建 WASM 应用的更多信息

- [WasmEdge 的基本 Rust 示例](https://github.com/second-state/rust-examples)
- [Rust 开发人员指南](/category/develop-wasm-apps-in-rust)
  - 使用 [PyTorch](../../develop/rust/wasinn/pytorch.md)、[OpenVINO](../../develop/rust/wasinn/openvino.md) 或 [Tensorflow Lite](../../develop/rust/wasinn/tensorflow_lite.md) 后端的 WASI-NN
  - [HTTP 和 HTTPS 客户端](../../develop/rust/http_service/client.md)
  - [MySQL 数据库客户端](../../develop/rust/database/my_sql_driver.md)
  - Redis 客户端
  - Kafka 客户端

## 运行 HTTP 服务器

该示例是一个独立的用 Rust 编写的 HTTP 服务器。它演示了 Rust + WasmEdge 作为微服务的轻量级技术栈。其源代码和构建说明可在[此处](https://github.com/second-state/rust-examples/tree/main/server)找到。

使用 Podman 从 Docker Hub 拉取容器镜像（大约 800KB），然后在 WasmEdge 容器中运行它。容器作为服务器启动。请注意，我们将容器的端口 8080 映射到本地主机的端口 8080，以使服务器从 WASM 容器外部访问。

```bash
$ podman --runtime /usr/bin/crun-wasm run -dp 8080:8080 --platform=wasi/wasm -t --rm docker.io/secondstate/rust-example-server:latest
Listening on http://0.0.0.0:8080
```

从另一个终端窗口执行以下命令。

```bash
$ curl http://localhost:8080/
Try POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`

$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

了解如何在 Rust 中创建 WASM 服务的更多信息

- [Rust 开发者指南](/category/develop-wasm-apps-in-rust)
- [HTTP 应用示例](https://github.com/WasmEdge/wasmedge_hyper_demo)
- [数据库应用示例](https://github.com/WasmEdge/wasmedge-db-examples)
- Rust 和 WasmEdge 中的轻量级微服务
  - [WasmEdge + Nginx + MySQL](https://github.com/second-state/microservice-rust-mysql)
  - [WasmEdge + Kafka + MySQL](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql)
  - [Dapr + WasmEdge](https://github.com/second-state/dapr-wasm)

## 运行基于 JavaScript 的服务器

此示例是使用 Node.js API 编写的独立 HTTP 服务器，演示了 WasmEdge 作为零依赖和可移动的 Node.js 应用的轻量级运行时。其源代码可在[此处](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/docker_wasm/server)找到。

```bash
$ podman --runtime /usr/bin/crun-wasm run -dp 8080:8080 --platform=wasi/wasm -t --rm docker.io/secondstate/node-example-server:latest
... ...
```

从另一个终端窗口执行以下命令。

```bash
$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```

了解如何在 WasmEdge 中运行 JavaScript 应用的更多信息。

- [WasmEdge QuickJS 运行时](https://github.com/second-state/wasmedge-quickjs)
- [AI 推理应用示例](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo)
- [使用 fetch() 的 Web 服务客户端示例](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js)

## 下一步

- [WasmEdge 的基本 Rust 示例](https://github.com/second-state/rust-examples)
- 用你喜欢的语言编写 WASM 应用，如 [Rust](/category/develop-wasm-apps-in-rust)、[C/C++](/category/develop-wasm-apps-in-cc)、[JavaScript](/category/develop-wasm-apps-in-javascript)、[Go](/category/develop-wasm-apps-in-go) 以及其他许多语言。
","**概述**

该文档旨在指导开发者使用 WasmEdge 在 Red Hat Linux 系统上快速启动应用程序。它提供了三个示例，分别使用 Rust、HTTP 服务器和 JavaScript 运行时来展示如何部署和管理 WASM 应用。

**功能性组件**

*   **安装**:文档提供了一条 `dnf` 命令来在 Fedora/CentOS/Red Hat Linux 系统上安装 WasmEdge 和必要的依赖项。
*   **WASM 应用示例**
    *   **独立的Rust应用**：使用 Podman 从 Docker Hub 拉取容器镜像，然后在 WASM 容器中运行它。
    *   **HTTP服务器**：使用 Podman 从 Docker Hub 拉取容器镜像然后在 WasmEdge 容器中运行它，并映射本地主机的端口 8080 到容器内部的端口 8080，确保从 WASM 容器外部可以访问服务器。
    *   **基于JavaScript的服务**：使用 Podman 从 Docker Hub 拉取容器镜像然后在 WasmEdge 容器中运行它。

**潜在问题**

*   如果您不使用 OpenShift/Podman，请参考[此文档](quick_start.md)继续。
*   文档中提供的命令和操作假设用户已经安装并配置了必要的依赖项和软件包。
*   使用 WASM 应用示例可能需要修改容器镜像来适应特定应用需求。

**改进区域**

*   提供更多关于 WasmEdge 和其依赖项的信息，例如使用方法、最佳实践以及常见问题解决方案。
*   为不同的应用场景提供更具体的指导，例如 web 应用、移动应用或微服务。
*   在示例中使用更现代的容器运行时和 Docker 仓库镜像。"
docs/embed/c/reference/upgrade_to_0.13.0.md,"---
sidebar_position: 4
---

# Upgrade to WasmEdge 0.13.0

Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the `0.12.1` to the `0.13.0` version.

In this version, there are only new features. Developers can build their original source with this WasmEdge version directly.

## Concepts

1. Introduced new API for setting data and its finalizer into module instances when creation.

   Developers can use the `WasmEdge_ModuleInstanceCreateWithData()` API to set the host data and its finalizer into the module instance.

2. Asynchronously invoking WASM function by executor.

   Developers can use the `WasmEdge_ExecutorAsyncInvoke()` API to execute a WASM function asynchronously.

3. Unified WasmEdge CLI.

   Developers can use the `WasmEdge_Driver_UniTool()` API to trigger the unified WasmEdge CLI.

## Set data and its finalizer into a module instance when creation

Besides setting host data into a host function, developers can set and move ownership of host data into a `Module` instance context with its finalizer. This may be useful when implementing the plug-ins.

```c
/* Struct definition. */
typedef struct Point {
  int X;
  int Y;
} Point;

/* Host function body definition. */
WasmEdge_Result Print(void *Data,
                      const WasmEdge_CallingFrameContext *CallFrameCxt,
                      const WasmEdge_Value *In, WasmEdge_Value *Out) {
  Point *P = (Point *)In;
  printf(""Point: (%d, %d)\n"", P->X, P->Y);
  return WasmEdge_Result_Success;
}

/* Finalizer definition. */
void PointFinalizer(void *Data) {
  if (Data) {
    free((Point *)Data);
  }
}

/* Create a module instance with host data and its finalizer. */
WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");
Point *Data = (Point *)malloc(sizeof(Point));
Data->X = 5;
Data->Y = -5;
WasmEdge_ModuleInstanceContext *HostModCxt =
    WasmEdge_ModuleInstanceCreateWithData(ExportName, Data, PointFinalizer);
/*
 * When the `HostModCxt` being destroyed, the finalizer will be invoked and the
 * `Data` will be its argument.
 */
WasmEdge_StringDelete(ExportName);
```

## Unified WasmEdge CLI

The `WasmEdge_Driver_UniTool()` API presents the same function as running the [`wasmedge` tool](../../../start/build-and-run/cli.md).

```c
#include <wasmedge/wasmedge.h>
#include <stdio.h>
int main(int argc, const char *argv[]) {
  /* Run the WasmEdge unified tool. */
  /* (Within both runtime and AOT compiler) */
  return WasmEdge_Driver_UniTool(argc, argv);
}
```
","**Summary**

The provided code is a reference guide for upgrading to WasmEdge 0.13.0, which includes breaking changes in the C API. The document outlines new features and APIs introduced in version 0.13.0.

**Key Components**

1. **New API for setting data and its finalizer into module instances**: `WasmEdge_ModuleInstanceCreateWithData()` allows developers to set host data and its finalizer into a module instance.
2. **Asynchronous invocation of WASM functions using executor**: `WasmEdge_ExecutorAsyncInvoke()` enables executing WASM functions asynchronously.
3. **Unified WasmEdge CLI**: `WasmEdge_Driver_UniTool()` provides a unified command-line interface.

**Example Use Cases**

1. **Setting data and its finalizer into a module instance**: Demonstrates how to create a module instance with host data and its finalizer using `WasmEdge_ModuleInstanceCreateWithData()`.
2. **Unified WasmEdge CLI**: Shows an example of running the unified WasmEdge CLI using `WasmEdge_Driver_UniTool()`.

**Potential Issues or Areas for Improvement**

1. **Breaking changes in C API**: The introduction of new APIs and breaking changes may require significant updates to existing codebases.
2. **Complexity of asynchronous execution**: The use of asynchronous execution may introduce additional complexity, especially for developers without prior experience with async programming.
3. **Limited documentation on unified CLI**: While the example provided demonstrates the usage of `WasmEdge_Driver_UniTool()`, further documentation and examples would be beneficial to ensure a smooth transition.

Overall, the code provides a clear guide for upgrading to WasmEdge 0.13.0, with well-documented examples and API references. However, developers should carefully review the breaking changes and potential areas of complexity before adopting this version."
i18n/zh/docusaurus-plugin-content-docs/current/embed/c/reference/upgrade_to_0.13.0.md,"---
sidebar_position: 4
---

# Upgrade to WasmEdge 0.13.0

Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the `0.12.1` to the `0.13.0` version.

In this version, there are only new features. Developers can build their original source with this WasmEdge version directly.

## Concepts

1. Introduced new API for setting data and its finalizer into module instances when creation.

   Developers can use the `WasmEdge_ModuleInstanceCreateWithData()` API to set the host data and its finalizer into the module instance.

2. Asynchronously invoking WASM function by executor.

   Developers can use the `WasmEdge_ExecutorAsyncInvoke()` API to execute a WASM function asynchronously.

3. Unified WasmEdge CLI.

   Developers can use the `WasmEdge_Driver_UniTool()` API to trigger the unified WasmEdge CLI.

## Set data and its finalizer into a module instance when creation

Besides setting host data into a host function, developers can set and move ownership of host data into a `Module` instance context with its finalizer. This may be useful when implementing the plug-ins.

```c
/* Struct definition. */
typedef struct Point {
  int X;
  int Y;
} Point;

/* Host function body definition. */
WasmEdge_Result Print(void *Data,
                      const WasmEdge_CallingFrameContext *CallFrameCxt,
                      const WasmEdge_Value *In, WasmEdge_Value *Out) {
  Point *P = (Point *)In;
  printf(""Point: (%d, %d)\n"", P->X, P->Y);
  return WasmEdge_Result_Success;
}

/* Finalizer definition. */
void PointFinalizer(void *Data) {
  if (Data) {
    free((Point *)Data);
  }
}

/* Create a module instance with host data and its finalizer. */
WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");
Point *Data = (Point *)malloc(sizeof(Point));
Data->X = 5;
Data->Y = -5;
WasmEdge_ModuleInstanceContext *HostModCxt =
    WasmEdge_ModuleInstanceCreateWithData(ExportName, Data, PointFinalizer);
/*
 * When the `HostModCxt` being destroyed, the finalizer will be invoked and the
 * `Data` will be its argument.
 */
WasmEdge_StringDelete(ExportName);
```

## Unified WasmEdge CLI

The `WasmEdge_Driver_UniTool()` API presents the same function as running the [`wasmedge` tool](../../../start/build-and-run/cli.md).

```c
#include <wasmedge/wasmedge.h>
#include <stdio.h>
int main(int argc, const char *argv[]) {
  /* Run the WasmEdge unified tool. */
  /* (Within both runtime and AOT compiler) */
  return WasmEdge_Driver_UniTool(argc, argv);
}
```
","**Summary**

This is a documentation for upgrading from WasmEdge version 0.12.1 to 0.13.0, which includes new features and breaking changes in the C API. The document provides guidelines for developers on how to use the new APIs and tools.

**Key Components**

1. **Setting data and its finalizer into a module instance**: Developers can use the `WasmEdge_ModuleInstanceCreateWithData()` API to set host data and its finalizer into a module instance.
2. **Asynchronously invoking WASM functions**: Developers can use the `WasmEdge_ExecutorAsyncInvoke()` API to execute WASM functions asynchronously.
3. **Unified WasmEdge CLI**: Developers can use the `WasmEdge_Driver_UniTool()` API to trigger the unified WasmEdge CLI, which presents the same function as running the `wasmedge` tool.

**Code Examples**

1. Setting data and its finalizer into a module instance: A code example demonstrates how to set host data into a host function and move ownership of the host data into a `Module` instance context with its finalizer.
2. Unified WasmEdge CLI: An example shows how to use the `WasmEdge_Driver_UniTool()` API to run the unified WasmEdge CLI.

**Potential Issues**

1. Breaking changes in C API: The new version of WasmEdge includes breaking changes in the C API, which may require developers to update their code.
2. New APIs and tools: Developers need to familiarize themselves with the new APIs and tools provided in WasmEdge 0.13.0.

Overall, this documentation provides a clear guide for upgrading from WasmEdge version 0.12.1 to 0.13.0, including key components, code examples, and potential issues to consider."
i18n/zh/docusaurus-plugin-content-docs/current/start/wasmedge/extensions/proposals.md,"---
sidebar_position: 1
---

# WebAssembly 提案

## 标准的 WebAssembly 功能

WasmEdge 支持以下 [WebAssembly 提案](https://github.com/WebAssembly/proposals)。这些提案可能成为未来的官方 WebAssembly 规范。

| 提案 | WasmEdge CLI 标志 | WasmEdge C API 枚举 | 默认开启 | 解释器模式 | AOT 模式 |
| --- | --- | --- | --- | --- | --- |
| [可变全局变量的导入/导出][] | `--disable-import-export-mut-globals` | `WasmEdge_Proposal_ImportExportMutGlobals` | ✓（自`0.8.2`） | ✓ | ✓ |
| [非陷阱浮点数到整数转换][] | `--disable-non-trap-float-to-int` | `WasmEdge_Proposal_NonTrapFloatToIntConversions` | ✓（自`0.8.2`） | ✓ | ✓ |
| [符号扩展操作][] | `--disable-sign-extension-operators` | `WasmEdge_Proposal_SignExtensionOperators` | ✓（自`0.8.2`） | ✓ | ✓ |
| [多值返回][] | `--disable-multi-value` | `WasmEdge_Proposal_MultiValue` | ✓（自`0.8.2`） | ✓ | ✓ |
| [引用类型][] | `--disable-reference-types` | `WasmEdge_Proposal_ReferenceTypes` | ✓（自`0.8.2`） | ✓ | ✓ |
| [批量内存操作][] | `--disable-bulk-memory` | `WasmEdge_Proposal_BulkMemoryOperations` | ✓（自`0.8.2`） | ✓ | ✓ |
| [固定宽度 SIMD][] | `--disable-simd` | `WasmEdge_Proposal_SIMD` | ✓（自`0.9.0`） | ✓（自`0.8.2`） | ✓（自`0.8.2`） |
| [尾调用][] | `--enable-tail-call` | `WasmEdge_Proposal_TailCall` |  | ✓（自`0.10.0`） | ✓（自`0.10.0`） |
| [多内存][] | `--enable-multi-memory` | `WasmEdge_Proposal_MultiMemories` |  | ✓（自`0.9.1`） | ✓（自`0.9.1`） |
| [扩展常量表达式][] | `--enable-extended-const` | `WasmEdge_Proposal_ExtendedConst` |  | ✓（自`0.10.0`） | ✓（自`0.10.0`） |
| [线程][] | `--enable-threads` | `WasmEdge_Proposal_Threads` |  | ✓（自`0.10.1`） | ✓（自`0.10.1`） |

以下提案正在开发中，可能在将来得到支持：

- [组件模型][]
- [异常处理][]
- [垃圾回收][]
- [WebAssembly C 和 C++ API][]

[Import/Export of Mutable Globals]: https://github.com/WebAssembly/mutable-global
[Non-trapping float-to-int conversions]: https://github.com/WebAssembly/nontrapping-float-to-int-conversions
[Sign-extension operators]: https://github.com/WebAssembly/sign-extension-ops
[Multi-value]: https://github.com/WebAssembly/multi-value
[Reference Types]: https://github.com/WebAssembly/reference-types
[Bulk memory operations]: https://github.com/WebAssembly/bulk-memory-operations
[Fixed-width SIMD]: https://github.com/webassembly/simd
[Tail call]: https://github.com/WebAssembly/tail-call
[Multiple memories]: https://github.com/WebAssembly/multi-memory
[Extended Constant Expressions]: https://github.com/WebAssembly/extended-const
[Threads]: https://github.com/webassembly/threads
[Component Model]: https://github.com/WebAssembly/component-model
[Exception handling]: https://github.com/WebAssembly/exception-handling
[Garbage collection]: https://github.com/WebAssembly/gc
[WebAssembly C and C++ API]: https://github.com/WebAssembly/wasm-c-api

## WASI 提案

WasmEdge 实现了以下 [WASI 提案](https://github.com/WebAssembly/WASI/blob/main/Proposals.md)：

| 提案 | 平台支持 |
| --- | --- |
| [Sockets][] | `x86_64 Linux`, `aarch64 Linux` (自 `0.10.0` 起) |
| [Crypto][] | `x86_64 Linux`, `aarch64 Linux` (自 `0.10.1` 起) |
| [机器学习（wasi-nn）][] | `x86_64 Linux`, OpenVINO (自 `0.10.1` 起), PyTorch (自 `0.11.1` 起), 以及 TensorFlow-Lite (自 `0.11.2` 起) 后端 |
| [proxy-wasm][] | `x86_64 Linux（仅解释器）` (自 `0.8.2` 起) |

以下提案正在开发中，将来可能会得到支持：

- WASI-NN 的 TensorFlow 后端

[Sockets]: https://github.com/WebAssembly/wasi-sockets
[Crypto]: https://github.com/WebAssembly/wasi-crypto
[机器学习（wasi-nn）]: https://github.com/WebAssembly/wasi-nn
[proxy-wasm]: https://github.com/proxy-wasm/spec
","**Summary**

This document outlines the features and proposals supported by WasmEdge, a WebAssembly runtime. It includes information on enabled and disabled features, as well as proposals that are in development.

**Key Components**

1. **WebAssembly Proposals**: A table listing WebAssembly proposals implemented in WasmEdge, including their corresponding CLI flags, C API enumerations, and default settings.
2. **WASI (WebAssembly System Interface) Proposals**: A table listing WASI proposals implemented in WasmEdge, including their corresponding platform support.

**Functionality**

The document provides information on the following features:

* WebAssembly proposals supported by WasmEdge, including:
	+ Mutable global variables
	+ Non-trapping float-to-int conversions
	+ Sign extension operators
	+ Multi-value returns
	+ Reference types
	+ Bulk memory operations
	+ Fixed-width SIMD
	+ Tail calls
	+ Multiple memories
	+ Extended constant expressions
	+ Threads
* WASI proposals supported by WasmEdge, including:
	+ Sockets
	+ Crypto
	+ Machine learning (wasi-nn)

**Areas for Improvement**

1. **Platform Support**: The document does not provide information on platform support for all features and proposals.
2. **Development Status**: Some proposals are marked as ""in development,"" but it is unclear when they will be implemented or released.

Overall, the document provides a good overview of WasmEdge's features and supported WebAssembly proposals, but may benefit from additional details and clarity on development status."
docs/contribute/overview.md,"---
sidebar_position: 1
displayed_sidebar: contributeSidebar
---

# Contribute and Extend WasmEdge

Contribution is always welcome! The WebAssembly ecosystem is still in its early days. Hosted by CNCF, WasmEdge aims to become an open source “reference implementation” of WebAssembly and its edge-related extensions. WasmEdge is developed in the open, and is constantly being improved by our users, contributors, and maintainers. It is because of you that we can bring great software to the community.We are looking forward to working together with you!

To help new contributors understand WasmEdge development workflow, this guide will include

- [Build WasmEdge and WasmEdge plug-in from source on different platforms](/category/build-wasmedge-from-source)
- [WasmEdge Plug-in system introduction](/category/wasmedge-plugin-system)
- [Test WasmEdge](test.md)
- [WasmEdge Fuzzing](fuzzing.md)
- [WasmEdge internal explanation](internal.md)
- [WasmEdge installer system explanation](installer.md)
- [contributing steps](contribute.md)
- [WasmEdge release process](release.md)
- [Join WasmEdge community](community.md)

## Ideas for contributions

If you're looking for something to contribute, we have issues

- labeled with [`good first issue`](https://github.com/WasmEdge/WasmEdge/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22), which are recommendations for developers to contribute to WasmEdge by working on some easy tasks. These tasks will help contributors to learn the WasmEdge development workflow.

- labeled with [`help wanted`](https://github.com/WasmEdge/WasmEdge/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22), for which are we need suggestions and opinions from the community.

- [Roadmap](https://github.com/WasmEdge/WasmEdge/blob/master/docs/ROADMAP.md) for every year, which elaborates the new features in the coming days. You are also welcome to pick one.

If you find something is missing, don't hesitate to create an issue and let us know. Again, WasmEdge is open in development.

## Mentoring

WasmEdge maintainers can provide mentoring for WasmEdge, WebAssembly, C++, Rust, compiler, etc. If you are interested in fixing one open issue, just let us know by commenting under the issue. WasmEdge maintainers will reply to your question in time.

Besides the regular GitHub issues, the WasmEdge project will participate in some open source mentoring projects like [Google Summer of Code (GSoC)](https://summerofcode.withgoogle.com/), [Google Season of Docs (GSoD)](https://developers.google.com/season-of-docs), [LFX Mentorship](https://mentorship.lfx.linuxfoundation.org/#projects_all), and [Open Source Promotion Plan (OSPP)](https://summer-ospp.ac.cn/). Join our [Discord server](https://discord.gg/U4B5sFTkFc) or follow [@realwasmedge](https://twitter.com/realwasmedge) on Twitter to get alerts on the application details.
","**Summary**

This documentation serves as an overview of the WasmEdge contribution guide, outlining the steps to contribute and extend the open-source ""reference implementation"" of WebAssembly. It covers topics such as building WasmEdge from source, plugin system introduction, testing, fuzzing, internal explanation, installer system explanation, contributing steps, release process, and joining the community.

**Key Components**

1. **Contributing Steps**: A guide for new contributors to understand the development workflow.
2. **Ideas for Contributions**: Suggestions for issues to work on, labeled as ""good first issue"" or ""help wanted"".
3. **Roadmap**: An outline of new features in the coming days.
4. **Mentoring**: WasmEdge maintainers offer mentoring for contributors interested in fixing open issues.

**Potential Issues or Areas for Improvement**

1. **Complexity**: The documentation covers a wide range of topics, which may be overwhelming for new contributors.
2. **Organization**: Some sections seem disconnected; better organization and categorization could improve the flow of information.
3. **Technical Details**: Some technical aspects might benefit from additional explanations or examples to help non-experts understand the concepts.
4. **Community Engagement**: While there are suggestions for contributing, it's unclear how contributors can engage with the community beyond reporting issues.

**Recommendations**

1. **Simplify the structure**: Break down complex topics into smaller sections and provide clear headings and summaries.
2. **Add more examples and explanations**: Provide additional technical details to help non-experts understand the concepts.
3. **Emphasize community engagement**: Highlight ways contributors can interact with the community, such as participating in discussions or attending meetups.
4. **Regularly update the roadmap**: Keep the roadmap up-to-date with new features and changes in priorities."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/overview.md,"---
sidebar_position: 1
displayed_sidebar: contributeSidebar
---

# Contribute and Extend WasmEdge

Contribution is always welcome! The WebAssembly ecosystem is still in its early days. Hosted by CNCF, WasmEdge aims to become an open source “reference implementation” of WebAssembly and its edge-related extensions. WasmEdge is developed in the open, and is constantly being improved by our users, contributors, and maintainers. It is because of you that we can bring great software to the community.We are looking forward to working together with you!

To help new contributors understand WasmEdge development workflow, this guide will include

- [Build WasmEdge and WasmEdge plug-in from source on different platforms](/category/build-wasmedge-from-source)
- [WasmEdge Plug-in system introduction](/category/wasmedge-plugin-system)
- [Test WasmEdge](test.md)
- [WasmEdge Fuzzing](fuzzing.md)
- [WasmEdge internal explanation](internal.md)
- [WasmEdge installer system explanation](installer.md)
- [contributing steps](contribute.md)
- [WasmEdge release process](release.md)
- [Join WasmEdge community](community.md)

## Ideas for contributions

If you're looking for something to contribute, we have issues

- labeled with [`good first issue`](https://github.com/WasmEdge/WasmEdge/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22), which are recommendations for developers to contribute to WasmEdge by working on some easy tasks. These tasks will help contributors to learn the WasmEdge development workflow.

- labeled with [`help wanted`](https://github.com/WasmEdge/WasmEdge/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22), for which are we need suggestions and opinions from the community.

- [Roadmap](https://github.com/WasmEdge/WasmEdge/blob/master/docs/ROADMAP.md) for every year, which elaborates the new features in the coming days. You are also welcome to pick one.

If you find something is missing, don't hesitate to create an issue and let us know. Again, WasmEdge is open in development.

## Mentoring

WasmEdge maintainers can provide mentoring for WasmEdge, WebAssembly, C++, Rust, compiler, etc. If you are interested in fixing one open issue, just let us know by commenting under the issue. WasmEdge maintainers will reply to your question in time.

Besides the regular GitHub issues, the WasmEdge project will participate in some open source mentoring projects like [Google Summer of Code (GSoC)](https://summerofcode.withgoogle.com/), [Google Season of Docs (GSoD)](https://developers.google.com/season-of-docs), [LFX Mentorship](https://mentorship.lfx.linuxfoundation.org/#projects_all), and [Open Source Promotion Plan (OSPP)](https://summer-ospp.ac.cn/). Join our [Discord server](https://discord.gg/U4B5sFTkFc) or follow [@realwasmedge](https://twitter.com/realwasmedge) on Twitter to get alerts on the application details.
","**Summary**

This markdown file is part of the Docusaurus plugin for WasmEdge, a WebAssembly runtime developed by CNCF. It serves as an overview guide for contributing to and extending WasmEdge. The document provides information on how to get started with contributing, including building from source, understanding the development workflow, and participating in various projects. It also highlights potential areas for contributions and introduces mentoring opportunities.

**Key Components**

1. **Guidance for new contributors**: The document includes a list of resources to help new contributors understand WasmEdge's development workflow.
2. **Ideas for contributions**: A section listing issues labeled with `good first issue` or `help wanted`, which are suitable for beginners or require community input.
3. **Mentoring opportunities**: WasmEdge maintainers can provide guidance on specific areas, such as WebAssembly, C++, Rust, and compiler development.

**Potential Issues/Improvements**

1. **Organization**: The document is well-structured, but it might be beneficial to add more visual organization (e.g., headings, sections) to facilitate navigation.
2. **Link management**: Some links are internal, while others are external; a consistent approach would make the content more accessible and easier to maintain.
3. **Versioning**: The document mentions specific versions of resources (e.g., GitHub issues, ROADMAP); consider adding version information to avoid potential inconsistencies.
4. **Community engagement**: While there's an invitation to join the WasmEdge community, it might be beneficial to include more explicit calls-to-action or direct links to engage with the project.

**Overall Assessment**

The provided markdown file is well-written and effectively communicates its purpose. With minor adjustments and improvements, this guide can serve as a valuable resource for new contributors and potential collaborators in the WasmEdge ecosystem."
i18n/zh/docusaurus-plugin-content-docs/current/start/wasmedge/extensions/plugins.md,"---
sidebar_position: 2
---

# WasmEdge 插件

对于那些过于重而难以编译成 WebAssembly的工作负载，将它们构建成本机主机函数是更好的选择。为了满足 WebAssembly 运行时的可移植性，WasmEdge 引入了插件机制，使主机函数可以加载和传输。

WasmEdge 的插件机制是一种扩展主机模块的简便方法，用户可以通过插件从由 WasmEdge 官方发布或其他开发人员发布的共享库中加载和实例化主机函数。

## 官方插件

下面列出了 WasmEdge 官方发布的插件。用户可以通过安装程序轻松安装它们。

| 插件 | 描述 | 平台支持 | 语言支持 |
| --- | --- | --- | --- |
| [WasmEdge-Process](../../../contribute/source/plugin/process.md) | 允许 WebAssembly 程序在主机操作系统中执行本机命令。它支持传递参数、环境变量、`STDIN`/`STDOUT` 管道以及主机访问的安全策略。 | `manylinux2014 x86_64`，`manylinux2014 aarch64` 和 `ubuntu 20.04 x86_64`（自`0.10.0`） | [Rust](https://crates.io/crates/wasmedge_process_interface) |
| [WASI-Crypto](https://github.com/WebAssembly/wasi-crypto) | 用于运行时向 WebAssembly 模块公开的 API，以执行加密操作和密钥管理。 | `manylinux2014 x86_64`，`manylinux2014 aarch64` 和 `ubuntu 20.04 x86_64`（自`0.10.1`） | [Rust](https://crates.io/crates/wasi-crypto) |
| [WASI-NN](https://github.com/WebAssembly/wasi-nn)[（OpenVINO 后端）](../../../develop/rust/wasinn/openvino.md) | 使用 OpenVINO 模型进行 AI 推理。 | `ubuntu 20.04 x86_64`（自`0.10.1`） | [Rust](https://crates.io/crates/wasi-nn)，JavaScript |
| [WASI-NN](https://github.com/WebAssembly/wasi-nn)[（Pytorch 后端）](../../../develop/rust/wasinn/pytorch.md)   | 使用 Pytorch 模型进行 AI 推理。 | `manylinux2014 x86_64` 和 `ubuntu 20.04 x86_64`（自`0.11.1`） | [Rust](https://crates.io/crates/wasi-nn)，JavaScript |
| [WASI-NN](https://github.com/WebAssembly/wasi-nn)[（TensorFlow-Lite 后端）](../../../develop/rust/wasinn/tensorflow_lite.md)  | 使用 TensorFlow-Lite 模型进行 AI 推理。 | `manylinux2014 x86_64`，`manylinux2014 aarch64` 和 `ubuntu 20.04 x86_64`（自`0.11.2`） | [Rust](https://crates.io/crates/wasi-nn)，JavaScript |
| [WasmEdge-Image](../../../contribute/source/plugin/image.md) | 用于 AI 推理任务中处理图像的本机库。 | `manylinux2014 x86_64`，`manylinux2014 aarch64`，`ubuntu 20.04 x86_64`，`darwin x86_64` 和 `darwin arm64`（自`0.13.0`） | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface)（0.3.0） |
| [WasmEdge-Tensorflow](../../../contribute/source/plugin/tensorflow.md) | 用于推理 TensorFlow 模型的本机库。 | `manylinux2014 x86_64`，`manylinux2014 aarch64`，`ubuntu 20.04 x86_64`，`darwin x86_64` 和 `darwin arm64`（自`0.13.0`） | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface)（0.3.0） |
| [WasmEdge-TensorflowLite](../../../contribute/source/plugin/tensorflowlite.md)  | 用于推理 TensorFlow-Lite 模型的本机库。 | `manylinux2014 x86_64`，`manylinux2014 aarch64`，`ubuntu 20.04 x86_64`，`darwin x86_64` 和 `darwin arm64`（自`0.13.0`） | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface) |
| WasmEdge-OpenCV  | 一个非常流行的常用于处理图像和视频以供 AI 输入/输出函数库。      | 未发布                                       | Rust |
| WasmEdge-eBPF    | 一个用于进行 eBPF 应用推理的原生库                           | `manylinux2014 x86_64`, `manylinux2014 aarch64`, `ubuntu 20.04 x86_64`, `darwin x86_64`, and `darwin arm64` (since `0.13.0`) | Rust                                                                   |
| WasmEdge-rustls | 一个用于进行 Rust 和 TLS 推理的原生库                        | `manylinux2014 x86_64`, `manylinux2014 aarch64`, `ubuntu 20.04 x86_64`, `darwin x86_64`, and `darwin arm64` (since `0.13.0`) | [Rust](https://crates.io/crates/wasmedge_rustls_api)                   |

## （过去的）WasmEdge 拓展

除了插件，WasmEdge 在 `0.13.0` 版本之前还提供了扩展功能。请注意，在 `0.13.0` 版本之后，这些扩展已经被相应的插件所取代。

支持这些扩展的最新版本是 `0.12.1`。当 WasmEdge 安装程序不再支持安装 `0.12.x` 版本时，本段将被废弃。

| 扩展 | 描述 | 平台支持 | 语言支持 |
| --- | --- | --- | --- |
| [图像处理](https://github.com/second-state/WasmEdge-image) | 用于处理人工智能推推理任务中的图像的本地库。在 WasmEdge `0.13.0` 版本后迁移到插件中。 | `manylinux2014 x86_64`，`manylinux2014 aarch64`，`android aarch64`，`ubuntu 20.04 x86_64` 和 `darwin x86_64` | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface) (0.2.2) |
| [TensorFlow 和 Tensorflow-Lite](https://github.com/second-state/WasmEdge-tensorflow) | 用于 TensorFlow 和 TensorFlow-Lite 模型推理的本地库。在 WasmEdge `0.13.0` 版本后迁移到插件中。 | `manylinux2014 x86_64`，`manylinux2014 aarch64`（仅限TensorFlow-Lite），`android aarch64`（仅限TensorFlow-Lite），`ubuntu 20.04 x86_64` 和 `darwin x86_64` | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface) (0.2.2) |
","**Summary**

This document describes the WasmEdge plugin system, which allows users to load and instantiate host functions from shared libraries published by WasmEdge or other developers. The plugins enable webAssembly runtime portability and are a convenient method for extending the host module.

**Key Components**

1. **Official Plugins**: These are plugins officially released by WasmEdge, listed in a table format with their description, platform support, and language support.
2. **Legacy Extensions**: These are extensions that were provided by WasmEdge before version 0.13.0, which have been replaced by corresponding plugins.

**Functionality**

The plugins enable users to:

* Execute native commands from webAssembly programs
* Perform encryption operations and key management using WASI-Crypto
* Use OpenVINO, PyTorch, or TensorFlow-Lite models for AI inference
* Process images for AI inference tasks
* Use TensorFlow, TensorFlow-Lite, or other libraries for machine learning

**Potential Issues**

1. **Legacy Extensions**: The legacy extensions are deprecated and will be removed in future versions of WasmEdge.
2. **Plugin Compatibility**: Some plugins may not be compatible with all platforms or languages, so users should check the compatibility before using a plugin.

Overall, the WasmEdge plugin system provides a convenient method for extending the host module and enables webAssembly runtime portability."
docs/develop/rust/database/redis_driver.md,"---
sidebar_position: 3
---

# Redis driver

WasmEdge provides a Redis driver for Rust developers, enabling developers to build database applications in Rust and then running in WasmEdge.

<!-- prettier-ignore -->
:::note
Before we start, [you need to have Rust and WasmEdge installed](../setup.md).
Make sure that you read the [special notes on networking apps](../setup#special-notes-for-networking-apps) especially if you are compiling Rust programs on a Mac.
:::

## Run the example

The [wasmedge-db-example/redis](https://github.com/WasmEdge/wasmedge-db-examples/tree/main/redis) is a Redis connector example written in Rust.

```bash
git clone https://github.com/WasmEdge/wasmedge-db-examples
cd wasmedge-db-examples/redis

# Compile the rust code into WASM
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release

# Execute Redis command against a Redis instance at redis://localhost/
wasmedge --env ""REDIS_URL=redis://localhost/"" target/wasm32-wasi/release/wasmedge-redis-client-examples.wasm
```

## Configuration

In order to compile the `redis` and `tokio` crates, we will need to apply patches to add WasmEdge-specific socket APIs to those crates in `Cargo.toml`.

```rust
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }

[dependencies]
anyhow = ""1.0""
chrono = { version = ""0.4"", features = [""serde""] }
tokio = { version = ""1"", features = [""full""] }
redis = { version = ""0.25.4"", default-features = false, features = [
    ""tokio-comp"",
] }
```

## Code explanation

The following program uses the `redis` crate to access a Redis server through its connection URL.
It gets the current time, saves the timestamp object to the Redis server, and then reads it back for
display on the console.

```rust
#[tokio::main(flavor = ""current_thread"")]
async fn main() -> Result<()> {
    // connect to redis
    let client = redis::Client::open(&*get_url()).unwrap();
    let mut con = client.get_multiplexed_async_connection().await.unwrap();

    let time = format!(""{}"", chrono::Utc::now());
    // throw away the result, just make sure it does not fail
    let _: () = con.set(""current_time"", time).await.unwrap();

    // read back the key and return it.  Because the return value
    // from the function is a result for String, this will automatically
    // convert into one.
    let value: String = con.get(""current_time"").await.unwrap();
    println!(""Successfully GET `time`: {}"", value);

    Ok(())
}
```

","**Summary**

The provided code is a Redis driver example written in Rust, designed to be executed within the WasmEdge environment. It utilizes the `redis` crate to interact with a Redis server and performs basic operations such as setting and getting values from the server.

**Key Components**

1. **Redis Connection**: The code establishes a connection to a Redis server using the `Client::open` method.
2. **Setting Values**: It uses the `set` method to store a timestamp value in the Redis server under the key ""current_time"".
3. **Getting Values**: The code retrieves the stored value from the Redis server using the `get` method and prints it to the console.

**Potential Issues or Areas for Improvement**

1. **Error Handling**: While the code uses `unwrap()` to handle potential errors, this is generally discouraged in production code. Consider using proper error handling techniques such as `Result` and `Error` types.
2. **Code Organization**: The example mixes Redis-specific operations with general-purpose Rust programming concepts (e.g., string formatting). Consider separating these concerns into different modules or functions for better modularity.
3. **Dependency Management**: As mentioned in the code, certain dependencies need to be patched to work with WasmEdge. This could lead to maintenance and compatibility issues over time."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/redis_driver.md,"---
sidebar_position: 3
---

# Redis driver

WasmEdge provides a Redis driver for Rust developers, enabling developers to build database applications in Rust and then running in WasmEdge.

<!-- prettier-ignore -->
:::note
Before we start, [you need to have Rust and WasmEdge installed](../setup.md).
Make sure that you read the [special notes on networking apps](../setup#special-notes) especially if you are compiling Rust programs on a Mac.
:::

## Run the example

The [wasmedge-db-example/redis](https://github.com/WasmEdge/wasmedge-db-examples/tree/main/redis) is a Redis connector example written in Rust.

```bash
git clone https://github.com/WasmEdge/wasmedge-db-examples
cd wasmedge-db-examples/redis

# Compile the rust code into WASM
RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release

# Execute Redis command against a Redis instance at redis://localhost/
wasmedge --env ""REDIS_URL=redis://localhost/"" target/wasm32-wasi/release/wasmedge-redis-client-examples.wasm
```

## Configuration

In order to compile the `redis` and `tokio` crates, we will need to apply patches to add WasmEdge-specific socket APIs to those crates in `Cargo.toml`.

```rust
[patch.crates-io]
tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }

[dependencies]
anyhow = ""1.0""
chrono = { version = ""0.4"", features = [""serde""] }
tokio = { version = ""1"", features = [""full""] }
redis = { version = ""0.25.4"", default-features = false, features = [
    ""tokio-comp"",
] }
```

## Code explanation

The following program uses the `redis` crate to access a Redis server through its connection URL.
It gets the current time, saves the timestamp object to the Redis server, and then reads it back for
display on the console.

```rust
#[tokio::main(flavor = ""current_thread"")]
async fn main() -> Result<()> {
    // connect to redis
    let client = redis::Client::open(&*get_url()).unwrap();
    let mut con = client.get_multiplexed_async_connection().await.unwrap();

    let time = format!(""{}"", chrono::Utc::now());
    // throw away the result, just make sure it does not fail
    let _: () = con.set(""current_time"", time).await.unwrap();

    // read back the key and return it.  Because the return value
    // from the function is a result for String, this will automatically
    // convert into one.
    let value: String = con.get(""current_time"").await.unwrap();
    println!(""Successfully GET `time`: {}"", value);

    Ok(())
}
```

","**Summary**

This code is a Redis driver for Rust developers, enabling them to build database applications in Rust and then run it on WasmEdge. The provided example demonstrates how to compile a Rust program that interacts with a Redis instance using the `redis` crate.

**Key Components**

1. **Redis Driver**: A Redis driver is a library or module that allows Rust programs to interact with a Redis instance.
2. **WasmEdge**: WasmEdge is an execution environment for WebAssembly (WASM) modules, allowing Rust code to run on different platforms.
3. **Rust Code Example**: The provided example is a simple Rust program that connects to a Redis instance, sets a key-value pair, and then reads the value back.

**Potential Issues**

1. **Networking Requirements**: The code requires the `redis` crate and WasmEdge installed on the system, as well as the ability to compile Rust programs.
2. **Special Notes for Networking Apps**: If compiling Rust programs on a Mac, special notes regarding networking applications should be followed.
3. **Patched Crates**: To compile the `redis` and `tokio` crates, patches need to be applied to add WasmEdge-specific socket APIs.

**Areas for Improvement**

1. **Error Handling**: The code does not handle errors robustly; in a production environment, error handling mechanisms should be implemented.
2. **Code Optimization**: The provided example is a simple demonstration of how to use the `redis` crate with WasmEdge. Optimizing the code for performance and readability would make it more suitable for a production environment.
3. **Documentation**: While the documentation provided is helpful, additional explanations or examples might be necessary to fully understand how to use the Redis driver with WasmEdge."
docs/contribute/source/os/riscv64.md,"---
sidebar_position: 6
---

# Build on RISC-V 64

## Prepare the Environment

This tutorial is based on Ubuntu 22.04 host, and WasmEdge uses the [RISCV-Lab](https://gitee.com/tinylab/riscv-lab), which provides Ubuntu 22.04 system with riscv64 architecture. Here users can use their riscv64 environment.

### Install and run RISCV-Lab

```bash
git clone https://gitee.com/tinylab/cloud-lab.git
cd cloud-lab
LOGIN=bash tools/docker/run riscv-lab
```

Note that it will take a long time to pull the image here.

## Build WasmEdge

### Get Source code

```bash
ubuntu@riscv-lab:/labs/riscv-lab$ git clone https://github.com/WasmEdge/WasmEdge.git
ubuntu@riscv-lab:/labs/riscv-lab$ cd WasmEdge
```

### Dependencies

WasmEdge requires LLVM 12 at least and you may need to install the following dependencies yourself.

```bash
ubuntu@riscv-lab:/labs/riscv-lab$ sudo apt-get update
ubuntu@riscv-lab:/labs/riscv-lab$ sudo apt install -y software-properties-common cmake
ubuntu@riscv-lab:/labs/riscv-lab$ sudo apt install -y llvm-12-dev liblld-12-dev
```

### Compile

Please refer to [here](../build_from_src.md#cmake-building-options) for the descriptions of all CMake options.

```bash
ubuntu@riscv-lab:/labs/riscv-lab$ cd WasmEdge
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge$ mkdir -p build && cd build
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ cmake -DCMAKE_BUILD_TYPE=Release .. && make -j
```

## Test

### Execute the wasmedge tool

For the pure WebAssembly, the `wasmedge` CLI tool will execute it in interpreter mode.

```bash
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ sudo make install
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ cd ../examples/wasm
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge -v
wasmedge version 0.12.0-alpha.1-13-g610cc21f
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge --reactor fibonacci.wasm fib 10
89
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge --reactor add.wasm add 2 2
4
```

### Execute wasmedge compile

To improve the performance, the `wasmedge compile` can compile WebAssembly into native machine code. After compiling with the `wasmedge compile` AOT compiler, the wasmedge tool can execute the WASM in AOT mode, which is much faster.

```bash
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge compile fibonacci.wasm fibonacci_aot.wasm
[2023-02-01 22:39:15.807] [info] compile start
[2023-02-01 22:39:15.857] [info] verify start
[2023-02-01 22:39:15.866] [info] optimize start
[2023-02-01 22:39:16.188] [info] codegen start
[2023-02-01 22:39:16.403] [info] output start
[2023-02-01 22:39:16.559] [info] compile done
[2023-02-01 22:39:16.565] [info] output start
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ time wasmedge --reactor fibonacci_aot.wasm fib 30
1346269
real    0m0.284s
user    0m0.282s
sys     0m0.005s
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ time wasmedge --reactor fibonacci.wasm fib 30
1346269
real    0m1.814s
user    0m1.776s
sys     0m0.016s
```
","**Summary**

This document provides instructions on how to build and run WasmEdge, a WebAssembly runtime, on RISC-V 64 architecture. The process involves:

1. Preparing the environment using RISCV-Lab
2. Cloning the WasmEdge repository
3. Installing dependencies (LLVM 12, CMake)
4. Building WasmEdge using CMake and Make
5. Testing the built binary

**Key Components**

* RISCV-Lab: A Ubuntu 22.04 system with riscv64 architecture provided by Gitee.
* WasmEdge: A WebAssembly runtime.
* LLVM 12: A compiler infrastructure for building and optimizing WasmEdge.
* CMake: A build system generator.
* Make: A build automation tool.

**Potential Issues or Areas for Improvement**

1. **Slow build process**: The build process involves cloning the repository, installing dependencies, and building WasmEdge. This can take a significant amount of time.
2. **Lack of detailed instructions**: Some steps are not explicitly mentioned, such as how to configure CMake options.
3. **Inadequate error handling**: If errors occur during the build or run process, they may be difficult to diagnose.
4. **Missing documentation on dependencies**: The document assumes familiarity with LLVM and CMake, but does not provide detailed information on these dependencies.

**Suggestions for Improvement**

1. Provide more detailed instructions for each step, including any specific configurations required.
2. Consider using a build tool like `bazel` or `meson` which can automate the build process and reduce the risk of errors.
3. Add error handling mechanisms to ensure that errors are caught and reported in a useful way.
4. Provide additional documentation on dependencies, such as LLVM and CMake, to help users understand their role in building WasmEdge.
5. Consider providing pre-built binaries for different platforms to simplify the build process."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/riscv64.md,"---
sidebar_position: 6
---

# Build on RISC-V 64

## Prepare the Environment

This tutorial is based on Ubuntu 22.04 host, and WasmEdge uses the [RISCV-Lab](https://gitee.com/tinylab/riscv-lab), which provides Ubuntu 22.04 system with riscv64 architecture. Here users can use their riscv64 environment.

### Install and run RISCV-Lab

```bash
git clone https://gitee.com/tinylab/cloud-lab.git
cd cloud-lab
LOGIN=bash tools/docker/run riscv-lab
```

Note that it will take a long time to pull the image here.

## Build WasmEdge

### Get Source code

```bash
ubuntu@riscv-lab:/labs/riscv-lab$ git clone https://github.com/WasmEdge/WasmEdge.git
ubuntu@riscv-lab:/labs/riscv-lab$ cd WasmEdge
```

### Dependencies

WasmEdge requires LLVM 12 at least and you may need to install the following dependencies yourself.

```bash
ubuntu@riscv-lab:/labs/riscv-lab$ sudo apt-get update
ubuntu@riscv-lab:/labs/riscv-lab$ sudo apt install -y software-properties-common cmake
ubuntu@riscv-lab:/labs/riscv-lab$ sudo apt install -y llvm-12-dev liblld-12-dev
```

### Compile

Please refer to [here](../build_from_src.md#cmake-building-options) for the descriptions of all CMake options.

```bash
ubuntu@riscv-lab:/labs/riscv-lab$ cd WasmEdge
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge$ mkdir -p build && cd build
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ cmake -DCMAKE_BUILD_TYPE=Release .. && make -j
```

## Test

### Execute the wasmedge tool

For the pure WebAssembly, the `wasmedge` CLI tool will execute it in interpreter mode.

```bash
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ sudo make install
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ cd ../examples/wasm
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge -v
wasmedge version 0.12.0-alpha.1-13-g610cc21f
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge --reactor fibonacci.wasm fib 10
89
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge --reactor add.wasm add 2 2
4
```

### Execute wasmedge compile

To improve the performance, the `wasmedge compile` can compile WebAssembly into native machine code. After compiling with the `wasmedge compile` AOT compiler, the wasmedge tool can execute the WASM in AOT mode, which is much faster.

```bash
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge compile fibonacci.wasm fibonacci_aot.wasm
[2023-02-01 22:39:15.807] [info] compile start
[2023-02-01 22:39:15.857] [info] verify start
[2023-02-01 22:39:15.866] [info] optimize start
[2023-02-01 22:39:16.188] [info] codegen start
[2023-02-01 22:39:16.403] [info] output start
[2023-02-01 22:39:16.559] [info] compile done
[2023-02-01 22:39:16.565] [info] output start
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ time wasmedge --reactor fibonacci_aot.wasm fib 30
1346269
real    0m0.284s
user    0m0.282s
sys     0m0.005s
ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ time wasmedge --reactor fibonacci.wasm fib 30
1346269
real    0m1.814s
user    0m1.776s
sys     0m0.016s
```
","**Summary**

The provided code is a tutorial on how to build and run WasmEdge, a WebAssembly runtime engine, on a RISC-V 64 architecture. The tutorial assumes an Ubuntu 22.04 host environment and uses the RISCV-Lab system, which provides a pre-configured Ubuntu 22.04 system with riscv64 architecture.

**Key Components**

1. **Preparation**: The tutorial starts by cloning the WasmEdge repository and preparing the build environment.
2. **Build WasmEdge**: The user is instructed to install dependencies (LLVM 12, CMake) and compile WasmEdge using CMake.
3. **Test**: The tutorial provides examples on how to execute WebAssembly programs with the `wasmedge` CLI tool in interpreter mode and AOT (Ahead-of-Time) compilation mode.

**Potential Issues**

1. **Time-consuming build process**: The compilation process can take a long time, especially for large projects like WasmEdge.
2. **Dependency management**: The tutorial assumes that users have already installed LLVM 12, CMake, and other dependencies. In practice, managing dependencies can be challenging, and users may encounter issues if these dependencies are not installed correctly.
3. **CMake build options**: The tutorial mentions CMake build options but does not provide detailed explanations or examples. This might make it difficult for users to customize the build process.

**Areas for Improvement**

1. **Provide more detailed instructions**: The tutorial could benefit from more detailed instructions, especially when it comes to installing dependencies and managing them.
2. **Improve documentation**: The CMake build options section should include explanations of each option and examples of how to use them.
3. **Test cases**: Adding more test cases to verify the correctness of the built WasmEdge runtime engine would help ensure that users can rely on the instructions provided.

**Additional Recommendations**

1. **Consider using a Docker image**: Using a pre-configured Docker image for building WasmEdge could simplify the build process and reduce dependencies.
2. **Provide troubleshooting guides**: A dedicated section on troubleshooting common issues, such as dependency conflicts or build errors, would be helpful in case users encounter problems during the build process."
docs/contribute/source/plugin/rusttls.md,"---
sidebar_position: 8
---

# (DEPRECATED after `0.14.0`) Build with Rustls Plug-in

<!-- prettier-ignore -->
:::note
This plug-in has been deprecated after WasmEdge `0.14.0` because the `rustls` is replaced by [`reqwest`](../../../develop/rust/http_service/client.md#the-reqwest-api).
:::

The WasmEdge Rustls plug-in is a replacement for the OpenSSL plug-in in WasmEdge. It provides a Rust-friendly interface to the Rustls library, which is a modern, fast, and more secure alternative to OpenSSL.

Here's a step-by-step guide on how to build the WasmEdge Rustls plug-in:

## Prerequisites

Ensure the following dependencies are installed on your system:

- Rust: You can install it from the [official website](https://www.rust-lang.org/tools/install).
- CMake: Minimum version 3.12. Install it from the [official website](https://cmake.org/download/).

## Clone the WasmEdge Repository

First, clone the WasmEdge repository from GitHub:

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
```

## Navigate to the Rustls Plug-in Directory

Navigate to the `wasmedge_rustls` directory within the cloned repository:

```bash
cd WasmEdge/plugins/wasmedge_rustls
```

## Build the Plug-in

Now you can build the Rustls plug-in. Run the following command:

```bash
cargo build --release
```

This command builds the plug-in in release mode. The compiled binary will be located in the `target/release` directory.

## Install the Plug-in

To install the plug-in, you can use the `cargo install` command:

```bash
cargo install --path .
```

This command will install the built plug-in into your Rust binary directory.

## Usage

To use the plug-in with WasmEdge, you need to specify it when starting the WasmEdge runtime:

```bash
wasmedge --dir .:. --reactor --rustls_plugin target/release/libwasmedge_rustls.so your_wasm_file.wasm
```

Replace `your_wasm_file.wasm` with the path to your WebAssembly file. The `--rustls_plugin` flag specifies the path to the Rustls plug-in.

That's it! You have successfully built and installed the WasmEdge Rustls plug-in. Please ensure to replace the OpenSSL plug-in with the Rustls plug-in in your WasmEdge runtime configuration if you were previously using OpenSSL.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_rustls).
","**Summary**

The provided code is a guide on how to build and install the WasmEdge Rustls plug-in, which provides a modern and secure alternative to OpenSSL for use with the WasmEdge runtime. The plug-in has been deprecated after version 0.14.0 of WasmEdge in favor of the reqwest library.

**Key Components**

1. **Prerequisites**: The guide requires the installation of Rust and CMake on the system.
2. **Cloning the WasmEdge Repository**: The user is instructed to clone the WasmEdge repository from GitHub.
3. **Navigating to the Rustls Plug-in Directory**: The user navigates to the `wasmedge_rustls` directory within the cloned repository.
4. **Building the Plug-in**: The user builds the plug-in using the `cargo build --release` command.
5. **Installing the Plug-in**: The user installs the built plug-in using the `cargo install --path .` command.
6. **Usage**: The user specifies the Rustls plug-in when starting the WasmEdge runtime.

**Potential Issues or Areas for Improvement**

1. **Deprecation Warning**: The guide should be updated to reflect that the Rustls plug-in has been deprecated after version 0.14.0 of WasmEdge.
2. **Outdated Instructions**: Some steps in the guide may be outdated, and it's recommended to update them to match the current version of WasmEdge.
3. **Lack of Error Handling**: The guide does not provide instructions on how to handle errors that may occur during the build or installation process.
4. **Missing Information on reqwest Library**: Since reqwest has replaced Rustls, additional information should be provided on how to use the reqwest library with WasmEdge runtime.

**Code Quality**

The provided code is a guide and not actual code. However, if we were to translate this guide into a set of instructions, here are some suggestions:

1. **Use clear and concise language**: Avoid using technical jargon or overly complex sentences that may confuse the user.
2. **Provide step-by-step instructions**: Break down each step into smaller, manageable tasks that users can follow easily.
3. **Use proper formatting**: Use headings, bullet points, and whitespace to make the guide easy to read and understand.
4. **Include error handling and troubleshooting tips**: Provide users with guidance on how to handle errors or troubleshoot common issues."
docs/contribute/source/docker.md,"---
sidebar_position: 2
---

# Docker Images for Building WasmEdge

WasmEdge supports a wide range of Linux distributions dated back to 2014. The official release contains statically linked binaries and libraries for older Linux systems.

The table below shows build targets in WasmEdge's official release packages.

Developers can use the `docker pull wasmedge/wasmedge:{tag_name}` command to pull the docker image for WasmEdge building.

| tag name | arch | based operating system | LLVM version | ENVs | compatibility | comments |
| --- | --- | --- | --- | --- | --- | --- |
| `latest` | x86_64 | Ubuntu 22.04 LTS | 15.0.7 | CC=clang, CXX=clang++ | Ubuntu 22.04+ | This is for CI, will always use the latest Ubuntu LTS release |
| `ubuntu-build-gcc` | x86_64 | Ubuntu 22.04 LTS | 15.0.7 | CC=gcc, CXX=g++ | Ubuntu 22.04+ | This is for CI, will always use the latest Ubuntu LTS release |
| `ubuntu-build-clang` | x86_64 | Ubuntu 22.04 LTS | 15.0.7 | CC=clang, CXX=clang++ | Ubuntu 22.04+ | This is for CI, will always use the latest Ubuntu LTS release |
| `ubuntu2004_x86_64` | x86_64 | Ubuntu 20.04 LTS | 10.0.0 | CC=gcc, CXX=g++ | Ubuntu 20.04+ | This is for developers who familiar with Ubuntu 20.04 LTS release |
| `ubuntu2104_armv7l` | armhf | Ubuntu 21.04 | 12.0.0 | CC=gcc, CXX=g++ | Ubuntu 21.04+ | This is for armhf release |
| `manylinux2014_x86_64` | x86_64 | CentOS 7, 7.9.2009 | 16.0.5 | CC=gcc, CXX=g++ | Ubuntu 16.04+, CentOS 7+ | This is for developers who familiar with CentOS on x86_64 architecture |
| `manylinux2014_aarch64` | aarch64 | CentOS 7, 7.9.2009 | 16.0.5 | CC=gcc, CXX=g++ | Ubuntu 16.04+, CentOS 7+ | This is for developers who familiar with CentOS on aarch64 architecture |
","**Summary**

The provided code snippet is from a Markdown file named `docker.md` located in the `docs/contribute/source` directory. It describes Docker images for building WasmEdge, a WebAssembly runtime engine. The document outlines various Docker tags that can be used to pull and build WasmEdge images with different configurations.

**Purpose**

The purpose of this code is to provide developers with a list of available Docker images for building WasmEdge, along with their respective characteristics such as architecture, based operating system, LLVM version, environment variables, compatibility, and comments.

**Key Components**

1. **Docker Tags**: The table lists various Docker tags that can be used to pull the corresponding WasmEdge images.
2. **Architectures**: Each tag specifies a specific architecture (e.g., x86_64, armhf, aarch64).
3. **Based Operating Systems**: The table shows the base operating system for each image (e.g., Ubuntu 22.04 LTS, CentOS 7).
4. **LLVM Versions**: Each image has an associated LLVM version.
5. **Environment Variables**: Some images specify environment variables (e.g., `CC=clang`, `CXX=clang++`).
6. **Compatibility**: The table indicates the minimum compatible operating system versions for each image.

**Potential Issues or Areas for Improvement**

1. **Readability**: The table layout and formatting could be improved for better readability.
2. **Consistency**: The formatting of comments in the last two rows of the table seems inconsistent with the rest of the table.
3. **Error Handling**: It is unclear how developers should handle errors when pulling or building images using these tags.
4. **Documentation**: Additional documentation on each tag's specific requirements and configurations could be beneficial.

Overall, this code snippet provides a useful reference for developers interested in building WasmEdge with specific configurations. However, it could benefit from some improvements to enhance readability and usability."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/docker.md,"---
sidebar_position: 2
---

# Docker Images for Building WasmEdge

WasmEdge supports a wide range of Linux distributions dated back to 2014. The official release contains statically linked binaries and libraries for older Linux systems.

The table below shows build targets in WasmEdge's official release packages.

Developers can use the `docker pull wasmedge/wasmedge:{tag_name}` command to pull the docker image for WasmEdge building.

| tag name | arch | based operating system | LLVM version | ENVs | compatibility | comments |
| --- | --- | --- | --- | --- | --- | --- |
| `latest` | x86_64 | Ubuntu 22.04 LTS | 15.0.7 | CC=clang, CXX=clang++ | Ubuntu 22.04+ | This is for CI, will always use the latest Ubuntu LTS release |
| `ubuntu-build-gcc` | x86_64 | Ubuntu 22.04 LTS | 15.0.7 | CC=gcc, CXX=g++ | Ubuntu 22.04+ | This is for CI, will always use the latest Ubuntu LTS release |
| `ubuntu-build-clang` | x86_64 | Ubuntu 22.04 LTS | 15.0.7 | CC=clang, CXX=clang++ | Ubuntu 22.04+ | This is for CI, will always use the latest Ubuntu LTS release |
| `ubuntu2004_x86_64` | x86_64 | Ubuntu 20.04 LTS | 10.0.0 | CC=gcc, CXX=g++ | Ubuntu 20.04+ | This is for developers who familiar with Ubuntu 20.04 LTS release |
| `ubuntu2104_armv7l` | armhf | Ubuntu 21.04 | 12.0.0 | CC=gcc, CXX=g++ | Ubuntu 21.04+ | This is for armhf release |
| `manylinux2014_x86_64` | x86_64 | CentOS 7, 7.9.2009 | 16.0.5 | CC=gcc, CXX=g++ | Ubuntu 16.04+, CentOS 7+ | This is for developers who familiar with CentOS on x86_64 architecture |
| `manylinux2014_aarch64` | aarch64 | CentOS 7, 7.9.2009 | 16.0.5 | CC=gcc, CXX=g++ | Ubuntu 16.04+, CentOS 7+ | This is for developers who familiar with CentOS on aarch64 architecture |
","**Summary**

The code appears to be a Markdown document that describes the available Docker images for building WasmEdge, a web assembly runtime. The document provides a table of various Docker images, each with its own configuration and compatibility details.

**Key Components**

1. **Table**: A table showing the available Docker images, including their tag names, architecture, base operating system, LLVM version, environment variables (ENVs), compatibility, and comments.
2. **Tag Names**: The unique identifier for each Docker image, such as `latest`, `ubuntu-build-gcc`, or `manylinux2014_x86_64`.
3. **Architecture**: The CPU architecture supported by each Docker image, such as x86_64 or aarch64.
4. **Base Operating System**: The Linux distribution used as the base for each Docker image, such as Ubuntu 22.04 LTS or CentOS 7.

**Functionality**

Developers can use the `docker pull` command to download and install the desired Docker image. For example, they can run `docker pull wasmedge/wasmedge:latest` to obtain the latest WasmEdge Docker image.

**Potential Issues/ Areas for Improvement**

1. **Table formatting**: The table is quite long and may not be easily readable on smaller screens.
2. **Image description**: Some of the tag names are quite generic, making it difficult to understand their purpose without reading the comments.
3. **Versioning**: The document does not explicitly mention how often the Docker images are updated or which versions of WasmEdge they support.

Overall, this document provides a useful summary of the available WasmEdge Docker images and their characteristics. However, some minor improvements could make it even more readable and maintainable."
docs/contribute/source/plugin/wasi_logging.md,"---
sidebar_position: 1
---

# Build WasmEdge With WASI-Logging Plug-in

WASI-Logging allows WebAssembly applications to log messages in a standardized way. This becomes particularly helpful when debugging applications or understanding the flow of execution within them. The WASI-Logging plug-in is designed to be straightforward to use, enabling developers to focus more on their application logic and less on logging mechanics.

## Prerequisites

The prerequisite of the Wasi-Logging plug-in is the same as the WasmEdge building environment on the [Linux](../os/linux.md) and [MacOS](../os/macos.md) platforms.

## Build WasmEdge with WASI-Logging Plug-in

To enable the WASI-Logging Plug-in, developers need to build the WasmEdge from source with the cmake option `-DWASMEDGE_PLUGIN_WASI_LOGGING=ON`.

```bash
cd <path/to/your/wasmedge/source/folder>
mkdir -p build && cd build
cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_LOGGING=ON .. && make -j
# For the WASI-Logging plug-in, you should install this project.
cmake --install .
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-Logging plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (`/usr/local/lib/wasmedge`, or the built plug-in path `build/plugins/wasi_logging`) to try to fix this issue. You should find `libwasmedgePluginWasiLogging.so` in your `WASMEDGE_PLUGIN_PATH`
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-Logging plugin under `/usr/local/lib/wasmedge/libwasmedgePluginWasiLogging.so` after installation.

## Loading WASI-Logging Plug-in

If the built `wasmedge` CLI tool cannot find the WASI-Logging plug-in, set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_logging/`) to resolve this issue 1.

After installation, the `wasmedge` runtime will be located under `/usr/local/bin` and the WASI-Logging plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiLogging.so`.

## Using WASI-Logging in Your Applications

You can use the WASI-Logging plug-in in your WebAssembly applications to log messages in a standardized way.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/examples/plugin/wasi-logging).
","**Summary**

This document outlines the steps to build WasmEdge with the WASI-Logging plug-in, which enables WebAssembly applications to log messages in a standardized way. The WASI-Logging plug-in is designed to be easy to use and helps developers focus on application logic rather than logging mechanics.

**Key Components**

1. **Prerequisites**: The same as the WasmEdge building environment on Linux and MacOS platforms.
2. **Build WasmEdge with WASI-Logging Plug-in**:
	* Create a build folder and navigate into it.
	* Run `cmake` with `-DWASMEDGE_PLUGIN_WASI_LOGGING=ON` option to enable the plug-in.
	* Run `make -j` to build WasmEdge with the plug-in.
3. **Loading WASI-Logging Plug-in**:
	* Set `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path if the built `wasmedge` CLI tool cannot find the plug-in.
4. **Using WASI-Logging in Your Applications**:
	* Use the WASI-Logging plug-in in your WebAssembly applications to log messages in a standardized way.

**Potential Issues or Areas for Improvement**

1. The document assumes a Linux or MacOS platform, but it's not clear if the WASI-Logging plug-in works on other platforms.
2. The `WASMEDGE_PLUGIN_PATH` environment variable is set to resolve an issue with the built `wasmedge` CLI tool not finding the WASI-Logging plug-in, but this could be a problem for users who don't know how to set environment variables.
3. The document doesn't provide clear instructions on how to use the WASI-Logging plug-in in WebAssembly applications.
4. There is no information on how to debug issues with the WASI-Logging plug-in or where to find more resources if needed.

**Recommendations**

1. Add more information on platform support and troubleshooting steps for issues with the built `wasmedge` CLI tool.
2. Provide clear instructions on how to use the WASI-Logging plug-in in WebAssembly applications, including examples.
3. Consider adding a FAQ section or links to resources that can help users resolve common issues with the WASI-Logging plug-in."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/wasi_logging.md,"---
sidebar_position: 1
---

# Build WasmEdge With WASI-Logging Plug-in

WASI-Logging allows WebAssembly applications to log messages in a standardized way. This becomes particularly helpful when debugging applications or understanding the flow of execution within them. The WASI-Logging plug-in is designed to be straightforward to use, enabling developers to focus more on their application logic and less on logging mechanics.

## Prerequisites

The prerequisite of the Wasi-Logging plug-in is the same as the WasmEdge building environment on the [Linux](../os/linux.md) and [MacOS](../os/macos.md) platforms.

## Build WasmEdge with WASI-Logging Plug-in

To enable the WASI-Logging Plug-in, developers need to build the WasmEdge from source with the cmake option `-DWASMEDGE_PLUGIN_WASI_LOGGING=ON`.

```bash
cd <path/to/your/wasmedge/source/folder>
mkdir -p build && cd build
cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_LOGGING=ON .. && make -j
# For the WASI-Logging plug-in, you should install this project.
cmake --install .
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WASI-Logging plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (`/usr/local/lib/wasmedge`, or the built plug-in path `build/plugins/wasi_logging`) to try to fix this issue. You should find `libwasmedgePluginWasiLogging.so` in your `WASMEDGE_PLUGIN_PATH`
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-Logging plugin under `/usr/local/lib/wasmedge/libwasmedgePluginWasiLogging.so` after installation.

## Loading WASI-Logging Plug-in

If the built `wasmedge` CLI tool cannot find the WASI-Logging plug-in, set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_logging/`) to resolve this issue 1.

After installation, the `wasmedge` runtime will be located under `/usr/local/bin` and the WASI-Logging plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiLogging.so`.

## Using WASI-Logging in Your Applications

You can use the WASI-Logging plug-in in your WebAssembly applications to log messages in a standardized way.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/examples/plugin/wasi-logging).
","**Summary**

The code document describes how to build WasmEdge with the WASI-Logging plug-in, a standardized way for WebAssembly applications to log messages. The prerequisites are the same as building WasmEdge on Linux or MacOS platforms. To enable the plug-in, developers need to build WasmEdge from source using CMake with the `-DWASMEDGE_PLUGIN_WASI_LOGGING=ON` option.

**Key Components**

1. **WASI-Logging Plug-in**: A standardized way for WebAssembly applications to log messages.
2. **CMake Option**: `-DWASMEDGE_PLUGIN_WASI_LOGGING=ON` used to enable the plug-in during WasmEdge build process.
3. **Build Process**: The code document describes how to build WasmEdge with the WASI-Logging plug-in using CMake and the `make` command.
4. **Installation**: After building, the code document explains how to install the plug-in and set environment variables (`WASMEDGE_PLUGIN_PATH`) for correct functioning.

**Potential Issues or Areas for Improvement**

1. **Complexity of Build Process**: The build process described may be complex for developers without prior experience with CMake and WasmEdge.
2. **Lack of Error Handling**: The document does not provide information on how to handle errors during the build or installation process.
3. **Inconsistent Formatting**: The code document uses inconsistent formatting styles, making it harder to read and understand.
4. **Limited Information on Troubleshooting**: The document provides limited information on troubleshooting common issues related to building and installing the WASI-Logging plug-in.

**Suggestions for Improvement**

1. **Simplify Build Process Documentation**: Break down the build process into smaller, more manageable steps with clear explanations.
2. **Provide Error Handling Guidance**: Offer guidance on how to handle errors during the build or installation process.
3. **Standardize Formatting Styles**: Use consistent formatting styles throughout the document to improve readability.
4. **Enhance Troubleshooting Information**: Provide more detailed information on common issues and solutions related to building and installing the WASI-Logging plug-in."
src/pages/talks.md,"import ReactPlayer from 'react-player/lazy'

# WasmEdge Talks

## 2023


### December 6th

####  Optimizing Microservices with WebAssembly and Linux Containers: Exploring Hybrid Container Architectures — Miley Fu, WasmEdge

<ReactPlayer url='https://youtu.be/YJWOpNsULiA?si=8UcWubtgcvHgMNdY' />

---

### December 5th

#### Lightweight and High-Performance Microservices with Dapr and WasmEdge — Michael Yuan, WasmEdge

<ReactPlayer url='https://youtu.be/RkEaz-MPR8k?si=QgbduonqUhZu3Tc_' />

---

### December 5th

#### Efficient and Cross-Platform AI Inference Apps Using Rust and Wasm — Michael Yuan, WasmEdge

<ReactPlayer url='https://youtu.be/HI2w_Qw06YE?si=tZcJX9GYUpn7Qeet' />

---

### September 

#### Develop Wasm Applications with Docker - Angel M De Miguel Meana, VMware & Justin Cormack, Docker

<ReactPlayer url='https://youtu.be/xPO3-TOZxW0?si=A-G3DP-ejMxJflwm' />

---

### May 10th

#### Exotic Runtime Targets: Ruby and Wasm on Kubernetes and GitOps Delivery Pipelines by Kingdon Barrett, Weaveworks

<ReactPlayer url='https://youtu.be/EsAuJmHYWgI?si=KPR96Lo-FyvSaumz' />

---

### May 11th

#### Microservices and WASM, Are We There Yet? by Will Christensen, Defense Unicorns and Kingdon Barrett, Weaveworks

<ReactPlayer url='https://youtu.be/2eTjGFbOz5E?si=Qg7EHyK-vknCpLPm' />

---

### April 21st

#### Create and Deploy a Lightweight Microservice in WebAssembly - Tai Hung-Ying & Vivian Hu, Second State

<ReactPlayer url='https://youtu.be/bBZf23f_sVg?si=2Jsao0ynI5dEitZs' />

---

### March 16th

#### Introduction to WebAssembly (WASM) with Rust and WASMEdge

<ReactPlayer url='https://www.youtube.com/live/shy9DYpoHtQ' />

---

### January 24th

#### Running WebAssembly Applications on Kubernetes with WasmEdge | Mirantis Labs - Tech Talks

<ReactPlayer url='https://youtu.be/--T-JFFNGlE' />

---

## 2022

#### JavaScript in WebAssembly? Why and How - Michael Yuan, WasmEdge

<ReactPlayer url='https://youtu.be/UogNdp-0Bgs' />

---

#### Lightning Talk: Lightweight Dapr Microservices In WebAssembly - Vivian Hu, Second State

<ReactPlayer url='https://youtu.be/RQYDCEF9c8c' />

---

#### With WasmEdge to New Shores - Max Körbächer, Liquid Reply

<ReactPlayer url='https://youtu.be/LgZIPzc_IeQ' />

---

#### Running JavaScript, Python, and Ruby in WebAssembly - Michael Yuan, Second State/WasmEdge

<ReactPlayer url='https://youtu.be/TBs0MYmtgGI' />

---

## 2021

#### Introduction to WasmEdge, A Cloud-native WebAssembly Runtime - Michael Yuan, WasmEdge

<ReactPlayer url='https://youtu.be/9LpvgWaG_T0' />
","**Summary:**

This is an HTML file named `talks.md` located in the `src/pages` directory. It contains a list of talks related to WebAssembly (WASM) and WasmEdge, a cloud-native WASM runtime. The talks are categorized by year, with each talk having a title, speaker(s), and a link to a YouTube video using the `<ReactPlayer>` component.

**Key Components:**

1. **Talks List:** A list of talks is presented in chronological order by year.
2. **Talk Card:** Each talk card consists of:
	* Title
	* Speaker(s)
	* Link to YouTube video using `ReactPlayer` component
3. **ReactPlayer Component:** Used to embed YouTube videos into the page.

**Potential Issues or Areas for Improvement:**

1. **Code organization:** The talks list could be extracted into a separate component for better reusability.
2. **Error handling:** If any of the YouTube URLs are invalid, the ReactPlayer component will throw an error.
3. **SEO optimization:** While the page is generated by a markdown file, it's essential to optimize it for search engines (e.g., add meta tags, descriptions).
4. **Accessibility:** Consider adding ARIA attributes and ensuring that the page follows Web Content Accessibility Guidelines (WCAG).

**Code Suggestions:**

To improve maintainability and scalability, consider extracting talks data into a separate JSON file or database and then rendering them dynamically using JavaScript.

```javascript
// Extract talks list from talks.json (example)
import talksData from '../data/talks.json';

const TalksList = () => {
  return (
    <div>
      {talksData.map((talk) => (
        <TalkCard key={talk.id} {...talk} />
      ))}
    </div>
  );
};

// Render a single TalkCard component
const TalkCard = ({ title, speaker, url }) => (
  <div>
    <h2>{title}</h2>
    <p>Speaker: {speaker}</p>
    <ReactPlayer url={url} />
  </div>
);
```

This code snippet demonstrates how to separate the talks list and talk card components for better reusability."
docs/develop/deploy/podman.md,"---
sidebar_position: 3
---

# Podman

## Fedora Platform

Fedora is the easiest platform to run the WASM app with container because the crun fedora package has supported WasmEdge as the default runtime. We don't need to make any changes to run WasmEdge apps on fedora platform. If you use other Linux distributions, go to [next section](#other-linux-distributions).

### Install podman and WasmEdge

```bash
sudo dnf -y install podman
sudo dnf -y install wasmedge
```

### Run A simple WASI app on Fedora

Now, we could run wasm apps.

```bash
podman run --rm --annotation module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest /wasi_example_main.wasm 50000000
```

That's it.

## Other Linux distributions

### Prerequisites

1. Install and configure Podman

   Use the following commands to install podman on your system. Here I use Ubuntu as an example. For more different types of podman, please refer to [Podman's installation instruction](https://podman.io/getting-started/installation).

   ```bash
   sudo apt-get -y update
   sudo apt-get -y install podman
   ```

2. [Install WasmEdge](../../start/install.md#install)

3. Build and configure crun with WasmEdge support

   Next, configure and build a `crun` binary with WasmEdge support.

   ```bash
   git clone https://github.com/containers/crun
   cd crun
   ./autogen.sh
   ./configure --with-wasmedge
   make
   sudo make install
   # replace crun (be careful, you may want to do a backup first)
   mv crun $(which crun)
   ```

   Then, you can use `crun -v` to check if crun is installed successfully.

   ```bash
   crun --version
   # Output
   crun version 1.7.2.0.0.0.26-51af
   commit: 51af1448f60b69326cf26e726e14b38fcb253943
   rundir: /run/user/0/crun
   spec: 1.0.0
   +SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +WASM:wasmedge +YAJL
   ```

### Run A simple WASI app

Now, we could run wasm apps.

```bash
podman run --rm --annotation module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest /wasi_example_main.wasm 50000000
```

For more information, you could refer to [crun](../deploy/oci-runtime/crun) chapter.

A great open-source project introduces podman and WASM from a community called [Kwasm](https://github.com/KWasm/podman-wasm). Check it out!
","**Summary**

The provided code is a documentation for deploying and running WebAssembly (WASM) applications using Podman on Fedora and other Linux distributions. It covers the installation of Podman, WasmEdge, and crun with WASM support, as well as how to run a simple WASI app.

**Key Components**

1. **Fedora Platform**: The code provides instructions for installing and running WASM apps on Fedora using the `dnf` package manager.
2. **Other Linux Distributions**: For other Linux distributions (e.g., Ubuntu), the code outlines the installation of Podman, WasmEdge, and crun with WASM support.
3. **Installation Commands**: The code includes shell commands for installing packages, building and configuring crun, and running a simple WASI app.

**Potential Issues or Areas for Improvement**

1. **Dependency Management**: The code assumes that dependencies (e.g., `crun`) are installed manually. Consider using package managers or automation tools to simplify dependency management.
2. **Error Handling**: The code does not handle errors or exceptions, which can lead to unexpected behavior or crashes. Add try-except blocks and error handling mechanisms to improve robustness.
3. **Documentation Organization**: The documentation is fragmented across multiple sections. Consider reorganizing it into a more cohesive structure, such as a tutorial-style guide with step-by-step instructions.
4. **Community Contributions**: The code references the Kwasm community project, which is a great resource for community involvement and collaboration.

**Additional Suggestions**

1. **Use Containerization Tools**: Podman is containerization tool that can be used to run WebAssembly applications in a isolated environment.
2. **Explore Other Runtimes**: Consider using other WASM runtimes (e.g., `wasmtime`) to provide more flexibility and options for developers.
3. **Improve Documentation Style**: Follow consistent documentation style guidelines, such as Markdown or Asciidoc, to improve readability and maintainability.

Overall, the provided code provides a good starting point for deploying and running WASM applications using Podman on various Linux distributions. However, some improvements can be made to enhance its robustness, maintainability, and user experience."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/podman.md,"---
sidebar_position: 3
---

# Podman

## Fedora Platform

Fedora is the easiest platform to run the WASM app with container because the crun fedora package has supported WasmEdge as the default runtime. We don't need to make any changes to run WasmEdge apps on fedora platform. If you use other Linux distributions, go to [next section](#other-linux-distributions).

### Install podman and WasmEdge

```bash
sudo dnf -y install podman
sudo dnf -y install wasmedge
```

### Run A simple WASI app on Fedora

Now, we could run wasm apps.

```bash
podman run --rm --annotation module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest /wasi_example_main.wasm 50000000
```

That's it.

## Other Linux distributions

### Prerequisites

1. Install and configure Podman

   Use the following commands to install podman on your system. Here I use Ubuntu as an example. For more different types of podman, please refer to [Podman's installation instruction](https://podman.io/getting-started/installation).

   ```bash
   sudo apt-get -y update
   sudo apt-get -y install podman
   ```

2. [Install WasmEdge](../../start/install.md#install)

3. Build and configure crun with WasmEdge support

   Next, configure and build a `crun` binary with WasmEdge support.

   ```bash
   git clone https://github.com/containers/crun
   cd crun
   ./autogen.sh
   ./configure --with-wasmedge
   make
   sudo make install
   # replace crun (be careful, you may want to do a backup first)
   mv crun $(which crun)
   ```

   Then, you can use `crun -v` to check if crun is installed successfully.

   ```bash
   crun --version
   # Output
   crun version 1.7.2.0.0.0.26-51af
   commit: 51af1448f60b69326cf26e726e14b38fcb253943
   rundir: /run/user/0/crun
   spec: 1.0.0
   +SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +WASM:wasmedge +YAJL
   ```

### Run A simple WASI app

Now, we could run wasm apps.

```bash
podman run --rm --annotation module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest /wasi_example_main.wasm 50000000
```

For more information, you could refer to [crun](../deploy/oci-runtime/crun) chapter.

A great open-source project introduces podman and WASM from a community called [Kwasm](https://github.com/KWasm/podman-wasm). Check it out!
","**Summary**

The provided code is a Markdown file that documents the process of deploying and running WebAssembly (WASM) apps using Podman on various Linux distributions. The document is divided into two main sections: Fedora Platform and Other Linux Distributions.

**Key Components**

1. **Fedora Platform**: This section provides instructions for installing Podman and WASMEdge, the runtime environment required to run WASM apps.
2. **Other Linux Distributions**: This section outlines the prerequisites and steps to install and configure Podman, WASMEdge, and crun on other Linux distributions (e.g., Ubuntu).
3. **Running a Simple WASI App**: The code snippet at the end of both sections demonstrates how to run a simple WebAssembly app using Podman.

**Potential Issues or Areas for Improvement**

1. **Complexity**: The instructions for installing and configuring crun with WasmEdge support may be overwhelming for users without prior experience.
2. **Distribution-Specific Instructions**: The document assumes the reader is familiar with specific Linux distributions (e.g., Ubuntu, Fedora). Consider adding more general instructions or links to distribution-specific documentation.
3. **Error Handling**: The code snippet for running a simple WASI app does not handle potential errors that may occur during execution.

**Suggestions**

1. **Simplify Installation Instructions**: Break down the installation process into smaller, more manageable steps and provide additional guidance on troubleshooting common issues.
2. **Use Distribution-Agnostic Language**: Where possible, use language that is applicable to multiple Linux distributions (e.g., ""use a package manager like `apt-get` or `dnf`"").
3. **Add Error Handling Mechanisms**: Modify the code snippet to handle potential errors and provide more robust instructions for users who encounter issues while running their WASI apps.

By addressing these areas for improvement, the document can be made more user-friendly and easier to follow for readers without prior experience with Podman or WebAssembly development."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/rusttls.md,"---
sidebar_position: 8
---

# Build with Rustls Plug-in

The WasmEdge Rustls plug-in is a replacement for the OpenSSL plug-in in WasmEdge. It provides a Rust-friendly interface to the Rustls library, which is a modern, fast, and more secure alternative to OpenSSL.

Here's a step-by-step guide on how to build the WasmEdge Rustls plug-in:

## Prerequisites

Ensure the following dependencies are installed on your system:

- Rust: You can install it from the [official website](https://www.rust-lang.org/tools/install).
- CMake: Minimum version 3.12. Install it from the [official website](https://cmake.org/download/).

## Clone the WasmEdge Repository

First, clone the WasmEdge repository from GitHub:

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
```

## Navigate to the Rustls Plug-in Directory

Navigate to the `wasmedge_rustls` directory within the cloned repository:

```bash
cd WasmEdge/plugins/wasmedge_rustls
```

## Build the Plug-in

Now you can build the Rustls plug-in. Run the following command:

```bash
cargo build --release
```

This command builds the plug-in in release mode. The compiled binary will be located in the `target/release` directory.

## Install the Plug-in

To install the plug-in, you can use the `cargo install` command:

```bash
cargo install --path .
```

This command will install the built plug-in into your Rust binary directory.

## Usage

To use the plug-in with WasmEdge, you need to specify it when starting the WasmEdge runtime:

```bash
wasmedge --dir .:. --reactor --rustls_plugin target/release/libwasmedge_rustls.so your_wasm_file.wasm
```

Replace `your_wasm_file.wasm` with the path to your WebAssembly file. The `--rustls_plugin` flag specifies the path to the Rustls plug-in.

That's it! You have successfully built and installed the WasmEdge Rustls plug-in. Please ensure to replace the OpenSSL plug-in with the Rustls plug-in in your WasmEdge runtime configuration if you were previously using OpenSSL.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_rustls).
","**Summary**

The provided code is a step-by-step guide on building and installing the WasmEdge Rustls plug-in, which replaces the OpenSSL plug-in in WasmEdge. The Rustls plug-in provides a modern, fast, and secure alternative to OpenSSL.

**Key Components**

1. **Prerequisites**: Install Rust and CMake, minimum version 3.12.
2. **Clone Repository**: Clone the WasmEdge repository from GitHub using `git clone https://github.com/WasmEdge/WasmEdge.git`.
3. **Navigate to Plug-in Directory**: Navigate to the `wasmedge_rustls` directory within the cloned repository using `cd WasmEdge/plugins/wasmedge_rustls`.
4. **Build Plug-in**: Build the Rustls plug-in in release mode using `cargo build --release`.
5. **Install Plug-in**: Install the built plug-in using `cargo install --path .`.
6. **Usage**: Use the plug-in with WasmEdge by specifying it when starting the runtime.

**Potential Issues**

1. **Rust and CMake versions**: Ensure that Rust and CMake are installed at the required versions (Rust 1.x, CMake 3.12).
2. **Build failures**: If `cargo build` or `cargo install` fails, check for errors in the terminal output.
3. **WasmEdge configuration**: Replace the OpenSSL plug-in with the Rustls plug-in in WasmEdge runtime configuration if previously using OpenSSL.

**Areas for Improvement**

1. **Error handling**: Improve error handling in `cargo build` and `cargo install` commands to provide more informative error messages.
2. **Code organization**: Consider refactoring the guide into separate sections or chapters for easier navigation.
3. **Example use cases**: Provide additional examples of using the Rustls plug-in with WasmEdge to demonstrate its capabilities."
docs/develop/deploy/oci-runtime/crun.md,"---
sidebar_position: 2
---

# Deploy with crun

The [crun project](https://github.com/containers/crun) has WasmEdge support baked in. This chapter will walk you through deploying WASM images with crun.

## Fedora Platform

The crun fedora package has WasmEdge as the default WebAssembly Runtime. So the easiest way to deploy WasmEdge with crun is on the Fedora Linux distribution. Please refer to the [next section](#other-linux-platforms) for the other Linux distributions.

First, install crun and WasmEdge on your fedora machine.

```bash
sudo dnf -y install wasmedge
sudo dnf -y install crun
```

Next, run `crun -v` to check if you installed successfully.

```bash
crun -v
# Output
crun version 1.7.2
commit: 0356bf4aff9a133d655dc13b1d9ac9424706cac4
rundir: /run/user/501/crun
spec: 1.0.0
+SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +CRIU +LIBKRUN +WASM:wasmedge +YAJL
```

You can see that crun has WasmEdge package already.

Next, you can run WASM apps on your [fedora machine](../../../start/getting-started/quick_start_redhat.md).

## Other Linux Platforms

### Quick start

The [GitHub repo](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on CRI-O.

- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio.yml)
- HTTP service example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio-server.yml)

### Prerequisites

1. Make sure you have installed [WasmEdge](../../../start/install.md#install)

2. Build and configure crun with WasmEdge support

For now, the easiest approach is just built it yourself from source. First, let's ensure that `crun` dependencies are installed on your Ubuntu 20.04. For other Linux distributions, please [see here](https://github.com/containers/crun#readme).

```bash
sudo apt update
sudo apt install -y make git gcc build-essential pkgconf libtool \
    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
    go-md2man libtool autoconf python3 automake
```

Next, configure, build, and install a `crun` binary with WasmEdge support.

```bash
git clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
```
","**Summary**

This document guides the reader on how to deploy WebAssembly (WASM) images using the `crun` project, which has built-in support for WASMEdge. The steps are divided into two sections:

1. **Fedora Platform**: Installing `crun` and WASMEdge on a Fedora Linux distribution, where crun has WasmEdge as its default WebAssembly Runtime.
2. **Other Linux Platforms**: Building and configuring crun with WASMEdge support on non-Fedora platforms.

**Key Components**

* `crun`: A lightweight container runtime for Linux
* WASMEdge: The default WebAssembly Runtime for crun (on Fedora) or a build dependency for custom builds
* Git: Used for cloning the crun repository and building it from source

**Potential Issues/Improvement Areas**

1. **Platform-specific dependencies**: The instructions for installing `crun` dependencies vary across Linux distributions. Providing more comprehensive documentation or tools to simplify this process would be helpful.
2. **Building from source**: For non-Fedora platforms, users need to build crun with WASMEdge support from source. This can be a complex and error-prone process, especially for those without experience in building and configuring container runtimes.
3. **Documentation updates**: The document mentions that the GitHub repository contains scripts and GitHub Actions for running example apps on CRI-O. However, these links are not clickable or directly accessible within the provided documentation.

**Recommendations**

1. **Improve platform-agnostic instructions**: Provide more detailed instructions or tools to simplify the process of installing `crun` dependencies across Linux distributions.
2. **Simplify building from source**: Consider providing a pre-built binary for non-Fedora platforms or improving the build process to reduce complexity and errors.
3. **Update documentation links**: Ensure that all provided links are clickable, up-to-date, and accessible within the document."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime/crun.md,"---
sidebar_position: 2
---

# Deploy with crun

The [crun project](https://github.com/containers/crun) has WasmEdge support baked in. This chapter will walk you through deploying WASM images with crun.

## Fedora Platform

The crun fedora package has WasmEdge as the default WebAssembly Runtime. So the easiest way to deploy WasmEdge with crun is on the Fedora Linux distribution. Please refer to the [next section](#other-linux-platforms) for the other Linux distributions.

First, install crun and WasmEdge on your fedora machine.

```bash
sudo dnf -y install wasmedge
sudo dnf -y install crun
```

Next, run `crun -v` to check if you installed successfully.

```bash
crun -v
# Output
crun version 1.7.2
commit: 0356bf4aff9a133d655dc13b1d9ac9424706cac4
rundir: /run/user/501/crun
spec: 1.0.0
+SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +CRIU +LIBKRUN +WASM:wasmedge +YAJL
```

You can see that crun has WasmEdge package already.

Next, you can run WASM apps on your [fedora machine](../../../start/getting-started/quick_start_redhat.md).

## Other Linux Platforms

### Quick start

The [GitHub repo](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on CRI-O.

- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio.yml)
- HTTP service example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio-server.yml)

### Prerequisites

1. Make sure you have installed [WasmEdge](../../../start/install.md#install)

2. Build and configure crun with WasmEdge support

For now, the easiest approach is just built it yourself from source. First, let's ensure that `crun` dependencies are installed on your Ubuntu 20.04. For other Linux distributions, please [see here](https://github.com/containers/crun#readme).

```bash
sudo apt update
sudo apt install -y make git gcc build-essential pkgconf libtool \
    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
    go-md2man libtool autoconf python3 automake
```

Next, configure, build, and install a `crun` binary with WasmEdge support.

```bash
git clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
```
","**Summary**

This code is a documentation chapter on deploying WASM (WebAssembly) images with crun, a container runtime project. The chapter provides step-by-step instructions for installing crun and WasmEdge on Fedora Linux, as well as other Linux platforms.

**Key Components**

1. **Fedora Platform**: The chapter explains that the crun package on Fedora Linux has WasmEdge as its default WebAssembly Runtime.
2. **Installation Instructions**: The code provides shell commands to install crun and WasmEdge on a Fedora machine using dnf.
3. **Verification**: The code includes an example of verifying the installation by running `crun -v`.
4. **Other Linux Platforms**: The chapter outlines the steps for installing crun with WasmEdge support on other Linux platforms, including Ubuntu 20.04.
5. **Prerequisites**: The code lists the dependencies required to build and configure crun with WasmEdge support.

**Potential Issues or Areas for Improvement**

1. **Platform-Specific Instructions**: The chapter provides platform-specific instructions, which may become outdated or need updates as new versions of operating systems are released.
2. **Assumptions**: The code assumes that the reader has a basic understanding of shell commands and Linux environments.
3. **Error Handling**: There is no explicit error handling in case something goes wrong during installation or verification.

**Code Quality**

The code is well-structured, with clear headings and concise instructions. However, there are some minor formatting issues and typos that should be addressed for better readability."
docs/develop/deploy/oci-runtime/youki.md,"---
sidebar_position: 3
---

# Deploy with youki

youki is an OCI container runtime written in Rust. youki has WasmEdge baked in. This chapter will walk you through deploying WASM images with youki.

## Prerequisites

1. Build and configure youki with WasmEdge support

   We will use Ubuntu 20.04 as an example. For other OS, please [see here](https://containers.github.io/youki/user/basic_setup.html).

   Run the following command line to build and install youki on your machine.

   ```bash
   $ sudo apt-get install \
      curl                \
      git                 \
      pkg-config          \
      libsystemd-dev      \
      libdbus-glib-1-dev  \
      build-essential     \
      libelf-dev          \
      libzstd-dev         \
      libseccomp-dev      \
      libclang-dev

   # If you don't have the rust toolchain installed run:
   $ curl https://sh.rustup.rs -sSf | sudo sh -s -- -y
   ```

   Next, configure, build, and install a `youki` binary with WasmEdge support.

   ```bash
   git clone --recurse-submodules https://github.com/containers/youki.git
   cd youki
   ./scripts/build.sh -o . -r -f wasm-wasmedge
   ./youki -h
   export LD_LIBRARY_PATH=$HOME/.wasmedge/lib
   ```

2. [Install WasmEdge](../../../start/install.md#install)

3. Configure the `config.json` from youki to run WASM modules.

   To run a webassembly module with youki, the `config.json` has to include either runc.oci.handler or module.wasm.image/variant=compat"". It also needs you to specify a valid .wasm (webassembly binary) or .wat (webassembly test) module as an entrypoint for the container.

   ```json
   ""ociVersion"": ""1.0.2-dev"",
   ""annotations"": {
       ""run.oci.handler"": ""wasm""
   },
   ""process"": {
       ""args"": [
           ""wasi_example_main.wasm"",
           ],
   ```

## Run a simple WebAssembly app

Now we can run a simple WebAssembly app. [A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md) explains how to compile, package, and publish the WebAssembly program as a container image to Docker hub.

```bash
sudo ctr i pull docker.io/wasmedge/example-wasi:latest
```

Run the example with Youki and Podman.

```bash
sudo podman --runtime /PATH/WHARE/YOU/BUILT/WITH/WASM-WASMEDGE/youki run /wasi_example_main.wasm 50000000
```

That's it.
","**Summary**

The code in this document provides a step-by-step guide to deploying WebAssembly (WASM) images using the OCI container runtime ""youki"". Youki is written in Rust and includes WasmEdge baked in. The guide assumes you have Ubuntu 20.04 as your operating system.

**Key Components**

1. **Prerequisites**: The user needs to build and configure youki with WasmEdge support, which involves installing dependencies and building the `youki` binary.
2. **Configuring config.json**: The `config.json` file needs to be configured to run WASM modules using either `runc.oci.handler` or `module.wasm.image/variant=compat`.
3. **Running a simple WebAssembly app**: Once youki and WasmEdge are set up, the user can run a simple WebAssembly app using `podman --runtime /path/to/youki`.

**Potential Issues**

1. **Dependencies**: The guide assumes that the necessary dependencies (e.g., Rust toolchain) are already installed on the system.
2. **WasmEdge installation**: WasmEdge needs to be installed separately, and its installation process is not included in the guide.
3. **Path issues**: The path to the `youki` binary may need to be adjusted depending on the user's system configuration.

**Recommendations**

1. **Improve error handling**: Add more explicit error messages or logging statements to help users diagnose any issues that may arise during the installation and setup process.
2. **Update dependencies**: Regularly update the list of required dependencies to ensure that the guide remains accurate and relevant.
3. **Add more examples**: Include additional examples of how to use youki and WasmEdge to deploy different types of WASM applications."
i18n/zh/docusaurus-plugin-content-docs/current/start/wasmedge/features.md,"---
sidebar_position: 1
---

# WasmEdge 功能

WasmEdge（[CNCF 旗下的沙盒项目](https://www.cncf.io/projects/wasmedge/)）是一个安全、快速、轻量、可移植且可扩展的 WebAssembly 运行时。

## 高性能

利用[基于 LLVM 的 AoT 编译器](../build-and-run/aot)，WasmEdge 是市场上速度最快的 WebAssembly 运行时。

- [高性能轻量设计用于无服务器计算](https://arxiv.org/abs/2010.07115)，发表于 2021 年 1 月 IEEE 软件。[https://arxiv.org/abs/2010.07115](https://arxiv.org/abs/2010.07115)
- [云端性能分析：Arm 与 x86 CPU 的比较](https://www.infoq.com/articles/arm-vs-x86-cloud-performance/)，发表于 2021 年 1 月的 infoQ.com。[https://www.infoq.com/articles/arm-vs-x86-cloud-performance/](https://www.infoq.com/articles/arm-vs-x86-cloud-performance/)
- [WasmEdge 在 Suborbital Reactr 测试套件中是最快的 WebAssembly 运行时](https://blog.suborbital.dev/suborbital-wasmedge)，2021 年 12 月

## 云原生扩展

除了 WASI 和标准的 WebAssembly 提案，WasmEdge 还有一些云原生扩展。

- 使用 Rust、C 和 JavaScript SDK 实现的非阻塞网络套接字和 Web 服务
- 基于 MySQL 的数据库驱动程序
- 键值存储
- 用于资源限制的 Gas 计量器
- 用于复杂参数传递的 WasmEdge-bindgen
- 使用 TensorFlow、TensorFlow Lite、PyTorch 和 OpenVINO 进行 AI 推理

## JavaScript 支持

通过 [WasmEdge-Quickjs](https://github.com/second-state/wasmedge-quickjs) 项目，WasmEdge 可以运行 JavaScript 程序，降低开发 WASM 应用的门槛。

- ES6 模块和 std API 支持
- NPM 模块支持
- Rust 中的原生 JS API
- Node.js API 支持
- 异步网络
- Fetch API
- React SSR

## 云原生编排

WasmEdge 可以与现有的云原生基础设施无缝集成。

要将 WasmEdge 与你现有的云原生基础架构集成，有几种管理 WASM 应用程序作为 Kubernetes 下的“容器”的选项。这些选项使你能够在 Kubernetes 集群中同时运行 Linux 容器和 WASM 容器。

**选项 #1：**[使用 OCI 运行时 crun](../../develop/deploy/oci-runtime/crun.md)（runc 的 C 版本，主要由 Red Hat 支持）。crun 根据镜像注释决定 OCI 镜像是 WASM 还是基于 Linux 的。如果镜像被注释为 wasm32，则 crun 将绕过 Linux 容器设置，直接使用 WasmEdge 运行镜像。通过使用 crun，你可以让整个 Kubernetes 栈（包括 CRI-O、containerd、Podman、kind、micro k8s 和 k8s）与 WASM 镜像一起工作。

选项 #2：[使用 containerd-shim 通过 runwasi 启动 WASM“容器”](../../develop/deploy/cri-runtime/containerd.md)。基本上，containerd 可以查看镜像的目标平台。如果镜像是 wasm32，则使用 runwasi；如果是 x86 / arm，则使用 runc。这是 Docker + Wasm 使用的方法。

## 跨平台

WASM 具有可移植性。编译后的 wasm 文件可以在不同的硬件和平台上运行，而无需任何更改。

WasmEdge 支持多种操作系统和硬件平台。它允许 WebAssembly 应用程序在各个平台上实现真正的可移植性。它可以在类似 Linux 的系统和微内核（例如实时系统 `seL4`）上运行。

WasmEdge 目前支持：

- [Linux（x86_64 和 aarch64）](../../contribute/source/os/linux.md)
- [MacOS（x86_64 和 M1）](../../contribute/source/os/macos.md)
- [Windows 10](../../contribute/source/os/windows.md)
- [Android](/category/build-and-run-wasmedge-on-android)
- [seL4 RTOS](../../contribute/source/os/sel4.md)
- [OpenWrt](../../contribute/source/os/openwrt.md)
- [OpenHarmony](../../contribute/source/os/openharmony.md)
- [Raspberry Pi](../../contribute/source/os/raspberrypi.md)
- [RISC-V(WIP)](../../contribute/source/os/riscv64.md)

## 易于扩展

使用 C、Go 和 Rust 中的原生宿主函数很容易构建自定义的 WasmEdge 运行时。

或者，你可以为 WasmEdge 构建自己的插件，

- [Rust](../../contribute/plugin/develop_plugin_rustsdk)
- [C](../../contribute/plugin/develop_plugin_c)
- [C++](../../contribute/plugin/develop_plugin_cpp)

## 易于嵌入到主机应用程序中

嵌入式运行时是 WasmEdge 的经典用例。你可以将 WasmEdge 函数嵌入到 C、Go、Rust、Node.js、Java(WIP) 和 Python(WIP) 主机应用程序中。
","**Code Analysis Summary**

This code is a feature description for WasmEdge, a WebAssembly runtime that provides high-performance, lightweight, and portable execution of WebAssembly modules. The document highlights the following key features:

1. **High-Performance**: WasmEdge is built using LLVM's Ahead-of-Time (AOT) compiler, making it one of the fastest WebAssembly runtimes available.
2. **Cloud-Native Extensions**: WasmEdge provides extensions for cloud-native applications, including non-blocking network sockets, web services, database drivers, and AI inference with TensorFlow, TensorFlow Lite, PyTorch, and OpenVINO.
3. **JavaScript Support**: WasmEdge can execute JavaScript programs using the Quickjs engine, making it easier to develop WASM applications.
4. **Cloud-Native Orchestration**: WasmEdge can be integrated with existing cloud-native infrastructure, allowing for seamless deployment of WASM applications as Kubernetes ""containers.""
5. **Cross-Platform Compatibility**: WasmEdge is designed to be highly portable and can run on various operating systems and hardware platforms, including Linux, MacOS, Windows 10, Android, seL4 RTOS, OpenWrt, OpenHarmony, Raspberry Pi, and RISC-V.
6. **Easy Extension and Embedding**: WasmEdge provides a simple way to extend its functionality using C, Go, or Rust native host functions and allows for easy embedding into host applications written in C, Go, Rust, Node.js, Java, and Python.

**Potential Issues and Areas for Improvement**

1. **Code organization**: The document could benefit from a more structured organization, with clear headings and subheadings to facilitate easier navigation.
2. **Consistency**: Some sections may have inconsistent formatting or styles, which can make it difficult to read and understand the content.
3. **Depth of information**: While the document provides an overview of WasmEdge's features, some sections could be expanded upon or provide more in-depth information for users who want to delve deeper into specific topics.

Overall, this code analysis reveals a well-structured document that effectively communicates the key features and benefits of WasmEdge. With minor adjustments to organization and formatting, it can become an even more effective resource for users looking to learn about this powerful WebAssembly runtime."
docs/contribute/source/os/macos.md,"---
sidebar_position: 2
---

# Build on macOS

Currently, WasmEdge project on MacOS supports both Intel and M1 models. However, we only test and develop on `Catalina`, `Big Sur`, and `Monterey`.

- Model:
  - Intel (x86_64)
  - M1, M2 (arm64)
- Operating System
  - Ventura
  - Monterey
  - Big Sur
  - Catalina

If you want to develop WasmEdge on MacOS, please follow this guide to build and test from source code.

## Get Source Code

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
```

## Requirements and Dependencies

WasmEdge will try to use the latest LLVM release to create our nightly build. If you want to build from source, you may need to install these dependencies yourself.

- LLVM 16.0.4 (>= 10.0.0)

```bash
# Tools and libraries
brew install cmake ninja llvm
export LLVM_DIR=""$(brew --prefix)/opt/llvm/lib/cmake""
export CC=clang
export CXX=clang++
```

## Build WasmEdge

Please refer to [here](../build_from_src.md#cmake-building-options) for the descriptions of all CMake options.

```bash
cmake -Bbuild -GNinja -DWASMEDGE_BUILD_TESTS=ON .
cmake --build build
```

If you don't want to link LLVM on MacOS dynamically, you can set the option `WASMEDGE_LINK_LLVM_STATIC` to `ON`.

## Run Tests

The following tests are available only when the build option `WASMEDGE_BUILD_TESTS` is set to `ON`.

Users can use these tests to verify the correctness of WasmEdge binaries.

```bash
cd build
DYLD_LIBRARY_PATH=$(pwd)/lib/api ctest
```

## Known issues

The following tests can not pass on Macos, we are investigating these issues:

- wasmedgeWasiSocketTests

But we have an open issue working on it. Don't hesitate to leave your feedback for [this issue](https://github.com/WasmEdge/WasmEdge/issues/2438).
","**Summary**

This document provides a guide for building the WasmEdge project on macOS. It covers the requirements and dependencies, including LLVM 16.0.4 or later, and how to install them using Homebrew. The guide also explains how to build WasmEdge from source code, including setting up CMake options, building the project, and running tests.

**Key Components**

1. **Get Source Code**: Clone the WasmEdge repository using Git.
2. **Requirements and Dependencies**: Install LLVM 16.0.4 or later using Homebrew, along with other tools and libraries such as CMake and Ninja.
3. **Build WasmEdge**: Use CMake to build the project in a separate directory (`build`), specifying the necessary options (e.g., `WASMEDGE_BUILD_TESTS=ON`).
4. **Run Tests**: Run tests using the `ctest` command, setting the `DYLD_LIBRARY_PATH` environment variable to the location of the built WasmEdge libraries.

**Potential Issues and Areas for Improvement**

1. **Incompatibility with macOS versions**: The guide only mentions testing on Catalina, Big Sur, and Monterey, but Ventura is also supported. It would be good to clarify this in the documentation.
2. **Dynamic linking issue**: The guide mentions a known issue where dynamic linking of LLVM can cause problems. It suggests setting `WASMEDGE_LINK_LLVM_STATIC` to `ON` as a workaround.
3. **Insufficient testing on M1 and M2 models**: While the guide mentions support for Intel, M1, and M2 (arm64) architectures, it would be good to clarify whether tests have been run successfully on these platforms.

Overall, this is a clear and concise guide that provides a step-by-step approach to building WasmEdge from source code on macOS. However, some minor improvements could be made to address potential issues and provide additional context for users."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/macos.md,"---
sidebar_position: 2
---

# Build on macOS

Currently, WasmEdge project on MacOS supports both Intel and M1 models. However, we only test and develop on `Catalina`, `Big Sur`, and `Monterey`.

- Model:
  - Intel (x86_64)
  - M1, M2 (arm64)
- Operating System
  - Ventura
  - Monterey
  - Big Sur
  - Catalina

If you want to develop WasmEdge on MacOS, please follow this guide to build and test from source code.

## Get Source Code

```bash
git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
```

## Requirements and Dependencies

WasmEdge will try to use the latest LLVM release to create our nightly build. If you want to build from source, you may need to install these dependencies yourself.

- LLVM 16.0.4 (>= 10.0.0)

```bash
# Tools and libraries
brew install cmake ninja llvm
export LLVM_DIR=""$(brew --prefix)/opt/llvm/lib/cmake""
export CC=clang
export CXX=clang++
```

## Build WasmEdge

Please refer to [here](../build_from_src.md#cmake-building-options) for the descriptions of all CMake options.

```bash
cmake -Bbuild -GNinja -DWASMEDGE_BUILD_TESTS=ON .
cmake --build build
```

If you don't want to link LLVM on MacOS dynamically, you can set the option `WASMEDGE_LINK_LLVM_STATIC` to `ON`.

## Run Tests

The following tests are available only when the build option `WASMEDGE_BUILD_TESTS` is set to `ON`.

Users can use these tests to verify the correctness of WasmEdge binaries.

```bash
cd build
DYLD_LIBRARY_PATH=$(pwd)/lib/api ctest
```

## Known issues

The following tests can not pass on Macos, we are investigating these issues:

- wasmedgeWasiSocketTests

But we have an open issue working on it. Don't hesitate to leave your feedback for [this issue](https://github.com/WasmEdge/WasmEdge/issues/2438).
","**Code Summary**

This is a documentation file for building the WasmEdge project on macOS. The document provides instructions and requirements for developing WasmEdge from source code.

**Key Components**

1. **Requirements**: The document lists the dependencies required to build WasmEdge, including LLVM 16.0.4 (>=10.0.0).
2. **Getting Source Code**: The user is instructed to clone the WasmEdge repository and navigate to the project directory.
3. **Building WasmEdge**: The user is provided with CMake commands to build WasmEdge with various options, including enabling tests and linking LLVM statically.
4. **Running Tests**: Instructions are given on how to run the available tests using the `ctest` command.

**Potential Issues or Areas for Improvement**

1. **Known issues**: The document mentions an open issue with the `wasmedgeWasiSocketTests` test that cannot pass on macOS. It would be beneficial to provide a workaround or temporary solution until the issue is resolved.
2. **Version requirements**: While LLVM 16.0.4 is specified, it's not clear if this version will always be compatible with future WasmEdge releases. A more flexible versioning strategy or recommendation for users to install the latest stable LLVM release might be beneficial.
3. **Dependency installation**: The document assumes that users have Homebrew installed and can use `brew` commands to install dependencies. Adding a note about alternative package managers (e.g., MacPorts, apt-get) or providing instructions on how to manually download and install dependencies would improve usability.

**Best Practices**

1. **Use clear headings and sectioning**: The document's structure and organization are clear, making it easy to follow along.
2. **Provide concise and specific instructions**: Each step has a clear and concise description, reducing the likelihood of users getting lost or confused.
3. **Link to external resources**: Providing links to related issues or documentation can help users dive deeper into specific topics and collaborate with others who may be experiencing similar challenges."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime/youki.md,"---
sidebar_position: 3
---

# Deploy with youki

youki is an OCI container runtime written in Rust. youki has WasmEdge baked in. This chapter will walk you through deploying WASM images with youki.

## Prerequisites

1. Build and configure youki with WasmEdge support

   We will use Ubuntu 20.04 as an example. For other OS, please [see here](https://containers.github.io/youki/user/basic_setup.html).

   Run the following command line to build and install youki on your machine.

   ```bash
   $ sudo apt-get install   \
       pkg-config         \
       libsystemd-dev     \
       libdbus-glib-1-dev \
       build-essential    \
       libelf-dev \
       libseccomp-dev \
       libclang-dev
   ```

   Next, configure, build, and install a `youki` binary with WasmEdge support.

   ```bash
   git clone https://github.com/containers/youki.git
   go into the cloned directory
   cd youki
   make youki-dev
   ./youki -h
   ./scripts/build.sh -o . -r -f wasm-wasmedge
   export LD_LIBRARY_PATH=$HOME/.wasmedge/lib
   ```

2. [Install WasmEdge](../../../start/install.md#install)

3. Configure the `config.json` from youki to run WASM modules.

   To run a webassembly module with youki, the `config.json` has to include either runc.oci.handler or module.wasm.image/variant=compat"". It also needs you to specify a valid .wasm (webassembly binary) or .wat (webassembly test) module as an entrypoint for the container.

   ```json
   ""ociVersion"": ""1.0.2-dev"",
   ""annotations"": {
       ""run.oci.handler"": ""wasm""
   },
   ""process"": {
       ""args"": [
           ""wasi_example_main.wasm"",
           ],
   ```

## Run a simple WebAssembly app

Now we can run a simple WebAssembly app. [A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md) explains how to compile, package, and publish the WebAssembly program as a container image to Docker hub.

```bash
sudo ctr i pull docker.io/wasmedge/example-wasi:latest
```

Run the example with Youki and Podman.

```bash
sudo podman --runtime /PATH/WHARE/YOU/BUILT/WITH/WASM-WASMEDGE/youki run /wasi_example_main.wasm 50000000
```

That's it.
","**Summary**

The code provided is a documentation chapter for deploying WebAssembly (WASM) images with the Youki container runtime. It assumes that the reader has already built and configured Youki with WasmEdge support on an Ubuntu 20.04 system. The chapter walks through the process of setting up and running a simple WASM app using Youki and Podman.

**Key Components**

1. **Prerequisites**: Building and configuring Youki with WasmEdge support.
2. **Installing WasmEdge**: Installing WasmEdge, a Rust implementation of the WebAssembly runtime environment.
3. **Configuring `config.json`**: Configuring the `config.json` file to run WASM modules using Youki.
4. **Running a simple WebAssembly app**: Compiling, packaging, and publishing a WASM program as a container image on Docker Hub, then running it with Youki and Podman.

**Potential Issues or Areas for Improvement**

1. **Code Organization**: The documentation chapter seems to be a mix of installation instructions, configuration examples, and usage guides. Consider breaking down the content into separate sections or chapters.
2. **Assumptions**: Some steps assume that the reader has already built and configured Youki with WasmEdge support. Provide more explicit guidance for users who are new to Youki or WasmEdge.
3. **Code Snippets**: The code snippets in the `config.json` file are not formatted consistently, which may make them harder to read. Consider using a consistent formatting style throughout the documentation.
4. **Links**: Some links (e.g., `[see here](https://containers.github.io/youki/user/basic_setup.html)`) seem to be broken or outdated. Update these links to ensure that they point to valid resources.

Overall, the code provided is well-structured and provides a clear guide for deploying WASM images with Youki. With some minor improvements in organization, assumptions, and formatting, it can become an even more effective resource for users."
docs/develop/c/simd.md,"---
sidebar_position: 4
---

# WebAssembly SIMD Example in C

[128-bit packed Single Instruction Multiple Data (SIMD)](https://webassembly.github.io/simd/core/syntax/instructions.html#simd-instructions) instructions provide simultaneous computations over packed data in just one instruction. It's commonly used to improve performance for multimedia applications. With the SIMD proposal, the modules can benefit from using these commonly used instructions in modern hardware to gain more speedup.

If you are interested in enabling the SIMD proposal will improve how much performance of the applications, please refer to our [wasm32-wasi benchmark](https://github.com/second-state/wasm32-wasi-benchmark) for more information. The Mandelbrot Set application can have a **2.65x** speedup in our benchmark.

We modified the Mandelbrot Set example from our [wasm32-wasi benchmark project](https://github.com/second-state/wasm32-wasi-benchmark/blob/master/src/mandelbrot.c). We will use this as an example in this article.

## Prerequisites

Before we start, make sure you have installed the following software:

1. [Install WasmEdge](../../start/install.md#install)

2. Emscripten, a toolchain for compiling C/C++ to WebAssembly. Please refer to the [emcc official repository](https://github.com/emscripten-core/emsdk) for detailed instructions.

```bash
git clone --depth 1 https://github.com/emscripten-core/emsdk.git
cd emsdk
./emsdk install latest
./emsdk activate latest
source ./emsdk_env.sh
```

## Compile the C-SIMD application to Wasm-SIMD binary with emcc

```bash
emcc -g -Oz --llvm-lto 1 -s STANDALONE_WASM -s INITIAL_MEMORY=32MB -s MAXIMUM_MEMORY=4GB \
  -mmutable-globals \
  -mnontrapping-fptoint \
  -msign-ext \
  mandelbrot-simd.c -o mandelbrot-simd.wasm
```

## Run with WasmEdge

```bash
wasmedge mandelbrot-simd.wasm 15000
```

## Ahead-of-Time mode

With WasmEdge's AoT compiler, you will get higher performance.

```bash
# Compile wasm-simd with wasmedge aot compiler
$ wasmedge compile mandelbrot-simd.wasm mandelbrot-simd-out.wasm
# Run the native binary with wasmedge
$ wasmedge mandelbrot-simd-out.wasm 15000
```
","**Summary**

This code provides a WebAssembly SIMD (Single Instruction Multiple Data) example in C, using the SIMD proposal to improve performance. The example uses the Mandelbrot Set application and demonstrates how to compile and run it with WasmEdge and Emscripten.

**Key Components**

1. **Prerequisites**: Installation of WasmEdge and Emscripten toolchain.
2. **Compilation**: Compilation of C-SIMD source code `mandelbrot-simd.c` using Emscripten's `emcc` compiler to generate a Wasm-SIMD binary.
3. **Run with WasmEdge**: Running the generated Wasm-SIMD binary with WasmEdge.
4. **Ahead-of-Time (AoT) compilation**: Compiling the Wasm-SIMD binary with WasmEdge's AoT compiler for higher performance.

**Potential Issues**

1. **Complexity**: The code requires knowledge of Emscripten, WebAssembly SIMD, and WasmEdge, which may be challenging to grasp for beginners.
2. **Performance variability**: Performance improvements due to SIMD instructions may not be consistent across different hardware platforms or use cases.
3. **Toolchain compatibility**: Compatibility issues between Emscripten and WasmEdge versions may arise.

**Areas for Improvement**

1. **Simplified compilation process**: Streamlining the compilation process using scripts or automated build tools.
2. **Optimized performance settings**: Experimenting with different compiler flags to achieve better performance results.
3. **Multi-threading support**: Enhancing the code to utilize multiple cores and improve parallel processing capabilities."
i18n/zh/docusaurus-plugin-content-docs/current/develop/c/simd.md,"---
sidebar_position: 4
---

# WebAssembly SIMD Example in C

[128-bit packed Single Instruction Multiple Data (SIMD)](https://webassembly.github.io/simd/core/syntax/instructions.html#simd-instructions) instructions provide simultaneous computations over packed data in just one instruction. It's commonly used to improve performance for multimedia applications. With the SIMD proposal, the modules can benefit from using these commonly used instructions in modern hardware to gain more speedup.

If you are interested in enabling the SIMD proposal will improve how much performance of the applications, please refer to our [wasm32-wasi benchmark](https://github.com/second-state/wasm32-wasi-benchmark) for more information. The Mandelbrot Set application can have a **2.65x** speedup in our benchmark.

We modified the Mandelbrot Set example from our [wasm32-wasi benchmark project](https://github.com/second-state/wasm32-wasi-benchmark/blob/master/src/mandelbrot.c). We will use this as an example in this article.

## Prerequisites

Before we start, make sure you have installed the following software:

1. [Install WasmEdge](../../start/install.md#install)

2. Emscripten, a toolchain for compiling C/C++ to WebAssembly. Please refer to the [emcc official repository](https://github.com/emscripten-core/emsdk) for detailed instructions.

```bash
git clone --depth 1 https://github.com/emscripten-core/emsdk.git
cd emsdk
./emsdk install latest
./emsdk activate latest
source ./emsdk_env.sh
```

## Compile the C-SIMD application to Wasm-SIMD binary with emcc

```bash
emcc -g -Oz --llvm-lto 1 -s STANDALONE_WASM -s INITIAL_MEMORY=32MB -s MAXIMUM_MEMORY=4GB \
  -mmutable-globals \
  -mnontrapping-fptoint \
  -msign-ext \
  mandelbrot-simd.c -o mandelbrot-simd.wasm
```

## Run with WasmEdge

```bash
wasmedge mandelbrot-simd.wasm 15000
```

## Ahead-of-Time mode

With WasmEdge's AoT compiler, you will get higher performance.

```bash
# Compile wasm-simd with wasmedge aot compiler
$ wasmedge compile mandelbrot-simd.wasm mandelbrot-simd-out.wasm
# Run the native binary with wasmedge
$ wasmedge mandelbrot-simd-out.wasm 15000
```
","**Code Summary**

This code is a tutorial on using WebAssembly SIMD (Single Instruction Multiple Data) instructions in C to improve performance for multimedia applications. The tutorial provides an example of modifying the Mandelbrot Set application to use SIMD instructions, resulting in a significant speedup.

**Key Components**

1. **Prerequisites**: The code requires WasmEdge and Emscripten to be installed.
2. **Compilation**: The C-SIMD application is compiled using emcc (Emscripten compiler) with various flags to enable SIMD instructions.
3. **Run**: The resulting Wasm-SIMD binary is run using WasmEdge.
4. **Ahead-of-Time (AoT) mode**: An optional step that uses the WasmEdge AoT compiler for further performance optimization.

**Potential Issues**

1. **Dependence on specific toolchains**: The code depends on Emscripten and WasmEdge, which might require additional setup or installation.
2. **Compilation flags complexity**: The emcc compilation flags are complex and may be difficult to understand or modify.
3. **Limited platform support**: WebAssembly SIMD instructions and the required toolchain might have limited platform support.

**Improvement Areas**

1. **Simplify compilation flags**: Provide a more concise explanation of the emcc compilation flags and possibly suggest alternative approaches.
2. **Provide more detailed setup instructions**: Offer step-by-step setup instructions for Emscripten and WasmEdge to make it easier for users to get started.
3. **Explore alternative toolchains**: Investigate other toolchains or alternatives that can simplify the process of compiling C-SIMD applications to WebAssembly SIMD binaries."
docs/start/overview.md,"---
sidebar_position: 1
displayed_sidebar: startSidebar
---

# Getting Started with WasmEdge

WasmEdge is a lightweight, high-performance, and extensible WebAssembly runtime for cloud-native, edge, and decentralized applications. It powers serverless apps, embedded functions, microservices, udf, smart contracts, and IoT devices. WasmEdge is currently a CNCF (Cloud Native Computing Foundation) Sandbox project.

The WasmEdge Runtime provides a well-defined execution sandbox for its contained WebAssembly bytecode program. The runtime offers isolation and protection for operating system resources (e.g., file system, sockets, environment variables, processes) and memory space. The most important use case for WasmEdge is to safely execute user-defined or community-contributed code as plug-ins in a software product (e.g., SaaS, database, edge nodes, or even blockchain nodes). It enables third-party developers, vendors, suppliers, and community members to extend and customize the software product.

This chapter will introduce how to install and get started with WasmEdge.

We will cover the following content:

- [Install and Uninstall WasmEdge](install.md)
- [Getting Started](/category/getting-started-with-wasmEdge)
- Introduce the [WasmEdge Runtime](/category/what-is-wasmedge)
- Usages of [Running WasmEdge](/category/running-with-wasmedge)
- [Frequently Asked Question](faq.md)
- [Style Guide](style_guide.md) for new contributors 
- [Troubleshooting Guide](troubleshooting_guide.md)

For advanced programming with WasmEdge, please refer to the guides for [developing WASM apps](../develop/overview.md), [Embedding WasmEdge in your apps](../embed/overview.md), or [contributing](../contribute/overview.md) to WasmEdge.

If you find any issues or have any feedback, please reach out to us via the following ways.

- [Discord Chat](https://discord.gg/U4B5sFTkFc)
- [Create a GitHub issue for technical support](https://github.com/WasmEdge/WasmEdge/issues)
- [Submit a GitHub discussion](https://github.com/WasmEdge/WasmEdge/discussions)
- [Follow @realwasmedge on Twitter](https://twitter.com/realwasmedge)
","**Summary**

The provided code is a markdown file (`overview.md`) that serves as an introduction to WasmEdge, a lightweight WebAssembly runtime. The file explains the purpose and functionality of WasmEdge, highlighting its use cases, features, and benefits. It also provides information on how to get started with WasmEdge, including installation, usage, and troubleshooting guides.

**Key Components**

1. **Introduction**: A brief overview of WasmEdge, its history, and its position as a CNCF (Cloud Native Computing Foundation) Sandbox project.
2. **Purpose**: Explanation of the runtime's purpose, providing isolation and protection for operating system resources and memory space.
3. **Use Cases**: Discussion of various use cases where WasmEdge is applicable, including serverless apps, embedded functions, microservices, smart contracts, and IoT devices.
4. **Getting Started**: Information on how to install and get started with WasmEdge, including links to relevant guides.
5. **Advanced Topics**: References to advanced programming topics, such as developing WASM apps, embedding WasmEdge in your apps, or contributing to WasmEdge.

**Potential Issues or Areas for Improvement**

1. **Length**: The file is quite long and may be overwhelming for new users. Breaking it up into smaller sections or using tables of contents could improve readability.
2. **Links**: Some links may become outdated over time. Regular updates and maintenance are necessary to ensure that links remain valid.
3. **Depth of information**: While the file provides a good introduction, some topics, such as advanced programming with WasmEdge, could benefit from more detailed explanations or examples.
4. **Organization**: The use case section feels a bit disorganized, with multiple points listed without clear connections between them.

Overall, the code is well-structured and provides valuable information on getting started with WasmEdge. However, some improvements in organization, links, and depth of information could enhance its usability and effectiveness."
docs/contribute/source/plugin/image.md,"---
sidebar_position: 4
---

# Build WasmEdge With WasmEdge-Image Plug-in

The WasmEdge Image plug-in is a software component that extends the functionality of the WasmEdge runtime, enabling it to load and decode JPEG and PNG images and convert them into tensors. This plug-in is useful for developers who need to process image data within their WebAssembly applications.

## Prerequisites

The prerequisites of the WasmEdge-Image plug-in is the same as the WasmEdge building environment on the [Linux platforms](../os/linux.md) or [MacOS platforms](../os/macos.md).

If developers build with their own environment, please ensure the `zlib` and `libboost-all-dev` are installed.

```bash
sudo apt update
sudo apt install zlib1g-dev libboost-all-dev
```

On MacOS platforms, the `libjpeg` and `libpng` are required.

```bash
brew install jpeg-turbo libpng
```

## Build WasmEdge with WasmEdge-Image Plug-in

To enable the WasmEdge WasmEdge-Image, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_IMAGE=On`.

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_IMAGE=On
cmake --build build
# For the WasmEdge-Image plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WasmEdge-Image plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_image/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-Image plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeImage.so` after installation.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_image).
","**Summary**

This code is a documentation for building WasmEdge with the WasmEdge-Image plug-in, which enables loading and decoding of JPEG and PNG images. The plug-in requires zlib and libboost-all-dev to be installed on Linux platforms or libjpeg and libpng to be installed on MacOS platforms.

**Functionality**

The functionality of this code is to provide instructions for building WasmEdge with the WasmEdge-Image plug-in, including:

1. Installing prerequisites (zlib and libboost-all-dev on Linux, or libjpeg and libpng on MacOS)
2. Building WasmEdge from source with the cmake option `-DWASMEDGE_PLUGIN_IMAGE=On`
3. Installing the built plug-in

**Key Components**

* `cmake`: a build system that generates a build configuration file
* `Ninja`: a fast build tool used by CMake
* `WASMEDGE_PLUGIN_IMAGE`: a CMake option to enable the WasmEdge-Image plug-in
* `zlib` and `libboost-all-dev`: prerequisites for Linux platforms
* `libjpeg` and `libpng`: prerequisites for MacOS platforms

**Potential Issues**

1. The installation of prerequisites may not be straightforward, especially on Linux platforms.
2. The CMake option `-DWASMEDGE_PLUGIN_IMAGE=On` must be used to enable the WasmEdge-Image plug-in during build time.
3. If the built `wasmedge` CLI tool cannot find the WasmEdge-Image plug-in, setting the `WASMEDGE_PLUGIN_PATH` environment variable may resolve the issue.

Overall, this code provides a clear and concise guide for building WasmEdge with the WasmEdge-Image plug-in, which is useful for developers who need to process image data within their WebAssembly applications."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/image.md,"---
sidebar_position: 4
---

# Build WasmEdge With WasmEdge-Image Plug-in

The WasmEdge Image plug-in is a software component that extends the functionality of the WasmEdge runtime, enabling it to load and decode JPEG and PNG images and convert them into tensors. This plug-in is useful for developers who need to process image data within their WebAssembly applications.

## Prerequisites

The prerequisites of the WasmEdge-Image plug-in is the same as the WasmEdge building environment on the [Linux platforms](../os/linux.md) or [MacOS platforms](../os/macos.md).

If developers build with their own environment, please ensure the `zlib` and `libboost-all-dev` are installed.

```bash
sudo apt update
sudo apt install zlib1g-dev libboost-all-dev
```

On MacOS platforms, the `libjpeg` and `libpng` are required.

```bash
brew install jpeg-turbo libpng
```

## Build WasmEdge with WasmEdge-Image Plug-in

To enable the WasmEdge WasmEdge-Image, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_IMAGE=On`.

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_IMAGE=On
cmake --build build
# For the WasmEdge-Image plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WasmEdge-Image plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_image/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-Image plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeImage.so` after installation.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_image).
","**Summary**

The provided code is a documentation for building WasmEdge, a WebAssembly runtime, with the WasmEdge-Image plug-in. The plug-in enables WasmEdge to load and decode JPEG and PNG images into tensors. The documentation outlines the prerequisites for building WasmEdge with the plug-in, which includes installing `zlib` and `libboost-all-dev` on Linux or MacOS platforms.

**Key Components**

1. **Prerequisites**: The prerequisites for building WasmEdge with the WasmEdge-Image plug-in.
2. **Building WasmEdge with WasmEdge-Image Plug-in**: The steps to build WasmEdge from source with the plug-in enabled.
3. **Troubleshooting**: A note about setting the `WASMEDGE_PLUGIN_PATH` environment variable if the built `wasmedge` CLI tool cannot find the WasmEdge-Image plug-in.

**Potential Issues**

1. **Outdated instructions**: The documentation assumes a specific version of WasmEdge and may not be applicable to newer versions.
2. **Missing dependencies**: If the reader misses installing `zlib` or `libboost-all-dev`, they may encounter issues building WasmEdge with the plug-in.

**Areas for Improvement**

1. **Versioning**: The documentation should include specific version numbers for WasmEdge and its dependencies to ensure compatibility.
2. **Clearer instructions**: Some steps, such as setting environment variables, could be made clearer with more explicit instructions.
3. **Additional troubleshooting information**: Providing additional tips or resources for resolving common issues would make the documentation more helpful to readers."
docs/contribute/source/plugin/process.md,"---
sidebar_position: 3
---

# Build WasmEdge With WasmEdge-Process Plug-in

The WasmEdge Process plug-in provides a sandboxed environment to execute system processes in a secured manner. This guide will walk you through the steps to build the WasmEdge Process plug-in.

## Prerequisites

The prerequisites of the WasmEdge-Process plug-in is the same as the [WasmEdge building environment on the Linux platforms](../os/linux.md).

## Build WasmEdge with WasmEdge-Process Plug-in

To enable the WasmEdge WasmEdge-Process, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_PROCESS=On`.

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_PROCESS=On
cmake --build build
# For the WasmEdge-Process plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WasmEdge-Process plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_process/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-Process plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeProcess.so` after installation.

## Usage

To use the plug-in with WasmEdge, you need to specify it when starting the WasmEdge runtime:

```bash
wasmedge --dir .:. --reactor --process_plugin target/release/libwasmedge_process.so your_wasm_file.wasm
```

Replace `your_wasm_file.wasm` with the path to your WebAssembly file. The `--process_plugin`flag specifies the path to the Process plug-in.

That's it! You have successfully built and installed the WasmEdge Process plug-in.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_process).
","**Summary**

The provided code is a guide to building the WasmEdge Process plug-in, which provides a sandboxed environment to execute system processes in a secured manner. The plug-in can be built and installed using CMake and Ninja build tools.

**Key Components**

1. **Prerequisites**: The prerequisites for building the WasmEdge-Process plug-in are the same as building WasmEdge from source on Linux platforms.
2. **Building WasmEdge with WasmEdge-Process Plug-in**: To enable the WasmEdge Process plug-in, developers need to build WasmEdge from source using CMake and Ninja, specifying the `-DWASMEDGE_PLUGIN_PROCESS=On` option.
3. **Installation**: After building, the plug-in can be installed using `cmake --install build`.
4. **Usage**: To use the plug-in with WasmEdge, developers need to specify it when starting the WasmEdge runtime using the `--process_plugin` flag.

**Potential Issues or Areas for Improvement**

1. **Error handling**: The provided code does not handle errors that may occur during building and installation.
2. **Plugin path**: The code assumes that the plug-in will be installed in `/usr/local/lib/wasmedge/`, but this might not be the case on all systems.
3. **Environment variable**: The code suggests setting the `WASMEDGE_PLUGIN_PATH` environment variable to fix issues with finding the WasmEdge-Process plug-in, but this is not a reliable solution.
4. **Documentation**: While the provided code is well-documented, it would be beneficial to include more information about the plug-in's functionality and use cases.

Overall, the provided code provides a clear guide to building and installing the WasmEdge Process plug-in, but some minor improvements could make it even more robust and user-friendly."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/plugin/process.md,"---
sidebar_position: 3
---

# Build WasmEdge With WasmEdge-Process Plug-in

The WasmEdge Process plug-in provides a sandboxed environment to execute system processes in a secured manner. This guide will walk you through the steps to build the WasmEdge Process plug-in.

## Prerequisites

The prerequisites of the WasmEdge-Process plug-in is the same as the [WasmEdge building environment on the Linux platforms](../os/linux.md).

## Build WasmEdge with WasmEdge-Process Plug-in

To enable the WasmEdge WasmEdge-Process, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_PROCESS=On`.

```bash
cd <path/to/your/wasmedge/source/folder>
cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_PROCESS=On
cmake --build build
# For the WasmEdge-Process plug-in, you should install this project.
cmake --install build
```

<!-- prettier-ignore -->
:::note
If the built `wasmedge` CLI tool cannot find the WasmEdge-Process plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_process/`) to try to fix this issue.
:::

Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-Process plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeProcess.so` after installation.

## Usage

To use the plug-in with WasmEdge, you need to specify it when starting the WasmEdge runtime:

```bash
wasmedge --dir .:. --reactor --process_plugin target/release/libwasmedge_process.so your_wasm_file.wasm
```

Replace `your_wasm_file.wasm` with the path to your WebAssembly file. The `--process_plugin`flag specifies the path to the Process plug-in.

That's it! You have successfully built and installed the WasmEdge Process plug-in.

For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_process).
","**Summary**

The provided code is a guide on building and using the WasmEdge Process plug-in for WebAssembly (WASM) development. The plug-in provides a sandboxed environment to execute system processes in a secured manner.

**Key Components**

1. **Prerequisites**: Building the WasmEdge Process plug-in requires the same environment as building WasmEdge from source on Linux platforms.
2. **Building WasmEdge with WasmEdge-Process Plug-in**: The guide explains how to build WasmEdge from source with the cmake option `-DWASMEDGE_PLUGIN_PROCESS=On`.
3. **Usage**: The plug-in is used by specifying it when starting the WasmEdge runtime, using the `--process_plugin` flag and providing the path to the Process plug-in.

**Potential Issues or Areas for Improvement**

1. **Error Handling**: The guide does not provide any information on error handling when building or using the WasmEdge Process plug-in.
2. **Debugging**: There is no mention of how to debug issues related to the plug-in or WasmEdge.
3. **Plugin Installation**: The guide assumes that the plug-in will be installed in a specific location (`/usr/local/lib/wasmedge/`), but it does not provide information on how to install the plug-in manually if this is not possible.
4. **Environment Variable**: The use of environment variable `WASMEDGE_PLUGIN_PATH` is mentioned as a potential solution for fixing issues with finding the WasmEdge-Process plug-in, but its usage and implications are not fully explained.

Overall, while the guide provides a good overview of building and using the WasmEdge Process plug-in, there are areas that could be improved to make it more comprehensive and user-friendly."
docs/start/wasmedge/comparison.md,"---
sidebar_position: 5
---

# Comparison

## What's the relationship between WebAssembly and Docker?

Check out our infographic [WebAssembly vs. Docker](https://wasmedge.org/wasm_linux_container/). WebAssembly runs side by side with Docker in cloud native and edge native applications.

## What's the difference for Native clients (NaCl), Application runtimes, and WebAssembly?

We created a handy table for the comparison.

|  | NaCl | Application runtimes (eg Node &amp; Python) | Docker-like container | WebAssembly |
| --- | --- | --- | --- | --- |
| Performance | Great | Poor | OK | Great |
| Resource footprint | Great | Poor | Poor | Great |
| Isolation | Poor | OK | OK | Great |
| Safety | Poor | OK | OK | Great |
| Portability | Poor | Great | OK | Great |
| Security | Poor | OK | OK | Great |
| Language and framework choice | N/A | N/A | Great | OK |
| Ease of use | OK | Great | Great | OK |
| Manageability | Poor | Poor | Great | Great |

## What's the difference between WebAssembly and eBPF?

`eBPF` is the bytecode format for a Linux kernel space VM that is suitable for network or security related tasks. WebAssembly is the bytecode format for a user space VM that is suited for business applications. [See details here](https://medium.com/codex/ebpf-and-webassembly-whose-vm-reigns-supreme-c2861ce08f89).
","**Summary**

The provided code is a Markdown document that serves as a comparison guide between various technologies, including WebAssembly, Docker, NaCl (Native clients), application runtimes (e.g., Node and Python), and eBPF. The document aims to provide an overview of the differences and similarities among these technologies in terms of performance, resource footprint, isolation, safety, portability, security, language and framework choice, ease of use, and manageability.

**Key Components**

1. **WebAssembly**: A binary format that runs code on web browsers or native environments with great performance, small footprint, excellent isolation, and high level of safety.
2. **Docker-like container**: A technology for running multiple isolated applications in a single environment with OK performance, poor resource footprint, good isolation, and decent security features.
3. **Application runtimes (e.g., Node & Python)**: Interpreted languages that have poor performance, large resource footprint, moderate isolation, and decent safety features.
4. **NaCl (Native clients)**: A technology for running native code in web browsers with great performance, small resource footprint, poor isolation, and low level of safety.
5. **eBPF**: A bytecode format for a Linux kernel space VM with poor performance, large resource footprint, excellent isolation, and high level of safety.

**Potential Issues or Areas for Improvement**

1. The table-based comparison might be overwhelming for readers unfamiliar with the technologies.
2. Some of the categories (e.g., language and framework choice) are not clearly defined or explained.
3. There is a lack of concrete examples or use cases to illustrate the differences between these technologies.

**Recommendations**

1. Consider adding more concise and focused sections to break up the content and make it easier to read.
2. Provide additional explanations or resources for readers who want to learn more about the underlying technologies.
3. Incorporate concrete examples or case studies to demonstrate the benefits and trade-offs of each technology."
docs/develop/javascript/es6.md,"---
sidebar_position: 6
---

# ES6 Modules

The WasmEdge QuickJS runtime supports ES6 modules. The roll-up commands we used in the [React SSR](ssr) examples convert and bundle CommonJS and NPM modules into ES6 modules to execute in WasmEdge QuickJS. This article will show you how to use the ES6 module in WasmEdge.

## Prerequisites

[See here](./hello_world#prerequisites)

## Run the example

We will take the example in [example_js/es6_module_demo](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/es6_module_demo) folder as an example. To run the example, you can do the following on the CLI.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/es6_module_demo/demo.js
hello from module_def.js
hello from module_def_async.js
./module_def_async.js `something` is  async thing
```

<!-- prettier-ignore -->
:::note
Make sure that you run those commands from the `wasmedge-quickjs` directory. [Here is why](./hello_world#prerequisites)
:::

## Code Explanation

The [module_def.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def.js) file defines and exports a simple JS function.

```javascript
function hello() {
  console.log('hello from module_def.js');
}

export { hello };
```

The [module_def_async.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def_async.js) file defines and exports an async function and a variable.

```javascript
export async function hello() {
  console.log('hello from module_def_async.js');
  return 'module_def_async.js : return value';
}

export var something = 'async thing';
```

The [demo.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/demo.js) file imports functions and variables from those modules and executes them.

```javascript
import { hello as module_def_hello } from './module_def.js';

module_def_hello();

var f = async () => {
  let { hello, something } = await import('./module_def_async.js');
  await hello();
  console.log('./module_def_async.js `something` is ', something);
};

f();
```
","**Summary**

This documentation provides an overview of using ES6 modules with the WasmEdge QuickJS runtime. The article explains how to convert and bundle CommonJS and NPM modules into ES6 modules to execute in WasmEdge QuickJS, using the example code from `example_js/es6_module_demo`.

**Key Components**

*   The example uses two ES6 modules: `module_def.js` and `module_def_async.js`.
*   `module_def.js` exports a simple JavaScript function `hello()` that logs a message to the console.
*   `module_def_async.js` exports an asynchronous function `hello()` and a variable `something`, both of which are used in the demo code.
*   The `demo.js` file imports functions and variables from these modules, executes them, and demonstrates how to use ES6 module imports.

**Potential Issues or Areas for Improvement**

1.  **Code Organization**: While the example code is organized into separate files for each module, it would be beneficial to include more documentation on how to structure larger projects using this approach.
2.  **Error Handling**: The demo code does not handle any errors that may occur during import or execution of the modules. Consider adding try-catch blocks to demonstrate error handling and provide a better user experience.
3.  **Security**: As with any JavaScript code, ensure proper input validation and sanitization when importing and executing ES6 modules from external sources.
4.  **Performance Optimization**: The example code is not optimized for performance. Consider exploring techniques like lazy loading or caching to improve the execution time of large projects.

Overall, this documentation provides a solid introduction to using ES6 modules with WasmEdge QuickJS, and the example code serves as a good starting point for building more complex applications."
i18n/zh/docusaurus-plugin-content-docs/current/develop/javascript/es6.md,"---
sidebar_position: 6
---

# ES6 Modules

The WasmEdge QuickJS runtime supports ES6 modules. The roll-up commands we used in the [React SSR](ssr) examples convert and bundle CommonJS and NPM modules into ES6 modules to execute in WasmEdge QuickJS. This article will show you how to use the ES6 module in WasmEdge.

## Prerequisites

[See here](./hello_world#prerequisites)

## Run the example

We will take the example in [example_js/es6_module_demo](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/es6_module_demo) folder as an example. To run the example, you can do the following on the CLI.

```bash
$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/es6_module_demo/demo.js
hello from module_def.js
hello from module_def_async.js
./module_def_async.js `something` is  async thing
```

<!-- prettier-ignore -->
:::note
Make sure that you run those commands from the `wasmedge-quickjs` directory. [Here is why](./hello_world#prerequisites)
:::

## Code Explanation

The [module_def.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def.js) file defines and exports a simple JS function.

```javascript
function hello() {
  console.log('hello from module_def.js');
}

export { hello };
```

The [module_def_async.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def_async.js) file defines and exports an async function and a variable.

```javascript
export async function hello() {
  console.log('hello from module_def_async.js');
  return 'module_def_async.js : return value';
}

export var something = 'async thing';
```

The [demo.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/demo.js) file imports functions and variables from those modules and executes them.

```javascript
import { hello as module_def_hello } from './module_def.js';

module_def_hello();

var f = async () => {
  let { hello, something } = await import('./module_def_async.js');
  await hello();
  console.log('./module_def_async.js `something` is ', something);
};

f();
```
","**Summary**

This code is a documentation page for using ES6 modules in the WasmEdge QuickJS runtime. It provides a step-by-step guide on how to use ES6 modules, including setting up prerequisites, running examples, and explaining the code behind it.

**Key Components**

1. **ES6 Module Support**: The WasmEdge QuickJS runtime supports ES6 modules.
2. **Prerequisites**: A link to another documentation page that outlines the necessary setup for using WasmEdge QuickJS.
3. **Run Example**: A command to run an example using the `wasmedge` CLI, demonstrating how to execute ES6 module code in WasmEdge QuickJS.
4. **Code Explanation**: An explanation of three JavaScript files: `module_def.js`, `module_def_async.js`, and `demo.js`. Each file is linked to a GitHub repository and includes code examples.

**Potential Issues or Areas for Improvement**

1. **Inconsistent Formatting**: The code snippets in the documentation have different formatting styles, which may make them harder to read.
2. **Lack of Context**: Some explanations assume prior knowledge of WasmEdge QuickJS and its ecosystem, making it challenging for readers without this context to understand the example code.
3. **No Error Handling**: The `demo.js` file does not include error handling mechanisms, which may lead to unexpected behavior or crashes if the imports or executions fail.
4. **Code Duplication**: The `module_def.js` and `module_def_async.js` files have similar export structures, which could be refactored for better maintainability.

**Recommendations**

1. Standardize code formatting throughout the documentation.
2. Provide more context and explanations for readers new to WasmEdge QuickJS.
3. Include error handling mechanisms in the example code (e.g., try-catch blocks).
4. Consider refactoring the code structure to minimize duplication and improve maintainability."
docs/develop/rust/command.md,"---
sidebar_position: 11
---

# Command interface

WASI enables WebAssembly programs to call standard library functions in the host operating system. It does so through a fine-grained security model known as “capability-based security”. The WebAssembly VM owner can grant access to host system resources when the VM starts. The program cannot access resources (e.g., file folders) that are not explicitly allowed.

Now, why limit ourselves to standard library functions? The same approach can call just any host function from WebAssembly. WasmEdge provides a WASI-like extension to access command line programs in the host operating system.

The command line program can

- Take input via command line arguments and the `STDIN` stream.
- Return value and data via the `STDOUT` stream.

Application developers for WasmEdge can use our Rust interface crate to access this functionality. In `Cargo.toml`, ensure you have this dependency.

```toml
[dependencies]
wasmedge_process_interface = ""0.2.1""
```

In the Rust application, you can now use the API methods to start a new process for the operating system command program, pass in arguments via the `arg()` method as well as via the `STDIN`, and receives the return values via the `STDOUT`.

```rust
let mut cmd = Command::new(""http_proxy"");

cmd.arg(""post"")
   .arg(""https://api.sendgrid.com/v3/mail/send"")
   .arg(auth_header);
cmd.stdin_u8vec(payload.to_string().as_bytes());

let out = cmd.output();
```

The Rust function is then compiled into WebAssembly and can run in the WasmEdge like the [hello world](hello_world.md) chapter.
","**Summary**

The code provides a Rust interface for interacting with command-line programs on the host operating system using WasmEdge's WASI-like extension. This allows WebAssembly programs to call any host function, not just standard library functions.

**Key Components**

1. The `wasmedge_process_interface` crate is used as a dependency in `Cargo.toml`.
2. The `Command` struct provides methods for creating and configuring a new process.
3. Methods include:
	* `arg()`: passing command-line arguments to the process.
	* `stdin_u8vec()`: sending input data (in this case, bytes) to the process via STDIN.
4. The `output()` method is used to receive the return values from the process via STDOUT.

**Purpose**

The purpose of this code is to enable WebAssembly programs running on WasmEdge to interact with command-line programs on the host operating system. This can be useful for applications that need to perform system-level tasks, such as sending emails or making HTTP requests.

**Potential Issues/Improvements**

1. **Error handling**: The example does not demonstrate error handling. In a real-world scenario, it's essential to handle potential errors when interacting with external processes.
2. **Security**: As with any external process interaction, there are security implications to consider. Ensure that the process being executed is trusted and validated.
3. **Performance**: If the command-line program is resource-intensive or has long-running operations, it may impact the performance of the WebAssembly application.
4. **Documentation**: The example code could benefit from additional comments and documentation to help users understand how to use the `Command` struct effectively.

Overall, this code provides a useful interface for interacting with command-line programs on WasmEdge, but careful consideration should be given to error handling, security, performance, and documentation."
i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/command.md,"---
sidebar_position: 11
---

# Command interface

WASI enables WebAssembly programs to call standard library functions in the host operating system. It does so through a fine-grained security model known as “capability-based security”. The WebAssembly VM owner can grant access to host system resources when the VM starts. The program cannot access resources (e.g., file folders) that are not explicitly allowed.

Now, why limit ourselves to standard library functions? The same approach can call just any host function from WebAssembly. WasmEdge provides a WASI-like extension to access command line programs in the host operating system.

The command line program can

- Take input via command line arguments and the `STDIN` stream.
- Return value and data via the `STDOUT` stream.

Application developers for WasmEdge can use our Rust interface crate to access this functionality. In `Cargo.toml`, ensure you have this dependency.

```toml
[dependencies]
wasmedge_process_interface = ""0.2.1""
```

In the Rust application, you can now use the API methods to start a new process for the operating system command program, pass in arguments via the `arg()` method as well as via the `STDIN`, and receives the return values via the `STDOUT`.

```rust
let mut cmd = Command::new(""http_proxy"");

cmd.arg(""post"")
   .arg(""https://api.sendgrid.com/v3/mail/send"")
   .arg(auth_header);
cmd.stdin_u8vec(payload.to_string().as_bytes());

let out = cmd.output();
```

The Rust function is then compiled into WebAssembly and can run in the WasmEdge like the [hello world](hello_world.md) chapter.
","**Summary**

This code is a part of the Docusaurus documentation for the WasmEdge project, specifically detailing how to use the `wasmedge_process_interface` Rust crate to interact with command-line programs on the host operating system from within WebAssembly (WASM) applications.

**Key Components**

1. The WASM interface allows developers to run host OS commands as part of a WASM application.
2. The code uses the `wasmedge_process_interface` Rust crate to access this functionality.
3. Developers can use API methods to start new processes for command-line programs, passing arguments and receiving output.

**Functionality**

1. **Command creation**: Create a new process for running a command using the `Command::new()` method.
2. **Argument passing**: Pass arguments to the command using the `arg()` method.
3. **Input/output handling**: Use `stdin_u8vec()` to pass input data and `output()` to receive the return value of the command.

**Potential Issues or Areas for Improvement**

1. Error handling: The code does not demonstrate error handling mechanisms, which is crucial when interacting with external processes and OS resources.
2. Security considerations: As this allows execution of arbitrary host commands from within WASM, additional security measures might be necessary to prevent potential exploits.
3. Documentation completeness: While the provided code snippet is self-explanatory, it would be beneficial to provide more detailed documentation on how to use the `wasmedge_process_interface` crate and its API methods.

**Notes**

This summary is based on the provided Markdown file. The actual code might be located elsewhere in the project repository."
docs/develop/deploy/kubernetes/docker-slim.md,"---
sidebar_position: 11
---

# WasmEdge DockerSlim

The `wasmedge/slim:{version}` Docker images provide slim WasmEdge images built with [DockerSlim](https://dockersl.im) every release.

- Image `wasmedge/slim-runtime:{version}` includes only WasmEdge runtime with `wasmedge` command.
- Image `wasmedge/slim:{version}` includes the following command line utilities:
  - `wasmedge`
  - `wasmedge compile`
- Image `wasmedge/slim-tf:{version}` includes the following command line utilities:
  - `wasmedge`
  - `wasmedge compile`
  - `wasmedge-tensorflow-lite`
  - `wasmedge-tensorflow`
  - `show-tflite-tensor`
- The working directory of the release docker image is `/app`.

<!-- prettier-ignore -->
:::note
The usage of `wasmedgec` is equal to `wasmedge compile`. We decide to deprecate `wasmedgec` in the future.
:::

## Examples

Use `wasmedge compile` and `wasmedge` ([link](https://github.com/WasmEdge/WasmEdge/tree/master/examples/wasm)):

```bash
$ docker pull wasmedge/slim:{{ wasmedge_version }}

$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge compile hello.wasm hello.aot.wasm
[2022-07-07 08:15:49.154] [info] compile start
[2022-07-07 08:15:49.163] [info] verify start
[2022-07-07 08:15:49.169] [info] optimize start
[2022-07-07 08:15:49.808] [info] codegen start
[2022-07-07 08:15:50.419] [info] output start
[2022-07-07 08:15:50.421] [info] compile done
[2022-07-07 08:15:50.422] [info] output start

$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge hello.aot.wasm world
hello
world
```

Use `wasmedge-tensorflow-lite` ([link](https://github.com/WasmEdge/WasmEdge/tree/master/examples/js)):

```bash
$ docker pull wasmedge/slim-tf:{{ wasmedge_version }}
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js

$ docker run -it --rm -v $PWD:/app wasmedge/slim-tf:{{ wasmedge_version }} wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js
label:
Hot dog
confidence:
0.8941176470588236
```
","**Summary**

The provided code documents the usage of `wasmedge/slim:{version}` Docker images, which are slim WasmEdge images built with DockerSlim. These images include various command-line utilities for compiling and running WebAssembly (WASM) code.

**Key Components**

1. **Docker Images**: Three types of Docker images are available:
	* `wasmedge/slim-runtime:{version}`: includes only the WasmEdge runtime with the `wasmedge` command.
	* `wasmedge/slim:{version}`: includes `wasmedge`, `wasmedge compile` utilities.
	* `wasmedge/slim-tf:{version}`: includes all the above utilities plus `wasmedge-tensorflow-lite`, `wasmedge-tensorflow`, and `show-tflite-tensor`.
2. **Working Directory**: The working directory of the release Docker image is `/app`.

**Examples**

Two examples are provided:

1. Compiling a WASM file using `wasmedge compile`:
```bash
$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge compile hello.wasm hello.aot.wasm
```
2. Running a TensorFlow Lite model using `wasmedge-tensorflow-lite`:
```bash
$ docker run -it --rm -v $PWD:/app wasmedge/slim-tf:{{ wasmedge_version }} wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js
```
**Notes**

* The usage of `wasmedgec` is deprecated in favor of `wasmedge compile`.
* The examples use Docker to run the WASM code and demonstrate how to compile and run a simple WASM program.
* The `wasmedge-tensorflow-lite` example requires additional dependencies, such as a TensorFlow Lite model and some JavaScript code.

**Potential Issues or Areas for Improvement**

1. **Docker Image Size**: The DockerSlim images are slim, but their size might still be larger than expected. Consider using other image optimization tools.
2. **Deprecation of `wasmedgec`**: Although deprecated, it's essential to ensure that users are aware of the replacement and don't rely on the old command.
3. **Additional Dependencies**: The TensorFlow Lite example requires additional dependencies, which might not be immediately apparent from the documentation.
4. **Documentation Updates**: Ensure that the documentation is up-to-date and reflects any changes or improvements made to the Docker images or examples."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/docker-slim.md,"---
sidebar_position: 11
---

# WasmEdge DockerSlim

The `wasmedge/slim:{version}` Docker images provide slim WasmEdge images built with [DockerSlim](https://dockersl.im) every release.

- Image `wasmedge/slim-runtime:{version}` includes only WasmEdge runtime with `wasmedge` command.
- Image `wasmedge/slim:{version}` includes the following command line utilities:
  - `wasmedge`
  - `wasmedge compile`
- Image `wasmedge/slim-tf:{version}` includes the following command line utilities:
  - `wasmedge`
  - `wasmedge compile`
  - `wasmedge-tensorflow-lite`
  - `wasmedge-tensorflow`
  - `show-tflite-tensor`
- The working directory of the release docker image is `/app`.

<!-- prettier-ignore -->
:::note
The usage of `wasmedgec` is equal to `wasmedge compile`. We decide to deprecate `wasmedgec` in the future.
:::

## Examples

Use `wasmedge compile` and `wasmedge` ([link](https://github.com/WasmEdge/WasmEdge/tree/master/examples/wasm)):

```bash
$ docker pull wasmedge/slim:{{ wasmedge_version }}

$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge compile hello.wasm hello.aot.wasm
[2022-07-07 08:15:49.154] [info] compile start
[2022-07-07 08:15:49.163] [info] verify start
[2022-07-07 08:15:49.169] [info] optimize start
[2022-07-07 08:15:49.808] [info] codegen start
[2022-07-07 08:15:50.419] [info] output start
[2022-07-07 08:15:50.421] [info] compile done
[2022-07-07 08:15:50.422] [info] output start

$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge hello.aot.wasm world
hello
world
```

Use `wasmedge-tensorflow-lite` ([link](https://github.com/WasmEdge/WasmEdge/tree/master/examples/js)):

```bash
$ docker pull wasmedge/slim-tf:{{ wasmedge_version }}
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js

$ docker run -it --rm -v $PWD:/app wasmedge/slim-tf:{{ wasmedge_version }} wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js
label:
Hot dog
confidence:
0.8941176470588236
```
","**Summary**

The provided code is a documentation for WasmEdge DockerSlim images. It explains the purpose and functionality of three different images:

1. `wasmedge/slim-runtime:{version}`: A slim WasmEdge image with only the runtime and `wasmedge` command.
2. `wasmedge/slim:{version}`: A slim WasmEdge image with additional command line utilities, including `wasmedge`, `wasmedge compile`, and possibly others in the future.
3. `wasmedge/slim-tf:{version}`: A slim WasmEdge image with TensorFlow Lite and TensorFlow support.

The documentation provides examples of using these images to run WasmEdge commands and demonstrates how to use specific features, such as compiling and running Wasm files and running TensorFlow Lite models.

**Key Components**

1. **Images**: The three Docker images are the primary focus of this documentation.
2. **Commands**: Various `wasmedge` commands are used throughout the examples, including `wasmedge compile`, `wasmedge`, `wasmedge-tensorflow-lite`, and others.
3. **Examples**: Real-world usage scenarios are provided to demonstrate how to use these images and commands.

**Potential Issues or Areas for Improvement**

1. **Lack of explicit dependencies**: While the examples rely on specific versions of Docker, WasmEdge, and other tools, the documentation does not explicitly list these dependencies.
2. **Assumed familiarity with Docker**: The examples assume a basic understanding of Docker and how to work with images, which may be a barrier for some readers.
3. **Missing context**: Some sections, such as the deprecation note about `wasmedgec`, feel disconnected from the rest of the documentation without additional context.

**Suggestions**

1. **Add explicit dependencies**: List the specific versions of Docker, WasmEdge, and other tools required to run these examples.
2. **Improve example clarity**: Consider breaking down complex examples into smaller, more manageable chunks or providing additional explanations for readers who may be new to Docker or WasmEdge.
3. **Provide additional context**: Connect related sections or add a brief introduction to explain the purpose of each image and its relationship to other WasmEdge features."
docs/embed/overview.md,"---
sidebar_position: 1
displayed_sidebar: embedSidebar
---

# Embed WasmEdge in Your Apps

As we mentioned before, the most important use case for WasmEdge is to safely execute user-defined or community-contributed code as plug-ins in a software product. It enables third-party developers, vendors, suppliers, and community members to extend and customize the software product.

We could use WasmEdge as a standalone container and deploy WasmEdge using the existing containers tools. The other way is to use WasmEdge as an embedded runtime and manage WasmEdge using the host applications.

WasmEdge provides SDKs for various programming languages. The WasmEdge library allows developers to embed the WasmEdge into their host applications, so that the WebAssembly applications can be executed in the WasmEdge sandbox safely. Furthermore, developers can implement the host functions for the extensions with the WasmEdge library.

![Embeded architecture](embed_arch.png)

In this section, we will walk you through how to embed WasmEdge in different languages. We will cover the following content:

- [Quick Start](/category/quick-start)
- [Passing complex data](/category/passing-complex-data)
- [Developing components using witc](witc.md)
- [Embed WasmEdge in C/C++](/category/c-sdk-for-embedding-wasmedge)
- [Embed WasmEdge in Rust](/category/rust-sdk-for-embedding-wasmedge)
- [Embed WasmEdge in Go](/category/go-sdk-for-embedding-wasmedge)
- [Embed WasmEdge in Java](/category/java-sdk-for-embedding-wasmedge)
- [Embed WasmEdge in Python](/category/python-sdk-for-embedding-wasmedge)
- [Use cases](/category/use-cases)

Besides this, we also have two more guides for [developing WASM apps](../develop/overview.md) and [contributing to WasmEdge](../contribute/overview.md).
","**Summary**

The provided code is a documentation section titled ""Embed WasmEdge in Your Apps"" from the docs/embed/overview.md file. It explains the purpose and functionality of embedding WasmEdge, a WebAssembly runtime, into various applications.

**Key Components**

1. **WasmEdge**: A WebAssembly runtime that allows for safe execution of user-defined or community-contributed code as plug-ins.
2. **Embedded Architecture**: An illustration showing how to embed WasmEdge in host applications.
3. **SDKs for Various Programming Languages**: Pre-built libraries for embedding WasmEdge into applications written in C/C++, Rust, Go, Java, and Python.

**Purpose**

The main goal of this documentation section is to guide developers through the process of embedding WasmEdge into their applications, providing SDKs and examples for various programming languages. It aims to enable developers to safely execute WebAssembly applications within their host applications.

**Potential Issues or Areas for Improvement**

1. **Lack of Code Examples**: While the documentation provides an overview of the process, it would be beneficial to include code examples for each programming language to help developers understand how to implement WasmEdge in their projects.
2. **SDKs and Libraries**: Although mentioned as being available, there is no information on where to download or access these SDKs and libraries, which may cause confusion for developers looking to integrate WasmEdge into their applications.
3. **Documentation Organization**: The documentation seems to be organized around different programming languages, but it would be more user-friendly if it were organized by use case or application type instead.

Overall, the provided code is a solid foundation for documenting how to embed WasmEdge in various applications. However, adding code examples and improving SDK accessibility will make this documentation more comprehensive and helpful for developers seeking to integrate WasmEdge into their projects."
i18n/zh/docusaurus-plugin-content-docs/current/embed/overview.md,"---
sidebar_position: 1
displayed_sidebar: embedSidebar
---

# Embed WasmEdge in Your Apps

As we mentioned before, the most important use case for WasmEdge is to safely execute user-defined or community-contributed code as plug-ins in a software product. It enables third-party developers, vendors, suppliers, and community members to extend and customize the software product.

We could use WasmEdge as a standalone container and deploy WasmEdge using the existing containers tools. The other way is to use WasmEdge as an embedded runtime and manage WasmEdge using the host applications.

WasmEdge provides SDKs for various programming languages. The WasmEdge library allows developers to embed the WasmEdge into their host applications, so that the WebAssembly applications can be executed in the WasmEdge sandbox safely. Furthermore, developers can implement the host functions for the extensions with the WasmEdge library.

![Embeded architecture](embed_arch.png)

In this section, we will walk you through how to embed WasmEdge in different languages. We will cover the following content:

- [Quick Start](/category/quick-start)
- [Passing complex data](/category/passing-complex-data)
- [Developing components using witc](witc.md)
- [Embed WasmEdge in C/C++](/category/c-sdk-for-embedding-wasmedge)
- [Embed WasmEdge in Rust](/category/rust-sdk-for-embedding-wasmedge)
- [Embed WasmEdge in Go](/category/go-sdk-for-embedding-wasmedge)
- [Embed WasmEdge in Java](/category/java-sdk-for-embedding-wasmedge)
- [Embed WasmEdge in Python](/category/python-sdk-for-embedding-wasmedge)
- [Use cases](/category/use-cases)

Besides this, we also have two more guides for [developing WASM apps](../develop/overview.md) and [contributing to WasmEdge](../contribute/overview.md).
","**Summary**

The provided code is a Markdown document that serves as an overview of embedding WasmEdge, a WebAssembly runtime, into various host applications. The document outlines the benefits of using WasmEdge, its architecture, and provides links to guides for embedding it in different programming languages (C/C++, Rust, Go, Java, Python). Additionally, it mentions use cases and points readers to more resources on developing WASM apps and contributing to WasmEdge.

**Key Components**

1. **Overview**: The document introduces the purpose of embedding WasmEdge into host applications.
2. **Benefits**: It highlights the advantages of using WasmEdge as a sandboxed runtime for executing user-defined code.
3. **Architecture**: A diagram illustrates how WasmEdge can be embedded into host applications, providing a secure execution environment for WebAssembly apps.
4. **Guides**: The document links to guides for embedding WasmEdge in different languages (C/C++, Rust, Go, Java, Python).
5. **Use Cases**: It mentions various use cases where WasmEdge can be applied.

**Potential Issues or Areas for Improvement**

1. **Outdated information**: The content might not reflect the current state of WasmEdge or its SDKs.
2. **Lack of code examples**: While links to guides are provided, actual code examples in this document would make it more helpful for readers.
3. **Typos and formatting issues**: Minor errors in formatting or grammar could be present.
4. **Incomplete information**: Some sections might not provide sufficient detail or context.

Overall, the document is well-structured and provides a clear overview of embedding WasmEdge into host applications. However, it would benefit from more detailed code examples, up-to-date information, and additional resources to enhance its value for readers."
docs/develop/python/hello_world.md,"---
sidebar_position: 1
---

# Python

Several different language implementations of the Python runtime exist, and some of them support WebAssembly. This document will describe how to run [RustPython](https://github.com/RustPython/RustPython) on WasmEdge to execute Python programs.

## Compile RustPython

To compile RustPython, you should install the Rust toolchain on your machine. And `wasm32-wasi` platform support should be enabled.

```bash
rustup target add wasm32-wasi
```

Then you could use the following command to clone and compile RustPython:

```bash
git clone https://github.com/RustPython/RustPython.git
cd RustPython
cargo build --release --target wasm32-wasi --features=""freeze-stdlib""
```

`freeze-stdlib` feature is enabled for including Python standard library inside the binary file. The output file should be at `target/wasm32-wasi/release/rustpython.wasm`.

## AOT Compile

WasmEdge supports compiling WebAssembly bytecode programs into native machine code for better performance. It is highly recommended to compile the RustPython to native machine code before running.

```bash
wasmedge compile ./target/wasm32-wasi/release/rustpython.wasm ./target/wasm32-wasi/release/rustpython.wasm
```

## Run

```bash
wasmedge ./target/wasm32-wasi/release/rustpython.wasm
```

Then you could get a Python shell in WebAssembly!

## Grant file system access

You can pre-open directories to let WASI programs have permission to read and write files stored on the real machine. The following command mounted the current working directory to the WASI virtual file system.

```bash
wasmedge --dir .:. ./target/wasm32-wasi/release/rustpython.wasm
```
","**Summary**

This document provides a step-by-step guide on how to run RustPython, a language implementation of Python in WebAssembly (Wasm), using the WasmEdge runtime. The guide covers compiling RustPython from source, AOT compiling the resulting Wasm file for better performance, and running the compiled RustPython.

**Key Components**

1. **Rustup**: A toolchain installer used to add the `wasm32-wasi` platform support.
2. **Cargo**: A package manager used to build RustPython from source.
3. **WasmEdge**: A WebAssembly runtime that supports compiling Wasm bytecode into native machine code and providing file system access.
4. **RustPython**: A language implementation of Python in Rust, compiled to Wasm.

**Functionality**

The guide enables users to:

1. Compile RustPython from source using Cargo.
2. AOT compile the resulting Wasm file for better performance.
3. Run the compiled RustPython using WasmEdge, which provides a Python shell in WebAssembly.

**Potential Issues or Areas for Improvement**

1. **Dependencies**: The document assumes that the reader has the necessary dependencies (Rust toolchain and WasmEdge) installed on their machine. Providing installation instructions or links to resources may be helpful.
2. **Error Handling**: While the guide provides basic error handling, it does not cover potential issues that may arise during compilation or execution of RustPython. Adding more robust error handling mechanisms may be beneficial.
3. **Performance Optimization**: The document suggests AOT compiling the Wasm file for better performance but does not provide additional optimization techniques. Exploring other performance enhancement methods (e.g., Just-In-Time compilation) may be worth investigating."
i18n/zh/docusaurus-plugin-content-docs/current/develop/python/hello_world.md,"---
sidebar_position: 1
---

# Python

Several different language implementations of the Python runtime exist, and some of them support WebAssembly. This document will describe how to run [RustPython](https://github.com/RustPython/RustPython) on WasmEdge to execute Python programs.

## Compile RustPython

To compile RustPython, you should install the Rust toolchain on your machine. And `wasm32-wasi` platform support should be enabled.

```bash
rustup target add wasm32-wasi
```

Then you could use the following command to clone and compile RustPython:

```bash
git clone https://github.com/RustPython/RustPython.git
cd RustPython
cargo build --release --target wasm32-wasi --features=""freeze-stdlib""
```

`freeze-stdlib` feature is enabled for including Python standard library inside the binary file. The output file should be at `target/wasm32-wasi/release/rustpython.wasm`.

## AOT Compile

WasmEdge supports compiling WebAssembly bytecode programs into native machine code for better performance. It is highly recommended to compile the RustPython to native machine code before running.

```bash
wasmedge compile ./target/wasm32-wasi/release/rustpython.wasm ./target/wasm32-wasi/release/rustpython.wasm
```

## Run

```bash
wasmedge ./target/wasm32-wasi/release/rustpython.wasm
```

Then you could get a Python shell in WebAssembly!

## Grant file system access

You can pre-open directories to let WASI programs have permission to read and write files stored on the real machine. The following command mounted the current working directory to the WASI virtual file system.

```bash
wasmedge --dir .:. ./target/wasm32-wasi/release/rustpython.wasm
```
","**Summary**

This code provides a guide on how to run RustPython, a Rust implementation of Python, on WasmEdge, a WebAssembly runtime. The process involves compiling RustPython using the `cargo build` command with specific flags and features, AOT (Ahead-of-Time) compiling the resulting WASM bytecode using `wasmedge compile`, and finally running the compiled RustPython binary.

**Key Components**

1. **Compile RustPython**: This section explains how to install the Rust toolchain, enable `wasm32-wasi` platform support, clone and compile RustPython using `cargo build`.
2. **AOT Compile**: This step shows how to AOT compile the RustPython WASM bytecode into native machine code for better performance.
3. **Run**: The final section explains how to run the compiled RustPython binary using `wasmedge`.
4. **Grant file system access**: This optional step demonstrates how to pre-open directories to grant RustPython permission to read and write files on the real machine.

**Potential Issues or Areas for Improvement**

1. **Compilation flags**: The guide assumes that the reader knows which compilation flags to use (e.g., `--release` and `--features=""freeze-stdlib""`). It may be helpful to explain these options in more detail.
2. **Error handling**: The guide does not mention how to handle potential compilation errors or issues with AOT compilation.
3. **Performance considerations**: While the guide recommends AOT compiling for performance, it does not provide any guidance on optimizing RustPython for WasmEdge or measuring its performance.
4. **Security**: As with any system that executes arbitrary code, there may be security concerns when running RustPython on WasmEdge. The guide should acknowledge these risks and provide guidance on mitigating them.

Overall, the code provides a clear guide to setting up and running RustPython on WasmEdge. However, it would benefit from additional explanations and considerations to make it more accessible and robust for users."
i18n/zh/docusaurus-plugin-content-docs/current/start/wasmedge/extensions/unique_extensions.md,"---
sidebar_position: 3
---

# 其他扩展

在服务器端运行 WASM 应用的挑战之一是缺乏对 Linux API 和常用应用程序库的支持。WasmEdge 通过为 WASM 应用程序添加许多平台 API 的支持来解决这个问题。开发人员通常可以简单地将他们的 Linux 应用编译成 WASM，并期望在 WasmEdge 中运行。WasmEdge 为社区提供了一种简单的扩展机制来添加这些 API。例如，

通过其对网络套接字和相关 API 的支持，WasmEdge 可以运行 Rust 应用程序，实现以下功能：

- [提供HTTP服务](https://github.com/WasmEdge/wasmedge_hyper_demo)
- [访问外部网络服务](https://github.com/WasmEdge/wasmedge_reqwest_demo)
- [连接到数据库](https://github.com/WasmEdge/wasmedge-db-examples)
- [连接到消息队列](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql)
- [支持基于数据库的微服务](https://github.com/second-state/microservice-rust-mysql)
- [支持具有Dapr边车的微服务](https://github.com/second-state/dapr-wasm)

此外，网络套接字 API 还允许我们在 WasmEdge 的 JavaScript 运行时中支持 Node.js API，包括 `server` 和 `fetch()`。

通过其对 WASI-NN API 的支持，WasmEdge 可以支持用于 AI 推理的 Rust 和 JavaScript 应用程序。来自流行 AI 框架（如 Tensorflow、PyTorch 和 OpenVINO）的模型[都已经得到了支持](https://github.com/second-state/WasmEdge-WASINN-examples)。

## 可用扩展

这些扩展可以通过 WasmEdge 安装程序轻松安装。它们也可以包含在用于 Docker、Podman 和 Kubernetes 应用程序的 WASM 容器映像中。

| 名称 | 描述 | 平台支持 | 语言支持 | 备注 |
| --- | --- | --- | --- | --- |
| 网络套接字 | 支持异步（非阻塞）的 POSIX 网络套接字 | Linux | Rust、JavaScript、C | 支持诸如 tokio（Rust）和 node（JavaScript）等流行库 |
| DNS | 支持网络套接字中的 DNS 域名 | Linux | Rust、JavaScript、C | 支持诸如 tokio（Rust）和 node（JavaScript）等流行库 |
| 域套接字 | 支持进程之间的高性能数据交换 | Linux | Rust、JavaScript、C |  |
| TLS | 支持从网络套接字进行 TLS 和 HTTPS 连接 | Linux | Rust、JavaScript、C |  |
| KV 存储 | 允许 WebAssembly 程序读写键值存储 | Linux | Rust |  |
| [以太坊](https://github.com/second-state/wasmedge-evmc) | 支持编译为 WebAssembly 的以太坊智能合约。 | Linux | 无 | 它是以太坊风格的 WebAssembly（Ewasm）的主要实现。 |
| [Substrate](https://github.com/second-state/substrate-ssvm-node) | [Pallet](https://github.com/second-state/pallet-ssvm) 允许 WasmEdge 在任何基于 Substrate 的区块链上作为以太坊智能合约执行引擎。 | Linux | 无 |  |
","**Summary:**

The code is a Markdown document that explains the unique extensions supported by WasmEdge, a WebAssembly runtime. These extensions aim to bridge the gap between WebAssembly and Linux APIs, enabling developers to run their WASM applications on servers with ease. The extensions include support for network sockets, DNS, domain sockets, TLS, key-value storage, and Ethereum smart contracts.

**Key Components:**

1. **Network Sockets**: Enables asynchronous (non-blocking) POSIX network sockets.
2. **DNS**: Supports DNS resolution within network sockets.
3. **Domain Sockets**: Allows high-performance data exchange between processes.
4. **TLS**: Supports TLS and HTTPS connections from network sockets.
5. **KV Storage**: Enables WebAssembly programs to read and write key-value storage.
6. **Ethereum**: Supports compiled Ethereum smart contracts.
7. **Substrate**: Pallet allows WasmEdge to execute as an Ethereum virtual machine on any Substrate-based blockchain.

**Potential Issues or Areas for Improvement:**

1. **Platform Support**: The document primarily focuses on Linux, which might limit its applicability to other platforms.
2. **Language Support**: Although the document mentions Rust and JavaScript support, it would be beneficial to expand language support to include more languages, such as C++ or Python.
3. **Documentation Quality**: While the document provides a good overview of WasmEdge's unique extensions, some sections could benefit from more detailed explanations and examples.

**Recommendations:**

1. Expand platform support to include Windows and macOS.
2. Enhance language support to include more languages.
3. Improve documentation quality by providing more detailed explanations, examples, and code snippets."
README.md,"# WasmEdge Docs

![WasmEdge Logo](https://github.com/WasmEdge/.github/raw/main/profile/wasmedge-runtime-logo.png)

This repo contains technical documentation for the [WasmEdge Runtime](https://github.com/WasmEdge/WasmEdge) project. The documentation website built from this repo is published <https://wasmedge.org/docs/>, check it out!

## Setting up the Docs Locally

To set up the WasmEdge Docs locally, you will need to follow these general steps:

1. **Clone the project:** Go to the GitHub repository page of the WasmEdge Docs project and click on the ""Code"" button to get the URL of the repository. Then, open a terminal or command prompt and type the following command:

   ```bash
   git clone https://github.com/WasmEdge/docs.git
   ```

2. **Install dependencies:** Navigate to the project directory in the terminal and run the following command to install the necessary dependencies:

   ```bash
   npm install
   ```

3. **Start the development server:** Once the dependencies are installed, you can start the development server by running the following command:

   ```bash
   npm start
   ```

This should start the development server on port 3000. You can access the running application by opening a web browser and navigating to <http://localhost:3000/docs/>.

That's it! You should now have a local instance of the WasmEdge Docs running on your machine.
","**Summary:**

This is a README file for the WasmEdge Docs project, which contains technical documentation for the WasmEdge Runtime. The project provides instructions on how to set up and run the documentation website locally using Git and npm.

**Key Components:**

1. Clone the project repository from GitHub
2. Install dependencies using `npm install`
3. Start the development server using `npm start`

**Functionality:**

The code sets up a local instance of the WasmEdge Docs, allowing developers to view and contribute to the documentation.

**Potential Issues or Areas for Improvement:**

1. **Error handling**: The instructions do not provide guidance on how to handle errors that may occur during the setup process.
2. **Dependency management**: The use of `npm install` implies that the dependencies are managed using npm, but it would be more robust to specify exact versions or use a tool like yarn.
3. **Development server configuration**: The instructions do not provide any information on how to configure the development server (e.g., setting environment variables).
4. **Security considerations**: Running a development server on port 3000 may pose security risks, and it would be better to specify a more secure port or use a reverse proxy.

**Recommendations:**

1. Add error handling mechanisms to the instructions.
2. Specify exact dependency versions or recommend using yarn for dependency management.
3. Provide configuration options for the development server.
4. Consider specifying alternative ports or using a reverse proxy for enhanced security."
docs/embed/use-case/serverless-saas.md,"---
sidebar_position: 5
---

# Serverless Software-As-A-Service Functions

WasmEdge can support customized SaaS extensions or applications using serverless functions instead of traditional network APIs. That dramatically improves SaaS users' and developers' productivity.

- WasmEdge could be embedded into SaaS products to execute user-defined functions. In this scenario, the WasmEdge function API replaces the SaaS web API. The embedded WasmEdge functions are much faster, safer, and easier to use than RPC functions over the web.
- Edge servers could provide WasmEdge-based containers to interact with existing SaaS or PaaS APIs without requiring the user to run his servers (e.g., callback servers). The serverless API services can be co-located in the same networks as the SaaS to provide optimal performance and security.

The examples below showcase how WasmEdge-based serverless functions connect SaaS APIs from different services and process data flows across those SaaS APIs according to each user's business logic.

## Slack

- [Build a serverless chatbot for Slack](http://reactor.secondstate.info/en/docs/user_guideline.html)

## Lark

It is also known as `飞书`, aka the Chinese Slack. Byte Dance, the parent company of Tiktok, creates it.

- [Build a serverless chatbot for Lark](http://reactor.secondstate.info/en/docs/user_guideline.html)
","**Summary**

The provided code is a documentation snippet that describes how WasmEdge can be used to build customized Software-As-A-Service (SaaS) extensions or applications using serverless functions. The goal is to improve users' and developers' productivity by replacing traditional network APIs with faster, safer, and easier-to-use WasmEdge function APIs.

**Key Components**

1. **WasmEdge**: A cloud-native, high-performance WebAssembly runtime that can be embedded into SaaS products.
2. **Serverless functions**: Customized code executed on demand, without the need for server management.
3. **Embedded WasmEdge functions**: Replace traditional web APIs, providing faster and safer interactions with SaaS services.
4. **Edge servers**: Provide WasmEdge-based containers to interact with existing SaaS or Platform-as-a-Service (PaaS) APIs.

**Functionality**

1. **WasmEdge embedded into SaaS products**: Execute user-defined functions directly within the SaaS product, reducing latency and improving performance.
2. **Edge servers provide WasmEdge-based containers**: Allow users to interact with existing SaaS or PaaS APIs without running their own callback servers.

**Potential Issues or Areas for Improvement**

1. **Security risks**: As with any serverless architecture, there is a risk of security vulnerabilities if not properly managed and secured.
2. **Scalability limitations**: Serverless functions may not be suitable for large-scale applications or high-traffic scenarios, requiring additional infrastructure scaling.
3. **Developer complexity**: The adoption of WasmEdge-based serverless functions may require significant development efforts to ensure smooth integration with existing SaaS services.

Overall, this documentation provides a good overview of the benefits and functionality of using WasmEdge for building customized SaaS extensions or applications with serverless functions."
i18n/zh/docusaurus-plugin-content-docs/current/embed/use-case/serverless-saas.md,"---
sidebar_position: 5
---

# Serverless Software-As-A-Service Functions

WasmEdge can support customized SaaS extensions or applications using serverless functions instead of traditional network APIs. That dramatically improves SaaS users' and developers' productivity.

- WasmEdge could be embedded into SaaS products to execute user-defined functions. In this scenario, the WasmEdge function API replaces the SaaS web API. The embedded WasmEdge functions are much faster, safer, and easier to use than RPC functions over the web.
- Edge servers could provide WasmEdge-based containers to interact with existing SaaS or PaaS APIs without requiring the user to run his servers (e.g., callback servers). The serverless API services can be co-located in the same networks as the SaaS to provide optimal performance and security.

The examples below showcase how WasmEdge-based serverless functions connect SaaS APIs from different services and process data flows across those SaaS APIs according to each user's business logic.

## Slack

- [Build a serverless chatbot for Slack](http://reactor.secondstate.info/en/docs/user_guideline.html)

## Lark

It is also known as `飞书`, aka the Chinese Slack. Byte Dance, the parent company of Tiktok, creates it.

- [Build a serverless chatbot for Lark](http://reactor.secondstate.info/en/docs/user_guideline.html)
","**Summary**

This document describes how WasmEdge can be used to create customized SaaS extensions or applications using serverless functions. This approach replaces traditional network APIs, improving productivity for users and developers. The document highlights two main use cases:

1. **Embedded WasmEdge Functions**: WasmEdge is embedded into SaaS products to execute user-defined functions, replacing the traditional SaaS web API.
2. **Serverless Edge Servers**: Edge servers provide WasmEdge-based containers to interact with existing SaaS or PaaS APIs without requiring users to run their own servers.

The document also provides examples of how to connect SaaS APIs from different services and process data flows using WasmEdge-based serverless functions, showcasing its capabilities on two platforms:

1. **Slack**: Building a serverless chatbot for Slack.
2. **Lark (Chinese Slack)**: Building a serverless chatbot for Lark.

**Key Components**

* WasmEdge: A modular webAssembly runtime that enables serverless computing.
* SaaS APIs: Software-as-a-Service APIs used to connect services and process data flows.
* Serverless functions: WasmEdge-based functions that replace traditional network APIs.

**Potential Issues or Areas for Improvement**

* Limited documentation on implementing serverless chatbots for Lark (Chinese Slack).
* No code examples provided in the document, making it harder for developers to implement the use cases described.
* The user guide link is not specific to building a serverless chatbot and appears to be a generic user guideline.

**Recommendations**

* Add more detailed documentation on implementing serverless chatbots for Lark (Chinese Slack).
* Provide code examples or snippets to illustrate the implementation of WasmEdge-based serverless functions.
* Update the user guide link to make it specific to building a serverless chatbot."
i18n/zh/docusaurus-plugin-content-docs/current/start/wasmedge/comparison.md,"---
sidebar_position: 5
---

# 对比

## WebAssembly 与 Docker 之间的关系是什么？

请查看我们的信息图表 [WebAssembly vs. Docker](https://wasmedge.org/wasm_docker/)。在云原生和边缘原生应用中，WebAssembly 与 Docker 并驾齐驱。

## Native clients（NaCl）、应用程序运行时和 WebAssembly 之间有何区别？

我们创建了一个便捷的表格进行对比。

|  | NaCl | Application runtimes (eg Node &amp; Python) | Docker-like container | WebAssembly |
| --- | --- | --- | --- | --- |
| Performance | Great | Poor | OK | Great |
| Resource footprint | Great | Poor | Poor | Great |
| Isolation | Poor | OK | OK | Great |
| Safety | Poor | OK | OK | Great |
| Portability | Poor | Great | OK | Great |
| Security | Poor | OK | OK | Great |
| Language and framework choice | N/A | N/A | Great | OK |
| Ease of use | OK | Great | Great | OK |
| Manageability | Poor | Poor | Great | Great |

## WebAssembly 与 eBPF 有何区别？

`eBPF` 是适用于网络或安全相关任务的 Linux 内核空间虚拟机的字节码格式。而 WebAssembly 是适用于业务应用的用户空间虚拟机的字节码格式。[点击此处查看详细信息](https://medium.com/codex/ebpf-and-webassembly-whose-vm-reigns-supreme-c2861ce08f89)。
","**Summary**

This is a Markdown document comparing WebAssembly (WASM) to other technologies such as Docker, Native clients (NaCl), Application runtimes (e.g. Node & Python), and eBPF (extended Berkeley Packet Filter). The document aims to provide an overview of the differences between these technologies in terms of performance, resource footprint, isolation, safety, portability, security, language and framework choice, ease of use, and manageability.

**Key Components**

* Table comparing NaCl, Application runtimes, Docker-like container, and WebAssembly
	+ Performance: Great for WASM and NaCl, Poor for Application runtimes
	+ Resource footprint: Great for WASM and NaCl, Poor for Docker-like container
	+ Isolation: Poor for NaCl, OK for Application runtimes and Docker-like container, Great for WASM
* Comparison between WebAssembly and eBPF
	+ eBPF is a bytecode format for Linux kernel space virtual machine for networking or security tasks
	+ WebAssembly is a bytecode format for user space virtual machine for business applications

**Potential Issues**

* The table comparing NaCl, Application runtimes, Docker-like container, and WebAssembly may be confusing due to its format and the fact that some values are not clearly defined.
* The comparison between WebAssembly and eBPF seems brief and could benefit from more detailed information and examples.

**Areas for Improvement**

* Consider adding more concrete examples or case studies to illustrate the differences between these technologies.
* Provide more details on how to implement WebAssembly and eBPF in real-world scenarios.
* Consider creating a more organized and easy-to-read table comparing the different technologies."
docs/develop/overview.md,"---
sidebar_position: 1
displayed_sidebar: developSidebar
---

# Develop WASM Apps

A fundamental value proposition of WebAssembly is that it supports multiple programming languages. WebAssembly is a ""managed runtime"" for many programming languages including [C/C++](/category/develop-wasm-apps-in-cc), [Rust](/category/develop-wasm-apps-in-rust), [Go](/category/develop-wasm-apps-in-go), and even [JavaScript](/category/develop-wasm-apps-in-javascript) and [Python](/category/develop-wasm-apps-in-python).

- For compiled languages (e.g., C and Rust), WasmEdge WebAssembly provides a safe, secure, isolated, and containerized runtime as opposed to Native Client (NaCl).
- For interpreted or managed languages (e.g., JavaScript and Python), WasmEdge WebAssembly provides a secure, fast, lightweight, and containerized runtime instead of Docker + guest OS + native interpreter.

This chapter will discuss how to compile sources into WebAssembly in different languages and run them in WasmEdge.

- Develop WebAssembly apps from your programming languages from [Rust](/category/develop-wasm-apps-in-rust), [C/C++](/category/develop-wasm-apps-in-cc), [JavaScript](/category/develop-wasm-apps-in-javascript), [Go](/category/develop-wasm-apps-in-go), and many other languages.
- [Deploy WASM Apps with the existing container toolings](/category/deploy-wasmedge-apps-in-kubernetes)

Besides this, we also have two more guides for [Embedding WASM Functions](../embed/overview.md) and [Contributing](../contribute/overview.md) to WasmEdge.
","**Summary**

This code snippet is part of the documentation for developing WebAssembly (WASM) applications with WasmEdge. It highlights the benefits of using WASM, which supports multiple programming languages and provides a safe, secure, isolated, and containerized runtime environment. The text also outlines the different programming languages supported by WasmEdge, including C/C++, Rust, JavaScript, Python, Go, and many others.

**Key Components**

1. **Multiple language support**: WasmEdge supports development in multiple programming languages.
2. **Runtime benefits**: Provides a safe, secure, isolated, and containerized runtime environment for compiled languages (C and Rust) and a fast, lightweight, and containerized runtime environment for interpreted/managed languages (JavaScript and Python).
3. **Language-specific guides**: Links to documentation for developing WASM apps in specific programming languages.
4. **Deployment guide**: References a guide on deploying WASM apps with existing container toolings.

**Potential Issues or Areas for Improvement**

1. **Outdated links**: Some links may become outdated as the documentation evolves.
2. **Limited scope**: The text focuses primarily on developing and deploying WASM apps, but doesn't address other aspects of WasmEdge development (e.g., embedding WASM functions).
3. **Assumes prior knowledge**: Readers may need prior experience with WebAssembly or specific programming languages to fully understand the content.

**Recommendations**

1. Regularly review and update links to ensure they remain valid.
2. Expand the scope of the documentation to cover additional aspects of WasmEdge development.
3. Consider adding introductory sections to provide a more comprehensive understanding of WebAssembly and its benefits for readers without prior experience in the field."
i18n/zh/docusaurus-plugin-content-docs/current/develop/overview.md,"---
sidebar_position: 1
displayed_sidebar: developSidebar
---

# Develop WASM Apps

A fundamental value proposition of WebAssembly is that it supports multiple programming languages. WebAssembly is a ""managed runtime"" for many programming languages including [C/C++](/category/develop-wasm-apps-in-cc), [Rust](/category/develop-wasm-apps-in-rust), [Go](/category/develop-wasm-apps-in-go), and even [JavaScript](/category/develop-wasm-apps-in-javascript) and [Python](/category/develop-wasm-apps-in-python).

- For compiled languages (e.g., C and Rust), WasmEdge WebAssembly provides a safe, secure, isolated, and containerized runtime as opposed to Native Client (NaCl).
- For interpreted or managed languages (e.g., JavaScript and Python), WasmEdge WebAssembly provides a secure, fast, lightweight, and containerized runtime instead of Docker + guest OS + native interpreter.

This chapter will discuss how to compile sources into WebAssembly in different languages and run them in WasmEdge.

- Develop WebAssembly apps from your programming languages from [Rust](/category/develop-wasm-apps-in-rust), [C/C++](/category/develop-wasm-apps-in-cc), [JavaScript](/category/develop-wasm-apps-in-javascript), [Go](/category/develop-wasm-apps-in-go), and many other languages.
- [Deploy WASM Apps with the existing container toolings](/category/deploy-wasmedge-apps-in-kubernetes)

Besides this, we also have two more guides for [Embedding WASM Functions](../embed/overview.md) and [Contributing](../contribute/overview.md) to WasmEdge.
","**Summary:**

This documentation chapter focuses on developing WebAssembly (WASM) apps using various programming languages. The chapter outlines the benefits of using WasmEdge WebAssembly, which provides a safe, secure, isolated, and containerized runtime for compiled languages like C/C++ and Rust, and a secure, fast, lightweight, and containerized runtime for interpreted or managed languages like JavaScript and Python.

**Key Components:**

1. **Languages Support**: The chapter mentions that WasmEdge supports multiple programming languages, including C/C++, Rust, Go, JavaScript, and Python.
2. **WasmEdge WebAssembly Runtime**: Describes the benefits of using WasmEdge as a runtime environment for WASM apps, particularly for compiled and interpreted languages.
3. **Compilation and Execution**: Outlines how to compile sources into WebAssembly in different languages and run them in WasmEdge.
4. **Guides and Resources**: Provides links to additional guides on embedding WASM functions and contributing to WasmEdge.

**Potential Issues or Areas for Improvement:**

1. **Readability**: The chapter has a good structure, but some sections (e.g., ""For compiled languages..."") are quite long and could be broken down into shorter paragraphs for better readability.
2. **Consistency**: Some links in the chapter seem to point to internal documentation (e.g., `/category/develop-wasm-apps-in-rust`) while others point to external resources (e.g., Docker).
3. **Missing Context**: The chapter assumes some prior knowledge of WebAssembly and WasmEdge, which might make it challenging for readers new to the topic.

Overall, this is a well-structured and informative chapter that provides valuable insights into developing WASM apps using various programming languages with WasmEdge. However, some minor adjustments can be made to improve readability, consistency, and context."
i18n/zh/docusaurus-plugin-content-docs/current/start/wasmedge/integrations.md,"---
sidebar_position: 2
---

# WasmEdge 集成

WasmEdge 是云原生和边缘计算应用的“无服务器”运行时。它允许开发人员安全地将第三方或“本地”函数嵌入主机应用程序或分布式计算框架中。

## 将 WasmEdge 嵌入到主机应用程序中

WasmEdge 的一个主要用例是从主机应用程序启动虚拟机实例。根据你的主机应用程序编程语言，你可以使用 WasmEdge SDK 来启动和调用 WasmEdge 函数。

- 使用 [WasmEdge C API](/category/c-sdk-for-embedding-wasmedge) 将 WasmEdge 函数嵌入到基于 `C` 的应用程序中。查看[快速入门指南](../../embed/c/intro.md)。
- 使用 [WasmEdge Go API](/category/go-sdk-for-embedding-wasmedge) 将 WasmEdge 函数嵌入到 `Go` 应用程序中。这里有一个[教程](https://www.secondstate.io/articles/extend-golang-app-with-webassembly-rust/) 和一些[示例](https://github.com/second-state/WasmEdge-go-examples)！
- 使用 [WasmEdge Rust crate](https://crates.io/crates/wasmedge-sdk) 将 WasmEdge 函数嵌入到 `Rust` 应用程序中。
- 使用 `NAPI` 将 WasmEdge 函数嵌入到 `Node.js` 应用程序中。这里有一个[教程](https://www.secondstate.io/articles/getting-started-with-rust-function/)。
- 通过生成一个新进程将 WasmEdge 函数嵌入到任何应用程序。查看 [Vercel 无服务器函数](https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/) 和 [AWS Lambda](https://www.cncf.io/blog/2021/08/25/webassembly-serverless-functions-in-aws-lambda/) 的示例。

不过，WebAssembly 规范仅支持用于 WebAssembly 字节码函数的非常有限的输入参数和返回值的数据类型。要传递复杂数据类型（例如字符串或数组）作为来自 Rust 编译的 WebAssembly 的调用参数，你应该使用[`wasmedge-bindgen`](https://crates.io/crates/wasmedge-bindgen)提供的 `bindgen` 解决方案。我们目前在 [Rust](../../develop/rust/bindgen.md) 和 [Go](../../embed/go/bindgen.md) 中支持`wasmedge-bindgen`。

## 使用 WasmEdge 作为类似 Docker 的容器

WasmEdge 提供符合 OCI 规范的接口。你可以使用诸如 CRI-O、Docker Hub 和 Kubernetes 之类的容器工具来编排和管理 WasmEdge 运行时。

- [使用 CRI-O 和 Docker Hub 管理 WasmEdge](https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/)。

## 从 WasmEdge 调用原生宿主函数

WasmEdge 的一个关键特性是其可扩展性。WasmEdge API 允许开发人员将来自主机编程语言的“主机函数”注册到 WasmEdge 实例中，并从 WebAssembly 程序中调用这些函数。

- WasmEdge C API 支持 [C 主机函数](../../embed/c/host_function.md)。
- WasmEdge Go API 支持 [Go 主机函数](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_HostFunc#wasmedge-go-host-function-example)。
- WasmEdge Rust API 支持 [Rust 主机函数](https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#host-functions)。

[这是一个示例](https://www.secondstate.io/articles/call-native-functions-from-javascript/)，演示了 WasmEdge 中的 JavaScript 程序调用底层操作系统中基于 C 的主机函数。

主机函数打破了 WASM 沙箱，以便访问底层操作系统或硬件。但这种沙箱破坏是经过系统操作者明确许可的。
","**Code Analysis Summary:**

This document provides an introduction to WasmEdge, a cloud-native and edge computing application ""serverless"" runtime. It explains how to integrate WasmEdge into host applications using various programming languages (C, Go, Rust, Node.js) through APIs or SDKs.

The main use cases for WasmEdge are:

1. **Embedding WasmEdge functions into host applications**: Developers can start a virtual machine instance from their host application and call WasmEdge functions using the provided APIs.
2. **Using WasmEdge as a container**: WasmEdge provides an OCI-compliant interface, allowing developers to manage WasmEdge runtime instances using tools like CRI-O, Docker Hub, or Kubernetes.
3. **Calling native host functions from WasmEdge**: WasmEdge allows developers to register ""host functions"" from their host programming language and call them from WebAssembly programs.

**Key Components:**

1. **WasmEdge APIs**: Provides a set of APIs for integrating WasmEdge into host applications using various programming languages.
2. **WasmEdge SDKs**: Offers software development kits (SDKs) for specific programming languages, making it easier to integrate WasmEdge into host applications.
3. **wasmedge-bindgen**: A tool for generating bindings between Rust or Go code and WebAssembly functions.

**Potential Issues/Areas for Improvement:**

1. **Limited input parameters and return values**: The WebAssembly specification only supports a limited set of data types as input parameters and return values, which may limit the complexity of WasmEdge functions.
2. **Dependence on third-party libraries**: Some WasmEdge features rely on external libraries (e.g., `wasmedge-bindgen`), which may introduce additional dependencies and maintenance burdens.

Overall, this document provides a comprehensive introduction to WasmEdge and its use cases, highlighting the benefits of integrating WasmEdge into host applications and using it as a container. However, further research and development are needed to address potential limitations and improve the overall ecosystem."
src/pages/releases.md,"import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem'; import ReleaseNotes from '@theme/ReleaseNotes';

# Releases

<Tabs lazy>
  <TabItem value ='WasmEdge' label=""WasmEdge"" default>
    <p><a href=""https://github.com/WasmEdge/WasmEdge/releases"">View releases on GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/Changelog.md' />
  </TabItem>
    <TabItem value ='tokio' label=""tokio"">
    <p><a href=""https://github.com/WasmEdge/tokio/releases"">View releases on GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/WasmEdge/tokio/master/tokio/CHANGELOG.md' />
  </TabItem>
  <TabItem value ='mio' label=""mio"">
    <p><a href=""https://github.com/WasmEdge/mio/releases"">View releases on GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/WasmEdge/mio/master/CHANGELOG.md' />
  </TabItem>
  <TabItem value ='sqlx' label=""sqlx"">
    <p><a href=""https://github.com/WasmEdge/sqlx"">GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/WasmEdge/sqlx/main/CHANGELOG.md' />
  </TabItem>
  <TabItem value ='redis-rs' label=""redis-rs"">
    <p><a href=""https://github.com/WasmEdge/redis-rs/releases"">View releases on GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/WasmEdge/redis-rs/main/redis/CHANGELOG.md' />
  </TabItem>
  <TabItem value ='combine' label=""combine"">
    <p><a href=""https://github.com/WasmEdge/combine/releases"">View releases on GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/WasmEdge/combine/master/CHANGELOG.md' />
  </TabItem>
  <TabItem value ='reqwest' label=""reqwest"">
    <p><a href=""https://github.com/WasmEdge/reqwest/releases"">View releases on GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/WasmEdge/reqwest/master/CHANGELOG.md' />
  </TabItem>
  <TabItem value ='rskafka_wasi' label=""rskafka_wasi"">
    <p><a href=""https://github.com/WasmEdge/rskafka_wasi"">View releases on GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/WasmEdge/rskafka_wasi/main/CHANGELOG.md' />
  </TabItem>
  <TabItem value ='WasmEdge-Go-SDK' label=""wasmedge-go"">
    <p><a href=""https://github.com/second-state/WasmEdge-go/releases"">View releases on GitHub</a></p>
    <ReleaseNotes url='https://raw.githubusercontent.com/second-state/WasmEdge-go/master/Changelog.md' />
 </TabItem>
</Tabs>
","**Summary**

This code generates a page with a tabbed interface displaying release notes for various dependencies of the WasmEdge project. The dependencies are listed in separate tabs, each containing links to their respective GitHub releases and changelogs.

**Key Components**

1. **Tabs**: The `Tabs` component from `@theme/Tabs` is used to create a tabbed interface.
2. **TabItem**: Each dependency has its own `TabItem` instance, which contains the link to the dependency's release notes.
3. **ReleaseNotes**: The `ReleaseNotes` component from `@theme/ReleaseNotes` is used to display the changelog for each dependency.

**Functionality**

When a tab is clicked, the corresponding release notes are displayed below the tab header. Each release note section contains a link to the GitHub releases page and a direct link to the changelog file (in Markdown format).

**Potential Issues/ Areas for Improvement**

1. **Error handling**: The code does not handle cases where the changelog URL is invalid or the file is not found.
2. **Code duplication**: Each dependency's configuration (e.g., GitHub repository, changelog file path) is hardcoded in each `TabItem` instance. This makes it difficult to manage changes and updates for multiple dependencies.
3. **Maintainability**: The code is repetitive, which can make it harder to maintain and update in the future.

**Recommendations**

1. **Introduce a data-driven approach**: Instead of hardcoding the dependency configurations, consider using a data file (e.g., JSON or CSV) that contains the metadata for each dependency.
2. **Use a loop or mapping function**: Create a single instance of `TabItem` and use a loop or mapping function to render each dependency's tab based on the data from the data file.
3. **Implement error handling**: Add try-catch blocks to handle cases where the changelog URL is invalid or the file is not found.
4. **Consider using a more robust library for generating release notes**: There are libraries available (e.g., `github-release`) that provide more features and better support for displaying release notes."
.github/PULL_REQUEST_TEMPLATE.md,"## Explanation

<!--
In a couple sentences, explain why this PR is needed and what it addresses. This should be an explanation a non-developer user can understand and covers the ""why"" question. It should also clearly indicate whether this PR represents an addition, a change, or a fix of existing behavior. This explanation will be used to assist in the release note drafting process.

THIS IS MANDATORY.
-->

## Related issue

<!--
Please link the GitHub issue this pull request resolves in the format of `Closes #1234`, `fixes #1234`.
-->

## What type of PR is this

<!--
> /kind bug
> /kind documentation
-->

## Proposed Changes

<!--
Describe the big picture of your changes here to communicate to the maintainers why we should accept this pull request. 
-->
","**Summary**

This is a Pull Request (PR) template, specifically designed for GitHub. The purpose of this template is to provide guidelines and structure for developers to submit PRs in a clear and concise manner.

**Functionality**

The template consists of four sections:

1. **Explanation**: A brief description of the PR, explaining why it's needed, what it addresses, and whether it adds, changes, or fixes existing behavior.
2. **Related issue**: A link to the GitHub issue that this PR resolves.
3. **What type of PR is this**: A categorization of the PR as either a bug fix, documentation update, or other type.
4. **Proposed Changes**: A high-level overview of the changes included in the PR.

**Key Components**

* The template emphasizes the importance of clear and concise communication for non-developer users.
* It provides structure for developers to follow when submitting PRs.
* The sections are designed to facilitate review and understanding of the PR by maintainers.

**Potential Issues or Areas for Improvement**

* While the template provides guidance, it may not cover all scenarios or edge cases. Developers should ensure that their PR explanation and proposed changes are comprehensive and easy to understand.
* Maintainers should regularly review and update this template to reflect changing project requirements and best practices.
* The use of markdown formatting in this template can make it more readable and accessible; however, it may also introduce limitations in certain text editors or platforms."
docs/contribute/internal.md,"---
sidebar_position: 6
---

# WasmEdge Internal

## Overview of WasmEdge Execution Flow

```mermaid
graph TD
    A[WASM] -->|From files or buffers| B(Loader)
    B -->|Create WASM AST| C(Validator)
    C -->|Validate WASM Module| D[Instantiator]
    D -->|Create WASM instances| E{AOT section found?}
    E -->|Yes| F[AOT Engine]
    E -->|No| G[Interpreter Engine]
    F <-->|Execute WASM| H[WasmEdge Engine]
    G <-->|Execute WASM| H[WasmEdge Engine]
    H -->|Host Function Call / Access Runtime Data| H1[WasmEdge Runtime]
    H1 <-->|Call Host Functions| I[Host Functions]
    H1 <-->|Access Runtime Data| J[Runtime Data Manager]
    I <-->|System Call| I1[WASM System Interface, WASI]
    I <-->|AI-related Function Call| I2[WASI-NN]
    I <-->|Crypto-related Function Call| I3[WASI-Crypto]
    I <-->|Socket-related Function Call| I4[WasmEdge-WASI-Socket]
    J <-->|Access Memory| J1[Memory Manager]
    J <-->|Access Stack| J2[Stack Manager]
    J <-->|Access Cross Module| J3[Registered Module/Function Manager]
```
","**Summary**

This code snippet from the `internal.md` file in the WasmEdge repository visualizes the execution flow of a WebAssembly (WASM) module using Mermaid. The flowchart illustrates the various components and processes involved in executing a WASM module within the WasmEdge engine.

**Key Components**

1. **Loader**: Loads the WASM module from files or buffers.
2. **Validator**: Validates the loaded WASM module to ensure it conforms to the WebAssembly specification.
3. **Instantiator**: Creates instances of the validated WASM module.
4. **AOT Engine/Interpreter Engine**: Executes the WASM code, either through Just-In-Time (JIT) compilation using an AOT engine or interpretation using an interpreter engine.
5. **WasmEdge Engine**: The core execution engine that executes the WASM instructions.
6. **Host Function Call/Runtime Data Manager**: Handles host function calls and access to runtime data, such as memory, stack, and registered modules/functions.
7. **Host Functions/WASI Interface**: Provides interfaces for system calls, AI-related functions, crypto-related functions, and socket-related functions.

**Potential Issues/Improvement Areas**

1. **Complexity**: The flowchart may appear overwhelming due to the numerous components involved in executing a WASM module. Consider breaking down the chart into smaller sections or creating an animated version.
2. **Code Documentation**: While the chart provides a high-level overview, it lacks detailed documentation on each component's functionality and implementation details.
3. **Error Handling**: The chart does not illustrate error handling mechanisms for invalid WASM modules, host function calls, or other potential issues that may arise during execution.

By addressing these areas for improvement, the WasmEdge team can make their codebase more accessible, maintainable, and easier to understand, ultimately facilitating contributions from a broader community."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/internal.md,"---
sidebar_position: 6
---

# WasmEdge Internal

## Overview of WasmEdge Execution Flow

```mermaid
graph TD
    A[WASM] -->|From files or buffers| B(Loader)
    B -->|Create WASM AST| C(Validator)
    C -->|Validate WASM Module| D[Instantiator]
    D -->|Create WASM instances| E{AOT section found?}
    E -->|Yes| F[AOT Engine]
    E -->|No| G[Interpreter Engine]
    F <-->|Execute WASM| H[WasmEdge Engine]
    G <-->|Execute WASM| H[WasmEdge Engine]
    H -->|Host Function Call / Access Runtime Data| H1[WasmEdge Runtime]
    H1 <-->|Call Host Functions| I[Host Functions]
    H1 <-->|Access Runtime Data| J[Runtime Data Manager]
    I <-->|System Call| I1[WASM System Interface, WASI]
    I <-->|AI-related Function Call| I2[WASI-NN]
    I <-->|Crypto-related Function Call| I3[WASI-Crypto]
    I <-->|Socket-related Function Call| I4[WasmEdge-WASI-Socket]
    J <-->|Access Memory| J1[Memory Manager]
    J <-->|Access Stack| J2[Stack Manager]
    J <-->|Access Cross Module| J3[Registered Module/Function Manager]
```
","**Code Summary**

The provided code is an internal documentation for the WasmEdge Execution Flow. It uses Mermaid to create a visual graph that illustrates the execution flow of WASM (WebAssembly) modules in the WasmEdge engine.

**Key Components:**

1. **WASM Loader**: responsible for loading WASM files or buffers.
2. **Validator**: validates the loaded WASM module.
3. **Instantiator**: creates WASM instances.
4. **AOT Engine**: executes AOT (Ahead-of-Time) sections of the WASM module.
5. **Interpreter Engine**: executes non-AOT sections of the WASM module.
6. **WasmEdge Engine**: serves as a runtime environment for both AOT and Interpreter Engines.
7. **Host Functions**: provides system calls, AI-related function calls, crypto-related function calls, and socket-related function calls to the WasmEdge Runtime.
8. **Runtime Data Manager**: manages access to runtime data.
9. **Memory Manager**, **Stack Manager**, and **Registered Module/Function Manager**: manage memory, stack, and cross-module functionality respectively.

**Potential Issues/Areas for Improvement:**

1. The graph is complex and may be difficult to understand without a thorough explanation of each component's role.
2. The use of multiple arrows between components can make it hard to follow the execution flow.
3. There is no clear indication of which components are responsible for error handling or exception management.
4. The involvement of multiple engines (AOT, Interpreter) and runtimes (WasmEdge Engine, Host Functions) might lead to complexity in debugging issues.

**Recommendations:**

1. Consider adding additional documentation or explanations to make the graph more accessible to readers unfamiliar with WASM execution flows.
2. Break down complex components into smaller, more manageable pieces to improve readability.
3. Identify and separate error handling and exception management logic from the main execution flow.
4. Consider using a more straightforward notation for representing relationships between components."
docs/embed/go/reference/upgrade_to_0.13.0.md,"---
sidebar_position: 2
---

# Upgrade to WasmEdge-Go v0.13.0

Due to the WasmEdge-Go API breaking changes, this document shows the guideline of programming with WasmEdge-Go API to upgrade from the `v0.12.1` to the `v0.13.0` version.

## Concepts

1. Removed the `TensorFlow`, `TensorFlow-Lite`, and `Image` extension APIs.

   After `v0.13.0`, the WasmEdge extensions are replaced by the corresponding plug-ins. Please refer to our newest [example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_mtcnn).

2. Asynchronously invoking WASM function by executor.

   Developers can use the `(wasmedge.Executor).AsyncInvoke()` API to execute a WASM function asynchronously.

3. Fixed the `(wasmedge.Executor).Invoke()` API to remove the first `wasmedge.Store` parameter.

   It's easy to update. Just drop the first parameter.

4. Unified WasmEdge CLI.

   Developers can use the `wasmedge.RunWasmEdgeUnifiedCLI()` API to trigger the unified WasmEdge CLI.
","**Summary:**

The provided code is a reference guide for upgrading to WasmEdge-Go v0.13.0, which introduces breaking changes to the API. The guide covers key concepts and modifications required for developers to migrate their applications from v0.12.1 to v0.13.0.

**Key Components:**

1. **Removed APIs**: TensorFlow, TensorFlow-Lite, and Image extension APIs have been removed.
2. **Asynchronous Invocation**: `(wasmedge.Executor).AsyncInvoke()` API allows developers to execute WASM functions asynchronously.
3. **Modified `Invoke()` API**: The first `wasmedge.Store` parameter has been removed from the `(wasmedge.Executor).Invoke()` API.
4. **Unified WasmEdge CLI**: Developers can use `wasmedge.RunWasmEdgeUnifiedCLI()` API to trigger the unified WasmEdge CLI.

**Potential Issues or Areas for Improvement:**

1. **API changes may require significant code updates**: The removal of TensorFlow, TensorFlow-Lite, and Image extension APIs will likely require substantial code modifications.
2. **Async invocation may introduce complexity**: Developers should carefully consider when and how to use asynchronous invocation to ensure it does not impact performance or application behavior.
3. **Unified CLI API may have compatibility issues**: Developers using the unified CLI API should test their applications thoroughly to ensure compatibility with the new API.
4. **Documentation and examples may be needed for specific use cases**: The guide does not cover all potential edge cases or scenarios, so additional documentation and examples would be beneficial for developers migrating from v0.12.1 to v0.13.0."
i18n/zh/docusaurus-plugin-content-docs/current/embed/go/reference/upgrade_to_0.13.0.md,"---
sidebar_position: 2
---

# Upgrade to WasmEdge-Go v0.13.0

Due to the WasmEdge-Go API breaking changes, this document shows the guideline of programming with WasmEdge-Go API to upgrade from the `v0.12.1` to the `v0.13.0` version.

## Concepts

1. Removed the `TensorFlow`, `TensorFlow-Lite`, and `Image` extension APIs.

   After `v0.13.0`, the WasmEdge extensions are replaced by the corresponding plug-ins. Please refer to our newest [example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_mtcnn).

2. Asynchronously invoking WASM function by executor.

   Developers can use the `(wasmedge.Executor).AsyncInvoke()` API to execute a WASM function asynchronously.

3. Fixed the `(wasmedge.Executor).Invoke()` API to remove the first `wasmedge.Store` parameter.

   It's easy to update. Just drop the first parameter.

4. Unified WasmEdge CLI.

   Developers can use the `wasmedge.RunWasmEdgeUnifiedCLI()` API to trigger the unified WasmEdge CLI.
","**Summary:**

This Markdown document outlines the guidelines for upgrading from WasmEdge-Go v0.12.1 to v0.13.0. The document covers four main areas:

1. **API breaking changes**: The `TensorFlow`, `TensorFlow-Lite`, and `Image` extension APIs have been removed. Instead, use corresponding plug-ins.
2. **Asynchronous WASM function invocation**: Use `(wasmedge.Executor).AsyncInvoke()` to execute a WASM function asynchronously.
3. **Invoke API update**: Drop the first parameter when updating from `(wasmedge.Executor).Invoke()`.
4. **Unified WasmEdge CLI**: Use `wasmedge.RunWasmEdgeUnifiedCLI()` to trigger the unified WasmEdge CLI.

**Key Components:**

* The document targets developers upgrading from v0.12.1 to v0.13.0.
* It highlights major API changes and provides simple examples for updating code.
* Key APIs affected are `(wasmedge.Executor).AsyncInvoke()`, `(wasmedge.Executor).Invoke()`, `TensorFlow`/`TensorFlow-Lite`/`Image` extension APIs, and `wasmedge.RunWasmEdgeUnifiedCLI()`.

**Potential Issues or Areas for Improvement:**

* The document assumes a basic understanding of WasmEdge-Go and its API. Providing more context or background information might be helpful for new users.
* The example link provided is external and may change over time. It would be beneficial to include a brief description of the example within the document itself.
* While the update instructions are concise, it's essential to emphasize that developers should review their entire codebase to ensure all changes are applied correctly."
docs/contribute/community.md,"---
sidebar_position: 10
---

# Join WasmEdge Community

Everyone is welcome to join the WasmEdge community.

## Contact

If you have any questions, feel free to open a GitHub issue on a related project or to join the following channels:

- Mailing list: Send an email to [WasmEdge@googlegroups.com](https://groups.google.com/g/wasmedge/)
- Discord: Join the [WasmEdge Discord server](https://discord.gg/h4KDyB8XTt)!
- Slack: Join the #WasmEdge channel on the [CNCF Slack](https://slack.cncf.io/)
- Twitter: Follow @realwasmedge on [Twitter](https://twitter.com/realwasmedge)

## Community Meeting

We host a monthly community meeting to showcase new features, demo new use cases, and a Q&A part. Everyone is welcome!

Time: The first Tuesday of each month at 11PM Hong Kong Time/ 7AM PST.

[Public meeting agenda/notes](https://docs.google.com/document/d/1iFlVl7R97Lze4RDykzElJGDjjWYDlkI8Rhf8g4dQ5Rk/edit#) | [Zoom link](https://us06web.zoom.us/j/88282362606?pwd=UFhOdzlVKyswdW43c21BKy9DdkdyUT09)
","**Summary**

The code snippet appears to be a Markdown document that serves as an introduction to the WasmEdge community. It provides information on how to join and engage with the community, including contact channels (mailing list, Discord, Slack, Twitter) and regular community meetings.

**Key Components**

1. **Community Invitation**: The document welcomes everyone to join the WasmEdge community.
2. **Contact Channels**: A list of communication channels where users can ask questions or get involved:
	* Mailing list: `WasmEdge@googlegroups.com`
	* Discord: `[Join the WasmEdge Discord server](https://discord.gg/h4KDyB8XTt)`
	* Slack: `#WasmEdge channel on the CNCF Slack` (`https://slack.cncf.io/`)
	* Twitter: Follow `@realwasmedge`
3. **Community Meeting**: The document announces a monthly community meeting, including:
	* Time and date (first Tuesday of each month at 11PM Hong Kong Time/ 7AM PST)
	* Links to the public meeting agenda and notes
	* Zoom link for attending the meeting

**Potential Issues or Areas for Improvement**

1. **Outdated Information**: The document mentions a mailing list that appears to be managed by Google Groups, which might not be the most reliable or secure option.
2. **Lack of Clear Instructions**: While the document provides links to join various channels, it would be helpful to include clear instructions on how to use each platform (e.g., Discord vs. Slack).
3. **Inconsistent Formatting**: The Markdown formatting is consistent throughout the document, but there are minor inconsistencies in indentation and spacing.
4. **No Clear Call-to-Action**: While the document invites users to join the community, it would be beneficial to include a clear call-to-action (CTA) or encouragement for users to participate in discussions or contribute to projects.

Overall, the code snippet is well-structured, but it could benefit from some minor adjustments and clarifications to make it more accessible and user-friendly."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/community.md,"---
sidebar_position: 10
---

# Join WasmEdge Community

Everyone is welcome to join the WasmEdge community.

## Contact

If you have any questions, feel free to open a GitHub issue on a related project or to join the following channels:

- Mailing list: Send an email to [WasmEdge@googlegroups.com](https://groups.google.com/g/wasmedge/)
- Discord: Join the [WasmEdge Discord server](https://discord.gg/h4KDyB8XTt)!
- Slack: Join the #WasmEdge channel on the [CNCF Slack](https://slack.cncf.io/)
- Twitter: Follow @realwasmedge on [Twitter](https://twitter.com/realwasmedge)

## Community Meeting

We host a monthly community meeting to showcase new features, demo new use cases, and a Q&A part. Everyone is welcome!

Time: The first Tuesday of each month at 11PM Hong Kong Time/ 7AM PST.

[Public meeting agenda/notes](https://docs.google.com/document/d/1iFlVl7R97Lze4RDykzElJGDjjWYDlkI8Rhf8g4dQ5Rk/edit#) | [Zoom link](https://us06web.zoom.us/j/88282362606?pwd=UFhOdzlVKyswdW43c21BKy9DdkdyUT09)
","**Summary**

The provided code is a Markdown file that serves as a community guide for the WasmEdge project. It outlines how to join and participate in the WasmEdge community, including contact channels, a community meeting schedule, and links to relevant resources.

**Key Components**

1. **Joining the Community**: The document explains how to reach out to the community through various communication channels (mailing list, Discord, Slack, Twitter).
2. **Community Meeting**: The monthly meeting agenda includes showcasing new features, demos of new use cases, and a Q&A session.
3. **Meeting Schedule**: The first Tuesday of each month at 11PM Hong Kong Time/ 7AM PST.
4. **Resources**:
	* Public meeting agenda/notes (Google Doc)
	* Zoom link for the community meeting

**Potential Issues or Areas for Improvement**

1. **Outdated Links**: The code includes links to external resources, which may become outdated over time. Consider implementing a mechanism to update these links automatically.
2. **Meeting Schedule**: Ensure that the meeting schedule is accurately reflected in multiple places (e.g., calendar events, community announcements) and communicated clearly to attendees.
3. **Community Engagement**: While the document encourages participation, consider adding more incentives or activities to foster engagement within the community.

Overall, this code serves as a valuable resource for the WasmEdge community, providing clear guidelines on how to participate and engage with others. By addressing potential issues and areas for improvement, the community can continue to grow and thrive."
docs/start/usage/wasm-smart-devices.md,"---
sidebar_position: 4
---

# WasmEdge On Smart Devices

Smart device apps could embed WasmEdge as a middleware runtime to render interactive content on the UI, connect to native device drivers, and access specialized hardware features (i.e., the GPU for AI inference). The benefits of the WasmEdge runtime over native-compiled machine code include security, safety, portability, manageability, OTA upgradability, and developer productivity. WasmEdge runs on the following device OSes.

- [Android](/category/build-and-run-wasmedge-on-android)
- [OpenHarmony](../../contribute/source/os/openharmony.md)
- [Raspberry Pi](../../contribute/source/os/raspberrypi.md)
- [The seL4 RTOS](../../contribute/source/os/sel4.md)

With WasmEdge on both the device and the edge server, we can support [isomorphic Server-Side Rendering (SSR)](../../develop/rust/ssr.md) and [microservices](../../start/build-and-run/docker_wasm.md#deploy-the-microservice-example) for rich-client mobile applications that are both portable and upgradeable.
","**Summary**

This document describes the use of WasmEdge, a WebAssembly runtime, on smart devices to enable interactive content rendering, native device driver integration, and access to specialized hardware features. The benefits of using WasmEdge include improved security, safety, portability, manageability, OTA upgradability, and developer productivity.

**Key Components**

1. **WasmEdge**: A WebAssembly runtime that enables the execution of WebAssembly modules on smart devices.
2. **Device OS Support**: WasmEdge runs on various device operating systems, including Android, OpenHarmony, Raspberry Pi, and seL4 RTOS.
3. **Interactive Content Rendering**: WasmEdge can render interactive content on the UI of smart devices.
4. **Native Device Driver Integration**: WasmEdge allows access to native device drivers for specialized hardware features.
5. **Isomorphic Server-Side Rendering (SSR)**: WasmEdge enables isomorphic SSR, allowing for rich-client mobile applications that are both portable and upgradeable.
6. **Microservices Support**: WasmEdge supports microservices architecture for building scalable and maintainable applications.

**Potential Issues or Areas for Improvement**

1. **Compatibility Issues**: Ensuring seamless integration with various device OSes and hardware configurations may require additional testing and optimization.
2. **Performance Optimization**: Optimizing performance, especially on resource-constrained devices, might be necessary to ensure smooth rendering of interactive content.
3. **Security Considerations**: Implementing robust security measures, such as sandboxing and memory protection, is crucial for safeguarding sensitive device resources and user data.
4. **Scalability and Maintainability**: As the application base grows, implementing efficient scaling strategies and monitoring tools will be essential to ensure seamless maintenance and updates."
docs/embed/data/intro.md,"---
sidebar_position: 1
---

# WasmEdge-Bindgen Introduction

Passing complex data like a string is difficult for WebAssembly since WASM does not have a string data type. That's why we have the [WasmEdge-Bindgen](https://github.com/second-state/wasmedge-bindgen) project. The Wasmedge-Bindgen project provides Rust macros for functions to accept and return complex data types and then for functions in the host to call such Rust functions running in WasmEdge.

Now WasmEdge-bindgen supports WasmEdge Go SDK and Rust SDK. I will walk you through how to pass complex data from GO and Rust host to an embedded WASM function.

- [Passing complex data from WasmEdge Go SDK](go.md)
- [Passing complex data from WasmEdge Rust SDK](rust.md)
","**Code Summary**

This is a documentation file for the WasmEdge-Bindgen project, which provides Rust macros for functions to accept and return complex data types in WebAssembly (WASM) environments. The code is written in Markdown format and serves as an introduction to the project.

**Purpose and Functionality**

The purpose of WasmEdge-Bindgen is to simplify the process of passing complex data between host languages (GO and Rust) and embedded WASM functions using the WasmEdge runtime environment. Specifically, it enables host programs to call Rust functions running in WasmEdge with complex data types.

**Key Components**

1. **WasmEdge-Bindgen project**: A set of Rust macros that provide a way to accept and return complex data types.
2. **Rust SDK**: A software development kit for building WasmEdge applications using Rust.
3. **Go SDK**: A software development kit for building WasmEdge applications using GO.

**Potential Issues or Areas for Improvement**

1. **Readability**: The Markdown formatting is clear, but the introduction section could benefit from a brief overview of what complex data types are and why they're difficult to work with in WASM.
2. **Navigation**: The document assumes that readers will navigate to the specific guides for passing complex data from GO and Rust hosts. Consider adding more prominent links or anchors to make navigation easier.
3. **Example Code**: While the introduction provides context, it would be helpful to include example code snippets or links to additional resources for a better understanding of how WasmEdge-Bindgen works.

Overall, this documentation is well-organized and easy to follow. With some minor improvements in readability and navigation, it can serve as an excellent resource for developers exploring the WasmEdge-Bindgen project."
i18n/zh/docusaurus-plugin-content-docs/current/embed/data/intro.md,"---
sidebar_position: 1
---

# WasmEdge-Bindgen Introduction

Passing complex data like a string is difficult for WebAssembly since WASM does not have a string data type. That's why we have the [WasmEdge-Bindgen](https://github.com/second-state/wasmedge-bindgen) project. The Wasmedge-Bindgen project provides Rust macros for functions to accept and return complex data types and then for functions in the host to call such Rust functions running in WasmEdge.

Now WasmEdge-bindgen supports WasmEdge Go SDK and Rust SDK. I will walk you through how to pass complex data from GO and Rust host to an embedded WASM function.

- [Passing complex data from WasmEdge Go SDK](go.md)
- [Passing complex data from WasmEdge Rust SDK](rust.md)
","**Code Analysis Summary**

This is a Markdown file (`intro.md`) used as an introduction to the WasmEdge-Bindgen project. It provides an overview of the challenges of passing complex data between WebAssembly and host languages, and introduces the WasmEdge-Bindgen project as a solution.

**Key Components:**

1. **WasmEdge-Bindgen**: The main topic of the document, which is a Rust macro-based project that enables passing complex data types between WebAssembly and host languages.
2. **Sidebar Positioning**: The file uses Markdown syntax to specify the position of this introduction in a sidebar or navigation menu (`sidebar_position: 1`).
3. **Links to Supporting Content**: The document links to two other Markdown files (`go.md` and `rust.md`) that provide step-by-step guides on how to use WasmEdge-Bindgen with Go SDK and Rust SDK, respectively.

**Potential Issues or Areas for Improvement:**

1. **Lack of Context**: While the introduction provides a brief overview of the challenges, it assumes the reader is already familiar with WebAssembly, WasmEdge, and the context in which these technologies are used.
2. **Ambiguity about Host Languages**: The term ""host language"" might be unclear for readers unfamiliar with the concept. Consider adding a definition or explanation for clarity.
3. **Readability**: Some of the sentences are quite long and convoluted, making it harder to follow the text. Break up complex sentences into simpler ones for better readability.
4. **Tone and Audience**: The tone is informative and technical, but might not be engaging enough for a broader audience. Consider adding examples or anecdotes to make the content more accessible and interesting.

Overall, this introduction provides a good starting point for explaining the purpose and functionality of WasmEdge-Bindgen. With some revisions to address the potential issues mentioned above, it can become an even more effective tool for conveying complex technical information."
docs/start/build-and-run/run.md,"---
sidebar_position: 2
---

# `wasmedge run` CLI

After [installation](../install.md#install), users can execute the `wasmedge run` command.

`wasmedge run` is an alias of `wasmedge` without `-v|--version` option. The usage of the `wasmedge run` tool will be:

```bash
$ wasmedge run -h
USAGE
   wasmedge run [OPTIONS] [--] WASM_OR_SO [ARG ...]
```

## Options

`wasmedge run` is an alias of `wasmedge` without `-v|--version` option.

In the other words, if users want to execute the following command.

```bash
wasmedge --reactor fibonacci.wasm fib 10
```

It is also accepted to add subcommand `run` and will have no difference on execution process and result.

```bash
wasmedge run --reactor fibonacci.wasm fib 10
```
","**Summary**

The `wasmedge run` command is a CLI tool that executes WebAssembly (WASM) files. It is an alias of the `wasmedge` command without the `-v|--version` option. The command takes optional arguments and allows users to specify WASM or Shared Object (SO) files to execute.

**Key Components**

1. **Command Syntax**: `wasmedge run [OPTIONS] [--] WASM_OR_SO [ARG ...]`
2. **Options**: Users can pass additional options to the command, but this is not explicitly documented.
3. **Aliases**: `wasmedge run` and `wasmedge` are considered aliases of each other.

**Functionality**

The `wasmedge run` command allows users to:

1. Execute WASM or SO files using the `--reactor` option.
2. Pass arguments to the executed file, as demonstrated by the example with `fibonacci.wasm` and `fib 10`.

**Potential Issues or Areas for Improvement**

1. **Lack of documentation on options**: The command syntax is provided, but there is no explanation of available options, which may lead to user confusion.
2. **Ambiguous aliases**: While `wasmedge run` and `wasmedge` are considered aliases, this might not be immediately clear to users.
3. **Inconsistent usage examples**: The original example uses `--reactor`, but the rewritten example using the `run` subcommand omits it. It would be more consistent to provide a single usage pattern throughout the documentation."
docs/develop/deploy/kubernetes/kwasm.md,"---
sidebar_position: 10
---

# Kwasm

[Kwasm](https://kwasm.sh/) is a Kubernetes Operator that adds WebAssembly support to your Kubernetes nodes.

## Quick start

You will need a running Kubernetes cluster to install Kwasm operator. Here we use a fresh cluster created by [kind](https://kind.sigs.k8s.io/):

```bash
kind create cluster
```

You will also need to [install helm](https://helm.sh/docs/intro/install/) to setup Kwasm:

```bash
helm repo add kwasm http://kwasm.sh/kwasm-operator/
helm repo update
helm install -n kwasm --create-namespace kwasm kwasm/kwasm-operator
kubectl annotate node --all kwasm.sh/kwasm-node=true
```

Apply the yaml file for the wasm job:

```bash
kubectl apply -f https://raw.githubusercontent.com/KWasm/kwasm-node-installer/main/example/test-job.yaml
```

After the job is finished, check the log:

```bash
kubectl logs job/wasm-test
```
","**Summary**

This documentation guide explains how to deploy the Kwasm Kubernetes Operator, which adds WebAssembly support to Kubernetes nodes. The guide provides a quick start section that outlines the necessary steps to install and run Kwasm on a fresh Kubernetes cluster created with Kind.

**Key Components**

1. **Kwasm Operator**: A Kubernetes Operator that adds WebAssembly support to nodes.
2. **Kind**: A tool for creating local Kubernetes clusters.
3. **Helm**: A package manager for installing and managing applications in Kubernetes.
4. **Kubectl**: The command-line interface for interacting with a Kubernetes cluster.

**Functionality**

The guide provides the following steps:

1. Create a fresh Kubernetes cluster using Kind.
2. Install Helm and add the Kwasm repository.
3. Install the Kwasm Operator using Helm.
4. Annotate all nodes in the cluster to indicate they support Kwasm.
5. Apply a YAML file for a wasm job, which runs on the Kwasm-enabled nodes.
6. Check the logs of the wasm job.

**Potential Issues or Areas for Improvement**

1. **Security**: The guide assumes that installing Helm and running `helm install` with admin privileges is secure. In production environments, careful consideration should be given to security best practices when using Helm.
2. **Cluster Configuration**: The guide does not mention any specific cluster configurations required for Kwasm to work correctly. It's essential to verify the compatibility of the Kubernetes version and other settings before deploying Kwasm.
3. **Troubleshooting**: The guide only provides a basic example of how to check logs, which might not be sufficient for troubleshooting more complex issues with the wasm job or Kwasm Operator.

By addressing these potential issues and areas for improvement, the guide can provide more robust guidance for deploying and managing Kwasm on Kubernetes clusters."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kwasm.md,"---
sidebar_position: 10
---

# Kwasm

[Kwasm](https://kwasm.sh/) is a Kubernetes Operator that adds WebAssembly support to your Kubernetes nodes.

## Quick start

You will need a running Kubernetes cluster to install Kwasm operator. Here we use a fresh cluster created by [kind](https://kind.sigs.k8s.io/):

```bash
kind create cluster
```

You will also need to [install helm](https://helm.sh/docs/intro/install/) to setup Kwasm:

```bash
helm repo add kwasm http://kwasm.sh/kwasm-operator/
helm repo update
helm install -n kwasm --create-namespace kwasm kwasm/kwasm-operator
kubectl annotate node --all kwasm.sh/kwasm-node=true
```

Apply the yaml file for the wasm job:

```bash
kubectl apply -f https://raw.githubusercontent.com/KWasm/kwasm-node-installer/main/example/test-job.yaml
```

After the job is finished, check the log:

```bash
kubectl logs job/wasm-test
```
","**Summary:**

The provided code snippet appears to be a documentation page for installing and configuring the Kwasm Kubernetes Operator on a Kubernetes cluster. The operator adds WebAssembly support to nodes in the cluster.

**Key Components:**

1. **Quick Start:** A step-by-step guide to setting up a fresh Kubernetes cluster using kind.
2. **Helm Installation:** Instructions to install Helm, a package manager for Kubernetes.
3. **Kwasm Operator Installation:** Commands to add the Kwasm operator repository and install the operator using Helm.
4. **Annotation:** An annotation is applied to all nodes in the cluster to mark them as Kwasm-enabled.
5. **WASM Job Configuration:** A YAML file is applied to create a WASM job, which can be customized for specific use cases.

**Potential Issues or Areas for Improvement:**

1. **Prerequisites:** The documentation assumes that kind and Helm are already installed on the system. However, it may not be clear to users how to install these prerequisites.
2. **Error Handling:** There is no mention of potential errors that might occur during installation or configuration, such as network connectivity issues or permission problems.
3. **Customization Options:** The example YAML file provided for the WASM job may not be suitable for all use cases. It would be helpful to provide more guidance on customizing this file.
4. **Security Considerations:** There is no mention of security considerations when using Kwasm, such as authentication and authorization mechanisms.

**Recommendations:**

1. Provide clear instructions on how to install prerequisites like kind and Helm.
2. Add error handling and troubleshooting sections to help users debug potential issues.
3. Offer more customization options for the WASM job YAML file.
4. Include security considerations and best practices for using Kwasm in production environments."
docs/contribute/source/os/raspberrypi.md,"---
sidebar_position: 9
---

# Build on Raspberry Pi

Raspberry Pi uses 64-bit processors starting from the 3 Model B. So WasmEdge can be executed on Raspberry Pi as well. For ARM, you can choose any 64-bit Linux distribution, such as Raspbian, Ubuntu, or Manjaro. This document has been tested on the Manjaro for ARM distribution, and the hardware is the Raspberry Pi 3 Model B.

The installation steps are no different from the [installation document](../../../start/install.md#install), and the execution is the same. Here's a video about installing WasmEdge and running a simple WebAssembly module to add two numbers up.

[![asciicast](https://asciinema.org/a/458453.svg)](https://asciinema.org/a/458453)
","**Summary**

This code is a documentation page for building and running WasmEdge on a Raspberry Pi. It explains that the Raspberry Pi's 64-bit processor allows WasmEdge to run on it, and provides information on how to choose a suitable Linux distribution (Raspbian, Ubuntu, or Manjaro) for ARM architecture. The installation steps are identical to those in the [installation document](../../../start/install.md#install), and execution is also the same.

**Key Components**

1. **Platform Information**: The code mentions that Raspberry Pi uses 64-bit processors from the 3 Model B onwards, enabling WasmEdge execution.
2. **Linux Distribution Options**: It lists three compatible Linux distributions for ARM architecture: Raspbian, Ubuntu, and Manjaro.
3. **Installation Link**: A link to the [installation document](../../../start/install.md#install) is provided, indicating that installation steps are the same as on other platforms.
4. **Execution Information**: Execution on Raspberry Pi is mentioned to be the same as on other platforms.
5. **Video Link**: A video demonstration of installing WasmEdge and running a simple WebAssembly module is linked.

**Potential Issues or Areas for Improvement**

1. **Platform Specificity**: While the code mentions that the hardware tested was the Raspberry Pi 3 Model B, it may be beneficial to provide more detailed platform information (e.g., specific versions of Linux distributions).
2. **Installation Steps Repetition**: The link to the [installation document](../../../start/install.md#install) repeats some installation steps. It might be better to provide a concise summary or checklist of platform-specific setup requirements.
3. **Video Content**: While the video is a good way to demonstrate WasmEdge execution, it's not directly integrated into the documentation. Consider adding a code snippet or example usage instead, or providing additional details about the WebAssembly module used in the video."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/raspberrypi.md,"---
sidebar_position: 9
---

# Build on Raspberry Pi

Raspberry Pi uses 64-bit processors starting from the 3 Model B. So WasmEdge can be executed on Raspberry Pi as well. For ARM, you can choose any 64-bit Linux distribution, such as Raspbian, Ubuntu, or Manjaro. This document has been tested on the Manjaro for ARM distribution, and the hardware is the Raspberry Pi 3 Model B.

The installation steps are no different from the [installation document](../../../start/install.md#install), and the execution is the same. Here's a video about installing WasmEdge and running a simple WebAssembly module to add two numbers up.

[![asciicast](https://asciinema.org/a/458453.svg)](https://asciinema.org/a/458453)
","**Summary**

This Markdown file is part of the i18n/zh/docusaurus-plugin-content-docs documentation for WasmEdge. It describes how to build and run WasmEdge on a Raspberry Pi device, specifically targeting 64-bit processors.

**Functionality**

The code serves as an instructional guide for users who want to install and execute WasmEdge on a Raspberry Pi. The document:

1. **Explains compatibility**: Highlights that WasmEdge can be executed on Raspberry Pi devices with 64-bit processors starting from the 3 Model B.
2. **Lists compatible Linux distributions**: Provides examples of ARM-based 64-bit Linux distributions (Raspbian, Ubuntu, or Manjaro) for users to install WasmEdge.
3. **References installation steps**: Links to a separate document (`installation document`) for detailed installation instructions.

**Key Components**

1. **Markdown syntax**: The file is written in Markdown format, using features like headers (#), links ([...](...)).
2. **Image and video embed**: Embeds an Asciinema video demonstrating the installation process.
3. **Linking**: Provides a link to a related document (`installation document`) for further information.

**Potential Issues/Improvements**

1. **Outdated compatibility information**: The Raspberry Pi 3 Model B is an older device; consider updating the text to reflect newer models' capabilities or hardware compatibility changes.
2. **Lack of concrete system requirements**: While mentioning compatible Linux distributions, it's unclear what specific minimum system configurations are required for WasmEdge execution.
3. **Readability improvements**: Breaking up long paragraphs and using concise headings can improve readability.

Overall, this code provides a clear and concise instructional guide on how to build and run WasmEdge on Raspberry Pi devices with 64-bit processors."
i18n/zh/docusaurus-plugin-content-docs/current/start/usage/use-cases.md,"---
sidebar_position: 1
---

# 使用案例

由于 WasmEdge 具备 AOT（Ahead of Time）编译器优化，是当今市场上最快的 WebAssembly 运行时之一。因此，在边缘计算、汽车行业、Jamstack、无服务器架构、SaaS、服务网格，甚至区块链应用中广泛使用。

- 现代 Web 应用程序具有丰富的用户界面，这些界面在浏览器和/或边缘云上渲染。WasmEdge 与流行的 Web UI 框架（如 React、Vue、Yew 和 Percy）合作，支持边缘服务器上的同构 [服务器端渲染（SSR）](../../embed/use-case/ssr-modern-ui.md) 功能。它还可以支持在边缘云上为 Unity3D 动画和 AI 生成的交互式视频进行服务器端渲染，用于 Web 应用程序。

- WasmEdge 为微服务提供了一个轻量级、安全且高性能的运行时。它与 Dapr 等应用服务框架以及 Kubernetes 等服务编排器完全兼容。WasmEdge 微服务可以在边缘服务器上运行，并且可以访问分布式缓存，以支持现代 Web 应用程序的无状态和有状态业务逻辑功能。另外相关的有：公共云中的无服务器函数即服务。

- [无服务器 SaaS（软件即服务）](/category/serverless-platforms) 函数使用户可以在不运营自己的 API 回调服务器的情况下扩展和自定义其 SaaS 体验。无服务器函数可以嵌入到 SaaS 中，或者驻留在与 SaaS 服务器相邻的边缘服务器上。开发人员可以简单地上传函数来响应 SaaS 事件或连接 SaaS API。

- [智能设备应用](./wasm-smart-devices.md) 可以将 WasmEdge 嵌入为中间件运行时，用于在 UI 上呈现交互式内容、连接原生设备驱动程序，并访问专门的硬件功能（例如，用于 AI 推断的 GPU）。与本地编译的机器码相比，WasmEdge 运行时的优势包括安全性、安全性、可移植性、可管理性和开发者生产力。WasmEdge 可在 Android、OpenHarmony 和 seL4 RTOS 设备上运行。

- WasmEdge 可以支持高性能的领域特定语言（DSL），或者作为一个云原生的 JavaScript 运行时，通过嵌入 JS 执行引擎或解释器。

- 开发人员可以利用诸如 [Kubernetes](../../develop/deploy/kubernetes/kubernetes-containerd-crun.md)、Docker 和 CRI-O 等容器工具来部署、管理和运行轻量级的 WebAssembly 应用程序。

- WasmEdge 应用程序可以插入到现有的应用程序框架或平台中。

如果你对 WasmEdge 有任何好的想法，请毫不犹豫地开启一个 GitHub 问题，我们一起讨论。
","**Summary:**

The provided Markdown file describes various use cases for WasmEdge, a WebAssembly runtime that enables Ahead-of-Time (AOT) compilation and optimization. The file highlights the versatility of WasmEdge in supporting modern web applications, microservices, serverless architectures, SaaS functions, smart devices, and high-performance domain-specific languages.

**Key Components:**

1. **WasmEdge**: A WebAssembly runtime that provides a lightweight, secure, and high-performance execution environment.
2. **Use Cases**:
	* Modern web applications with rich UIs
	* Microservices with compatibility with Dapr and Kubernetes
	* Serverless SaaS functions
	* Intelligent devices applications (e.g., Android, OpenHarmony, seL4 RTOS)
	* High-performance domain-specific languages (DSL) or cloud-native JavaScript runtime
3. **Deployment and Management**: Utilizing container tools like Kubernetes, Docker, and CRI-O to deploy, manage, and run WebAssembly applications

**Potential Issues or Areas for Improvement:**

1. **Code Complexity**: The Markdown file is lengthy and may benefit from reorganization into separate sections or sub-documents to improve readability.
2. **Link Clusters**: There are multiple links within the document that lead to external resources (e.g., other MD files, GitHub issues). Consider using anchor links or a table of contents to make navigation easier.
3. **Cross-References**: Some sentences or phrases reference content not explicitly mentioned in this Markdown file. Ensure consistency and provide clear context for cross-references.
4. **SEO**: Optimize the document's metadata (e.g., title, description) for better search engine visibility.

**Additional Recommendations:**

1. **Use headings and subheadings**: Enhance readability by using clear headings and subheadings to structure the content.
2. **Shorten long sentences**: Break up lengthy sentences into shorter ones to improve comprehension.
3. **Add images or diagrams**: Incorporate visual elements to illustrate complex concepts, making it easier for readers to understand.
4. **Review grammar and spelling**: Ensure accuracy in language usage and eliminate any grammatical or spelling errors."
i18n/zh/docusaurus-plugin-content-docs/current/start/overview.md,"---
sidebar_position: 1
displayed_sidebar: startSidebar
---

# 开始使用 WasmEdge

WasmEdge 是一款轻量级、高性能、可扩展的 WebAssembly 运行时，适用于云原生、边缘和去中心化应用。它支持无服务器应用、嵌入式函数、微服务、UDF、智能合约和物联网设备。WasmEdge 目前是 CNCF（Cloud Native Computing Foundation）的沙盒项目。

WasmEdge 运行时为其包含的 WebAssembly 字节码程序提供了良好定义的执行沙盒环境。该运行时提供了对操作系统资源（例如文件系统、套接字、环境变量、进程）和内存空间的隔离和保护。WasmEdge 最重要的使用场景是将用户定义的或社区贡献的代码作为软件产品中的插件（例如 SaaS、数据库、边缘节点，甚至区块链节点）安全地执行。它使第三方开发者、供应商、提供者和社区成员能够扩展和定制软件产品。

本章将介绍如何安装并开始使用 WasmEdge。

涵盖以下内容：

- [安装和卸载 WasmEdge](install.md)
- [入门指南](/category/getting-started-with-wasmEdge)
- 介绍 [WasmEdge 运行时](/category/what-is-wasmedge)
- [运行 WasmEdge](/category/running-with-wasmedge)

对于使用 WasmEdge 进行高级编程，请参考[开发 WASM 应用程序](../develop/overview.md)，[在应用中嵌入 WasmEdge](../embed/overview.md)，或向 WasmEdge [进行贡献](../contribute/overview.md) 的指南。

如果你有任何问题或有任何反馈，请通过以下方式联系我们：

- [Discord 聊天](https://discord.gg/U4B5sFTkFc)
- [创建 GitHub 问题以获取技术支持](https://github.com/WasmEdge/WasmEdge/issues)
- [提交 GitHub 讨论](https://github.com/WasmEdge/WasmEdge/discussions)
- [在 Twitter 关注 @realwasmedge](https://twitter.com/realwasmedge)
对于使用 WasmEdge 进行高级编程，请参考[开发 WASM 应用程序](../develop/overview.md)，[在应用中嵌入 WasmEdge](../embed/overview.md)，或向 WasmEdge [进行贡献](../contribute/overview.md) 的指南。

如果你有任何问题或有任何反馈，请通过以下方式联系我们：

- [Discord 聊天](https://discord.gg/U4B5sFTkFc)
- [创建 GitHub 问题以获取技术支持](https://github.com/WasmEdge/WasmEdge/issues)
- [提交 GitHub 讨论](https://github.com/WasmEdge/WasmEdge/discussions)
- [在 Twitter 关注 @realwasmedge](https://twitter.com/realwasmedge)
","**Code Summary**

This is a Markdown file titled ""开始使用 WasmEdge"" (Getting Started with WasmEdge) located in the docusaurus-plugin-content-docs project. The code provides an overview of WasmEdge, a lightweight, high-performance WebAssembly runtime, and its use cases.

**Key Components**

1. **Introduction**: A brief introduction to WasmEdge, highlighting its features and benefits.
2. **Use Cases**: A list of scenarios where WasmEdge can be used, including cloud-native, edge computing, decentralized applications, and IoT devices.
3. **Installation Guide**: A link to the installation guide for WasmEdge.
4. **Getting Started**: A link to a getting-started guide for WasmEdge.
5. **WasmEdge Runtime**: An introduction to the WasmEdge runtime environment.
6. **Running WasmEdge**: Instructions on how to run WasmEdge.
7. **Advanced Programming**: Links to guides on developing WASM applications, embedding WasmEdge in applications, and contributing to WasmEdge.
8. **Support**: Information on how to contact the WasmEdge team for support.

**Potential Issues or Areas for Improvement**

1. The code is written in Chinese, which may limit its accessibility to non-Chinese speakers.
2. There are multiple links to external resources, including Discord, GitHub, and Twitter, which may make it difficult for users to find relevant information.
3. Some of the links are not clickable, as they are encoded URLs.
4. The code could benefit from additional formatting and headings to improve readability.

Overall, the code provides a good introduction to WasmEdge and its use cases, but there are some areas for improvement in terms of accessibility, formatting, and link organization."
docs/develop/deploy/cri-runtime/containerd.md,"---
sidebar_position: 1
---

# Deploy with containerd's runwasi

The containerd-shim [runwasi](https://github.com/containerd/runwasi/) project supports WasmEdge.

## Prerequisites

1. [Install Rust](https://www.rust-lang.org/tools/install) because we need to compile the runwasi project.

2. Download the runwasi project

   ```bash
   git clone https://github.com/containerd/runwasi.git
   ```

3. Build and install the wasmedge-containerd-shim

   ```bash
   # Reference: https://github.com/containerd/runwasi/blob/main/CONTRIBUTING.md#setting-up-your-local-environment
   cd runwasi
   ./scripts/setup-linux.sh
   make build-wasmedge
   INSTALL=""sudo install"" LN=""sudo ln -sf"" make install-wasmedge
   ```

## Run a simple Wasi app

   ```bash
   make load
   sudo ctr run --rm --runtime=io.containerd.wasmedge.v1 ghcr.io/containerd/runwasi/wasi-demo-app:latest testwasm /wasi-demo-app.wasm echo 'hello'
   ```
","**Code Analysis Summary**

The code is a deployment guide for using the `containerd-shim` project with WasmEdge, which provides a runtime environment for WebAssembly (WASM) applications. The purpose of this guide is to outline the steps required to deploy and run a simple WASM application using `runwasi`, a containerization solution that supports WasmEdge.

**Key Components**

1. Prerequisites:
	* Install Rust: necessary for compiling the `runwasi` project.
	* Download the `runwasi` project from GitHub.
2. Building and installing `wasmedge-containerd-shim`:
	+ Run scripts to set up the local environment (using `setup-linux.sh`)
	+ Build and install the shim using `make`
3. Running a simple WASM application:
	+ Load the `runwasi` project into container runtime
	+ Run a `ctr` command with `--rm` option, specifying the runtime as `io.containerd.wasmedge.v1`, to execute the WASM application

**Potential Issues and Areas for Improvement**

* The guide assumes a Linux environment and does not provide instructions for other platforms (e.g., macOS or Windows).
* The `setup-linux.sh` script may not work on all distributions or environments.
* There is no error handling or debugging information in case of issues during the installation or execution process.
* The example application (`wasi-demo-app`) and its configuration might require modifications to suit specific requirements.
* There could be more detailed explanations of the containerization and runtime concepts involved."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/cri-runtime/containerd.md,"---
sidebar_position: 1
---

# Deploy with containerd's runwasi

The containerd-shim [runwasi](https://github.com/containerd/runwasi/) project supports WasmEdge.

## Prerequisites

1. [Install Rust](https://www.rust-lang.org/tools/install) because we need to compile the runwasi project.

2. Download the runwasi project

   ```bash
   git clone https://github.com/containerd/runwasi.git
   ```

3. Build and install the wasmedge-containerd-shim

   ```bash
   cd runwasi
   make build-wasmedge
   INSTALL=""sudo install"" LN=""sudo ln -sf"" make install-wasmedge
   ```

## Run a simple Wasi app

   ```bash
   make load
   sudo ctr run --rm --runtime=io.containerd.wasmedge.v1 ghcr.io/containerd/runwasi/wasi-demo-app:latest testwasm /wasi-demo-app.wasm echo 'hello'
   ```
","**Code Summary**

This code is a part of the Docusaurus documentation for deploying a CRI (Container Runtime Interface) runtime with containerd's runwasi project. The purpose of this code is to guide users through setting up and running a simple WasmEdge application using containerd.

**Key Components**

1. **Prerequisites**: The section outlines the necessary steps to install Rust, download the runwasi project, and build/install the wasmedge-containerd-shim.
2. **Run a simple Wasi app**: This section provides the command to load the wasmedge-containerd-shim and run a simple WasmEdge application.

**Potential Issues or Areas for Improvement**

1. **Security**: The code assumes that users will install and run the containerd-shim as root, which may pose security risks. It would be better to provide instructions on how to use a non-root user.
2. **Error Handling**: There is no error handling in the provided code. Adding try-catch blocks or other error-handling mechanisms would improve the robustness of the setup process.
3. **Documentation**: While this code snippet is part of a larger documentation, it could benefit from additional explanations and examples to make it easier for users to follow along.

Overall, the code provides clear instructions on how to set up and run a CRI runtime with containerd's runwasi project. With some minor adjustments, it can be made even more user-friendly and secure."
docs/start/wasmedge/component_model.md,"---
sidebar_position: 4
---

# Component Model

The component model for WASM would dramatically improve WASM module’s reusability and composability. It will allow better access from one WASM module to other modules and systems, including the operating system APIs (e.g., networking).

WasmEdge is already committed to supporting and implementing [the component model proposal](https://github.com/WebAssembly/component-model). See the related issue [here](https://github.com/WasmEdge/WasmEdge/issues/1892).

After the support for the component model is done, WasmEdge could be integrated by Spin and Spiderlightning.
","**Summary**

The code snippet is an excerpt from a documentation file describing the Component Model for WASM (WebAssembly). The Component Model aims to enhance the reusability and composability of WASM modules by enabling better access between modules and system APIs. WasmEdge, a WebAssembly runtime, has committed to implementing this proposal.

**Key Components**

1. **Component Model**: A proposed standard for improving the modularity and integration of WASM modules.
2. **WasmEdge**: A WebAssembly runtime that will support and implement the Component Model.
3. **Spin** and **Spiderlightning**: Tools or frameworks that may integrate with WasmEdge after the Component Model is supported.

**Potential Issues or Areas for Improvement**

1. **Limited context**: The documentation snippet assumes prior knowledge of WASM, WasmEdge, and the Component Model proposal.
2. **Lack of implementation details**: The text does not provide insight into how WasmEdge will implement the Component Model or what specific changes are required.
3. **Unclear integration plans**: The mention of Spin and Spiderlightning's potential integration with WasmEdge is vague, and it is unclear what specific benefits or challenges this may bring.

To improve the code snippet, additional context and implementation details could be added to make it more accessible and informative for readers unfamiliar with the topic."
i18n/zh/docusaurus-plugin-content-docs/current/start/build-and-run/run.md,"---
sidebar_position: 2
---

# `wasmedge run` 

安装完成后（参见[安装](../install.md#install)），用户可以执行 `wasmedge run` 命令。

`wasmedge run` 是不带 `-v|--version` 选项的 `wasmedge` 的别名。`wasmedge run` 工具的用法如下：

```bash
$ wasmedge run -h
USAGE
   wasmedge run [OPTIONS] [--] WASM_OR_SO [ARG ...]
```

## 选项

`wasmedge run` 是不带 `-v|--version` 选项的 `wasmedge` 的别名。

换句话说，如果用户希望执行以下命令。

```bash
wasmedge --reactor fibonacci.wasm fib 10
```

也可以使用子命令 `run`，在执行过程和结果上不会有任何区别。

```bash
wasmedge run --reactor fibonacci.wasm fib 10
```
","**Summary**

The provided code is a documentation for the `wasmedge run` command, which is an alias of the `wasmedge` command without the `-v|--version` option. This command allows users to execute WebAssembly (WASM) files in a sandboxed environment.

**Key Components**

1. **Command syntax**: The code provides the usage syntax for the `wasmedge run` command, which takes a WASM or SO file as input and optional arguments.
2. **Options**: The documentation mentions that the `run` subcommand is equivalent to executing the main `wasmedge` command with the same arguments, without any differences in execution or results.

**Potential Issues/Improvements**

1. **Lack of clarity on reactor option**: The documentation only briefly mentions the `--reactor` option, but its purpose and usage are not clear.
2. **Insufficient error handling**: There is no information on how to handle errors that may occur when executing WASM files or passing arguments.
3. **Missing examples for non-standard use cases**: While the code provides an example for using the `--reactor` option, it would be beneficial to include more examples for less common scenarios, such as specifying custom command-line flags or handling environment variables.

Overall, the code provides a good starting point for understanding the basic usage of the `wasmedge run` command. However, additional documentation and clarifications are necessary to make it a comprehensive resource for users."
docs/start/usage/serverless/tencent.md,"---
sidebar_position: 4
---

# WebAssembly serverless functions on Tencent Cloud

As the main users of Tencent Cloud are from China, so the tutorial is [written in Chinese](https://my.oschina.net/u/4532842/blog/5172639).

We also provide a code template for deploying serverless WebAssembly functions on Tencent Cloud, please check out [the tencent-scf-wasm-runtime repo](https://github.com/second-state/tencent-scf-wasm-runtime).

Fork the repo and start writing your own rust functions.
","**Summary**

The provided code snippet is a Markdown file documenting the usage of WebAssembly serverless functions on Tencent Cloud. The tutorial is written in Chinese due to the primary user base being from China. The file includes links to external resources, including a blog post and a GitHub repository containing a code template for deploying serverless WebAssembly functions.

**Key Components**

*   Links to:
    *   A Chinese-language tutorial on My OS China
    *   The Tencent SCF Wasm Runtime GitHub repository
*   Instructions to fork the repo and write own Rust functions

**Purpose**

The purpose of this Markdown file is to provide users with a starting point for deploying serverless WebAssembly functions on Tencent Cloud. It directs them to external resources, including documentation and code templates, to help them get started.

**Areas for Improvement**

*   The language barrier posed by the Chinese-language tutorial may be a significant limitation for non-Chinese speaking developers.
*   The instruction to fork the repo assumes that users have basic knowledge of Git and GitHub, which might not be the case for all users."
docs/develop/deploy/docker_wasm.md,"---
sidebar_position: 2
---

# Docker + Wasm

Docker announced its support for WebAssembly in partnership with WasmEdge. Now we can use one single command line `docker compose up` to run WASM Apps.

Please refer to the [Quick start with Docker](../../start/getting-started/quick_start_docker.md) part.
","**Code Analysis Summary**

This code is a Markdown file (`docker_wasm.md`) located in the `docs/develop/deploy` directory. It appears to be part of a documentation set for deploying WebAssembly (WASM) applications using Docker.

**Purpose and Functionality**

The purpose of this code is to introduce and explain how to deploy WASM Apps using Docker, specifically highlighting the partnership between Docker and WasmEdge. The code serves as a quick reference guide, pointing users to another document (`quick_start_docker.md`) for further instructions on getting started with deploying Docker containers.

**Key Components**

* Markdown syntax: Used to format text and structure content.
* Sidebar configuration: `sidebar_position` is set to 2, indicating the position of this page in a sidebar or table of contents.
* Link to another document: `[Quick start with Docker](../../start/getting-started/quick_start_docker.md)`

**Potential Issues or Areas for Improvement**

1. **Lack of context**: The code snippet is incomplete and lacks surrounding content, making it difficult to understand the full context in which this information is presented.
2. **Assumed knowledge**: Readers are assumed to have prior knowledge about Docker, WASM Apps, and WasmEdge, which may not be the case for new users.
3. **Inconsistent formatting**: The Markdown code uses a mix of bold and italic text styles; using a consistent style throughout would improve readability.

Overall, this code appears to be a useful reference guide for developers familiar with Docker and WASM Apps. However, it could benefit from additional context and clarity to make it more accessible to new users."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/docker_wasm.md,"---
sidebar_position: 2
---

# Docker + Wasm

Docker announced its support for WebAssembly in partnership with WasmEdge. Now we can use one single command line `docker compose up` to run WASM Apps.

Please refer to the [Quick start with Docker](../../start/getting-started/quick_start_docker.md) part.
","**Summary:**

The provided code is a Markdown file (`docker_wasm.md`) in the Docusaurus documentation project, specifically targeting Chinese-speaking users. The file describes the integration of WebAssembly (WASM) with Docker and provides instructions on how to run WASM apps using a single command line.

**Key Components:**

1. **Documentation**: This file is part of the Docusaurus documentation project, serving as a tutorial or guide for users.
2. **WebAssembly and Docker**: The content focuses on the integration of WASM with Docker, enabling users to deploy WASM-based applications using Docker containers.
3. **Quick Start Link**: The file includes a link to another Markdown file (`quick_start_docker.md`) which is likely a step-by-step guide on getting started with Docker.

**Functionality:**

1. **Introduction**: The file introduces the concept of WebAssembly in Docker and its benefits.
2. **Instructions**: It provides instructions on how to run WASM apps using Docker Compose.

**Potential Issues or Areas for Improvement:**

1. **Lack of Specific Instructions**: While the file mentions a Quick Start link, it would be beneficial to include more detailed steps within this document.
2. **Assumes Prior Knowledge**: The content assumes that users are familiar with Docker and WebAssembly basics; adding introductory sections could enhance user understanding.

Overall, this Markdown file provides a good starting point for users interested in deploying WASM apps using Docker. However, it would benefit from additional detail and context to make the instructions more comprehensive and accessible to readers."
i18n/zh/docusaurus-plugin-content-docs/current/start/usage/wasm-smart-devices.md,"---
sidebar_position: 4
---

# WasmEdge 在智能设备上

智能设备应用可以将 WasmEdge 嵌入为中间件运行时，以在用户界面上呈现交互式内容，连接原生设备驱动程序，并访问专门的硬件功能（例如，用于 AI 推断的 GPU）。WasmEdge 运行时相对于本地编译的机器码的优势包括安全性、安全性、可移植性、可管理性、OTA 升级能力和开发者生产力。WasmEdge 可在以下设备操作系统上运行。

- [Android](/category/build-and-run-wasmedge-on-android)
- [OpenHarmony](../../contribute/source/os/openharmony.md)
- [Raspberry Pi](../../contribute/source/os/raspberrypi.md)
- [The seL4 RTOS](../../contribute/source/os/sel4.md)

通过在设备和边缘服务器上使用 WasmEdge，我们可以为丰富的客户端移动应用程序提供支持，实现[同构的服务器端渲染（SSR）](../../develop/rust/ssr.md)和[微服务](../../start/build-and-run/docker_wasm.md#deploy-the-microservice-example)，使其具备可移植性和可升级性。
","**Summary**

This is a documentation page for using WasmEdge on smart devices. It explains how WasmEdge can be embedded as a middleware runtime to run interactive content on user interfaces, connect native device drivers, and access specific hardware features (e.g., GPU for AI inference). The page highlights the benefits of running WasmEdge over machine code, including security, safety, portability, manageability, OTA upgrade capabilities, and developer productivity.

**Key Components**

1. **WasmEdge**: A middleware runtime that can be embedded on smart devices.
2. **Smart Devices**: Supported platforms include Android, OpenHarmony, Raspberry Pi, and the seL4 RTOS.
3. **Benefits**: Security, safety, portability, manageability, OTA upgrade capabilities, and developer productivity.

**Potential Issues or Areas for Improvement**

1. **Lack of detailed technical information**: The page focuses on high-level benefits and supported platforms, but lacks technical details about how to implement WasmEdge on smart devices.
2. **Unclear instructions**: The page links to other documentation pages, but it's unclear which ones are relevant for implementing WasmEdge on specific platforms.
3. **Limited platform support**: The page only mentions a few supported platforms, whereas the target audience may be interested in using WasmEdge on other devices.

**Recommendations**

1. Add more technical details about implementing WasmEdge on smart devices, including code snippets or example projects.
2. Clearly document instructions for each supported platform.
3. Expand platform support to include other popular smart device platforms (e.g., iOS, Linux-based devices)."
docs/contribute/source/os/openharmony.md,"---
sidebar_position: 7
---

# Build on OpenHarmony

<!-- prettier-ignore -->
:::info
Work in Progress
:::
 For Chinese speakers, please [check out this instruction](https://github.com/WasmEdge/WasmEdge/blob/master/utils/ohos/README-zh.md).
","**Code Analysis:**

The provided code is a Markdown file located in the `docs/contribute/source/os/openharmony.md` directory. Here's a summary of its purpose, functionality, and key components:

**Purpose:** The code is intended to provide instructions on how to build OpenHarmony, a Chinese operating system.

**Functionality:**

1. **Sidebar Positioning**: The code sets the sidebar position to 7 using the `sidebar_position` attribute.
2. **Informational Notice**: A ""Work in Progress"" notice is displayed using the `:::info` syntax.
3. **Link to Instructions for Chinese Speakers**: The file contains a link to an external README file (in Chinese) that provides additional instructions on building OpenHarmony.

**Key Components:**

1. Markdown syntax and attributes (e.g., `sidebar_position`, `:::info`)
2. Link to external documentation

**Potential Issues or Areas for Improvement:**

1. **Language**: The code is written in English, but it links to a Chinese-language README file. It would be more helpful to provide both language options within the same document.
2. **Lack of Context**: The ""Work in Progress"" notice doesn't provide any context about what's being worked on or why the instructions are not yet complete.
3. **Incomplete Instructions**: The link to the external README file is provided without explaining why users would need to read it instead of following the instructions in this document.

**Suggestions for Improvement:**

1. Merge the language options into a single document with translation attributes.
2. Provide more context about what's being worked on and why the instructions are not yet complete.
3. Consider copying relevant content from the external README file into this document to reduce the need for users to navigate externally."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/source/os/openharmony.md,"---
sidebar_position: 7
---

# Build on OpenHarmony

<!-- prettier-ignore -->
:::info
Work in Progress
:::
 For Chinese speakers, please [check out this instruction](https://github.com/WasmEdge/WasmEdge/blob/master/utils/ohos/README-zh.md).
","Here is a concise summary of the code:

**Purpose:** This Markdown file appears to be part of a documentation system, specifically providing information on contributing to OpenHarmony.

**Functionality:**

* The file has been assigned a position in the sidebar (`sidebar_position: 7`), indicating its place within the overall documentation structure.
* A notice is displayed informing readers that the content is ""Work in Progress"" (WIP).
* A link is provided for Chinese speakers, directing them to an external resource with further instructions.

**Key Components:**

* `:::info`: A Markdown codeblock used to render a highlighted warning or information box.
* `pretter-ignore`: A comment indicating that the following lines should be ignored by the Prettier code formatter.
* `sidebar_position` property: Sets the position of this page in the sidebar.

**Potential Issues or Areas for Improvement:**

* The WIP notice may not be sufficient to convey the current state of the content. Consider adding a more explicit label (e.g., ""Draft"") or providing a clear indication of when the content is expected to be complete.
* The link provided for Chinese speakers may become outdated if the target resource is updated or deleted. It would be beneficial to provide a more permanent reference, such as a repository branch or commit hash."
i18n/zh/docusaurus-plugin-content-docs/current/start/wasmedge/component_model.md,"---
sidebar_position: 4
---

# 组件模型

WASM 的组件模型将大幅改善 WASM 模块的可重用性和可组合性。它将允许一个 WASM 模块更好地访问其他模块和系统，包括操作系统的 API（例如网络功能）。

WasmEdge 已经致力于支持和实现 [组件模型提案](https://github.com/WebAssembly/component-model)。请在[此处](https://github.com/WasmEdge/WasmEdge/issues/1892)查看相关问题。

在支持组件模型之后，WasmEdge 将能够被 Spin 和 Spiderlightning 集成。
","**Summary**

The provided code is a markdown file located in the `i18n/zh/docusaurus-plugin-content-docs/current/start/wasmedge/component_model.md` directory. It discusses the Component Model for WebAssembly (WASM) and its potential benefits, including improved reusability and composability of WASM modules.

**Key Components**

1. **Component Model**: The code describes the WASM component model, which enables a WASM module to access other modules and system APIs.
2. **WasmEdge Support**: The text mentions that WasmEdge is committed to supporting and implementing the Component Model proposal.
3. **Integration with Spin and Spiderlightning**: After supporting the Component Model, WasmEdge will be able to integrate with Spin and Spiderlightning.

**Potential Issues or Areas for Improvement**

1. **Lack of technical details**: The text provides a general overview but lacks specific technical details about the Component Model, making it challenging for developers to understand its implementation.
2. **No clear guidelines for adoption**: The code does not provide guidance on how to adopt the Component Model in existing projects or when to expect WasmEdge's support.

**Recommendations**

To improve this content:

1. Provide more technical details about the Component Model, including examples and use cases.
2. Offer guidance on how to adopt the Component Model in existing projects.
3. Include a timeline for WasmEdge's support of the Component Model."
docs/embed/rust/complex_data.md,"---
sidebar_position: 4
---

# Pass Complex Data

<!-- prettier-ignore -->
:::info
Work in Progress
:::
 See an example here: <https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-4-1-define-a-host-function-with-string-arguments>
","Based on the provided code, it appears to be a documentation snippet for the Wasmedge Rust SDK. Here is a concise summary of its purpose and functionality:

**Purpose:** This section of the documentation explains how to pass complex data types as arguments in a host function.

**Functionality:**

* The example references another resource (<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-4-1-define-a-host-function-with-string-arguments>) where the concept is demonstrated.
* Although marked as ""Work in Progress,"" it implies that this section will provide guidance on passing complex data types, such as strings.

**Key Components:**

* A reference to another resource with an example implementation.
* A note indicating that the content is a work in progress.

As for potential issues or areas for improvement:

* The lack of concrete information makes it challenging for users to understand how to pass complex data types without referring to external resources.
* Given its marked ""Work in Progress"" status, it may be beneficial to indicate when this section will be completed or provide an estimated completion date.
* Consider adding more context or examples within the documentation to enhance user understanding and make it more self-contained."
i18n/zh/docusaurus-plugin-content-docs/current/embed/rust/complex_data.md,"---
sidebar_position: 4
---

# Pass Complex Data

<!-- prettier-ignore -->
:::info
Work in Progress
:::
 See an example here: <https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-4-1-define-a-host-function-with-string-arguments>
","**Code Summary**

The provided code snippet appears to be a documentation page written in Markdown format, specifically designed for the Docusaurus framework. The purpose of this page is to document how to pass complex data in Rust.

**Key Components:**

1. **Metadata**: The page has a `sidebar_position` metadata set to 4, which likely controls its positioning within the documentation sidebar.
2. **Title and Heading**: The title is ""Pass Complex Data"" and is followed by an info box indicating that this section is currently ""Work in Progress.""
3. **Link to Example Code**: A link is provided to an external GitHub repository containing example code for working with complex data in Rust.

**Functionality**

The page serves as a placeholder or a work-in-progress documentation, directing users to an external resource for an example implementation of passing complex data in Rust.

**Potential Issues/ Areas for Improvement:**

1. **Outdated link**: The provided link might become outdated if the referenced repository or code is modified.
2. **Insufficient information**: This page does not provide any concrete examples or explanations on how to pass complex data, making it less useful as a documentation resource.
3. **Lack of clarity**: Without more context, it's unclear what type of ""complex data"" this refers to, and what the implications are for users looking to implement such functionality.

To address these issues, consider adding more detailed information or examples to this page, updating any links to ensure they remain relevant, and clarifying the scope of complex data being discussed."
docs/embed/data/go.md,"---
sidebar_position: 3
---

# Go Host application with wasmedge-bindgen

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Summary**

This code is a documentation snippet for embedding data in a Go (Golang) host application using wasmedge-bindgen. The purpose of this code is to provide information on how to integrate the wasmedge-bindgen tool into a Go project.

**Key Components**

1. **Language**: The code uses Markdown syntax and appears to be part of a documentation or tutorial.
2. **Tooling**: Wasmedge-bindgen, a tool for generating WebAssembly (WASM) bindings for Go applications, is mentioned.
3. **Content**: A warning label (`Work in Progress`) suggests that the content is still being developed.

**Functionality**

The code serves as an introduction or guide to using wasmedge-bindgen with a Go host application. It likely provides instructions on how to configure and use the tool to generate WASM bindings, making it easier for developers to integrate WebAssembly modules into their Go applications.

**Potential Issues/Areas for Improvement**

1. **Incomplete content**: The ""Work in Progress"" label indicates that the documentation is still being developed. This may lead to confusion or frustration among readers.
2. **Missing context**: Without a clear understanding of the surrounding project structure and setup, new users might find it challenging to follow the instructions provided by this code snippet.

To improve this documentation, consider providing more concrete examples, detailed instructions on setting up the environment, and a clearer explanation of how wasmedge-bindgen is used in the Go host application."
docs/embed/data/rust.md,"---
sidebar_position: 2
---

# Rust Host application with wasmedge-bindgen

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Based on the provided code, I can provide a concise summary of its purpose and functionality. 

**Summary:**
The code snippet appears to be an incomplete documentation page for Rust Host application with wasmedge-bindgen integration.

**Purpose:**
The primary objective is to document the process or guide for creating or using a Rust application that leverages wasmedge-bindgen, which is likely used for building bindings between WebAssembly (WASM) code and the Rust programming language. However, due to the ""Work in Progress"" note, it's clear that this documentation is not yet complete.

**Functionality:**
While there isn't any actual code provided within the snippet, the inclusion of `wasmedge-bindgen` suggests that the documentation will focus on how to use this tool or library for integrating WASM into a Rust application. This may involve explaining how to set up the necessary dependencies, generate bindings from WASM modules, and integrate them into a Rust project.

**Key Components:**
- **Rust Host Application:** The code will likely explain what a Rust Host application is and how it interacts with WASM code.
- **Wasmedge-bindgen:** This is the library or tool that provides the necessary functionality for generating bindings from WASM to Rust. 
- **Documentation Status:** The ""Work in Progress"" status implies that this documentation page is not yet complete, suggesting ongoing development.

**Potential Issues or Areas for Improvement:**
- **Lack of Detailed Information:** Given its current state, the documentation lacks detailed information about how to use `wasmedge-bindgen` effectively.
- **Incomplete Tutorial or Guide:** Without further content, it's challenging to understand how to proceed with creating a Rust application that leverages WASM through `wasmedge-bindgen`.
- **Accuracy and Relevance:** The completeness of the documentation will likely impact its usefulness. Incomplete or outdated information could lead users astray.

Overall, this code snippet indicates the intention to provide documentation on integrating wasmedge-bindgen with a Rust Host application but emphasizes the need for further work to make it comprehensive and useful."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/kubernetes-containerd-runwasi.md,"---
sidebar_position: 3
---

# Kubernetes + Containerd + Runwasi

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Summary**

This Markdown file is part of a documentation project, specifically designed for i18n (internationalization) purposes. It describes how to deploy an application using Kubernetes, Containerd, and RunWASI (WebAssembly System Interface) on the WASI target platform. The document appears to be under development (""Work in Progress"").

**Key Components**

1. **Kubernetes**: A container orchestration system for automating deployment, scaling, and management of containerized applications.
2. **Containerd**: A container runtime that provides a minimal, efficient way to run containers on various platforms.
3. **RunWASI**: An implementation of the WASI API (Application Programming Interface) that allows WebAssembly programs to interact with the host operating system.

**Functionality**

The document likely describes how to:

1. Set up a Kubernetes cluster.
2. Install and configure Containerd as a container runtime on the cluster.
3. Deploy an application using RunWASI on the cluster.

**Potential Issues or Areas for Improvement**

1. **Work in Progress**: The document is marked as ""Work in Progress"", indicating that it may contain incomplete or outdated information. It's essential to verify the accuracy and completeness of the content before sharing it with others.
2. **Platform specificity**: RunWASI is a platform-specific technology, which might limit its applicability on other platforms.
3. **Containerd configuration**: The document may assume specific Containerd configurations, which could lead to errors or inconsistencies if not followed correctly.

**Recommendations**

1. Verify the accuracy and completeness of the content before sharing it with others.
2. Consider adding more details on setting up a Kubernetes cluster and installing Containerd, as these are critical steps in the deployment process.
3. Emphasize platform-specific requirements and configurations to ensure readers understand the scope and limitations of the document."
i18n/zh/docusaurus-plugin-content-docs/current/embed/data/go.md,"---
sidebar_position: 3
---

# Go Host application with wasmedge-bindgen

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Summary**

The provided code is a Markdown file (`go.md`) that appears to be part of a documentation system, likely Docusaurus, used for generating documentation for the `Go Host application with wasmedge-bindgen`. The code defines metadata and content for a specific page in the documentation.

**Key Components**

1. **Metadata**: The first line `sidebar_position: 3` sets the position of this page in the sidebar navigation.
2. **Header**: The `# Go Host application with wasmedge-bindgen` header is the title of the page.
3. **Info Block**: The `:::info Work in Progress :::` block displays an info message indicating that the content is a work-in-progress.

**Purpose**

The purpose of this code is to create a documentation page for the `Go Host application with wasmedge-bindgen`, providing a clear and organized structure for the content.

**Potential Issues or Areas for Improvement**

1. **Outdated Content Warning**: The info block suggests that the content is a work-in-progress, but it's unclear when this will be updated or what changes are being made.
2. **Lack of Context**: Without additional information, it's difficult to understand the specific context and purpose of the `Go Host application with wasmedge-bindgen`.
3. **Limited Navigation**: The sidebar position is set to 3, but without more information on the structure of the documentation, it's unclear what this means in terms of navigation.

To address these areas for improvement, the author could consider adding a clear update schedule or milestone list for the work-in-progress content, providing more context about the purpose and goals of the `Go Host application with wasmedge-bindgen`, and ensuring that the sidebar position aligns with the overall documentation structure."
i18n/zh/docusaurus-plugin-content-docs/current/embed/data/rust.md,"---
sidebar_position: 2
---

# Rust Host application with wasmedge-bindgen

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Here's a concise summary of the provided code:

**Summary**

This is a Markdown file that appears to be part of a documentation system (likely Docusaurus) for a Rust Host application with Wasmedge-Bindgen. The code defines the metadata and structure for this specific document, including its position in the sidebar.

**Key Components**

1. `sidebar_position: 2`: This line specifies the position of the current document in the sidebar, which suggests that it will be displayed as the third item (since positions are likely zero-indexed).
2. `# Rust Host application with wasmedge-bindgen`: This is a Markdown heading that indicates the title of the document.
3. `<!-- prettier-ignore -->`: This is a comment that appears to instruct a code formatter (Prettier) to ignore this line.
4. `:::info`: This is an information box or alert block, indicating that the content below is still work-in-progress.

**Potential Issues/Areas for Improvement**

1. The use of `<!-- prettier-ignore -->` may be unnecessary if the code is not being formatted by Prettier. Consider removing this line to simplify the code.
2. The document status (""Work in Progress"") may not be explicitly mentioned elsewhere in the documentation. Consider adding a more prominent warning or alert to indicate that this content is still under development.

Overall, the provided code appears to be well-structured and clear in its purpose. However, removing unnecessary comments and considering additional warnings for work-in-progress content could further improve the quality of the code."
i18n/zh/docusaurus-plugin-content-docs/current/start/usage/serverless/tencent.md,"---
sidebar_position: 4
---
# 腾讯云上的 WebAssembly 无服务器函数

由于腾讯云的主要用户来自中国，所以本教程是[用中文撰写的](https://my.oschina.net/u/4532842/blog/5172639)。

我们还提供了一个代码模板，用于在腾讯云上部署无服务器的 WebAssembly 函数，请查看 [tencent-scf-wasm-runtime 存储库](https://github.com/second-state/tencent-scf-wasm-runtime)。

Fork 这个存储库并开始编写你自己的 Rust 函数。

","Here is a concise and coherent summary of the provided code:

**Summary**

This Markdown file, titled ""腾讯云上的 WebAssembly 无服务器函数"" (WebAssembly Serverless Functions on Tencent Cloud), is part of a documentation project for Docusaurus. It provides instructions on how to deploy WebAssembly functions on Tencent Cloud's serverless platform using Rust.

**Purpose**

The purpose of this code is to guide users through the process of creating and deploying WebAssembly functions on Tencent Cloud, specifically targeting Chinese-speaking users due to Tencent Cloud's primary user base in China.

**Key Components**

1. **Code template**: The file links to a GitHub repository called ""tencent-scf-wasm-runtime"" that provides a code template for deploying WebAssembly functions on Tencent Cloud.
2. **Rust function development**: Users are encouraged to fork the repository and develop their own Rust functions using this template.

**Potential Issues or Areas for Improvement**

1. **Language barrier**: The documentation is in Chinese, which may create a language barrier for non-Chinese speaking users.
2. **Lack of step-by-step instructions**: While the file provides links to relevant resources, it does not offer explicit step-by-step instructions on how to deploy WebAssembly functions on Tencent Cloud using Rust.

Overall, this code appears to be a helpful resource for Chinese-speaking developers interested in deploying WebAssembly functions on Tencent Cloud using Rust. However, additional documentation and clearer instructions may be needed to make the process more accessible to users with varying levels of technical expertise."
docs/embed/java/intro.md,"---
sidebar_position: 1
---

# WasmEdge Java SDK Introduction

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Code Summary**

The provided code is a Markdown file (`intro.md`) that serves as an introduction to the WasmEdge Java SDK. It appears to be part of a documentation set for the SDK.

**Purpose and Functionality**

The main purpose of this code snippet is to provide a brief overview of the WasmEdge Java SDK, serving as an entry point for developers interested in using the SDK. The code includes:

1. **Sidebar Position**: Sets the position of the current page in the documentation sidebar to 1.
2. **Title and Heading**: Specifies the title and heading of the document, which is ""WasmEdge Java SDK Introduction"".
3. **Informational Note**: Includes a warning label `Work in Progress` using an `info` block, indicating that the content is still under development.

**Key Components**

* Markdown syntax for formatting text
* Use of HTML elements (e.g., `prettier-ignore`, `:::`) to include code snippets and styled text
* YAML front matter for metadata (sidebar position)

**Potential Issues or Areas for Improvement**

* The `Work in Progress` note might be unnecessary if the content is indeed still under development. A clear indication of the document's status can help developers understand its reliability.
* Consider adding a brief summary or overview section to provide more context about the WasmEdge Java SDK and its purpose.

Overall, this code snippet appears to be well-structured and follows standard Markdown conventions. However, incorporating additional details and improving clarity might enhance the overall documentation experience for users."
docs/embed/python/intro.md,"---
sidebar_position: 1
---

# WasmEdge Python SDK Introduction

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Here's a concise and coherent summary of the code:

**Summary**

This is a markdown file that serves as an introduction to the WasmEdge Python SDK. The content is part of a documentation set and is indicated to be ""Work in Progress"".

**Key Components**

* **Sidebar Position**: The `sidebar_position` metadata specifies the position of this page in the sidebar navigation, set to 1.
* **Markdown Content**: The main content of the file is written in markdown format and introduces the WasmEdge Python SDK.

**Functionality**

The purpose of this file appears to be providing an introductory overview of the WasmEdge Python SDK, likely as part of a documentation set or tutorial. The ""Work in Progress"" label suggests that this section may not be complete or up-to-date.

**Potential Issues/Areas for Improvement**

* The ""Work in Progress"" label could be misleading if the content is incomplete or outdated. A more accurate status indicator might be beneficial.
* There are no obvious technical issues with the code, but a review of the surrounding context (i.e., the rest of the documentation set) may reveal additional concerns.

Overall, this is a straightforward markdown file that serves as an introductory page for the WasmEdge Python SDK."
i18n/zh/docusaurus-plugin-content-docs/current/embed/java/intro.md,"---
sidebar_position: 1
---

# WasmEdge Java SDK Introduction

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Here is a concise, coherent summary of the code:

**Summary**

This is an introduction to the WasmEdge Java SDK written in Markdown. The content is currently marked as ""Work in Progress"" and has a specified position (1) within a sidebar.

**Key Components**

* `sidebar_position`: specifies the order of the page within a sidebar.
* `:::info` block: marks the text within as informational or note-worthy, with a red background to draw attention.

**Potential Issues/Areas for Improvement**

None identified. The code is simple and clearly indicates that it is a work in progress."
i18n/zh/docusaurus-plugin-content-docs/current/embed/python/intro.md,"---
sidebar_position: 1
---

# WasmEdge Python SDK Introduction

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Code Summary**

The provided code is a Markdown file (`intro.md`) located in the `i18n/zh/docusaurus-plugin-content-docs/current/embed/python/intro` directory. It appears to be part of a documentation project, specifically for a WasmEdge Python SDK.

**Key Components:**

1. **Sidebar Position**: The first line `sidebar_position: 1` specifies that this document should be displayed in the left sidebar with position 1.
2. **Document Title**: The `# WasmEdge Python SDK Introduction` line indicates the title of the document.
3. **Info Box**: The `:::info` block is a YAML front matter comment indicating that the content within is an ""Info"" box, which is likely used for displaying important information or warnings to readers.

**Purpose:**

The purpose of this code is to introduce the WasmEdge Python SDK and provide relevant context for developers interested in using it. The `Work in Progress` label suggests that the SDK is still being developed and may not be fully stable or functional yet.

**Potential Issues/Areas for Improvement:**

1. **Context Clarity**: While the document title provides some context, it's unclear what specific aspects of the WasmEdge Python SDK are covered in this introduction.
2. **Missing Content**: The `Work in Progress` label implies that there may be a lack of content or information about the SDK in this document.
3. **Consistency**: It would be helpful to ensure consistency across the documentation project, including formatting and styling choices.

By addressing these areas for improvement, the code can become more effective at providing valuable information to developers interested in using the WasmEdge Python SDK."
docs/develop/deploy/oci-runtime/quark.md,"---
sidebar_position: 4
---

# Deploy with quark

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Summary**

The code snippet appears to be a Markdown file (`.md`) that documents the process of deploying an application with Quark. The document is part of a larger documentation set, indicated by the `sidebar_position` and other metadata.

**Purpose**

The purpose of this code is to provide instructions on how to deploy an application using Quark, likely as part of a Kubernetes or container orchestration setup.

**Functionality**

The code does not contain any executable code, but rather provides guidance on the deployment process. However, based on the context and metadata, it's likely that the document will outline steps such as:

* Creating a Quark configuration file
* Building and pushing an image to a registry (e.g., Docker Hub)
* Deploying the application to a Kubernetes cluster or other container runtime environment

**Key Components**

Based on the metadata and context:

* **sidebar_position**: indicates the document's position in the sidebar navigation of the documentation set.
* **quark**: likely refers to the Quark deployment tool or framework being used.

**Potential Issues or Areas for Improvement**

1. **""Work in Progress"" notice**: The use of this notice may indicate that the documentation is incomplete, outdated, or subject to change. It's essential to update the document with accurate information when the work is completed.
2. **Lack of executable code**: As a Markdown file, there is no executable code in this snippet. However, it might be beneficial to provide a basic example or template for users to follow.
3. **Assumed knowledge**: The documentation assumes a level of familiarity with Quark and container deployment concepts. Additional context or explanations may be necessary for new users.

Overall, this code snippet serves as a foundation for the documentation, but further development is needed to create a comprehensive guide for deploying applications using Quark."
docs/embed/witc.md,"---
sidebar_position: 3
---

# Developing components using witc

Work in progress. Please refer to <https://github.com/second-state/witc>.
","Here's a concise summary of the provided code snippet:

**Summary:**

The provided Markdown file serves as documentation for developing components using witc. It is currently marked as ""work in progress"" and advises readers to refer to the official witc repository on GitHub.

**Functionality:**

The file appears to be a placeholder or introduction to the topic of working with witc, pointing users towards more detailed information available elsewhere.

**Key Components:**

1. Markdown syntax for documentation (e.g., `sidebar_position`, headers, and links).
2. A single link to the official GitHub repository for witc.
3. A warning label indicating that the content is work in progress.

**Potential Issues/Areas for Improvement:**

1. **Lack of detailed content:** As the file is currently marked as ""work in progress,"" it's unclear what specific topics or instructions would be included if this documentation were complete.
2. **Unclear purpose:** The file seems to exist solely for linking to an external repository, which may make it unnecessary unless the purpose is to provide a centralized location for related resources.
3. **Minimal value for users:** Without additional content or context, readers may not find this file particularly useful, especially if they are new to witc and looking for introductory information.

To address these issues, I would suggest:

1. **Filling in the gaps:** Provide a comprehensive introduction to witc, explaining its purpose, features, and usage examples.
2. **Making it self-contained:** Include relevant links and resources within the file itself, so readers can find the necessary information without having to leave the documentation.
3. **Clearly defining the scope:** Indicate what topics or aspects of witc are covered (or not) in this documentation, helping users understand its value and limitations."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime/quark.md,"---
sidebar_position: 4
---

# Deploy with quark

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Here's a concise and coherent summary of the code:

**Summary:**

This is a Markdown file named ""quark.md"" in the Docusaurus project, located in the `i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/oci-runtime` directory. The file contains documentation on deploying with Quark.

**Key Components:**

1. **Sidebar Position**: The file specifies a sidebar position of 4, which determines its placement within the documentation tree.
2. **Document Title**: The document title is ""Deploy with quark"".
3. **Warning Tag**: A warning tag `:::info` is used to indicate that the content is still a work in progress.

**Purpose and Functionality:**

This file serves as a placeholder for future documentation on deploying with Quark, an Oracle Cloud Infrastructure (OCI) runtime. The content is currently empty, awaiting updates to provide guidance on the deployment process.

**Potential Issues or Areas for Improvement:**

1. **Lack of Content**: As mentioned earlier, this file lacks actual content on deploying with Quark.
2. **Incomplete Documentation**: Without proper documentation, users may struggle to understand the deployment process, which can lead to frustration and wasted time.
3. **Outdated Status Indication**: The ""Work in Progress"" tag might become outdated if the document is updated but still doesn't provide comprehensive information.

To address these concerns, it's essential to update this file with accurate and comprehensive documentation on deploying with Quark, ensuring that users have a clear understanding of the process."
i18n/zh/docusaurus-plugin-content-docs/current/embed/witc.md,"---
sidebar_position: 3
---

# Developing components using witc

Work in progress. Please refer to <https://github.com/second-state/witc>.
","**Summary:**

This code snippet is a Markdown file located in the `i18n/zh/docusaurus-plugin-content-docs/current/embed` directory. It appears to be part of a documentation site, likely generated using Docusaurus.

**Purpose:** The purpose of this file is to provide an introduction or overview of developing components using witc (Work-in-Progress). It includes a link to the original GitHub repository for further information.

**Functionality:**

* The Markdown document contains a heading (`# Developing components using witc`) and a brief text that describes its work-in-progress status.
* A link is provided to direct users to the original GitHub repository for more detailed information.

**Key Components:**

* `sidebar_position`: This line specifies the position of this page in the documentation sidebar, which will be rendered accordingly.
* Link to the external resource (GitHub repository): This link provides a direct reference to the source material for those interested in learning more about witc.

**Potential Issues/Improvements:**

1. **Content**: As mentioned, the text is work-in-progress, which may indicate that this documentation section is incomplete or not up-to-date.
2. **Link Maintenance**: If the GitHub repository moves or becomes outdated, the link provided might break. Consider maintaining an active link to a stable resource or version control system like GitLab or Bitbucket.
3. **Additional Guidance**: To improve user experience, it would be beneficial to provide more context about what witc is, its benefits, and why users should care about it.

Overall, this code snippet seems to be a placeholder or draft documentation for an ongoing project. To enhance the value of this content, consider revising and refining it with relevant information and examples related to witc."
docs/develop/c/networking.md,"---
sidebar_position: 2
---

# Networking Socket

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Based on the provided code snippet, here is a concise and coherent summary:

**Purpose:** The provided code is a documentation snippet for a networking-related topic, specifically focusing on ""Networking Socket"".

**Key Components:**

* A heading with the title ""Networking Socket""
* An informational block indicating that this section is still a work-in-progress
* Prettier ignores, which are used to prevent formatting issues

**Functionality:** This code serves as a placeholder for future documentation content related to networking sockets. It provides an indication of its status and warns readers to expect updates.

**Potential Issues:**

1. **Work-in-Progress Status**: The fact that this section is still under development might lead to incomplete or outdated information, which could confuse or mislead users.
2. **Lack of Context**: Without additional surrounding text or links to related topics, this snippet may not be immediately clear or useful to readers who are seeking information on networking sockets.

**Suggestions for Improvement:**

1. **Add More Information**: Provide more context and details about what is being documented under ""Networking Socket"". This could include a brief introduction, an explanation of the topic, and possibly links to relevant resources.
2. **Schedule Completion**: Establish a clear deadline or schedule for completing this section, so readers can plan when they might expect it to be updated with useful information.
3. **Link to Relevant Topics**: Provide links to related topics or documentation sections that offer more in-depth explanations of networking-related concepts, making the content more navigable and helpful."
docs/embed/rust/reference.md,"---
sidebar_position: 7
---

# API Reference

Check out [the `wasmedge-sdk` crate](https://crates.io/crates/wasmedge-sdk) for more information.
","Based on the provided code snippet, here is a concise summary of its purpose, functionality, and key components:

**Summary**: The code is part of an API reference documentation for the `wasmedge-sdk` crate.

**Purpose**: To provide a brief introduction to the `wasmedge-sdk` crate and direct users to the official crate page on crates.io for more information.

**Functionality**: The code serves as a placeholder or table of contents entry, linking to the external resource with detailed documentation about the crate.

**Key Components**:

1. **Anchor text**: ""API Reference""
2. **Link**: A link to the `wasmedge-sdk` crate page on crates.io
3. **External resource**: The actual crate documentation and information

**Potential Issues/Areas for Improvement**: None identified in this specific code snippet. However, it's essential to ensure that the linked external resource remains up-to-date and accurate.

In general, when working with API reference documentation, consider the following best practices:

1. Ensure links are active and point to relevant resources.
2. Use clear and concise anchor text to help users navigate the documentation.
3. Regularly review and update API references as the underlying codebase or crate evolves.

This analysis highlights that this particular code snippet serves as a straightforward link to external documentation, with no complexities or areas for improvement in its own right."
i18n/zh/docusaurus-plugin-content-docs/current/develop/c/networking.md,"---
sidebar_position: 2
---

# Networking Socket

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Summary:**

The code snippet appears to be a Markdown file, likely part of a documentation project, specifically Docusaurus. The file is titled ""Networking Socket"" and has a `sidebar_position` value set to 2. It contains a warning indicating that the content is still a work in progress.

**Functionality:**

This file serves as a placeholder or a stub for documenting a section on Networking Sockets. The purpose of this file seems to be providing an empty template for future content creators to fill in, while also giving a heads-up to users that this specific topic is not yet fully developed.

**Key Components:**

1. **Metadata**: `sidebar_position` is set to 2, which likely determines the position of this documentation page within the sidebar navigation.
2. **Markdown Content**: The file contains basic Markdown formatting and some placeholder text (the ""Work in Progress"" message).

**Potential Issues or Areas for Improvement:**

1. **Lack of meaningful content**: This file does not contain any substantial information about Networking Sockets, making it less useful to users who are looking for documentation on this topic.
2. **Insufficient warning**: While the ""Work in Progress"" message is a good start, it might be more effective if the warning was clearer or more prominent, e.g., with an alarm icon or a more explicit statement about the content being incomplete.

**Recommendations:**

1. Fill in the documentation for Networking Sockets to make this page more useful.
2. Consider adding a more prominent warning or placeholder text to indicate that the content is still work in progress.
3. Review and revise the Markdown formatting and content structure to ensure consistency with other documentation pages."
i18n/zh/docusaurus-plugin-content-docs/current/embed/rust/reference.md,"---
sidebar_position: 7
---

# API Reference

Check out [the `wasmedge-sdk` crate](https://crates.io/crates/wasmedge-sdk) for more information.
","**Code Analysis Summary**

This is a Markdown file (`reference.md`) in the `i18n/zh/docusaurus-plugin-content-docs/current/embed/rust/reference` directory. The purpose of this file is to provide an API reference for Rust programming language.

**Key Components:**

1. **Sidebar Position:** The code specifies that the current page should be positioned at index 7 in the sidebar (`sidebar_position: 7`).
2. **API Reference Title:** The main title of the document is ""API Reference"".
3. **External Link:** There is a link to the `wasmedge-sdk` crate on crates.io for users who want more information about the API.

**Potential Issues or Areas for Improvement:**

1. **Lack of Content:** The current implementation only provides a brief title and an external link. A detailed API reference with descriptions, examples, and usage guides would be beneficial to users.
2. **Redundancy:** If the `wasmedge-sdk` crate is already linked elsewhere in the project, this redundancy might not be necessary.

**Recommendations:**

1. Expand on the API reference content to provide more information for developers.
2. Consider adding a table of contents or a list of APIs covered in the reference for better navigation.
3. Ensure that links and dependencies are up-to-date and correctly implemented to avoid potential errors."
docs/contribute/fuzzing.md,"---
sidebar_position: 5
---

# Fuzzing

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Based on the provided code snippet, here is a summary of its purpose, functionality, and key components:

**Summary**: This markdown document appears to be an incomplete contribution guideline for fuzzing in the project's documentation. The title suggests that fuzzing is a topic being worked on and not yet fully fleshed out.

**Functionality**: There doesn't seem to be any functional code provided; instead, it looks like a placeholder or a work-in-progress note.

**Key Components**:

* A markdown heading indicating the position of this document in the project's sidebar (sidebar_position: 5).
* An `info` box containing a warning label for ""Work in Progress"".
* The `prettier-ignore` directive, which is likely used to prevent prettier formatting from being applied to specific lines or sections of code.

**Potential Issues/ Areas for Improvement**:

* There is no actual content related to fuzzing provided; the file appears to be incomplete.
* The ""Work in Progress"" note might be misleading, as it implies that there's a tangible contribution process waiting to be documented.
* Without more context about the project or the specific requirements of the contribution guidelines, it's challenging to provide a thorough analysis."
docs/contribute/test.md,"---
sidebar_position: 4
---

# Testing

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Code Analysis Summary**

The provided code snippet appears to be a Markdown file named `test.md` located in the `docs/contribute` directory. Here's a breakdown of its purpose and functionality:

* **Purpose**: The file is intended for documenting testing procedures, likely for contributing or developing code.
* **Functionality**: There is no actual code written in this file; it only contains metadata and formatting information.

**Key Components**

1. `sidebar_position: 4`: This line specifies the position of the sidebar navigation for the page generated from this Markdown file.
2. `# Testing`: This heading indicates that the content will be related to testing procedures.
3. `<!-- prettier-ignore -->`: This comment is likely used by a code formatter (Prettier) to ignore formatting rules for the following lines.

**Potential Issues or Areas for Improvement**

* The file seems incomplete, with a ""Work in Progress"" label indicating that more content needs to be added.
* There are no actual testing procedures documented in this file.
* Consider reorganizing or splitting long files like this into smaller ones for better maintainability and clarity."
docs/develop/c/threads.md,"---
sidebar_position: 3
---

# Thread

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Here is a concise and coherent summary of the code:

**Summary**

The provided code snippet appears to be a documentation section for a ""Thread"" topic in an online knowledge base or wiki. It consists of a title (""Thread""), a heading level indicator (#), and a brief warning message that the content is still being worked on (<!-- prettier-ignore -->:::info Work in Progress:::).

**Key Components**

* Title: ""Thread""
* Heading level: ""#""
* Warning message: ""<!-- prettier-ignore -->:::info Work in Progress:::""

**Potential Issues or Areas for Improvement**

1. **Lack of content**: The documentation section is currently empty, which may make it difficult for readers to understand the topic.
2. **Outdated warning message**: Although the warning message indicates that the content is still being worked on, it is unclear what ""Work in Progress"" means in this context. Consider updating or removing it once the content is finalized.
3. **Missing organization structure**: Without any subheadings or clear sections, the documentation may feel disorganized and difficult to navigate. Consider adding more headings or separating related topics.

**Recommendations**

1. **Add content**: Fill out the documentation section with relevant information about threads, such as their definition, use cases, and examples.
2. **Update warning message (if necessary)**: Remove or update the ""Work in Progress"" warning once the content is finalized to avoid confusing readers.
3. **Organize content**: Break down the documentation into clear sections and subheadings to make it easier for readers to navigate."
docs/develop/deploy/kubernetes/openfunction.md,"---
sidebar_position: 9
---

# OpenFunction

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Here is a concise summary of the code:

**Summary**

The provided code snippet appears to be a section from an open-source documentation file (openfunction.md) for OpenFunction, a platform that allows developers to deploy serverless functions. The section is titled ""OpenFunction"" and has a position in the sidebar set to 9.

**Key Components**

1. **Metadata**: The code includes metadata such as `sidebar_position: 9`, which suggests it's part of a documentation hierarchy.
2. **Warning/Info block**: The code includes an info block with the text ""Work in Progress"", indicating that this section is currently being developed or updated.

**Purpose and Functionality**

This code snippet appears to be a placeholder or a notice for developers, indicating that the OpenFunction documentation is still under development. There is no functional code or configuration provided in this snippet.

**Potential Issues or Areas for Improvement**

1. **Incomplete Documentation**: The fact that it's marked as ""Work in Progress"" suggests that the documentation might not yet be comprehensive or accurate.
2. **Missing Content**: This section seems to be a placeholder, but the actual content related to OpenFunction is missing.

Please provide more context if you would like me to analyze any further code snippets from this file."
docs/embed/rust/asyncfy.md,"---
sidebar_position: 6
---

# Asyncfy

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Summary**

The provided code is a Markdown file (`asyncfy.md`) that appears to be part of an online documentation or tutorial series. It introduces the concept of ""Asyncfy"" and marks it as a ""Work in Progress"".

**Purpose and Functionality**

Based on the title and surrounding content, Asyncfy seems to be a tool or feature that allows users to transform synchronous code into asynchronous versions. The purpose is likely to provide a way to write more efficient, concurrent code in languages that support asynchronous programming.

**Key Components**

None are explicitly mentioned in this code snippet. However, based on the context, some possible components of Asyncfy might include:

* A transformation engine or algorithm for converting synchronous code into asynchronous versions
* Support for various programming languages and frameworks (e.g., Rust, JavaScript)
* Integration with existing libraries or tools to enhance performance

**Potential Issues and Areas for Improvement**

1. **Ambiguity around Asyncfy's purpose**: While the concept of transforming synchronous code into asynchronous versions is interesting, more context and examples would be helpful to understand its value proposition.
2. **Limited documentation**: The ""Work in Progress"" label suggests that the project is still under development. Consider adding more information on its features, benefits, and roadmap to keep users engaged.
3. **Lack of code snippets or examples**: To help users better understand how Asyncfy works, consider including short examples or code snippets illustrating its usage.

By addressing these concerns, the documentation for Asyncfy can become more comprehensive, user-friendly, and effective in promoting this innovative tool."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/fuzzing.md,"---
sidebar_position: 5
---

# Fuzzing

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Code Analysis Summary**

This is a markdown file (`fuzzing.md`) located in the Docusaurus plugin's documentation directory. Here's a summary of its purpose and functionality:

**Purpose:** This document appears to be an introductory guide on Fuzzing, a software testing technique that involves providing invalid or unexpected inputs to a program to test its behavior.

**Functionality:** The file contains a brief note indicating that the content is still a ""Work in Progress"". It also includes a prettier-ignore directive, which suggests that the formatting of this section may need special attention during code review.

**Key Components:**

1. **sidebar_position**: This line sets the position of the current document within the sidebar navigation.
2. **:::info...:::**: This is an info box containing a brief message indicating that the content is still under development.

**Potential Issues or Areas for Improvement:**

* The ""Work in Progress"" label may not be sufficient to indicate that the content is incomplete or inaccurate. Consider adding more explicit warnings or disclaimers.
* The use of prettier-ignore directives should be used judiciously and only when necessary, as it can make the code harder to read and review.

Overall, this markdown file appears to be a basic placeholder for future content on Fuzzing. Its purpose is clear, but its functionality is currently limited."
i18n/zh/docusaurus-plugin-content-docs/current/contribute/test.md,"---
sidebar_position: 4
---

# Testing

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Summary**

The provided code is a Markdown file (`test.md`) located in the `i18n/zh/docusaurus-plugin-content-docs/current/contribute/test` directory. This file appears to be part of a documentation system, likely Docusaurus.

**Purpose and Functionality**

This file serves as a test or example document, marked with a ""Work in Progress"" note using Markdown syntax and an HTML-like info box component (`:::info`). The file also contains metadata in the first line, specifying the position of the sidebar.

**Key Components**

1. **Metadata**: `sidebar_position: 4` - specifies the position of the sidebar for this document.
2. **Markdown content**: The actual text content of the file is minimal, indicating that it's a test or placeholder page.
3. **Info box component**: `:::info` - used to mark the ""Work in Progress"" note.

**Potential Issues or Areas for Improvement**

1. **Empty content**: This document contains very little content, making it unclear what the purpose of this file is, beyond being a placeholder.
2. **Lack of context**: Without more information about the surrounding documentation and project requirements, it's difficult to determine if this file serves any specific purpose or if it can be safely removed.

In general, having an empty test document like this one might not provide much value unless it's used as a template for future documentation or testing purposes. In that case, it would be beneficial to provide more guidance on its intended use and potential next steps."
i18n/zh/docusaurus-plugin-content-docs/current/develop/c/threads.md,"---
sidebar_position: 3
---

# Thread

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","**Code Summary**

The provided code is a Markdown file for a documentation page in a Docusaurus project. It appears to be part of the `i18n/zh/docusaurus-plugin-content-docs` module, which suggests that it's a translation of an English version from this path.

**Functionality**

This code creates a new document with the following features:

1. **Sidebar Position**: The page will have a sidebar position of 3.
2. **Title**: The title of the page is ""Thread"".
3. **Warning Message**: A warning message is displayed at the top of the page, indicating that this content is still in progress (work-in-progress).

**Key Components**

1. **Front Matter**: The code begins with a YAML front matter section (`---`), which contains metadata for the document.
2. **Markdown Content**: The rest of the file contains Markdown-formatted text, including headings and warning messages.

**Potential Issues or Areas for Improvement**

1. **Missing content**: Although this is a work-in-progress page, it's expected to have some placeholder content or an outline to guide the development process. This is currently missing.
2. **Improper use of Docusaurus features**: The `sidebar_position` directive should be placed in a YAML front matter section with proper formatting (e.g., indentation)."
i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/kubernetes/openfunction.md,"---
sidebar_position: 9
---

# OpenFunction

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Here is a concise summary of the provided code:

**Summary**

This markdown file appears to be part of a documentation project, likely for a website or knowledge base. The file describes the topic ""OpenFunction"" and has been assigned a position (9) in the sidebar.

**Key Components**

1. **Metadata**: The first line `---` indicates metadata that is not visible in the rendered markdown text.
2. **Sidebar Position**: The line `sidebar_position: 9` specifies the position of this page in the sidebar navigation.
3. **Title and Heading**: The title ""OpenFunction"" is displayed as a heading (H1) on the page.
4. **Status Indicator**: The warning icon `:::info` indicates that this content is still a work-in-progress.

**Potential Issues or Areas for Improvement**

None apparent in this code snippet. However, based on the context, it's likely that this file will need to be expanded with more content and possibly additional metadata (e.g., tags) as development progresses.

Please let me know if you'd like me to analyze any specific aspects of this code further!"
i18n/zh/docusaurus-plugin-content-docs/current/embed/rust/asyncfy.md,"---
sidebar_position: 6
---

# Asyncfy

<!-- prettier-ignore -->
:::info
Work in Progress
:::
","Here is a concise and coherent summary of the code:

**Summary:**

This is an Markdown document (`.md` file) for Docusaurus, a documentation platform. The document appears to be part of a series on asynchronous programming in Rust.

**Key Components:**

1. **sidebar_position**: This line sets the position of the document in the sidebar navigation of the documentation site, with a value of `6`.
2. **Title and Tag**: The title of the document is ""Asyncfy"", and it has an informational tag indicating that it's a work-in-progress.
3. **Content**: There is no actual content in this file, only a placeholder comment suggesting that it's currently under development.

**Potential Issues or Areas for Improvement:**

1. **Missing content**: As mentioned earlier, the file is empty except for the title and tag. This suggests that the document has not been fully implemented yet.
2. **Inconsistent formatting**: The use of `<!-- prettier-ignore -->` is a directive to disable Prettier's formatting for this line, which might be inconsistent with other parts of the documentation.

Overall, this code appears to be a placeholder or a starting point for further development, and it does not provide any concrete functionality."
docs/embed/rust/function.md,"---
sidebar_position: 3
---

# Embed WASM Functions and Async Functions

<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-4-define-and-register-a-host-function>

<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-5-define-and-register-async-host-functions>
","**Summary:**

The provided code snippet is part of the documentation for embedding WASM (WebAssembly) functions and async functions using the Wasmedge Rust SDK. The code demonstrates how to define and register host functions, as well as async host functions, which are essential components of building a web application that interacts with native code.

**Key Components:**

1. **Host Functions**: These are Rust functions that can be called from WASM code, enabling the interaction between the web application and native code.
2. **Async Host Functions**: Similar to host functions, but designed for asynchronous operations. They allow the web application to perform tasks in the background while maintaining responsiveness.

**Functionality:**

The code shows how to:

1. Define a new host function using the `#[no_mangle]` attribute, which makes the function callable from WASM.
2. Register the host function with Wasmedge using the `wasm_host_function` macro.
3. Define an async host function using the `async fn` syntax and the `#[wasmedge::main]` attribute to specify its entry point.
4. Register the async host function with Wasmedge.

**Potential Issues or Areas for Improvement:**

1. **Error Handling**: The code does not demonstrate how to handle errors that may occur during function execution or registration. Proper error handling is essential in production environments.
2. **Function Signatures**: The examples use simple function signatures, but in a real-world scenario, you might need to consider more complex signatures, such as functions with multiple parameters or return types.
3. **Performance Optimizations**: Depending on the specific requirements of your web application, you may need to optimize the performance of the embedded WASM code and host functions.

Overall, this code snippet provides a solid foundation for understanding how to embed WASM functions and async functions using the Wasmedge Rust SDK. However, it is essential to consider additional factors, such as error handling, function signatures, and performance optimizations, when building production-ready applications."
i18n/zh/docusaurus-plugin-content-docs/current/embed/rust/function.md,"---
sidebar_position: 3
---

# Embed WASM Functions and Async Functions

<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-4-define-and-register-a-host-function>

<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-5-define-and-register-async-host-functions>
","**Summary**

This Markdown file appears to be part of a documentation system for Docusaurus, a popular open-source static site generator. The content is related to embedding WebAssembly (WASM) functions and asynchronous functions using the Wasmedge-RustSDK library.

**Functionality**

The code provides links to external GitHub repositories that contain examples on how to:

1. Define and register a host function in WASM.
2. Define and register an async host function in WASM.

These examples are likely used as references or tutorials for developers interested in working with Wasmedge-RustSDK.

**Key Components**

* Markdown formatting, including headings (# Embed WASM Functions and Async Functions) and links to external resources (<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-4-define-and-register-a-host-function>).
* Links to Wasmedge-RustSDK library examples on GitHub.
* No code is provided in this file; it serves as a reference or pointer to external resources.

**Potential Issues/Areas for Improvement**

1. **Lack of context**: Without additional information, readers may not understand the purpose or context behind the links provided.
2. **No executable code**: The file does not contain any code examples that could be used for learning or reference purposes.
3. **Outdated links**: If the external resources referenced are moved or updated, the links in this file would become outdated.

To improve this file, consider adding more context, providing inline code examples, and regularly verifying the accuracy of linked resources."
CODE_OF_CONDUCT.md,"# WasmEdge Code of Conduct

See the Code of Conduct [here](https://github.com/WasmEdge/WasmEdge/blob/master/docs/CODE_OF_CONDUCT.md).
","Based on the provided code snippet from `CODE_OF_CONDUCT.md`, here is a summary of the code:

**Purpose:** The purpose of this code is to provide a link to the WasmEdge Code of Conduct document.

**Functionality:**

* The code provides an anchor link (#) with the title ""WasmEdge Code of Conduct"" that redirects users to the specified URL.
* The URL points to a separate Markdown file (`CODE_OF_CONDUCT.md`) located in the `docs` directory within the WasmEdge repository on GitHub.

**Key components:**

* A header with the title ""WasmEdge Code of Conduct""
* An anchor link (#) with the same title
* A hyperlink ([here](https://github.com/WasmEdge/WasmEdge/blob/master/docs/CODE_OF_CONDUCT.md)) to the Code of Conduct document

**Potential issues or areas for improvement:**

* The code assumes that the Code of Conduct document exists at a specific location in the repository, which might change in the future. It would be better to make the link more flexible or dynamic.
* The use of an absolute URL (https://github.com/WasmEdge/WasmEdge/blob/master/docs/CODE_OF_CONDUCT.md) might not be ideal for all users (e.g., those behind a corporate firewall). Consider providing both the GitHub-specific URL and a more general alternative."
docs/embed/rust/ai.md,"---
sidebar_position: 5
---

# AI Inference with Pytorch
","Based on the provided code snippet, it appears to be a Markdown document that serves as an introduction to AI Inference with PyTorch. Here is a concise summary of its purpose, functionality, and key components:

**Summary:**

This document is intended to provide an overview of using PyTorch for AI inference. The content will likely cover the basics of PyTorch, its application in AI inference, and possibly provide examples or tutorials on how to use it.

**Key Components:**

1. **Sidebar Position**: The `sidebar_position` metadata is set to 5, which suggests that this document will be placed at position 5 within a sidebar.
2. **Document Title**: The title of the document is ""AI Inference with Pytorch"".

**Potential Issues or Areas for Improvement:**

1. **Lack of Content**: Since the provided code snippet only includes metadata and a title, it's likely that the actual content of this document has not been included in the provided snippet.
2. **Unclear Purpose**: Without more information about the specific AI inference tasks that will be covered in this document, its purpose may be unclear to readers who are unfamiliar with PyTorch.

**Suggested Improvements:**

1. **Add more detailed content**: Include examples, tutorials, or explanations of how to use PyTorch for AI inference.
2. **Provide clear instructions on usage**: Make sure that the document provides a clear guide on how to apply the concepts and techniques discussed in the document.
3. **Consider adding a table of contents or index**: A well-organized structure would make it easier for readers to navigate the content of this document."
docs/embed/rust/app.md,"---
sidebar_position: 2
---

# Embed WASM Apps

<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-1-run-a-wasm-app-from-host>
","Summary:

The provided code snippet is a Markdown document that serves as an example of how to embed WebAssembly (WASM) applications in the browser using Rust and WASMedge. The document appears to be part of a larger documentation set, and this specific section explains how to run a WASM app from a host.

Purpose:

* To provide an example of embedding a WASM app using Rust and WASMedge
* To serve as a guide for developers on how to achieve this task

Functionality:

* The code snippet likely includes steps or instructions for setting up the project, compiling the Rust code, and loading the WASM app in the browser.
* It may also include links to external resources (such as GitHub repositories) for further information.

Key Components:

* WASMedge: A runtime environment for running WASM applications
* Rust: A programming language used for developing the WASM app
* WASM app: The application that will be embedded and run in the browser

Potential Issues or Areas for Improvement:

* The code snippet appears to be incomplete, as it only provides a link to an external resource. It would be more helpful if the actual code or instructions were included.
* There is no indication of how the WASM app is packaged or loaded into the browser. Additional information on this process might be necessary for developers to successfully embed the app.
* The documentation does not provide any information on debugging or troubleshooting techniques, which could be useful for developers encountering issues with embedding the app."
i18n/zh/docusaurus-plugin-content-docs/current/embed/rust/ai.md,"---
sidebar_position: 5
---

# AI Inference with Pytorch
","Based on the provided code, here is a summary of its purpose, functionality, and key components:

**Purpose:** The code defines a documentation page for AI Inference with PyTorch.

**Functionality:**

* The page is placed at position 5 in the sidebar.
* It is part of a larger documentation project that uses Docusaurus as the static site generator.

**Key Components:**

* `sidebar_position`: A metadata field that determines the position of the page in the sidebar.
* Markdown content: The code contains Markdown-formatted text, which will be rendered as HTML in the documentation site."
i18n/zh/docusaurus-plugin-content-docs/current/embed/rust/app.md,"---
sidebar_position: 2
---

# Embed WASM Apps

<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-1-run-a-wasm-app-from-host>
","**Summary**

This is a Markdown file (`app.md`) that appears to be part of a documentation system for a Docusaurus plugin. The purpose of this file is to document how to embed WASM (WebAssembly) apps, specifically using the Rust programming language and the `wasmedge-rustsdk` library.

**Functionality**

The code snippet provides a link to an external resource (`README.md`) on GitHub, which contains examples for running a WASM app from a host. The file itself does not contain any executable code but serves as a documentation anchor point in the Docusaurus sidebar, indicating that this topic is located at position 2.

**Key Components**

1. **Metadata**: The first two lines (`sidebar_position: 2`) are metadata that define the document's position in the Docusaurus sidebar.
2. **Heading**: The `# Embed WASM Apps` heading serves as a title for the document.
3. **Link**: The `<https://github...>` link points to an external resource containing additional information on running WASM apps.

**Potential Issues or Areas for Improvement**

1. **Missing content**: The current file does not contain any useful content, making it unnecessary in its current form.
2. **Orphaned links**: If the linked GitHub repository is deleted or its URL changes, this document will become broken.
3. **Duplicated information**: Depending on the context of the Docusaurus plugin, it might be better to include a brief summary or example code within this file instead of relying solely on an external link.

**Recommendations**

1. Remove redundant metadata and focus on providing valuable content within the Markdown file.
2. Consider including a brief description or an example to make this document more informative.
3. Ensure that the linked resource remains up-to-date and accessible."
